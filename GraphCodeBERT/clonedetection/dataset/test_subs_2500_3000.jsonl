{"id1": "12128591", "id2": "481364", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"hash": [" Hash", "hex", " address", "update", "dump", " fingerprint", " text", "h", " key", "id", "print", " body", " salt", " hashing", " h", " check", "code", " sum", " mac", " code", "Hash", " id", " message", " signature", " equals", " version"], "data": ["info", "what", "secret", "ata", "table", "mu", "DATA", "any", "a", "batch", "raw", "block", "value", "message", "buffer", "image", "sequence", "this", "password", "content", "out", "padding", "action", "window", "rel", "output", "dat", "string", "input", "json", "html", "bytes", "hello", "text", "command", "result", "accept"], "digest": ["digse", " digave", "mailgest", "deist", "digave", "deest", "Digse", "Digested", "redest", "initest", "redester", " digist", "digested", "mdest", "mailest", "displayested", "digester", "mdgest", "mailester", "digests", "equave", "deested", "equit", "mdests", "Digests", "initEST", "initested", "displayse", "mdit", "redgest", "initester", "mdested", "DigEST", "digly", " digit", "redly", "mdave", "Digist", " digested", "diggest", " digse", "mdse", "displayest", "displayests", "equest", "dese", " digEST", "digist", "mdester", "mailly", "Digest", "Digester", "mdly", "digEST", "equse", " digester", "digit"]}}
{"id1": "6871529", "id2": "21010945", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "label": 0, "substitutes": {"readUrlFile": ["readURLPage", "readURLFile", "readurlfile", "readPathFile", "readUrlPage", " readURLfile", " readUrlStream", "readurlFile", " readURLFile", "readURLStream", " readURLPage", "readURLfile", "readPathStream", "readPathPage", "readUrlStream", "readPathfile", "readurlStream", "readUrlfile", " readURLStream", "readurlPage", " readUrlfile", " readUrlPage"], "fullUrl": [" fullURL", "FullUr", "pathUr", "FullRoute", "FullURL", "partialPath", "Fullurl", "partialRoute", "completeurl", "fulUrl", "fulRoute", "fullUr", "FullName", "partialUrl", "fullPath", "fulURL", " fullurl", "completeUrl", " fullName", "fulurl", "pathUrl", "fullName", "FullUrl", "fullurl", "fullRoute", "pathURL", "completeURL", " fullPath", "partialURL", "fullURL", "pathName", "partialurl", "completePath", " fullUr"], "out": ["pretty", "os", "t", "w", "b", "table", "c", "us", "ch", "o", "ws", "aos", "it", "client", "p", "writer", "s", "to", "outs", "print", "report", "io", "log", "flush", "write", "n", "res", "output", "txt", "Out", "screen", "nt", "ou", "json", "file", "OUT", "msg", "net"], "url": ["bel", "ur", "oul", "http", "link", "b", "path", "ref", "ls", "base", "build", "client", "resource", "l", "uri", "f", "sl", "r", "nl", "git", "service", "conn", "str", "rel", "mount", "sb", "google", "ssl", "char", "Url", "web", "mail", "ul", "config", "file", "ll", "dl", "job", "open", "URL", "browser"], "encoding": ["Encoded", "ENCoder", "Encoding", "coded", "rcoding", "ENCoded", "encapping", "rcoded", "ENCapping", "caching", "Encryption", "coding", "ENCoding", "encoded", "rcryption", "Encapping", "capping", "cryption", "encoder", "Encaching", "encryption", "coder", "encaching", "rcaching", "Encoder"], "in": ["gin", "info", "m", "sql", " din", "stream", "cin", "inf", "inn", "ind", "id", "er", "ins", "l", "rin", "f", "io", "reader", "r", "source", "user", "IN", "from", "inner", "bin", "conf", "input", "din", "body", "sum", "inside", "i", "el", "file", "data", "and", "In"]}}
{"id1": "13946197", "id2": "20939940", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"transformByMD5": [" encryptByMD5", " encryptBymd5", " encryptByMD4", " encryptByMC4", " encryptBymd4", " encryptByMDTime", " encryptbymd7", " encryptBySMTime", " encryptByMCTime", " encryptByMC5", " encryptbymdTime", " encryptBymd7", " encryptBySM4", " encryptbyMD4", " encryptbyMD7", " encryptByMC7", " encryptbyMD5", " encryptByMD7", " encryptbymd4", " encryptBySM5", " encryptbymd5", " encryptBySM7", " encryptBymdTime", " encryptbyMDTime"], "password": ["pass", " passwords", "secret", "email", "phrase", "w", "Password", "security", "path", "username", "prefix", "value", "address", "name", "message", "filename", "sword", "login", "account", "padding", "user", "pattern", "token", "word", "database", "hash", "PASS", "description", "data", "command", "entry", "hello", "key", "wd", "text", "auth", " Password"], "md5": [" MD3", "MD3", "mag2", "md3", "mdnt", "dig2", "mdhed", "MD5", "md10", "mand5", " mdnt", " mdle", "MDhed", " mdhed", " MD2", " md7", "MD7", "md2", "mag3", "dig3", "maghed", "MD10", "mand2", " MD5", " MDnt", " md3", "mand3", "mag5", "MD2", "md7", " md10", "MDle", " MD7", " MDle", "MDnt", " md2", "mdle", "dig5", "mand10"], "output": ["answer", "PUT", "echo", "successful", "column", "exit", "document", "batch", "Output", "line", "block", "results", "four", "accept", " outputs", "list", "message", "buffer", "log", "print", "hidden", "write", "put", "out", "source", "respond", "console", "csv", "export", "all", "input", "current", "outer", " Output", "STDOUT", "ou", "web", "OU", "data", "view", "file", "response", "remote", "display", "text", "result", "collection"], "bufferPass": ["BufferPASS", "bufferAdd", "screenAss", "screenPassword", "screenPass", "sequenceAdd", "bufferSe", " bufferAdd", " bufferpass", "bufferAss", "bufferEn", "sequencePass", "batchPassword", "bufDe", "batchPass", "bufPass", " bufferPassword", " bufferEn", "bufPASS", "memorySe", " bufferSe", "memoryDe", "BufferPass", " bufferCat", " bufferPASS", "bufSe", "BufferPassword", "bufferCat", "Bufferpass", " bufferDe", "bufferPassword", " bufferAss", "bufpass", "batchpass", "sequencePassword", "bufferpass", "memoryEn", "bufCat", "bufferPASS", "screenAdd", "memoryPass", "sequenceAss", "BufferCat", "bufEn", "bufferDe"], "b": ["bar", "m", "bt", "u", "bg", "wb", "z", "w", "bs", "j", "c", "bit", "o", "h", "a", "batch", "base", "be", "e", "block", "bb", "ib", "B", "buffer", "v", "p", "bool", "fb", "y", "l", "bound", "k", "emb", "r", "mb", "blue", "gb", "n", "g", "bi", "sb", "rb", "bp", "i", "db", "ob", "cb", "bis", "nb", "bc", "d"]}}
{"id1": "5061606", "id2": "18974466", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNacessesar", "createSettingsIfNacessesible", "createSettingsIfNecessible", "createSettingsIfNacessary", "createSettingsIfNeccesed", "createSettingsIfNecessesary", "createSettingsIfNeccesible", "createSettingsIfNeccessed", "createSettingsIfNeccessible", "createSettingsIfNeccesary", "createSettingsIfNecessesible", "createSettingsIfNeccesar", "createSettingsIfNacessible", "createSettingsIfNeccessar", "createSettingsIfNeccessary", "createSettingsIfNacessesary", "createSettingsIfNacessar", "createSettingsIfNecessesed", "createSettingsIfNecessesar", "createSettingsIfNacessesed", "createSettingsIfNecessed", "createSettingsIfNacessed", "createSettingsIfNecessar"], "out": ["cn", "os", "that", "go", "null", "t", "exit", "gc", "w", "ent", "note", "err", "end", "ion", "ot", "ch", "writer", "o", "up", "aos", "it", "cho", "on", "or", "oe", "list", "client", "yes", "bo", "obj", "can", "to", "outs", "report", "flush", "io", "f", "log", "off", "print", "write", "conn", "one", "n", "res", "output", "ex", "timeout", "Out", "init", "con", "again", "server", "nt", "outer", "conv", "ou", "oss", "inv", "sys", "OU", "comment", "file", "OUT", "co", "max", "ne", "cos", "net"], "fSettings": ["sfSettings", "sfsettings", "sfOptions", " fsettings", "esettings", " fSetup", " fChanges", "cfSettings", "bfChanges", " fSetting", "finalSetting", "eSetting", "bfSetting", "fChanges", " fOptions", "fsettings", "finalOptions", "fOptions", "bfsettings", "eSettings", "sfSetup", "cfSetup", "bfSettings", "fSetup", "sfSetting", "hSettings", "cfsettings", "fSetting", "hsettings", "finalsettings", "hSetting", "sfChanges", "cfSetting", "finalSettings"], "src": ["sit", "rt", "ur", "sc", "upload", "fn", "attr", "rc", "cont", "syn", "pkg", "url", "ls", "desc", "ser", "sq", "resource", "spec", "rl", "sf", "cur", "source", "th", "rel", "txt", "rs", "sb", "rx", "dest", "img", "sr", "tmp", "root", "config", "sys", "view", "loc", "filename", "dir"], "in": ["gin", "info", "ad", "vin", " din", "cin", "inf", "inn", "id", "ins", "l", "rin", "r", "source", "n", "ln", "IN", "from", "iter", "init", "en", "bin", "isin", "inner", "input", "sin", "din", "i", "inside", "is", "and", "In"]}}
{"id1": "12004824", "id2": "8069594", "code1": "    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) {\n        HttpResponse response = null;\n        try {\n            HttpParams httpParams = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParams, maxTime);\n            HttpConnectionParams.setSoTimeout(httpParams, maxTime);\n            httpclient = new DefaultHttpClient(httpParams);\n            response = httpclient.execute(httpRequest);\n            maxTime = 15000;\n        } catch (Exception e) {\n        }\n        return response;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"executeHttpRequest": ["executeHTTPPost", "execHttpQuery", "executeSingleRequest", "execHttpPost", "execHTTPCommand", "execHttpCommand", "execHTTPRequest", "executeHttpQuery", "executeHTTPCommand", "executeWebRequest", "executeHttpPost", "executeSingleCommand", "execHTTPQuery", "execHttpRequest", "executeWebCommand", "executeHTTPQuery", "executeWebPost", "executeHTTPRequest", "executeWebQuery", "executeHttpCommand", "executeSinglePost", "executeSingleQuery", "execHTTPPost"], "httpRequest": ["httpsCommand", "ttpResponse", "httpEvent", "HTTPResponse", "httpCall", " httpCommand", "htmlCommand", "httpsEvent", " httpResponse", "htmlEvent", "ttpCommand", " httpCall", "HTTPCall", "htmlRequest", "httpCommand", "httpsResponse", "HTTPCommand", "httpResponse", "httpsRequest", "htmlResponse", "ttpCall", " httpEvent", "ttpRequest", "HTTPRequest"], "response": ["answer", "exit", "resp", "document", "object", "onse", "default", "value", "message", "connection", "image", "sequence", "yes", "report", "print", "content", "service", "out", "request", "respond", "unknown", "example", "application", "res", "respons", "output", "tree", "reply", "instance", "Response", "body", "next", "json", "relation", "xml", "description", "data", "model", "view", "hello", "entry", "display", "result"], "httpParams": ["hparars", "httpAttams", "httpPars", "httpparcs", " HTTPParamps", "httpPms", "httpparms", "httpPards", "HttpParam", "httpParparams", "httpParcs", "httpPyars", "httpParars", "httpParamps", "httppards", "hParams", " httpParparams", "httpPamps", "httpPARparams", "httpparamb", "hParam", " HTTPPyamps", " httpparamb", " HTTPParms", "httpparars", "httpParms", "httpSpeams", "httpAttcs", "httpParamamb", "hParars", "httpPARams", "HttpParcs", "httpParamb", "httpPargs", "httpParam", "httpPyams", " HTTPPyams", " httpParamb", " HTTPPyms", "httpPARgs", "hparam", " httpparams", "httpSpeam", "httpAttans", "httpparam", "httpParamams", "httpParans", "httpParamgs", "httpPyms", "httpPARamb", "httpPams", "httpparparams", "httpparams", " HTTPParars", "HttpParams", "HttpParans", "httpSpears", " httpPargs", "hparams", "httpparamps", "httppargs", " httppargs", "httpParamparams", "hpards", "hPards", "httpPyamps", "httpSpeds", "httpparans", " HTTPPyars", " httpparparams", " HTTPParams", "httpAttam"], "httpclient": ["webclient", "webconnection", "htmlClient", "htmlclient", "webconn", "httpcontroller", "httpconnection", "blockclient", "htmlserver", "httpClient", "webserver", "blockconnection", "httpsclient", "webClient", "httpserver", "htmlcontroller", "blockconn", "httpsconnection", "httpsconn", "httpsserver", "webcontroller", "blockClient", "httpscontroller", "httpsClient", "httpconn"], "maxTime": ["maxWait", "MaxWait", "maxTimes", "MAXTimeout", "minWait", "minTimeout", "MAXTime", "minSize", "MaxTimeout", " maxWait", " maxSize", "minTime", "MaxTimes", "MAXWait", "maxSize", " maxTimes", "MaxTime", "maxTimeout", "MAXTimes", " maxTimeout", "MaxSize"]}}
{"id1": "9805906", "id2": "15445861", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"dump": ["info", " describe", "send", "zip", "read", "update", "link", "diff", " println", "store", " show", "flush", "print", "write", "debug", "init", "copy", "stat", "export", "save", "show", "display", " dumps", "println", " debug", "download", " dumped", "load"], "source": ["info", "src", "sql", "sample", "SOURCE", "se", "scope", "parent", "check", "store", "sequence", "resource", "image", "spec", "service", "select", "ource", "site", "from", "local", "start", "iter", "init", "origin", "copy", "search", "ie", "style", "template", "input", "java", "config", "sys", "Source", "form", "script", "file", "view", "remote", "ink", "text", "shell"], "target": ["project", "that", "null", "t", "goal", "link", "mac", "table", "gt", "tif", "host", "top", "base", "compatible", "it", "delete", "arg", "to", "Target", "term", "test", "bolt", "output", "local", "replace", "copy", "dest", "pattern", "template", "style", "current", "proxy", "next", "arget", "file", "match"], "is": ["sis", "ms", "isl", "im", "in", "ii", "ls", "ios", "lis", "has", "it", "its", "isi", "tis", "isc", "es", "iss", "ib", "ists", "ins", "s", "ic", "mos", "isf", "bits", "ai", "ois", "ir", "ist", "iris", "nis", "ip", "act", "init", "isin", "si", "ics", "ri", "ris", "ys", "iso", "xs", "oss", "i", "abs", "sys", "Is", "IS", "ais", "ar", "ims", "bis", "isa", "are"], "os": ["Os", "ants", "ox", "ros", "pos", "bs", "oses", "ot", "o", "ls", "css", "ios", "aos", "ss", "osi", "or", "ost", "oS", "es", "ns", "oes", "uts", "ts", "cs", "ose", "ows", "s", "outs", "mos", "io", "js", "fs", "los", "ols", "oos", "ds", "bos", "oss", "sys", "nos", "OS", "cos", "dos", "ps", "obs"], "done": ["failed", "later", "finished", "progress", "ished", "Done", "du", "pleted", "started", "desc", "shown", "di", "valid", "found", " Done", "enabled", "flag", "seen", "created", "only", "needed", "did", "de", "die", "given", "disabled", "set", "expected", "dirty", "gone", "led", "continue", "checked", "ded", "des", "filled", "made", " continued", "loaded", "complete", "d"]}}
{"id1": "20019847", "id2": "10158738", "code1": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" CopyFile", " CopyFiles", " cpStream", " cpfile", " CopyStream", "copyfile", " cpFiles", "Copyfile", "CopyFiles", "copyFiles", " Copyfile", "copyStream", "CopyStream", " cpFile", "CopyFile"], "source": ["ace", "src", "sql", "details", "sample", "SOURCE", "archive", "base", "se", "it", "scope", "space", "check", "parent", "store", "ce", "name", "sequence", "resource", "spec", "seed", "service", "ource", "site", "from", "start", "init", "origin", "copy", "search", "string", "style", "template", "input", "query", "config", "Source", "scene", "file", "subject", "view", "size", "format", "filename", "series"], "target": ["join", "project", "that", "t", "stop", "goal", "link", "mac", "tif", "gt", "table", "get", "top", "base", "it", "parent", "delete", "check", "arg", "resource", "to", "Target", "print", "test", "bolt", "output", "replace", "touch", "copy", "dest", "pattern", "template", "alias", "next", "arget", "file", "match", "result"], "in": ["gin", "info", "re", "im", " din", "up", "cin", "it", "inf", "inn", "ind", "internal", "id", "client", "ain", "ins", "ic", "rin", "inc", "ai", "al", "from", "iter", "IN", "init", "en", "bin", "isin", "inner", "con", "input", "sin", "din", "inside", "i", "is", "ar", "In"], "out": ["cn", "t", "b", "gt", "c", "ot", "ch", "o", "up", "aos", "it", "on", "or", "client", "v", "can", "to", "l", "outs", "io", "by", "conn", "n", "g", "cmd", "user", "output", "ex", "Out", "en", "con", "nt", "ou", "i", "at", "sys", "auto", "msg", "OUT", "co", "channel", "ne", "and", "result", "net"]}}
{"id1": "3330775", "id2": "11546108", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getJSONData": ["loadjsonData", "loadJSONObject", "getJResponse", "getBasicObject", "getjsonContent", "getJSONObject", "getjsonObject", "getJData", "getBasicData", "getJSONResponse", "loadJSONData", "getBasicResponse", "loadjsonContent", "getJContent", "loadjsonObject", "loadJSONContent", "getjsonData", "loadJSONResponse", "getJSONContent", "getBasicContent", "getJObject", "getjsonResponse", "loadjsonResponse"], "url": ["ret", "pl", "item", "ur", "http", "link", "b", "href", "path", "ls", "host", "util", "base", "lim", "address", "id", "name", "l", "log", "sl", "nl", "str", "rel", "location", "string", "ssl", "pattern", "json", "Url", "i", "web", "ul", "addr", "file", "loc", "ll", "remote", "dl", "URL", "result"], "jObject": ["jsonNull", "objObj", "jsonData", "jObj", " jObj", "reportData", "jsonObject", "reportObj", " jNull", "reportDocument", "jData", "objObject", " jobject", "jDocument", "jobject", " jAnonymous", "jAnonymous", "jsonAnonymous", "jpNull", "jpobject", "jpObject", "jsonObj", "jpAnonymous", "jsonobject", "objDocument", " jDocument", "jsonDocument", "reportObject", "objData", " jData", "jNull"], "data": ["details", "api", "ad", "feed", "ata", "sample", "done", "mu", "DATA", "stream", "raw", "results", "aw", "block", "value", "trans", "or", "media", "error", "name", "message", "buffer", "image", "resource", "sequence", "content", "cache", "source", "window", "no", "output", "dat", "dev", "string", "input", "area", "body", "session", "json", "html", "bytes", "size", "ne", "text", "result"], "httpClient": [" httpclient", "httpsContext", "ttpclient", " httpControl", "HttpContext", "ttpContext", "httpsControl", "HttpGet", "httpsclient", "ttpClient", "HttpBuilder", "httpContext", "HttpClient", "Httpclient", "httpBuilder", "httpclient", "ttpGet", "HttpControl", "httpsBuilder", "httpsGet", "httpsClient", " httpBuilder", "httpControl"], "uri": ["domain", "ur", "u", "api", "http", "URI", "phi", "link", "archive", "qi", " URI", "path", "ref", "du", "util", "range", "base", "pi", "host", "lu", " ur", "ui", "cp", "address", "hi", "client", "connection", "resource", "directory", "hu", "uu", "term", "iri", "source", "nu", "hub", "ip", "location", "origin", "ri", "char", "server", "point", "i", "Url", "via", "manager", "ilo", "subject", "remote", "uni", "qu", "URL"], "httpGet": [" httpGET", "HTTPQuery", "hGET", "HTTPGET", " httpQuery", "hGate", "httpGate", "htmlGate", "HTTPGet", "htmlGET", "hGet", "httpPut", "hQuery", "htmlPut", " httpPut", "httpGET", " httpGate", "htmlQuery", "HTTPPut", "htmlGet", "httpQuery"], "response": ["answer", "successful", "pos", "http", "opening", "resp", "document", "object", "onse", "success", "version", "block", "socket", "client", "connection", "message", "image", "resource", "yes", "context", "report", "service", "request", "respond", "still", "application", "output", "page", "reply", "server", "Response", "body", "next", "json", "frame", "description", "hello", "remote", "resolution", "status", "result"], "line": ["LINE", "row", "column", "phrase", "link", "sample", "eline", "key", "inline", " Line", "e", "block", "ice", "part", "liner", "error", "cell", "name", "message", "Line", "sequence", "l", "log", "print", "nl", "number", "code", "ln", "user", "stroke", "entity", "lin", "page", "word", "next", "point", "frame", "comment", "header", "file", "online", "entry", "len", "ine", "label", "text", "chain", "status", "field"], "builder": ["bar", "join", "full", "row", "ener", "built", "b", "length", "atter", " builders", "alph", "upper", "bean", "oster", "base", "lu", "building", "board", "build", "name", "fb", "black", "buffer", "message", "writer", "uf", "er", "library", "control", "by", "sf", "number", "ender", "order", "Builder", "ward", "utils", "sb", "language", "lower", "inner", "operator", "der", "eng", "web", "trace", "BU", "builders", "parser", "loader"], "reader": ["dd", "record", "row", " read", "older", "per", "read", "handler", "where", "rar", "ner", "dra", "util", "range", "driver", "stream", "e", "roller", "worker", "peer", "iterator", "oder", "message", "buffer", "writer", "er", "runner", "bo", "wrapper", "r", "readable", "rl", "ro", "iter", "Reader", "dr", "inner", "ri", "ger", "river", " readers", "reading", "parser", "entry", "field", "loader", "ator", " writer", "mr"]}}
{"id1": "1769771", "id2": "4599372", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " CopyFiles", " copyStream", " copyLine", " CopyStream", "CopyLine", " copyFiles", "CopyFiles", "copyLine", " CopyLine", "copyFiles", "copyStream", "CopyStream", "CopyFile"], "in": ["gin", "b", "old", "up", "cin", "on", "ini", "inf", "inn", "ind", "ins", "l", "rin", "ic", "io", "r", "inc", "source", " input", "IN", "from", "mm", "init", "en", "isin", "bin", "inner", "input", "din", "i", "el", "is", "In"], "out": ["os", "t", "err", "w", "update", "po", "b", "gt", "c", "ot", "o", "up", "it", "v", "help", "p", "s", "to", "outs", "log", "l", "io", "op", "n", "res", "output", "ex", "Out", "nt", "ou", "at", "file", "OUT", "msg", "serv", "net"], "inChannel": ["inchannel", "inButton", "inCommand", "inConnection", "intChan", "InCommand", "cinChannel", " inCase", "dinConnection", " inCategory", "insideScope", "sinCase", "ainChannel", " inchannel", "sinChannel", "cinCommand", "sinRoom", "innCase", "intChannel", "inCategory", " inChan", "intchannel", "sinButton", " inConnection", "innButton", "outConnection", "insideClient", "intCommand", "sinClient", "inScope", " inButton", "sinCommand", "ainCategory", " inCommand", "dinchannel", "inCase", "dinChan", "outchannel", "inClient", " inRoom", "inRoom", "insideCategory", "innClient", "ainClient", "cinRoom", "InChan", "outChan", "dinChannel", " inScope", "innChannel", "Inchannel", "ainScope", "inChan", "insideChannel", " inClient", "InChannel"], "outChannel": ["outCh", "inchannel", "outputManager", "outGate", "parentGate", "outMany", "outSection", "aosMember", "cnManager", "aosChannel", "neChannel", "blockChannel", "inMember", "cnChannel", "neChan", "outputCh", " outCh", "neMember", "inSection", "outputChan", "aosChan", " outManager", "outManager", "aosSection", "inCh", "parentChan", "neSection", "parentChannel", " outMany", "outchannel", "parentMany", "cnChan", "blockGate", "outputChannel", "blockMany", "outputchannel", "blockChan", " outChan", " outchannel", "outChan", "inChan", " outGate", "outMember"]}}
{"id1": "9275622", "id2": "11484416", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", " cpStream", " duplicatefile", " cpfile", " copyfile", " duplicateFiles", "copyfile", " cpFiles", " copyFiles", " duplicateStream", " duplicateFile", "copyFiles", "copyStream", " cpFile"], "_file1": ["_files1", "_filesOne", "_ileFirst", "_File2", "_ile1", "_files2", "_FileOne", "_fileInit", "_ile2", "_link2", "_linkInit", "_ileOne", "_FileInit", "_ileInit", "_File1", "_link1", "_FileFirst", "_filesFirst", "_fileOne", "_linkOne", "_fileFirst"], "_file2": ["_FILE02", "_fileb", " _FILE2", " _File2", " _File1", "_FILEb", "_FILE1", "_File2", "_image2", "_filetwo", "_linkTwo", "_File02", "_FILE2", " _fileTwo", " _FileTwo", "_linktwo", " _Filetwo", "_link2", "_imageb", " _FILE1", "_file02", "_Filetwo", "_FileTwo", "_Fileb", "_File1", "_image02", "_link1", " _filetwo", " _FILE02", " _file02", " _fileb", "_image1", " _FILEb", "_fileTwo"], "fis": ["Fos", "kais", "cfis", "flis", "cis", "cais", "cfris", "Fris", " fios", "fliss", "fiss", " fris", "cfiss", "fais", "cfois", "flios", "kis", "ufi", " fiss", "fios", "ufios", "qiss", "fli", "Fios", "ufiss", "Fiss", "kios", "qos", "fois", "Fois", "qios", "ufis", "Fis", "fi", "kos", " fi", "qis", " fais", "fris", "cos", " fois", "cios"], "fos": ["mows", "foes", "sfose", " foes", " fows", "flis", "fows", "sfos", "flos", "maos", "wos", "floes", "wows", "ffoes", "hoes", "waos", "mos", "woss", "floss", "fose", "hose", "sfoes", "faos", " foss", "ffos", "hoss", "ffis", "wis", "hos", "foss", " fose", "woes", "sfoss", " faos", "ffoss", "moes"], "canalFuente": ["canalfuent", "canalKuje", "canallFuenza", "canallfuje", "canallfueree", "canallFuent", "canalKuperor", "canalKuente", "canallFuperor", "canalFient", "canallFuestro", "canallFueree", "canalTenent", "canalfuenza", "canalFuje", "canalFalperor", "canalTenperor", "canalFaleree", "canalfueree", "canallFuente", "canalfuestro", "canalKuent", "canalFuestro", "canalfuente", "canalFalente", "canallfuperor", "canalUtestro", "canalFueree", "canallfuente", "canalFiente", "canalFienza", "canalTenenza", "canalFuent", "canalUtent", "canallfuestro", "canalfuperor", "canalFiperor", "canalFalestro", "canalUteree", "canalTenente", "canallfuenza", "canalFuenza", "canalUtente", "canallFuje", "canalFuperor", "canalFalent", "canallfuent", "canalFalje", "canalfuje"]}}
{"id1": "9796161", "id2": "11968328", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD2", "toMD5", "getmd5", "getmd4", "getSHA7", "getMD4", "getMD7", "toMD4", "getmd2", "getmd7", "toSHA7", "getSHA5", "toSHA2", "toMD7", "toMD2", "getSHA4", "getSHA2", "toSHA5", "toSHA4"], "s": ["src", "ms", "sql", "os", "t", "bs", "b", "aws", "c", "h", "ws", "ls", "ss", "its", " gets", "space", "es", "sq", "ns", "ies", "ts", "p", "v", "y", "ins", "l", "f", "ses", "str", "ats", "n", "js", "sv", "S", "gs", "source", "fs", "g", "rs", "sb", "sts", "string", "xs", "ends", "i", "abs", "bytes", "data", "strings", "is", "gets", "text", "ps"], "m": ["perm", "mod", "ms", "mut", "mac", "mu", "managed", "mk", "mc", "hm", "h", "pm", "mi", "fm", "e", "nm", "bm", "rm", "v", "y", "md", "mt", "l", "M", "mask", "sm", "g", "me", "em", "dm", "mm", "om", "am", "man", "gm", "rem", "manager", "cm", "vm", "tm", "made", "mo", "mr"]}}
{"id1": "7087108", "id2": "4164833", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"doGet": ["invokeSet", " handleGET", "invokeget", " handleget", " handleGet", "doGET", " handleSet", "doSet", " doget", "doget", " doGET", " doSet", "invokeGet", "invokeGET"], "request": ["info", "project", "re", "QUEST", "forward", "each", "http", "setup", "document", "url", "get", "reference", "raw", "version", "quest", "worker", "store", "address", "client", "question", "message", "the", "change", "post", "context", "reset", "report", "call", "req", "begin", "enter", "transform", "select", "application", "construct", "controller", "order", "local", "create", "relative", "search", "input", "position", "core", "instance", "server", "index", "query", "first", "remove", "frame", "xml", "model", "initial", "requ", "Request", "hello", "subject", "open", "handle", "command", "complete", "attribute", " Request"], "response": ["os", "re", "http", "resp", "onse", "default", "success", "ce", "message", "context", "image", "connection", "report", "print", "write", "out", "respond", "one", "application", "res", "respons", "output", "page", "reply", "render", "server", "Response", "body", "next", "frame", "description", "xml", "view", "status", "result"], "path": ["full", "project", "hex", "text", "ath", "dir", "where", "pkg", "url", "base", "prefix", "value", "check", "system", "name", "p", "uri", "print", "log", "patch", "temp", "route", "transform", "th", "select", "mount", "test", "output", "location", "relative", "title", "string", "pattern", "template", "dest", "query", "Path", "config", "key", "filename", "chain", "prop", "PATH"], "file": ["full", "bar", "File", "null", "upload", "ile", "binary", "FILE", "disk", "link", "run", "table", "document", "rule", "object", "base", "be", "e", "valid", "check", "fe", "name", "port", "resource", "bo", "image", "to", "library", "bool", "f", "spec", "report", "source", "console", "user", "output", "local", "page", "tree", "load", "real", "word", "le", "relation", "mail", "db", "form", "model", "view", "chain", "channel", "job", "lock", "key", "ca", "filename", "handle", "result"], "in": ["gin", "pic", "read", "sample", "thin", " din", "mc", "up", "cin", "it", "on", "or", "ini", "inn", "ind", "mn", "ins", "s", "l", "rin", "ic", "reader", "kin", "inc", "out", "al", "source", "one", "IN", "mm", "copy", "en", "bin", "isin", "inner", "ck", "con", "input", "again", "sin", "din", "asin", "sum", "i", "cm", "as", "is", "and", "In"]}}
{"id1": "13122204", "id2": "14502142", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnarchiveModule", "UnarchiveModel", "unzipModule", "unlatemodel", "unzipImage", "Unzipmodel", "UnzipModel", "unzipmodel", "unarchiveModel", "uncodeModel", "unarchiveImage", "unlateModel", "uncodeModule", "uncodeImage", "unarchiveModule", "UnarchiveImage", "UnzipModule", "Unarchivemodel", "uncodemodel", "unlateModule", "unlateImage", "UnzipImage", "unarchivemodel"], "filename": ["sql", "ivo", "FILE", "fn", "mson", "jpg", "FN", "fp", "journal", "path", "dra", "FIL", "username", "SourceFile", "nm", "fle", "name", "nil", "directory", "ename", "nl", "source", "stem", "n", "ln", "txt", "output", "location", "origin", "title", "original", "til", "kl", "river", "fil", "wl", "println", "file", "Filename", "subject", "download"], "tempdir": ["tmpdir", " tempfile", "tmpfolder", "Tempfile", "testpath", "tempdirectory", "testfolder", "tempDir", "temdir", "temDIR", " tempDIR", "tempDIR", " tempDir", "testdir", "temdirectory", "tempfile", "temppath", "tmpdirectory", "tempath", "temfolder", "tmpfile", "Tempdirectory", "tmpDIR", "tempfolder", " tempdirectory", "tmppath", "TempDir", "temDir", "testDir", "Tempdir", "tmpDir"], "dest": ["src", "null", "pos", "send", "Dest", "table", "cont", "document", "default", "stream", "desc", "trans", "parent", "store", "tail", "peer", "slave", "decl", "coord", "dc", "buffer", "port", "generated", "rest", "master", "obj", "writer", "temp", "out", "dist", "write", "source", "test", "st", "output", "ctr", "dat", "dev", "origin", "bin", "deep", "usr", "tr", "nt", "tmp", "nom", "pipe", "target", "inv", "sum", "ptr", "des", "foreign", "loc", "est", "display", "comb", "result", "del"], "fis": ["fjs", "fatis", "flis", "lis", "zatis", "flos", "zi", "fljs", "zjs", "ifatis", "flatis", "los", "zos", "ifos", "fli", "ifis", "li", "fi", "ifi", "ljs"], "BUFFER": ["BBER", "BUBuffer", "BAULT", "MAXFFER", "CUBuffer", "LOCKBuffer", "MAXOUNT", " BUOUNT", " BUULT", "BABER", "BufferBER", "LOCKBER", "BOUNT", "BAFFER", "BLBuffer", "MAXBuffer", "BufferBuffer", "BufferMT", "LOCKFR", "CUFR", "FFERMT", "BAOUNT", " BUFR", "BUBER", "LOCKFFER", "FFERBuffer", " BUBER", "BufferFFER", "BUMT", "BUOUNT", "BLOUNT", "FFERFFER", " BUMT", "BFFER", " BUBuffer", "BUFR", "FFERBER", "MAXBER", "BLBER", "BUULT", "BLFFER", "CUFFER", "CUBER", "BULT"], "zis": [" zris", "fip", "zip", "zeis", "xos", "ozip", " zIS", " zos", "zeos", "xis", "zies", "zi", "fiss", "ozis", "zoneris", " zi", "zees", "Zos", "zios", "Zis", " zip", "ozi", "zIS", "zeIS", "ziis", "zeris", "zoneits", "zos", "Zi", "zris", "zoneis", "Ziss", "ziss", "zits", "zoneiss", "xiss", "zes", "ziIS", " zes", "xi", " zits", "zeiss", "oziss", "fi", " ziss", "zeits"], "entry": ["record", "row", "item", "zip", "link", "Entry", "existent", "table", "jo", "piece", "se", "e", "or", "part", "way", "ce", "system", "cell", "connection", "ze", "image", "zo", "name", "log", "element", "enter", "member", "card", "source", "je", "pe", "jar", "inter", "ie", "def", "word", "char", "nt", "index", "ry", "comment", "escape", "match", "chain", "file", "header", "key", "ent", "result"], "count": ["OUNT", "counter", "z", "read", "cloud", "length", "total", "c", "cont", "amount", "Count", "batch", "base", "add", "acc", "found", "part", "check", "common", "cc", "ct", "cond", "cell", "ce", "buffer", "call", "f", "cache", "number", "n", "code", "ount", "child", "ctr", "start", "page", "all", "current", "core", "nt", "num", "index", "sum", "force", "comment", "size", "match", "len", "max", "nb"], "data": ["ata", "sample", "table", "done", "zero", "DATA", "batch", "raw", "results", "value", "part", "valid", "accept", "message", "ATA", "image", "buffer", "p", "content", "dec", "cache", "out", "str", "n", "window", "rel", "output", "step", "dat", " DATA", "all", "area", "next", "mat", "bytes", "size", "dl", "format", "text", "result", "d"], "fos": ["lOS", "voes", "foes", "Fos", " foes", "fOS", "voses", "Foes", " fios", "loss", "Foss", " foses", "los", "Foses", "fios", " foss", " fOS", "voss", "Fios", "vos", "foss", "foses", "lios", "FOS"]}}
{"id1": "4686922", "id2": "7351534", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResources2Files", "extractResourceTofile", "extractResourceAsStream", "extractResourceFromFile", "extractResourceFromFiles", "extractResourceToFiles", "extractResource2Files", "extractResource2Stream", "extractResourceAsFiles", "extractResourceFromfile", "extractResources2File", "extractResourceToStream", "extractResources2Stream", "extractResourcesToFile", "extractResource2File", "extractResourcesToFiles", "extractResourcesToStream", "extractResourceAsFile", "extractResourceFromStream", "extractResources2file", "extractResource2file", "extractResourceAsfile", "extractResourcesTofile"], "resourcePath": ["templateIn", "attributePath", " resourcepath", "templateName", "templatePath", " resourceIn", "uriUrl", "resourceName", "resourceLocation", "Resourcepath", "attributeLocation", "ResourceIn", "ResourcePath", "uriPath", "attributeUrl", "ResourceName", "uriName", "resourcepath", "templatepath", "resourceUrl", "attributeName", "uriLocation", "resourceIn", "ResourceLocation", "ResourceUrl", " resourceName"], "dest": ["src", "null", "orig", "w", "Dest", "opt", "cont", "end", "desc", "trans", "mem", "parent", "home", "sp", "decl", "coord", "this", "rest", "to", "temp", "dist", "source", "output", "good", "cat", "gov", "etc", "origin", "dat", "img", "tmp", "target", "nom", "lit", "des", "loc", "self", "comb", "prop", "result", "dir"], "in": ["gin", "m", "re", " din", "mc", "mi", "up", "cin", "it", "on", "raw", "or", "none", "ini", "inf", "inn", "ind", "id", "resource", "ins", "l", "rin", "f", "r", "inc", "al", "source", "ln", "no", "IN", "from", "iter", "local", "init", "isin", "bin", "inner", "all", "con", "input", "conf", "sin", "din", "i", "inside", "file", "is", "ne", "In"], "out": ["os", "cn", "null", "t", "note", "w", "exit", "b", "ot", "ch", "o", "aos", "na", "it", "on", "client", "v", "writer", "can", "obj", "to", "outs", "print", "f", "io", "stable", "cache", "write", "n", "res", "no", "output", "Out", "en", "inner", "con", "again", "nt", "conv", "tmp", "outer", "ou", "oss", "i", "at", "sys", "pool", " Out", "OUT", "co", "ne", "cos", "col", "net"]}}
{"id1": "9275622", "id2": "18696387", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", " cpStream", " duplicatefile", " cpfile", " copyfile", " duplicateFiles", "copyfile", " cpFiles", " copyFiles", " duplicateStream", " duplicateFile", "copyFiles", "copyStream", " cpFile"], "_file1": ["_files1", "_filesOne", "_ileFirst", "_File2", "_ile1", "_files2", "_FileOne", "_fileInit", "_ile2", "_link2", "_linkInit", "_ileOne", "_FileInit", "_ileInit", "_File1", "_link1", "_FileFirst", "_filesFirst", "_fileOne", "_linkOne", "_fileFirst"], "_file2": ["_FILE02", "_fileb", " _FILE2", " _File2", " _File1", "_FILEb", "_FILE1", "_File2", "_image2", "_filetwo", "_linkTwo", "_File02", "_FILE2", " _fileTwo", " _FileTwo", "_linktwo", " _Filetwo", "_link2", "_imageb", " _FILE1", "_file02", "_Filetwo", "_FileTwo", "_Fileb", "_File1", "_image02", "_link1", " _filetwo", " _FILE02", " _file02", " _fileb", "_image1", " _FILEb", "_fileTwo"], "fis": ["Fos", "kais", "cfis", "flis", "cis", "cais", "cfris", "Fris", " fios", "fliss", "fiss", " fris", "cfiss", "fais", "cfois", "flios", "kis", "ufi", " fiss", "fios", "ufios", "qiss", "fli", "Fios", "ufiss", "Fiss", "kios", "qos", "fois", "Fois", "qios", "ufis", "Fis", "fi", "kos", " fi", "qis", " fais", "fris", "cos", " fois", "cios"], "fos": ["mows", "foes", "sfose", " foes", " fows", "flis", "fows", "sfos", "flos", "maos", "wos", "floes", "wows", "ffoes", "hoes", "waos", "mos", "woss", "floss", "fose", "hose", "sfoes", "faos", " foss", "ffos", "hoss", "ffis", "wis", "hos", "foss", " fose", "woes", "sfoss", " faos", "ffoss", "moes"], "canalFuente": ["canalfuent", "canalKuje", "canallFuenza", "canallfuje", "canallfueree", "canallFuent", "canalKuperor", "canalKuente", "canallFuperor", "canalFient", "canallFuestro", "canallFueree", "canalTenent", "canalfuenza", "canalFuje", "canalFalperor", "canalTenperor", "canalFaleree", "canalfueree", "canallFuente", "canalfuestro", "canalKuent", "canalFuestro", "canalfuente", "canalFalente", "canallfuperor", "canalUtestro", "canalFueree", "canallfuente", "canalFiente", "canalFienza", "canalTenenza", "canalFuent", "canalUtent", "canallfuestro", "canalfuperor", "canalFiperor", "canalFalestro", "canalUteree", "canalTenente", "canallfuenza", "canalFuenza", "canalUtente", "canallFuje", "canalFuperor", "canalFalent", "canallfuent", "canalFalje", "canalfuje"]}}
{"id1": "3558512", "id2": "12306305", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["initialization", " serializer", "initialized", "serialization", "Serialate", "erialate", "serialized", "erialized", "serialate", "Serialze", "Serializer", "serialze", "finalize", "finalization", "Serialization", " serialate", "Serialize", "Serialized", "finalze", " serialized", "finalized", "initialize", "erialize", "initialze", "serializer", "erializer"], "out": ["os", "t", "err", "w", "b", "c", "ch", "o", "a", "up", "stream", "aos", "it", "p", "v", "to", "outs", "report", "log", "io", "f", "sw", "n", "res", "output", " OUT", "Out", "sum", "ou", "i", "pool", "OU", "file", "OUT", "serv", "result", "d"], "parser": ["asser", "processor", "parse", "per", "handler", "pkg", "util", "base", "tar", "tp", "worker", "part", "rer", "peer", "jack", "now", "ker", "p", "writer", "er", "password", "bank", "reader", "Parser", "proc", "loader", "magic", "lp", "plan", "language", "inner", "tree", "style", "token", "instance", "ger", "walker", "arser", "manager", "aser", "xml", "file", "layer", "policy", "format", "ler", "job", "command", "builder"], "on_disk": ["On2Disk", " on_dis", "on_disc", " on_file", "On2disk", "on_dis", "on_Disk", "on2Disk", "on_cloud", " on_Disk", " on_disc", "on2file", "on2link", "on_volume", "on_file", "On_link", "On_Disk", "On2link", "On_cloud", " on_download", "On2file", "on_download", "On_disk", "on_link", "on2disk", "On_file", " on_volume"], "in": ["gin", "ad", "vin", " IN", " din", "mi", "cin", "it", "on", "inf", "inn", "ind", "id", "ain", "min", "ins", "rin", "io", "r", "inc", "IN", "from", "en", "bin", "inner", "isin", "input", "sin", "din", "body", "i", "inside", "is", "and", "In"]}}
{"id1": "22366505", "id2": "6008635", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"incluir": ["incluiier", "inCLUar", "incluiator", "inclUier", "inclUar", "incluar", "incluiar", "inCLuier", "inCLUier", "inclouar", "inclouier", "inclUator", "inclUir", "inCLuir", "incluator", "inCLuar", "inCLUator", "inclouir", "inclouator", "incluier", "inCLUir", "inCLuator", "incluiir"], "igreja": [" iggreva", "iggreva", "iggreje", " iggrej", " igcrej", " igreje", "igopenja", " igrej", "igvreje", "iggreji", "igarrejas", "iggreJa", " igcreJa", "igarrej", " igreJa", "iggreja", "igcreji", "igrejas", " igrejas", "igcreJa", "igcrej", "igopenva", "igreje", "igreva", "igarreje", "igvrej", " igreva", "igvrejas", "igarreva", "igarreja", " iggreji", " iggrejas", " iggreje", "igreJa", " iggreja", "igvreja", "igcreja", " igcreja", "igopenj", "igarreji", "iggrejas", "igrej", "iggrej", "igarreJa", " igcreji", "igreji", "igopenji", " igreji"], "connection": ["which", "computer", "creator", "link", "setup", "close", "c", "document", "ion", "engine", "gate", " Connection", "component", "statement", "reference", "management", "condition", "established", "socket", "settings", "system", "Connection", "client", "context", "directory", "resource", "to", "library", "message", "conn", "operation", "connected", "created", "n", "application", "function", "user", "language", "container", "con", "section", "instance", "server", "network", "position", "current", "database", "session", "relation", "query", "manager", "db", "city", "config", "connect", "pool", "communication", "description", "response", "generation", "open", "command", "collection"], "sql": ["pl", "scl", "install", "zip", "expression", "table", "statement", "url", "pel", "sq", "serial", "series", "normal", "login", "spec", "log", "seed", "nl", "spr", "sf", "q", "sol", "sd", "select", "sv", "ln", "cmd", "csv", "plan", "string", "title", "template", "shell", "SQL", "query", "inv", "sys", "sk", "xml", "description", "form", "lock", "san", "dl", "command", "ql"], "sql2": ["SQL2", "ql02", "sd2", "SQL3", "sql3", "sql1", "ql2", " sql02", "sd4", "SQL1", "ql3", "sql4", "sd02", " sql4", " sql1", "sd3", "sql02", "SQL4", " sql3", "SQL02", "ql1"], "stmt": ["restm", "statMT", "ststat", "statmn", " ststat", "Ststat", "tmt", "Stmm", " stmb", "strmb", "statm", "STmt", "strmt", "restmm", " stm", "STMT", "STmm", "estm", "strMT", "estmb", "reststat", "strm", "stm", "tMT", "statmt", " stMT", "estmt", "estMT", "StMT", "restmt", "Stm", "tmb", " stmn", "tmm", "stmb", "stMT", " stmm", "Stmn", "stmm", "Stmb", "Stmt", "STmb", "STm", "STmn", "stmn"], "stmt2": ["stmrtwo", "sttm3", "stMT1", "Stmt2", "Stmem2", " stmp4", " stmp3", "stmt02", " stMT3", "sttx3", "stmr4", "stmptwo", " stmt4", "stmTwo", "stmp2", "stmem1", "stmpTwo", "sttx1", "stmemTwo", " stMT1", "stm02", " stmt1", "Stmt1", " stmp2", "stmr2", " stmptwo", "stmp1", "sttm2", "stmr1", "sttm4", "stmem2", "stmt1", "stmp3", "stmt3", "stmt4", " stMT02", "stMTTwo", " stmpTwo", " stmt02", "stmem3", " stmtTwo", "stMT4", " stmt3", " stmttwo", "Stmem3", "stmttwo", "stmtTwo", "stMTtwo", " stmp1", "stMT2", "stm3", "Stmem1", "stmp4", "StmemTwo", "stMT02", " stMT2", "sttmTwo", "stm2", "stm1", "StmtTwo", "stMT3", "sttx02", "sttx2", "Stmt3"], "rs": ["rt", "ms", "ros", "eps", "bs", "rc", "vs", "ws", "rows", "ls", "ss", "mr", "rd", "results", "its", "Rs", "ns", "cs", "ts", "s", "ins", "ows", "r", "ats", "gs", "js", "fs", "res", "pers", "rys", "vers", "rss", "sts", "ds", "ks", "usr", "ris", "ys", "sr", "hs", "rates", "ras", "xs", "RS", "ars", "ims", "qs", "ps"], "retorno": ["montorno", "eltano", "eltorn", "altorn", "altano", " retogo", "montora", " retorn", "retrero", "retora", "altorno", " retora", "retorn", " retrero", "retogo", "eltogo", "gotorne", " retorne", "eltorno", "retorne", "altogo", "montrero", "gotorno", " retano", "gotora", "gotrero", "montorne", "retano"]}}
{"id1": "17161805", "id2": "18433984", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"encode": ["Enforce", "encforce", "enscode", "enprocess", "enccode", "unode", "Enode", "enode", "ensforce", "unprocess", "uncode", "enforce", "Encode", "unforce", "ensprocess", "encprocess", "ensode"], "plaintext": ["plainText", " plainlat", "plainlat", "mainText", "maintext", "formmessage", " plainth", " plainText", "formdata", "plaindata", "prontext", "formText", "pronlat", "ainText", "aintext", "formtext", "plainth", "plainmessage", "ainmessage", "pronText", " plaindata", "mainth", " plainmessage", "aindata", "pronth", "mainlat"], "md": ["mod", "m", "ms", "med", "det", "pd", "df", "amd", "ld", " MD", "managed", "mk", "dh", "mc", "pm", "add", "MD", "ng", "del", "ind", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "pdf", "sha", "der", "nt", "hd", " Md", "red", "mand", "grad", "msg", "mo", "mp", "dd", "d"], "raw": ["full", "hex", "row", " Raw", "orig", "read", "unsigned", "custom", "bare", "strip", "value", "mem", "aw", "valid", "sh", "message", "bound", "map", "stable", "wrap", " RAW", "clean", "unknown", "n", "buf", "cmd", "pack", "inner", "Raw", "def", "input", "cooked", "modified", "RAW", "json", "des", "bytes", "rendered", "serial", "derived"]}}
{"id1": "19849797", "id2": "16142024", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", " copyStream", "transferStream", "transferfile", " cpStream", "transferFiles", " cpfile", " copyfile", "copyfile", " cpFiles", " copyFiles", "copyFiles", "copyStream", " cpFile"], "sourceFile": [" sourcePath", " sourcePage", "srcPath", "ourcePath", "srcLine", "ourceFile", "srcField", "ourceField", "ourceTable", "sourcePage", "sourceLine", "sourcefile", "srcFile", "sourcePath", "srcPage", "ourcePage", " sourceLine", "srcfile", "sourceTable", " sourceField", " sourcefile", "ourceLine", "sourceField", "srcTable", " sourceTable", "ourcefile"], "destFile": ["datPlace", "declEntity", "optFolder", "destDir", "DestFile", "destFilename", "restPlace", "optPath", "optFile", "srcFolder", "DestPath", "srcPath", " destPath", "DestFilename", "DestFiles", " destDir", "destEntity", "restFile", "optFilename", "srcFile", " destFilename", " destPlace", "declFile", "destFolder", "destPath", "optEntity", "srcFiles", "datFilename", "destFiles", "datFiles", "restFiles", "datFile", "DestDir", "srcDir", "destPlace", "srcEntity", "declDir", " destFiles", "restFilename", "declFolder", "optDir"], "source": ["src", "before", "OURCE", "send", "note", "in", "parse", "update", "sample", "local", "SOURCE", "table", "component", "back", "score", "se", "stream", "scope", "none", "parent", "check", "store", "ce", "slave", "iterator", "use", "scale", "image", "resource", "sequence", "spec", "owner", "reader", "service", "console", "ource", "standard", "from", "iter", "start", "create", "init", "origin", "copy", "search", "inner", "style", "ie", "load", "input", "missing", "char", "body", "index", "target", "proxy", "query", "show", "force", "Source", "comment", "cause", "match", "subject", "channel", "attribute", "pose", "series", "result", "shell"], "destination": ["destined", "separment", "Destinator", "decinate", "noninate", "nonination", "decination", "descation", "descinate", "verination", " destation", "restinator", "descinator", "verinated", "termininate", " destinate", " destinator", "noninator", "restinated", "destation", "Destation", " destificate", "veration", "descination", " destment", "separinated", "separation", "Destination", "decined", "separination", "destificate", "Destment", "Destinate", "noninated", "Destinated", "restinate", "destinator", " destined", "destinate", "terminined", " destinated", "termininated", "destinated", "destment", "restination", "decinated", "terminination", "verificate", "Destificate"]}}
{"id1": "18374598", "id2": "19934218", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"download": ["dial", " downloads", "install", " Download", "upload", "read", "link", "sample", "update", "poll", "submit", "url", "get", "check", "delete", "GET", "Download", "loader", "create", " downloaded", "pull", "save", "connect", "file", "data", "open", "filename", "load"], "a": ["aa", "go", "u", "t", "aaa", "ata", "va", "ia", "b", "c", "ab", "path", "o", "any", "alpha", "base", "aos", "h", "na", "url", "part", "aw", "au", "ga", "address", "A", "name", "v", "arg", "ae", "s", "l", "r", "ai", "al", "ao", "ta", "la", "an", "from", "pa", "att", "all", "title", "app", "sa", "area", "sta", "ma", "i", "at", "oa", "apa", "as", "el", "html", "data", "era", "eta", "array", "ar", "ca", "ap", "am", "ac", "attribute", "d"], "p": ["pl", "rep", "m", "perm", "t", "pos", "b", "j", "pp", "pid", " pe", "pkg", "c", "h", "prop", "pad", "pi", "power", "part", "pg", "cp", "ping", "pb", "l", "op", "q", "pro", "x", "pat", "np", "g", "pers", "pre", "pe", "lp", "vp", "ip", "pc", "pa", "pt", "P", "jp", "par", "pard", "bp", "pr", "i", "tp", "wp", "ap", "ps", "d"], "td": ["dial", "tc", "ad", "t", "det", "pd", "df", "tif", "ld", "ot", "dh", "cot", "tap", "cz", "nd", " TD", "ct", "dc", "ts", "cd", "md", "pb", "od", "bd", "th", "sd", " sd", "fc", "pc", "pt", "ds", "lf", "tr", "nt", "deb", "tmp", "div", "ptr", "db", "hd", "dt", "fd", "tf", "dl", "tp", "dd", "TD", "d"], "f": ["ft", "t", "w", "df", "b", "j", "fn", "c", "fw", "fp", "F", "o", "h", "bf", "fm", "func", "e", "alf", "fe", "fb", "ff", "v", "uf", "l", "fl", "rf", "sf", "fo", "g", "fs", "fx", "cf", "fc", "lf", "i", "fr", "form", "af", "file", "fd", "tf", "fi", "xf", "fa", "fin", "d"], "total": ["equal", "full", "info", "t", "note", "active", "length", "table", "done", "base", "trans", "unique", "none", "count", "valid", "available", "scale", "buffer", "sequence", "normal", "last", "to", "stable", "number", "otal", "ta", "percent", "start", "all", "template", "current", "meta", "nt", "num", "le", "sum", "sys", "initial", "eta", "net", "max", "len", "open", "complete", "Total"], "progress": ["bar", "process", "memory", "usage", "t", "finished", "update", "length", "portion", "done", "poll", "offset", "priority", "speed", "Progress", "success", "count", "history", "scale", "address", "grade", "resource", "summary", "report", "print", "depth", "dist", "payment", "pro", "scroll", "debug", "percent", "step", "distance", "state", "performance", "result", "continue", "current", "pdf", "important", "age", "ptr", "wait", "display", "status", "complete"], "in": ["im", "oin", "o", "get", "cin", "on", "it", "ini", "inf", "inn", "ind", "ze", "ins", "to", "l", "ic", "rin", "by", "io", "ai", "inc", "iter", "from", "IN", "win", "init", "mm", "en", "inner", "bin", "con", "input", "din", "inside", "i", "is", "ar", "and", "In"], "out": ["os", "cn", "null", "t", "pos", "w", "err", "b", "c", "end", "ch", "o", "aos", "it", "on", "list", "client", "v", "writer", "can", "obj", "to", "outs", "l", "s", "io", "by", "ins", "log", "write", "conn", "put", "cache", "g", "res", "output", "ex", "Out", "con", "nt", "outer", "ou", "oss", "at", "cb", "OU", "pool", "sys", "auto", "OUT", "co", "vol", "lock", "ne", "net"], "buf": ["bar", "row", "wb", "orig", "buff", "b", "cap", "mu", "pkg", "batch", "block", "Buffer", "cp", "vec", "buffer", "uf", "pb", "obs", "tab", "window", "seq", "Buff", "aka", "cmd", "bl", "cat", "bag", "bin", "rb", "img", "br", "conv", "next", "bed", "db", "ob", "cb", "norm", "box", "bytes", "cv", "data", "msg", "arr"], "n": ["dn", "nc", "m", "cn", "t", "z", "w", "nr", "note", "fn", "j", "b", "c", "o", "nan", "na", "gn", "on", "ng", "nm", "count", "none", "ns", "y", "v", "min", "l", "nl", "number", "yn", "N", "x", "g", "np", "ln", "no", "nn", "an", "sn", "en", "nt", "num", "nor", "wn", "i", "names", "ren", "norm", "nw", "len", "max", "ne", "nb", "d"], "percentage": ["propade", "taxance", "CENTategy", "percentile", "parage", "parance", "parAGE", "quantance", "Percentume", "Percentile", "CENTage", "quantility", "centAGE", "centume", "percentade", "Percentade", "centity", "quantension", "Percentility", "quantage", "percentategy", "percentAGE", "CENTume", "scaleage", "oppility", "Percentage", "parility", "scaleility", "CENTade", "percentility", "taxility", "percentance", "percentume", "percentension", "centager", "oppade", "centility", "propage", "centategy", "percentager", "Percentant", "oppant", "parager", "propity", "oppage", "taxension", "scaleAGE", "Percentity", "centage", "scaleager", "Percentategy", "propile", "percentant", "centade", "percentity", "parension", "centile", "taxage"], "tmpPercentage": [" tmpPercentance", "tmpPercentency", "tmpPlusane", " tmpPercentade", "tmpIntade", " tmpPercentages", " tmppercentane", " tmpIntage", " tmpIntade", " tmpPercentency", "tmpIntage", " tmpPercentate", "tmpMagnade", " tmpPercenture", "tmpPercentages", "tmpPropency", "tmpPlusage", " tmpIntency", " tmppercentages", "tmppercentane", " tmppercentate", "tmpPercentance", "tmpPropade", "tmppercenture", " tmppercentage", "tmpMagnate", "tmppercentage", "tmpPercenture", " tmpPercentane", "tmpMagnages", "tmpPercentane", "tmpMagnage", "tmppercentade", " tmppercenture", "tmppercentate", "tmpPercentade", "tmpPropance", "tmpIntency", " tmpIntance", "tmpIntance", "tmpPlusade", "tmpPercentate", "tmpPropage", " tmppercentade", "tmppercentages", "tmpPlusure"], "size": ["storage", "send", "length", "empty", "c", "capacity", "SIZE", "e", "space", "count", "used", "sp", "scale", "now", "name", "ose", "ze", "s", "l", "loss", "sw", "needed", "Size", "sd", "g", "code", "see", "set", "sn", "small", "ize", "position", "notice", "area", "body", "num", "sum", "bytes", "loc", "max", "len"], "checksum": ["cksam", "readsum", "hasam", "kscan", "ksam", "timessum", "hasum", "hascan", "checksumm", "readsave", "hssum", "timesum", "hsul", "ksum", "actionsumm", "cksul", "actionssum", "checksam", "readsul", "actionsul", " checksul", "actionsum", "timesave", "checksave", "checkssum", "hassum", "timesul", "hsum", "readssum", "ckscan", "ckssum", "hsumm", "checksul", "cksave", " checksumm", "kssum", "cksum", " checkssum", "checkscan"]}}
{"id1": "22552318", "id2": "16142024", "code1": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["LoadCDL", "loadPDL", "loadDDDL", "LoadDDL", "loadCDl", "loadCDML", "loadCDL", "loadPDl", "LoadCDDL", "LoadCDl", "LoadDDl", "loadDSl", "loadPDDL", "LoadDDDL", "LoadDDML", "loadCDDL", "loadDSML", "LoadCDML", "loadPDML", "loadDDML", "loadDSL", "loadDDl", "loadDSDL"], "stmt": ["STmp", "astMT", "stst", "stmp", "asttm", " stct", " sttm", "utm", "Stmm", "STmt", "utMT", "strmt", "stct", " stm", "astmt", "frm", "STMT", "STmm", " stmp", "strm", "stm", "Stst", "utst", " stMT", "Sttm", "frmt", "utmt", "StMT", " superstct", "astm", " stst", "Stm", "sttm", "stMT", " stmm", "strmp", " superstmt", " superstm", " stpt", "frct", "frpt", "Stmt", "stmm", " superstpt", "STm", "stpt", "strmm"], "qry": ["Qrys", "qri", "sqri", "sqRY", "quary", "qRY", "Qri", " qRY", "qurys", "quri", " qary", "qrys", "qary", " qri", " qrys", "Qry", "qury", "sqry", "sqrys", "QRY", "sqary"], "q": ["iq", "m", "u", "dq", "t", "z", "w", "j", "qi", "c", "pkg", "o", "h", "e", "sq", "Q", "p", "v", "s", "f", "k", "r", "n", "g", "qv", "qt", "query", "i", "ry", "qa", "comment", "qu", "qq", "qs", "ql", "d"]}}
{"id1": "5759961", "id2": "15500892", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"saveUser": [" enrichAccount", " manipulateGroup", "saveuser", " saveuser", "saveGroup", " manipulateUser", " enrichuser", " enrichUser", " enrichGroup", "saveAccount", " saveAccount", " saveGroup", " manipulateAccount", " manipulateuser"], "user": ["record", "info", "project", "row", "usage", "u", "person", "item", "email", "per", "update", "table", "responsible", "rule", "object", "us", "url", "get", "username", "base", "ver", "add", "e", "or", "version", "User", "used", "store", "use", "name", "client", "message", "this", "v", "post", "login", "owner", "password", "report", "print", "by", "content", "account", "write", "me", "test", "uid", "ro", "USER", "profile", "create", "replace", "load", "word", "server", "usr", "char", "actor", "force", "data", "file", "response", "job", "entry", "author", "cert", "human", "auth", "result"], "digest": ["digse", "readested", "compests", "Digse", "Digested", "readse", "digested", "compress", "mdest", "digester", "hashester", "readest", "digests", " digress", "hashress", "compested", "mdested", "DigEST", "hashested", "hashest", "hashEST", "compest", " digested", " digse", "mdse", "hashests", " digEST", "readester", "digress", "mdester", "Digest", "Digester", "digEST", " digester", " digests"], "hash": ["full", "handle", "hex", "mac", "h", "has", "uh", "add", "ash", "version", "block", "check", "sh", "count", "id", "dig", "password", "cache", "number", "mask", "height", "ashes", "test", "init", "search", "char", "sha", "Hash", "hed", "index", "sum", "num", "tag", "html", "her", "size", "type", "max", "key", "rh", "result"], "bigInt": ["BigInteger", " bigLong", "littleint", "bigInteger", "littleInt", " bigint", "littleINT", "pgInt", "pgint", "bigINT", "hugeInteger", "BigLong", "BigInt", "bigint", "hugeInt", "longint", "hugeLong", "bigLong", " bigInteger", "Bigint", "pgINT", "longINT", "longInt", "hugeint"], "hashtext": ["ashtext", " hashstr", "Hashfunction", "ashText", "hashinfo", " hashinfo", "shatext", "hashpath", "ashstr", "hexText", "Hashstr", "Hashinfo", "hashtxt", " hashvalue", "hexvalue", " hashtxt", "shavalue", "ashtxt", "hashfunction", "hexread", "sumstr", "hashstr", "hexpath", " hashfunction", "hashread", " hashread", "ashread", "hashvalue", "hextext", "hashText", " hashText", "sumtext", "shaText", "sumpath", "shatxt", "HashText", "sumfunction", "sumText", "ashinfo", "hextxt", "Hashpath", "Hashtext"]}}
{"id1": "14168494", "id2": "397240", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpByte", " CopyFile", " copyStream", " cpStream", " cpfile", " copyfile", " CopyStream", " copyByte", "Copyfile", "CopyByte", " Copyfile", " CopyByte", "CopyStream", " cpFile", "CopyFile"], "dest": ["w", "orig", "Dest", "gt", "cont", "trans", "del", "way", "v", "rest", "master", "to", "doc", "temp", "out", "dist", "source", "np", "st", "www", "good", "etc", "origin", "img", "them", "usr", "nt", "tmp", "target", "nom", "des", "loc", "nw", "pub", "result", "dir", "d"], "src": ["sc", "upload", "sel", "rc", "cont", "ls", "desc", "ser", "sq", "ins", "req", "sl", "sub", "cur", "source", "rel", "st", "from", "rs", "start", "sb", "rx", "init", "iv", "sec", "input", "img", "usr", "sr", "sys", "Source", "inst", "file", "loc"], "srcChannel": ["sourceCh", "srcchannel", "srcPanel", "sqChannel", "srcCan", "sqCan", " srcCh", "rcCommand", "bgCan", " srcMessage", " srcChain", "instChan", "sysChannel", "srcCommand", "sqPanel", "destMessage", "sqChain", "sourceChan", "destChan", " srcchannel", "sysChan", "instPanel", "destChannel", "sourceChannel", "rcMessage", "bgPanel", "sysCommand", "srcCh", " srcChan", "syschannel", "bgChain", "instChain", "rcChannel", "srcChan", "rcchannel", " srcCommand", "rcChan", "instChannel", "instCan", "destChain", "srcChain", "instCh", "bgChannel", "rcChain", "srcMessage"], "dstChannel": ["dndChan", "ddestCh", " dotHandler", "ddestHandler", "ddestChannel", "dstCh", "dotChan", "pdestCommand", "dstHandler", "destClient", "dbrHandler", " dotChan", "dndCommand", " dstChan", " dstButton", "dndChannel", "dotHandler", "pstCommand", " dotCh", "dbrChan", " dstHandler", "pdestChannel", "dstChan", "destChannel", "dbrCh", "dstClient", "pdestButton", "dbrChannel", "dndButton", "dotChannel", "dstCommand", "ddestClient", "ddestChan", "destCommand", "pdestClient", "ddestCommand", "dndCh", "dotCh", " dotButton", "ddestButton", "destButton", "dstButton", "dotButton", "pstChannel", " dstCh", "pstClient", "dndClient", "pstButton", " dotChannel"]}}
{"id1": "11475527", "id2": "22844377", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public int scrapeForIsbns(URL url) {\n        int matches = 0;\n        Pattern p = Pattern.compile(\"ISBN-10:</strong>\\\\s*(\\\\w{10})\");\n        Matcher m;\n        for (int i = 0; i < RETRIES; i++) {\n            try {\n                InputStream in = url.openStream();\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String str;\n                while ((str = br.readLine()) != null) {\n                    m = p.matcher(str);\n                    while (m.find()) {\n                        matches++;\n                        outputIsbns.put(m.group(1));\n                        logger.debug(\"Got ISBN: \" + m.group(1));\n                    }\n                }\n                break;\n            } catch (ConnectException e) {\n                logger.warn(\"Connection attempt \" + i + \" failed, trying again. Max retries: \" + RETRIES);\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e1) {\n                }\n            } catch (IOException e) {\n                logger.error(\"Error reading URL stream\", e);\n            } catch (InterruptedException e) {\n                logger.error(\"Interrupted while calling put(Object E)\", e);\n            }\n        }\n        return matches;\n    }\n", "label": 1, "substitutes": {"addDataFromURL": ["addTextFromurl", "addDataFormurl", "addDataToURL", "addDataFormURL", "addDataTourl", "addDatafromURL", "addTextFormURL", "addDatafromUrl", "addDataFormUrl", "addDataFromUrl", "addDatafromLocation", "addDataToLocation", "addTextFromURL", "addDataFromLocation", "addDataFormLocation", "addTextFromUrl", "addTextFormUrl", "addDataFromurl", "addTextFromLocation", "addTextFormLocation", "addTextFormurl", "addDataToUrl", "addDatafromurl"], "theurl": ["TheUrl", "Theuri", "heloader", "heuri", "teURL", " theloader", " theuri", "thloader", "Theurl", " theURL", "theloader", "teuri", "heURL", "heUrl", "teurl", "thefile", "thfile", "heurl", "theUrl", " theUrl", " thefile", "thUrl", "hefile", "teUrl", "theURL", "TheURL", "theuri", "thurl"], "line": ["record", "LINE", "row", "email", "link", "sample", "rule", "ner", "eline", "inline", "block", "ice", "valid", "day", "cell", "name", "message", "Line", "sequence", "l", "print", "source", "lined", "code", "node", "ln", "stroke", " inline", "lin", "page", "string", "char", "point", "le", "zone", "frame", "online", "header", "status", "lane", "comment", "entry", "ine", "text", "chain", "liner"], "in": ["gin", "t", "include", "read", "lo", "old", "oin", "mc", "o", "mi", "cin", "it", "or", "inf", "inn", "id", "ain", "ins", "l", "rin", "f", "ic", "reader", "r", "pin", "inc", "conn", "out", "ai", "al", "source", "proc", "n", "st", "IN", "from", "win", "init", "en", "isin", "bin", "inner", "con", "input", "again", "din", "phys", "ma", "i", "is", "ac", "serv", "open", "In"], "data": ["join", "info", "feed", "ad", "text", "ata", "read", "DATA", "a", "stream", "raw", "iterator", "client", "this", "buffer", "writer", "io", "reader", "content", "dec", "cache", "out", "window", "user", "dat", "def", "input", "body", "next", "pipe", "query", "size", "file", "bus", "da", "result", "d"], "e": ["m", "re", "t", "err", "ee", "b", "ec", "c", "ge", "o", "h", "a", "se", "be", "or", "ed", "es", "oe", "ce", "error", "y", "p", "ze", "er", "ae", "v", "element", "f", "ve", "ele", "r", "x", "E", "n", "g", "me", "pe", "de", "eeee", "ex", "ie", "le", "te", "i", "eu", "ne", "entry", "ine", "ue", "event", "d"]}}
{"id1": "3024992", "id2": "15905041", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_NullOut", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter2null_", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2Nullin"], "baout": ["buouts", "caOut", "cait", "BAoul", "BAouts", "BAouth", "baouts", "BAit", "cain", "bain", "abaout", "BAout", "buin", "abain", "abait", "gain", "dbouth", "gaouth", " baouts", "dboul", "baoul", "gaoul", " bain", "gaout", "baOut", "BAin", "baouth", "caout", "dbin", "BAOut", "bait", "buout", "dbout", "abaOut", " baOut", "buOut"], "out": ["null", "err", "in", "o", "it", "gr", "ser", "er", "outs", "io", "write", "n", "res", "output", "ex", " OUT", "Out", "tmp", "pool", "gen", "sys", "OUT", "serv", "result", "net"], "writer": ["processor", "rw", "null", "w", "handler", "document", "wright", "driver", "worker", "maker", "wrote", "client", "this", "buffer", "usher", "er", "riter", "print", "reader", "write", "service", "window", "output", "widget", "NULL", "inner", "killer", "writ", "player", "outer", "target", "Writer", "println", "woman", "data", "file", "nw", "channel", "builder"]}}
{"id1": "14053882", "id2": "11005804", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"encrypt": ["Encrypt", "Encode", " encrypted", "encryption", " encode", "Encryption", "decryption", "encrypted", "decode", "decrypted", " encryption", "decrypt", "encode", "Encrypted"], "plaintext": ["plainText", "mainText", "longth", "maintext", " plainth", " plainText", "longmessage", "mainTEXT", "mainpassword", "publicpassword", " plainTEXT", "broadText", "broadtext", "longText", "publicText", " plainpassword", "plainth", "plainmessage", "publicTEXT", "plainTEXT", "plainpassword", "broadmessage", " plainmessage", "broadth", "publictext", "longtext"], "md": [" ma", "mod", "m", "ms", " dd", "mark", "med", "det", "pd", "df", "ld", "managed", "mk", "dh", "mc", "nd", "MD", "ng", "del", "ind", "rm", "dig", "cd", "mn", "mt", "od", "mb", "sam", " mo", "sm", " mc", "sd", "mg", "cmd", "dm", "mm", "met", "metadata", "dr", "ds", "der", "sha", "nt", "ma", "hd", "esm", "mand", "grad", "mo", "mp", "dd", "d"], "raw": ["full", "hex", "row", " Raw", "orig", "unsigned", "custom", "bare", "base", "strip", "value", "aw", "valid", "available", "sh", "message", "right", "bound", "r", "out", " RAW", "clean", "unknown", "n", "buf", "good", "pack", "extra", "encrypted", "random", "all", "Raw", "input", "original", "RAW", "known", "box", "bytes", "data", "rendered", "array", "hook", "clear"], "hash": ["handle", "hex", "mac", "ssh", "total", "href", "h", "url", "has", "ash", "ashed", "flash", "sh", "id", "message", "password", "print", "hidden", "cache", "mask", "height", "proof", "unknown", "alert", "hat", "ashes", "sign", "search", "tr", "sha", "Hash", "hed", "sum", "json", "tag", "html", "key", "cert", "shadow"]}}
{"id1": "19113613", "id2": "14502142", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "pixel", "zip", "link", "gc", "Copy", "delete", "opy", "cp", "php", "cross", "map", "to", "sync", "write", "same", "Cop", "cat", "create", "replace", "ip", "init", "crop", "move", "save", "share", "core", "clip", "slice", "proxy", "split", "transfer", "clone", "py", "co", "cop", "download", "cos"], "in": ["gin", "info", "re", "old", "o", "mi", "up", "cin", "it", "on", "check", "inf", "ini", "inn", "ind", "id", "y", "ins", "ic", "rin", "l", "by", "inc", "ai", "from", "IN", "local", "act", "init", "iter", "en", "isin", "inner", "bin", "ie", "all", "input", "con", "sin", "din", "inv", "i", "inside", "el", "is", "ar", "ir", "In", "net"], "out": ["os", "null", "t", "w", "err", "b", "gt", "end", "ion", "ot", "ch", "o", "base", "aos", "ver", "it", "on", "store", "client", "this", "v", "y", "p", "port", "obj", "to", "log", "l", "outs", "io", "op", "can", "over", "cache", "write", "conn", "not", "one", "n", "res", "output", "local", "set", "ex", "Out", "en", "inner", "all", "con", "nt", "outer", "tmp", "ou", "oss", "at", "sys", "OU", "OUT", "co", "ent", "result", "net"], "source": ["src", "sql", "SOURCE", "range", "base", "se", "prefix", "scope", "space", "parent", "store", "sp", "use", "system", "ce", "this", "sequence", "resource", "unit", "s", "ie", "service", "scan", "select", "ource", "site", "from", "local", "start", "language", "origin", "search", "inner", "string", "template", "title", "style", "input", "si", "lower", "sin", "shell", "position", "index", "query", "relation", "Source", "cause", "subject", "format", "key", "status", "finder", "attribute"], "target": ["join", "that", "module", "null", "t", "other", "goal", "link", "table", "gt", "tif", "url", "top", "base", "scope", "parent", "arg", "resource", "to", "Target", "print", "term", "rel", "test", "ARGET", "bolt", "output", "local", "step", "location", "origin", "tree", "dest", "alias", "template", "style", "token", "pattern", "root", "point", "query", "arget", "match", "translation", "key"], "files": ["faces", "styles", "modules", "details", "packages", "actions", "features", "jobs", "banks", "services", "pages", "resources", "balls", "events", "ls", "facts", "lets", "states", "issues", "books", "users", "values", "workers", "items", "uploads", "pieces", "lines", "members", "assets", "fs", "les", "headers", "thumbnails", "objects", "plates", "ports", "reports", "iles", "tools", "parts", "models", "images"], "file": ["full", "row", "item", "File", "ile", "FILE", "table", "document", "fp", "rule", "path", "tile", "base", "line", "be", "e", "block", "parent", "fe", "name", "image", "resource", "port", "library", "print", "f", "ve", "feature", "play", "folder", "node", "pe", "user", "local", "child", "page", "tree", "work", "current", "word", "foo", "le", "relation", "el", "model", "data", "job", "entry", "field", "key", "label", "filename", "event", "dir"], "inCh": ["cinCr", "InCod", " inch", "inCl", "rinCl", "outCod", "cinch", "InCh", "cinCod", "dinCh", " inCl", "incCh", "inCor", "InCl", "inch", "inSam", "incSam", "rinCod", "incCor", " inChan", "cinChan", "incCr", "inCr", " inCod", "rinChan", "dinCor", "cinCor", "rinCh", "cinCh", "outch", "dinCr", "InChan", "outChan", "inCod", "inChan", "cinSam", "dinSam"], "outCh": ["outputCod", "inCol", " outGr", "newGr", "newCol", " outch", "outCod", "newChan", "inch", " outCol", "outputCh", " outCod", "outputChan", "newCod", "newch", "outCol", "outGr", "outputGr", " outChan", "outch", "outChan", "inChan", "newCh"]}}
{"id1": "14794404", "id2": "23532405", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptionPassword", "encryptedPass", "encipherpassword", "decryptpassword", "encryptedpassword", "decryptedPassword", "encryptPass", "encipherSecret", "encryptionpassword", "decryptPass", "decryptedSecret", "decryptPassword", "decryptSecret", "encryptpassword", "encipherPass", "encipherPassword", "decryptedpassword", "encryptSecret", "decryptedPass", "encryptionSecret", "encryptionPass", "encryptedSecret"], "password": ["pass", "secret", "phrase", "w", "email", "Password", "path", "username", "prefix", "value", "address", "name", "message", "filename", "directory", "sword", "login", "reset", "content", "number", "padding", "wordpress", "user", "string", "pattern", "token", "word", "input", "database", "hash", "past", "description", "data", "entry", "key", "text", "command", "shadow", "attribute"], "encryptedPassword": [" encryptedpassword", "confirmedPassword", "coloredPassword", "encryptedpassword", "finishedpassword", "encryptedConnection", "coloredStatement", "initializedStatement", "encryptedAttribute", "confirmedpassword", "updatedGuest", "updatedPassword", "coloredDatabase", "finishedDatabase", "installedDirectory", "installedDatabase", "ryptedpassword", "updatedpassword", "finishedGuest", "initializedPassword", "confirmedDatabase", " encryptedStatement", "ryptedPassword", " encryptedGuest", "updatedAttribute", "confirmedDirectory", "updatedDirectory", " encryptedDirectory", " encryptedConnection", "encryptedGuest", "initializedConnection", "initializedDatabase", "coloredConnection", "updatedDatabase", "encryptedStatement", " encryptedAttribute", "installedPassword", "ryptedDatabase", "finishedPassword", "installedAttribute", "ryptedDirectory", "encryptedDirectory", "encryptedDatabase", " encryptedDatabase"], "md5": [" Md3", " MD3", "MD25", "MD3", "md3", "md25", " md25", "dig2", "MD5", "MD512", " md512", " Md8", " mdle", "sha7", " MD2", " md7", "MD7", "md2", "md512", "sha2", "md8", "sha5", "dig3", " MD5", " md3", " MD8", "sha512", "dig25", "MD2", "md7", " MDle", " md8", " Mdle", " md2", "mdle", "dig5", " Md5"], "digest": ["digse", "Digse", "Digested", "mdEST", "digested", "hexest", "mdest", "digester", "Digness", "digests", "hashester", "Digests", "hashum", "mdests", "digum", "digness", "DigEST", "hashested", "hashest", "hashEST", "mdness", "Digum", "hexness", " digse", "mdse", "hexested", " digEST", "mdester", "Digest", "Digester", "digEST", "hexEST", "mdested", " digests", "mdum"], "i": ["ji", "m", "iq", "ci", "u", "t", "im", "err", "in", "z", "phi", "j", "b", "ii", "gu", "qi", "c", "gi", "I", "span", "my", "mi", "ti", "a", "o", "pi", "it", "di", "ui", "ski", "ind", "hi", "id", "zi", "y", "multi", "ic", "uri", "io", "ai", "\u0438", "q", "x", "n", "me", "bi", "iter", "ip", "init", "si", "ie", "ij", "ri", "conv", "index", "point", "sim", "li", "ix", "xi", "is", "yi", "key", "ei", "major"], "hex": ["full", "rex", "solid", "hl", "zip", "unsigned", "dump", "ch", "h", "alpha", "mix", "raw", "none", "check", "sh", "flash", "color", "serial", "sex", "print", "pex", "rh", "temp", "x", "kw", "str", "term", "sv", "uint", "cf", "cmd", "ex", "txt", "tex", "exp", "percent", "iter", "oct", "def", " Hex", "br", "com", "ph", "json", "comp", "hash", "html", "des", "lit", "form", "ne", "rendered", "tx", "xf", "cert"]}}
{"id1": "21308543", "id2": "7908169", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFiles", "cpDirectory", "copyfile", "cpFile", "Copyfile", "CopyFiles", "cloneFile", "cloneFiles", "cloneDirectory", "CopyDirectory", "copyFiles", "cpfile", "clonefile", "copyDirectory", "CopyFile"], "src": ["sit", "rt", "ur", "sc", "ripp", "rc", "pkg", "cont", "usc", "ser", "sq", "ins", "req", "rl", "cur", "source", "js", "fx", "rel", "st", "rs", "start", "sb", "rx", "init", "ctr", "iv", "sec", "usr", "sr", "ix", "sys", "Source", "inst", "sur", "subject", "loc", "ipl", "obs"], "target": ["tt", "that", "t", "other", "stop", "goal", "link", "mac", "gt", "mk", "top", "base", "parent", "delete", "eth", "arg", "the", "to", "Target", "patch", "term", "source", "rel", "test", "ARGET", "bolt", "output", "set", "replace", "start", "touch", "dest", "template", "jp", "nt", "next", "arget", "file", "match", "result"], "ic": ["ico", "eric", "wic", "iq", "ci", "nic", "tic", "pic", "ia", "rc", "IC", "cin", "it", "lc", "ice", "isc", "ric", "ib", "cit", "ican", "mic", "iu", "icc", "sic", "anc", "fc", "ip", "cli", "pc", "vc", "arc", "ics", "cu", "ik", "icing", "iac", "i", "ix", "irc", "aic", "bc", "ac"], "oc": ["ico", "nc", "mot", "ci", "ox", "nic", "pic", "gc", "ec", "c", "rc", "og", "ot", "mc", "o", "soc", "isc", "cc", "oci", "ocon", "osc", "od", "ocr", "toc", "oco", "mic", "unc", "anc", "voc", "pc", "oct", "ko", "cu", "arc", "yo", "OC", "oss", "ob", "irc", "aic", "co", "roc", "cos", "bc", "ac", "cus"]}}
{"id1": "884867", "id2": "11952735", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"zipname": ["zname", "polyname", "archivename", "gzsize", "gznamed", " zipbase", "zipnamed", "zipsize", "archiveName", "ziproot", "tarname", "archiveout", " zipsize", "zename", "zeout", "tarsize", "downloadnamed", "tarroot", "downloadname", "downloadfilename", "zebase", "archivebase", "zName", "polyName", "downloadName", " zipName", "polyfilename", "zipName", " ziproot", "zipfilename", "znamed", "zfilename", "tarnamed", "zipbase", "polynamed", " zipnamed", "gzname", "gzroot", "zeName"], "zipout": ["zname", " zipoutput", "zin", "zout", "zipobj", "Zipout", "gzout", " zipall", "sendout", "zn", "gzobj", " zipobj", " zipclient", "sendin", "zOut", "zipn", "zgen", " zipgen", "zipgen", " zipin", "Zipclient", "gzOut", "sendn", "gzall", "zipin", "zipall", "gzion", "zipclient", "zipion", "sendoutput", "zall", "zion", "Zipn", "sendclient", "sendname", "Zipname", "gzin", "zipOut", "zipoutput", "Zipin", "gzgen", "Zipoutput", " zipion", "zobj", " zipOut"], "out": ["pretty", "cn", "t", "w", "up", "aos", "can", "log", "io", "by", "str", "one", " manager", "init", "en", "conf", " sys", "oss", "OUT", "co", "ac", "net", "o", "desc", "inf", "client", "to", "print", "conn", "ln", " outs", " OUT", "gov", "ou", " Out", "cos", "go", "gt", "opt", " fmt", "on", "list", "obj", "n", "res", "cmd", "all", "cfg", "screen", " bout", "gen", " output", "msg", "dt", "ent", "os", "null", "ch", "name", "p", "writer", " abort", "ins", "group", "outs", " say", "g", "output", "ex", "set", "Out", "inner", "con", "nt", "inv", "at", "sys", "auto"], "buffer": ["paste", "memory", "bar", "row", "phrase", "binary", "buff", "table", "variable", "total", "document", "batch", "pad", "line", "block", "mem", "Buffer", "available", "history", "filter", "message", "sequence", "library", "cache", "queue", "temp", "window", "buf", "output", "iter", "page", "tree", "template", "database", "frame", "comment", "button", "command", "stack", "attribute", "append"], "in": ["gin", "info", "im", "per", "read", "nin", "oin", "mc", "get", "up", "cin", "on", "it", "pi", "or", "check", "inf", "ini", "inn", "ind", "ins", "ic", "rin", "by", "reader", "inc", "ai", "like", "bi", "from", "IN", "mm", "ex", "init", "iter", "en", "isin", "inner", "bin", "con", "input", "din", "ma", "query", "i", "form", "is", "ac", "and", "In"], "length": ["join", "full", "bow", "shift", "read", "phi", "total", "capacity", "ENGTH", "amount", "component", "character", "integer", "version", "value", "space", "count", "vector", "available", "history", "tail", "message", "sequence", "maximum", "frequency", "library", "print", "depth", "number", "needed", "padding", "height", "code", "impl", "no", "distance", "language", "volume", "string", "load", "class", "ength", "position", "present", "Length", "database", "point", "display", "angle", "size", "match", "reading", "loc", "hello", "len", "family", "type", "duration", "shape", "collection"]}}
{"id1": "1798720", "id2": "12782570", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "label": 1, "substitutes": {"save": ["install", "send", "upload", "zip", "update", " Save", "dump", "archive", "pkg", "register", "version", "aw", "release", "delete", "store", "Save", " seal", "folder", "pack", "init", "export", "data", "download", "filename", "saving", "accept"], "packageName": [" packagename", "pkgNames", "pkgKey", "packageKey", "pkgType", "PackageId", "packagename", "PackageNames", " packageKey", "pkgId", "pkgName", "packageId", "moduleId", "PackageName", "moduleNames", " packageCode", "packageNames", " packageType", " packageNames", " packageId", "PackageType", "moduleCode", "modulename", "pkgCode", "packageType", "moduleKey", "packageCode", "pkgname", "moduleName"], "fileContents": [" fileBytes", " fileItems", "packageContents", " fileValues", "fileItems", "packageContent", "byteNames", "byteContent", "fileContent", "FileBytes", "fileValues", "FileContent", "packageNames", "FileItems", "fileIngredients", "FileNames", "pageItems", "byteContents", "pageNames", "FileContents", "pageBytes", " fileIngredients", "pageContents", "byteValues", "fileBytes", "packageIngredients", "FileIngredients", " fileContent", "FileValues"], "fileNames": ["issueVaults", "fieldNumbers", "dirNames", "fileTypes", "messageNames", "fileLeaks", "moduleVaults", "fieldTypes", "resourceTypes", "fileName", "FileTypes", " fileLeaks", "fileNumbers", "issueNames", "dirTypes", " fileValues", "FileLeaks", "messageKeys", " fileName", "messageValues", "moduleNames", "fieldNames", " fileTypes", "moduleContents", "fieldContents", "fileValues", "issueName", "FileNames", "resourceNumbers", " fileVaults", " fileNumbers", "resourceValues", "fileKeys", "messageName", "FileContents", "resourceContents", "resourceNames", "FileName", "dirLeaks", "fileVaults", "dirKeys", " fileKeys", "issueContents", "moduleName", "FileKeys", "FileValues"], "dirBase": [" directoryBuilder", "dirBasic", "DIRBas", "irSet", "DirBase", "dirBas", "dirSet", "pathBasic", "folderBas", "folderBasic", "DIRBase", "DirBuilder", "directorySet", " directoryBottom", "dirBuilder", "DirBottom", " directoryBase", "pathbase", "directorybase", "DIRBottom", "dirbase", "pathBas", "irbase", "folderBase", "directoryBase", "pathBase", "directoryBas", "directoryBasic", "pkgSet", "pkgBase", "irBas", "pkgBas", "pkgbase", " directoryBas", "irBase", "folderbase", "dirBottom", "DIRBuilder", "DirBas"], "packageDir": [" packageFolder", " packageDist", "podDist", "pkgDir", "pkgRel", "podDef", " packagePath", "podD", "installDir", "packageDist", "pkgPath", "moduleFolder", " packageD", "podDir", "installDef", " packageRel", "moduleDir", "pkgFolder", "moduleDef", "packagePath", "installD", "packageRel", "moduleRel", "packageD", " packageDef", "packageFolder", "modulePath", "installDist", "pkgDef", "packageDef"], "created": ["creator", "successful", "creat", "mounted", "arted", "forced", "activated", "existent", "TED", "joined", "creation", "started", "founded", "called", "ced", "ready", "registered", "generated", "provided", "developed", "raised", "confirmed", " started", "recorded", "given", "create", "allowed", "released", "associated", "printed", "present", "installed", "reported", "Created", "checked", " generated", "filled", "defined", "made", "loaded", "locked", "added", "produced"], "currentPath": ["currentlyCh", "currentPoint", "recentName", "currentCh", " currentName", "CurrentCh", "currentlyPath", "currentFile", "CurrentName", "CurrentPoint", "currentlyName", " currentPoint", "currentParent", " currentFile", "recentPath", "recentParent", "CurrentParent", "currentName", " currentParent", "recentPoint", "CurrentPath", " currentCh", "currentlyFile", "CurrentFile"], "i": ["info", "m", "I", "oi", "y", "f", "me", "init", "ie", "them", "index", "cgi", "u", "gi", "j", "o", "pi", "it", "di", "ind", "zi", "ai", "q", "bi", "li", "key", "status", "iii", "major", "go", "im", "in", "phi", "ii", "mu", "qi", "my", "ti", "batch", "ini", "ski", "hi", "this", "v", "multi", "iy", "uri", "iu", "ip", "cli", "ij", "ki", "xi", "ei", "ji", "os", "iq", "ci", "mi", "ui", "id", "p", "ic", "g", "ex", "exp", "si", "jj", "ri", "slice", "sim", "ix", "ami", "yi", "chain", "ity"], "file": ["info", "row", "File", "ile", "FILE", "link", "dir", "table", "handler", "disk", "rule", "path", "h", "base", "parent", "name", "buffer", "port", "resource", "p", "l", "log", "f", "io", "sf", "fo", "play", "source", "set", "child", "local", "page", "template", "body", "le", "db", "pool", "comment", "header", "format", "type", "handle", "et"], "fos": ["Fo", "foes", "Fos", " foes", "ffo", "fOS", "sfos", "woses", "flos", "oow", "Foes", "wos", "floes", "flo", "ffoes", "woss", "floses", "floss", "fo", " fo", "sfOS", "fow", "Foss", " foses", "fbow", "oaos", "flaos", "sfaos", "fbos", "faos", " foss", " fOS", "ffos", "oos", "ffaos", "Faos", "foss", "foses", "woes", " fow", "fbo", "sfoss", " faos", "fbaos", "oo", "FOS"], "fileSrc": ["fileErc", "jobSri", " fileInsource", "fileSrl", "fileSRC", "fileSource", "fileInsource", "fileInssrc", "fileDci", "jobSrl", " fileSsrc", "fileSci", "jobNri", "fileInsrc", "fileEri", "fileSsrc", "fileEci", "fileNci", "fileDri", "jobNrc", "jobSci", "fileInRC", " fileInsrc", "fileNrl", " fileInssrc", "fileNrc", " fileInsRC", "fileDsrc", "fileNri", "fileDrc", "jobSrc", "fileInsRC", "jobNrl", " fileSource", "fileDrl", "fileInrc", "fileDource", "fileDRC", "jobNci", "fileSri", " fileSRC", "fileErl", "fileInource"], "fileDst": ["fileSpl", "fileSlt", "fileDcr", "FileDld", "fileNcr", "FileDnd", "fileScr", "fileDld", "fileDnd", "filednd", "FileDpl", "FileScr", "fileSot", "fileDpl", "FileDot", "fileDot", "FileSot", "fileNot", "fileDlt", "filedld", "FileDcr", "fileWpl", "fileSnd", "fileNnd", "FileDlt", "filedcr", "FileSpl", "FileSld", "fileNst", "fileWot", "filedst", "FileSst", "fileNpl", "fileWlt", "fileWst", "fileNlt", "fileSld", "FileSlt", "FileDst", "fileSst", "fileNld", "FileSnd"], "reader": ["rot", "row", "read", "ocker", "handler", "rc", "rar", "upper", "ner", "driver", "stream", "roller", "rer", "book", "iterator", "oder", "buffer", "context", "er", "resource", "runner", "readable", "r", "rl", "controller", "ader", "iter", "Reader", "ro", "rx", "dr", "inner", "Larry", "ri", "query", "review", "actor", "reading", "parser", "ler", "entry", "loader", "author", "rr"], "writer": ["editor", "adder", "creator", "storage", "later", "w", "read", "table", "handler", "variable", "document", "wright", "driver", "stream", "worker", "maker", "store", "iterator", "client", "buffer", "runner", "riter", "flush", "print", "wrapper", "writing", "report", "write", "service", "window", "console", "function", "test", "user", "order", "iter", "Reader", "caster", "operator", "writers", "word", "server", "wire", "player", "outer", "query", "walker", "draw", "manager", "ter", "Writer", "println", "parser", "format", "loader", "entry", "liner", "browser", "builder"], "line": ["record", "LINE", "row", "detail", "column", "link", "sample", "rule", "eline", "range", "inline", "block", "ole", "valid", "cell", "message", "Line", "sequence", "port", "l", "print", "nl", "kin", "number", "source", "lined", "date", "code", "node", "ln", "pe", "user", "stroke", "entity", "lin", "page", "string", "style", "word", "continue", "edge", "point", "le", "frame", "comment", "header", "entry", "ine", "label", "text", "chain", "liner"]}}
{"id1": "22708533", "id2": "6866575", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": [" copyDocumentAsFile", " copyDocumenttoUrl", " copyDocumentFromURI", " copydocumenttoFile", " copyDocumentFromFile", " copyDocumentToURI", " copyDocumentToFile", " copyDocumentFromURL", " copydocumentToUrl", " copyDocumenttoFile", " copydocumenttoURI", " copydocumentToURI", " copydocumenttoURL", " copyDocumentAsURL", " copyDocumentAsUrl", " copyDocumentFromUrl", " copyDocumentAsURI", " copydocumentToFile", " copyDocumentToUrl", " copyDocumenttoURI", " copydocumentToURL", " copydocumenttoUrl", " copyDocumenttoURL", " copyDocumentToURL"], "file": ["full", "File", "ile", "FILE", "sample", "table", "where", "document", "rule", "path", "default", "base", "valid", "check", "name", "message", "image", "resource", "log", "f", "doc", "source", "local", "from", "origin", "string", "title", "work", "place", "input", "le", "fil", "data", "filename", "command", "attribute"], "target": ["join", "project", "update", "link", "table", "back", "component", "host", "top", "base", "scope", "home", "valid", "this", "arg", "to", "Target", "print", "layout", "source", "window", "select", "rel", "ARGET", "local", "replace", "location", "origin", "dest", "pattern", "template", "alias", "root", "arget", "view", "remote", "result"], "is": ["sis", "ms", "isl", "ci", "im", "bs", "isa", "us", "vs", "mi", "lis", "ios", "has", "it", "its", "ism", "isi", "isc", "tis", "es", "ns", "iss", "ists", "cs", "ains", "ins", "mos", "isf", "bits", "ois", "dis", "fs", "mis", "iris", "nis", "ip", "rs", "isin", "si", "ics", "ri", "\u00eds", "ris", "ys", "iso", "xs", "oss", "i", "isal", "abs", "IS", "Is", "vis", "ais", "ims", "bis", "ir", "est", "obs"], "os": ["Os", "mot", "ms", "ox", "pos", "ros", "eps", "ones", "bs", "oses", "ot", "us", "oin", "o", "asis", "css", "ios", "aos", "osi", "ss", "tes", "none", "ost", "oS", "oes", "es", "ns", "uts", "ts", "ose", "ows", "ins", "mes", "mos", "io", "out", "ori", "los", "acs", "ols", "oos", "ks", "bos", "ops", "oss", "osa", "sys", "des", "nos", "oa", "OS", "bis", "cos", "dos", "ps", "et", "obs"], "url": ["domain", "re", "ur", "t", "http", "link", "https", "ls", "host", "cp", "address", "name", "client", "l", "uri", "f", "r", "nl", "service", "conn", "str", "n", "rel", "mount", "user", "location", "ssl", "con", "char", "Url", "web", "ul", "ll", "channel", "job", "open", "cert", "URL", "net"], "connection": ["t", "opening", "link", "close", "c", "document", "ion", " Connection", "creation", "character", "reference", "cone", "condition", "established", "Connection", "client", "resource", "l", "uri", "pointer", "service", "conn", "number", "n", "still", "application", "using", "con", "position", "network", "database", "relation", "session", "communication", "city", "connect", "description", "closure", "channel", "response", "entry", "generation", "open", "command", "result", "net"]}}
{"id1": "13414771", "id2": "3756429", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encriptPassword": [" descryptKey", " descriptKey", " desizeField", " descriptPassword", "EnribeField", " descryptPassword", "EncriptPassword", "EncriptKey", "EnribePassword", " desizeAuth", "EncriptAuth", "EnribeAuth", " descriptAuth", " desribeField", " descryptField", " desribeKey", " desizeKey", "EncriptField", " descryptAuth", " desribePassword", " descriptField", "EnribeKey", " desribeAuth", " desizePassword"], "passwd": ["paswd", "asswd", " password", "defphrase", "pw", "passw", "assw", "mailword", "passphrase", " passw", "password", "pasw", " passsword", "defwd", "pword", "passsword", "pwd", "mailw", "defw", "assword", "psword", "pasword", "defword", "mailphrase", "mailwd", "assphrase"], "md": ["mod", "m", "ms", "pd", "df", "ld", " MD", "managed", "mk", "dh", "mc", "hm", "pm", "add", "desc", "MD", "di", "ind", "rm", "cd", "mn", "mt", "od", "bd", "mb", "mask", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "td", "ds", "pdf", "der", "nt", "ma", "mail", "hd", "at", "red", "mo", "down", "and", "dd", "d"], "hash": ["hex", "bh", "ah", "sample", "mac", "ssh", "h", "oh", "score", "has", "uh", "ash", "ashed", "check", "sh", "sq", "filter", "message", "kernel", "mass", "password", "trust", "hidden", "cache", "mask", "proof", "sha", "Hash", "hed", "sum", "checked", "hd", "her", "key", "rh", "shadow"]}}
{"id1": "21092340", "id2": "19096138", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToHariver", "addInArchFile", "addInHariver", "addToArchFile", "addToExiver", "addToZipiver", "addToZipFile", "addInArchiver", "addToArchZip", "addToZipive", "addToHarive", "addInHarZip", "addInArchive", "addToExive", "addToExFile", "addToHarZip", "addInHarFile", "addToExZip", "addToHarFile", "addToZipZip", "addInHarive", "addToArchiver", "addInArchZip"], "pod": ["project", "module", "ad", "ack", "disk", "table", "archive", "poll", "pkg", "component", "pick", "top", "pad", "check", "device", "cp", "message", "p", "post", "spec", "od", "report", "op", "proc", "ods", "start", "pc", "pack", "body", "Pod", "zone", "point", "task", "policy", "job", "volume", "wp"], "podArchiveOutputStream": ["podArchiveoutputStream", "podArchiveOUStream", "podArchiveResourceStream", "podArchiverInputForm", "podArchiveOUForm", "podArchiverInputPoint", "podArchiveStreamSync", "podArchiveEntryPoint", "podArchiverOutputStream", "podArchiverInputStreamer", "podArchiveInputStreamer", "podArchiverOutputPoint", "podArchiveResourcestream", "podArchiveInputSync", "podArchiveOutputForm", "podArchiveoutputStreamer", "podArchiveMainSteam", "podArchiveOutputSteam", "podArchiverInputContext", "podArchiveOutputMap", "podArchiveOUSync", "podArchiveOutputSync", "podArchiverOutputMap", "podArchiveInputStream", "podArchiveEntryStream", "podArchiveMainStreamer", "podArchiveEntrySteam", "podArchiveOutSteam", "podArchiveoutputForm", "podArchiveInputPoint", "podArchiveOutputPoint", "podArchiveResourceSteam", "podArchiveStreamForm", "podArchiveStreamStream", "podArchiverOutputStreamer", "podArchiverOutputForm", "podArchiverOutputContext", "podArchiveOutStream", "podArchiveOutPoint", "podArchiveOUMap", "podArchiveInputSteam", "podArchiveInputstream", "podArchiveOutstream", "podArchiverInputStream", "podArchiveOutputContext", "podArchiverInputSteam", "podArchiveInputContext", "podArchiverInputSync", "podArchiveMainStream", "podArchiveOutputstream", "podArchiveInputForm", "podArchiverOutputSteam", "podArchiveStreamMap", "podArchiverInputMap", "podArchiveoutputSteam", "podArchiveMainForm", "podArchiveOutputStreamer", "podArchiverInputstream", "podArchiveResourceContext", "podArchiverOutputstream", "podArchiveInputMap", "podArchiverOutputSync", "podArchiveOutContext"], "filename": ["NAME", "upload", "binary", "FILE", "fn", "jpg", "archive", "FN", "fp", "path", "url", "username", "prefix", "png", "version", "nm", "release", "name", "nil", "message", "p", "directory", "resource", "ename", "uri", "folder", "stem", "output", "txt", "location", "title", "string", "original", "kl", "fil", "names", "ame", "latest", "println", "description", "file", "Filename", "subject", "family", "key"], "source": ["info", "src", "sql", "sample", "SOURCE", "component", "get", "stream", "ser", "store", "use", "address", "iterator", "context", "image", "resource", "sequence", "spec", "password", "seed", "service", "proc", "select", "ource", "from", "start", "copy", "inner", "style", "template", "supp", "input", "body", "force", "Source", "file", "view", "loader", "series", "shell"], "entry": ["record", "ace", "row", "zip", "link", "Entry", "archive", "component", "sheet", "se", "line", "or", "ment", "ce", "system", "cell", "connection", "resource", "obj", "element", "log", "enter", "cue", "card", "quick", "set", "good", "ie", "word", "char", "nt", "tmp", "query", "ry", "task", "comment", "data", "file", "channel", "job", "key", "book", "ent", "attribute"]}}
{"id1": "471804", "id2": "6558022", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersioncheck", "doVersionscheck", "doDateCheck", "doDateFix", "doDatecheck", "doVersionsFix", "doVersionsUpdate", "DoVersioncheck", "doLicensecheck", "DoDatecheck", "doLicenseCheck", "DoDateFix", "DoVersionCheck", "DoDateUpdate", "doVersionsCheck", "DoDateCheck", "doLicenseFix", "doDateUpdate", "DoVersionUpdate", "DoVersionFix", "doVersionFix", "doVersionUpdate", "doLicenseUpdate"], "view": ["iew", "row", "http", "hl", "update", "table", "document", "engine", "component", "open", "get", "host", "util", "block", "check", "blade", "cell", "client", "this", "buffer", "help", "image", "v", "views", "context", "report", "print", "layout", "call", "doc", "wrapper", "out", "q", "window", "console", "controller", "see", "widget", "View", "page", "tree", "VIEW", "input", "server", "show", "index", "query", "review", "manager", "web", "html", "tv", "cv", "form", "model", "file", "subject", "self", "display", "eye", "browser"], "url": ["pl", "lr", "ur", "bel", "null", "oul", "http", "hl", "link", "b", "path", "github", "ls", "host", "gl", "socket", "address", "id", "client", "v", "uri", "l", "f", "sl", "r", "nl", "log", "rl", "str", "org", "date", "rel", "mount", "location", "language", "ssl", "string", "char", "json", "Url", "web", "ul", "html", "file", "loc", "lb", "ll", "dl", "URL", "browser"], "in": ["gin", "info", " IN", "b", " din", "In", "stream", "cin", "inf", "inn", "ain", "mn", "ins", "rin", "l", "f", "reader", "kin", "inc", "out", "source", "n", "ln", "IN", "init", "isin", "inner", "input", "sin", "din", "body", "asin", "i", "mat", "file", "is", "vin"], "bin": ["gin", "bg", "spin", "binary", "buff", "b", "thin", " din", " bins", "ebin", "bn", "cin", "stock", "mem", "inn", "buffer", "rin", "mon", "by", "reader", "sam", "obin", "conn", "out", "cache", "ln", "cos", "bi", "bl", "local", "win", "bur", "rb", "inner", "lib", "con", "sin", "din", "abin", " Bin", "bed", "pipe", "file", "ran", "len", "loader", "nb"], "line": ["record", "LINE", "row", "column", "err", "link", "sample", "lo", "path", "eline", "range", "ls", "inline", "base", "se", " Line", "block", "ice", "ide", "part", "store", "level", "cell", "Line", "port", "l", "log", "print", "lines", "one", "code", "ln", "no", "cmd", "iter", "cat", "lin", "page", "string", "style", "state", "word", "section", "char", "body", "point", "le", "el", "trace", "frame", "comment", "file", "lane", "channel", "job", "entry", "field", "ine", "text", "chain", "liner", "col", "load"], "version": ["info", "project", "usage", "update", "VER", "vision", "versions", "ion", "VERSION", "key", "ver", "value", "release", "python", "scale", "name", "client", "v", "image", "resource", "sequence", "spec", "serial", "feature", "number", "license", "date", "video", "vers", "test", "language", "volume", "string", "title", "virtual", "position", "iso", "index", "Version", "software", "river", "tag", "hash", "latest", "description", "form", "match", "major", "translation", "format", "type", "status", "command", "browser"], "build": ["make", "full", "project", "install", "other", "update", "binary", "built", "b", "link", "where", "old", "util", "ver", "add", "struct", "be", "release", "building", "use", "unit", "last", "log", "print", "uild", "dist", "th", "date", "test", "round", "builder", "ward", "arch", "dev", "load", "style", "lib", "ble", "work", "Build", "boost", "develop", "tag", "db", "hash", "latest", "fail", "match", "ship", "bug", "bor", "hold"]}}
{"id1": "5707205", "id2": "18097962", "code1": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"run": ["process", "go", "dial", "install", "exec", "submit", "func", "check", "evaluate", "runner", "unit", "background", "call", "scan", "running", "apply", "Run", "test", "flow", "start", "work", "launch", "loop", "task", "execute", "thread"], "dbHelper": ["DBHelper", "bdAdapter", " dbhel", "DbHelp", "DBHel", "mbManager", "bdHelper", " dbHel", "DBManager", "dbManager", "DbAdapter", "DbHelper", "dbAdapter", " dbHelp", "mbHelper", "dbhel", "DbManager", "dbHelp", " dbAdapter", "bdHelp", "mbHel", "DBhel", "mbhel", " dbManager", "bdManager", "dbHel"], "notifyId": [" notifierid", "notifierCount", "noteifyid", " notifyID", "notificationid", "notifyID", " notifierCount", "notificateid", "notifyid", " notifierID", "notificateById", "notifyById", " notifierId", "notifiedId", "notificateId", "notificateCount", "noteifyById", "notifierId", "noteifyId", "noteifierid", "notifiedid", "notificationCount", "noteifierId", "notifiedID", "notifyCount", "noteifierById", " notifyid", "notificationID", "noteifierCount", "notifierById", "notificationById", "notifiedCount", " notifyCount", "notifierID", "notifierid", "notificationId", "noteifyCount"], "host": ["domain", "hex", "row", "null", "http", "https", "path", "h", "url", "base", "version", "value", "ost", "address", "system", "name", "id", "context", "port", "client", "password", "here", "conn", "cert", "source", "str", "Host", "node", "arch", "location", "ip", "string", "container", "pattern", "instance", "server", "nick", "index", "target", "hash", "addr", "localhost", "chain", "key", "handle", "status", "dir"], "sp": ["sc", "spe", "pp", "esp", "sch", "SF", "space", "sh", "sq", "cp", "isp", "pb", "spr", "sf", "sm", "asp", "lp", "sv", "Sp", "sb", "osp", "ssl", "si", "jp", "bp", "sr", "SP", "sk", "mp", "tp", "bsp", "ap", "ps"], "userAgent": ["useagent", "usernameAgent", "useragent", "UserAgent", "userProduct", "usernameProduct", "usernameAg", " userAg", "UserProduct", "browserAgent", "useAgent", "useAg", "Useragent", "browseragent", "UserAg", "usernameagent", "userAg", " userProduct", " useragent", "browserAg"], "ahc": ["ahlc", "asyc", " ahbc", "avc", "avm", "ahl", "ahd", "ohci", "Ahm", " ahlc", "ohd", "asylc", "Ahc", "ohl", "ahci", "Ahd", " ahci", "Ahl", "ohbc", "avd", "avl", "ahbc", "ohm", "ohlc", "asybc", "asyci", "ahm", "ohc"], "uri": ["hog", "domain", "details", "umi", "u", "ur", "api", "http", "parse", "URI", "phi", "link", "archive", " URI", "component", "path", "upper", "url", "du", "range", "util", "prefix", "ini", "ui", "address", "iterator", "menu", "resource", "unit", "direction", "uu", "io", "folder", "route", "term", "iri", "uint", "nu", "basic", "uid", "iu", "ip", "location", "init", "origin", "thus", "ri", "doi", "iso", "slice", "query", "via", "html", "addr", "form", "auto", "ilo", "subject", "description", "uni", "filename"], "norm": ["non", "cn", "cmp", "err", "im", "intern", "orm", "util", "url", "nv", "range", "nm", "mem", "lu", "common", "or", "normal", "uv", "mn", "prim", "io", "Norm", "mb", "sync", "sam", "transform", "term", "low", "ori", "n", "res", "np", "nu", "nn", "om", "exp", "init", "iam", "def", " norms", "Normal", "ri", "irm", "iso", "nom", "nor", "query", "known", "form", "san", "NOR", "human", "rm"], "get": ["send", "exec", "read", "update", "parse", "give", "ge", "url", "GET", "check", "Get", "need", "grab", "use", "got", "resource", "post", "call", "service", "put", "request", "like", "getting", "set", "find", "create", "pull", "show", "next", "query", "gm", "draw", "gets", "execute", "cgi", "handle"], "response": ["process", "answer", "detail", "successful", "resp", "document", "zero", "object", "onse", "success", "raw", "results", "block", "version", "client", "message", "connection", "image", "resource", "sequence", "yes", "report", "request", "respond", "still", "res", "application", "respons", "output", "tree", "reply", "present", "server", "Response", "body", "next", "json", "relation", "frame", "description", "header", "channel", "entry", "status", "result", "collection"], "entity": ["info", "person", "note", "email", "empty", "orm", "document", "security", "object", "component", "util", "oe", "error", "activity", "id", "name", "image", "obj", "em", "pe", "user", "profile", "metadata", "encrypted", "instance", "iso", "body", "json", "Entity", "ITY", "el", "xml", "status", "comment", "auto", "model", "entry", "type", "ent", "ity", "event"], "baos": [" bao", "BAo", "Baos", "BAos", "boo", " baOS", "Baoss", "poos", "vaos", " baol", "Bao", " baoss", "baoss", "bool", "bao", "BAis", "vaOS", "BAOS", "vais", "boos", "poo", " bais", "vao", "Baol", "bois", "poOS", "boOS", "bais", "booss", "baol", "pois", "baOS"], "data": ["ret", "info", "what", "details", "row", "ata", "done", "table", "DATA", "url", "batch", "success", "results", "value", "valid", "rew", "error", "message", "buffer", "sequence", "resource", "to", "content", "cache", "action", "rel", "debug", "output", "dat", " DATA", "encrypted", "pattern", "partial", "input", "area", "next", "json", "query", "trace", "html", "msg", "format", "entry", "display", "text", "command", "result"], "i": ["info", "ji", "m", "ci", "u", "t", "im", "in", "phi", "j", "gi", "ii", "gu", "qi", "my", "I", "us", "fire", "mi", "o", "ti", "batch", "pi", "it", "di", "ui", "hi", "y", "multi", "v", "ic", "io", "ai", "q", "x", "ori", "me", "bi", "set", "ip", "cli", "init", "si", "ie", "PI", "index", "sim", "li", "ix", "xi", "ami", "eu", "key", "chain"], "p": ["rep", "perm", "m", "re", "t", "pp", "c", "pkg", "e", "pg", "cp", "php", "pb", "f", "patch", "r", "op", "proc", "q", "pat", "np", "n", "lp", "vp", "ip", "pc", "pa", "pt", "P", "pattern", "jp", "par", "bp", "pr", "type", "tp", "wp", "ps", "d"], "sysMillis": ["sysMillIs", "sysMillus", "sysMsIs", "systemMsIs", "sysMinies", "sysMillies", "sysMicroIs", "sysMsis", "sysMicrois", "sysMinis", "sysMsus", "sysMicroies", "sysMicrous", "systemMillus", "systemMsis", "sysMinus", "systemMsies", "sysMinIs", "systemMillIs", "systemMsus", "sysMsies", "systemMillies", "systemMillis"], "errorOccurred": ["errorAccurring", "errorAccured", "errorIncurred", "errorOccur", "erroroccurring", "Erroroccured", "errorOccurring", " errorOccured", "errorOccured", " erroroccurring", "ErrorOccured", "erroroccurred", "ErrorOccur", "errorAccurred", "erroroccured", "Erroroccurrence", "errorAccurrence", "errorIssurred", " erroroccurred", "ErrorOccurrence", "errorIncur", "errorOccurrence", " erroroccurrence", "errorIssurring", "Erroroccur", "errorIssurrence", " errorOccurring", " errorOccurrence", "errorIncurrence", "errorIncured", "Erroroccurred", " erroroccured", "ErrorOccurred", "erroroccur", "erroroccurrence", "errorIssured"]}}
{"id1": "14001795", "id2": "8754809", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyoverWarFile", "copyoverWarFiles", "copyOverTarFilename", "copyOverWarFiles", "copyoverwarFiles", "copyOverwarFiles", "copyOverwarfile", "copyOverTarfile", "copyOverTarFile", "copyOverTarFiles", "copyoverwarFilename", "copyoverWarFilename", "copyOverwarFile", "copyOverWarFilename", "copyOverWarfile", "copyoverWarfile", "copyoverwarfile", "copyoverwarFile", "copyOverwarFilename"], "dir": ["dial", "re", "zip", "disk", "df", "old", "ld", "mk", "path", "coll", "url", " d", "add", "desc", "di", "del", "parent", "ind", " Dir", "name", "cd", "directory", "md", "direct", "log", "Dir", "doc", "folder", "out", "DIR", "dist", "cur", "ir", "window", "res", "rel", "dm", "iter", "local", "good", "dat", "dr", "def", "dep", " directory", "tmp", "div", "dim", "db", "addr", "form", "file", "fd", "fin", "dl", "loc", "vol", "wd", "dd", "d"], "ff": [" cf", "ffe", "ft", "fact", " ref", "df", "buff", " eff", "ld", "fp", "F", "aft", " af", "UFF", "bf", "alf", "xff", "wind", "cond", "filter", "aff", " df", " def", "uf", "mt", "fl", "FF", "off", "sf", "fx", "cf", "fc", " aft", "ck", "lf", "ef", " FF", "eff", "cb", "uff", "iff", "af", "file", "fd", "tf", "fg", "xf"], "files": ["faces", "styles", "frames", "bees", "features", "jobs", "forms", "Files", "resources", "rows", "ls", "facts", "balls", "issues", "ails", "values", "flows", "items", "uploads", "lines", "fields", "members", "les", "fs", "assets", "objects", "plates", "keys", "ports", "leases", "iles", "ories", "names", "parts", "tests", "file", "models", "days", "mas", "images", "ions"], "f": ["m", "ft", "t", "w", "fab", "b", "c", "fw", "fp", "F", "h", "a", "bf", "alf", "fm", "e", "fe", "v", "p", "uf", "l", "k", "fl", "rf", "sf", "n", "fs", "g", "cf", "fc", "exp", "def", "lf", "fac", "i", "elf", "file", "tf", "fd", "xf", "fa", "col", "d"], "newFile": ["NewPage", "uniquefile", "uniquePage", "newFiles", "NEWfile", " newfile", "NewNode", " newPlace", "newNode", "secureFile", "newKey", "anotherFile", " newFiles", "oldFilename", "oldfile", "newsKey", "newFilename", "newsfile", " newFilename", "anotherfile", "NewFilename", "uniqueFile", "NewFiles", "Newfile", "anotherFiles", "NewFile", "newsFile", "anotherPlace", "newPage", "oldFile", "secureKey", "securefile", "NEWPage", "NewPlace", "newPlace", "NewKey", "NEWFile", "newfile", "uniqueNode", "NEWNode"], "fi": ["ci", "phi", "ii", "fp", "mi", "ti", "ifa", "bf", "pi", "isi", "di", "ini", "fe", "zi", "flo", "uf", "io", "Fi", "sf", "iu", "cf", "ni", "bi", "afi", "si", "ife", "lf", "ki", "ri", "li", "i", "FI", "fr", "fd", "fa", "fin"], "fo": ["po", "hea", "tif", "sty", "jo", "ti", "o", "opa", "oe", "eto", "hi", "ow", "tto", "zo", "flo", "bo", "tk", "ato", "sf", "uo", "ott", "cf", "eno", "ko", "ki", "fam", "ph", "oooo", "vo", "te", "zz", "wo", "wt", "tf", "co", "mo", "xf", "oo", "FO", "ho"]}}
{"id1": "12146394", "id2": "11049257", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["md4Crypt", " Md5crypt", " Md3Crypt", " Md3Enc", " Md3crypt", "md5crypt", "md2Enc", "md5Enc", " Md5Enc", "md4crypt", "md4Enc", "md3Enc", "md3Dec", " Md3Dec", "md2crypt", "md5Dec", " Md5Crypt", "md2Dec", "md4Dec", "md3crypt", " Md5Dec", "md2Crypt", "md3Crypt"], "key": ["piece", "pair", "version", "none", "block", "address", "icon", "y", "by", "x", "str", "code", "user", "keys", "input", "word", "char", "index", "json", "prime", "poly", "hash", "box", "chain", "type", "net", "note", "table", "default", "ice", "client", "er", "to", "password", "source", "act", "iv", "air", "query", "ke", "form", "blow", "Key", "ek", "length", "link", "ion", "check", "ce", "list", "change", "gem", "test", "ip", "string", "KEY", "root", "file", "ca", "text", "ace", "item", "null", "phrase", "mac", "host", "base", "prefix", "value", "name", "id", "message", "p", "image", "k", "seed", "window", "no", "ex", "start", "state", "token", "sum", "data", "entry", "ey", "policy", "cert", "event", "any"], "salt": ["piv", "cig", "shet", "slash", "salted", "slalt", "halt", "siv", "calt", "Sash", "psALT", " sig", "seALT", "hALT", "Sil", "sass", "psalt", "seash", " sint", " sALT", "Sert", "slALT", "palt", "sALT", "pALT", "unsalt", "Save", " sass", "sint", " sol", "Salt", "unsalted", "hig", " salted", "unsALT", "sol", "hiv", "tsALT", "slil", "psass", "tsol", "sash", "sert", " sert", "save", "Sig", "unsig", "Sass", "Sol", " shet", "tsalt", "Sint", "chet", "sil", " save", "psave", "Siv", "sealt", "tsave", "SALT", "cass", "sig", "seil", "pig", "Salted"], "_md": ["_____mp", "_mand", " _mand", "_____mg", "_mg", "_mb", "_dm", "___mn", "_MD", " _cmd", "___MD", "_mn", "_mp", "_____dm", " _MD", "_df", "_____mb", "_sd", " _dm", "_cmd", "___dm", "_____mn", "_____md", " _sd", "___md", " _mn", " _df", "_mk"], "md2": ["mode2", "md6", "md5", "mb5", "mand4", "sd1", "sd2", "mdTwo", " md52", "mand5", "mode4", "ddTwo", " md4", "cmdto", "mdtwo", " mdto", "cmdtwo", " md5", "dd5", "rm2", "mb2", "cmd5", "md52", "cmd6", "sdTwo", "mand2", "cmd2", " md1", "mb4", "cmd4", "ddtwo", "dd2", "mdto", "rm5", "dd4", "rm4", "modetwo", "md4", "mb52", "mandto", "dd1", "mode5", " mdTwo", "md1", "cmd52", " md6", "sd5", "rm6"], "abyFinal": ["inessInitial", "uyFinal", "aberTotal", "washingAll", "boatInitial", "sayUpdated", "abyDual", "phiDual", "abyFin", "BabyLast", "abyZero", "agusUpdated", "aberFinal", "andyAll", "uffyFinal", "abyAll", "BabyZero", "sayFixed", "uyInitial", "abyFull", "sayFinal", "abyTotal", "washingDual", "washingLast", "BabyFinal", "phiReal", "washingFinal", "uffyFixed", "agusFinal", "aberInitial", "alyAll", "sayTotal", "seatFin", "andyComplete", "boatReal", "BabyFin", "boatDual", "seatInitial", "washingFin", "uffyUpdated", "washingFull", "satFin", "sayReal", "alyFixed", "washingReal", "alyComplete", "uyFin", "washingComplete", "sayInitial", "andyFinal", "abyReal", "alyFinal", "satFinal", "phiFull", "inessFixed", "seatTotal", "abyUpdated", "inessFinal", "agusTotal", "seatFinal", "abyFixed", "abyInitial", "satZero", "aberFin", "inessReal", "abyLast", "uyTotal", "uffyTotal", "boatFixed", "washingZero", "satLast", "agusFixed", "phiFinal", "abyComplete", "boatFinal", "washingFixed", "boatFull", "andyFixed"], "n": ["dn", "nc", "non", "cn", "m", "t", "note", "z", "nr", "w", "c", "un", "syn", "o", "nan", "na", "gn", "nm", "ng", "count", "ns", "name", "pn", "v", "p", "y", "mn", "l", "k", "nl", "number", "yn", "N", "out", "np", "g", "nu", "no", "nn", "ni", "ln", "an", "sn", "en", "all", "con", "network", "nt", "num", " N", "nor", "names", "ul", "ren", "el", "norm", "size", "nw", "net", "len", "ne", "nb", "d"], "j": ["ji", "im", "z", "ia", "b", "I", "it", "y", "kj", "v", "obj", "jit", "p", "k", "J", "out", "q", "x", "ja", "js", "oj", "g", "bi", "uj", "si", "jj", "ij", "jp", "dj", "jl", "br", "index", "json", "ix", "at", "aj", "jc", "bj", "jump"], "i": ["ji", "info", "m", "ci", "u", "ia", "phi", "ii", "gi", "gu", "c", "qi", "I", "mi", "ti", "pi", "it", "di", "ini", "hi", "p", "y", "multi", "v", "ic", "l", "k", "ai", "iu", "ni", "bi", "ip", "cli", "init", "si", "ij", "ri", "ki", "li", "ix", "ami", "xi", "ei"], "sbPasswd": ["sbDefw", "sbPushwd", "cbPassenc", "sbDefsword", "cbMassess", "sbMassenc", "sbPasssword", "sbPASSwd", "cbPassrc", "sbAsswd", "sbDefwd", "sbMasswd", "ebChainWD", "sbPassweight", "ebChainword", "sbpasswd", "sbPushrc", "cbPasswd", "ebPassWD", "sbChainword", "sbMassess", "sbPushgrad", "sbWorkw", "sbWorkwd", "cbPassw", "sbGuWD", "sbPASSgrad", "sbMassWD", "ebPassweight", "sbDefweight", "cbMassenc", "cbpasswd", "zbDefw", "zbPassweight", "cbPassWD", "sbpassgrad", "sbGuwd", "sbpasssword", "sbPushw", "sbChainwd", "sbPassess", "ebChainweight", "sbPushess", "cbpassw", "sbChainWD", "sbAssword", "ebPassword", "sbAssWD", "sbPassrc", "sbpassw", "sbWorksword", "sbWorkweight", "sbPushenc", "ebPasswd", "sbGuess", "cbPassgrad", "sbPASSrc", "zbPasswd", "sbPASSw", "cbpassgrad", "sbpassrc", "sbPassgrad", "sbPassw", "sbPassword", "ebChainwd", "cbMassWD", "sbPushWD", "sbpassweight", "sbAssweight", "sbChainweight", "zbDefsword", "cbpassrc", "cbMasswd", "sbPassWD", "zbDefwd", "zbPassw", "cbPassess", "zbPasssword", "zbDefweight", "sbPassenc", "sbGuenc"], "md3": ["m43", "md30", " md43", "MD3", "mb5", "md5", "dm3", "md43", "MD5", "mb43", "mt30", "cmdThree", " md4", "m3", "cmd33", "cmd03", "mt43", " md5", "rmThree", "mt33", "md03", "cmd5", "cmd43", "cmd2", "mt2", "dm33", "mb4", "cmd3", "MD2", "dm03", "dm5", "mdThree", "md33", "mt03", "mt3", "rm3", "mb3", "rm5", "cmd30", "md4", "mtThree", "MD43", "m4", "mt5", "rm30", "m5"]}}
{"id1": "20920051", "id2": "8150996", "code1": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"copyTo": [" copyPhoto", "copyOver", "copyFiles", "opyDir", "transferTo", "copyDir", "opyOver", "copyPhoto", "opyPhoto", " copyFile", "moveDir", "opyTo", "movePhoto", " copyOver", "transferFrom", " copyDir", "CopyFrom", "transferFile", " copyFrom", "transferFiles", " copyFiles", "CopyFiles", "copyFile", "CopyFile", "CopyTo", "copyFrom", "moveTo", "moveOver"], "source": ["src", "details", "SOURCE", "empty", "get", "se", "none", "part", "sf", "from", "init", "ie", "input", "oss", "subject", "shell", "sql", "note", "sample", "old", "raw", "unit", "service", "scan", "select", "site", "visible", "search", "style", "template", "sin", "query", "config", "Source", "status", "component", "secure", "scope", "sort", "flat", "store", "use", "spec", "sl", "iter", "file", "ace", "null", "base", "parent", "sp", "name", "id", "image", "resource", "s", "seed", "ource", "local", "start", "copy", "origin", "missing", "original", "target", "pse", "size", "entry"], "dest": ["tom", "src", "null", "w", "orig", "d", "Dest", "opt", "end", "path", "ref", "it", "desc", "trans", "parent", "name", "dc", "this", "port", "rest", "master", "to", "deg", "doc", "out", "dist", "folder", "pro", "test", "st", "good", "txt", "dat", "origin", "dev", "result", "nt", "tmp", "target", "nom", "des", "loc", "self", "est", "dir", "del"], "temp": ["make", "porary", "mod", "pl", " temporary", "null", "t", "orig", "w", "zip", "alt", "empty", "fake", "mk", "path", "tar", " tmp", "EMP", "parent", "cp", "buffer", "p", "mt", "tab", "out", "emp", " Temp", "stem", "em", "test", "txt", "mm", "unt", "local", "dat", "template", "Tem", "tmp", "rem", "tm", "tem", "mp", "Temp", "por", "rm", "pt"], "sel": ["pl", "nav", "sc", "zh", " sl", "ael", "selected", "kel", "syn", "ls", "El", "se", "sen", "sels", "ml", "ser", "cel", "ial", "cell", "selection", "sl", " lic", "nl", "ele", "fl", "rl", "cl", "sol", "lv", "select", "Se", "sv", "nel", "Sel", "lf", "kl", "le", "rol", "elect", "el", "mil", "fol", "so", "sil", "del"], "tempDest": ["mmLoc", "mmTemp", "poraryDe", " temporaryTemp", "tempDec", " temporarydest", "tempDir", "poraryDest", "poraryTemp", "poraryDec", "tempNeg", "temdest", "tempTemp", " tempTemp", " tempDir", "ptNeg", " tempdest", "poraryLoc", "temDe", " temporaryDest", "destLoc", "destTemp", " tempDe", "destDec", "destDest", "porarydest", "mmDec", "tempLoc", " tempNeg", "poraryDir", "temDir", "ptTemp", "mmDest", "ptdest", " temporaryNeg", "tempDe", "temDest", "tempdest", "ptDest"], "sourceCh": ["seedChan", " sourceCor", " sourcech", " sourceCH", "startComp", "srcComp", "srcch", "srcCol", "ourceCh", "startCH", "statusCol", "sourceCr", "srcColl", "startCol", "ourceComp", "samplech", "sampleComp", "srcCH", "ourceCH", "sourceCor", "sourceComp", "sourceColl", "srcCh", "ourceChan", "statusCh", "sourceCH", " sourceCol", "srcCor", "seedCh", " sourceCr", " sourceComp", "ourceColl", "statusCH", "srcChan", "sampleCor", "statusCr", "sourceCol", "sampleCh", "sourcech", "startCh", "seedCol", "ourceCr", "ourceCol", "sourceChan", "seedColl"], "destCh": ["destCl", "destC", "tempCl", "usrChan", " destChar", "targetCh", "estCl", "tempCol", " destC", "targetChan", "usrChar", "destChan", " destDest", "restChan", "targetC", "tempChan", " destCl", "tempC", "destDest", "destCol", "restC", " destCol", "targetChar", "tempCh", "usrCh", "estC", "estDest", "destChar", "restCol", " destChan", "usrC", "restCh", "estCh"]}}
{"id1": "310182", "id2": "14619453", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"convert": ["conVERT", "compverts", "CONVERT", "unversion", "confer", "Confer", "Converted", "unverts", "consverting", "Conversion", "CONversion", "converting", "compvert", "unfer", "ConVERT", "consversion", "converted", "unprocess", "converts", "CONvert", "Convert", "CONverting", "CONfer", "CONverted", "Converts", "unverted", "compprocess", "unvert", "conprocess", "compversion", "Converting", "consVERT", "consvert", "conversion", "Conprocess"], "src": ["sit", "RC", "sc", "ur", "upload", "orig", "hl", "http", "ebin", "SOURCE", "attr", "rc", "cont", "pkg", "href", "path", "url", "host", "stream", "func", "SourceFile", "its", "cc", "ser", "sq", "rest", "s", "ins", "uri", "req", "buster", "cur", "dist", "source", "str", "scan", "rel", "ource", "st", "from", "rs", "start", "txt", "rx", "iv", "input", "img", "usr", "sin", "sr", "config", "sys", "addr", "Source", "scene", "inst", "file", "loc", "ipl", "filename"], "dest": ["gin", " orig", " dst", "orig", "disk", "Dest", "table", "tif", " Destination", "port", "rest", "write", "temp", "dist", "source", "test", " Dest", "txt", "dat", "img", " destinations", "target", "mat", "foreign", " destination", "est", "result", "dir"], "in": ["m", "sql", "ad", "b", "up", "stream", "cin", "inf", "inn", "ind", "ins", "l", "rin", "io", "reader", "r", "source", "res", "st", "from", "IN", "en", "isin", "inner", "bin", "input", "din", "i", "el", "as", "file", "is", "ar", "serv", "In", "d"], "p": ["rep", "pl", "m", "t", "per", "parse", "pd", "j", "b", "pp", "c", "pkg", "fp", "h", "pm", "pi", "it", "part", "pg", "cp", "sp", "php", "er", "ping", "pb", "l", "post", "f", "r", "op", "pro", "g", "lp", "pre", "pers", "pe", "vp", "dp", "pc", "pa", "pt", "P", "jp", "prot", "ph", "i", "at", "py", "parser", "tp", "wp", "ap", "ps", "d"], "ds": ["df", "aws", "ws", "nas", "ts", "yes", "mys", "edes", "sd", "cks", " DS", "posts", "hd", "des", "iffs", "tags", "dd", "dos", "d", "lists", "eds", "ils", "eps", "bs", "els", "ss", " d", "points", "tes", "its", "di", "cs", "workers", "ats", "sets", "ods", "scripts", "sts", "ys", "hs", " os", "ras", "dl", "qs", "obs", " des", " dd", "gd", "pd", "dh", "docs", "ns", "gs", "dp", "ks", "ports", "terms", "uds", "db", "tests", "dt", "tp", "ps", "ags", "os", "ads", "vs", "ls", "Ds", "amps", "s", "outs", "js", "loads", "rs", "dates", " ads", "drivers", "xs", "dds", "DS", "ands"], "format": ["pretty", "module", "t", "parse", "Format", "table", "mode", "path", "fm", "top", "pi", "it", "version", "MAT", "ct", "settings", "filter", "name", "id", "unit", "spec", "mt", "l", "f", "layout", "feature", " Format", "source", "ats", "cf", "output", "fc", "sche", "feat", "act", "set", "title", "pattern", "template", "style", "lat", "tag", "mat", "at", "form", "file", "size", "policy", "type", "status", "shape"], "hasPixelData": ["HasPixelData", " hasPixeldata", "haspixelData", "haspixeldata", "hasixeldata", "hasFramedata", "Haspixeldata", "HasPixeldata", "haspixelDATA", "HaspixelData", " hasPixelDATA", "HasPixelDATA", "hasixelData", "hasPixeldata", "hasPixelDATA", "HaspixelDATA", "hasFrameDATA", "hasixelDATA", "hasFrameData"], "inflate": ["informat", "inflat", "Inflate", "inflicate", "inFlicate", "invalidate", "inflocate", "inFlocate", "incelocate", "inFlate", "Inflated", " invalidATE", "invalidicate", "infolate", "incelate", "inFLocate", "Informated", "Informocate", "informated", "infolated", "Inflocate", "informocate", " inflocate", "incelATE", " inflATE", "inFLated", "incelicate", "Informat", "Informate", " invalidocate", "inFLate", " invalidicate", "infolocate", "invalidATE", "Inflat", "informate", " invalidate", "inflATE", "invalidocate", "inFLat", "infolat", "inflated", "inFlATE", " inflicate"], "pxlen": ["xplen", "packfun", "phplen", "pixellength", "packln", "pexls", "cplen", "xylen", "packdec", "pxln", "pixellen", "pexlength", "mxlength", "tmplen", "packlen", "pxden", "xpln", "tmpln", "packlength", "pexfun", "pxls", "mxln", "pxfun", "pxlength", "cpden", "pxlin", "phplength", "phpln", "pixells", "xpden", "cplength", "pxdec", "packls", "mmlin", "xylin", "mxdec", "xyln", "tmplength", "pexden", "pexln", "cpln", "tmplin", "xylength", "phpdec", "pixelfun", "mmlength", "pexlen", "xplength", "mmln", "mmlen", "mxlen"], "out": ["pretty", "err", "up", "aos", "prefix", "gr", "store", "list", "name", "client", "writer", "obj", "group", "outs", "log", "print", "io", "temp", "conn", "crit", "res", "ln", "user", "cmd", "output", "ex", "gov", "init", "Out", "inter", "cfg", "screen", "outer", "sum", "ou", "inv", "sys", "msg", "OUT", "dir", "net"]}}
{"id1": "13886238", "id2": "20128728", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"init": ["go", "update", "gc", "setup", "open", "get", "base", "version", "release", "Init", "rest", "ping", "reset", " reset", "construct", " Init", "create", "start", "save", "launch", "index", " initiate", " initialization", " refresh", "download", "load"], "backupFile": [" backupStream", "BackapFile", "backipLog", "backupFormat", "backopStream", "backupidFile", "BackupFile", "BackapFormat", "backapfile", "BackupFILE", "BackupLock", "backupidfile", "backapFILE", "backusterFile", "backipStream", " backopStream", " backopfile", "backipfile", "backakLock", "backusterfile", "BackapFILE", "backupFILE", "backoreStream", " backopImage", "backusterFormat", "BackupFormat", " backupfile", " backopFile", "backoreImage", "backapFormat", "backupLock", "backipLock", " backupImage", "BackipFile", "backipFile", "backupidFormat", "backorefile", "backupidFILE", "backupidLock", "BackipLock", "backupImage", "Backipfile", "backopfile", "backupStream", "backakFile", "backoreFile", "backupfile", "Backapfile", "backusterFILE", "backipImage", "BackipLog", "backupLog", "backakLog", "BackupLog", "backopFile", "backakfile", "backapFile", "backupidLog", "backopImage", "Backupfile"], "buff": ["bg", "prof", "null", "text", "binary", "b", "bs", "end", "zero", "ref", "append", "grow", "font", "batch", "bf", "lim", "nd", "xff", "wind", "bm", "mem", "bb", "ind", "cond", "fb", "black", "buffer", "ff", "uf", "pb", "bound", "req", "emb", "tab", "bits", "Buff", "buf", "cmd", "bl", "txt", "bin", "qq", "xx", "printf", "img", "num", "bed", "comp", "ob", "cb", "uff", "bytes", "tf", "msg", "max", "bis", "butt", "nb", "hold"], "in": ["gin", "im", " din", "mc", "o", "mi", "get", "up", "cin", "it", "on", "add", "ini", "inf", "inn", "ind", "id", "ze", "ain", "ins", "ic", "rin", "l", "io", "r", "inc", "ai", "IN", "mm", "iter", "ex", "en", "isin", "bin", "inner", "con", "input", "ri", "conf", "din", "body", "i", "inside", "is", "In"], "out": ["full", "os", "cn", "w", "end", "ion", "o", "up", "aos", "on", "v", "writer", "can", "obj", "to", "outs", "io", "op", "write", "conn", "one", "n", "res", "cos", "output", "ex", "Out", "inner", "con", "conf", "again", "conv", "outer", "ou", "oss", "i", "at", "sys", "OU", "auto", "OUT", "co", "ne", "we", "net"], "read": ["before", "pop", "send", "shift", "pos", "Read", "length", "have", "run", "old", "give", "close", "end", "ok", "take", "get", "stream", "add", "raw", "mem", "check", "count", "ind", "build", "READ", "need", "ready", "buffer", "skip", "print", "readable", "write", "play", "scroll", "scan", "bind", "n", "tell", "find", "start", "iter", "copy", "push", " Read", "input", "seek", " write", "update", "show", "index", "next", "query", "remove", "size", "reading", "len", "max", "open", "reads", "load", "shape", "hold"], "reportWriter": [" reportHandler", "moduleMember", "repairPage", "reportHandler", "repairScope", "servicePage", "repairWriter", "reportTimer", "portwriter", "moduleManager", "detailFile", " reportApplication", "reportWrite", "portReader", "reportFile", " reportContent", "xmlWriter", "repairMember", "modulewriter", "portWrite", "xmlReader", "reportTree", "repairEntry", "xmlFile", " reportEngine", "listWrite", "repairPublisher", "portPublisher", "createEntry", "reportPage", "createScope", "repairApplication", "summaryHandler", "repairWriting", "serviceWriting", " reportManager", " reportScope", "repairManager", "detailReader", "repairEngine", "repairContent", "createwriter", "repairwriter", "repairWrite", " reportMember", "serviceWriter", "reportApplication", "serviceApplication", "xmlHandler", "listwriter", "portWriter", "reportEntry", " reportTree", "commentEngine", "commentWriting", "summaryTree", " reportEditor", "createWriter", "reportWriting", "summaryWriting", "reportScope", "reportManager", "summaryEditor", " reportTimer", "commentContent", "detailWriter", "repairHandler", " reportWriting", "summaryTimer", "reportContent", "repairTree", "repairEditor", " reportPage", "commentWriter", "repairTimer", "reportEngine", "summaryWriter", "portHandler", "moduleWriter", "reportEditor", "reportMember", "portFile", "reportwriter", "reportReader", " reportwriter", "detailHandler", "listPublisher", "reportPublisher", "listWriter", " reportEntry"], "restarting": ["restreated", "restrupting", "restrictating", "restartsbing", "restartbing", "restruptating", "restruptbing", "restreatating", "restricted", " restartating", "startbing", "started", "restorting", "restarteding", "restorted", "starting", "restreating", "restartsating", "restarteded", "restartsed", "restricting", "restartedating", " restartinging", "restartating", "startating", "starteded", "restarted", "restrupted", "restartsing", "startedating", "restartedbing", " restorting", "restreatinging", " restortating", " restarted", "restortinging", " restortinging", "restortating", "startedbing", " restorted", "starteding", "restartinging", "restrictinging"]}}
{"id1": "7809093", "id2": "11546108", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getContent": [" getEntity", " getStream", "getContents", "readEntity", " getData", "getEntity", "readStream", "readContent", "GetEntity", "readData", "GetContent", "GetContents", "GetData", "getData", "getStream", "readContents", "GetStream", " getContents"], "request": ["project", "item", "QUEST", "email", "http", "document", "object", "url", "open", "get", "quest", "address", "message", "question", "this", "resource", "post", "req", "call", "claim", "transform", "q", "application", "create", "start", "search", "template", "input", "instance", "query", "task", "xml", "Request", "hello", "command", "execute", "job", "self", "event", "attribute"], "sb": ["bt", "bh", "bg", "wb", "rob", "gc", "bs", "obb", "bn", "b", "erb", "bf", "kb", "bps", "bb", "sq", "sp", "ib", "fb", "buffer", "pb", "bd", "mb", "sf", "sm", "gb", "sth", "sv", "ub", "bsp", "buf", "lp", "eb", "sg", "ssl", "zb", "rb", "SB", "sa", "bp", "cb", "xb", "lb", "nb", "rm"], "client": ["cn", "tc", "ci", "api", "http", "https", "c", "ch", "secure", "cp", "ce", "cell", "connection", "context", "resource", "grid", "control", "wrapper", "call", "io", "service", "cache", "cl", "conn", "console", "cmd", "create", "ip", "google", "cli", "init", "con", "core", "server", "web", "city", "cm", "force", "connect", "config", "co", "remote", "key", "Client", "chain", "net"], "httpParams": ["httpPans", " httpPars", " httpParms", "apiParms", "httpparAMS", "httpPrms", "httpPars", "httpParAMS", "httpParims", "httpPerms", "httpParms", " httpPams", "httpPms", " httpPims", "httpPam", "httpparms", "httpPARims", "httpPeram", "apiparams", "httpPARars", "httpPerans", "httpParparams", "apiParparams", "apiparms", " httpParims", "httpParars", "httpPrparams", " httpPms", "httpPerams", "httpParans", "httpPARams", "apiParAMS", " httpParans", "httpPrAMS", "httpParam", "apiParams", " httpParars", "httpPrams", "httpPams", "httpPims", "apiparparams", "httpparparams", "httpparams", " httpParam", "apiparAMS", "httpPARms"], "response": ["answer", "that", "successful", "pos", "http", "resp", "document", "object", "onse", "success", "version", "block", "message", "connection", "image", "resource", "sequence", "report", "service", "out", "respond", "still", "application", "output", "given", "page", "tree", "reply", "Response", "body", "next", "json", "description", "data", "entry", "status", "result"], "entity": ["info", "details", "person", "note", "email", "phrase", "ee", "existent", "document", "object", "component", "e", "unique", "valid", "peer", "ce", "quote", "activity", "error", "image", "resource", "obj", "group", "enc", "one", "me", "code", "application", "pe", "user", "metadata", "encrypted", "token", "body", "json", "Entity", "el", "comment", "xml", "data", "form", "status", "translation", "entry", "ent", "ity", "event", "result", "attribute", "net"], "reader": ["row", "older", "linger", "per", "read", "handler", "rar", "ner", "range", "stream", "roller", "worker", "rer", "iterator", "buffer", "writer", "runner", "er", "resource", "owner", "r", "readable", "rl", "user", "ro", "iter", "Reader", "dr", "inner", "input", "rr", "comment", "reading", "file", "data", "parser", "entry", "loader", "dd", "builder"], "line": ["LINE", "row", "detail", "email", "phrase", "link", "sample", "where", "rule", "eline", "inline", "e", "block", "ice", "day", "cell", "message", "Line", "sequence", "l", "print", "nl", "number", "lines", "source", "license", "lined", "ln", "user", "stroke", "lin", "string", "page", "continue", "body", "edge", "le", "point", "zone", "el", "frame", "comment", "header", "msg", "file", "lane", "entry", "ine", "label", "text", "chain", "liner"]}}
{"id1": "16142024", "id2": "13783549", "code1": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyBuffer", "cpFilename", "linkBuffer", "copyfile", "cpFile", "linkFile", "Copyfile", "CopyBuffer", "linkfile", "cpBuffer", "CopyFilename", "cpfile", "linkFilename", "copyFilename", "CopyFile"], "srcFile": [" srcPath", " srcFiles", "rcile", "srcFILE", "sourceFile", "synFile", "rcFile", "rcDir", "destfile", "Sourceile", "selFile", "SourceFile", "srcPath", "srcLine", "destLine", "rcfile", " srcWeb", "sourceLine", "sourcefile", "sourcePath", "rcPath", "selFILE", "synDir", "srcWeb", "rcFILE", "srcfile", "Sourcefile", "srcFiles", "selDir", "sourceFiles", "destFiles", "rcWeb", " srcile", " srcfile", "SourceWeb", " srcLine", "srcDir", "srcile", "synFILE"], "destDir": ["stDirectory", "distDir", "DestUrl", "srcdir", "destCond", "DestFile", "srcCond", " destDirectory", "srcUrl", "destdir", "descCond", " destdir", "descDirectory", "srcPath", " destPath", "stCond", "stDir", "distdir", "distPath", "destDirectory", "srcDirectory", "distDirectory", "descDir", "destPath", "destUrl", "Destdir", "srcDir", "DestDir", " destUrl"], "buffer": ["paste", "memory", "row", "phrase", "binary", "read", "buff", "b", "table", "sample", "length", "variable", "batch", "base", "pad", "raw", "block", "value", "Buffer", "available", "quote", "message", "sequence", "directory", "resource", "password", "cache", "queue", "padding", "source", "window", "buf", "code", "output", "input", "word", "frame", "comment", "header", "file", "data", "channel", "entry", "text", "chain", "command", "result", "attribute", "append"], "destFile": ["DestFile", "newLog", "newTable", "DestPath", "srcPath", " destPath", "DestFiles", " destTable", "newFile", "destTable", "newDir", "srcLog", "destPath", "srcFiles", "destFiles", "srcDir", "DestDir", " destLog", " destFiles", "srcTable", "destLog"], "in": ["gin", "im", "read", "per", " din", "oin", "up", "cin", "it", "on", "ini", "inf", "inn", "ind", "ze", "ain", "ins", "ic", "rin", "by", "reader", "inc", "ai", "al", "source", "from", "IN", "iter", "init", "en", "isin", "inner", "bin", "con", "input", "sin", "din", "inside", "i", "is", "ar", "ir", "In"], "out": ["cn", "os", "t", "b", "gt", "end", "ot", "o", "up", "aos", "it", "on", "list", "client", "v", "writer", "can", "obj", "to", "outs", "log", "by", "io", "op", "write", "cache", "n", "g", "res", "output", "Out", "con", "nt", "outer", "sum", "ou", "oss", "at", "sys", "auto", "OUT", "co", "and", "net"], "bytesRead": ["bytesNeed", "secondsNeed", "fieldsRead", "fieldsReader", "fieldsLength", "tesRead", "netsRun", "netsRead", "tesLoad", "fieldsCount", "valuesRun", " bytesLength", "bytesCount", "BytesReader", "BytesLength", "valuesNeed", "tesNeed", "bytesReader", " bytesLoad", " bytesReader", "netsNeed", "BytesCount", "netsWrite", "BytesRead", "bytesLoad", "termsRun", "termsRead", "tesWrite", "termsWrite", "secondsWrite", "secondsLoad", " bytesWrite", "termsNeed", "valuesWrite", "bytesRun", "secondsRead", "bytesLength", " bytesCount", " bytesNeed", "valuesRead", "bytesWrite"]}}
{"id1": "8132219", "id2": "20924119", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " CopyFiles", " copyStream", " copyfile", " CopyStream", "copyfile", "Copyfile", "CopyFiles", " copyFiles", "copyFiles", " Copyfile", "copyStream", "CopyStream", "CopyFile"], "inFile": ["innFile", "dinFile", "innPath", " inEmail", "inputTemplate", "inputFilename", "inputName", "inName", "ninFile", "dinPath", "inRow", "outFilename", "ninName", "innRow", "ninFilename", "dinRow", "inPath", "inputFile", "outName", "innEmail", "inEmail", "dinEmail", "inFilename", "outTemplate", "ninTemplate", "inTemplate", " inRow", " inPath"], "outFile": ["outTable", "outputTable", "destfile", "inFILE", "inTable", " outfile", "ouTable", "outFilename", "outFormat", "ouFile", "outfile", " outFormat", "ouFILE", "destFILE", "outputFile", "destFile", "outFILE", "outputfile", "destFormat", "outputFILE", "ouFilename", "inFilename", " outFILE", "outputFormat", "outputFilename"], "in": ["gin", "info", " din", "old", "o", "up", "cin", "it", "on", "ini", "inf", "inn", "ind", "id", "ze", "ain", "ins", "s", "ic", "rin", "inc", "ai", "source", " input", "IN", "from", "init", "en", "isin", "inner", "bin", "input", "sin", "din", "irm", "i", "el", "is", "ir", "In"], "out": ["os", "t", "w", "b", "gt", "c", "ot", "o", "aos", "it", "e", "name", "client", "p", "v", "can", "to", "outs", "io", "by", "one", "n", "g", "res", "output", "ex", "Out", "en", "all", "ou", "at", "file", "OUT", "co", "ne", "net"], "inChannel": ["inColumn", "inchannel", "inPanel", "outBlock", "ginPanel", "cinStream", "ginCategory", "vinCase", "sinSlot", "inButton", "vinCategory", "cinChannel", "insideButton", "cinComponent", "cinBlock", "insideComponent", "sinCase", "inBlock", " inchannel", "newPanel", "sinChannel", "sinBlock", "sinCategory", "insideHandler", "innSlot", " inHandler", "innCase", "inCategory", "cinColumn", "newCategory", " inChan", "sinColumn", " inConnection", "isinSlot", "innerChannel", "sinStream", "outConnection", "outColumn", "inComponent", "cinButton", "innerChan", " inButton", "newCase", "vinChannel", "outStream", "inCase", "isinChannel", "newChannel", "outchannel", "innerConnection", "isinCase", "inHandler", "cinHandler", "ginCase", "inSlot", " inComponent", "outChan", "inChan", "innChannel", "inStream", "innerchannel", "inConnection", "vinPanel", "innCategory", "isinCategory", "insideChannel", "ginChannel"], "outChannel": ["outCh", "inchannel", "outBlock", "OutCh", "nStream", "OutChan", "oClient", " outPassword", " outConnection", "outputConnection", "oChan", "exBlock", "outputCh", "outClient", " outCh", "outputChan", " outChain", "outConnection", "nchannel", "inPassword", " outStream", "exChan", " outBlock", "nChan", "outChain", "outStream", " outClient", "outchannel", "exChannel", "inClient", "nChannel", "outputChannel", "OutConnection", "oPassword", " outChan", " outchannel", "outChan", "outPassword", "oChannel", "inStream", "exChain", "inChan", "OutChannel"]}}
{"id1": "17296916", "id2": "7458833", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"logging": [" logStorage", " logger", "loging", "Logger", "LogStorage", "logger", "logStorage", "Loging", " loging", "debuging", "debugging", "debugStorage", "Logging", "debugger"], "wrap": ["handle", "ad", "w", "zip", "parse", "link", "read", "gate", "wx", "ws", "grow", "get", "W", "pad", "add", " wrapped", "aw", "wind", "python", "store", "sp", "build", "use", "message", "ow", "wrapper", "reset", "sw", "transform", "x", "window", "me", "ew", " wrapper", "safe", "find", "pack", "create", "start", "inter", "work", "word", "wire", "root", "wra", "rap", "web", "force", "box", "wa", "form", "chain", "nw", "format", "xf", "we", "shape"], "buffer": ["bar", "memory", "row", "note", "phrase", "binary", "buff", "table", "surface", "document", "batch", "base", "reference", "line", "block", "Buffer", "bb", "flash", "store", "quote", "message", "sequence", "writer", "bo", "pb", "directory", "report", "print", "library", "wrapper", "reset", "flag", "queue", "cache", "window", "buf", "console", "builder", "output", "profile", "iter", "reply", "template", "word", "position", "screen", "bridge", "body", "database", "ob", "trace", "face", "frame", "header", "size", "view", "layer", "button", "display", "command", "complete", "attribute", "append"], "encoding": ["enumging", "Encoding", "enaling", "enging", "clanguage", "enoding", "cododing", "enlanguage", "cododed", "encging", "enoded", "ecoding", "enclanguage", "enryption", "Encryption", "coding", "ecoded", "encoded", "caling", "enumoder", "cging", "cryption", "encaling", "encoder", "ecryption", "encryption", "coder", "enumlanguage", "enoder", "ecoder", "cododer", "Encoder", "codryption", "Encaling", "enumoding"], "getEncoding": ["getEncling", "getEnging", "getExpging", "getEnling", "getEncination", "getOrigoding", "getencling", "getOrigination", " getEnging", "getOrigling", "getEnination", " getEncging", "getEnression", "getExpryption", " getEnoding", " getEncryption", "getencryption", "getencoding", "getencination", " getEncression", "getOrigryption", " getEnling", " getEnryption", "getEncression", "getExpression", " getEnression", "getEnoding", " getEncling", "getExpoding", "getencging", "getEncryption", "getencression", " getEnination", "getEncging", " getEncination", "getEnryption"], "headers": ["styles", "modules", "frames", "params", "authors", "codes", "ctors", "relations", "values", "users", "ers", "pins", "heads", "checks", "blocks", "fields", "comments", "members", "ilers", "ids", "caps", "weights", "rs", "groups", "objects", "boxes", "keys", "holders", "ports", "writers", "drivers", "properties", "head", "terms", "reports", "pres", "names", "header", "builders", "chains", "ppers", "limits", "images", "tags", "ters"], "is": ["was", "os", "sis", "ms", "isl", "in", "bs", "us", "ios", "lis", "has", "osi", "isi", "its", "or", "isc", "tis", "ui", "iss", "ists", "ins", "ic", "isf", "does", "ois", "dis", "fs", "mis", "ist", "iris", "nis", "ip", "isin", "si", "ri", "\u00eds", "ris", "ys", "iso", "isd", "i", "sys", "as", "Is", "IS", "ais", "ims", "bis", "isa", "obs"], "bos": ["fits", "os", "ms", "bh", "bones", "ones", "bs", "oops", "banks", "eros", "bes", "aos", "ios", "soc", "tes", "isi", "boards", "lets", "tis", "ui", "uts", "ts", "cs", "bo", "ows", "bits", "oids", "ses", "js", "fs", "los", "bi", "ods", "ols", "bin", "oos", "ubis", "bas", "tops", "jas", "ys", "windows", "pod", "oss", "uds", "bot", "sys", "des", "nos", "bytes", "ots", "stats", "bis", "cos", "dos", "ps", "obs"], "e": ["m", "re", "t", "err", "ee", "c", "ge", "o", "h", "a", "se", "ed", "es", "oe", "error", "p", "v", "er", "ae", "f", "r", "ev", "x", "E", "n", "g", "me", "de", "ex", "eeee", "en", "ie", "exc", "ate", "le", "i", "ne", "d"]}}
{"id1": "18451704", "id2": "300397", "code1": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"isValidPage": ["isCompleteRow", "isCompletePage", "isValidRow", "isSupportedRow", " isAvailablePoint", "isAvailablePage", "isCompletePoint", "isCompletepage", " isValidpage", "isSupportedpage", "isAvailablepage", "isAvailableRow", " isValidRow", " isAvailablePage", " isAvailablepage", " isAvailableRow", " isValidPoint", "isValidpage", "isAvailablePoint", "isSupportedPoint", "isSupportedPage", "isValidPoint"], "page": ["property", "e", "block", "version", "address", "port", "article", "log", "code", "node", "me", "see", "wikipedia", "word", "channel", "display", "attribute", "project", "row", "table", "pp", "post", "to", "report", "password", "layout", "out", "request", "site", "age", "web", "config", "header", "key", "result", "record", "office", "link", "document", "pg", "peer", "Page", "application", "pe", "server", "file", "book", "collection", "true", "item", "module", "phrase", "rule", "object", "base", "be", "parent", "name", "message", "p", "image", "resource", "content", "cache", "admin", "window", "create", "language", "title", "instance", "bp", "frame", "data", "entry", "policy", "chain", "event", "complete"], "panel": ["bar", "join", "dial", "spin", "chart", "table", "cal", "span", "bean", "sheet", "desktop", "Panel", "block", "pan", "peer", "list", "addon", "cell", "menu", "summary", "login", "group", "layout", "tab", "window", "plugin", "console", "controller", "local", "profile", "widget", "plan", "pal", "container", "within", "title", "inner", "notice", "player", "bridge", "manager", "el", "frame", "view", "tool", "label", "radius"], "isValid": ["isPublic", "imOk", "setOk", "formAvailable", " isPresent", "IsOk", "hasOk", " isvalid", "imValid", " isVal", "ISInvalid", " isFound", "IsAvailable", "ISValid", "setActive", "isInvalid", "tracevalid", "isFound", "lisOk", "lisValid", "lisPublic", " isAvailable", " isActive", "lisInvalid", "isOk", "hasValid", "stillValid", "ISVal", "isAvailable", "ISFound", "IsValid", "formValid", "formvalid", "ISOk", "issValid", "traceValid", "setValid", "traceAvailable", "isVal", "IsFound", "stillVal", "imAvailable", " isInvalid", "stillInvalid", "isvalid", "ISAvailable", "hasPublic", "isPresent", "hasInvalid", "issVal", "issOk", "IsInvalid", "traceInvalid", "IsActive", "formInvalid", " isOk", "imInvalid", "setPresent", " isPublic", "IsPresent", "issInvalid", "isActive", "stillOk"], "url": ["ur", "u", "null", "http", "email", "link", "b", "https", "ml", "build", "address", "name", "resource", "uri", "l", "f", "sl", "r", "nl", "rl", "str", "window", "mount", "user", "sb", "location", "ssl", "string", "char", "Url", "mail", "abs", "ul", "external", "file", "ll", "dl", "tool", "open", "cert", "URL", "browser"]}}
{"id1": "16079868", "id2": "5989666", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"readIntoList": ["readintoList", "readIntToMenu", "readintintolist", "readIntTolist", "readintintoMenu", "readIntintoMenu", "readIntIntlist", "readintolist", "readintintoList", "readIntIntList", "readIntIntMenu", "readIntolist", "readIntintolist", "readIntToList", "readintintoMap", "readIntintoList", "readintoMap", "readIntintoMap", "readIntoMenu", "readIntToMap", "readIntIntMap", "readIntoMap", "readintoMenu"], "url": ["ret", "domain", "bel", "ur", "http", "link", "b", "ref", "address", "name", "id", "image", "resource", "uri", "l", "log", "f", "r", "nl", "str", "window", "mol", "rect", "mount", "hub", "from", "location", "ssl", "string", "input", "char", "Url", "web", "mail", "el", "xml", "file", "loc", "ll", "dl", "open", "cert", "URL", "browser"], "list": ["info", "record", "dict", "m", "module", "detail", "t", "table", "batch", "top", "get", "add", "block", "part", "parent", "level", "name", "p", "port", "summary", "map", "l", "print", "group", "v", "out", "cache", "only", "n", "test", "st", "set", "state", "all", "tree", "network", "show", "relation", "pool", "view", "LIST", "listed", "is", "format", "type", "label", "status", "rm", "lists", "collection"], "in": ["gin", "re", "read", " din", "val", "get", "up", "cin", "add", "on", "line", "check", "inf", "inn", "ill", "mn", "ins", "er", "ic", "rin", "by", "reader", "r", "pin", "inc", "doc", "out", "source", "IN", "from", "en", "isin", "bin", "inner", "all", "con", "input", "conf", "din", "sum", "i", "file", "is", "and", "In"], "inputLine": ["inputL", "contextline", "htmlLINE", "textLin", "httpL", "formline", "nextText", "selectText", "inputLINE", "nameline", "httpLINE", "InputLINE", "nameBlock", "formBlock", "inputline", "nameLINE", "latLINE", " inputRow", " inputLINE", "nameLine", "inputLin", "textL", "commandLine", "nextLine", "htmlBlock", "contextLine", "outputLine", " inputBlock", "nextLINE", "latLine", "inputBlock", "attLINE", "Inputline", "selectLINE", "textLINE", "nextRow", "helloLin", "InputBlock", "outputline", "textLine", "selectRow", "commandline", "helloLine", "actLine", "dataLine", "formLINE", "activeLINE", "htmlline", "inputRow", "attLine", " inputText", "actLINE", "httpLine", "actline", "httpLin", " inputline", "activeLine", "commandLINE", "contextLINE", "outputLINE", "selectLine", "formLine", "helloLINE", "dataLINE", "helloL", "inputText", "InputLine", "htmlLine"], "commandNameBegin": ["commandnamebegin", "commandFamilyBeg", "commandTypebegin", "commandNameStart", "commandNAMEMon", "commandNamesBeginning", "commandNamesbegin", " commandNamebegin", "commandFamilyMon", "commandTypeStart", "commandSizeBeg", " commandNameBeginning", "commandNameBeginning", "commandNameMon", "commandNamebegin", "commandSizeMorning", "commandNameEGIN", "commandNameInitial", "CommandNameStart", "commandnameBeginning", " commandNameEGIN", "commandnameBegin", " commandOrderStart", "commandFamilyInitial", "commandNAMEBegin", "commandLineBegin", " commandSizeMorning", " commandSizeBegin", "CommandNamebegin", "commandLineStart", "commandTypeBeginning", "CommandNameBegin", "commandFamilyBegin", " commandNameMon", "commandFamilyEGIN", "commandNAMEInitial", "CommandNamesBeginning", "commandOrderbegin", "commandFamilyBeginning", "commandOrderBeginning", "commandnameEGIN", "CommandNamesStart", "CommandNamesbegin", "commandnameBeg", "commandNamesStart", "commandSizeEGIN", "commandLinebegin", " commandOrderBeginning", "commandFamilyMorning", "commandNameMorning", " commandNameMorning", " commandNameInitial", "commandOrderStart", " commandSizeBeg", "commandOrderBegin", "CommandNamesBegin", " commandSizeEGIN", "commandLineBeginning", " commandOrderBegin", "commandSizeBegin", "commandnameStart", "commandNameBeg", " commandOrderbegin", " commandNameBeg", "commandNamesBegin", "commandnameMorning", "CommandNameBeginning", "commandNAMEBeginning", "commandTypeBegin", " commandNameStart"], "commandNameEnd": [" commandNamesEnd", " commandNameend", "commandStringEND", "formNameEND", "formNameStart", "commandNamesEND", " commandLineend", "commandNameStart", "commandSizeStart", "commandNamesStart", "commandStringEnd", "cmdNameEnd", "cmdTimeEnd", " commandNameEND", "commandLineEND", "commandNamesend", "commandLineend", "cmdNameend", " commandNamesEND", "commandNamesBegin", "commandTypeend", " commandLineEnd", "cmdNameEND", "cmdTimeend", "formNameEnd", "commandStringBegin", "cmdTimeEND", "commandnameend", "commandnameEnd", " commandNamesBegin", "formNameend", " commandLineEND", "commandTypeStart", "formSizeStart", "commandTypeEnd", "formSizeEND", "commandSizeEnd", "commandTimeEND", "commandNamesEnd", "commandLineEnd", "commandTypeEND", "commandSizeEND", "commandnameEND", "commandNameEND", "commandNameend", "commandTimeEnd", "formSizeEnd", "commandTimeend", "commandSizeend", "commandTypeBegin", " commandNamesStart", "formSizeend", " commandNameStart", "commandStringStart"], "item": ["info", "bar", "m", "row", "module", "im", "other", "link", "handler", "this", "rule", "object", "option", "Item", "base", "mix", "it", "add", "or", "mem", "check", "store", "question", "p", "image", "unit", "obj", "article", "owner", "element", "menu", "group", "items", "event", "member", "hit", "em", "iter", "mm", "local", "exp", "widget", "page", "title", "inner", "template", "tree", "app", "instance", "related", "index", "sim", "li", "i", "monitor", "el", "task", "match", "type", "entry", "button", "key", "label", "command"], "e": ["m", "re", "u", "t", "err", "w", "ent", "ee", "b", "ec", "c", "end", "eur", "ge", "h", "o", "a", "se", "be", "ed", "es", "fe", "oe", "ce", "error", "v", "p", "ze", "er", "ae", "l", "f", "ve", "r", "ea", "ev", "x", "q", "E", "n", "g", "one", "de", "pe", "eb", "ex", "eeee", "en", "ie", "ef", "le", "te", "i", "eg", "el", "eu", "ne", "ue", "event", "et", "d"]}}
{"id1": "21363911", "id2": "17193692", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "label": 1, "substitutes": {"testTransactions": ["testTacts", " testTransitions", " testtransaction", " testtransacts", "testTactions", "testTaction", "testTransitions", "testtransaction", " testtransactions", "testTransacts", "testtransactions", " testtransitions", "testTransaction", " testTransacts", "testtransitions", "testTitions", " testTransaction", "testtransacts"], "con": ["cn", "tc", "gate", "c", "coll", "xc", "util", "bo", "can", "cur", "anc", "ctx", "en", "conf", "co", "ac", "nc", "dial", "po", "gc", "bn", "rc", "client", "conn", "enc", "rec", "console", "ln", "act", "don", "CON", "config", "ran", "open", "pt", "dn", "go", "re", "sc", "fn", "un", "pen", "mc", "on", "cc", "ct", "cp", "connection", "ain", "fl", "res", "cf", "fc", "ens", "db", "cm", "connect", "cv", "gen", "bc", "ctrl", "pl", "cal", "cont", "ch", "Con", "ic", "cache", "win", "pc", "conv", "com", "ren", "sur", "cons"], "st": ["tt", "rt", "bt", "ft", "sc", "t", "stop", "ld", "sty", "ste", "ut", "statement", "h", "it", "nd", "stre", "ct", "ost", "sp", "ast", "ts", "must", "St", "bo", "rest", "s", "mt", "l", "obj", "sl", "stage", "sw", "std", "et", "cl", "put", "th", "sol", "str", "sth", "ln", "ist", "start", "sb", "sn", "stat", "sts", "cr", "ust", "art", "step", "stra", "nt", "sta", "irst", " superst", "fr", "wt", "inst", "stan", "co", "so", "const", "est", "ST", "pt"], "rs": ["ubs", "ws", "ts", "rys", "ris", "RS", "ires", "vr", "mr", "rt", "ms", "bs", "rc", "els", "ss", "its", "cs", "ress", "r", "ats", "sts", "ds", "usr", "ys", "sr", "rates", "hs", "ras", "pres", "ars", "abs", "ems", "acks", "qs", "irms", "rots", "re", "aps", "arms", "rows", "rd", "ns", "ows", "rets", "gs", "hr", "res", "vers", "rel", "rss", "dr", "ks", "ges", "cases", "ps", "rr", "ags", "ros", "rings", "vs", "ls", "arts", "Rs", "rus", "s", "ins", "ues", "rl", "js", "pc", "rx", "ics", "ri", "xs", "times", "sys", "dds", "stats", "ims", "icks", "rm"]}}
{"id1": "7276377", "id2": "7351534", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "label": 0, "substitutes": {"checksum": ["csest", "cksam", " checksume", "checksest", "csume", "csam", "cksume", "cksum", "checksam", "cksest", " checksam", " checksest", "csum", "checksume"], "url": ["domain", "bel", "ur", "u", "email", "http", "link", "https", "document", "path", "ls", "host", "base", "get", "gl", "dll", "build", "address", "name", "image", "uri", "log", "l", "nl", "request", "q", "str", "rect", "mount", "rel", "location", "ssl", "string", "pattern", "char", "Url", "web", "mail", "config", "el", "html", "ul", "xml", "file", "loc", "ll", "dl", "key", "URL", "browser"], "algorithm": ["Alculus", " algo", "Algorith", "alignment", "approculus", "maliment", "operabet", "palgorithm", "aliment", "malgo", "opergorithm", "alculus", "opergo", "palter", "alterignment", "Alter", "malignment", "palgo", " algorith", "palabet", "alabet", "malgorithm", "approgorith", "approgorithm", "algo", "operter", "alter", "approgo", "altergorithm", "alteriment", "Algo", " alculus", "Alignment", "algorith", "altergo", "Aliment", "Alabet", "Algorithm"], "messageDigest": ["messageCheckse", "messageDiger", " messageDiger", "MessageDigse", "MessageDigest", "messageDebuger", "applicationDigests", "messageCheckest", "Messagedigest", "applicationDigester", "messagedigist", "messageDigester", "messageHasests", "messagedigum", "messageDigse", "messageDigum", "MessageDiger", "messageDum", "messagedigidate", " messageDigist", "messageDigist", "applicationDesignester", "messageCheckum", "messageDigests", " messageDigidate", "messageDesignests", "messageDebugest", "messageChecker", "messageMerist", "messagedigest", "messagedigester", "applicationDigest", "Messagedigse", "applicationDesigner", "messageHaser", "messageDse", "messageMerse", "messagedigse", "messageDesignest", "messageDebugidate", "applicationDiger", "messagediger", "messageDebugse", "applicationDesignest", "messageDesignester", " messageDigse", "messageHasester", "messageMerest", "applicationDesignests", "MessageDigum", "messageDer", "Messagedigum", "messageDigidate", "messagedigests", "Messagediger", "messageHasest", "messageDesigner", "messageDest"], "bytes": ["frames", "notes", "words", "ones", "eps", "bs", "jobs", "Bytes", "services", "versions", "vs", "pages", "resources", "rows", "bes", "tes", "its", "bps", "files", "es", "ies", "seconds", "users", "values", "outs", "items", "checks", "blocks", "pieces", "ces", "lines", "bits", "out", "gs", "gb", "groups", "vals", "pointers", "types", "bos", "units", "steps", "terms", "names", "parts", "gets", "strings", "classes", "images", "ions"], "in": ["gin", "info", "m", "re", "null", "t", "nin", "oin", "mc", "o", "h", "mi", "up", "cin", "it", "on", "or", "pi", "check", "inf", "socket", "inn", "ind", "name", "client", "p", "ain", "can", "ins", "l", "rin", "io", "reader", "by", "inc", "ai", "out", "al", "proc", "source", "one", "n", "impl", "IN", "from", "init", "en", "isin", "bin", "inner", "con", "input", "conf", "again", "din", "asin", "ma", "i", "form", "is", "co", "serv", "handle", "In"], "nBytesRead": [" nBytesread", "nFramesSupported", "nItemsWritten", "nTokensRead", "nFilesRead", " nItemsReader", "nFramesRead", "NRsRun", "nBytesReader", "nFilesread", "nBytesRun", " nItemsFound", "nItemsFound", "NBytesread", "nTokensread", "nbytesWritten", "NBytesRead", "nbytesSupported", "nbytesread", " nRsWritten", "nFilesRun", "nRsRead", "nItemsReader", "nFilesWritten", "nFramesFound", "NRsWritten", "NRsread", "nRsread", " nRsread", "nRsReader", " nBytesReader", "nItemsRead", " nBytesFound", "NBytesRun", " nBytesWritten", "nFramesWritten", "nTokensWritten", "nRsWritten", " nItemsWritten", "NRsRead", "nRsRun", "nBytesFound", "nBytesSupported", " nBytesSupported", " nRsSupported", "nTokensRun", "nBytesread", "nRsFound", "nFramesReader", "nBytesWritten", " nItemsRead", "NBytesWritten", "nRsSupported", " nRsRead", "nbytesRead", "nFramesread"], "checksumValue": ["checksamVal", "checksumedValue", "checksummVal", "checksumValues", "checksUMModel", " checksamDocument", " checksumDocument", "checksumvalue", " checksumvalue", "checksumedDocument", "checksummModel", "checksumDocument", "checksummvalue", "checksummData", " checksummvalue", "checksumData", "checksumVal", " checksumVal", "checksumerModel", " checksumValues", "checksUMvalue", "checksamDocument", "checksumerValues", " checksummValue", "checksamValue", " checksummModel", "checksamData", "checksummValues", "checksumModel", "checksUMValues", "checksummDocument", "checksumervalue", " checksamValue", "checksumerValue", "checksUMValue", "checksumedVal", " checksumData", "checksumedData", " checksamData", " checksamVal", " checksumModel", " checksummValues", "checksummValue"]}}
{"id1": "14877116", "id2": "20073619", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 0, "substitutes": {"cpFile": ["pasteFile", " copSingle", " cpStream", "pasteStream", " cpSingle", " copBuffer", " dupSingle", "pasteSingle", " copStream", " dupStream", " dupBuffer", " dupFile", " cpBuffer", "pasteBuffer", " copFile"], "source": ["SOURCE", "get", "up", "se", "none", "from", "init", "ie", "input", "char", "comp", "scene", "subject", "self", "series", "shell", "attribute", "sql", "before", "sample", "old", "path", "unit", "service", "scan", "select", "site", "find", "search", "style", "template", "query", "config", "Source", "form", "status", "in", "component", "secure", "scope", "store", "peer", "use", "ce", "this", "spec", "string", "current", "file", "remote", "format", "ace", "null", "base", "stream", "parent", "sp", "name", "image", "resource", "ource", "local", "create", "start", "copy", "origin", "dest", "original"], "target": ["that", "t", "port", "master", "tor", "dev", "arget", "join", "project", " dst", "goal", "table", "tif", "path", "default", "it", "internal", "normal", "to", "print", "transform", "site", "style", "template", "secondary", "update", "link", "gt", "range", "scope", "peer", "build", "this", "arg", "buffer", "primary", "mount", "test", "alias", "current", " Target", "root", "tmp", "next", "force", "global", "file", "tool", "remote", "format", "null", "host", "top", "base", "parent", "resource", "Target", "window", "ARGET", "bolt", "output", "local", "set", "theme", "origin", " targ", "tree", "dest", "point", "localhost", "type", "handle"], "replace": ["join", "record", "null", "include", "update", "link", "close", " Replace", "repl", "repeat", "inline", "hide", "register", "compatible", "add", "prefix", "enable", "delete", "store", "keep", "use", "fix", "change", "report", "fill", "places", "write", "only", "apply", "repair", "find", "copy", "search", "save", "share", "place", "ignore", "first", "force", "placed", "remove", "insert", "match", "format", "remote", "display", "rm", "load", "append"], "bufferSize": ["windowSize", "windowSIZE", "BufferCount", "bufferName", " bufferSIZE", "blockCount", "BufferSize", "windowCount", " bufferStyle", "bufferStyle", "BufferName", "windowName", " bufferCount", "blockSize", "BufferSIZE", "blockSIZE", "BufferStyle", "blockStyle", "bufferSIZE", "bufferCount", " bufferName"], "src": ["rt", "RC", "sc", "http", "in", "read", "SOURCE", "rc", "syn", "secure", "stream", "ser", "sq", "sp", "obj", "ins", "req", "sl", "sync", "sf", "out", "proc", "rl", "sub", "str", "fc", "cur", "std", "st", "iter", "rs", "txt", "sb", "rx", "copy", "ctr", "init", "dest", "rb", "supp", "bin", "sec", "input", "img", "usr", "sin", "sr", "tmp", "conv", "sys", "Source", "inst"], "tarn": ["yarp", "parn", "wtann", "yarn", "vtann", "starm", " tinn", "vtarn", "stourn", "porn", "Tard", "utorn", "tard", "wtarn", "thourn", "Tara", "pourn", "tinn", " tard", "thorn", "yarm", "Tarm", "tharl", "Tinn", "Tarn", "Tann", "tann", "tara", "tarp", " tara", "storn", "tourn", "Tourn", "utard", " tourn", "wtinn", " tann", "starl", "Torn", "parm", "vtarm", "starp", " tarp", "yourn", " tarm", "torn", " torn", "tarm", "pann", "vtorn", "utarn", "utann", "wtara", "tharn", "tarl", "starn", " tarl"], "tardir": ["tradart", " tardart", "tardart", "tarnore", " tardar", "tradr", "taredir", " tardint", " tartart", "tarnint", "tarnir", " tarddir", " tarnr", " tartir", "tartr", "tarddir", "tadint", "tarndir", "tardint", " tardr", " tartore", " tarnir", "tardr", "taredar", "tradore", "taddir", "tarnar", "tardar", "tarnart", "tarnr", "tartar", "tardore", " tarnar", "tareddir", " tardore", "taredint", " tarndir", "tartore", "tartir", "tradir", " tartr", "tartdir", "tadir", "tartart", "tadr", " tarnint", "tadar"], "n": ["nc", "m", "cn", "t", "z", "nr", "w", "j", "c", "un", "nan", "na", "on", "nm", "count", "ns", "ind", "y", "mn", "l", "k", "nl", "number", "N", "x", "g", "nu", "ln", "nn", "sn", "en", "con", "nt", "num", "index", "next", "i", "norm", "max", "nb", "d"], "tar": ["drop", "cro", "gre", "zip", "parse", "nut", "gz", "tif", "bare", "archive", "rar", "dra", "tap", "cot", "mar", "add", "or", "part", "store", "buffer", "stable", "mask", "cube", "sv", "war", "bolt", "cat", "txt", "csv", "pack", "tor", "sea", "ctr", "dr", "copy", "car", "tr", "trap", "par", "tan", "star", "gob", "sum", "te", "qa", "box", "tg", "roo", "tf", "cast", "vol", "ar", "Tar"], "bytes": ["cells", "frames", "words", "ones", "bs", "versions", "services", "Bytes", "pages", "rows", "resources", "bags", "ls", "tes", "its", "bps", "files", "ips", "es", "seconds", "values", "users", "cs", "outs", "pins", "blocks", "bits", "pieces", "lines", "bles", "gs", "les", "groups", "vals", "some", "unks", "elines", "steps", "reports", "parts", "gets", "strings", "classes", "ings", "qs", "series", "boxes"], "readn": ["readnn", "writele", "Readnl", "readns", "loadn", "writeN", "rollle", "writens", " readnl", "printn", "writen", "readN", " Readnl", "writel", "ReadN", "printle", "rolll", " Readn", "loadnn", "readnl", "loadN", " readl", " Readl", "Readl", "rolln", "loadl", "readle", "Readnn", "readl", "Readn", "printl", "printns", "rollns", "writenn"]}}
{"id1": "22441244", "id2": "21092340", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "label": 1, "substitutes": {"send": ["parse", "security", "end", "submit", "get", "add", "build", "message", "post", "Send", "report", "print", "write", "apply", "set", "create", "init", "export", "reply", "push", "save", "mail", "transfer", "msg", "execute", "sent"], "hsession": ["HShip", " HSess", "rssession", "HSession", "HSpace", "hessions", "hettings", "HSettings", "hhession", "hhhip", "hship", "hssession", "rsess", "hession", " HSsession", "HSessions", " HSpace", "hhip", "hhessions", "hsessions", "rspace", "hspace", "hhettings", "hsettings", "HSsession", "hhsession", "HSess", "rsession", " HSession", "hsess"], "session": ["ession", "document", "object", "driver", "parent", "store", "name", "client", "connection", "message", "context", "password", "sid", "content", "account", "cache", "set", "ip", "state", "instance", "manager", "Session", "ess", "view", "lock", "job", "event"], "repositoryName": ["repoositoryNAME", "repoitoryNAME", "repositoryTitle", "reposoryNAME", "reposoryName", "repositionTitle", "repoitoryPath", "repoitoryName", "repoitoryTitle", "repositableName", "repositorName", "repoositoryPath", "repositionName", "repositionPath", "repoositoryTitle", "reposoryData", "repoositoryData", "reposositoryNAME", "repoositoryName", "reposositoryPath", "repositorNAME", "repositableNAME", "repositorPath", "reposositoryname", "repositoryNAME", "repoitoryname", "repoitoryData", "repoositoryname", "repositionNAME", "reposoryname", "repositableData", "reposositoryTitle", "repositoryname", "repositorTitle", "repositoryData", "reposositoryData", "repositablename", "reposositoryName", "repositoryPath"], "ideIdint": ["ideInfoINT", "ideInfost", "ideDst", " ideIdline", "ideIdINT", "IDEidINT", "ideIdst", "ideThind", "IDEIdst", "IDEIdint", "ideIDline", "ideIDno", "IDEidst", "ideIdentno", "ideIDint", "ideIdentint", " ideThint", "ideDint", "ideInfoint", "ideThno", " ideThind", "ideIdline", "ideThline", "ideIDind", "ideIdentline", "IDEidint", "ideidst", "ideIdno", " ideThno", "ideDINT", "ideidint", "ideThint", "ideIdind", "ideIdentind", " ideIdind", " ideIdno", "ideidINT", " ideThline", "IDEIdINT"], "to": ["topic", "tt", "os", "t", "pos", "po", "about", "o", "range", "top", "company", "eto", "address", "client", "tel", "by", "ato", "route", "toc", "pro", "ta", "site", "To", "st", "no", "token", "tr", "too", "target", "addr", "auto", "co", "contact", "phone", "tp", "TO"], "cc": ["ico", "cn", "ci", "cy", "sc", "tc", "cmp", "cloud", "ec", "rc", "mc", "cin", "company", "ct", "cp", "ce", "cs", "dc", "cd", "control", "ic", "cl", "cca", "toc", "cf", "cmd", "fc", "cr", "cci", "ck", "cm", "cb", "cv", "co", "CC", "ca", "ac", "ctrl"], "bcc": ["vcy", "bce", "rbck", "rbce", "sbcc", " bck", "cbCC", "bCC", " bcm", "vcc", "bck", "vce", "sbce", "rbcy", " bCC", "cbck", "sbcy", "cbcm", "rbcc", "bcy", "rbCC", "vck", "sbck", "bcm", "cbcc", "rbcm"], "subject": ["topic", "note", "heading", "security", "host", "prefix", "id", "name", "message", "filename", "uri", "content", "source", "Subject", "metadata", "title", "template", "head", "mail", "html", "face", "description", "comment", "form", "author", "header", "text"], "body": ["hex", "Body", "bh", "ODY", "null", "note", "zip", "other", "binary", "params", "b", "object", "back", "h", "url", "default", "inline", "base", "top", "line", "files", "part", "name", "message", "buffer", "post", "summary", "report", "background", "news", "layout", "content", "padding", "source", "code", "no", "ody", "output", "title", "inner", "template", "head", "business", "json", "query", "mail", "parts", "html", "bill", "description", "bytes", "comment", "data", "response", "text", "handle", "shell", "any"], "attachments": ["achmentments", "atttypes", "attachtypes", "Attachresses", "attresses", "achmentresses", "Attachachment", "attments", "Attachments", "achmenttypes", "Attachtypes", "achmentachment", "attachresses", "attachachment"], "isHtml": ["isJhtml", " isWhip", " isHip", "isWhhtml", "isWhtml", "IsHap", "ishap", "isVhtml", "isJtml", " isHHTML", "isHhtml", "isJap", "ishtml", "isChHTML", "isWhHTML", "isHip", "isHHTML", "isChhtml", " isWhHTML", "IsHhtml", "isHttp", "IsHtml", " isWhtml", "IsHttp", "ishttp", "isJttp", "isVtml", "isWhip", "isChip", "isChtml", " isWhhtml", "isVHTML", "isHap", " isHhtml", "isVip", "ishhtml"], "charset": ["clarsets", "charsale", "chersetter", "chactersets", "charspace", "charpet", "CHarset", "CHarsett", "chARSET", "chableset", "chARSet", "CharsET", "ChARSetic", "charpets", "quarsale", "quatsec", "chacterset", "charpetic", "ChARSetter", "charsetic", "chatset", "charpET", "quatset", "charsets", "chippett", "quarsetter", "Charsetic", "quarset", "chacterspace", "charpett", "channelset", "clarset", "Charset", "clarsetter", "chARSetter", "CHippets", "cherspace", "clarspace", "clerset", "chippale", "ChARSET", "chippec", "charsec", "channelsetic", "quatsale", "charsET", "ChARSet", "CHippett", "chippetter", "chactersetter", "charsetter", "chersets", "chARSetic", "charpetter", "CHippET", "chippet", "clersets", "channelsET", "chARSets", "clerspace", "channelsetter", "chippET", "quarsec", "chARSpace", "chablesec", "CHippet", "chatsetter", "chablesetter", "CHarsET", "CHarsets", "quatsetter", "chatsale", "charsett", "chatsec", "clersetter", "cherset", "chablesale", "chippets", "Charsetter"], "headers": ["details", "params", "authors", "codes", " trailers", "files", "relations", "users", "ers", "heads", "lines", "members", "comments", "fields", " heads", "ilers", "metadata", "dr", "keys", "types", "head", "names", "header", "ppers", "ors", "limits", "ters"], "priority": ["pos", "security", "prefix", "company", "level", "phone", "id", "context", "grade", "primary", "password", "flags", "comments", "order", "due", "profile", "origin", "title", "state", " severity", "position", "properties", " urgency", "description", "policy", "status", "serial"], "email": ["echo", "domain", "ome", "comment", "detail", "note", "office", "http", "link", "sample", "ee", "document", "il", "object", "url", "Email", "line", "e", "company", "delete", "oe", "gmail", "address", "message", "label", "er", "element", "print", "log", "report", "call", "password", "enter", "initial", "et", "reset", "license", "example", "console", "em", "test", "die", "output", "ssl", "all", "search", "template", "instance", "server", "voice", "database", "fax", "mail", "html", "el", "xml", "model", "ilo", "view", "external", "response", "description", "entry", "contact", "ne", "msg", "ell", "liner", "event", "result", "shell"], "user": ["browser", "person", "usage", "creator", "util", "username", "User", "used", "use", "system", "name", "client", "connection", "users", "id", "login", "owner", "by", "student", "account", "admin", "me", "uid", "from", "output", "USER", "profile", "entity", "ip", "usr", "manager", "actor", "match", "usa", "ident", "author", "human", "auth", "result"], "identity": ["recognicate", "recognity", "identITY", "idITY", "instator", "personentity", "presentity", "IDENTITY", "equator", "ententity", "solidality", "presententity", "entifier", "personicate", "identator", "IDENTality", "personificate", "personITY", "instentity", "personity", "primificate", "idality", "identitate", "primance", "identality", "IDENTity", "presentitate", "IDENTifier", "recognentity", "ethnicity", "ethnicitate", "recognance", "IDENTentity", "instalty", "IDENTiciary", "IDENTance", "identifier", "solidularity", "entity", "IDENTitate", "identificate", "idententity", "identiciary", "entularity", "IDENTularity", "idiciary", "instity", "IDENTicate", "equalty", "equity", "solidity", "identularity", "instularity", "idity", "identalty", "idularity", "presentularity", "IDENTalty", "personiciary", "instifier", "IDENTificate", "primity", "IDENTator", "ethnicularity", "primicate", "primentity", "equentity", "solidentity", "ethnicentity", "identance", "identicate"], "_returnPath": ["_returnLocation", "_errorPoint", "_errorUrl", " _errorAddress", "_replyPath", "setsavepath", " _errorPoint", "_errorName", "_retPoint", "_ReturnName", "_requestAddress", "_returnDir", "_errorAddress", "_savePath", "_resultPoint", "_ReturnAddress", "_errorpath", "setsaveTo", "_requestName", "_retCode", "_ReturnPath", "_resultTo", " _returnPoint", "_replyDir", " _returnName", "_getDir", "_getPath", "_retDir", "_getTo", "setreturnTo", "_errorLocation", "setsaveUrl", "_replyCode", "_requestPoint", "_returnPoint", "setreturnPath", "_resultLocation", "_returnpath", "_errorTo", "_returnCode", "_retTo", " _returnAddress", "_deletePath", " _errorPath", "setreturnUrl", "setreturnpath", "_retUrl", "_getCode", "_returnName", "_returnUrl", "_resultPath", "_returnAddress", "_ReturnPoint", "_deletepath", "_deletePoint", " _errorName", "setsavePath", "_saveTo", "_savepath", "_deleteTo", "_retpath", "_retPath", "_requestPath", "_retLocation", "_errorPath", "_returnTo", "_saveUrl"], "_from": ["_local", "\tform", " _reset", "_author", "_reset", "_actor", "longsource", "longreset", "letabout", "_source", "_addr", "_form", " _author", " _about", "\tfrom", "letfrom", " _source", "letto", "\tauthor", "letsource", " _actor", "remaddr", "remlocal", "longfrom", "longto", " _form", "\tactor", "remowner", "_owner", "remfrom", "_about"], "_replyTo": ["_ReplyFrom", "_responsePath", "_closeTo", "_respondFrom", "_backTo", "_responseFrom", "_backTO", "_ReplyOnly", "_respondTO", "_commentLine", "_responseLine", "_commentTO", "_responseOf", "_ReplyTO", "_commentTo", "_returnOnly", "_backFrom", "_backPath", "_replyOf", "_ReplyPath", "_commentOf", "_replyTO", "_replyFrom", "_returnTO", "_respondTo", "_returnTo", "_closeOf", "_replyLine", "_returnFrom", "_replyOnly", "_ReplyTo", "_respondOnly", "_responseTo", "_closeLine", "_closeTO", "_replyPath", "_responseTO"], "_to": ["_topic", "successtopic", "prito", "successsite", "successta", "prisite", "prita", "_site", "successto", "pritopic", "_ta"], "_cc": ["_cs", " _cs", "_subject", " _subject", "_cca", " _cca"], "_bcc": ["_rca", "_wcc", "_rcc", "_rck", "_bca", "_rbca", "_rbcc", "_racc", "_wacc", "_bck", "_wck", "_rbacc", "_wca", "_rbck", "_bacc"]}}
{"id1": "13122204", "id2": "20619879", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnarchiveModule", "UnarchiveModel", "unzipModule", "unlatemodel", "unzipImage", "Unzipmodel", "UnzipModel", "unzipmodel", "unarchiveModel", "uncodeModel", "unarchiveImage", "unlateModel", "uncodeModule", "uncodeImage", "unarchiveModule", "UnarchiveImage", "UnzipModule", "Unarchivemodel", "uncodemodel", "unlateModule", "unlateImage", "UnzipImage", "unarchivemodel"], "filename": ["sql", "ivo", "FILE", "fn", "mson", "jpg", "FN", "fp", "journal", "path", "dra", "FIL", "username", "SourceFile", "nm", "fle", "name", "nil", "directory", "ename", "nl", "source", "stem", "n", "ln", "txt", "output", "location", "origin", "title", "original", "til", "kl", "river", "fil", "wl", "println", "file", "Filename", "subject", "download"], "tempdir": ["tmpdir", " tempfile", "tmpfolder", "Tempfile", "testpath", "tempdirectory", "testfolder", "tempDir", "temdir", "temDIR", " tempDIR", "tempDIR", " tempDir", "testdir", "temdirectory", "tempfile", "temppath", "tmpdirectory", "tempath", "temfolder", "tmpfile", "Tempdirectory", "tmpDIR", "tempfolder", " tempdirectory", "tmppath", "TempDir", "temDir", "testDir", "Tempdir", "tmpDir"], "dest": ["src", "null", "pos", "send", "Dest", "table", "cont", "document", "default", "stream", "desc", "trans", "parent", "store", "tail", "peer", "slave", "decl", "coord", "dc", "buffer", "port", "generated", "rest", "master", "obj", "writer", "temp", "out", "dist", "write", "source", "test", "st", "output", "ctr", "dat", "dev", "origin", "bin", "deep", "usr", "tr", "nt", "tmp", "nom", "pipe", "target", "inv", "sum", "ptr", "des", "foreign", "loc", "est", "display", "comb", "result", "del"], "fis": ["fjs", "fatis", "flis", "lis", "zatis", "flos", "zi", "fljs", "zjs", "ifatis", "flatis", "los", "zos", "ifos", "fli", "ifis", "li", "fi", "ifi", "ljs"], "BUFFER": ["BBER", "BUBuffer", "BAULT", "MAXFFER", "CUBuffer", "LOCKBuffer", "MAXOUNT", " BUOUNT", " BUULT", "BABER", "BufferBER", "LOCKBER", "BOUNT", "BAFFER", "BLBuffer", "MAXBuffer", "BufferBuffer", "BufferMT", "LOCKFR", "CUFR", "FFERMT", "BAOUNT", " BUFR", "BUBER", "LOCKFFER", "FFERBuffer", " BUBER", "BufferFFER", "BUMT", "BUOUNT", "BLOUNT", "FFERFFER", " BUMT", "BFFER", " BUBuffer", "BUFR", "FFERBER", "MAXBER", "BLBER", "BUULT", "BLFFER", "CUFFER", "CUBER", "BULT"], "zis": [" zris", "fip", "zip", "zeis", "xos", "ozip", " zIS", " zos", "zeos", "xis", "zies", "zi", "fiss", "ozis", "zoneris", " zi", "zees", "Zos", "zios", "Zis", " zip", "ozi", "zIS", "zeIS", "ziis", "zeris", "zoneits", "zos", "Zi", "zris", "zoneis", "Ziss", "ziss", "zits", "zoneiss", "xiss", "zes", "ziIS", " zes", "xi", " zits", "zeiss", "oziss", "fi", " ziss", "zeits"], "entry": ["record", "row", "item", "zip", "link", "Entry", "existent", "table", "jo", "piece", "se", "e", "or", "part", "way", "ce", "system", "cell", "connection", "ze", "image", "zo", "name", "log", "element", "enter", "member", "card", "source", "je", "pe", "jar", "inter", "ie", "def", "word", "char", "nt", "index", "ry", "comment", "escape", "match", "chain", "file", "header", "key", "ent", "result"], "count": ["OUNT", "counter", "z", "read", "cloud", "length", "total", "c", "cont", "amount", "Count", "batch", "base", "add", "acc", "found", "part", "check", "common", "cc", "ct", "cond", "cell", "ce", "buffer", "call", "f", "cache", "number", "n", "code", "ount", "child", "ctr", "start", "page", "all", "current", "core", "nt", "num", "index", "sum", "force", "comment", "size", "match", "len", "max", "nb"], "data": ["ata", "sample", "table", "done", "zero", "DATA", "batch", "raw", "results", "value", "part", "valid", "accept", "message", "ATA", "image", "buffer", "p", "content", "dec", "cache", "out", "str", "n", "window", "rel", "output", "step", "dat", " DATA", "all", "area", "next", "mat", "bytes", "size", "dl", "format", "text", "result", "d"], "fos": ["lOS", "voes", "foes", "Fos", " foes", "fOS", "voses", "Foes", " fios", "loss", "Foss", " foses", "los", "Foses", "fios", " foss", " fOS", "voss", "Fios", "vos", "foss", "foses", "lios", "FOS"]}}
{"id1": "20024612", "id2": "6866575", "code1": "    private void parse() throws Exception {\n        BufferedReader br = null;\n        InputStream httpStream = null;\n        URL fileURL = new URL(url);\n        URLConnection urlConnection = fileURL.openConnection();\n        httpStream = urlConnection.getInputStream();\n        br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\"));\n        String ligne;\n        String post;\n        String date;\n        String titre;\n        String resume;\n        String url2DL;\n        while ((ligne = br.readLine()) != null) {\n            if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) {\n                post = null;\n                date = null;\n                titre = null;\n                try {\n                    post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\")));\n                    ligne = br.readLine();\n                    date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24);\n                    date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim();\n                    log.info(\"Post   : \" + post + \" du \" + date);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\"));\n                    titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim();\n                    url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\";\n                    log.info(\"Titre  : \" + titre);\n                    log.info(\"To DL  : \" + url2DL);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\"));\n                    resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    log.info(\"Resume : \" + resume);\n                } catch (Exception e) {\n                    log.error(\"ERREUR : Le film n'a pas pu etre parse...\");\n                }\n                log.info(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\");\n            }\n        }\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["process", "feed", "fork", "read", "handler", "se", "build", "reset", "print", "Parser", "request", "construct", "start", "init", "search", "save", "launch", "file", "data", "execute", "parser", "format", " parsing", "open", " parser", "handle", "load"], "br": ["bt", "bh", "lr", "shr", "nr", "bs", "b", "bn", "Br", "bf", "be", "gr", "bm", "sp", "yr", "reader", "r", "bd", "wr", "hr", "buf", "rel", "bl", "eb", "ctr", "cr", "dr", "rb", "bro", "adr", "tr", "BR", "bp", "bridge", "ger", "brace", "pr", "fr", "ren", "kr", "bre", "ber", "vr", "bsp", "bc", "mr", "browser", "shell", "arr"], "httpStream": ["upperStream", "xmlConnection", "upperContext", "httpBody", "upperBody", "feedSocket", "httpsSteam", "ttpBody", "ttpData", "xmlStream", "httpData", " httpConnection", "httpsSocket", "upperSteam", "ttpStream", "httpsStream", "feedStreamer", "hrSocket", "upperConnection", "xmlContext", "httpsStreamer", "httpContext", "feedSteam", " httpSteam", "hrStream", "hrStreamer", "xmlSteam", " httpContext", "upperData", "ttpSteam", "httpConnection", "httpSocket", " httpBody", "httpStreamer", "hrSteam", " httpData", "httpSteam", "feedStream"], "fileURL": ["fileSR", "urlSSL", "urlLocation", "FileSSL", " fileUrl", "FileUrl", " fileLocation", " fileSSL", "fileLocation", "fileSSL", "FileURL", "FileLocation", "fileUrl", "urlUrl", "FileSR", "urlSR", "urlURL", " fileSR"], "urlConnection": ["urlConnect", " urlConnect", " urlconnection", "URLConnector", "URLConnection", "urlClient", "webConfiguration", "webConnect", "httpconnection", "httpClient", "webConnection", " urlConfiguration", " urlClient", "urlConfiguration", "fileConnection", "URLConfiguration", "urlconnection", "httpConnect", "fileConnect", "httpConnection", "urlConnector", "URLConnect", "fileClient", "webConnector", " urlConnector", "fileconnection"], "ligne": [" lardi", "gigne", "liadr", "jligne", "liysis", "rligne", "lysis", " lubric", " lesson", "lorde", "slenge", "ligation", "ylourse", "iligne", "gourse", "llysis", "clagen", "lade", "llourse", "longe", " lotto", "llubric", "slubric", "lubric", " laxy", "alounge", "iladr", " line", "rliner", "lroit", "jlonge", " lien", "giner", "ylige", "liesson", "lligne", "lounge", "aliner", "bline", "alonge", " language", " lagen", "ellwine", "line", "liotto", "lotto", "lige", "jlagen", "ylroit", " lenge", "liige", "yladr", "vigne", "lene", "lligation", "lardi", "lladr", "ilien", "lesson", "glien", "sladr", "sliven", " longe", "liorde", "gligation", "liigation", " lige", " liner", "iliner", " lroit", "llazy", "yligne", "slotto", " lounge", "slige", "vonge", "liubric", "sligne", "blounge", "jlene", "gligne", "clanguage", "jlige", "rladr", "slourse", " ladr", " ligation", "liiven", "bladr", "bliner", "liourse", "lenge", "clubric", "viner", "liroit", "slardi", "aligne", " lorde", "liene", "liounge", "yliner", "ylazy", "blige", " lwine", "ellourse", "jligation", "slaxy", "sline", "llounge", "lagen", "liven", "liiner", "liigne", "bligne", "llige", "jliner", "vysis", "slounge", "rlorde", "jlanguage", "lazy", "lwine", "llonge", "lourse", " lene", " lazy", "elligation", "ladr", "elligne", "llade", "lionge", "liwine", " liven", "slonge", "cligne", " lade", "llaxy", "jlubric", "language", "liade", "glounge", " lourse", "lliner", "alige", "lien", "llenge", "liardi", "laxy", "gesson", "llien", "liner"], "post": ["pass", "mod", "tt", "tim", "row", "pl", "pos", "zip", "po", "pp", "pid", "zero", "POST", "back", "url", "key", "prefix", "add", "parent", "ost", "pg", "son", "id", "name", "p", "port", "log", "patch", "op", "put", "proc", "code", "pre", "ip", "Post", "hot", "title", "page", "save", "body", "index", "draw", "posts", "pres", "col", "comment", "form", "data", "time", "type", "text", "wp", "ps", "pt"], "date": ["month", "note", "update", "diff", "cal", "end", "get", "today", "add", "reason", "day", "Date", "when", "name", "now", "change", "grade", "oday", "md", "mate", "log", "dig", "week", "number", "night", "me", "trade", "code", "pe", "no", "debug", "due", "dates", "set", "dat", "create", "local", "string", "page", "title", "state", "result", "bon", "notice", "ate", "index", "zone", "json", "te", "tag", "draw", "mail", "age", "comment", "file", "data", "dt", "type", "late", "days", "time", "dated", "year", "pose", "event", "duration"], "titre": ["tolitbre", "Tittbre", "tolitre", "Tittres", "TitRE", "titsrie", "nitrev", "nittere", "TittRE", "ltitre", "Titres", "Tittrie", "nitere", "titebre", "titarer", "tipRE", "tipbre", "tistbre", "nittRE", "ltitere", "Tittre", "tipere", "titrie", "tuitre", "tITRE", "Titbre", " titrer", "titr", "titabre", " tolitbre", "titerie", "tITrev", "tittrie", "tITere", "titar\u00e9", "tiprer", "titare", " titbre", "tistrie", "tuitrev", "ptitre", "tuitere", "totr", "titeres", "titerbre", "ltitr", "ptittbre", "totr\u00e9", "titsres", "tittr\u00e9", "nittrev", "tolitrer", "titere", "ptittre", "titerre", "tipres", "ptittrie", "tittr", "ptitrie", "titRE", "tittres", "titsre", "tistrate", "tittrev", "titrev", "tITres", "ltittre", "tittRE", "tuitRE", " titere", "ptittrate", " tolitre", "titres", "ltittere", "tittrate", "totre", "nitre", "tipre", "ltittr\u00e9", "Titre", "totere", "titerrate", "ptitrate", " tolitrer", "titr\u00e9", "Titrie", "titerrie", "titbre", "nittre", "tITre", "ltittr", "tistre", "titar", "titaere", "ptitbre", "titrer", "nitRE", "ltitr\u00e9", "tittere", "titsbre", "tittbre", " tolitere", "tittre", "titrate", "tITbre", "tolitere"], "resume": ["reserve", "preserve", "RESumption", "presolve", "presume", "RESolve", "RESume", "Reserve", "Resumption", "Resume", "presumption", "Resolve", "resolve", "resumption", "REServe"], "url2DL": ["url1DL", "url12DL", "Url4DL", "url2dl", "url4FL", "url22DD", "url1LL", "url12DS", "url02LL", "url4DD", "url5DD", "url7DL", "url2DR", "url1dl", "url3dl", "url3DL", "url2DM", "url22DL", " url5DB", "url2FL", "url2DS", " url2DB", "url2TL", "url02URL", " url2dl", " url5DM", "url2URL", "url5DM", "url22DR", " url2URL", "url4DM", " url1dl", "url5DR", "Url2LL", "url7DD", " url1LL", "Url2DD", " url5DS", "Url2DR", "url7DS", "url2DB", "url5FL", " url2TL", "url7DB", " url5DL", "url2DD", "url1URL", "url02dl", "url22LL", " url5DD", "url3LL", " url2DS", "url5DL", "url4LL", " url2DD", " url2LL", "Url4DR", " url2DM", "url2LL", "url5DB", "Url4DD", "url12DD", "url02DL", " url1URL", " url5TL", " url2FL", " url1DL", "url12DB", "url4DL", "url3URL", " url5FL", "Url2DL", "url5LL", "Url4LL", "url5TL", "url4TL", "url5DS", "url4DR"]}}
{"id1": "19849797", "id2": "17116123", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFile", " copyStream", "transferStream", "transferfile", " cpStream", "transferFiles", " cpfile", " copyfile", "copyfile", " cpFiles", " copyFiles", "copyFiles", "copyStream", " cpFile"], "sourceFile": [" sourcePath", " sourcePage", "srcPath", "ourcePath", "srcLine", "ourceFile", "srcField", "ourceField", "ourceTable", "sourcePage", "sourceLine", "sourcefile", "srcFile", "sourcePath", "srcPage", "ourcePage", " sourceLine", "srcfile", "sourceTable", " sourceField", " sourcefile", "ourceLine", "sourceField", "srcTable", " sourceTable", "ourcefile"], "destFile": ["datPlace", "declEntity", "optFolder", "destDir", "DestFile", "destFilename", "restPlace", "optPath", "optFile", "srcFolder", "DestPath", "srcPath", " destPath", "DestFilename", "DestFiles", " destDir", "destEntity", "restFile", "optFilename", "srcFile", " destFilename", " destPlace", "declFile", "destFolder", "destPath", "optEntity", "srcFiles", "datFilename", "destFiles", "datFiles", "restFiles", "datFile", "DestDir", "srcDir", "destPlace", "srcEntity", "declDir", " destFiles", "restFilename", "declFolder", "optDir"], "source": ["src", "before", "OURCE", "send", "note", "in", "parse", "update", "sample", "local", "SOURCE", "table", "component", "back", "score", "se", "stream", "scope", "none", "parent", "check", "store", "ce", "slave", "iterator", "use", "scale", "image", "resource", "sequence", "spec", "owner", "reader", "service", "console", "ource", "standard", "from", "iter", "start", "create", "init", "origin", "copy", "search", "inner", "style", "ie", "load", "input", "missing", "char", "body", "index", "target", "proxy", "query", "show", "force", "Source", "comment", "cause", "match", "subject", "channel", "attribute", "pose", "series", "result", "shell"], "destination": ["destined", "separment", "Destinator", "decinate", "noninate", "nonination", "decination", "descation", "descinate", "verination", " destation", "restinator", "descinator", "verinated", "termininate", " destinate", " destinator", "noninator", "restinated", "destation", "Destation", " destificate", "veration", "descination", " destment", "separinated", "separation", "Destination", "decined", "separination", "destificate", "Destment", "Destinate", "noninated", "Destinated", "restinate", "destinator", " destined", "destinate", "terminined", " destinated", "termininated", "destinated", "destment", "restination", "decinated", "terminination", "verificate", "Destificate"]}}
{"id1": "9824814", "id2": "4056444", "code1": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 0, "substitutes": {"run": ["go", "exec", "sample", "un", "get", "block", "runs", "build", "runner", "unit", "call", "begin", "play", "running", "Run", "test", "start", "work", "render", "launch", "show", "loop", "execute", "job", "open"], "file": ["record", "fast", "File", "text", "upload", "ile", "http", "binary", "FILE", "picture", "table", "handler", "document", "fp", "rule", "path", "object", "get", "base", "stream", "e", "files", "fe", "error", "name", "message", "port", "resource", "image", "p", "log", "f", "io", "reader", "content", "out", "pe", "user", "local", "output", "entity", "page", "string", " File", "tree", "class", "instance", "body", "fine", "le", "session", "web", "db", "pool", "face", " FILE", "header", "data", "lock", "channel", "type", "format", "download", "filename", "handle", "result", "angle"], "inputStream": ["inputView", "InputFile", " inputFile", "inputFile", " InputFile", "InputStream", "InputView", " inputView", " InputView", "InputPath", " InputPath", "inputPath", " InputStream", " inputPath"], "url": ["domain", "sql", "u", "ur", "http", "email", "link", "b", "https", "document", "il", "path", "github", "ls", "host", "base", "get", "socket", "build", "address", "name", "client", "id", "resource", "uri", "l", "log", "sl", "r", "nl", "library", "rl", "service", "str", "loader", "method", "mount", "www", "location", "ssl", "string", "page", "server", "Url", "web", "mail", "ul", "xml", "dl", "loc", "ll", "channel", "open", "cert", "URL", "browser", "builder"], "beatportAccessor": ["beatportAccessutor", "beatportSelecter", "beatcraftAccessor", "beatportaccessior", "beatcraftAdaptor", "beatportAdaptor", "beatportAdapter", "beatcraftAdaptior", "beatportAdaptior", "beatportSelectior", "beatcraftAccessOR", "beatportAdaptOR", "beatportProcessor", "beatportAccesser", "beatportaccessutor", "beatportProcesser", "beatphoneaccesser", "beatphoneaccessor", "beatportaccessor", "beatphoneAccesser", "beatportSelectOR", "beatportSelector", "beatportaccessOR", "beatphoneaccessutor", "beatphoneAccessor", "beatportProcessOR", "beatportCreatOR", "beatportAccessOR", "beatcraftAdaptOR", "beatcraftAccesser", "beatcraftAdapter", "beatportaccesser", "beatportCreater", "beatportCreator", "beatportAccessior", "beatportCreatutor", "beatphoneAccessutor", "beatportProcessutor", "beatphoneAccessOR", "beatphoneaccessOR", "beatcraftAccessior"], "sessionCookies": ["SessionCookies", "sessioncooks", "sessionCopies", "sessionBuffs", "essionCookles", " sessioncookys", "sessionCels", "sessioncookies", "sessioncookles", "essionCoples", "sessionCms", "sessioncookrys", "essionCopms", "SessionCookles", "sessionCoples", "sessionCookries", "sessionCookels", " sessionCookles", "sessionCookrys", "sessionCopms", "sessionBuffries", "essionCookessions", "sessionCookessions", " sessionBuffries", " sessioncookles", "sessionCessions", "sessionCs", "Sessioncookrys", "sessionCles", "sessionStries", "sessionCries", "sessionCies", "sessionCookles", "Sessioncookies", "sessionBuffies", "sessioncookms", " sessionCookels", "sessionPrefs", "sessionCookms", "SessionCooks", "sessioncookessions", "sessionCrys", "sessionStrys", " sessionBuffs", "sessionStrles", " sessionCooks", "essionCookies", "sessionPrefrys", "sessionCooks", " sessioncookies", "sessionStrels", "Sessioncooks", "essionCookms", "sessioncookels", " sessionBuffies", "sessionCookys", " sessioncookels", "sessionPrefles", "sessionCopessions", "sessioncookries", "sessionCys", " sessionCookys", "sessioncookys", "essionCopies", "essionCopessions", "sessionPrefies", "SessionCookrys", " sessionCookries", "Sessioncookles"], "connection": ["record", "computer", "link", "handler", "close", "c", "document", "ion", "engine", "termination", "statement", "creation", "character", "information", "reference", "cone", "condition", "version", "established", "reason", "socket", "settings", "Connection", "client", "context", "resource", "message", "directory", "to", "uri", "log", "pointer", "conn", "operation", "connected", "number", "created", "still", "method", "application", "function", "controller", "location", "language", "internet", "token", "con", "position", "network", "database", "json", "session", "relation", "communication", "connect", "description", "data", "response", "channel", "entry", "translation", "command", "result", "collection"], "contentLength": ["documentToken", "ontentLen", "ontentFrame", "ContentENGTH", "ontentToken", "codeLen", "ContentDuration", "sizeSize", " contentDuration", "ContentType", " contentSize", "documentSize", "ContentSize", "Contentlength", "contentToken", "ContentLen", "sizeLen", "contentDuration", "contentFrame", "codeENGTH", "ontentlength", "sizeType", "contentSize", "contentlength", " contentType", "contentLen", "ontentSize", "ontentLength", "documentLength", "codelength", " contentToken", "contentType", " contentENGTH", "codeLength", " contentlength", "ContentLength", "sizeLength", " contentLen", " contentFrame", "contentENGTH", "documentLen", "ontentDuration", "ContentFrame"], "size": ["storage", "send", "length", "sample", "empty", "total", "done", "zero", "capacity", "amount", "grow", "speed", "SIZE", "count", "scale", "address", "name", "summary", "limit", "news", "content", "cache", "Size", "scroll", "number", "height", "sent", "set", "timeout", "state", "small", "ize", "position", "notice", "area", "body", "index", "sum", "huge", "fee", "city", "sized", "bytes", "data", "max", "type", "serial"], "downloaded": ["info", "_", "Exception", "https", "this", "New", "call", "connect"], "status": ["process", "active", "progress", "mode", "version", "scale", "error", "id", "name", "summary", "login", "s", "flag", "service", "source", "code", "start", "stat", "complete", "state", "server", "wait", "Status", "type", "result"], "success": ["failed", "ccess", "successful", " proceed", "Success", "progress", " succeed", " successfully", "top", " succ", "results", "cc", " failure", " Success", "summary", " completion", "continue", " succeeds", " suc", " shutdown", " successes", "exist", " successful", "fail", "successfully", "result", "accept"]}}
{"id1": "8452134", "id2": "4272289", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public static int[] sortstring(int[] a1) {\n        int temp;\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        return a1;\n    }\n", "label": 0, "substitutes": {"exists": ["comist", "exits", " exits", "Exits", "existies", " exinates", "Exinates", " exies", "comception", "existinates", "existits", "exinates", "exception", "xits", "xception", "extist", "xist", "Exists", "xists", "extception", "exies", "Exies", "extists", "exist", "existists", "comits", "extits", "comists"], "fileToCheck": ["filetoSee", "file2Check", "fileToSee", "pathTOCheck", "fileTOSee", "fileTOcheck", "filetoCheck", "filenameTOcheck", "pathToWatch", "fileTOTest", "filenameTOTest", "pathTOWatch", "file2check", "pathTOSee", "fileTOWatch", "filenameToCheck", "pathTOTest", "fileToTest", "pathToCheck", "pathToSee", "pathToTest", "filenameToTest", "filetoTest", "filenameTocheck", "fileToWatch", "fileTocheck", "file2Test", "filenameTOCheck", "fileTOCheck", "filetoWatch"], "ftp": ["ifttp", "lattp", " ftps", "aftchange", "ldph", "iftphp", "rotl", "ftv", "fabp", " ftph", "fabph", "rotcp", " ftt", "aptcp", "ftm", "ftchange", " ftchange", "aftp", " ftc", "rotchange", "aftv", "ctps", "ftt", "iftcache", "ctcp", " ftcp", "aftc", " ftpl", "ftr", "ftcache", "iftp", "ffc", "latcache", "ftphp", "rotpl", " ftr", "ftl", "latphp", "ldphp", "ldp", "ffp", "cttp", " fttp", "aftpl", "apttp", "ffr", "ldc", "rotm", "aftl", "fttp", "ftps", "rotp", "rotps", "ftc", "aptl", "fabphp", "aftr", " ftphp", "fft", "fabc", "aftt", " ftv", "ftcp", "aptp", "ffv", "afttp", "ctp", "aftm", "ffcp", "ffcache", "ftph", "ftpl", "latp", " ftl", " ftm", "fftp", "aftcp", "rottp", "ffphp"], "found": ["full", "matched", "failed", "initialized", "successful", "finished", "built", "done", "affected", "started", "success", "results", "valid", "count", "ed", "id", "Find", "enabled", "seen", "needed", "out", "created", "killed", "tested", "good", "find", "expected", "search", "printed", "fixed", "result", "installed", "successfully", "index", "checked", " Found", "filled", "elt", "identified", "fd", "loaded", "Found", "sent", "finder", "d"], "reply": ["record", "ret", "answer", "echo", "pop", "link", "close", "zero", "repl", "back", "mi", "onse", "base", "success", "strip", "count", "check", "cor", "error", "message", "post", "ply", "ping", "report", "print", " Reply", "nl", "flag", "sync", "code", "txt", "replace", "state", "push", "conf", "continue", "vote", "notice", "Reply", "index", "next", "embed", "force", "comment", "msg", "match", "py", "response", "len", "nb", "status", "result", "shell"]}}
{"id1": "1421557", "id2": "13783549", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToDisk", "encodeStringToFiles", "encodeStringAsFile", "encodeStringToFile", "encodeStringAsStream", "encodeFiletoDisk", "encodeStringToStream", "encodeFiletoFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileAsStream", "encodeFileAsFiles", "encodeFiletoFiles", "encodeStringAsFiles", "encodeFileFromFile", "encodeFileAsFile", "encodeFileFromDisk", "encodeFiletoStream", "encodeStringAsDisk", "encodeFileToStream", "encodeFileAsDisk", "encodeFileFromFiles", "encodeFileToFiles"], "infile": ["Inbase", "inpath", "outFile", "outfilename", "InFile", "outpath", " infilename", "Infile", " inbase", "inFile", "inputFile", "inbase", " inFile", "inputpath", "infilename", " inpath", "inputfile", "inputfilename", "Inpath", "outbase"], "outfile": ["outfp", " outname", "infp", "outFile", "newname", "outfilename", "newfilename", "inname", " outFile", "fromFile", "outname", "todir", "outdir", "inFile", " outfilename", "newFile", "fromdir", "tofp", "indir", "fromfp", "tofile", "infilename", "fromfile", "toFile", "newfile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "image", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "ro", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "up", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "total", "variable", "document", "length", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "cache", "number", "temp", "queue", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "attribute", "append"], "read": ["before", "each", "text", "send", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", "ok", "submit", "ratulations", " succ", "condition", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "ith", " Success", "summary", "primary", "commit", "positive", "surv", "same", "good", "safe", "complete", "continue", "second", "sufficient", "democracy", "town", " okay", "warning", "unity", "please", " successes", "first", "support", "city", " successful", "ceed", "fail", "response", "successfully", "status", "result", "crit", "accept"]}}
{"id1": "5237257", "id2": "3806532", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"download": ["paste", " downloads", " Download", "upload", "dump", " downloading", " drop", "open", "get", " seek", "delete", " restore", " browse", " retrieve", "Download", "write", " zip", " upload", " downloaded", " checkpoint", "init", "copy", "export", "save", " recover", " dump", "file", "load"], "fileName": ["projectPath", " filename", "resourcePath", " fileFilename", "fileTime", "FileType", "resourceName", "FILEName", "FileTime", " fileTime", "imageName", "FILEPath", "FilePath", "fileType", "FILEFilename", " fileType", "FILEname", "projectname", "resourceType", "resourceTime", "projectName", "fileFilename", "projectFilename", "FileName", "imagePath", "filename"], "filePath": [" fileId", "resourcePath", "fileP", "FileId", "fileId", "languageId", "FILEpath", "resourceName", " fileUrl", "languagePath", "FILEName", "FILEUrl", "fileStart", "FILEP", "FILEPath", "FilePath", "languageName", "FileStart", "filepath", "resourcepath", "fileUrl", "FileP", "resourceUrl", " filepath", "FileName", "ileStart", "ileName", "FILEStart", "ileP", "ilePath"], "in": ["gin", "m", "re", "im", "read", "nin", "mi", "o", "up", "cin", "it", "on", "pi", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "login", "l", "rin", "f", "io", "r", "ai", "inc", "al", "one", "n", "ln", "st", "iter", "IN", "from", "win", "init", "local", "en", "bin", "inner", "isin", "ie", "con", "input", "sin", "din", "i", "inside", "el", "is", "co", "ar", "In", "net"], "out": ["cn", "os", "null", "t", "note", "w", "po", "nin", "gt", "end", "ion", "ch", "o", "up", "aos", "na", "it", "on", "or", "ns", "name", "client", "p", "v", "can", "obj", "to", "outs", "boot", "io", "op", "we", "conn", "write", "not", "n", "no", "user", "cos", "output", "ex", "Out", "inner", "con", "nt", "conv", "outer", "ou", "oss", "i", "at", "sys", "OU", "file", "OUT", "co", "ne", "ent", "net"]}}
{"id1": "3330944", "id2": "732800", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"extractImage": ["extractorImage", "extractImages", "ExtractImages", "extlateImage", "extprocessFrame", "ExtprocessFrame", "ExtprocessImage", "Extprocessimage", "extractorImages", "extlateFrame", "ExtprocessImages", "extprocessImage", "Extractimage", "extlateImages", "extractFrame", "ExtractFrame", "extractorimage", "extlateimage", "ExtractImage", "extprocessimage", "extprocessImages", "extractorFrame", "extractimage"], "input": ["before", "null", "upload", "sample", "audio", "empty", "rc", "path", "url", "base", "prefix", "it", "raw", "check", "internal", "error", "address", "this", "context", "image", "buffer", "ins", "p", "uri", "background", "seed", "hidden", "out", "request", "Input", "source", "q", "str", "select", "from", "start", "ip", "init", "local", "origin", "string", "txt", "pattern", "partial", "current", "img", "tmp", "index", "query", "i", "config", "qa", "xml", "initial", "file", "data", "hello", "format", "text", "accept"], "output": ["pretty", "PUT", "path", "o", "Output", "prefix", "success", "oe", "icon", "name", "image", "generated", "port", "to", "print", "hidden", "temp", "put", "write", "out", "source", "current", "STDOUT", "target", "OU", "file", "OUT", "response", "type", "format", "display", "filename", "result"], "params": ["pretty", "styles", "modules", "eters", "details", "m", "packages", "pps", "eps", "actions", "phi", "images", "arms", "pkg", "devices", "prop", "docs", "points", "pi", "results", "settings", "pas", "Par", "abilities", "p", "users", "s", "spec", "AMS", "fps", "pins", "proc", "members", "gs", "pro", "param", "Parameters", "caps", "mm", "rs", "ctx", "keys", "types", "ports", "conf", " parameters", "jp", "properties", "units", "par", "photos", "las", "phys", "ims", "terms", "json", "changes", "ams", "parts", "config", "ars", "tools", "names", "marks", "chains", "requires", "stats", "options", "parents", "tags", "ps"], "w": ["m", "hw", "wb", "rw", "wh", "wx", "ws", "h", "o", "W", "e", "v", "p", "writer", "Ws", "f", "we", "sw", "write", "out", "q", "wr", "kw", "window", "n", "ew", "word", "wo", "wl", "wt", "wa", "Writer", "nw", "wal", "wd", "wp", "d"], "in": ["gin", "info", "sql", "null", "include", " IN", "po", "read", "nin", " din", "old", "path", "mc", "mi", "In", "base", "cin", "it", "raw", "e", "ini", "inf", "inn", "id", "name", "p", "ins", "rin", "f", "copy", "out", "al", "Input", "source", "one", "ln", "IN", "mm", "from", "win", "init", "local", "en", "isin", "bin", "inner", "all", "con", "edIn", "conf", "sin", "din", "phys", "ma", "i", "file", "is", "ar", "vin"], "dest": ["src", " dst", "wb", "orig", "Dest", "tif", "alt", "resp", "opt", "end", "cont", "path", "ws", "shape", "trans", "desc", "mem", "way", "oe", "pas", "decl", "p", "port", "rest", "to", "deg", "temp", "out", "dist", "write", "source", "buf", "st", "cat", "csv", "txt", "dat", "origin", "save", "img", "usr", "tmp", "nom", "target", "pipe", "lit", "des", "data", " destination", "loc", "display", "comb", "prop", "result", "dir"], "bi": ["ji", "bra", "obi", "hog", "bh", "bg", "bie", "umi", "rob", "buff", "b", " nib", "gi", "bs", "mu", "qi", "phi", "mi", "oi", "bf", "pi", "be", "beck", "isi", "bm", "bb", "di", "ini", "zi", "ib", "ba", "abi", "bo", "pb", "bank", "ibi", "obo", "vi", "ai", "bits", "ali", "ibe", "iri", "Bi", "jiang", "ni", "bin", "ble", "ki", "BI", "bp", "bil", "bas", "nb", "phy", "li", "i", "fi", "yi", "bis", "bone", "bc"], "os": ["Os", "mot", "ox", "ros", "pos", "bs", "oses", "ot", "us", "ons", "o", "ls", "css", "ios", "aos", "osi", "or", "oid", "es", "oes", "ns", "cs", "ow", "ose", "ts", "ows", "s", "mos", "io", "fs", "los", "acs", "ols", "oos", "ds", "ks", "bos", "ys", "ops", "oss", "sys", "is", "OS", "cos", "oo", "et", "obs"]}}
{"id1": "20924119", "id2": "18358467", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"gzip": ["mdef", "gZip", "mzip", " garchive", "garchive", "Garchive", "gdef", " gZip", "marchive", "GZip", "mZip", " gdef", "Gdef", "Gzip"], "zipout": [" zipnet", "logout", "zin", "gzouts", "zout", "gzout", "zou", " zipou", "gzconn", "zipou", "locko", "lockop", "zOut", "logOut", "zipop", " zipin", "gzOut", "zipouts", "login", "zouts", "zipin", "lockconn", " zipo", "zipo", "zipnet", "gzo", "lockout", " zipconn", "pipenet", "zipconn", "pipein", "pipeou", "logouts", "gzin", "znet", "gzop", "zipOut", " zipop", "pipeout"], "buffer": ["paste", "memory", "row", "phrase", "binary", "buff", "table", "sample", "variable", "document", "batch", "stream", "pad", "line", "block", "mem", "Buffer", "device", "history", "message", "sequence", "limit", "password", "seed", "cache", "number", "queue", "window", "buf", "code", "string", "word", "char", "database", "stack", "frame", "bytes", "header", "size", "data", "comment", "button", "command", "result", "attribute", "append"], "dir": ["pos", "det", "df", "pkg", "mk", "dra", "path", "add", "desc", "part", "parent", "del", "ind", "cond", " Dir", "cd", "directory", "direct", "md", "Dir", "req", "doc", "folder", "DIR", "dist", "ory", "cur", "out", "ir", "ord", "rect", "rel", "iter", "dat", "dr", "tree", "def", " director", " directory", "root", "tmp", "div", "draw", "db", "file", "fd", "fin", "dl", "self", "loc", "vol", "wd", "dd", "d"], "in": ["gin", "im", "read", "oin", "up", "cin", "on", "it", "ini", "inf", "check", "inn", "ind", "ain", "ins", "ic", "rin", "reader", "iter", "inc", "out", "al", "source", "like", "IN", "from", "act", "win", "ex", "init", "en", "isin", "inner", "bin", "input", "ri", "sin", "din", "inside", "i", "el", "form", "is", "and", "In"], "length": ["full", "join", "before", "row", "read", "total", "capacity", "ENGTH", "end", "component", "character", "SIZE", "count", "available", "history", "tail", "ind", "message", "sequence", "port", "frequency", "l", "number", "needed", "padding", "height", "impl", "start", "distance", "volume", "load", "ength", "position", "char", "Length", "body", "database", "index", "data", "match", "size", "hello", "len", "time", "type", "family", "text", "duration", "shape", "angle"]}}
{"id1": "13852596", "id2": "16572931", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"execute": ["process", " proceed", "exec", " replay", " executed", "run", " benchmark", " launch", " assemble", "evaluate", " deploy", " executable", " release", " evaluate", " eval", "construct", " execution", "init", " exec", "launch", " chain", " test", " scan", " inherit", " sweep", " perform", " resolve"], "resources": ["faces", "modules", "packages", "actions", "banks", "services", "rooms", "accessible", "rows", "roots", "lets", "results", "files", "relations", "artifacts", "issues", "they", "ifiers", "users", "resource", "these", "stores", "flows", "workers", "items", "uploads", "blocks", "res", "ids", " Resources", "groups", "rs", "Resources", "objects", "scripts", "pointers", "types", "ports", "writers", "locks", "ris", "archives", "reports", "names", "projects", "apps", "bytes", "builders", "models", "classes", "images", "ions"], "i": ["info", "ji", "ci", "t", "im", "in", "ia", "phi", "gi", "ii", "j", "mu", "I", "mi", "ti", "h", "oi", "ios", "pi", "e", "di", "ini", "ui", "hi", "list", "v", "multi", "abi", "l", "io", "ai", "\u0438", "q", "ali", "iri", "ori", "g", "iu", "bi", "ex", "ip", "cli", "si", "ij", "ri", "ki", "li", "xi", "ami", "ims", "bis", "ir"], "classFile": ["userFiles", "connectionFile", "fastfile", "ClassLine", "sourceFile", "ClassClass", " classFILE", "objectClass", "ClassFILE", "fastFiles", " classClass", " classTree", "classifiedFile", "cellClass", "attributeFILE", "attributeFiles", "clFile", "classfile", "clFiles", "recordFilename", "classTree", "instanceFile", "clTree", "userFile", "Classfile", "classifiedfile", " classfile", "cellFile", "parentfile", "userfile", "classChain", "sourceFILE", "typeFILE", "classDirectory", "ClassChain", " classFiles", " classSourceFile", "attributeResource", "classFiles", "classFILE", "targetSourceFile", "parentSourceFile", "recordfile", "parentFile", "classLine", "typeLine", "ClassFilename", " classResource", "sourceFiles", "ClassFile", "attributeEntry", " classFilename", " classChain", "targetFILE", "userFILE", "connectionFILE", "sourceClass", "clfile", "ClassTree", "targetFiles", "classifiedSourceFile", "ClassFiles", "classFilename", "recordFiles", "ClassSourceFile", "classEntry", "attributeChain", "typeFile", "connectionSourceFile", "instanceFilename", "classSourceFile", "attributeFile", "instanceFiles", "connectionfile", "classifiedFiles", "classFolder", " classLine", "typeFiles", "ClassEntry", " classFolder", "ClassDirectory", "objectFolder", "instanceDirectory", "fastFile", "recordFile", " classEntry", "classClass", "classifiedFILE", "fastFILE", " classDirectory", "objectFile", "classResource", "cellFolder", "ClassResource", "targetFile", "parentFILE"], "inputStream": ["ipStream", "familyFile", "innerSteam", "familySource", "inSteam", "thisSteam", "ipStyle", "ipSteam", "jsonStream", "inStreamer", "inputSt", "outputPort", "outputSteam", "errorSteam", "jsonSteam", "familyStyle", " inputstream", "inputPort", " inputFile", "thisFile", "InputTime", "jsonStreamer", "outputstream", "inputSteam", "audioSteam", "audioStreamer", "thisSource", "thisStream", "InputMode", "ipFile", "inPort", " inputPort", "inputStreamer", "errorstream", "innerSet", "instream", "inputSet", " inputSteam", "audioStream", "innerStream", "inputSource", "outputFile", "inputFile", "outStreamer", "inputTime", "familyStream", "inputStyle", "outStream", "outputTime", "inputMode", "outSteam", "inputstream", " inputSt", "inSet", "InputSteam", " inputTime", " inputSource", "outputStyle", "errorStream", "jsonSet", "innerStreamer", "InputStream", " inputMode", "Inputstream", "inStream", "outSt", "errorMode", "audioSt", " inputStreamer", "familySteam"], "reader": ["editor", "dd", "row", "older", "per", "read", "handler", "variable", "document", "rar", "ner", "rule", "key", "definition", "driver", "prototype", "stream", "worker", "rer", "peer", "oder", "iterator", "client", "image", "runner", "er", "owner", "wrapper", "master", "r", "readable", "write", "service", "rl", "test", "user", "draft", "Reader", "dr", "inner", "operator", "instance", "ger", "query", "review", "manager", "actor", "red", "Writer", "penter", "reading", "layer", "parser", "ler", "entry", "loader", "field", "author", "mr", "finder", "builder"], "oldSize": ["oldersize", "oldFontSize", "oldLength", "olderLength", " oldLength", "OLDFontSize", " oldsize", "oldsize", "OLDsize", "OLDSize", "OLDLength", "olderSize", " oldFontSize", "olderFontSize"], "writer": ["editor", "adder", "row", "rw", "wb", "storage", "w", "written", "read", "handler", "variable", "document", "ner", "key", "definition", "driver", "weight", "worker", "wrote", "message", "buffer", "er", "riter", "runner", "wrapper", "writing", "owner", "r", "write", "service", "method", "buf", "node", "test", "draft", "Reader", "inner", "writers", "word", "player", "walker", "review", "draw", "actor", "ter", "manager", "Writer", "penter", "parser", "entry", "ler", "loader", "format", "author", "finder", "vector", "builder"], "b": ["m", "u", "wb", "t", "w", "binary", "bs", "c", "erb", "ab", "bit", "h", "a", "batch", "base", "bf", "bb", "ib", "fb", "v", "p", "B", "bound", "l", "f", "emb", "r", "bits", "mb", "gb", "n", "g", "sb", "bin", "rb", "br", "bp", "db", "ob", "bis", "nb", "d"], "outputStream": ["outputForm", "writePoint", " outputForm", "outputSteam", "outputPoint", "writeStream", "resultString", "resultForm", "OutputStream", "resultSteam", "outputstream", "inputSteam", "OutputString", "resultstream", " outputString", "OutputForm", "inputView", "writeSteam", "Outputstream", "writeView", " outputPoint", "resultStream", "inputstream", "OutputSteam", "outputString", "inputPoint", "outputView", " outputView", " outputSteam", "inputForm"], "injectedClasses": ["injectedUsES", "injectedUsBytes", "injectedCountes", "injectedUsets", "injectUsES", "injectUsBytes", "injectUsets", "injectedCountES", "injectedClassES", "injectedUses", "injectedClassets", "injectUses", "injectedCountBytes", "injectedClassBytes", "injectedCountets", "injectedSuccessBytes", "injectClassES", "injectedSuccesses", "injectClasses", "injectClassets", "injectedSuccessets", "injectedSuccessES", "injectClassBytes"], "newSize": ["newMax", "oldFontSize", "newFontSize", "newName", " newName", " newFontSize", "NewSize", "NewMax", "NewFontSize", " newMax", "NewName", "oldMax", "oldName"]}}
{"id1": "17161805", "id2": "21489105", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"encode": ["Enforce", "encforce", "enscode", "enprocess", "enccode", "unode", "Enode", "enode", "ensforce", "unprocess", "uncode", "enforce", "Encode", "unforce", "ensprocess", "encprocess", "ensode"], "plaintext": ["plainText", " plainlat", "plainlat", "mainText", "maintext", "formmessage", " plainth", " plainText", "formdata", "plaindata", "prontext", "formText", "pronlat", "ainText", "aintext", "formtext", "plainth", "plainmessage", "ainmessage", "pronText", " plaindata", "mainth", " plainmessage", "aindata", "pronth", "mainlat"], "md": ["mod", "m", "ms", "med", "det", "pd", "df", "amd", "ld", " MD", "managed", "mk", "dh", "mc", "pm", "add", "MD", "ng", "del", "ind", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "pdf", "sha", "der", "nt", "hd", " Md", "red", "mand", "grad", "msg", "mo", "mp", "dd", "d"], "raw": ["full", "hex", "row", " Raw", "orig", "read", "unsigned", "custom", "bare", "strip", "value", "mem", "aw", "valid", "sh", "message", "bound", "map", "stable", "wrap", " RAW", "clean", "unknown", "n", "buf", "cmd", "pack", "inner", "Raw", "def", "input", "cooked", "modified", "RAW", "json", "des", "bytes", "rendered", "serial", "derived"]}}
{"id1": "11616716", "id2": "7425022", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultsasSteam", "getCMSResultasStream", "getCMSResultasString", "getCMSResultasSteam", "getCMSResultsasStream", "getCMSResultAsSteam", "getCMSResultsAsStream", "getCMSResultsasView", "getCMSResultsAsView", "getCMSResultsAsSteam", "getCMSResultAsString", "getCMSResultAsView", "getCMSResultasView", "getCMSResultsasString", "getCMSResultsAsString"], "rqlQuery": ["rumbleStatement", "rqlString", " rqlStatement", "rsqlStatement", "rqQuery", "rqString", "rqlquery", "rsqlString", "rQLQuery", "rqStatement", "rumbleString", "rqlStatement", "rQLquery", "RqlQuery", " rqlString", "rumbleQuery", "RQLQuery", " rsqlQuery", " rsqlStatement", "rviewCommand", "rqlCommand", "rsqlQuery", "RQLCommand", "RQLquery", "rQLCommand", " rsqlString", "rqquery", "Rqlquery", "rviewquery", "RqlCommand", "rqCommand", "rviewQuery"], "osr": ["osesr", "osvr", " osrar", "ioscr", " ossr", "iosvr", "iossr", "oosd", "oesrw", "osq", "ossh", "oesr", "oser", "ioser", "osh", "oosr", "ossrar", "posrator", "ossr", "or", "osrw", "osd", "osser", "iosmr", "oscr", " osq", "oesmr", " oscr", "posr", "osscr", "oseser", "osmr", "possr", " osh", "iosh", "iosd", "ossvr", "osrar", "ossq", "iosrator", "ossmr", "osrg", "osesmr", "ovr", "ossrw", "oessr", "oesrator", " osvr", " osrg", "osssr", "osesrw", "osrator", "ossrg", "ooscr", "orar", "iosq", "ooser", "iosrg", "ossd", "oeser", " osmr", "iosr"], "url": ["ret", "bel", "ur", "http", "hl", "link", "ld", "https", "pkg", "il", "ls", "host", "gl", "build", "client", "ol", "l", "uri", "sl", "nl", "mb", "str", "rel", "mount", "ssl", "char", "Url", "web", "mail", "ul", "el", "abs", "ll", "lb", "loc", "dl", "open", "cert", "URL", "net"], "conn": ["nc", "cn", "os", "exec", "link", "j", "resp", "close", "c", "cont", "syn", "ch", "ct", "pg", "pas", "cp", "socket", "ns", "client", "connection", "obj", "l", "req", "sync", "out", "Conn", "enc", "connected", "cur", "org", "n", "proc", "res", "rel", "cmd", "act", "ctx", "win", "init", "comm", "con", "jp", "conf", "nt", "conv", "cb", "connect", "canon", "addr", "sys", "nw", "loc", "open", "cert", "col"]}}
{"id1": "13852596", "id2": "14053882", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"execute": ["process", " proceed", "exec", " replay", " executed", "run", " benchmark", " launch", " assemble", "evaluate", " deploy", " executable", " release", " evaluate", " eval", "construct", " execution", "init", " exec", "launch", " chain", " test", " scan", " inherit", " sweep", " perform", " resolve"], "resources": ["faces", "modules", "packages", "actions", "banks", "services", "rooms", "accessible", "rows", "roots", "lets", "results", "files", "relations", "artifacts", "issues", "they", "ifiers", "users", "resource", "these", "stores", "flows", "workers", "items", "uploads", "blocks", "res", "ids", " Resources", "groups", "rs", "Resources", "objects", "scripts", "pointers", "types", "ports", "writers", "locks", "ris", "archives", "reports", "names", "projects", "apps", "bytes", "builders", "models", "classes", "images", "ions"], "i": ["info", "ji", "ci", "t", "im", "in", "ia", "phi", "gi", "ii", "j", "mu", "I", "mi", "ti", "h", "oi", "ios", "pi", "e", "di", "ini", "ui", "hi", "list", "v", "multi", "abi", "l", "io", "ai", "\u0438", "q", "ali", "iri", "ori", "g", "iu", "bi", "ex", "ip", "cli", "si", "ij", "ri", "ki", "li", "xi", "ami", "ims", "bis", "ir"], "classFile": ["userFiles", "connectionFile", "fastfile", "ClassLine", "sourceFile", "ClassClass", " classFILE", "objectClass", "ClassFILE", "fastFiles", " classClass", " classTree", "classifiedFile", "cellClass", "attributeFILE", "attributeFiles", "clFile", "classfile", "clFiles", "recordFilename", "classTree", "instanceFile", "clTree", "userFile", "Classfile", "classifiedfile", " classfile", "cellFile", "parentfile", "userfile", "classChain", "sourceFILE", "typeFILE", "classDirectory", "ClassChain", " classFiles", " classSourceFile", "attributeResource", "classFiles", "classFILE", "targetSourceFile", "parentSourceFile", "recordfile", "parentFile", "classLine", "typeLine", "ClassFilename", " classResource", "sourceFiles", "ClassFile", "attributeEntry", " classFilename", " classChain", "targetFILE", "userFILE", "connectionFILE", "sourceClass", "clfile", "ClassTree", "targetFiles", "classifiedSourceFile", "ClassFiles", "classFilename", "recordFiles", "ClassSourceFile", "classEntry", "attributeChain", "typeFile", "connectionSourceFile", "instanceFilename", "classSourceFile", "attributeFile", "instanceFiles", "connectionfile", "classifiedFiles", "classFolder", " classLine", "typeFiles", "ClassEntry", " classFolder", "ClassDirectory", "objectFolder", "instanceDirectory", "fastFile", "recordFile", " classEntry", "classClass", "classifiedFILE", "fastFILE", " classDirectory", "objectFile", "classResource", "cellFolder", "ClassResource", "targetFile", "parentFILE"], "inputStream": ["ipStream", "familyFile", "innerSteam", "familySource", "inSteam", "thisSteam", "ipStyle", "ipSteam", "jsonStream", "inStreamer", "inputSt", "outputPort", "outputSteam", "errorSteam", "jsonSteam", "familyStyle", " inputstream", "inputPort", " inputFile", "thisFile", "InputTime", "jsonStreamer", "outputstream", "inputSteam", "audioSteam", "audioStreamer", "thisSource", "thisStream", "InputMode", "ipFile", "inPort", " inputPort", "inputStreamer", "errorstream", "innerSet", "instream", "inputSet", " inputSteam", "audioStream", "innerStream", "inputSource", "outputFile", "inputFile", "outStreamer", "inputTime", "familyStream", "inputStyle", "outStream", "outputTime", "inputMode", "outSteam", "inputstream", " inputSt", "inSet", "InputSteam", " inputTime", " inputSource", "outputStyle", "errorStream", "jsonSet", "innerStreamer", "InputStream", " inputMode", "Inputstream", "inStream", "outSt", "errorMode", "audioSt", " inputStreamer", "familySteam"], "reader": ["editor", "dd", "row", "older", "per", "read", "handler", "variable", "document", "rar", "ner", "rule", "key", "definition", "driver", "prototype", "stream", "worker", "rer", "peer", "oder", "iterator", "client", "image", "runner", "er", "owner", "wrapper", "master", "r", "readable", "write", "service", "rl", "test", "user", "draft", "Reader", "dr", "inner", "operator", "instance", "ger", "query", "review", "manager", "actor", "red", "Writer", "penter", "reading", "layer", "parser", "ler", "entry", "loader", "field", "author", "mr", "finder", "builder"], "oldSize": ["oldersize", "oldFontSize", "oldLength", "olderLength", " oldLength", "OLDFontSize", " oldsize", "oldsize", "OLDsize", "OLDSize", "OLDLength", "olderSize", " oldFontSize", "olderFontSize"], "writer": ["editor", "adder", "row", "rw", "wb", "storage", "w", "written", "read", "handler", "variable", "document", "ner", "key", "definition", "driver", "weight", "worker", "wrote", "message", "buffer", "er", "riter", "runner", "wrapper", "writing", "owner", "r", "write", "service", "method", "buf", "node", "test", "draft", "Reader", "inner", "writers", "word", "player", "walker", "review", "draw", "actor", "ter", "manager", "Writer", "penter", "parser", "entry", "ler", "loader", "format", "author", "finder", "vector", "builder"], "b": ["m", "u", "wb", "t", "w", "binary", "bs", "c", "erb", "ab", "bit", "h", "a", "batch", "base", "bf", "bb", "ib", "fb", "v", "p", "B", "bound", "l", "f", "emb", "r", "bits", "mb", "gb", "n", "g", "sb", "bin", "rb", "br", "bp", "db", "ob", "bis", "nb", "d"], "outputStream": ["outputForm", "writePoint", " outputForm", "outputSteam", "outputPoint", "writeStream", "resultString", "resultForm", "OutputStream", "resultSteam", "outputstream", "inputSteam", "OutputString", "resultstream", " outputString", "OutputForm", "inputView", "writeSteam", "Outputstream", "writeView", " outputPoint", "resultStream", "inputstream", "OutputSteam", "outputString", "inputPoint", "outputView", " outputView", " outputSteam", "inputForm"], "injectedClasses": ["injectedUsES", "injectedUsBytes", "injectedCountes", "injectedUsets", "injectUsES", "injectUsBytes", "injectUsets", "injectedCountES", "injectedClassES", "injectedUses", "injectedClassets", "injectUses", "injectedCountBytes", "injectedClassBytes", "injectedCountets", "injectedSuccessBytes", "injectClassES", "injectedSuccesses", "injectClasses", "injectClassets", "injectedSuccessets", "injectedSuccessES", "injectClassBytes"], "newSize": ["newMax", "oldFontSize", "newFontSize", "newName", " newName", " newFontSize", "NewSize", "NewMax", "NewFontSize", " newMax", "NewName", "oldMax", "oldName"]}}
{"id1": "1362", "id2": "23677147", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"bubbleSort": ["bubargeSort", "bubblesSort", "gobblingSort", "bubblesCompare", "gobblingLess", "bubbleCompare", "bubblingSort", "gobbleSort", "bubbleLess", "gobbleCompare", "bubblingCompare", "bubblesLess", "gobbleLess", "bubargeCompare", "bubblingLess", "bubargeLess", "gobblingCompare"], "a": ["aa", "go", "t", "aaa", "ata", "w", "ia", "va", "b", "isa", "z", "c", "ab", "h", "o", "alpha", "na", "ed", "au", "history", "ga", "es", "eas", "A", "list", "p", "v", "ae", "l", "f", "ea", "cache", "out", "ao", "window", "la", "g", "aka", "order", "aaaa", "an", "act", "att", "all", "app", "sa", "area", "ma", "changes", "trace", "el", "as", "apa", "form", "oa", "data", "era", "array", "da", "ap", "am", "ac", "arr"], "swapped": ["snaped", "swap", " swaps", "scaps", "Swaped", " swap", " swaped", " swapping", " snap", "SWap", "stickaps", "waped", "scaped", "snapped", "SWapped", "swaps", "SWaped", " snaped", "Swap", "snapping", " snapped", "wapping", "swaped", "stickaped", "Swapping", "snaps", "wapped", "Swapped", "SWapping", "scapping", "swapping", "stickapped", "waps", " snapping", "stickapping", "scapped"], "i": ["ji", "m", "ci", "u", "t", "im", "in", "phi", "j", "ii", "gi", "gu", "qi", "c", "my", "I", "us", "mi", "ti", "oi", "base", "pi", "it", "di", "ini", "ui", "ind", "zi", "id", "client", "hi", "y", "multi", "ic", "uri", "f", "io", "ai", "x", "iri", "ori", "me", "iu", "bi", "ip", "cli", "init", "origin", "si", "ie", "ij", "ki", "ri", "iso", "index", "sim", "li", "ix", "xi", "ami", "is", "uli", "key", "ei", "chain", "status", "ir"], "tmp": ["perm", "tt", "m", "mut", "cmp", "t", "orig", "attr", "pkg", "my", "mk", "managed", "prefix", "sq", "sp", "obj", "amp", "sam", "temp", "cache", "cur", "emp", "sup", "np", "same", "pre", "test", "txt", "ctx", "etc", "timeout", "td", "xy", "lib", "clip", "nom", "comp", "gm", "db", "tf", "tg", "MP", "mp", "nb", "result"]}}
{"id1": "6457199", "id2": "19096138", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["handleRequest", "handleResponse", "handlerequest", "dorequest", " dorequest", "handleQuery", "doQuery", " doQuery", "processrequest", "processResponse", "processQuery", " doResponse", "doResponse", "processRequest"], "request": ["project", "re", "forward", "each", "QUEST", "http", "setup", "document", "get", "reference", "quest", "address", "question", "message", "context", "report", "reset", "req", "call", "transform", "select", "application", "user", "create", "search", "input", "position", "seek", "query", "first", "frame", "xml", "initial", "view", "Request", "hello", "open", "command", "complete"], "response": ["re", "feed", "send", "http", "exit", "resp", "document", "fire", "onse", "block", "e", "release", "socket", "message", "context", "image", "writer", "connection", "report", "print", "reset", "content", "write", "out", "service", "respond", "application", "res", "console", "respons", "output", "page", "reply", "position", "render", "continue", "Response", "server", "next", "json", "relation", "frame", "xml", "header", "view", "channel", "format", "display", "status", "result"], "path": ["full", "api", "text", "ath", "dir", "length", "where", "pkg", "href", "url", "qualified", "host", "base", "prefix", "key", "raw", "parent", "binding", "error", "name", "right", "context", "p", "port", "physical", "primary", "log", "uri", "message", "patch", "print", "pointer", "route", "clean", "transform", "select", "method", "mount", "near", "test", "local", "ex", "location", "relative", "string", "pattern", "template", "partial", "alias", "input", "core", "kind", "root", "index", "json", "Path", "trace", "parts", "policy", "format", "type", "filename", "chain", "prop", "PATH"], "internal": ["ret", "api", "orig", "in", "binary", "central", "intern", "managed", "back", "url", "inline", "generic", "Internal", "valid", "common", "id", "name", "this", "context", "normal", "primary", " external", "invoke", "impl", "console", "rel", "standard", "uid", "local", "relative", "origin", "init", "bin", "inner", "alias", "template", "inter", "virtual", "original", "real", "regular", "index", "inside", "external", "initial", "identified", "san", "skin", "entry", "ident"], "resource": ["record", "process", "re", "binary", "object", "component", "url", "range", "resources", "reference", "stream", "region", "release", "store", "socket", "media", "address", "system", "connection", "buffer", "image", "context", "directory", "uri", "library", "print", "pointer", "service", "exclusive", "source", "res", "console", "controller", "local", "create", "core", "instance", "network", "Resource", "model", "file", "channel", "remote", "entry", "resolution", "handle", "result"], "mimeType": ["mIMEType", " mimeTypes", "maxStyle", " mimesStyle", " mimePolicy", "MetyType", "maxPolicy", "Mimetype", "mIMETypes", "metyName", "mimesType", "mtimeStyle", "misctype", "miscName", "metyTypes", "mtimeName", "meshName", "Metytype", "mimeTypes", "mIMEtype", "mimesTypes", " meshName", " mimesPolicy", "mimetype", "metyPolicy", "mtimeType", "metyType", "MimeTypes", "MimeType", " mimesTypes", " meshStyle", "maxTypes", " mimetype", "metyStyle", "maxType", " mimeName", "mimeStyle", "miscTypes", "meshType", "MetyTypes", " meshtype", " mimeStyle", "mIMEName", " meshType", "MimeName", "meshtype", "mimePolicy", "miscType", "mtimetype", "mimeName", "meshStyle", "mimesStyle", "mimesPolicy", "MetyName", "mIMEStyle", " mimesType", "metytype"], "is": ["sis", "isl", "in", "ls", "has", "ios", "isi", "its", "ism", "isc", "es", "mus", "iss", "cs", "ains", "ins", "s", "ic", "obs", "isf", "fs", "res", "iris", "nis", "rs", "isin", "si", "ics", "ri", "ris", "ys", "iso", "i", "as", "IS", "Is", "gets", "ais", "bis", "icks", "isa", "are"], "os": ["Os", "ms", "ox", "ros", "bs", "oses", "ot", "us", "o", "ls", "css", "ss", "ios", "aos", "osi", "oS", "es", "oes", "ts", "cs", "er", "s", "fs", "res", "los", "ols", "oos", "ds", "ks", "bos", "ys", " Os", "oss", "oz", "sys", "des", "as", "nos", "OS", "ps", "et", "obs"]}}
{"id1": "20181656", "id2": "21979714", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "label": 0, "substitutes": {"sortRows": ["sortRecues", "sortRecows", "sortDords", "sortLords", "sortDrows", "sortLues", " sortRues", " sortLues", " sortLords", "sortDows", "sortRecords", "sortRecrows", "sortRords", "sortRues", "sortRrows", " sortRords", " sortLows", " sortLrows", "sortLrows", " sortRrows", "sortDues", "sortLows"], "rows": ["packages", "users", "rices", "ids", "links", "keys", "types", "ris", "reports", "posts", "series", "ms", "cells", "row", "bs", "rooms", "raw", "runs", "relations", "values", "views", "workers", "checks", "ods", "headers", "rates", "abs", "ards", "images", "events", "pages", "docs", "roots", "orts", "history", "list", "ows", "items", "members", "fields", "res", "groups", "ports", "terms", "orders", "changes", "uds", "names", "rown", "tests", "models", "ges", "tracks", "cases", "ints", "arr", "modules", "frames", "ros", "forms", "vs", "resources", "ls", "results", "files", "issues", "errors", "ins", "outs", "ues", "heads", "blocks", "lines", "ries", "rules", "sheets", "rs", "dates", "xs", "months", "projects", "data", "stats", "maps"], "i": ["ji", "m", "ci", "u", "in", "ia", "phi", "gi", "ii", "us", "mi", "ti", "pi", "it", "e", "di", "ini", "ui", "zi", "hi", "id", "v", "p", "ic", "io", "ai", "out", "q", "ori", "g", "iu", "bi", "ip", "init", "si", "ie", "ri", "ki", "li", "ix", "xi", "is", "ar", "ei"], "j": ["ji", "ret", "m", "last", "u", "im", "z", "err", "other", "note", "b", "jo", "og", "my", "o", "it", "e", "di", "son", "adj", "kj", "y", "v", "obj", "s", "jit", "l", "kid", "k", "by", "req", "er", "J", "out", "q", "x", "jet", "ja", "js", "oj", "g", "je", "rel", "user", "uj", "state", "si", "jj", "ij", "jp", "dj", "jl", "br", "next", "json", "pr", "ix", "fr", "bot", "rem", "jac", "sim", "aj", "job", "uni", "jc", "bj", "jump"], "temp": ["porary", "tt", "tim", "perm", "mod", "tc", "null", "t", "orig", "mp", "alt", "variable", "fake", "base", " tmp", "EMP", "mem", "level", "cell", "buffer", "vt", "emp", "term", "kw", "clean", "pre", "test", "txt", "local", "dat", "template", "current", "tr", "tmp", "fac", "cum", "mint", "tem", "const", "Temp", "status", "result"]}}
{"id1": "160739", "id2": "6457199", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createOutputFile", "createInputSteam", " createFileStream", "createOutputSteam", " createOutputstream", " createOutSteam", " createOutStream", " createInputSteam", " createInputStream", " createOutputSteam", " createFileFile", " createInputFile", " createFileSteam", "createInputStream", "createInputFile", " createInputstream", "createInputstream", " createOutputFile", " createFilestream", "createOutputstream", " createOutFile", " createOutstream"], "inFile": [" infile", "dinFile", " inPort", "inputPath", "ninFile", "inputPort", "dinPath", "outFilename", "dinPort", "inPort", "ninfile", "ninFilename", "outfile", " inDir", "infile", "inPath", "inputFile", "dinDir", "outPath", "ninPath", "inDir", "inputDir", " inFilename", "inFilename", " inPath"], "outFile": ["toFilename", "Outfile", "toPort", "exFilename", "outFilename", "outPort", "exFile", "newFilename", "inPort", "OutFilename", "outfile", "infile", "outputFile", "newFile", "outputfile", "tofile", "toFile", "outputPlace", "OutFile", "exfile", "newPlace", "OutPort", "inFilename", "newfile", "outputFilename", "outPlace", "exPlace"], "k_blockSize": ["k_BlockTime", "k4BlockStyle", "k4blockName", "k2byteCount", "k4BlockSize", "k2byteSize", "k2blockSize", "k4blockStyle", "k_byteTime", "k_byteCount", "k_batchCount", "k_blockCount", "k_byteSize", "k4BlockCount", "k_BlockStyle", "k4BlockName", "k_batchSize", "k2byteLength", "k_batchTime", "k_blockName", "k2blockLength", "k4blockCount", "k_blockTime", "k_byteStyle", "k_batchLength", "k2blockCount", "k2byteTime", "k_blockLength", "k4blockSize", "k_byteLength", "k_blockStyle", "k_BlockSize", "k2blockTime", "k_BlockName", "k_BlockCount", "k_BlockLength", "k_byteName"], "byteCount": ["blockCounter", " byteCounter", "charCount", "wordN", "bitCheck", "bytecount", "byteN", "blockCount", " byteCheck", "bbCount", "bitLength", "bitCounter", " bytePtr", " bytecount", "bbCode", "bbSize", "wordCount", "lineLength", "linePtr", "linecount", "byteLength", "charcount", "blockCheck", "wordSize", "bbN", "wordCode", "charLength", "bytePtr", "byteCheck", "byteSize", " byteLength", "lineCount", "byteCode", "bitCode", "blockLength", "byteCounter", "charPtr", "bitSize", "bitCount", "bitN"], "buf": ["bg", "buff", "b", "bn", "cap", "pkg", "alph", "batch", "raw", "block", "mem", "Buffer", "vec", "buffer", "uf", "pb", "doc", "queue", "cur", "proc", "str", "Buff", "seq", "cmd", "bl", "txt", "cat", "ctr", "exp", "ctx", "bag", "rb", "img", "conv", "db", "cb", "cv", "bytes", "msg", "tx", "cast", "fg", "bc", "arr"], "ofp": ["ofd", "owlP", "OFP", "ofl", "OFp", " ofd", " ofP", "OFd", "ofP", "Ofl", "Ofd", " ofl", "owlp", "Ofp", "OfP", "owlpa", "Ofpa", " ofpa", "ofpa", "OFl", "owld"], "zos": ["zen", "os", "sis", "zin", "zh", "zip", "z", "hz", "bs", "zag", "eros", "ws", "cz", "css", "bes", "sch", "osi", "ossus", "tis", "python", "ps", "es", "settings", "socket", "zi", "zl", "zik", "ze", "zo", "zon", "amia", "enos", "zy", "std", "rose", "gs", "nz", "esa", "js", "zers", "los", "init", "ez", "rss", "zb", "sbm", "jp", "hess", "za", "jas", "zzle", "zes", "oss", "rez", "LOS", "zona", "south", "zer", "webkit", "cos", "zu", "psy"], "osw": ["ossW", "cosew", " osd", "sysrw", "aosw", "cosw", "aosrw", "aosws", "cosws", "isW", "owa", " osW", "ossw", "osrw", "osd", "aoswd", "ow", "oswd", "osW", "aosew", "sysw", "aoswa", "oW", "osws", "ospace", "osew", "osssw", " osew", "osswd", "aospace", "oswx", "osswx", "cosd", "ossrw", "issw", "syswd", "sysW", "osipace", " ossw", " oswx", " osws", "isw", "opace", "oswa", "osiW", "osiw", "iswx", "osiwa", "aosW", "aosd"], "bw": ["bwk", " bz", "pbwy", "bex", "wbx", "bbex", "obsw", "obw", "bbwp", " bex", "wbw", "obwb", "sbw", "bwb", "bwe", "bew", "bbws", "obwl", " bend", "pbew", "bbz", "bbend", "bx", "sbwt", "bewl", "wbend", "bsw", "bwy", "wbwt", "wbz", "bbem", "abwe", "nbwe", "abw", "pbwe", " bem", "pbw", "rbz", " bwp", " bsw", " bwl", "bbwt", "nbw", " bws", "pbwb", "pbz", "nbwy", "obwt", " bwt", "obwk", "sbz", "obz", "rbws", " bx", "bend", "bwt", "pbwt", "nbew", "bewk", "bbx", "bem", "abwy", "bws", "rbex", "sbwb", "wbem", "bwl", "bz", " bwk", "bbw", "rbw", "bwp", "abew", "wbwp", "besw"], "zot": ["zerot", "zerote", " zo", "Zote", " ziot", "zero", "ziat", "ziot", "zhot", " zote", "Zit", "zipiot", "zipot", "zoonet", " zhot", "zeriot", "zeriat", "zo", "zoo", "zote", "zoor", " zott", "zerit", "zeronet", "ziphot", " zonet", "zonet", "zipiat", "zott", "zor", " ziat", "zoot", "zerott", " zor", "zeror", "Zot", "Zott", "zerhot"], "ifp": [" ifr", " iftp", "iwr", "ihr", "iwp", " ifP", "isth", "IfP", "ifd", "ihd", " ifth", "iwtp", "isp", "isjp", "iwd", "ifth", "ihtp", "ifjp", "Ifp", "ihp", "iftp", " ifjp", " ifd", "ifP", "isP", "ifr", "Ifjp", "Ifth"], "zis": ["ezis", "zipIS", "ezi", "ziiss", " zisc", "zipic", "ziisa", "eziss", " zIS", "izinit", "izisa", "iziss", "zisa", "zi", "zoisa", "ziinit", "zipis", " zic", " zi", "zoiss", "izi", "zIS", "ziis", "zeris", "zoinit", "zerIS", "ziss", "ezisc", "zois", "zeric", "izisc", "zic", " ziss", "zisc", "zinit", "izis"], "isr": ["isalpr", "iossr", "issrs", "isscr", "itssr", "iscr", "sisrs", "isalstr", "sisrc", " isrs", "itsr", "issr", "ispr", "iosr", "iosstr", "issrc", "isrs", "iospr", "sisr", " isrc", "isrc", " iscr", "isalr", "isstr", "itsstr", "isalsr", "siscr", "itspr"], "br": ["bt", "bh", "shr", " Br", "lr", "Fr", "b", "bn", "obl", "Br", "bf", "gr", "bm", "ba", "yr", "bd", "r", "wr", "hr", "str", "js", "rel", "bl", "bi", "ctr", "cr", "dr", "rb", "bro", "tr", "BR", "bp", "sr", "pr", "ptr", "fr", "kr", "ber", "vr", "bj", "mr"], "zit": ["ezIT", "zipist", "izip", "lexIT", "zIT", "zip", "ozunit", "oziti", "zeip", "ziti", "ozip", "ezite", " zop", "zeit", "zeot", "zIt", "zipIt", "cziti", " zite", "zipite", "lexit", "izit", "zist", "zite", "ziIT", "czit", "lexIt", " zip", "zipit", "iziti", "ziIt", "ozit", "czot", "czunit", "izunit", "zipIT", "ziist", "zop", "ezlit", "ezit", "czip", "zeop", "zunit", "ziit", "ziplit", "czop", " zIT", " zlit", "lexist", "zlit"]}}
{"id1": "10218878", "id2": "17116123", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"DecodeMapFile": ["DecvertMapFile", "DecodeToLog", "DecodeTofile", "DecvertMapLog", "DecodeFromFiles", "DecvertMAPfile", "DecvertMAPFile", "DecodeFromFile", "DecodeToFiles", "DecvertMapFiles", "DecodeMapFiles", "DecodeFromfile", "DecodeToFile", "DecodeMapfile", "DecodeMAPFile", "DecodeMAPfile", "DecodeMAPLog", "DecvertMapfile", "DecodeMAPFiles", "DecodeMapLog", "DecvertMAPFiles", "DecodeFromLog", "DecvertMAPLog"], "mapFile": [" mapPath", "imagefile", "imageFilename", "imageStream", " mapFILE", "mapfile", "MapStream", "listFILE", "mapStream", " mapStream", "cacheFILE", "imageFile", "MapFilename", " mapfile", "mapPath", "listFile", "cacheFile", "cachePath", "Mapfile", "MapFile", " mapFilename", "mapFILE", "mapFilename", "listPath"], "outputFile": ["inputName", "writeName", "outputPath", " outputPath", "outFile", "writeStream", "outFilename", "mapStream", " outputFilename", "writeDir", "outputName", "outputDir", "OutputPath", "inputFile", "outPath", "OutputFile", " outputDir", "mapDir", "OutputFilename", "OutputDir", "writeFile", "outputStream", "mapName", "inputDir", "outputFilename", "outDir", "inputStream"], "magicKey": ["anticField", "MagicKey", "prefixKey", "magicCounter", " magicId", " magicName", "magicField", " magicChar", " magicCode", "prefixCounter", "prefixValue", " magicKEY", "serialKey", "magicId", "anticKey", "prefixCode", "MagicKEY", " magicValue", "antickey", " magicField", "uniqueKey", "magicChar", "encryptedkey", "magicName", "magicValue", "encryptedKey", "uniqueValue", "magicKEY", "uniqueCounter", "serialName", "encryptedChar", " magicCounter", "uniqueCode", "magickey", "MagicName", "anticChar", "encryptedField", " magickey", "MagicId", "serialId", "magicCode", "serialKEY"], "buffer": ["paste", "memory", "row", "detail", "phrase", "binary", "buff", "length", "table", "sample", "total", "variable", "document", "batch", "base", "stream", "pad", "block", "mem", "Buffer", "vector", "flash", "check", "history", "filter", "message", "black", "sequence", "bo", "print", "attribute", "cache", "queue", "window", "buf", "code", "iter", "stroke", "page", "template", "screen", "char", "bridge", "index", "database", "sum", "program", "frame", "header", "initial", "button", "display", "bone", "command", "stack", "shape", "append"], "nread": ["Nreadable", "maxRead", "ncreadable", "nREAD", "Nread", "NRead", "maxget", " ntry", "rawread", " nreadable", "renwrite", " nRead", "nRead", "renread", "rawtry", "nget", "maxread", "ncadd", "rnread", "rnREAD", "nwrite", "nreader", "rnRead", " nREAD", "ncwrite", "Nadd", "ntry", "rentry", " nwrite", "renreader", "rawreader", "rnwrite", "nreadable", "rawwrite", " nreader", "Nget", "ncRead", "ncget", "maxadd", "ncread", "nadd", "Nwrite", "NREAD"], "map": ["make", "ace", "memory", "m", "mod", "pl", "module", "parse", "per", "aps", "read", "table", "where", "open", "batch", "up", "block", "mem", "ml", "apping", "address", "image", "collect", "mate", "master", "mt", "op", "ape", "cache", "mask", "MAP", "window", "down", "mount", "set", "ip", "pack", "pose", "maps", "apper", "con", "app", "place", "meta", "bridge", "com", "man", "manager", "config", "cm", "form", "file", "view", "lock", "co", "clear", "mp", "ap", "load", "shape"], "output": ["exit", "other", "update", "object", "o", "open", "Output", "batch", "stream", "secure", "block", "four", "socket", "oe", "plain", "icon", "client", "port", "can", "log", "print", "hidden", "write", "put", "out", "cache", "blue", "queue", "console", "entity", "input", "current", "network", "outer", "target", "next", "ou", "web", "latest", "auto", "ilo", "file", "online", "response", "format", "display", "result", "net"], "i": ["ji", "m", "ms", "ci", "u", "t", "spin", "phi", "b", "ii", "j", "gi", "qi", "gu", "I", "span", "us", "mi", "ti", "batch", "pi", "it", "di", "ini", "ui", "ind", "id", "y", "v", "multi", "ic", "uri", "ai", "ish", "q", "x", "n", "g", "iu", "ni", "bi", "ip", "cli", "si", "ie", "ri", "index", "sim", "li", "ix", "xi", "ami", "is", "fi", "ei"]}}
{"id1": "12034046", "id2": "17729554", "code1": "    private InputStream openRemoteStream(String remoteURL, String pathSuffix) {\n        URL url;\n        InputStream in = null;\n        try {\n            url = new URL(remoteURL + pathSuffix);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            in = connection.getInputStream();\n        } catch (Exception e) {\n        }\n        return in;\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"openRemoteStream": ["closeRemoteFile", "closeRawSocket", "openRemoteSocket", "openLocalFile", "openLocalResource", "openExternalResource", "openRemoteResource", "openRawFile", "openRemoteFile", "closeRemoteSocket", "closeRemoteResource", "openLocalSocket", "closeRawFile", "openRawStream", "openExternalStream", "closeRemoteStream", "openExternalFile", "openExternalSocket", "openRawSocket", "openLocalStream", "closeRawStream", "closeRawResource", "openRawResource"], "remoteURL": ["sceneUrl", "serverURI", "fromurl", "remoteurl", "remoteUR", "fromUrl", "remoteID", "RemoteURL", "fromUR", "RemoteUrl", " remoteURI", " remoteID", "sceneUR", "remoteUrl", "RemoteURI", "RemoteUR", "sceneURL", "Remoteurl", "fromURL", "serverID", "serverUR", "sceneurl", " remoteUR", "remoteURI", "serverURL", "RemoteID"], "pathSuffix": ["pathSsuffixed", "pathSuffIX", "pathPsuffIX", "pathSeffixed", "pathPsuffux", "pathSufffix", "pathSffixed", "pathSPrefix", "pathPuffix", "pathSsuffix", "pathSeuffixed", "pathPufffix", "pathPsufffix", "pathSeufffix", "pathSPrefIX", "pathSeffix", "pathSuffux", "pathSumpfix", "pathSsuffIX", "pathSeffess", "pathSuffixed", "pathSefffix", "pathSumpess", "pathSPreffix", "pathSufux", "pathSumpix", "pathSuffess", "pathSeuffix", "pathPuffux", "pathSeuffess", "pathSufIX", "pathSsuffess", "pathSffess", "pathSumpixed", "pathSsuffux", "pathSffix", "pathSPrefux", "pathPuffIX", "pathSufix", "pathPsuffix", "pathSfffix", "pathSsufffix"], "url": ["pl", "bel", "ur", "lr", "http", "hl", "link", "run", "https", "h", "ls", "host", "base", "gl", "get", "raw", "ml", "build", "address", "name", "client", "resource", "uri", "l", "print", "sl", "r", "nl", "conn", "str", "rel", "mount", "hub", "www", "console", "cmd", "user", "ssl", "char", "Url", "web", "mail", "ul", "xml", "file", "ll", "self", "cert", "URL", "browser"], "in": ["gin", "m", "po", "nin", " din", "thin", "qi", "oin", "mc", "mi", "a", "In", "up", "stream", "cin", "it", "ini", "inn", "p", "ain", "ins", "login", "rin", "pin", "inc", "kin", "out", "ai", "conn", "source", "n", "ln", "IN", "from", "en", "isin", "bin", "inner", "con", "input", "din", "sum", "inv", "i", "ma", "qa", "as", "file", "is", "channel", "vin"], "connection": ["link", "c", "ion", "statement", "character", "cone", "condition", "version", "client", "Connection", "context", "resource", "directory", "l", "pointer", "service", "conn", "connected", "number", "still", "application", "controller", "associated", "con", "position", "network", "database", "session", "relation", "web", "communication", "city", "connect", "description", "channel", "response", "entry", "generation", "command", "result"]}}
{"id1": "7396682", "id2": "21348951", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"copy": ["pixel", "upload", "zip", "read", "link", "gc", "fit", "archive", "Copy", "repeat", "opy", "delete", "cp", "php", "cross", "map", "sync", "write", "Cop", "cat", "create", "replace", "crop", "move", "share", "core", "clip", "slice", "proxy", "split", "transfer", "clone", "py", "cop", "download", "load"], "srcFS": ["sourceFS", "srcOS", "rcFs", "sourceOS", "srcVS", "srcFs", "srcSF", "sysOS", " srcVS", "sysFs", "sysFS", "srcfs", "sourceCS", "rcFS", " srcFs", "srcCS", "sourceFs", "rcMS", "srFs", "rcfs", " srcfs", "sysVS", "sourcefs", "srcMS", " srcOS", " srcCS", " srcSF", "sourceVS", "sourceSF", "rcVS", "srfs", "srFS", " srcMS", "rcOS", "srMS", "rcCS", "rcSF"], "src": ["sit", "RC", "sc", "http", "SOURCE", "selected", "https", "rc", "cont", "syn", "pkg", "path", "url", "secure", "pri", "desc", "check", "ser", "sq", "nil", "resource", "obj", "spec", "uri", "req", "boot", "sync", "sub", "cur", "proc", "source", "str", "th", "node", "rel", "st", "from", "txt", "start", "sb", "rx", "sn", "ctr", "rs", "dest", "supp", "iv", "init", "sec", "input", "img", "usr", "sin", "sr", "tmp", "target", "comp", "via", "sys", "addr", "Source", "sci", "inst", "subject", "loc", "lb", "filename", "dir", "obs"], "dst": ["dslt", " dDest", "ldest", "lst", "deest", "Dest", "dddest", "dsdest", "dsst", "Dlt", "dDest", "dedest", "lgt", "dhdest", "ddnd", "ddlt", "dST", "dgt", "ddest", "Ddest", "degt", "deslt", "dnd", "dsST", "dhDest", "dsnd", "DST", " ddest", "desdest", "dsest", "desnd", " dest", "dsgt", "DDest", "dest", "lest", " dST", "dlt", "Dst", "desst", " dlt", "ddst", "dhst", "dhlt"], "deleteSource": [" deleteSources", "closeSource", "destroySource", "leteDest", "updateSOURCE", " deleteResult", "removeSource", "removeParent", "DeleteSourceFile", "closeSourceFile", "DeleteSOURCE", "updateSite", "leteResult", "delParent", "DeleteSource", "leteSource", "deleteSOURCE", "destroySources", "leteSOURCE", "deleteSite", "removeSOURCE", "removeDest", "delSource", "leteParent", "delSOURCE", "leteSources", " deleteTarget", "deleteTarget", "updateSource", "destroyResult", "deleteSources", "deleteDest", "DeleteSite", "deleteParent", "closeSite", "deleteSourceFile", "delDest", "destroyTarget", "updateSourceFile", "leteTarget", "closeSOURCE", "deleteResult"], "conf": ["info", "m", "cn", "params", "cms", "ch", "ref", "css", "acc", "check", "cc", "ban", "map", "report", "req", "f", "log", "cache", "conn", "q", "scan", "fs", "param", "ln", "cf", "mm", "plan", "ctx", "comm", "cfg", "def", "lib", "con", "irm", "conv", "com", "hash", "config", "cm", "cb", "pool", "comment", "co", "job", "ca", "Conf", "prop"], "contents": ["Contodes", "contants", " Contents", "CONTresses", " contterms", "constends", " contresses", "CONTENT", "CONTants", " Contresses", "Content", "CONTodes", "constENTS", " content", "contENTS", "CONTends", " ContENTS", " contants", "constaves", " contENTS", "CONTaves", "content", "contaves", "contterms", "CONTent", "ContENT", "CONTENTS", "Contents", " Content", " contENT", "Contterms", "CONTterms", " contends", "Contants", "contresses", "CONTents", "contodes", "contENT", " contodes", "constents", " contaves", "contends"], "i": ["ji", "m", "ms", "iq", "ci", "u", "im", "phi", "j", "ii", "gi", "qi", "my", "I", "us", "span", "o", "key", "mi", "ti", "oi", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "client", "y", "multi", "ic", "ai", "\u0438", "q", "x", "n", "ori", "me", "bi", "iter", "ip", "cli", "init", "inner", "si", "ie", "ij", "ki", "index", "sim", "li", "ix", "docker", "json", "ami", "xi", "is", "ims", "ei", "chain"], "in": ["sql", "re", "read", "sample", " din", "mc", "cin", "add", "raw", "ini", "inf", "check", "inn", "ind", "ze", "ins", "by", "r", "reader", "inc", "doc", "out", "source", "from", "IN", "en", "bin", "inner", "isin", "con", "input", "char", "din", "body", "xml", "is", "and", "In"]}}
{"id1": "11716816", "id2": "647224", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"updateFile": ["UpdateSourceFile", "updatePage", "UpdateContent", "downloadFile", "downloadContent", "updateContent", "downloadPage", "archiveContent", "UpdatePage", "archiveSourceFile", "updateSourceFile", "downloadSourceFile", "archiveFile", "archivePage", "UpdateFile"], "file": ["info", "full", "File", "t", "null", "ile", "FILE", "link", "table", "document", "fp", "rule", "path", "h", "url", "get", "base", "line", "e", "use", "name", "message", "issue", "image", "resource", "port", "p", "log", "report", "f", "io", "content", "source", "output", "local", "page", "title", "input", "le", "db", "data", "channel", "format", "entry", "type", "filename", "handle", "attribute"], "IOException": ["IOProblem", "OperationError", " IOError", " IOProblem", "OperationException", "SecurityException", "IOError", "OperationProblem", "SecurityError", "SecurityProblem"], "destFile": ["targetPath", "targetDir", "sourceFolder", "optFolder", "Destfile", "optPlace", "destPage", "sourceFile", "destDir", "DestFile", "declSourceFile", "destfile", " destinationDir", "destEmail", "tempPath", "sourceDir", " destEmail", "optFile", "optPage", "targetFolder", "tempDir", "declile", " DestFile", " destPage", "destile", "DestPath", " destPath", " destinationEmail", "Destile", " destinationFile", "tempfile", " destDir", "tempFile", " destfile", " destFolder", " destDo", "DestPage", " DestDo", "sourcePath", "destFolder", " destPlace", "declFile", "DestFolder", " DestDir", " destSourceFile", "destPath", "DestPlace", "destSourceFile", " DestEmail", "DestDir", "destPlace", "targetFile", "declFolder", "DestSourceFile", " destinationDo", " destile", "destDo"], "in": ["gin", "pass", "info", "m", "re", "im", "read", " IN", "local", " din", "oin", "mi", "up", "cin", "it", "on", "raw", "ini", "inf", "inn", "ind", "ain", "ins", "s", "ic", "rin", "f", "io", "r", "l", "ai", "inc", "al", "n", "ln", "IN", "mm", "from", "iter", "init", "act", "en", "bin", "isin", "inner", "ie", "all", "con", "input", "edIn", "sin", "din", "i", "inside", "is", "ne", "In", "net"], "out": ["cn", "os", "null", "t", "note", "fn", "b", "gt", "ion", "ot", "ch", "o", "up", "aos", "it", "or", "oe", "client", "v", "obj", "s", "to", "outs", "can", "log", "io", "flush", "write", "conn", "cache", "one", "n", "g", "no", "cmd", "output", "ex", " OUT", "Out", "en", "con", "jp", "again", "nt", "conv", "outer", "ou", "oss", "at", "sys", "OU", "msg", "OUT", "co", "channel", "chain", "ne", "cos", "result", "net"]}}
{"id1": "13563706", "id2": "23666867", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", " doPut", "doGET", "Doget", "DoGet", "handleget", " doget", "doget", " doGET", "DoGET", "handlePut", "DoPut", "doPut", "handleGET"], "request": ["project", "re", "each", "QUEST", "forward", "http", "setup", "document", "path", "url", "get", "reference", "version", "parent", "socket", "use", "address", "message", "connection", "context", "resource", "directory", "report", "reset", "call", "event", "route", "transform", "application", "order", "user", "create", "search", "input", "current", "position", "query", "first", "frame", "xml", "initial", "subject", "Request", "hello", "view", "command", "complete", "attribute"], "response": ["answer", "http", "exit", "resp", "document", "fire", "zero", "security", "default", "success", "condition", "version", "block", "ce", "message", "connection", "image", "sequence", "summary", "report", "print", "ve", "write", "service", "respond", "example", "application", "res", "console", "see", "output", "search", "reply", "tree", "position", "server", "network", "Response", "render", "foundation", "continue", "next", "json", "relation", "hash", "frame", "description", "header", "view", "format", "display", "status", "result", "collection"], "selectedPage": ["electedPage", "specifiedPort", " selectedpage", "electedPort", " selectedPort", "matchedFrame", "lectedKey", "selectedpage", "electedFrame", "electionFrame", "namedPort", " selectedRow", "electionPage", " selectedPath", "namedToken", "selectionItem", "lectedFile", "lectedPort", "lectedLine", "namedLine", "specifiedDocument", "matchedPage", "selectionFile", "matchedPort", "verifiedFile", "lectedDocument", "selectFile", "selectedDocument", "singlePort", "namedpage", "selectPath", "selectItem", " selectedKey", "electedpage", "singlepage", "selectedFrame", "namedPage", "selectPort", "selectedLine", "lectedItem", "lectedPath", "namedKey", "selectionToken", "selectPage", "singlePage", "selectedPort", "lectedFrame", "lectedRow", "verifiedRow", "selectLine", " selectedFile", "selectedRow", "electionPort", "lectedPage", " selectedLine", "lectedToken", "singleFrame", "namedFrame", "matchedpage", "selectedFile", "verifiedpage", "verifiedPage", "selectedPath", "electionDocument", "lectedpage", "selectionLine", "specifiedFrame", "selectionPort", "selectedItem", "selectionPage", "specifiedPage", " selectedFrame", "selectedKey", "selectedToken"], "page": ["version", "block", "filter", "address", "port", "menu", "log", "number", "node", "me", "user", "profile", "proxy", "channel", "self", "display", "project", "row", "table", "pp", "line", "client", "to", "layout", "site", "age", "pool", "form", "view", "phone", "result", "record", "successful", "office", "document", "pages", "peer", "pointer", "Page", "application", "position", "server", "current", "next", "force", "collection", "phrase", "rule", "object", "url", "be", "parent", "message", "p", "image", "resource", "group", "cache", "created", "window", "output", " Page", "associated", "language", "instance", "network", "point", "frame", "policy", "chain", "complete"], "portalRequest": ["portalerequest", " portalApply", "portualEvent", "portalingCall", "portpalResponse", "portralResponse", "PortaleRequest", "portalidResponse", "portsortalEvent", "portaleAccess", "portualResponse", "portalityContext", "PortaleQuery", "portalApply", "terminalidRequest", "portalThread", "portalityFrame", " portaleApply", "portalaAccess", "PortalThread", "terminalQuery", "portalSession", "portsalRequest", "terminalidSession", "portalAccess", "portaleContext", "portsalResponse", "portalidSession", "portralQuery", "portortalRequest", "PortalFrame", "portaleRequest", "portalityResponse", "portaleApply", "PortalQuery", "PortaleThread", "portortalQuery", "portalFrame", "portpalThread", "portsalrequest", "portalrequest", "portalaRequest", "portortalrequest", " portaleRequest", "portalCall", "portalContext", "portalingApply", "portaleResponse", "portralContext", "portalingAccess", "portalidFrame", "PortaleContext", "portaleFrame", "PortalRequest", "portalityRequest", "portalingRequest", "portsortalrequest", "PortaleResponse", "portaleSession", "portpalContext", "portalQuery", "portortalContext", "portualrequest", "terminalidQuery", "portsalEvent", "portralRequest", "portalaCall", "PortaleFrame", "portaleEvent", "terminalSession", "portalaApply", "portalEvent", "portaleCall", "portualRequest", "portortalResponse", " portaleCall", "portalidQuery", "portralSession", " portalAccess", " portalCall", "portortalEvent", "portpalRequest", "portortalThread", "portsortalResponse", "portaleQuery", "PortalResponse", "terminalRequest", "portalResponse", "terminalidResponse", "portsortalRequest", "portalidRequest", " portaleAccess", "portalidContext", "portaleThread", "PortalContext", "terminalResponse"], "pageProp": ["pageDef", "poolZip", " pagePack", "imageProp", "sectionPro", "propertyPack", "pagePr", "officePack", "pageProperty", "phraseProperty", "ageProp", "officePriv", "poolPro", " pagePr", "pagePack", "sectionProp", "sectionPred", "profilePred", "profilePro", "pageComp", "imagePred", "profileZip", " pagePro", " pagePriv", "officeDef", "propertyProp", " pageDef", " pageProperty", "officeProp", "imagePr", "propertyDef", "agePro", "phraseProp", "phrasePr", "pageZip", "imagePro", "pagePriv", "profileProp", "sectionZip", "phraseComp", "pagePro", "pagePred", "keyComp", "agePr", " pagePred", "keyProperty", " pageComp", "agePred", "propertyPriv", "keyPr", "poolProp", "keyProp", "poolPred"], "possiblePage": ["PossiblyUser", "pspecifiedpage", "pibleUser", " packedCollection", "PossiblePage", "pentialPages", "pspecifiedPage", "pbablePage", "possibleLine", " possibleTag", "pableLine", "possiblyChild", "pibleCollection", "PossiblePages", "possiblePages", "pableTag", "possibleChild", "PossibleTag", "pableCollection", "possibleUser", "PossiblyCollection", "possiblyUser", "pbableUser", "pspecifiedPages", " possibleLine", "possibleCollection", "packedCollection", "pentialpage", "possiblepage", "packedLine", "pbableChild", "pibleChild", "pspecifiedTag", "PossiblyPage", "PossiblyChild", " packedLine", "packedPage", "PossibleUser", "pentialPage", "pbableCollection", "possiblyPage", " packedPage", "piblePage", "possiblyLine", "pentialTag", "packedTag", " packedTag", "PossibleChild", "possiblyCollection", "possiblyTag", "Possiblepage", "possibleTag", " possibleCollection", "pablePage", "PossibleCollection"], "property": ["domain", "rue", "phrase", "expression", "variable", "rule", "object", "key", "definition", "integer", "value", "address", "name", "message", "p", "resource", "owner", "feature", "service", "function", "location", "metadata", "title", "string", "operator", "class", "position", "properties", "second", "Property", "relation", "config", "trace", "frame", "description", "header", "behavior", "policy", "command", "field", "type", "prop", "attribute"], "referer": ["vererer", "relerential", "retered", "reere", "differing", "frer", "reportrer", "Refere", "defered", "relering", "Refrer", "redrer", "verrier", "reterer", "diffonder", "refering", "printrer", "rerer", "rederee", "afener", " refrer", "rederer", "refarer", "redere", "refirect", "rangeener", "fener", "refered", "relender", "rorered", "defirect", "defrer", "aferential", "referee", "reportarer", "rorirect", "reerential", "rearer", "retrer", "refere", "verrer", "relerer", "vererential", "printerer", "refrier", "reerer", "retarer", "refrer", "refonder", "requerer", "aferer", "rerier", "relener", "Referer", "reonder", "reporterer", "rorrer", "requonder", "fering", "deferer", "referential", "rangerer", "printrier", "reender", "relrer", "printerential", "rangeerer", "refener", "reeree", " refered", " refirect", "Referee", "requrer", "rangeender", "reener", "reered", "differer", "ferer", "requering", "afrer", "reering", "diffrer", "refender", "rorerer", "reportered"], "e": ["m", "echo", "t", "err", "ee", "eur", "ge", "o", "h", "a", "se", "es", "oe", "error", "p", "er", "ae", "f", "r", "x", "E", "n", "g", "me", "de", "eeee", "ie", "te", "eg", "eu", "ception", "event"]}}
{"id1": "12306305", "id2": "5414088", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doCopyFile": [" doCopfile", "doCopFiles", " doCopFile", "doMovefile", " doCopyFiles", "doCopyByte", "doMoveFile", "docopyFile", "doMoveByte", "doCopyFiles", "doCopfile", "docopyfile", " doCopByte", "doCopyfile", " doCopFiles", "doCopByte", "doMoveFiles", " doCopyByte", " doCopyfile", "docopyByte", "doCopFile", "docopyFiles"], "srcFile": ["srcFilename", " srcPath", "srcFILE", "rcile", "destPage", "sourceFile", "rbFilename", "rcFile", "destFilename", "destfile", "locPage", " srcFilename", "rcDir", "sourceDir", " srcDir", "locModel", "locFile", "selFile", "destModel", "selfile", "srcPath", "destile", "srcLine", "rcFilename", " srcFILE", " srcModel", "rbPath", "destLine", "srcModel", "rcfile", "rbFile", "rcLine", "sourceLine", "sourcefile", "selPage", "rcPath", "srcPage", "rcFILE", "srcfile", "selFilename", " srcPage", "srcDir", " srcLine", " srcfile", " srcile", "locFilename", "rcPage", "rbFILE", "srcile"], "destFile": ["memFiles", "memfile", "distDir", "Destfile", "srcFilename", "srcFILE", "destPage", "destDir", "DestFile", "origFile", "destfile", "litfile", "DestFILE", " destDirectory", "destFilename", "critGrid", "destMail", "foreignFILE", "critfile", "memFILE", "litMail", "distFilename", " destPage", "foreignFile", "DestFilename", "destOnly", "DestFiles", "descGrid", "declFILE", "DestMail", "origOnly", " destDir", "DestGrid", "critDir", " destfile", "DestDirectory", "declfile", "distfile", "destFILE", "foreignOnly", "destDirectory", "srcDirectory", "DestPage", "origDir", "srcPage", "declFile", " destFilename", "descDir", " destFILE", "memFile", "destGrid", " destGrid", "srcfile", "srcFiles", "critFile", "srcGrid", "litFILE", "origFILE", "descPage", "destFiles", "srcDir", "DestDir", "distFile", "srcOnly", " destFiles", "foreignDir", "declMail", "descFile", "litFile"], "preserveFileDate": ["preserveFileDuration", "preserveLineDate", "preservefileTime", "preserveFilenameTime", "preservesfileDuration", "preserveLotDay", "presoreFileDate", "preserveFilenameDay", "preservefileDay", "preserveLineSize", "presoreLotdate", "preservesFileTime", "preserveFilesdate", "presoreFiledate", "preservesFileDate", "presoreLotDay", "preserveFileDay", "preserveFilenameDate", "preserveLotSize", "preserveLinedate", "preserveFilesSize", "preserveLotDate", "presoreFileSize", "preservesfileTime", "preservefileDate", "presoreFileDay", "preservesfileDate", "preserveFilenameDuration", "preserveSetDuration", "preserveSetTime", "preservesFileDuration", "preserveLotdate", "presoreLotSize", "preserveFilesDay", "preserveSetDate", "preserveFileTime", "preserveFileSize", "preserveFilesDate", "preservesfileDay", "presoreLotDate", "preserveFiledate", "preserveSetDay", "preservesFileDay", "preservefileDuration", "preserveLineDay"], "input": ["info", "before", "feed", "upload", "http", "in", "read", "exec", "parse", "audio", "archive", "get", "up", "stream", "alpha", "add", "raw", "it", "history", "internal", "client", "buffer", "image", "context", " Input", "focus", "io", "reader", "op", "hidden", "request", "Input", "source", "q", "local", "ip", "from", "init", "start", "iter", "inner", "pattern", "partial", "current", "installed", "index", "json", "xml", "auto", "initial", "entry", "open", "command", "accept"], "output": ["module", "exit", "o", "open", "Output", "stream", "success", "block", "four", "icon", "client", "connection", "buffer", "image", "generated", "port", "message", "writer", "group", "print", "hidden", "write", "put", "out", "console", "page", "section", "network", "outer", "body", "next", "ou", "web", "cut", "latest", "auto", "file", "ilo", "data", "response", "channel", "format", "remote", "display", "text", "result", "net"]}}
{"id1": "8000624", "id2": "22410173", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " copyInt", " copiesTo", " copiesInt", " copiesFrom", " CopyFrom", "CopyInt", " CopyInt", " copyTo", "CopyFrom"], "dest": ["src", "null", "orig", "w", "fn", "Dest", "opt", "cont", "path", "it", "mem", "sp", "name", "p", "v", "image", "rest", "temp", "source", "th", "st", "output", "txt", "cat", "origin", "copy", "img", "them", "usr", "tmp", "target", "pipe", "nom", "loc", "est", "filename", "result", "dir", "d"], "in": ["gin", "m", "re", "t", "per", "read", "nin", " din", "thin", "o", "mi", "up", "cin", "it", "on", "ini", "inf", "inn", "ind", "internal", "client", "image", "ain", "min", "ins", "login", "l", "rin", "by", "reader", "r", "inc", "ai", "al", "source", "one", "ire", " input", "IN", "from", "iter", "local", "init", "win", "en", "isin", "bin", "inner", "con", "input", "sin", "din", "i", "inside", "file", "is", "ac", "ar", "ir", "In", "net"], "out": ["full", "os", "cn", "null", "t", "w", "other", "note", "b", "fn", "gt", "end", "ot", "o", "batch", "up", "aos", "na", "it", "e", "oe", "ns", "list", "client", "v", "writer", "can", "obj", "to", "outs", "flush", "boot", "io", "by", "op", "loss", "write", "not", "one", "dis", "n", "res", "ln", "user", "output", "ex", "Out", "en", "inner", "all", "con", "nt", "outer", "conv", "ou", "oss", "at", "OUT", "co", "ne", "cos", "net"], "c": ["nc", "u", "sc", "t", "z", "gc", "ec", "cap", "cont", "rc", "ch", "C", "character", "lc", "e", "count", "ct", "cc", "cp", "ce", "cs", "v", "cd", "l", "f", "k", "uc", "cl", "n", "g", "code", "unc", "cf", "cat", "cr", "arc", "conf", "con", "current", "char", "i", "cm", "cut", "cb", "ca", "cod", "bc", "ac", "d"]}}
{"id1": "13657527", "id2": "19549577", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 1, "substitutes": {"getDatasetsList": ["getDatisetsResult", "getDatisetStatus", "getDatasetStatus", "getDatasesStatus", "getDatasetsResult", "getDatisetsList", "getDatasesList", "getDatisetList", "getDatasuresResult", "getDatisetsStatus", "getDatasuresStatus", "getDatasetResult", "getDatasetList", "getDatasetsStatus", "getDatasesResult", "getDatasuresList", "getDatisetResult"], "surl": ["lsurl", "lsuri", "slim", "sURL", "jsUrl", "esUrl", "stsurl", "sUrl", "sysserver", "lsUrl", "lsmail", "esurl", "suri", "ssuri", "slt", "esURL", "lslt", "jslim", "esuri", "sserver", " suri", "jsuri", " sUrl", " sname", "jsurl", "sslim", "sysuri", "sysurl", "ssURL", "syslt", "ssUrl", "ssurl", "esname", "lsserver", "stsuri", "sname", "smail", " smail", "stsserver", "stslt"], "datasetsList": ["datassetslist", "datasamesSet", "datasagesSet", "datmassetsList", "datasureslist", "datasuresMap", "datasetSet", "datasagesData", "datasetslist", "datisetsGroup", "datisetsMap", "datasETSList", "datassetsLock", "datasenslist", "datassetsMap", "datasameslist", "datisetName", "datasamesMap", "datasourcesTable", "datasagesTable", "datmasetsLock", "datassetsTable", "datisetsList", "datasETSGroup", "datisetsName", "datasetsMap", "datmasetsMap", "datarsetsMap", "datarsetlist", "datarsetsList", "datmasetsData", "datarssetsList", "datarsetsLock", "datarssetsSet", "datarsetsSet", "datasetMap", "datarssetsLock", "dataselinesGroup", "datarssetsTable", "datasourcesList", "dataselinesList", "datasensMap", "datasagesMap", "datasetsSet", "datmassetsLock", "datasamesList", "datmassetsData", "datasetsName", "dataselinesMap", "datasetlist", "datasETSMap", "datasetGroup", "datasourcesSet", "datasagesList", "datarsetsTable", "datasuresList", "datmasetsList", "datasetsLock", "datmassetsMap", "datisetList", "datarsetList", "dataselinesName", "datasetsData", "datassetsList", "datisetMap", "datasETSName", "datarsetslist", "datasetsGroup", "datasourcesLock", "datasetName", "datasuresSet", "datisetGroup", "datasagesLock", "datasetData", "datarsetMap", "datasetsTable", "datassetsSet", "datasetLock", "datarsetSet", "datassetsData", "datasensList", "datasetList"], "result": ["record", "ret", "answer", "details", "successful", "detail", "table", "diff", "default", "success", "results", "found", "valid", "there", "message", "buffer", "sequence", "menu", "report", "folder", "cert", "res", "test", "set", "complete", "search", "def", "relation", "first", "exist", "Result", "comment", "form", "description", "chain", "response", "contact", "successfully", "status"], "reader": ["row", "older", "per", "read", "handler", "rar", "ner", "upper", "range", "driver", "stream", "mr", "timer", "rd", "roller", "ser", "rer", "socket", "peer", "iterator", "READ", "client", "buffer", "writer", "resource", "er", "runner", "bo", "wrapper", "r", "redo", "rl", "test", "ro", "iter", "Reader", "dr", "inner", "operator", "body", "river", "query", "via", "reading", "file", "layer", "parser", "field", "loader", "author", "handle", "liner", "rr"], "url": ["lr", "ur", "row", "null", "http", "link", "il", "ls", "key", "stream", "address", "id", "client", "resource", "l", "uri", "sl", "r", "nl", "rl", "str", "org", "mount", "user", "location", "ssl", "char", "Url", "web", "mail", "ul", "file", "dl", "ll", "loader", "URL", "browser"], "s": ["full", "ms", "os", "less", "sql", "t", "sample", "b", "bs", "us", "h", "ws", "ls", "ss", "has", "tes", "its", "es", "sq", "ns", "sym", "ts", "y", "series", "cs", "v", "ins", "l", "r", "sw", "gs", "str", "source", "js", "n", "sv", "ids", "ats", "S", "still", "rs", "csv", "sb", "sts", "string", "ds", "hs", "i", "abs", "as", "gets", "strings", "is", "qs", "ps"], "list": ["pretty", "join", "full", "detail", "note", "table", "cont", "ls", "batch", "top", "add", "block", "part", "ml", "php", "sequence", "group", "log", "l", "print", "layout", "member", "test", "left", "ist", "local", "set", "st", "single", "L", "all", "def", "word", "li", "pool", "form", "LIST", "array", "ll", "dl", "format", "listed", "chain", "stack", "lists", "collection"]}}
{"id1": "15241397", "id2": "18696387", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", " doPut", "doGET", "Doget", "DoGet", "handleget", " doget", "doget", " doGET", "DoGET", "handlePut", "DoPut", "doPut", "handleGET"], "request": ["re", "each", "QUEST", "forward", "http", "in", "setup", "document", "get", "reference", "quest", "address", "client", "question", "message", "the", "context", "connection", "reset", "report", "req", "transform", "application", "user", "create", "start", "input", "position", "server", "current", "query", "first", "frame", "initial", "Request", "hello", "command", "complete", "attribute"], "response": ["answer", "send", "http", "exit", "resp", "document", "fire", "object", "onse", "success", "version", "block", "ce", "connection", "message", "image", "context", "resource", "sequence", "report", "print", "reset", "ve", "content", "write", "service", "respond", "application", "res", "console", "site", "output", "page", "reply", "position", "server", "network", "Response", "body", "next", "json", "session", "frame", "description", "xml", "view", "form", "status", "result"], "rewrittenQueryString": ["rewrittenQueryStr", "rewwrittenqueryQuery", "rewrittenURLStr", "rewrittenqueryString", "rewwrittenQueryStr", "rewrittenQuStr", "rewrittenQueryQuery", "rewrittenQuString", "rewrittenqueryQuery", "rewliedqueryStr", "rewartedQueryStr", "rewrittenCurrentQuery", "rewliedqueryString", "rewartedQueryString", "rewwrittenQuerystring", "rewwrittenqueryStr", "rewrittenQustring", "rewartedQuerystring", "rewrittenqueryStr", "rewliedQueryStream", "rewrittenQueryStream", "rewrittenRequeststring", "rewrittenQuerystring", "rewrittenHeaderStream", "rewrittenquerystring", "rewrittenRequestString", "rewwrittenquerystring", "rewrittenRequestQuery", "rewrittenURLstring", "rewrittenHeaderStr", "rewartedHeaderString", "rewrittenCurrentstring", "rewartedHeaderStream", "rewartedHeaderStr", "rewwrittenQueryString", "rewrittenURLString", "rewwrittenQueryQuery", "rewartedHeaderstring", "rewrittenQuestionStream", "rewrittenCurrentString", "rewrittenHeaderstring", "rewliedQueryString", "rewrittenQuestionStr", "rewwrittenqueryString", "rewrittenQuStream", "rewrittenRequestStr", "rewrittenQuestionString", "rewliedQueryStr", "rewliedqueryStream", "rewrittenHeaderString", "rewartedQueryStream", "rewrittenCurrentStr", "rewrittenURLStream", "rewrittenqueryStream"], "rewrittenUrl": ["rewriteUrl", "RewwrittenString", "rewittenurl", "rewrittenurl", "rewwrittenLink", "RewrittenUr", "RewwrittenUr", "rewriterUr", "RewwrittenURL", "rewwrittenURL", "rewriddenURL", "rewrotePosition", "rewroteUrl", "rewroteURL", "rewriteURL", "Rewrittenurl", "rewrownUr", "rewrittenString", "rewrittenLink", "RewrittenLink", "rewadjustedPort", "RewrittenPosition", "rewrittenPosition", "rewroteUr", "rewartedPosition", "Rewwrittenurl", "RewwrittenLink", "rewittenUrl", "rewadjustedUrl", "RewrittenUrl", "rewwrittenString", "rewedURL", "rewrownURL", "RewrittenString", "rewartedUr", "rewriddenUrl", "rewrownUrl", "RewwrittenPort", "rewriddenPosition", "rewartedUrl", "RewrittenURL", "rewrapedURL", "RewrittenPort", "rewwrittenPosition", "rewroteLink", "rewartedURL", "rewriteUr", "rewrittenPort", "rewrownPosition", "rewriterString", "rewartedurl", "rewadjustedUr", "rewedUrl", "rewriterUrl", "rewittenURL", "rewriterURL", "rewwrittenPort", "rewrapedUr", "RewwrittenPosition", "RewwrittenUrl", "rewwrittenUr", "rewedString", "rewittenLink", "rewrittenURL", "rewriddenUr", "rewwrittenUrl", "rewedUr", "rewriteurl", "rewroteurl", "rewadjustedURL", "rewrittenUr", "rewwrittenurl", "rewrapedPort", "rewrapedUrl"], "httpURLConnection": ["httpRLConnect", " httpUrlconnection", "httpHTTPApplication", "HttpUrlConnect", "ttpUrlApplication", "httpFileConn", "ttpURLControl", "httpSRconnection", "httpRLconnection", "httpUrlConnection", " httpURLConnect", "ttpURLConnection", "httpUrlConnect", "httpUrlConfiguration", "httpRLApplication", "httpMLConnection", "HttpHTTPConnect", "httpUrlControl", "httpURLConn", "httpHTTPConn", "HttpUrlconnection", "HttpURLApplication", "ttpURLApplication", "ttpUrlControl", "httpURLConnect", "HttpURLConfiguration", "ttpUrlConnect", "httpHTTPConnection", "HttpURLConnection", "ttpURLconnection", "ttpUrlConn", "httpHTTPconnection", "httpUrlConn", "httpMLConnect", " httpUrlApplication", "httpRLConnection", "HttpHTTPConnection", " httpURLconnection", "httpURLControl", "HttpURLConnect", "httpSRApplication", "HttpURLconnection", "HttpUrlConnection", "httpURLConfiguration", "ttpURLConn", "httpHTTPControl", "ttpUrlconnection", "httpFileConnect", "httpSRConfiguration", " httpURLApplication", "httpURLconnection", "httpSRControl", "HttpHTTPApplication", "httpURLApplication", " httpUrlConnection", "httpSRConnect", "httpHTTPConnect", "httpMLApplication", "ttpUrlConnection", "HttpHTTPConfiguration", "ttpURLConnect", "HttpHTTPconnection", " httpUrlConnect", "httpFileApplication", "httpHTTPConfiguration", "httpUrlApplication", "httpSRConnection", "httpMLconnection", "httpFileConnection", "httpUrlconnection"], "header": ["info", "detail", "column", "shift", "heading", "handler", "variable", "rule", "component", "option", "h", "holder", "line", "prefix", "version", "block", "part", "check", "device", "peer", "filter", "address", "client", "buffer", "port", "er", "wrapper", "feature", "hidden", "padding", "term", "argument", "user", "Header", "headers", "init", "metadata", "dr", "page", "title", "state", "token", "operator", "section", "core", "head", "meta", "zone", "query", "relation", "tag", "hash", "ter", "comment", "layer", "field", "format", "policy", "handle", "status", "event", "attribute"], "value": ["record", "email", "sample", "expression", "val", "property", "default", "VALUE", "pair", "version", "python", "address", "name", "message", "values", "v", "sequence", "unit", "password", "element", "content", "example", "sv", "test", "see", "create", "language", "string", "save", "instance", "server", "current", "Value", "zone", "json", "hash", "des", "description", "comment", "data", "ue", "hello", "entry", "field", "key", "label", "text", "attribute", "job", "format", "vector"], "inputStream": ["outputLoop", " inputView", "InputLoop", "InputThread", "errorSteam", "errorWindow", " inputstream", "outputSteam", "inputThread", " inputWindow", " inputLoop", "inputLoop", "outputstream", "InputView", "inputSteam", "outputWindow", "errorstream", "inputView", " inputSteam", " inputThread", "inputstream", "outputView", "errorStream", "InputStream", "inputWindow", "outputThread"], "outputStream": ["responseForm", "outputForm", " outputForm", " outputstream", "OutputLength", "outputLength", "outputSteam", "displayStream", "OutputStream", "responseStream", "displaySteam", "outputstream", "inputSteam", "OutputForm", "responseSteam", "inputView", "responseLength", "displaystream", " outputView", "inputstream", "OutputSteam", "outputView", " outputLength", " outputSteam", "displayView"]}}
{"id1": "18793482", "id2": "12782570", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyapplicationData", "modifyServerMessage", "modifyapplicationmessage", "modifyApplicationData", "modureAppMessage", "modifyAppMessage", "modifyServerMsg", "modureAppMsg", "modifyAppData", "modureAppmessage", "modureApplicationMsg", "modureAppData", "modifyapplicationMsg", "modureApplicationmessage", "modureApplicationData", "modifyServermessage", "modifyAppmessage", "modureApplicationMessage", "modifyapplicationMessage", "modifyAppMsg", "modifyApplicationmessage", "modifyApplicationMsg", "modifyServerData"], "locale": [" localey", "localey", " locales", "localALE", "regALE", "locales", " locALE", " locational", "localale", "Localey", "localales", "locational", "localational", "regale", "Locales", "regational", "locALE", "regales", "LocALE", "Locational", "localaley", "Locale"], "messageName": [" messageNAME", "MessageNAME", "messageKey", "messageNames", "messageNAME", "messageType", " messageNames", "MessageType", "msgType", "msgKey", " messageType", "MessageKey", "mediaName", "msgName", "MessageValue", "mediaKey", "msgValue", "mediaNames", "mediaNAME", "MessageNames", "MessageName", " messageKey"], "messageValue": ["messageVALUE", "messageVal", "messageType", "MessageType", "essageVal", " messageType", "MessageVALUE", "msgvalue", "essageValue", "essageType", "languageName", "languagevalue", "messagevalue", "MessageVal", "MessageValue", "msgName", "Messagevalue", " messageVal", "msgValue", "msgVALUE", "languageVALUE", "languageValue", "MessageName", "essageName"], "properties": ["project", "details", "params", "pid", "property", "prop", "results", "files", "settings", "message", "report", " props", "pro", "utils", "profile", "metadata", "types", "pdf", "json", "parts", "config", "perties", " Properties", "data", "policy", "options", "ps"], "i18nPath": ["i18nyPath", "i18rDriver", "i18nIf", "i18nUrl", "i18anP", "i8nDir", "i18neDriver", "i18nDriver", "i18nyDriver", "i18lUrl", "i18anDir", "i18nPoints", "i18bDir", "i8lUrl", "i18bUrl", "i18natDriver", "i18nDir", "i18rDir", "i18lStr", "i18natPath", "i18anPath", "i18nP", "i18bPath", "i18nePoints", "i18lDir", "i8nUrl", "i18neStr", "i18lPath", "i18anIf", "i18natP", "i18nStr", "i8lDir", "i18nyDir", "i18rPath", "i18neUrl", "i18natPoints", "i8nPath", "i18anDriver", "i18anPoints", "i18neDir", "i18nyIf", "i18neP", "i8nStr", "i18rIf", "i8lStr", "i8lPath", "i18bStr", "i18nePath"], "englishFile": ["englishDirectory", "electricFile", " englishDirectory", "ianaFile", "languageFile", "englishDir", "ianaDirectory", "enFilename", "wikifile", "enfile", "EnglishFilename", "ianaPath", "electricPort", " englishfile", "ianaPort", "englishTable", "englishPort", "electricDirectory", "ianaDir", "electricDir", "englishFilename", "wikiFile", " englishTable", "Englishfile", " englishPort", " englishDir", "englishPath", "EnglishFile", "ianaTable", "enFile", "ianafile", " englishPath", "languageFilename", "englishFiles", "languagefile", "englishfile", "EnglishFiles", "wikiPath", "languageFiles", "wikiTable", "enFiles"], "propertiesFilePath": ["settingsFilenamePath", "propertiesFilepath", "pertiesFilepath", "settingsFileLocation", "pertiesFileType", "pertiesfileName", "settingsFileName", "propertiesFilenameLocation", "propertiesfileName", "propertiesfileLocation", "propertiesFileType", "propertiesfileType", "pertiesfilePath", "pertiesfilepath", "settingsFilepath", "propertiesFileLocation", "propertiesFilenamepath", "propertiesFilesType", "propertiesfilePath", "propertiesFilesName", "propertiesFilenamePath", "settingsFilenameLocation", "propertiesfilepath", "pertiesFileName", "propertiesFilespath", "settingsFilenameName", "propertiesFileName", "settingsFilePath", "propertiesFilesLocation", "propertiesFilenameName", "propertiesFilenameType", "pertiesfileType", "settingsFilenamepath", "pertiesFilePath", "propertiesFilesPath"], "file": ["record", "info", "domain", "os", "comment", "module", "File", "null", "ile", "FILE", "table", "run", "document", "fp", "rule", "path", "object", "base", "be", "files", "parent", "use", "name", "message", "connection", "buffer", "resource", "image", "port", "library", "print", "f", "io", "report", "content", "write", "source", "application", "console", "output", "create", "local", "complete", "language", "page", "string", "style", "class", "current", "pool", "model", "xml", "data", "fi", "channel", "type", "entry", "format", "key", "filename", "handle", "result", "attribute"], "in": ["gin", "read", " din", "oin", "get", "cin", "it", "ini", "inf", "inn", "ind", "ain", "ins", "ic", "rin", "io", "reader", "inc", "ai", "al", "IN", "from", "iter", "init", "en", "isin", "bin", "inner", "input", "ri", "sin", "din", "asin", "i", "inside", "ar", "ir", "In"], "out": ["os", "w", "end", "o", "aos", "it", "check", "can", "to", "outs", "log", "print", "io", "sw", "write", "put", "cache", "n", "cos", "output", "ex", "set", "csv", "Out", "inner", "con", "conf", "screen", "again", "nt", "outer", "conv", "ou", "at", "external", "OUT", "co", "we", "net"], "c": ["nc", "u", "t", "\u00e7", "gc", "ec", "cap", "rc", "cont", "ch", "C", "mc", "character", "lc", "count", "ct", "cc", "cp", "ce", "cs", "v", "dc", "cd", "l", "k", "call", "r", "cache", "cl", "x", "n", "code", "unc", "cos", "cf", "fc", "pc", "etc", "cr", "arc", "cu", "con", "conf", "char", "i", "cm", "cb", "co", "chain", "ca", "cod", "bc", "col", "ac", "d"], "is": ["os", "sis", "sit", "isl", "ios", "lis", "it", "isi", "its", "tis", "isc", "es", "iss", "ins", "ic", "isf", "iris", "nis", "isin", "ri", "\u00eds", "ris", "iso", "i", "sys", "as", "IS", "Is", "ais", "bis", "isa"], "breader": ["brewer", "breadr", " breadber", "bbr", "brower", "bbar", "brewger", " breadar", "bbder", "breadber", "browe", "breade", "bler", "blear", "browger", "brewber", " breadr", "browber", "breadder", "breadar", " breadger", "bleer", " breade", " breadder", "bleder", "bber", "breadger", "brewe"], "line": ["record", "handle", "LINE", "row", "detail", "note", "column", "phrase", "parse", "link", "sample", "email", "lo", "stay", "rule", "eline", "range", "inline", "se", "side", "block", "ice", "part", "cell", "message", "Line", "sequence", "port", "normal", "l", "log", "nl", "queue", "lines", "node", "code", "ln", "no", "cmd", "left", "iter", "stroke", "ip", "entity", "lin", "page", "string", "section", "continue", "char", "word", "body", "edge", "point", "query", "le", "slice", "mail", "next", "trace", "frame", "comment", "header", "online", "lane", "entry", "ine", "label", "text", "chain", "liner", "shell"], "strBuilder": ["strParser", "objBuilder", "stringbuilder", "StrBuffer", "stringParser", "arrBu", " strParser", "strBuilt", "Strbuilder", "stringBuild", " strBuffer", "objBuffer", "strBuffer", "arrBuilder", "stringBuilt", "arrParser", "strBu", "StrParser", "arrbuilder", "frBuilt", "StrBuilt", " strbuilder", "stringBuffer", " strBu", "objBuild", "StrBuild", "frParser", "objbuilder", "frBuilder", "arrBuild", "stringBuilder", "StrBuilder", "strbuilder", "strBuild", "arrBuffer", " strBuild", "StrBu", "frBuild"], "pieces": ["fits", "words", "knife", "eps", "rings", "ctors", "services", "xes", "ties", "piece", "sections", "its", "finals", "letters", "cars", "cuts", "powers", "pins", "places", "feet", "bits", "checks", "lines", "blocks", "items", "Parts", "ces", "caps", "groups", "links", "plates", "sts", "pointers", "keys", "types", "units", "ops", "steps", "fixes", "terms", "times", "tools", "parts", "bytes", "strings", "tips", "players", "ps", "maps"], "found": [" caught", " detected", " founded", "failed", "successful", "err", "mounted", "finished", "read", "forced", "built", "done", "old", "empty", "supported", "started", "success", "valid", "ed", "count", "used", "available", "bool", "focused", "needed", "confirmed", "created", "changed", "opened", "tested", "good", "find", "given", "released", "expected", "search", "printed", "fixed", "installed", "index", "compl", "first", " Found", "filled", "identified", "defined", "loaded", "Found", "sent", "sold", "finder"]}}
{"id1": "5125848", "id2": "5998352", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 1, "substitutes": {"combineJs": ["combINEJs", "ComboseJs", "combineLink", "combINEJS", "Combinejs", "combinatejs", "CombineLink", "combinateJS", "ComboseJS", "combinejs", "combINELink", "comboseJS", "combINEjs", "ComboseLink", "combinateLink", "combineJS", "Combosejs", "comboseJs", "CombineJS", "CombineJs", "comboseLink", "combinateJs", "combosejs"], "base": ["domain", "re", "api", "ase", "bottom", "b", "based", "host", "prefix", "Base", "address", "id", "buffer", "bound", "uri", "reset", " based", "source", "bid", "site", "from", "local", "start", "relative", "origin", "page", "template", " Base", "server", "bas", "root", " basis", "db", "absolute", "file", "data", " bases"], "linkJs": ["linkedLinks", " linkScript", "linkjs", "inkTags", "LinkJS", "Linkjs", "linkedJS", "LinkJs", " linkJS", "inkScript", " linkTags", " linkjs", "inkJs", "LinkTags", "linkLinks", "linkedJs", "inkJS", "inkLinks", "linkedScript", "inkjs", " linkLinks", "linkScript", "linkTags", "linkJS"], "newFiles": ["linkFiles", "newLinks", "nextFiles", "linkDocuments", "newDocuments", "nextfiles", "nextLinks", "linkfiles", " newLinks", "linkLinks", " newDocuments", "nextDocuments", " newfiles", "newfiles"], "dir": ["dd", "mod", "module", "zip", "disk", "diff", "done", "pkg", "mk", "ref", " d", "tar", "desc", "di", " Dir", "id", "cd", "directory", "md", "DB", "Dir", "doc", "folder", "DIR", "created", "temp", "out", "fs", "rel", "dm", "good", "local", "dr", "def", "lib", " directory", "dep", "root", "tmp", "div", "area", "manager", "db", "sys", "addr", "auto", "file", "fd", "lock", "dl", "loc", "vol", "wd", "ir", "d"], "name": [" prefix", " dummy", " filename", " scanner", " self", " names", " report", " str", " tmp", " logger", " start", " karma", " foo", " browser", " info", " res", " err", " vm", " manager", " rebuild", " db", " log", " b", " bar", " msg", " os", " cleaner", " parser", " loader"], "minDir": ["sortRel", "thinTier", "minutePref", "skindir", "skinDir", "minuteDir", "mindir", "smallDb", " minPref", " minJar", "miniTrans", " minFile", "smallLoc", "smallNet", "miniDir", "minNet", "minTrans", "minFile", "minRel", "miniJar", " minNet", "MinNet", "sortDar", " minDar", "mainLoc", "thinJar", "MinDir", "thinDir", "MinFile", "smallDir", "minJar", "minuteRel", "minuteDar", "miniTier", "maindir", "minLoc", "sortDir", "minDb", "skinLoc", " minRel", "sortPref", "smallFile", "minPref", "minTier", "smalldir", " minTier", " minTrans", "minDar", "mainDb", "skinDb", "mainDir", "thinTrans"], "combineFile": ["coordinefile", "combinfile", "coordINEWriter", "combineMessage", "comboiceMessage", "combinerfile", "comboiceEmail", "combinateMessage", "combinateEmail", "comineFile", "coordINEfile", "combINEWriter", "combosefile", "cominefile", "coordINESet", "comineEmail", "comboseWriter", "combinefile", "cominateMessage", "combinFile", "combINEfile", "combineSet", "combinWriter", "cominateFile", "comboiceFile", "cominatefile", "combineEmail", "coordineWriter", "comineMessage", "comboicefile", "coordineSet", "combinSet", "combINESet", "combinateFile", "coordineFile", "combINEFile", "coordINEFile", "comboseFile", "cominateEmail", "comboseSet", "combinerEmail", "combinatefile", "combinerMessage", "combinerFile"], "concatFile": ["convertTable", "cocatFile", "comcFile", "concatfile", "convertfile", "concDir", "conatTable", "conatFiles", "conCatDir", "covertFiles", "convertDir", "cocatTable", "concapFiles", "concatDir", "cocatfile", "concatFilename", "covertTable", "concFile", "convertFilename", "comcFilename", "comcDir", "cocatFiles", "covertFile", "concapFile", "concapTable", "covertfile", "comcatDir", "concapfile", "comcatFile", "conatfile", "concatTable", "convertFiles", "convertFile", "conatFile", "conCatFilename", "concatFiles", "concFilename", "comcatFilename", "conCatFile"], "combineWriter": ["ComboseCounter", "combieFile", "combineCounter", "Combinewriter", "combinateCounter", "combinewriter", "combieReader", "declineReader", "comboseCounter", "CombineWriter", "combieWriter", "combenWrite", "CombineCounter", "combenWriter", "combinatewriter", "declineWriter", "combineReader", "comboseReader", "combinateWriter", "declineFile", "comboseWriter", "combenCounter", "declinateFile", "combineWrite", "combinateWrite", "declineWrite", "declinateWriter", "ComboseWriter", "combieWrite", "ComboseWrite", "combinateReader", "CombineWrite", "combosewriter", "comboseWrite", "combinateFile", "comboseFile", "Combosewriter", "combenwriter", "declinateReader", "declinateWrite"], "concatWriter": ["coatFile", "cocatFile", "coatWriter", "concatsFile", "cocatWrite", "conatWriter", "convertReader", "comvertFile", "cocatWriter", "concatsWrite", "comcatWriter", "convertWrite", "comcatWrite", "conatWrite", "convertWriter", "concatReader", "conatReader", "coatWrite", "comvertWriter", "concatsWriter", "comvertReader", "comvertWrite", "cocatReader", "comcatFile", "concatsReader", "convertFile", "concatWrite", "conatFile", "coatReader", "comcatReader"], "fails": ["failed", "mailed", "facailing", "facails", "failing", "facocks", "frailing", "lails", "Fails", " falls", "lailed", "Fils", " failed", "Failed", "mocks", "frils", "frails", " focks", "mails", "lailing", "ifailing", "ifails", "ifocks", "frailed", "mailing", "ifailed", "lils", "fils", " failing", "focks", "Failing", "lalls", "facailed", "malls", "falls"], "link": ["mark", "close", "c", "linked", "inline", "line", "add", "check", "Link", "address", "map", "l", "skip", "log", "source", "node", "code", "ln", "set", "child", "links", "follow", "push", "share", "embed", "relation", "li", "display", "task", "script", "match", "loc", "self", "remote", "ink", "open", "load"], "path": ["join", "full", "src", "hex", "ath", "href", "ref", "prefix", "id", "p", "image", "resource", "uri", "route", "source", "str", "location", "relative", "string", "pattern", "template", "alias", "style", "input", "kind", "root", "Path", "data", "match", "file", "loc", "format", "entry", "key", "text", "prop", "PATH"], "url": ["lr", "ur", "null", "http", "hl", "href", "il", "ref", "ls", "host", "gl", "get", "build", "address", "id", "this", "resource", "uri", "l", "sl", "r", "nl", "request", "source", "str", "rel", "mount", "location", "ssl", "string", "char", "li", "Url", "mail", "abs", "ul", "web", "addr", "html", "loc", "ll", "URL", "browser"], "inputStream": ["outputSteam", " inputstream", "InputStyle", "InputTime", "outputstream", "inputSteam", "InputSet", "instream", "inputSet", " inputSteam", "inputTime", " inputStyle", "inTime", "inputStyle", " inputSet", "inputstream", "InputSteam", "inSet", " inputTime", "outputStyle", "InputStream", "Inputstream", "inStream"], "jsFile": ["cssPath", "javascriptFile", "jsPath", "jFilename", "cssFile", " jsfile", "javascriptTable", "JsFilename", "jPath", "javascriptPath", "javascriptName", "Jsfile", "javascriptfile", "cssTable", " jsFilename", "JsFile", " jsName", "JsPath", "jsfile", "cssfile", "jsTable", "jFile", " jsTable", "jName", "cssFilename", "jsName", "javascriptFilename", " jsPath", "jsFilename"], "fileName": ["getHash", " filePath", " fileHash", "FileName", "FileHash", " filename", "getName", "FilePath", "getname", "filePath", "getPath", "Filename", "filename", "fileHash"], "outputStream": ["outputForm", " outputForm", " outputstream", "outputSteam", " outputSet", " outputStyle", "writeStream", "OutputSet", "OutputStream", "outputstream", "inputSteam", "OutputStyle", "OutputForm", "outputSet", "writeSteam", "inputStyle", "Outputstream", "writeSet", "inputstream", "OutputSteam", "outputStyle", " outputSteam", "writestream", "inputForm"], "first": ["fast", "true", "each", "send", "First", "default", "top", "success", "unique", "valid", "sort", "ind", "now", "natural", "must", "false", "fourth", "last", "prev", "primary", "master", "seconds", "only", "same", "quick", "st", "front", "start", "all", "real", "current", "continue", "second", "index", "next", "important", "then", "latest", "initial", "self", "open", "third", "stack"], "reader": ["row", "http", "read", "handler", "rc", "rar", "ner", "driver", "stream", "mr", "rer", "iterator", "this", "buffer", "context", "writer", "runner", "er", "resource", "wrapper", "rator", "r", "io", "ocr", "rl", "ro", "Reader", "inner", "input", "core", "file", "data", "layer", "parser", "loader", "rr", "builder"], "jsCompressor": ["cssRepressor", "cssCompressor", "cssReposer", "jscompiler", "jscompression", "cssComposer", "cssCompression", "jsReposer", "jsCompiler", "cssRepiler", "jsRepressor", "jsBuffression", "cssCompiler", "jsComposer", "jsBuffiler", "jsCompression", "jsBuffressor", "jscompressor", "jsRepiler", "cssRepression", "jsBuffoser", "jsRepression", "jscomposer"], "s": ["full", "ms", "details", "less", "os", "words", "eds", "t", "qs", "ls", "ss", "tes", "es", "ies", "ns", "ts", "y", "cs", "ers", "l", "lines", "ats", "gs", "fs", "pers", "ids", "S", "ens", "ds", "hs", "xs", "parts", "is", "ings", "tags", "ps"], "s1": ["ls81", "ys0", "ys1", "pers0", "ls0", "idFirst", "id1", "sFirst", "s0", "s3", "ys81", "pers1", "es1", "ls3", "esFirst", "s81", " s81", " s3", "es9", "s9", "ps0", "ps1", "ls1", "ys3", " s0", "id9", "id2", "es2"], "i": ["iat", "ci", "ifier", "im", "ia", "j", "ii", "iti", "ion", "I", "ch", "us", "mi", "oi", "o", "ati", "pi", "it", "di", "ui", "id", "p", "y", "v", "ic", "io", "ai", "um", "ori", "iu", "bi", "ip", "ig", "ie", "ri", "li", "is", "ity"], "s2": ["tes1", "Stwo", "ss22", "tes2", "gsSecond", "es02", "SSecond", "gs2", "s02", "S2", "ss02", "stwo", "es1", "ssTwo", "ztwo", "ms02", "z02", "sTwo", "esTwo", "ss2", "ms2", "gs02", "gstwo", "tes02", "sSecond", "zSecond", "z2", "msTwo", "s22", "tesTwo", "ms22", "es2", "S02"], "i1": ["oOne", "eOne", "a1", "p4", "iOne", "p1", "it01", "o0", "it4", "p2", "a01", "it2", "it0", "e4", "o1", "e2", "i2", "a2", "p01", "i0", "pOne", "o4", "p0", "e1", "aOne", "i4", "i01", "itOne", "it1"]}}
{"id1": "19810820", "id2": "15905041", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"copyFileChannel": ["copyByteChannel", " copyFileFile", " copyFilesStream", "copyByteFile", " copyStreamChannel", "copyBytechannel", " copyFilesFile", " copyFileschannel", " copyByteFile", "copyFilechannel", " copyByteStream", " copyByteChannel", " copyBytechannel", "copyFileFile", " copyStreamchannel", " copyStreamFile", " copyFilechannel", " copyFileStream", "copyByteStream", " copyFilesChannel", " copyStreamStream", "copyFileStream"], "src": ["rt", "RC", "sc", "in", "bs", "SOURCE", "rc", "cont", "syn", "ls", "usc", "SourceFile", "ser", "sq", "s", "ins", "req", "sl", "sync", "sf", "cur", "rl", "source", "js", "rel", "st", "from", "rs", "ctr", "sb", "rx", "txt", "start", "init", "dest", "sec", "input", "img", "usr", "sr", "tmp", "sys", "Source", "inst", "loc", "filename", "obs"], "dst": [" dist", "Dnd", "best", "Dest", "snd", "sst", "dut", " dth", "ddest", "Ddest", "jst", "bist", "dnd", "jdest", "sest", "dist", " ddest", "sdest", "sth", "jest", " dest", "dest", "bst", " dnd", "sut", "dth", "Dth", "bdest", "Dist", "Dst", "jut", "Dut"], "preserveModificationTime": ["preserveModifyingLength", "preserveModificationsPoint", "preserveModifyingTime", "preserveModifiedTim", "preserveQualificationTime", "preserveModifiedTime", "preserveModifyingPoint", "preserveSpecificationTimes", "preserveQualificationPoint", "preserveModifyPoint", "preserveSpecificationTime", "preserveSpecificationsTimes", "preserveModifyingTimes", "preserveModifiedTimes", "preserveModificationTim", "preserveModifierTim", "preserveQualificationsTimes", "preserveQualificationTimes", "preserveModificationsTim", "preserveModifyTimes", "preserveModificationsTimes", "preserveModifierTimes", "preserveModificationsTime", "preserveQualificationLength", "preserveModificationPoint", "preserveModificationsLength", "preserveModificationTimes", "preserveSpecificationsTim", "preserveQualificationsLength", "preserveSpecificationTim", "preserveQualificationsTime", "preserveModifierTime", "preserveModifyTime", "preserveModificationLength", "preserveModifyLength", "preserveQualificationsPoint", "preserveSpecificationsTime"], "inputChannel": ["openConnection", "inputChuck", " inputGray", " inputchannel", "openGray", "evalChan", " inputCategory", "openChan", "inputChan", "inputGray", "hiddenCategory", "InputChannel", " inputConnection", " inputListener", "clientChan", "outputChuck", "clientGray", "hiddenListener", "inputConnection", "clientConnection", "entityChan", "clientChannel", "inputchannel", "interfaceChannel", "infochannel", "inputBuffer", "infoChuck", "outputChan", " inputBuffer", "innerChannel", "infoChannel", "innerStream", "inputListener", "interfaceListener", "hiddenChannel", " inputStream", " inputChan", "innerChan", "entityChannel", "InputBuffer", "infoChan", "outputBuffer", "outputStream", "InputChan", "openChannel", "Inputchannel", "inputCategory", "outputchannel", "InputStream", "evalChannel", " inputChuck", "interfaceCategory", "inputStream", "innerchannel"], "outputChannel": ["outputButton", "writechannel", "coinChannel", "displaychannel", "outputManager", "OutputConnection", "inputChan", "putChan", "doubleChannel", "webChannel", "Outputchannel", "putButton", "writeStream", "writeManager", "putChannel", "displayChannel", " outputConnection", "outputConnection", "OutputChannel", "inputConnection", "inputManager", " outputManager", "OutputStream", "webchannel", " outputButton", " outputchannel", "doubleChan", "coinField", "OutputManager", "coinInstance", " outputChan", "outputChan", "doubleField", "webManager", "inputField", "outputStream", "displayChan", "inputInstance", "coinChan", "outputchannel", "putchannel", "outputField", "displayButton", "OutputChan", "writeChan", "writeChannel", "outputInstance", "doubleInstance", " outputStream"], "length": ["full", "join", "details", "capacity", "ENGTH", "offset", "amount", "component", "end", "base", "value", "count", "required", "available", "history", "list", "width", "buffer", "sequence", "to", "l", "library", "limit", "number", "needed", "padding", "height", "term", "left", "start", "expected", "volume", "load", "all", "partial", "ength", "position", "present", "Length", "json", "HH", "then", "loop", "bytes", "size", "data", "type", "len", "max", "family", "time", "text", "duration", "shape"], "total": ["equal", "bar", " Total", "full", "info", "less", "successful", "t", "note", "active", "done", "zero", "offset", "amount", "free", "base", "raw", "unique", "valid", "required", "count", "used", "available", "scale", "this", "sequence", "last", "summary", "to", "stable", "number", "created", "otal", "ta", "unknown", "human", "no", "local", "good", "title", "all", "current", "meta", "num", "index", "sum", "checked", "quant", "description", "size", "eta", "translation", "max", "complete", "Total"]}}
{"id1": "18370075", "id2": "22625683", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"createPasswordDigest": ["createPasswordDester", "createPasswordDigests", "createPasswordDigum", "createPasswordDest", "createPasswordDigester", "createPassworddigest", "createPassworddigester", "createPassworddigum", "createPasswordDum", "createPassworddigests", "createPasswordDests"], "password": ["pass", "secret", "words", "email", "phrase", "Password", "username", "value", "address", "name", "message", "sword", "login", "reset", "padding", "user", "auth", "string", "pattern", "token", "word", "present", "database", "session", "hash", "description", "data", "response", "hello", "entry", "key", "wd", "command", "shadow", "attribute"], "salt": ["sesave", "paint", " sig", "tol", "taint", "Saint", "sesalt", "sesALT", " sALT", "palt", "sALT", "Save", "pALT", "Salt", "talt", "sol", "save", "Sig", "Sol", "sesig", " save", "SALT", "pol", "sig", "tALT", "saint"], "md": ["mod", "m", "ms", "ad", "det", "pd", "df", "ld", "amd", "mode", "mk", "mc", "pm", "add", "nd", "desc", "MD", "di", "ct", "ind", "rm", "cd", "mn", "mt", "od", "bd", "sam", "mb", "sm", "mg", "sd", "js", "strong", "cmd", "dm", "mm", "metadata", "dr", "td", "def", "pdf", "der", "nt", "hd", "red", "mand", "mp", "and", "dd", "d"], "digest": ["degested", " digidate", "signum", " digum", "designester", "degesting", "designest", "degest", "digute", " digist", "mdEST", "digested", "Digidate", "designesting", " digute", "mdest", "mdesting", "mdist", "digester", "signidate", "degester", "digesting", "digum", "digidate", "DigEST", "signest", "designested", "Digum", "Digist", "Digute", " digEST", "digist", "mdester", "signute", "Digest", "digEST", "mdested", "mdum"]}}
{"id1": "20375440", "id2": "21488868", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyDirectory", " copyfile", "moveFiles", "moveDirectory", "copyfile", "CopyFiles", "Copyfile", " copyFiles", "CopyDirectory", "copyFiles", "moveFile", "copyDirectory", "movefile", "CopyFile"], "srcFile": ["subWeb", " srcPath", " srcFiles", "sourceFile", "rcFile", "srcPath", "srcLine", "subFile", "rcfile", "subPath", "rcLine", " srcWeb", "rcFiles", "sourcefile", "sourcePath", "rcPath", "subLine", "srcWeb", "srcfile", "srcFiles", "sourceFiles", "rcWeb", " srcLine", " srcfile"], "destFile": ["srcFilename", "destDir", "DestFile", "destFilename", "destMail", "DestPath", "srcPath", " destPath", "srcMail", "DestFiles", " destDir", "potMail", " destMail", "potDir", " destFilename", "destPath", "srcFiles", "potFilename", "destFiles", "potFile", "srcDir", "DestDir", " destFiles"], "src": ["sit", "rt", "sc", "sing", "rob", "http", "sel", "rc", "syn", "pri", "ser", "sh", "sq", "rest", "ins", "req", "sl", "reader", "sync", "rl", "cur", "sub", "proc", "source", "sf", "scan", "rel", "ln", "st", "rs", "ctr", "sb", "rx", "ssl", "rb", "iv", "inner", "usr", "sin", "sr", "gob", "comp", "via", "sys", "inst", "loc", "const"], "dest": ["pl", "sit", "gd", "pos", "Dest", "gate", "opt", "cont", "end", "mk", "nd", "trans", "desc", "di", "pas", "decl", "coord", "must", "dc", "port", "rest", "master", "news", "doc", "std", "temp", "dist", "out", "source", "dis", "rel", "st", "output", "mm", "exp", "cat", "dat", "bin", "result", "them", "usr", "nt", "priv", "nom", "sum", "target", "inv", "pipe", "comp", "des", "loc", "self", "pub", "comb", "est"], "buffer": ["bar", "memory", "row", "phrase", "binary", "buff", "length", "table", "sample", "variable", "document", "object", "component", "batch", "base", "stream", "block", "value", "mem", "Buffer", "available", "message", "sequence", "limit", "print", "password", "event", "number", "cache", "window", "buf", "page", "word", "char", "stack", "frame", "comment", "header", "data", "initial", "channel", "entry", "button", "text", "attribute", "command", "result", "shape", "append"], "read": ["t", "Read", "get", "add", "str", " Read", "word", "input", " write", "char", "num", "index", "draw", "reading", "reads", "load", "parse", "sample", "old", "end", "ind", "scale", "last", "print", "depth", "play", "q", "find", "seek", "query", "wait", "config", "key", "open", "shape", "record", "each", "in", "length", "have", "give", "mix", "check", "build", "skip", "fill", "sync", "height", "n", "pe", "iter", "current", "next", "text", "pass", "send", "shift", "allow", "run", "stream", "valid", "count", "tail", "need", "READ", "reader", "readable", "write", "no", "start", "size", "len", "hold"]}}
{"id1": "10131427", "id2": "13886238", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " copyStream", " cpStream", " copyImage", " cpImage", " cpfile", " copyfile", " CopyStream", "CopyImage", "Copyfile", " CopyImage", " Copyfile", "CopyStream", " cpFile", "CopyFile"], "in": ["gin", "vin", "b", "old", "o", "up", "cin", "it", "on", "inf", "inn", "ind", "ins", "s", "ic", "rin", "l", "r", "inc", "source", "n", "st", "from", "IN", "mm", "en", "isin", "input", "edIn", "din", "i", "el", "is", "ar", "In"], "out": ["os", "t", "err", "w", "po", "b", "gt", "ot", "ch", "o", "it", "check", "v", "help", "s", "to", "outs", "l", "log", "io", "str", "n", "output", "ex", "Out", "nt", "ou", "oss", "i", "file", "OUT", "serv", "ne", "net"], "sourceChannel": ["matchChannel", "ourceChannel", " sourceButton", "srcchannel", "resourcechannel", "resourceStream", "seedApplication", "inputChan", "SourceConnection", "SourceChannel", "SourceStream", "resourceChannel", "sourceChuck", "Sourcechannel", "sourceConnection", "seedButton", "sourcechannel", "inputConnection", "inputChain", "ourceChain", "sourceApplication", " sourceChan", "srcButton", "matchButton", "matchApplication", "srcStream", "singleChannel", "srcChannel", "ourceChan", "sourceChain", "matchChuck", " sourcechannel", "ourceButton", "seedChuck", " sourceStream", "ourceConnection", "singleApplication", "ourceStream", " sourceChain", "ourcechannel", "resourceConnection", "singleChuck", "inputChannel", "sourceStream", " sourceConnection", "singleButton", "sourceButton", "sourceChan", "seedChannel"], "destinationChannel": ["destroyClient", "DestinationChan", "DestinationConnection", "destinatedChan", "DestationContext", "desticationChannel", "destinatoryChannel", "destroyChan", "DestensionChan", "DestationChan", "destinationConnection", "DestationChannel", "destationConnection", "destinatoryChan", "destensionChan", "destationClient", "destroyConnection", "desticationCow", "DestationConnection", "desticationChan", "DestinationCow", "destensionChannel", "destinatedChannel", "destationBlock", "DestationCow", "destinationClient", "destinationContext", "destationCow", "DestensionChannel", "destensionConnection", "destationChan", "DestinationChannel", "desticationBlock", "DestinationContext", "destinationBlock", "destinationChan", "DestensionClient", "destinationsChannel", "DestinationBlock", "destinatedConnection", "destinationsContext", "destinationsChan", "destinationsConnection", "destensionClient", "destinationCow", "DestensionConnection", "destationContext", "destroyChannel", "destinatoryBlock", "DestationBlock", "DestinationClient", "destinatedContext", "destationChannel", "destinatoryCow"]}}
{"id1": "7458833", "id2": "16623181", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFiletoCodeFile", " copyParseFiletoCodeTable", " copyParseFileToGofile", " copyParseFileToInfoFile", " copyParseFileToInfofile", " copyParseFileTocodefile", " copyParseFileToGoFiles", " copyParseFiletocodeTable", " copyParseFiletocodefile", " copyParseFileToCodefile", " copyParseFiletocodeFile", " copyParseFileToInfoTable", " copyParseFiletoCodeFiles", " copyParseFileTocodeTable", " copyParseFileTocodeFile", " copyParseFiletocodeFiles", " copyParseFileToGoTable", " copyParseFileToCodeTable", " copyParseFileToGoFile", " copyParseFileToCodeFiles", " copyParseFileTocodeFiles", " copyParseFiletoCodefile", " copyParseFileToInfoFiles"], "in": ["gin", "info", "ad", "im", "read", "up", "cin", "it", "on", "check", "inf", "ini", "inn", "ind", "ze", "ain", "ins", "ic", "rin", "io", "ai", "inc", "al", "iter", "from", "IN", "act", "init", "mm", "en", "isin", "inner", "bin", "con", "input", "din", "inside", "i", "is", "ar", "ir", "In"], "out": ["os", "cn", "null", "t", "ot", "o", "up", "aos", "it", "on", "check", "client", "v", "writer", "can", "obj", "to", "outs", "io", "by", "write", "one", "dis", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "and", "nt", "conv", "outer", "ou", "oss", "i", "at", "sys", "auto", "OUT", "co", "ne", "cos", "net"], "buffer": ["bar", "memory", "paste", "row", "phrase", "binary", "buff", "table", "sample", "variable", "document", "component", "batch", "character", "pad", "block", "reason", "Buffer", "history", "cell", "message", "sequence", "resource", "print", "queue", "cache", "temp", "window", "buf", "iter", "template", "result", "word", "char", "bridge", "database", "frame", "comment", "initial", "view", "button", "display", "bone", "command", "stack", "attribute", "append"], "length": ["enth", "full", "join", "bow", "t", "stop", "total", "capacity", "how", "ENGTH", "component", "collection", "amount", "integer", "count", "available", "history", "binding", "message", "sequence", "maximum", "frequency", "l", "print", "number", "padding", "height", "availability", "impl", "start", "distance", "deep", "ength", "position", "present", "Length", "lambda", "database", "point", "frame", "closure", "data", "reading", "size", "hello", "len", "duration", "volume", "family", "load", "shape", "angle"]}}
{"id1": "14819747", "id2": "18433984", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"debug": ["mod", "javascript", "module", "binary", " debugging", "progress", "dump", "close", "mode", "default", "secure", "hide", "enable", " DEBUG", "valid", "error", "color", "enabled", "bug", "ose", "change", "log", "print", "depth", "hidden", "cache", "write", "play", "hack", "production", "date", "console", "test", "google", "step", "dev", "related", " debugger", "shell", "develop", "DEBUG", "show", "tag", "web", "db", "trace", "config", "comment", "data", "file", "development", "Debug", "display", "stats", "dd", "browser", "dir", "d"], "prologFile": ["procellLine", "propelFile", "probadFILE", "prolexBody", "profileFile", "prozipParser", "ProLogMessage", "prologFILE", "prologPlace", "proconfigFiles", "prologFiles", "ProLogFiles", "proplotBody", "problogFiles", "prozipfile", "PrologLine", "proplotFilename", "proplotFILE", "prologMessage", "ProLogParser", "probadParser", "proplogFilename", "proLogFiles", "prologParser", "PrologFILE", "prologLine", "proLogPlace", "Prologfile", "procellfile", "prozipFile", "probadFile", "ProLogLine", "prosystemfile", "prologBody", "prosystemFile", "problogfile", "procellPath", "proLogFile", "ProLogFILE", "profilefile", "proplexFilename", "rologFiles", "prozipFILE", "PrologParser", "proplotFile", "propelFILE", "propelFilename", "prolexFile", "prolexFILE", "proLogFILE", "proLogPath", "problogFilename", "prologDo", "PrologFilename", "prologFilename", "proplogFILE", "prologfile", "proplogBody", "prologPath", "PrologPath", "PrologPlace", "rologFile", "proplexFile", "proLogMessage", "proLogLine", "PrologFiles", "PrologMessage", "ProLogFilename", "prolexFilename", "proLogDo", "propelBody", "problogFile", "problogPlace", "ProLogPlace", "rologDo", "ProLogfile", "prosystemMessage", "proLogFilename", "proplexBody", "proconfigFile", "problogDo", "PrologFile", "ProLogFile", "proLogParser", "proplogFile", "proconfigPlace", "profilePath", "rologfile", "ProLogPath", "profileLine", "probadfile", "proLogfile", "proconfigFilename", "proplexFILE", "procellFile", "prosystemFiles"], "targetFile": ["targetPath", "targetDir", "targetFilename", "sourceFile", "destDir", "destFilename", "TargetPath", "TargetFile", "topFile", "secondaryDisk", "sourceDir", "topDirectory", "baseDir", "targetDisk", "secondaryPath", "TargetDisk", "basePath", "topDisk", "baseFilename", "secondaryDirectory", "secondaryFile", "targetDirectory", "destFile", "TargetDirectory", "sourcePath", "topPath", "destPath", "baseFile", "sourceFilename"], "source": ["join", "src", "sql", "secret", "note", "sample", "expression", "SOURCE", "base", "se", "scope", "raw", "ser", "store", "sp", "message", "buffer", "sequence", "resource", "unit", "password", "layout", "content", "str", "code", "ource", "site", "from", "start", "language", "string", "title", "state", "template", "style", "input", "position", "show", "body", "target", "html", "Source", "comment", "description", "file", "response", "format", "display", "text", "status", "result", "shell"], "myParser": ["somePlayer", "miparser", "MyParser", "myPlugin", " myPlayer", "miPlugin", "MyBuilder", "myReader", " myPlugin", "someParser", "miParser", " myparser", "someBuilder", "MyPlayer", "multiparser", "multiParser", "myPlayer", "myparser", " myBuilder", "miReader", "multiPlugin", "myBuilder", "someReader", " myReader", "multiReader", "MyReader"], "myProgram": ["yourProcess", "yourProgram", "userPlatform", "anotherProgram", "Myprogram", "MyProcess", "userProgram", " myProcess", " myLog", "thisProgram", "userWar", " myWar", "userProcess", "MyLog", "anotherParser", "miProgram", "yourParser", "thisPlatform", "miprogram", "anotherprogram", " myPlatform", "miLog", "anotherProcess", "thisWar", "myWar", "myProcess", "myLog", "myprogram", "yourprogram", "myPlatform", "thisProcess", "miProcess", "MyProgram", " myprogram"], "myVisitor": ["myActivier", "miVisier", "myJaniter", "myJanistor", "miVisactor", "yourJanator", "myVisiter", "myJanitation", "yourJanistor", " myvisiter", "myJanifier", "myActivitor", "myAudactor", "myVisualifier", "myActivactor", " myvisistor", "miAuditer", "myVisactor", "myvisistor", " myvisitor", "myVisualistor", "miAudier", "miAudactor", "myVitation", "yourJanifier", "myAuditor", "myJanitor", "myCreatator", "myCreatistor", " myvisitation", "myAudier", "myAuditer", "miVisitor", "myViter", "myvisitor", "myVisualitor", "myVisualator", "myActiviter", "myJanier", " myVisistor", "yourVisitor", "yourVisifier", "myvisiter", "yourJanitor", "myVisistor", "myVistor", "yourVisistor", "myJanactor", " myVisiter", "miVisiter", " myVisitation", "myCreatitor", "myVisator", "myVisier", "myVitor", "yourVisator", "myvisitation", "myVisitation", "myCreatifier", "miAuditor", "myJanator", "myVisifier"], "adapterLayer": ["adurationMap", "adviceHeader", "adurationStack", "adviceMap", "adviceListener", "agapterListener", "adapterStack", "anviceMap", "anapterLayer", "adaptersStack", "agapterLayout", "adaptersHeader", "agclerLayout", "agclerLayer", "adclerListener", "adclerLayout", "adviceStack", "adapterLayout", "adaptersListener", "anapterStack", "agapterLayer", "adaptersLayer", "adclerHeader", "adclerLayer", "adapterHeader", "adviceLayer", "anviceStack", "adviceLayout", "adaptersMap", "agclerHeader", "anapterMap", "agapterHeader", "anviceLayer", "agclerListener", "adaptersLayout", "adapterListener", "adapterMap", "adurationLayer"], "classLoader": ["Classloader", "ClassReader", "ClassPath", "classReader", " classloader", "resourcePath", " classReader", "classPath", "resourceReader", "resourceLoader", "ClassLoader", " classPath", "resourceloader", "classloader"], "adapterWriter": ["audaptersReader", "adaptersReader", "audapterReader", "adaptersMaker", "adabilityWrite", "audaptersWriter", "audaptersMaker", "adapterWrite", "audapterWrite", "adabilityMaker", "adaptersWriter", "audaptersWrite", "adabilityReader", "adabilityWriter", "adAdapterWrite", "adaptersWrite", "audapterMaker", "adAdapterReader", "adAdapterMaker", "adAdapterWriter", "adapterReader", "adapterMaker", "audapterWriter"], "annotationGenerator": ["annotationGenerators", "annationgenerators", "annotationGenators", "annationgenerator", "annotationValidater", "annotationValidator", "annotationgenerator", "annationGenerater", "annationGeneration", "annotationGenater", "annotationGeneration", "annotationValidators", "annationgenerater", "annotationgeneration", "annotationGenerater", "annotationgenerater", "annationgeneration", "annotationgenerators", "annationGenerator", "annationGenerators", "annotationValidation", "annotationGenator", "annotationGenation"], "out": ["pretty", "null", "err", "in", "w", "nr", "up", "aos", "base", "gr", "desc", "inf", "store", "list", "client", "last", "writer", "obj", "ins", "group", "outs", "print", "log", "io", "content", "conn", "term", "str", "n", "res", "cmd", "output", "ex", "txt", "set", "Out", "init", "inter", "inner", "cfg", "tree", "con", "screen", "nt", "outer", "conv", "sum", "ou", "inv", "session", "manager", "json", "sys", "pool", "msg", "OUT", "dt", "crit", "net"]}}
{"id1": "1954410", "id2": "13783898", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"doExecute": ["doExecutes", "doEditute", "DoExecit", "doCommutes", "doCommute", "DoExecExec", "doCommExec", "doEditutes", "doExecExec", "DoExecutes", "doCommit", "doEditExec", "DoExecute", "doEditit", "doExecit"], "mapping": ["mappings", "smappings", "Mapper", "smapping", "mapped", " mappings", " mapper", " mapped", "Mapped", "mapper", "smapper", "Mapping", "smapped", "Mappings"], "form": [" FORM", "m", "orm", "forms", "path", "FORM", "raw", "parent", "map", "owner", "f", "sam", "Form", " forms", "fc", "template", "app", " Form", "session", "config", "subject", "formed", "view", "self", "format", "type", "command"], "request": ["QUEST", "http", "w", "se", "version", "quest", "address", "context", "impl", "user", "input", "model", "project", "Exception", "client", "post", "report", "order", "template", "session", "query", "xml", "view", "Request", "open", "command", "document", "store", "question", "this", "sw", "application", "def", "current", "server", "first", "initial", "remote", "true", "upload", "_", "allow", "cont", "url", "host", "reference", "parent", "Upload", "message", "resource", "reset", "req", "window", "create", "container", "instance", "frame"], "response": ["re", "send", "resp", "document", "success", "sp", "ce", "message", "connection", "report", "print", "content", "write", "respond", "application", "res", "output", "reply", "server", "Response", "session", "frame", "xml", "view", "status", "result"], "errors": [" steps", "Mess", " mess", " warnings", " requests", " success", "ages", " updates", " statements", " managers", " logs", " storage", " problems", " states", " state", " flash", " Messages", " messages", " manager", " error", " changes", " fails", " elements", " messenger", " status", " flashes", " moves", " sessions"], "isMultipart": ["isMultospart", "isMultiIPain", "isMultIPade", "isMultiod", "isMultipod", "isMultipain", "isMultiIPod", "isMultiIPart", "isMultiade", "isMultifarts", "isMultIPart", "isMultiplade", "isMultIPod", "isMultosparts", "isMultipade", "isMultifain", "isMultipare", "isMultiipart", "isMultiiparts", "isMultifart", "isMultospare", "isMultiipade", "isMultiarts", "isMultiIParts", "isMultiipain", "isMultiplod", "isMultiparts", "isMultIParts", "isMultiplart", "isMultiIPade", "isMultospain", "isMultiipare", "isMultIPain", "isMultiart", "isMultiipod", "isMultifare", "isMultiIPare", "isMultiplarts", "isMultIPare"], "mailInstance": ["flexance", "emailance", "flexinstance", " MailBuilder", "emailinstance", " mailinstance", "mailance", " mailance", "mailinstance", " MailInst", "flexInstance", "emailBuilder", "emailInstance", " mailInst", " MailInstance", " Mailinstance", "flexInst", "mailInst", "mailBuilder", "emailInst", " mailBuilder"], "fields": ["faces", "modules", "details", "frames", "packages", "qs", "features", "services", "forms", "pages", "rows", "balls", "sections", "files", "relations", "states", "packs", "users", "views", "workers", "checks", "bits", "prints", "lines", "flags", "comments", "members", "rules", "groups", "headers", "links", "dates", "objects", "keys", "holders", "types", "ports", "phones", "drivers", "properties", "locks", "plugins", "levels", "terms", "orders", "reports", "names", "parts", "posts", "tests", "lights", "models", "strings", "days", "field", "atts", "classes", "images", "tags", "lists", "boxes"], "attachments": ["Attachions", "attachements", " attachitions", "attitions", " attachions", "achresses", "acheements", "payements", "Attachensions", "acheitions", "Attachresses", "Attachitions", "Attachments", "attensions", "payitions", "attachMENTS", "achions", "attachions", " attachresses", "attachitions", " attachements", "AttachMENTS", "attments", "achments", "attachresses", "attMENTS", " attachances", "achements", "achensions", "attachances", "achitions", "attachensions", "payances", "achMENTS", "payments", "acheances"], "items": [" inputs", "packages", " images", "actions", "Items", "services", "pages", "resources", " Items", "events", "rows", "results", "its", "files", " files", "ips", "issues", "lines", "members", " results", "ids", "groups", "links", "objects", "keys", "phones", "photos", "archives", "reports", "orders", "names", "parts", " samples", "apps", "tests", "images", "cases", "qs"], "iter": ["oper", "re", "older", "cmp", "each", "read", "tif", "coll", "upper", "ner", "Iterator", "it", "its", "maker", "ser", "store", "ind", "iterator", "list", "writer", "er", "Iter", "reader", "gener", "ait", "altern", "test", "order", "set", "former", "init", "inter", "inner", "tr", "ite", "outer", "orient", "walker", "i", "li", "ter", "iner", "el", "loop", "loc", "ipper", "ator", "result", "dir"], "item": ["info", "details", "attr", "up", "add", "claim", "member", "atom", "one", "anything", "att", "word", "json", "el", "match", "attribute", "row", "it", "raw", "internal", "cell", "unit", "er", "order", "mm", "step", "entity", "stat", "related", "template", "xml", "job", "key", "status", "record", "other", "link", "Item", "on", "or", "store", "change", "obj", "spec", "element", "ip", "app", "area", "addr", "file", "initial", "module", "detail", "zip", "rule", "object", "url", "name", "image", "resource", "group", "single", "ex", "local", "page", "inner", "instance", "ix", "data", "layer", "entry", "type", "event"], "aux": ["av", "ox", "aim", "fuck", "ax", "buff", "mu", "us", "du", "pet", "ups", "aos", "lim", "pad", "aw", "used", "au", "aff", "uf", "AU", "off", "ux", "fu", "fx", "vers", "airs", "ex", "extra", "etc", "cu", "imp", "fat", "fam", "area", "ras", "fax", "uds", "aus", "abs", "ix", "uff", "af", "eu", "auto", "tx", "max", "foo", "net"], "part": ["mod", "api", "pkg", "piece", "pair", "add", "version", "block", "worker", "party", "member", "pre", "Part", "word", "par", "relation", "comp", "join", "pos", "sample", " parts", "bound", "print", "half", "temp", "card", "step", "art", "zone", "html", "tx", "job", "and", "pt", "person", "photo", "PART", "component", "pad", "peer", "list", "primary", "work", "tmp", "split", "parts", "format", "detail", "object", "pet", "top", "prefix", "base", "parent", "sp", "message", "p", "group", "wrapper", "patch", "tab", "admin", " Part", "local", "start", "inner", "partial", "section", "pod", "point", "layer"], "baos": ["caOS", "boOs", "boo", "poops", "caoss", "taos", "kais", "pooses", "caOs", "vaoss", "tao", "baols", "poos", "bios", "cao", "vaos", "waols", "biOS", "baoses", "tais", "baops", "waoss", "baoss", "waos", "bao", "taOs", "pooss", "kaoss", "kaops", "caos", "bio", "taops", "vaOs", "taoss", "boos", "caols", "poo", "kaos", "waOs", "bioses", "baOs", "booses", "poOS", "boOS", "vaols", "bais", "booss", "pois", "baOS"], "body": ["pass", "Body", "ODY", "detail", "t", "note", "send", "binary", "null", "foot", "default", "base", "tail", "plain", "name", "message", "buffer", "port", "summary", "post", "report", "log", "layout", "content", "scroll", "rel", "output", "title", "tree", "template", "head", "business", "json", "mail", "html", "bill", "loop", "description", "comment", "header", "subject", "data", "size", "file", "format", "display", "text", "ody", "shell"], "preferencesInstance": ["prefferencesinstance", "prefutesImpl", "preffiesInstance", "prefancesInstance", "prefutesinstance", "prefiesObj", "prefferencesInstance", "preffiesinstance", "prefancesImpl", "prefutesInstance", "preferencesImpl", "prefiesinstance", "prefancesObj", "prefiesImpl", "prefferencesImpl", "preffiesObj", "preffiesImpl", "preferencesinstance", "prefutesObj", "preferencesObj", "prefferencesObj", "prefancesinstance", "prefiesInstance"]}}
{"id1": "19849797", "id2": "8150996", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", " copyStream", "transferStream", "transferfile", " cpStream", "transferFiles", " cpfile", " copyfile", "copyfile", " cpFiles", " copyFiles", "copyFiles", "copyStream", " cpFile"], "sourceFile": [" sourcePath", " sourcePage", "srcPath", "ourcePath", "srcLine", "ourceFile", "srcField", "ourceField", "ourceTable", "sourcePage", "sourceLine", "sourcefile", "srcFile", "sourcePath", "srcPage", "ourcePage", " sourceLine", "srcfile", "sourceTable", " sourceField", " sourcefile", "ourceLine", "sourceField", "srcTable", " sourceTable", "ourcefile"], "destFile": ["datPlace", "declEntity", "optFolder", "destDir", "DestFile", "destFilename", "restPlace", "optPath", "optFile", "srcFolder", "DestPath", "srcPath", " destPath", "DestFilename", "DestFiles", " destDir", "destEntity", "restFile", "optFilename", "srcFile", " destFilename", " destPlace", "declFile", "destFolder", "destPath", "optEntity", "srcFiles", "datFilename", "destFiles", "datFiles", "restFiles", "datFile", "DestDir", "srcDir", "destPlace", "srcEntity", "declDir", " destFiles", "restFilename", "declFolder", "optDir"], "source": ["src", "before", "OURCE", "send", "note", "in", "parse", "update", "sample", "local", "SOURCE", "table", "component", "back", "score", "se", "stream", "scope", "none", "parent", "check", "store", "ce", "slave", "iterator", "use", "scale", "image", "resource", "sequence", "spec", "owner", "reader", "service", "console", "ource", "standard", "from", "iter", "start", "create", "init", "origin", "copy", "search", "inner", "style", "ie", "load", "input", "missing", "char", "body", "index", "target", "proxy", "query", "show", "force", "Source", "comment", "cause", "match", "subject", "channel", "attribute", "pose", "series", "result", "shell"], "destination": ["destined", "separment", "Destinator", "decinate", "noninate", "nonination", "decination", "descation", "descinate", "verination", " destation", "restinator", "descinator", "verinated", "termininate", " destinate", " destinator", "noninator", "restinated", "destation", "Destation", " destificate", "veration", "descination", " destment", "separinated", "separation", "Destination", "decined", "separination", "destificate", "Destment", "Destinate", "noninated", "Destinated", "restinate", "destinator", " destined", "destinate", "terminined", " destinated", "termininated", "destinated", "destment", "restination", "decinated", "terminination", "verificate", "Destificate"]}}
{"id1": "810342", "id2": "22875895", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersioncheck", "doVersionscheck", "doDateCheck", "doDateFix", "doDatecheck", "doVersionsFix", "doVersionsUpdate", "DoVersioncheck", "doLicensecheck", "DoDatecheck", "doLicenseCheck", "DoDateFix", "DoVersionCheck", "DoDateUpdate", "doVersionsCheck", "DoDateCheck", "doLicenseFix", "doDateUpdate", "DoVersionUpdate", "DoVersionFix", "doVersionFix", "doVersionUpdate", "doLicenseUpdate"], "view": ["iew", "row", "http", "hl", "update", "table", "document", "engine", "component", "open", "get", "host", "util", "block", "check", "blade", "cell", "client", "this", "buffer", "help", "image", "v", "views", "context", "report", "print", "layout", "call", "doc", "wrapper", "out", "q", "window", "console", "controller", "see", "widget", "View", "page", "tree", "VIEW", "input", "server", "show", "index", "query", "review", "manager", "web", "html", "tv", "cv", "form", "model", "file", "subject", "self", "display", "eye", "browser"], "url": ["pl", "lr", "ur", "bel", "null", "oul", "http", "hl", "link", "b", "path", "github", "ls", "host", "gl", "socket", "address", "id", "client", "v", "uri", "l", "f", "sl", "r", "nl", "log", "rl", "str", "org", "date", "rel", "mount", "location", "language", "ssl", "string", "char", "json", "Url", "web", "ul", "html", "file", "loc", "lb", "ll", "dl", "URL", "browser"], "in": ["gin", "info", " IN", "b", " din", "In", "stream", "cin", "inf", "inn", "ain", "mn", "ins", "rin", "l", "f", "reader", "kin", "inc", "out", "source", "n", "ln", "IN", "init", "isin", "inner", "input", "sin", "din", "body", "asin", "i", "mat", "file", "is", "vin"], "bin": ["gin", "bg", "spin", "binary", "buff", "b", "thin", " din", " bins", "ebin", "bn", "cin", "stock", "mem", "inn", "buffer", "rin", "mon", "by", "reader", "sam", "obin", "conn", "out", "cache", "ln", "cos", "bi", "bl", "local", "win", "bur", "rb", "inner", "lib", "con", "sin", "din", "abin", " Bin", "bed", "pipe", "file", "ran", "len", "loader", "nb"], "line": ["record", "LINE", "row", "column", "err", "link", "sample", "lo", "path", "eline", "range", "ls", "inline", "base", "se", " Line", "block", "ice", "ide", "part", "store", "level", "cell", "Line", "port", "l", "log", "print", "lines", "one", "code", "ln", "no", "cmd", "iter", "cat", "lin", "page", "string", "style", "state", "word", "section", "char", "body", "point", "le", "el", "trace", "frame", "comment", "file", "lane", "channel", "job", "entry", "field", "ine", "text", "chain", "liner", "col", "load"], "version": ["info", "project", "usage", "update", "VER", "vision", "versions", "ion", "VERSION", "key", "ver", "value", "release", "python", "scale", "name", "client", "v", "image", "resource", "sequence", "spec", "serial", "feature", "number", "license", "date", "video", "vers", "test", "language", "volume", "string", "title", "virtual", "position", "iso", "index", "Version", "software", "river", "tag", "hash", "latest", "description", "form", "match", "major", "translation", "format", "type", "status", "command", "browser"], "build": ["make", "full", "project", "install", "other", "update", "binary", "built", "b", "link", "where", "old", "util", "ver", "add", "struct", "be", "release", "building", "use", "unit", "last", "log", "print", "uild", "dist", "th", "date", "test", "round", "builder", "ward", "arch", "dev", "load", "style", "lib", "ble", "work", "Build", "boost", "develop", "tag", "db", "hash", "latest", "fail", "match", "ship", "bug", "bor", "hold"]}}
{"id1": "18238468", "id2": "6421904", "code1": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testLoadSource": [" testloadSourceFile", " testAddFile", "testloadSourceFile", " testLoadSourceFile", " testAddSources", " testLoadSources", "testloadSource", " testloadSource", " testloadSources", "testloadSources", "testLoadSources", " testLoadFile", " testAddSourceFile", " testloadFile", "testLoadFile", "testloadFile", " testAddSource", "testLoadSourceFile"], "metadata": ["info", "m", "details", "ad", "detail", "about", "params", "df", "sample", "document", "managed", "mk", "my", "sheet", "default", "definition", "desc", "valid", "common", "iterator", "activity", "message", "md", "directory", "article", "map", "mt", "primary", "password", "layout", "summary", "content", "report", "wrapper", "payment", "unknown", "license", "still", "basic", "cmd", "met", "dirty", "template", "properties", "pdf", "meta", "tmp", "material", "json", "adata", "manager", "config", "xml", "header", "data", "parser", "policy", "dd"], "inputStream": ["thisView", "formStream", "thisSteam", " inputView", "currentSteam", "dataStream", "loadStore", " inputstream", "currentStreamer", "inputPort", "dataSteam", "InputForm", "formForm", "inputPresent", "loadSteam", "InputView", "inputSteam", "thisStream", " inputPort", "inputStreamer", "inputView", " inputSteam", " inputForm", "loadstream", "loadStream", "inputStore", "currentStream", "InputSteam", "formSteam", "thisPresent", "inputstream", "dataPort", " inputStore", "dataStreamer", "InputStream", "inputForm", "Inputstream", "InputStore", "currentPort", "InputPresent", " inputPresent", " inputStreamer"], "writer": ["editor", "adder", "creator", "storage", "counter", "null", "w", "written", "unsigned", "handler", "WR", "wright", "stream", "worker", "maker", "rew", "wrote", "iterator", "buffer", "riter", "master", "wrapper", "writing", "to", "reader", "write", "out", "temp", "window", "console", "order", "output", "caster", "inner", "string", "operator", "writers", "network", "wire", "writ", "outer", "walker", "manager", "her", "Writer", "woman", "channel", "loader", "event", "builder"], "contents": ["Contodes", " CONTENT", "utfented", " CONTodes", "Contented", "Content", " CONTens", "CONTented", "utfent", " CONTents", "content", " contens", "ContENT", "CONTent", "Contents", " contENT", "contens", "contodes", "Contens", "utfents", "CONTents", "contented", "contENT", " contodes"]}}
{"id1": "1362", "id2": "17083703", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubargeSort", "bubblesSort", "gobblingSort", "bubblesCompare", "gobblingLess", "bubbleCompare", "bubblingSort", "gobbleSort", "bubbleLess", "gobbleCompare", "bubblingCompare", "bubblesLess", "gobbleLess", "bubargeCompare", "bubblingLess", "bubargeLess", "gobblingCompare"], "a": ["aa", "go", "t", "aaa", "ata", "w", "ia", "va", "b", "isa", "z", "c", "ab", "h", "o", "alpha", "na", "ed", "au", "history", "ga", "es", "eas", "A", "list", "p", "v", "ae", "l", "f", "ea", "cache", "out", "ao", "window", "la", "g", "aka", "order", "aaaa", "an", "act", "att", "all", "app", "sa", "area", "ma", "changes", "trace", "el", "as", "apa", "form", "oa", "data", "era", "array", "da", "ap", "am", "ac", "arr"], "swapped": ["snaped", "swap", " swaps", "scaps", "Swaped", " swap", " swaped", " swapping", " snap", "SWap", "stickaps", "waped", "scaped", "snapped", "SWapped", "swaps", "SWaped", " snaped", "Swap", "snapping", " snapped", "wapping", "swaped", "stickaped", "Swapping", "snaps", "wapped", "Swapped", "SWapping", "scapping", "swapping", "stickapped", "waps", " snapping", "stickapping", "scapped"], "i": ["ji", "m", "ci", "u", "t", "im", "in", "phi", "j", "ii", "gi", "gu", "qi", "c", "my", "I", "us", "mi", "ti", "oi", "base", "pi", "it", "di", "ini", "ui", "ind", "zi", "id", "client", "hi", "y", "multi", "ic", "uri", "f", "io", "ai", "x", "iri", "ori", "me", "iu", "bi", "ip", "cli", "init", "origin", "si", "ie", "ij", "ki", "ri", "iso", "index", "sim", "li", "ix", "xi", "ami", "is", "uli", "key", "ei", "chain", "status", "ir"], "tmp": ["perm", "tt", "m", "mut", "cmp", "t", "orig", "attr", "pkg", "my", "mk", "managed", "prefix", "sq", "sp", "obj", "amp", "sam", "temp", "cache", "cur", "emp", "sup", "np", "same", "pre", "test", "txt", "ctx", "etc", "timeout", "td", "xy", "lib", "clip", "nom", "comp", "gm", "db", "tf", "tg", "MP", "mp", "nb", "result"]}}
{"id1": "10445819", "id2": "22552318", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"getReader": ["getRead", "getreader", "getStream", " getStream", "newReader", " getreader", "newreader", " getRead", "GetReader", "GetRead", "Getreader", "newRead", "GetStream", "newStream"], "stream": ["Stream", "row", "feed", "sample", "cont", "engine", "url", "secure", "trans", "ream", "store", "socket", "system", "iterator", "filter", "message", "buffer", "sequence", "list", "port", "resource", "context", "wrapper", "log", "sl", "reader", "sw", "out", "proc", "clean", "window", "console", "st", "user", "metadata", "ssl", "inner", "style", "page", "input", "instance", "present", "body", "pipe", "draw", "form", "data", "channel", "open", "chain", "stack"]}}
{"id1": "23672408", "id2": "22022715", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 0, "substitutes": {"copyIconFiles": ["copyiconfiles", "copyIndexDocuments", "copyIndexFiles", " copyiconImages", "copyiconFiles", "copyiconImages", "copyIconDocuments", "copyIndexfiles", "copyIconImages", "copyIconfiles", "copyiconDocuments", " copyIconDocuments", " copyiconDocuments", " copyIconImages", " copyIconfiles", " copyiconFiles", " copyiconfiles", "copyIndexImages"], "clazz": ["Clazz", "Close", "classe", "CLazz", " plub", "claz", "clus", "pkgashed", "classotted", "crazz", " clbean", "chojure", "classuddy", "scloser", "escazz", " closer", "callaz", "colluster", " clotted", "chace", " clojure", "collazz", " claz", "closer", "plasse", "pkgazz", "descaz", "Clab", "cluddy", "plazz", "plashed", "Clbo", "CLace", "Claz", "classazz", "clab", "callazz", "chotted", "relose", "clotted", "chazz", "clbean", "relab", "escotted", "collotted", "CLbean", "sclazz", "CLoser", "sclbean", "Clace", "relazz", "club", " club", "pkgaz", "relaz", " plaz", "plaz", "craz", "classuster", " clace", "callbo", "sclace", " clus", "descab", " classe", "close", " plus", " cluster", "descazz", "crub", "cluster", "escace", "escojure", "clace", " clashed", " clbo", "crus", " cluddy", "clbo", "pkgasse", " plazz", "callace", "colluddy", "clashed", "descose", "clojure"], "i16": ["pi16", "iri16", "liShort", "ini19", "pi6", "amiShort", "ri157", "i160", "i24", "ri6", "ii160", "ii216", "ami150", "ini24", "ii16", "iri6", "ini216", "iniShort", "i216", "ini2016", "ami6", "ri16", "li16", "ini160", " i216", "ji150", "iri157", " i24", "i6", "pi150", "i2016", " i157", "ii24", "ami16", "pi63", "ami2016", "i150", "li19", "ami63", "i157", "iri2016", "ji16", " i2016", "i19", " i160", "ji6", "i63", "li2016", "ji63", "iShort", "ri2016", " i6", "ini16", "ami19"], "fileType": ["eventList", "iletype", "relationFamily", "webTYPE", "formatValue", "FILEtype", "FILEType", "resourceUnit", " fileUnit", "fieldTYPE", "formType", "relationType", "webDef", "policyType", "policyFamily", "FileName", "relationHandler", "eventTYPE", "viewTYPE", "policyHandler", " filetype", "viewtype", "fileTime", "fieldType", "coreDef", "policyTyp", "coreHandler", "FileType", "fileName", "ilePattern", "coreTyp", " filePattern", " fileList", "formtype", " fileTime", "coreFamily", "relationTyp", "filetype", "coreType", "formName", "issuetype", "issueType", "filePattern", "coreTYPE", "resourceTYPE", "fileFamily", "formatTYPE", "issuePattern", "fileHandler", "treeType", "fileFormat", "fieldTyp", "fileDef", "ileTyp", "FILEName", "webType", "ileType", "formatType", "fileTYPE", "webTyp", "viewType", "eventUnit", "fileTyp", "fieldDef", " fileValue", "Filetype", "formatTime", "treetype", "formattype", "resourceFormat", "fileList", " fileFormat", "eventType", "eventFormat", "webList", "resourceType", "viewValue", "fileValue", " fileTyp", " fileTYPE", "issueTyp", "treeTYPE", "fileUnit", "treeTime"], "desti16": ["destgi16", "destui24", "destsi16", "resulti16", "resultii24", "resulti216", " destsi18", "destxi16", "desti2016", " desti18", "destii16", "desti160", "destsi160", "destxi32", "resulti24", "destui160", "destui16", "resulti2016", "destui32", " desti160", "destxi18", "desti216", "resultii2016", "resultii16", "destsi18", "destgi2016", "destui2016", "destii216", " destsi160", "resultii216", " destsi32", " destsi16", "destsi32", "destui18", "destgi24", "destui216", "destgi216", "desti18", "destii2016", "desti24", "destxi160", "destii24"], "src": ["sit", "bh", "isl", "sc", "cmp", "rob", "hl", "bg", "sel", "ctx", "rc", "cont", "syn", "pkg", "ls", "urg", "desc", "ser", "sq", "sp", "rest", "ins", "bin", "req", "sl", "nl", "iter", "sync", "rl", "cur", "std", "sub", "source", "sol", "gs", "rg", "proc", "scan", "rel", "ln", "st", "ibl", "txt", "rs", "ctr", "sb", "rx", "fc", "etc", "ssl", "inner", "rb", "iv", "sn", "sec", "input", "dest", "usr", "cli", "img", "sr", "tmp", "comp", "via", "ptr", "sys", "cb", "addr", "inst", "loc", "vr", "bc", "obs"], "dst": ["dLcut", "Dnd", "nput", " dmt", "ndsts", "ndest", "dmn", " ddr", "fdr", "dsot", "dddest", "fdest", "fnd", "dsst", "dLot", "tput", "nnd", "ndmt", "dsnet", "dbl", "rdest", "dLnet", "rcut", "dermn", "dmt", "ddnd", "dput", "dcut", " dbl", "dgt", "ddest", "Ddest", "dsts", "Ddr", "dnd", "dLest", " dsts", "derst", " ddest", " dcut", "dLbl", " dput", "tnd", "rdst", "dsest", " dest", "tst", "dest", "fst", "dnet", "rbl", "ngt", " dnd", "nst", "dLst", "ddr", "dernd", "derdest", " dgt", "rdmt", "dLdest", " dmn", "rdsts", "tgt", "ndst", "dot", "Dst", " dnet", "ddst", "ddmn", "rst", " dot"], "i32": ["xi22", "i31", "ini31", "i28", "i48", "ic40", "xi31", "ip31", "pi64", " i40", "ip34", "pi34", "i22", "pi31", "ic342", "i64", "ip64", "ic48", " i64", " i86", "pi32", "ini48", "ii342", "isi32", "i34", "ini32", "xi32", "ip32", "i86", "ic34", "ic64", "isi40", "i342", "isi64", "ic31", "ic22", "ii34", " i342", "ii28", "isi86", "ic32", "i40", "ic28", " i28", "ini22", " i34", "xi48", "ii32", "ic86", " i31"], "desti32": ["desti31", "Desti31", "destpi30", "destic30", "DestI90", "destu256", "destic32", "destu90", "destdi34", "targetpi34", "desti90", "destpi31", "destu32", "destpi34", "targeti34", "DestI256", "destI256", "desti30", "targeti30", "destI90", "targeti31", "destdi32", "DestI31", "targetpi31", "targetpi32", "desti256", "destdi30", "Desti256", "destu31", "desti34", "destdi31", "targetpi30", "destI32", "Desti90", "targeti32", "destpi32", "destic34", "destI31", "DestI32", "destic31", "Desti32"]}}
{"id1": "11005804", "id2": "5723876", "code1": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"kodetu": ["kodoti", "kodettbu", "kodettui", "kodhetu", "kodheti", "kodotu", "kondotu", "kondotui", "kondotbu", "kodotui", "kodetbu", "kodotbu", "kodhetbu", "kondeti", "kodetui", "kodetti", "kodettu", "kodhetui", "kondetu", "kodeti", "kondetbu", "kondoti", "kondetui"], "testusoila": ["testusantla", "testusoilada", "testusofiada", "testusesoilya", "testusoolana", "testusanka", "testusesoolsa", "testusesoola", "testusesoilana", "testusesoilla", "testusankada", "testusanta", "testusyla", "testusantya", "testusylana", "testusoilya", "testusesoolla", "testusoolsa", "testusesoolana", "testusylya", "testusofiana", "testusankana", "testusantana", "testusoola", "testusesoolya", "testusofisa", "testusesoilada", "testusesoilsa", "testusoilla", "testusoolya", "testusesoila", "testusoilsa", "testusanksa", "testusoolada", "testusylla", "testusoolla", "testusofia", "testusoilana", "testusesoolada"], "md": [" ms", " ma", "mod", "m", "ms", " mm", " dd", "med", "det", "pd", "df", "mac", "ld", "mk", "mc", "pm", "nd", "e", "MD", "mem", "ng", "del", "ind", "rm", " m", "dig", "cd", "mn", "mt", "bd", "mb", " mo", "sm", " mc", "mg", "cmd", "dm", "mm", "metadata", "dr", "der", "sha", "material", "ma", "hd", " Md", "mand", "grad", "mp", " cmd", "dd", "d"], "raw": ["full", "hex", "row", " Raw", "w", "unsigned", "aws", "custom", "bare", "base", "value", "aw", "rew", "sh", "available", "mem", "message", "out", " RAW", "clean", "unknown", "n", "buf", "cmd", "good", "pack", "random", "all", "Raw", "input", "cooked", "RAW", "json", "known", "box", "bytes", "data", "rendered", "array", "clear", "human"], "hash": ["hex", "zh", "mac", "ssh", "crypt", "total", "h", "has", "uh", "ash", "unique", "flash", "check", "sh", "id", "name", "password", "print", "cache", "transform", "mask", "proof", "ashes", "sign", "ASH", "random", "sha", "Hash", "index", "sum", "json", "tag", "key", "cert", "shadow", "ho"]}}
{"id1": "18731843", "id2": "21488518", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"doBody": [" sendBody", " sendHead", " doContent", " writebody", "loadContent", " doHead", "loadBody", " writeHead", " sendbody", " writeBody", "loadHead", " writeContent", " sendContent", "loadbody", " dobody"], "req": ["err", "http", "exec", "Requ", "j", "pkg", "wx", "urg", "gr", "quest", "ps", "sq", "q", "request", "proc", "hr", "pro", "js", "res", "rec", "quick", "cmd", "ctx", "def", "conf", "jp", "qt", "query", "inv", "fr", "reg", "requ", "aj", "Request", "tx", "qq", "express", "crit"], "resp": ["ret", "rep", "re", "pos", "err", "http", "Res", "esp", "soc", "trans", "sp", "client", "out", "cl", "wr", "respond", "sol", " res", "rec", "res", "rel", "js", "respons", "output", "exp", "comm", "def", "Response", "next", "Rep", "RES", "wa", "Resp", "vol", "response", "serv", "result"], "bis": ["os", "ads", "bh", "bt", "bie", "lbs", "bs", "bat", "mi", "oi", "lis", "bes", "cin", "ios", "be", "isi", "bps", "iss", "atis", "zo", "fps", "pins", "pin", "bits", "ses", "bid", "los", "mis", "bi", "iris", "nis", "onis", "sb", "lin", "isin", "phis", "ubis", "ris", "inet", "bil", "iso", "rison", "oss", "aus", "is", "ais", "webkit", "avi", "idis", "obs"], "bos": ["fits", "os", "bh", "bs", "oops", "ubs", "eros", "banks", "oi", "asis", "bes", "aos", "ios", "tes", "its", "tis", "uts", "ts", "bo", "vas", "ows", "outs", "mes", "pins", "bits", "gs", "fs", "asket", "los", "bi", "ods", "acs", "BS", "ols", "bin", "oos", "zb", "ubis", "bas", "bil", "jas", "ys", "stones", "oss", "uds", "nos", "is", "dos", "obs"]}}
{"id1": "17901739", "id2": "11562165", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"setMembers": ["getMember", "setmembers", "initmembers", "initMember", " setMethods", "getMethods", " setmembers", "initMethods", "getMembers", "initMembers", "setMethods", "getmembers", "setMember", " setMember"], "url": ["pl", "lr", "ur", "http", "hl", "link", "github", "ref", "open", "ls", "base", "gl", "socket", "address", "client", "connection", "resource", "l", "uri", "f", "sl", "r", "nl", "rl", "conn", "impl", "ssl", "Url", "web", "ul", "file", "ll", "lb", "dl", "loc", "loader", "acl", "URL", "browser"], "reader": ["rot", "row", "older", "http", "in", "read", "handler", "anger", "rar", "upper", "ner", "range", "driver", "stream", "roller", "iterator", "client", "writer", "er", "runner", "resource", "uri", "io", "r", "redo", "rl", "console", "ro", "iter", "Reader", "inner", "file", "reading", "parser", "loader", "ator", "rr", "load"], "buffer": ["buff", "b", "back", "prototype", "block", "reason", "available", "filter", "summary", "background", "profile", "input", "word", "database", "trace", "program", "channel", "display", "stack", "row", "note", "binary", "sample", "expression", "table", "line", "raw", "bb", "report", "print", "password", "queue", "source", "template", "bridge", "body", "html", "bytes", "command", "thread", "memory", "length", "document", "batch", "Buffer", "history", "pause", "buf", "function", "iter", "string", "position", "ob", "initial", "format", "button", "text", "detail", "null", "phrase", "base", "stream", "message", "sequence", "cache", "window", "output", "page", "frame", "comment", "data", "entry", "chain", "vector", "append"], "pattern": ["pretty", "process", "lead", "column", "phrase", " Pattern", "sample", "expression", "variable", "period", "path", "rule", "prefix", "png", "expr", "graph", "system", "client", "p", "ping", "group", "password", "print", "map", "patch", "service", "operation", "pat", "function", "find", "step", "pal", "template", "problem", "def", "operator", "style", "prot", "network", "pdf", "Pattern", "quant", "sharp", "model", "xml", "TERN", "match", "parser", "format", "field", "policy", "entry", "command", "shape", "net"], "matcher": ["Matchers", "matener", "patacher", " matter", "matger", "mutcher", "reger", "matacher", "patatcher", "mither", "reherer", "metatcher", "metporter", "matchacher", "metcher", "matchchers", " matporter", "matchers", "mather", "matched", "mutpatch", "matchatcher", "selectger", "patener", "matatcher", " mather", "matchter", "patterncher", "metver", "patternatcher", "recher", " matifier", "Matatcher", "mitifier", "matchifier", "matifier", "mutchers", " matatcher", "repatch", "Matcher", "tagacher", "patporter", "tagener", "matchener", "patchers", "matchched", "Matter", "matter", "cather", "mutherer", "muther", "catver", "matchcher", "pather", "selectpatch", "patver", "tagcher", "tagter", "Mather", "catter", "matver", "matpatch", "compchers", "matherer", " matver", "compter", "selectcher", "patternher", "matporter", "compcher", "patternched", "Matver", "catcher", "patter", "mutger", "selectherer", "patcher", "patifier", "matchher", "mutifier", "mitcher", " matched", "compatcher", "mitter", "Matifier"], "erg": ["eret", "eric", "ert", "hung", "auc", "erc", "enger", "\u00e9r", "rah", "uber", "igator", "ager", "rog", "og", "eur", "igor", "ivic", "urg", "erd", "jer", "clus", "omer", "ric", "agogue", "ere", "ung", "ERG", "er", "ENG", "ocr", "erm", "org", "ero", "erick", "gae", "sg", "agame", "eh", "arag", "der", "ger", "agog", "eng", "alg", "inal", "eg", "iac", "olog", "reg", "her", "kr", "era", "gent", "mont", "enz", "peror", "ather", "roc", "staff"], "start": ["stop", "back", "get", "enable", "add", "part", "from", "init", "index", "draw", "match", "make", "before", "end", "it", "starting", "ind", "error", "client", "begin", "play", "source", "st", "find", "step", "Start", "art", " Start", "style", "seek", "head", "show", "delay", "max", "key", "open", "result", "starter", "diff", "offset", "range", "pad", "wind", "check", "store", "this", "middle", "fill", "pause", "iter", "position", "kind", "next", "first", "addr", "send", "shift", "close", "top", "base", "started", "valid", "name", "rest", "reset", "seed", "ish", "like", "ify", "window", "set", "origin", "state", "target", "point", "sum", "size", "entry", "handle"], "von": ["vine", "bra", "nie", "endon", "ivan", "oni", "bott", "vil", "mond", "hon", "umen", "son", "viol", "lon", "onder", "zon", "ben", "mun", "mon", "vid", "vi", "irin", "van", "vard", "ston", "ona", "avan", "ln", "onis", "ley", "leen", "innie", "don", "melon", "ano", "tan", "john", "iann", "rison", "den", "jen", "vati", "mont", "san", "ideon", "ldon", "vette", "mint", "ton", "aven", "vin", "won"], "bis": ["rots", "lie", "bra", "non", "pos", "bs", "bat", "vs", "oi", "ls", "lis", "bes", "cin", "prefix", "its", "tis", "udi", "lon", "ben", "fps", "zon", "beta", "zo", "mes", "pins", "mos", "bits", "nes", "bles", "bid", "js", "fs", "mis", "los", "onis", " bos", "nis", "bi", "ni", "vy", "iter", "alli", "isin", "inter", "xy", "phis", "bos", "jin", "ris", "bil", "rison", "ennis", "oss", "ends", "fr", "south", "antis", "eni", "is", "ldon", "cos", "dos", "fin", "idis", "obs"], "m_strComponents": ["m_strcomponents", "m_intcompages", "m_strPackors", "m_strcompors", "m_strCompors", "m_strMessages", "m_brChonents", "m_intCompors", "m_brCompances", "m_brChorts", "m_strCompances", "m_strcomports", "m_strChors", "m_brChors", "m_strMessorts", "m_strCommors", "m_strPackances", "m_strCommorts", "m_strcompages", "m_strChonents", "m_brChances", "m_strContorts", "m_intcomports", "m_strMessors", "m_strMessonents", "m_strChorts", "m_strCommances", "m_brComports", "m_strComports", "m_intComports", "m_brComponents", "m_strCompages", "m_intComponents", "m_strPackonents", "m_strContors", "m_brCompors", "m_intCompages", "m_strContonents", "m_intcompors", "m_strPackorts", "m_intcomponents", "m_strCommonents", "m_strChances", "m_strContages"], "m_strPriorities": ["m_stringPriority", "m_strPriorifiers", "m_strRankifiers", "m_stringPriorifiers", "m_strPriority", "m_strRankies", "m_strSpecificitives", "m_strPrefings", "m_strPosities", "m_strSpecificity", "m_strPerites", "m_strPosity", "m_strPosings", "m_stringPriorings", "m_strRankings", "m_strPerities", "m_strRankities", "m_strPrefifiers", "m_stringPositives", "m_stringPriorites", "m_strPriorings", "m_strPosies", "m_stringPrioritives", "m_strPrefities", "m_strPrefies", "m_stringPosifiers", "m_strPosifiers", "m_stringPosies", "m_strPositives", "m_strPeritives", "m_strPriorites", "m_strPosites", "m_strSpecificites", "m_stringPosity", "m_stringPosings", "m_stringPosities", "m_stringPriorities", "m_stringPriories", "m_strPriories", "m_stringPosites", "m_strPrioritives", "m_strSpecificities", "m_strPerity"]}}
{"id1": "13644374", "id2": "4982745", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getBytesForPath", "getBytesfromUrl", "getBytesFromPage", "getBytesForPage", "getBytesFormUrl", "getBytesFromPath", "getByteFromUrl", "getBytesFormURL", "getByteFromPath", "getByteFormPath", "getBytesFormPage", "getBytesfromPath", "getBytesForUrl", "getByteFromURL", "getBytesForURL", "getByteFormPage", "getBytesfromPage", "getByteFormURL", "getByteFromPage", "getBytesFormPath", "getBytesfromURL", "getByteFormUrl", "getBytesFromURL"], "url": ["full", "pl", "domain", "ur", "http", "parse", "link", "https", "path", "ref", "ls", "host", "base", "default", "build", "address", "name", "id", "uri", "l", "sl", "nl", "str", "res", "rect", "location", "string", "page", "pattern", "Url", "web", "html", "el", "ul", "xml", "loc", "ll", "dl", "URL"], "get": ["full", "send", "http", "exec", "read", "parse", "give", "ge", "GET", "check", "Get", "build", "let", "this", "got", "post", "call", "service", "put", "request", "play", "like", "select", "g", "pre", "set", "find", "create", "pull", "search", "body", "show", "query", "gets", "download", "we", "load"], "response": ["answer", "that", "successful", "pos", "http", "resp", "document", "object", "onse", "soc", "success", "version", "block", "client", "message", "connection", "image", "resource", "yes", "post", "content", "service", "request", "respond", "still", "application", "res", "respons", "output", "given", "page", "tree", "reply", "Response", "body", "next", "json", "entry", "open", "status", "result"], "entity": ["record", "info", "eme", "person", "note", "email", "ee", "total", "document", "security", "object", "component", "base", "se", "line", "unique", "peer", "ce", "icon", "activity", "client", "image", "resource", "obj", "unit", "group", "content", "member", "put", "one", "me", "em", "pe", "user", "encrypted", "result", "and", "instance", "body", "iso", "le", "json", "Entity", "el", "comment", "model", "data", "form", "entry", "type", "ent", "ity", "event", "load", "any"]}}
{"id1": "14324112", "id2": "15645004", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"innerProcess": ["innerSelect", " innerprocess", "inlineProcess", "originalRender", "inlineRender", "originalSelect", "originalProcess", "originalprocess", "inlineprocess", " innerRender", "inlineSelect", "innerRender", "innerprocess", " innerSelect"], "curi": ["lcphi", "lcvoid", "cdui", "cathtml", "ctumi", "couni", "ctri", "acumi", "cdumi", "Ciri", "crudi", "lcudi", "acuri", "mcumi", "lri", "crui", "wdu", "uncdu", "cdu", "luri", "cumi", "lcuri", "diri", "cdurl", "ctdu", "caddress", "Curi", "wri", " cdu", "Caddress", "lcui", "mcuni", "cvoid", "cruri", "Cdu", " cudi", "cuni", "rcui", "Curl", "Cui", " curl", "mciri", "cduri", "chtml", " cri", "coumi", "duri", " couri", "cudi", " caddress", "cphi", "coury", " citi", "catumi", "mcuri", "ctui", "covoid", "couri", "lcury", "uncri", "rcuri", "liri", "lcri", "curl", "uncaddress", "mchtml", "acuni", "citi", "Couri", "achtml", "catphi", "wiri", "cri", "crdu", "cturi", "cdri", "cui", " ciri", "lciti", "cophi", "Cri", "dumi", "ctiri", "cury", "cori", "catuni", "caturi", "durl", "wuri", "catvoid", "catury", " cumi", "ctiti", "Cumi", " cui", "Cuni", "lcdu", "acri", "rcouri", "uncuri", "rcri", "lui", "mcurl", "ciri"], "maxsize": [" maxspace", "minSIZE", " MAXlength", "MAXsize", " MAXsize", "Maxize", "mxsize", "maxnumber", "MAXlength", " maxSIZE", "axlen", "minsize", "maxbytes", "axSIZE", " MAXSize", "Maxbytes", "Maxlen", "MAXnumber", " maxnumber", "mxSIZE", "maxlength", " maxbytes", "MaxSIZE", "MAXSize", "minSize", " maxlength", "axSize", " maxlen", " maxSize", "maxSIZE", "maxize", "maxspace", "maxSize", "mxSize", " MAXnumber", " maxize", "minspace", "axsize", "maxlen", "axize", "Maxsize", "mxspace", "axbytes", "MaxSize"], "regexpr": ["fregexexpr", "congexexpr", "resexpr", "regexpro", "replexpr", "fregdpt", "brecreps", "brecreexpr", "brecreer", "regexpt", "regdpr", "recreps", "resexprop", "replexexpr", "repexpr", "repexPR", "reexexpr", "congexprop", "reexper", "brecrepr", "consexexpr", "fregexper", "rexpro", "reqpr", "repatternvr", "resexrepl", "fregdvr", "bregexexpr", "recreexpr", "regexexpr", "reqer", "repatternpr", "consexpr", "consexprop", "fregexpt", "congexpr", "relyprop", "relyrepl", "reexps", "bregexpr", "regexPR", "bregexer", "frepexPR", "congexrepl", "regdvr", "reqps", "reewprop", "reewexpr", "regexer", "reewpr", "reewrepl", "bregexps", "fregexPR", "fregexpro", "frepexpr", "regexper", "reexer", "rexpr", "fregexpr", "regexrepl", "rexexpr", "regexps", "recrepr", "regexvr", "replexPR", "frepexpro", "repexpro", "repatternper", "rexPR", "reexpt", "repexexpr", "fregexvr", "relyexpr", "frepexexpr", "recreer", "regdpt", "reqexpr", "replexpro", "regdper", "resexexpr", "regexprop", "fregdpr", "reexpr", "consexrepl", "reexvr", "fregdper", "repatternpt", "relypr"], "cs": ["nc", "cn", "ms", "cas", "sc", "gc", "bs", "cms", "c", "unes", "ws", "ls", "css", "ss", "mr", "its", "cc", "sels", "es", "ns", "cp", "CS", "ts", "acts", "ces", "gs", "ats", "cks", "js", "fs", "Cs", "caps", "cf", "ours", "rs", "csv", "acs", "ctr", "ctx", "sts", "ds", "ks", "ics", "ars", "wcs", "ims", "icks", "qs", "ps", "cus"], "digest": ["digse", "shaum", "hashse", "signum", "Digse", "Digested", "ddist", "dester", "digested", "Diger", "signse", "shaest", " diger", "digester", "ddest", "hashester", "digum", "dist", "hashest", "signest", "Digum", "Digist", "diger", "hasher", "ddester", "dest", "signested", " digse", "der", "digist", "dder", "Digest", "Digester", " digester", "shaested", "shase"], "s": ["ms", "less", "os", "t", "w", "b", "j", "simple", "c", "o", "ws", "a", "ss", "h", "ls", "es", "sq", "ns", "v", "p", "ts", "y", "l", "f", "r", "x", "gs", "ats", "n", "js", "str", "S", "fs", "sb", "sts", "string", "ds", "conv", "i", "des", "gets", "strings", "is", "ims", "stats", "text", "qs", "ps"], "m": ["mod", "ms", "t", "w", "b", "c", "span", "h", "mi", "fm", "nm", "arm", "rm", "p", "v", "md", "message", "mt", "l", "f", "r", "M", "sm", "n", "g", "mol", "em", "dm", "mm", "gm", "i", "mat", "cm", "vm", "ym", "tm", "model", "match", "mo", "mr", "d"]}}
{"id1": "539195", "id2": "2511579", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"copy": ["upload", "link", "gc", "dump", "Copy", "ls", "delete", "cp", " cop", "to", "sync", "Cop", "cat", "create", "replace", "csv", "init", " cp", "move", "save", "slice", "transfer", "clone", "println", " Copy", "cop", "download", "load"], "src": ["sit", "rt", "sc", "orig", "in", "sel", "attr", "rc", "pkg", "url", "ls", "urg", "host", "desc", "ser", "sq", "this", "ins", "spec", "uri", "req", "spr", "rl", "cur", "dist", "source", "str", "rel", "st", "txt", "from", "start", "sb", "rx", "init", "ctr", "rs", "iv", "imp", "input", "sec", "usr", "sin", "img", "sr", "comp", "pres", "sys", "addr", "Source", "inst", "loc", "ident", "filename"], "dest": ["orig", "d", "Dest", "gt", "opt", "https", "cont", "end", "it", "trans", "mem", "home", "way", "decl", "id", "p", "rest", "master", "deg", "req", "temp", "dist", "source", "sup", "test", "st", "cat", "exp", "origin", "them", "usr", "tmp", "target", "nom", "nw", "loc", "est", "dir", "del"], "ifp": ["ibsp", "Ifcp", " ife", " ifop", "ifpc", "ifttp", "ifsp", "ifop", " ifcp", "ibpa", "Ife", "ihe", "iftpc", "ifcp", "alftp", "alfpp", " ifsp", "Ifop", "ffpa", "alfp", "alfpc", "ify", "ffsp", "ihp", "Ifp", "afp", "iftpp", "ihcp", "ibp", "ife", "ifpa", "iftp", "ffy", "ifpp", "aftp", " ify", " ifpa", "ihop", "ffp", "iby", "afpc", "afpp"], "ofp": ["ofd", "orfproc", "ofsp", "OFP", "orfp", "OFp", " ofd", "offjp", "OFd", "ofP", "Ofjp", "orfd", "Ofd", "offd", "Ofsp", "offp", " ofsp", "Ofproc", " ofproc", "Ofp", "ofproc", "OfP", "offP", "OFjp", "ofjp", "orfsp"], "fis": ["Fais", "Fos", "gi", " fai", "fiiss", "flis", "fai", "gis", "wi", "gais", "Fai", "fliss", "fiss", "fais", "flai", "fiist", "wiss", " fiss", "giss", "fios", "fiis", "fist", "Fiss", "wis", "flais", "Fist", " fist", "Fis", " fais", "fi", " fi", "wais"], "fos": ["fiaos", "wios", "foes", "Fos", " foes", "flis", "woses", "flos", "Foes", " fios", "wos", "floes", "waos", "fioes", "woss", "flaos", "flios", "Foss", " foses", "Foses", "fios", "faos", " foss", "fiis", "foss", "foses", "woes", " faos"], "b": ["bar", "bg", "wb", "z", "binary", "bs", "j", "ab", "bit", "h", "ch", "reb", "batch", "base", "be", "bb", "fb", "B", "v", "p", "y", "pb", "l", "f", "k", "bd", "mb", "bits", "blue", "gb", "g", "bi", "eb", "sb", "rb", "lib", "br", "body", "db", "ob", "cb", "bis", "nb", "bc", "d"]}}
{"id1": "1180878", "id2": "20619879", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchStringdata", "fectUrldata", "fetchUrlStream", "fetchStringStream", "fetchURLFrame", "fectUrlStream", "fetchURLStream", "fetchGETdata", "fectURLFrame", "fectURLStream", "fectUrlData", "fectURLdata", "fetchGETFrame", "fectUrlFrame", "fetchStringFrame", "fetchURLdata", "fectURLData", "fetchUrldata", "fetchGETData", "fetchUrlFrame", "fetchGETStream", "fetchUrlData", "fetchStringData"], "url": ["full", "pl", "domain", "sql", "ur", "null", "http", "link", "b", "https", "path", "ref", "ls", "host", "base", "default", "lim", "gl", "address", "name", "resource", "uri", "l", "log", "sl", "print", "nl", "cl", "rel", "mount", "location", "ssl", "string", "pattern", "Url", "mail", "web", "html", "ul", "el", "xml", "file", "loc", "dl", "ll", "URL"], "proxyHost": ["proxyUrl", "slaveLabel", " proxyCheck", "roxyOver", "serverHost", " proxyOver", "slaveAddress", " proxyhost", "serverName", "proxyOver", "roxyhost", "Proxyhost", "proxyLabel", "roxyHost", "proxyhost", "ProxyHost", "roxyLabel", "ProxyPort", "roxyCheck", "roxyUrl", "roxyAddress", "ProxyLabel", "proxyName", "ProxyName", " proxyAddress", " proxyName", "slaveCheck", "slaveUrl", "ProxyUrl", "proxyAddress", "serverhost", "slavehost", "proxyCheck", "serverPort", "slaveHost", "slaveOver"], "proxyPort": ["serverport", "aliasAddress", "Proxyport", "aliasHost", "serverHost", "aliasport", "ProxyHost", "ProxyPort", " proxyport", "serverPORT", "proxyport", " proxyAddress", " proxyPORT", "proxyPORT", "serverAddress", "ProxyPORT", "proxyAddress", "aliasPort", "serverPort"], "con": ["nc", "non", "cn", "go", "dial", "po", "close", "cal", "c", "un", "cont", "gate", "pen", "xc", "mc", "syn", "open", "ver", "cone", "func", "trans", "pan", "cc", "ocon", "Con", "cp", "cond", "cover", "client", "connection", "cs", "bo", "ain", "can", "call", "conn", "cur", "Conn", "sub", "proc", "rec", "ln", "cf", "cmd", "cat", "fc", "ex", "pc", "act", "en", "comm", "conf", "don", "conv", "com", "CON", "fac", "connect", "canon", "col", "co", "cgi", "ran", "lock", "mo", "cons", "cos", "bc", "fin", "ctrl", "const"], "is": ["was", "os", "ms", "sis", "isl", "im", "eps", "in", "bs", "us", "ios", "lis", "has", "its", "isi", "isc", "es", "ps", "iss", "ists", "cs", "ts", "ains", "isp", "ins", "s", "isf", "bits", "ois", "dis", "fs", "mis", "ist", "iris", "iter", "ip", "rs", "init", "isin", "si", "ri", "ris", "ys", "iso", "xs", "oss", "i", "abs", "sys", "as", "Is", "IS", "gets", "ais", "ims", "bis", "isa", "are"], "u": ["ur", "mu", "un", "c", "us", "ut", "o", "pu", "up", "su", "lu", "au", "ui", "uv", "uf", "hu", "uri", "uu", "yu", "fu", "g", "tu", "nu", "iu", "U", "ru", "uid", "user", "uj", " nu", "cu", "ou", "i", "ul", "eu", "uni", "ue", "ud", "bu"], "proxy": ["shadow", "project", "echo", "go", "domain", "cas", "null", " proxies", "zip", "po", "PRO", "http", "link", "https", "host", "base", "cone", "pi", "Proxy", "version", "XY", "socket", "cp", "phone", "slave", "address", "client", "connection", "port", "bo", "ping", "map", "password", "library", "pin", "pointer", "cache", "pro", "x", "pre", "pe", "aco", "profile", "ip", "timeout", "ssl", "alias", "xy", "token", "jp", "server", "gp", "pipe", "pse", "prime", "embed", "web", "friend", "via", "roxy", "pool", "py", "translation", "policy", " prox", "browser"], "baos": [" bao", "naos", "BAo", "BAos", " baows", " baOS", "baows", "poos", "nao", "vaos", "aoos", " baose", "BAOs", "vaoS", " baoss", "baoss", " baOs", "bao", "aoOS", "vaOS", "poOs", "vais", "poo", " bais", "baose", " baoS", "aois", "BAoss", "BAose", "baOs", "poose", "naoss", "naows", "BAows", "aooS", "bais", "baoS", "baOS"]}}
{"id1": "7872659", "id2": "23532405", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndVideoIndexFiles", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndVideoindexfile", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndVideoindexTable"], "completePath": ["completeDir", " completesLocation", "totalPod", "CompleteLocation", " completesDirectory", "COMPLEScript", " completeDirectory", "CompleteDirectory", "fullPod", "completeScript", "CompleteProject", "pletionPath", "totalRoot", "completePod", "completeProject", "completeNow", "COMPLEDir", "COMPLEPath", "pleteScript", " completeDir", "fullPath", "pleteNow", "CompletePath", "CompleteLog", "fullRoot", "totalLocation", "completeRoot", "pleteProject", "pletionProject", "pletePath", "pleteLog", "CompleteDir", "completeLocation", "pletePod", "totalPath", "CompleteNow", "pletionNow", "pletionDir", "completeLog", " completeLocation", "pleteDir", "completeDirectory", "fullLocation", "pleteLocation", " completesDir", "pleteRoot", " completesPath", "CompleteScript", "COMPLELog"], "masterFile": ["managerfile", " masterFilename", "managerFilename", "currentFile", "MasterFile", "masterPath", "masterName", "managerPath", "MasterFilename", " masterPath", " masterfile", "MasterPath", "completeName", "managerFile", "currentName", "completeFile", "masterfile", "masterFilename", "Masterfile", "currentfile", "currentPath", "MasterName", "completefile"], "CustRatingFileName": ["CustRatingFileNames", "CustRatingFilenameName", "CustRatingFilenameType", "CustRatingTablename", "CustRatingFileType", "CustRatedFileNames", "CustRankFilename", "CustRankFilesname", "CustRatingTableName", "CustRankFileInfo", "CustRankFilesInfo", "CustRatedfileName", "CustRatedFileName", "CustRatedFileSet", "CustRatingfileSet", "CustRatingfileName", "CustRatingFilenameSet", "CustRatingfileNames", "CustRankFilesName", "CustRankFileType", "CustRatingFileInfo", "CustRankFileName", "CustRatingFieldInfo", "CustRatingTableType", "CustRatedfileNames", "CustRatingTableSet", "CustRatingTableInfo", "CustRatingFilename", "CustRatingFilesInfo", "CustRatingFieldName", "CustRatingFieldType", "CustRatingFieldname", "CustRatingFileSet", "CustRatingfileType", "CustRatedFileType", "CustRatedfileType", "CustRatedfileSet", "CustRatingFilesname", "CustRatingTableNames", "CustRankFilesType", "CustRatingFilenameNames", "CustRatingFilesType", "CustRatingFilesName"], "MovieIndexFileName": ["MovieindexfileNumber", "MovieindexFileKey", "MovieIndexfileType", "MovieIndexTableName", "MovieIndexFieldKey", "MovieindexFileType", "MovieIndexFILENumber", "MovieindexFileName", "MovieIndexTableNames", "MovieIndexFieldName", "MovieIndexTableType", "MovieIndexFileKey", "MovieIndexFileType", "MovieIndexFileNumber", "MovieIndexFILEType", "MovieindexFileNames", "MovieIndexFieldType", "MovieIndexFileNames", "MovieindexfileName", "MovieindexfileNames", "MovieIndexFILEName", "MovieIndexTableKey", "MovieindexFileNumber", "MovieIndexfileNames", "MovieIndexFILENames", "MovieIndexfileKey", "MovieindexfileKey", "MovieIndexFieldNames", "MovieIndexfileName", "MovieindexfileType", "MovieIndexfileNumber"], "inFile": [" infile", "localFILE", "localFile", "localfile", "inFILE", "INFile", "outFile", "localC", "INC", "INfile", "INF", "outfile", "infile", "INFILE", "outC", " inFILE", "inF", "outF", " inF"], "inC": ["iR", " inCS", "outG", "outCL", "outFile", "inCI", "inputC", " outC", "intCI", " inR", "iCI", " outL", "inL", " inL", "intR", "iC", "inG", " inCL", "inCL", "iCS", " outF", " inCI", "inputFile", " outCL", "inputG", "outC", "intC", "intCS", " inG", "inR", "inputF", "inF", "outF", "inCS", "outL", " inF"], "outFile1": ["outputFileOnce", "outChannel1", "outFILE2", "outfile1", " outfile6", " outfile1", "outFile6", "outFileOnce", "outfile6", " outFile6", "outChannelOnce", "outFile0", "outputPageOne", " outfile2", "outPageOne", "outFILE1", "outFileOne", "outfile0", "outPage1", "outputFile9", "outFILE0", "outPageOnce", "outPage0", "outputPage9", "outPage2", "outputPageOnce", "outFILE6", "outChannel9", "outputPage1", "outputFileOne", "outPage9", "outFile9", " outfile0", "outPage6", " outFile0", "outChannelOne", "outputFile1", "outfile2"], "outC1": ["inC3", "outCB1", "outc2", "outR3", "inFile2", "outc1", "inC2", "outCB0", "outROne", "outC3", "outCB3", "inC0", "outPOne", "outFileOne", "outCB2", "outC0", "outR1", "outP1", "outc3", "outCOne", "inC1", "outP2", "outR2", "inFile3", "inCOne", "outc0", "inFileOne", "outP3", "inFile1", "outFile3"], "outFile2": ["exChannel3", "outTable3", "outChannel1", " outFile3", "outfile1", "outTableTwo", "outFile0", "outFile02", "exFile2", "outTable02", "outChannel0", "outfile0", "outTable2", "exChannel1", "outfile2", "exChannel2", "outF2", " outFile02", "outF0", "exChannel0", "outfileTwo", "exFile3", "exFile1", "outChannel3", "exFile0", "outChannel2", " outFileTwo", "outF1", "outFileTwo", "outF3", "outfile3", "outfile02", "outFile3"], "outC2": ["OutR4", "outBTwo", "outR3", "allB22", "outB3", "outS2", "outS22", "outCTwo", "outE4", "OutR1", "OutC1", "OutC3", "outE3", "allC3", "allBTwo", "outC3", "outE2", "OutR2", "allC2", "outE1", "outS3", "outR4", "outB22", "OutR3", "outM3", "outR1", "outSTwo", "outC22", "OutC4", "outM2", "allB2", "outB2", "outC4", "allB3", "outM22", "allC22", "outMTwo", "outR2", "OutC2", "allCTwo"], "fileSize": ["byteSIZE", "baseName", "issueSize", "baseSIZE", "fileSIZE", "fileLength", "FileSize", " fileCount", "issueLength", "baseCount", "fileName", "FileSIZE", " fileName", "FileLength", "baseSize", "fileCount", " fileSIZE", "byteLength", "FileCount", "issueSIZE", "issueName", "byteSize", "byteName", "FileName", " fileLength"], "totalNoDataRows": ["totalNodataRecows", "totalNoDataSloles", "totalNoDataSlocks", "totalNoDataRoles", "totalNodataRecoles", "totalNodataRecocks", "totalNodataRows", "totalNoDataRecues", "totalNoDataSlows", "totalNoDataBoles", "totalNoDataRecoles", "totalNoDataRocks", "totalNoDataBows", "totalNoDataRues", "totalNoDataRecocks", "totalNodataRecues", "totalNoDataBocks", "totalNodataRocks", "totalNoDataRecows", "totalNodataRues", "totalNodataRoles", "totalNoDataBues", "totalNoDataSlues"], "mappedBuffer": ["mapedbuffer", " mappedCounter", " mapperCounter", "MappedBB", " mapperQueue", "mmappingbuffer", "mapedCallback", "matchedQueue", "mapedData", "MapedBuffer", "mressedFB", " mappedCallback", "MappedBuff", "mmappedBuff", "mapperCounter", "mmappingBuff", "mapperbuffer", "mapperBB", " mapedCallback", "MapperBB", "mappingQueue", "mapBuff", "mapedQueue", " mapedBuff", "maphBuffer", "matchedCounter", "mappedCounter", "maphFB", "mapedFB", "mappingbuffer", "mappedCallback", " mappedBuff", "mapBuffer", "mappingBB", "MapedBB", "mmappedBuffer", "mmappedbuffer", "mressedBuffer", " mappedFB", "MapperBuffer", "mappingBuff", "maphCallback", " mappedQueue", "mapedBuff", "mapperBuffer", "mappedQueue", "mmappingBuffer", "MapperBuff", "MapedBuff", "mappedData", "mmappingQueue", " mapperBuffer", "matchedBuff", "mapedBB", "mattedBB", "mattedBuffer", "mattedBuff", "MappedData", "matchedBuffer", " mapedBuffer", "mressedBuff", "mapBB", "mappedbuffer", "mappingBuffer", "mappedBB", "mappedBuff", "mapedBuffer", "mappingCounter", "mappingData", "mressedCallback", "mapperQueue", "mmappedQueue", " mapedFB", "maphBuff", "mappedFB", "mapperBuff", " mapperBuff", "mattedData", "MappedBuffer", "MapedData"], "startIndex": [" startindex", "endIndex", "currentPoint", "Startindex", " startPos", "startPage", "StartPos", "currentIndex", "StartIter", "currentPosition", " startIter", "StartPage", "firstInd", "startindex", "StartPoint", "startPoint", "StartIndex", " startPosition", " startInd", "initPosition", " startPoint", "endIter", "endPage", "firstIndex", "startPosition", "initIndex", "firstPosition", "firstindex", "currentPos", "StartInd", "startInd", "endPosition", " startPage", "StartPosition", "startIter", "startPos", "initindex"], "count": ["info", "process", "counter", "cloud", "length", "total", "c", "amount", "coll", "Count", "batch", "category", "add", "found", "check", "ind", "now", "list", "name", "id", "last", "limit", "call", "depth", "number", "created", "n", "code", "mount", "ount", "order", "user", "find", "ctr", "act", "start", "state", "page", "conf", "con", "core", "current", "continue", "num", "index", "next", "sum", "more", "i", "first", "force", "size", "cast", "max", "type", "status", "result"], "currentMovie": ["currentImage", "activeSpider", " currentHero", " currentMusic", "activePlayer", "currentMedia", "presentImage", "firstDate", "currentDate", "firstMouse", " currentSpider", "primaryHero", "primaryMovie", " currentMouse", "currentVideo", "firstMovie", "primaryVideo", "currentlyMonster", "currentMonster", " currentMonster", "reportedMouse", "currentlyVideo", "currentlyDate", "firstVideo", "reportedImage", "reportedMusic", "currentMusic", " currentMedia", " currentVideo", "presentMusic", " currentImage", "currentHero", "currentlySpider", "currentSpider", "primaryDate", "currentlyHero", "presentHero", "reportedMedia", "firstHero", "firstMonster", "reportedMovie", "currentlyPlayer", "reportedHero", "currentMouse", "activeMovie", "firstMedia", "currentPlayer", "activeVideo", " currentPlayer", "currentlyMovie", "presentMovie"], "movieName": ["httpNAME", "ovieNAME", "filmNAME", "filmType", "monstername", "mpegGroup", " movieNAME", "movieNAME", "movieGroup", "mpegname", "movieType", "httpName", " moviename", "oviename", "filmGroup", "mpegNAME", " movieType", "filmname", "filmName", "Moviename", "ovieName", " movieTitle", "mpegName", "ovieGroup", "monsterNAME", "MovieType", "MovieTitle", "monsterName", "moviename", "movieTitle", "MovieName", "httpname", "filmTitle"], "customer": ["Customer", "customER", "developator", "customity", "developizer", " customER", " customator", "customorder", "ustomER", "Customity", "stickity", "developER", "stickER", "CustomER", "ustomator", "ustomorder", "developer", "customizer", "developity", "developorder", "sticker", "ustomer", " customorder", "stickizer", "customator", "Customizer"], "rating": ["rage", "heading", "testing", "rank", "option", " Rating", "playing", "score", "weight", "reporting", "scale", "error", "rate", "ating", "ping", "ranking", "strength", "setting", "scoring", "term", "card", "boarding", "credit", "user", "having", "core", "Rating", "average", "review", "tag", "rat", "reading", "translation", "format", "type", "saving", "rated", "attribute"], "outBuf1": ["outBufOne", "outBlf2", "outBuf0", "outBuc1", "outBuffy1", "outDuf0", "outBBuff3", "outBufone", "outBurg0", "outBuf11", "outBbufOne", "outRbuf0", "outBbuf0", "outBlf1", "outBoolone", "outBBuff0", "outDuf1", "outBuff1", "outBlf0", "outRbufOne", "outBulpOnce", "outBooll", "outDbuf1", "outBbuf11", "outBbufOnce", "outBool3", "outBuff0", "outBuf64", "outBurg1", "outBlf3", "outBufl", "outBfx3", "outBuf3", "outRbuf5", "outBbuf18", "outDbuf11", "outBucOne", "outBbufone", "outBurg18", "outBuf18", "outBuffyl", "outBuffy18", "outBfx11", "outBulp1", "outRuf3", "outBBuff1", "outBdf3", "outBbuf5", "outBool1", "outRuf5", "outRuf0", "outDbuf0", "outBuffyone", "outRuf1", "outRufOne", "outBdf64", "outBdfOnce", "outBuc0", "outDuf11", "outBfx1", "outBbuf3", "outRbuf1", "outBuc5", "outRbuf3", "outBbuf1", "outBBuff11", "outBuf5", "outBdf1", "outBulp64", "outRuf18", "outBufOnce", "outBfx0", "outRbuf18", "outBuff2", "outBbufl", "outDbuf3", "outBuffy3", "outBuffy0", "outBulp3", "outBuff3", "outDuf3", "outBurg3", "outBbuf64"], "outBuf2": ["outBuf15", "outBbufTwo", "outMbuf2", "outBbuf1", "outBuf42", "outMbuf15", "outBuff4", "outBbuff15", "outBfg02", "outBbuffj", "outBuffyTwo", "outBfx2", "outBuffy02", "outBuffy2", "outBufj", "outFuf4", "outFuf02", "outBuffy4", "outBbuff4", "outFbuf4", "outFbuf2", "outBuffj", "outBfx3", "outBbuf42", "outMuf2", "outBuf3", "outMbuf1", "outBfg4", "outBbuf02", "outBuff2", "outBuf02", "outFufTwo", "outFuf2", "outBuff42", "outBbufj", "outBbuf4", "outBbuff42", "outBfg2", "outFbufTwo", "outBbuf15", "outBufTwo", "outBbuff2", "outFbuf02", "outBfgTwo", "outMuf15", "outBfx1", "outBbuf3", "outBfx15", "outBbuf2", "outBbuff3", "outMuf3", "outBuffy3", "outBbuff1", "outMuf1", "outBuf4", "outBuff3", "outMbuf3", "outBuff1", "outBuffTwo"], "endOfIndexFile": ["endofIndexFiles", "endOFindexFile", "endOfindexLine", "endofindexfile", "endOfIndexLine", "EndFile", "endofIndexTable", "endOFindexLine", "endOfIndLine", "endofindexFile", "endOfIndfile", "endOfIndexfile", "endOFIndexLine", "endOfErrorF", "endOfPositionFile", "endedFile", "endofIndexFile", "endFile", "endOfIndFile", "endofindexFiles", "endOfindexF", "endofIndexF", "endOFIndexFile", "endOfPositionfile", "endOfindexFile", "endOfPositionTable", " endFile", "endOfindexTable", "endOfErrorfile", "endOfErrorFile", "endOFIndexfile", "endOfErrorFiles", "endOfIndexTable", "endofindexF", "endOFindexfile", "endofIndexfile", "endofindexTable", "endOfindexFiles", "endOfPositionFiles", "endOfIndexFiles", "endOfindexfile", "endOfIndexF"]}}
{"id1": "6301863", "id2": "15971794", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"doRawRequest": ["doNativeQuery", "sendRawAction", "sendHttpQuery", "doNativeRequest", "sendHttpCall", "sendRawRequest", "doDirectCall", "doRawQuery", "doDirectQuery", "doHttpAction", "sendRawQuery", "sendHttpRequest", "doHttpQuery", "doHttpRequest", "doDirectRequest", "doNativeCall", "doDirectAction", "sendHttpAction", "doNativeAction", "sendRawCall", "doRawAction", "doHttpCall", "doRawCall"], "postData": ["requestData", "POSTMessage", "PostData", "PostString", " postString", "preBody", " postMessage", "requestBody", "postedData", "PostMessage", "postString", "POSTDATA", "postedMessage", "preDATA", "postedString", "postdata", " postdata", "POSTBody", "preMessage", "postDATA", "requestDATA", "requestMessage", "POSTData", "preData", "postMessage", "posteddata", "postBody", "Postdata"], "url": ["ret", "pl", "re", "bel", "ur", "hl", "http", "link", "ld", "https", "pkg", "ls", "gl", "build", "client", "l", "uri", "sl", "nl", "str", "org", "rel", "mount", "www", "cmd", "google", "ssl", "con", "Url", "web", "mail", "ul", "abs", "addr", "ll", "lb", "loc", "dl", "cert", "URL"], "conn": ["nc", "cn", "exec", "j", "resp", "close", "c", "cont", "syn", "ch", "gn", "ct", "pg", "pas", "cp", "ns", "client", "connection", "l", "cur", "Conn", "iw", "enc", "org", "res", "rel", "cmd", "act", "nec", "pt", "ssl", "comm", "con", "jp", "nt", "com", "conv", "inv", "cb", "connect", "canon", "addr", "col", "sys", "loc", "open", "cert", "fin", "net"], "wr": ["lr", "rw", "wb", "w", "WR", "dx", "wx", "fw", "mk", "tn", "wid", "rew", "wm", "writer", "RW", "r", "spr", "sw", "write", "iw", "hr", "dr", "writ", "kl", "wn", "Wr", "wy", "wer", "fr", "pr", "wt", "kr", "rou", "Writer", "nw", "wk", "vr", "wd", "wp", "mr", "vet"], "rd": ["dd", "rt", "rw", "rob", "rend", "ld", "rc", "rog", "rar", "rand", "mr", "erd", "nd", "RD", "rer", "ra", "r", "reader", "rl", "hr", "rect", "ru", "ro", "rs", "rod", "rx", "cr", "nder", "dr", "rb", "rpm", "ri", "rid", "sr", "pr", "ptr", "fr", "ry", "red", "rn", "rh", "rr", "adr"], "sb": ["bh", "bg", "bt", "RB", "rob", "lbs", "gc", "bs", "bn", "obb", "b", "erb", "bf", "kb", "bps", "bb", "sh", "sq", "sp", "ib", "pb", "bd", "mb", "sf", "sm", "gb", "sd", "bsp", "lp", "sv", "sth", "eb", "sg", "bag", "SB", "zb", "si", "rb", "sa", "bp", "gob", "abs", "ob", "cb", "xb", "lb", "bis", "nb", "bj", "obs"], "line": ["LINE", "row", "phrase", "link", "sample", "stay", "rule", "eline", "inline", "e", "block", "ice", "check", "valid", "list", "name", "cell", "message", "buffer", "Line", "sequence", "l", "log", "print", "nl", "number", "code", "ln", "pe", "stroke", "entity", "lin", "string", "page", "style", "word", "point", "le", "zone", "display", "frame", "comment", "header", "file", "entry", "ine", "label", "text", "chain", "liner"]}}
{"id1": "9996334", "id2": "4531653", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"generateToken": ["generatesString", " GeneratesString", "generatorCode", " GenerateCode", " GenerateString", "generatesCode", "generatesKey", "generatorToken", "generatesToken", "generateKey", "generatorString", "generateString", " GenerateKey", "generatorKey", " GeneratesToken", " GeneratesKey", "generateCode", " GeneratesCode", " GenerateToken"], "code": ["codes", "c", "ode", "close", "component", "e", "value", "reason", "rice", "ce", "error", "name", "address", "message", "sequence", "buffer", "password", "content", "source", "x", "str", "function", "test", "string", "state", "template", "token", "char", "Code", "hash", "html", "data", "response", "hello", "text", "command"], "md": ["mod", "m", "ms", "med", "det", "pd", "df", "amd", "ld", "mk", "dh", "mc", "pm", "add", "nd", "desc", "MD", "di", "ind", "rm", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "de", "cmd", "dm", "mm", "dr", "ds", "pdf", "der", "mat", "hd", "red", "mand", "msg", "mo", "mp", "dd", "d"], "bytes": ["hex", "ms", "words", "binary", "bs", "b", "Bytes", "ents", "versions", "pages", "tes", "its", "raw", "files", "results", "bps", "es", "seconds", "values", "users", "s", "outs", "blocks", "bits", "pieces", "lines", "gs", "gb", "groups", "objects", "vals", "keys", "ds", "unks", "pdf", "steps", "terms", "parts", "latest", "gets", "strings", "classes"]}}
{"id1": "22708533", "id2": "3809087", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": [" copyDocumentAsFile", " copyDocumenttoUrl", " copyDocumentFromURI", " copydocumenttoFile", " copyDocumentFromFile", " copyDocumentToURI", " copyDocumentToFile", " copyDocumentFromURL", " copydocumentToUrl", " copyDocumenttoFile", " copydocumenttoURI", " copydocumentToURI", " copydocumenttoURL", " copyDocumentAsURL", " copyDocumentAsUrl", " copyDocumentFromUrl", " copyDocumentAsURI", " copydocumentToFile", " copyDocumentToUrl", " copyDocumenttoURI", " copydocumentToURL", " copydocumenttoUrl", " copyDocumenttoURL", " copyDocumentToURL"], "file": ["full", "File", "ile", "FILE", "sample", "table", "where", "document", "rule", "path", "default", "base", "valid", "check", "name", "message", "image", "resource", "log", "f", "doc", "source", "local", "from", "origin", "string", "title", "work", "place", "input", "le", "fil", "data", "filename", "command", "attribute"], "target": ["join", "project", "update", "link", "table", "back", "component", "host", "top", "base", "scope", "home", "valid", "this", "arg", "to", "Target", "print", "layout", "source", "window", "select", "rel", "ARGET", "local", "replace", "location", "origin", "dest", "pattern", "template", "alias", "root", "arget", "view", "remote", "result"], "is": ["sis", "ms", "isl", "ci", "im", "bs", "isa", "us", "vs", "mi", "lis", "ios", "has", "it", "its", "ism", "isi", "isc", "tis", "es", "ns", "iss", "ists", "cs", "ains", "ins", "mos", "isf", "bits", "ois", "dis", "fs", "mis", "iris", "nis", "ip", "rs", "isin", "si", "ics", "ri", "\u00eds", "ris", "ys", "iso", "xs", "oss", "i", "isal", "abs", "IS", "Is", "vis", "ais", "ims", "bis", "ir", "est", "obs"], "os": ["Os", "mot", "ms", "ox", "pos", "ros", "eps", "ones", "bs", "oses", "ot", "us", "oin", "o", "asis", "css", "ios", "aos", "osi", "ss", "tes", "none", "ost", "oS", "oes", "es", "ns", "uts", "ts", "ose", "ows", "ins", "mes", "mos", "io", "out", "ori", "los", "acs", "ols", "oos", "ks", "bos", "ops", "oss", "osa", "sys", "des", "nos", "oa", "OS", "bis", "cos", "dos", "ps", "et", "obs"], "url": ["domain", "re", "ur", "t", "http", "link", "https", "ls", "host", "cp", "address", "name", "client", "l", "uri", "f", "r", "nl", "service", "conn", "str", "n", "rel", "mount", "user", "location", "ssl", "con", "char", "Url", "web", "ul", "ll", "channel", "job", "open", "cert", "URL", "net"], "connection": ["t", "opening", "link", "close", "c", "document", "ion", " Connection", "creation", "character", "reference", "cone", "condition", "established", "Connection", "client", "resource", "l", "uri", "pointer", "service", "conn", "number", "n", "still", "application", "using", "con", "position", "network", "database", "relation", "session", "communication", "city", "connect", "description", "closure", "channel", "response", "entry", "generation", "open", "command", "result", "net"]}}
{"id1": "8452134", "id2": "20735941", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"exists": ["comist", "exits", " exits", "Exits", "existies", " exinates", "Exinates", " exies", "comception", "existinates", "existits", "exinates", "exception", "xits", "xception", "extist", "xist", "Exists", "xists", "extception", "exies", "Exies", "extists", "exist", "existists", "comits", "extits", "comists"], "fileToCheck": ["filetoSee", "file2Check", "fileToSee", "pathTOCheck", "fileTOSee", "fileTOcheck", "filetoCheck", "filenameTOcheck", "pathToWatch", "fileTOTest", "filenameTOTest", "pathTOWatch", "file2check", "pathTOSee", "fileTOWatch", "filenameToCheck", "pathTOTest", "fileToTest", "pathToCheck", "pathToSee", "pathToTest", "filenameToTest", "filetoTest", "filenameTocheck", "fileToWatch", "fileTocheck", "file2Test", "filenameTOCheck", "fileTOCheck", "filetoWatch"], "ftp": ["ifttp", "lattp", " ftps", "aftchange", "ldph", "iftphp", "rotl", "ftv", "fabp", " ftph", "fabph", "rotcp", " ftt", "aptcp", "ftm", "ftchange", " ftchange", "aftp", " ftc", "rotchange", "aftv", "ctps", "ftt", "iftcache", "ctcp", " ftcp", "aftc", " ftpl", "ftr", "ftcache", "iftp", "ffc", "latcache", "ftphp", "rotpl", " ftr", "ftl", "latphp", "ldphp", "ldp", "ffp", "cttp", " fttp", "aftpl", "apttp", "ffr", "ldc", "rotm", "aftl", "fttp", "ftps", "rotp", "rotps", "ftc", "aptl", "fabphp", "aftr", " ftphp", "fft", "fabc", "aftt", " ftv", "ftcp", "aptp", "ffv", "afttp", "ctp", "aftm", "ffcp", "ffcache", "ftph", "ftpl", "latp", " ftl", " ftm", "fftp", "aftcp", "rottp", "ffphp"], "found": ["full", "matched", "failed", "initialized", "successful", "finished", "built", "done", "affected", "started", "success", "results", "valid", "count", "ed", "id", "Find", "enabled", "seen", "needed", "out", "created", "killed", "tested", "good", "find", "expected", "search", "printed", "fixed", "result", "installed", "successfully", "index", "checked", " Found", "filled", "elt", "identified", "fd", "loaded", "Found", "sent", "finder", "d"], "reply": ["record", "ret", "answer", "echo", "pop", "link", "close", "zero", "repl", "back", "mi", "onse", "base", "success", "strip", "count", "check", "cor", "error", "message", "post", "ply", "ping", "report", "print", " Reply", "nl", "flag", "sync", "code", "txt", "replace", "state", "push", "conf", "continue", "vote", "notice", "Reply", "index", "next", "embed", "force", "comment", "msg", "match", "py", "response", "len", "nb", "status", "result", "shell"]}}
{"id1": "22879400", "id2": "3024970", "code1": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 0, "substitutes": {"loadAllProperties": ["loadAllPropPro", "loadallProps", "loadallPropertyperties", "loadallPropertyps", "loadAllPropertyPro", "loadAllProPro", "loadAllPropperties", "loadAllPrps", "loadallProPro", "loadallPropertyPro", "loadAllPrPro", "loadAllProps", "loadAllPrperties", "loadAllPropertyps", "loadallProperties", "loadAllPropertyperties", "loadAllPropps"], "resourceName": ["resourceFull", " resourcePath", "resourcePath", "templateName", "propertyNames", " resourceLength", "uriLength", "resourcename", "fileName", "ResourceFull", " resourcename", "Resourcename", "resourceString", " resourceFull", "propertyString", "templateNames", "templateString", "propertyName", "ResourcePath", "uriPath", "fileNames", "propertyname", "ResourceName", "uriName", "ResourceLength", "ResourceNames", "resourceNames", "fileFull", "templatename", "ResourceString", " resourceNames", "resourceLength", "filename"], "classLoader": ["ClassReader", "clLess", "ClassPath", "ClassLess", "fileName", "fileloader", "classReader", "classPath", "classLess", " classPath", "fileLoader", "Classloader", " className", "clLoader", "ClassName", "className", "ClassLoader", "resourceLess", "resourceReader", "resourceloader", "clReader", " classloader", "clloader", "filePath", "resourceLoader", "classloader"], "clToUse": ["clLoUs", "clAsUs", " plTOUsing", " plToUse", " plToRead", "sclToBe", "sclTOLoad", "ClToUs", "cl2Read", "Cltouse", "clToBe", "clTargetLoad", "cltoLoad", " plTOUse", " plToLoad", "clLoUse", "cl2Using", "clReUse", "cltoUs", "clToUSE", "clAsuse", "sclTOuse", "clToRead", "clAsUse", "sclTOUse", "cltoUSE", "clReRead", "clTOLoad", "cltouse", "cltoApply", "sclTouse", "clTargetUse", "clDoUse", "cl2Load", "clReLoad", "CltoApply", "clAsUSE", "ClTouse", "clToUsing", "sclToUse", "CltoUs", "clTargetuse", "clLoUSE", "clTOUse", "CltoUSE", "clToApply", "clToLoad", "clReUsing", "clTouse", "clLouse", "ClToUSE", "clDoApply", "cl2Use", "cltoUse", "clTOBe", "ClToApply", "clTOUsing", "ClToUse", "CltoUse", "clTOuse", "sclToLoad", " plTOLoad", "clToUs", "clTargetBe", "clDouse", "sclTOBe", " plTORead", "cltoBe", "clTORead", " plToUsing"], "properties": ["info", "details", "frames", "packages", "params", "features", "services", "resources", "property", "rows", "results", "its", "states", "ps", "settings", "articles", "values", "p", "items", "prints", "fields", "comments", "pro", "members", "objects", "metadata", "state", "types", "ports", "current", "units", "pdf", "reports", "terms", "changes", "json", "parts", "projects", "perties", "trace", "posts", "beans", "policy", "classes", "options", "prop"], "urls": [" urlls", "Urls", "limls", "nlps", "paths", "pathb", "urlt", "limers", " urlers", "urlb", "urlals", "lls", "urlits", "urlps", "llits", "llls", "URLps", "urlls", "URLt", "nls", "Urlb", "llers", " urlt", "nlt", "URLals", "pathals", "Urlals", "URLb", " urlits", "urlers", "URLs", "lims", "limits", " urlps"], "url": ["pl", "row", "bel", "ur", "http", "link", "il", "path", "ref", "ls", "key", "base", "gl", "address", "name", "resource", "ol", "uri", "l", "f", "sl", "r", "nl", "mb", "rl", "str", "rel", "mount", "att", "ssl", "char", "li", "Url", "ul", "loc", "dl", "ll", "job", "open", "URL"], "is": ["info", "was", "os", "ms", "sis", "isl", "in", "bs", "us", "mi", "ls", "ios", "lis", "has", "its", "isi", "isc", "tis", "es", "iss", "ists", "cs", "isp", "s", "isf", "bits", "ois", "dis", "js", "fs", "still", "mis", "iris", "nis", "ip", "isin", "si", "ris", "iso", "xs", "oss", "i", "as", "Is", "IS", "vis", "gets", "ais", "ims", "bis", "isa"], "con": ["nc", "cn", "dial", "re", "pos", "cal", "c", "un", "syn", "cont", "pen", "ver", "cone", "ct", "Con", "cond", "cover", "connection", "ain", "conn", "cur", "Conn", "ln", "cf", "fc", "win", "bur", "conf", "conv", "com", "CON", "fac", "cm", "connect", "canon", "co", "ran", "open", "cons", "cos", "bc", "ctrl", "const"]}}
{"id1": "1698200", "id2": "17337238", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginBitshare", " loginBitStock", "loginbitShare", " loginbitshare", "loginByteStock", " loginbitStock", " loginBitshare", "loginbitStock", "loginByteShare", "loginBitStock", "loginByteshare", "loginbitshare", " loginbitShare"], "params": ["pretty", "details", "pps", "http", "cms", "services", "points", "pi", "ps", "settings", "cp", "pas", "Par", "p", "pins", "members", "comments", "gs", "param", "caps", "Parameters", "mm", "headers", "rs", "metadata", "keys", "types", "ports", "properties", "photos", "terms", "json", "changes", "ams", "parts", "config", "names", "posts", "hash", "pres", "chains", "parser", "requires", "stats", "options", "acl", "tags", "auth"], "httpclient": ["ttpclient", " httpconnection", "Httpconnection", "httco", "httClient", "httpco", "hyperconnection", "http2", "https2", "httcontroller", "ttpcontroller", " httpClient", "httpcontroller", "httpconnection", " httpcli", "httpsco", "ttpco", "httpClient", "httprequest", "httpsclient", "ttpClient", "httpscli", " http2", "hypercli", "HttpClient", "httclient", "Httpclient", " httprequest", "httpsconnection", "hyperclient", "httpsrequest", "httpcli", "httpscontroller", "httpsClient", "hyper2", "Httprequest"], "httppost": ["httpperom", "httplpost", "httmppost", "httplart", "httplom", "httppom", " httpom", "httmpost", " httpost", "httppop", "httpploster", "httpposter", "httmpart", "httppposter", " httppop", "httphost", "httphoster", "httphpost", "httpoint", "httplop", "httpost", "httpppost", "httpplost", "httpperpost", "httppppost", "httmpop", "httploint", "httpppop", "httpperop", " httpop", " httppom", "httphoint", "httpplop", "httpop", "httposter", "httpom", "httpplpost", "httpppoint", "httpplart", "httpperost", "httpart", " httpppost", "httplost", "httppoint", "httpploint", "httpppart", "httploster", "httppart"], "formparams": ["foremembers", "functionproperties", "formerrors", "formParameters", " formdetails", "formmembers", " formsettings", "condproperties", "batchnames", "formedparams", "batcherrors", "formchanges", "feedParameters", " formproperties", " formmembers", "foreparams", "condsettings", "inputtags", "formederrors", "formparam", "foreargs", "batchparams", "formedtags", "formauthors", "functionparams", " formargs", "formnames", "formargs", "feeddetails", "foresettings", "formednames", "inputerrors", "functionmembers", "inputParameters", "functionargs", "functionchanges", " formchanges", "inputparam", "formdetails", "inputparams", " formauthors", "batchtags", "forenames", " formParameters", "foreauthors", " formparam", "feedparams", "functiondetails", "formsettings", "inputnames", "forechanges", "condparams", "feedparam", "condnames", "foreproperties", "functionauthors", "foredetails", "formproperties", " formnames", "inputdetails", "formtags"], "entity": ["eme", "person", "note", "ee", "empty", "orm", "document", "security", "component", "object", "line", "ce", "quote", "activity", "buffer", "content", "out", "enc", "ew", "em", "user", "profile", "create", "metadata", "ENT", "template", "body", "json", "inv", "Entity", "ITY", "html", "el", "fee", "form", "xml", "comment", "data", "entry", "ell", "ent", "ity", "event"], "httpresponse": ["ttpResponse", "HTTPresp", "HTTPresult", " httpconnection", "HTTPResponse", "procresult", "httpconnection", "procreply", "procresponse", "httpresp", "HTTPconnection", "procResponse", " httpResponse", "HTTPreply", " httpreply", " httpresp", "httpreply", "ttpconnection", "HTTPresponse", " httpresult", "httpResponse", "httpresult", "ttpresp", "ttpresponse"], "it": ["MIT", "IT", "ert", "sit", "t", "im", "il", "ot", "ut", "iz", "mit", "its", "ed", "ind", "v", "ect", "ic", "l", "rit", "al", "st", "you", "iter", "ex", "ip", "act", "ist", "init", "itter", "ite", "ate", "It", "li", "i", "lit", "at", "el", "ul", "itted", "is", "he", "ent", "est", "et"], "escookie": ["ecotton", "isecookie", "eyancel", "ecog", "eycookie", "iseccake", "httpsookie", "occoder", "escog", "Esctrl", "httpsotton", "occookie", "esccake", "ecace", "descookie", "esctrl", "escotton", "escace", "httpsog", "occotton", "occcake", "escoder", "desccookie", "escue", "ecancel", "espace", "eyace", "escancel", "eyookie", "esccookie", "espookie", "Esccookie", "Escue", "occog", "ectrl", "eccake", "espancel", "ecookie", "descue", "ecoder", "httpscookie", "eccookie", "isecoder", "desctrl", "espcookie", "iseccookie", "ecue", "occcookie", "Escookie"]}}
{"id1": "21824901", "id2": "23666867", "code1": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copyExternalResource": ["copyInternalResources", "downloadexternalResource", "copyExternalresource", "copyOptionalresource", "copyexternalresource", "copyOptionalReference", "downloadexternalResources", "copyInternalResource", "downloadexternalReference", "downloadExternalResources", "copyexternalReference", "copyInternalReference", "downloadexternalresource", "copyexternalResource", "downloadExternalresource", "downloadExternalResource", "copyExternalResources", "copyInternalresource", "copyexternalResources", "copyOptionalResource", "downloadExternalReference", "copyOptionalResources", "copyExternalReference"], "sourceFile": [" sourceDir", " sourcePath", " sourcePage", "destPage", "sourceDir", "SourceFilename", "SourceFile", "SourceChain", "srcPath", "srcLine", "ourceFile", "ourceChain", "destLine", "sourcePage", "sourceChain", "sourceLine", "srcFile", "sourcePath", "srcPage", "ourceFilename", "destPath", " sourceChain", " sourceLine", " sourceFilename", "ourceDir", "sourceFilename", "SourceDir"], "destFile": ["Destfile", "optPlace", "srcFILE", "locFILE", "destDir", "DestFile", "destFilename", "destfile", "critDir", "optFile", "locFile", "critfile", "srcPlace", "locPath", "srcPath", "locDir", "optFiles", " destPath", "DestFilename", "DestFiles", " destDir", " destfile", "critFilename", "destFILE", "srcFile", " destPlace", " destFilename", " destFILE", "destPath", "srcfile", "srcFiles", "critFile", "destFiles", "srcDir", "DestDir", "destPlace", " destFiles", "optDir"], "source": ["src", "before", "sql", "less", "in", "update", "sample", "SOURCE", "table", "archive", "component", "back", "score", "se", "stream", "base", "scope", "none", "parent", "check", "store", "ce", "iterator", "use", "address", "connection", "image", "resource", "sequence", "owner", "reader", "iter", "service", "cache", "console", "ource", "from", "create", "start", "local", "init", "origin", "copy", "search", "inner", "style", "ie", "load", "input", "body", "index", "target", "proxy", "query", "session", "force", "Source", "cause", "match", "subject", "channel", "pose", "series", "result", "shell"], "destination": ["compination", "catinated", "potociation", "notinator", "destociation", "Destinator", "compinator", " destuation", "notination", "descinate", " destation", "combinator", "descinator", "catinate", "compation", "catinator", "combinated", " destinator", "destation", "Destation", "destuation", "potination", "descination", "compinated", "catination", "Destination", "descinated", "combination", "Destociation", "notinate", "Destinated", "notinated", "destinator", "destinate", " destinated", "destinated", "potation", "Destuation", "combuation", " destociation", "potinator"]}}
{"id1": "21821404", "id2": "6908537", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public String login() {\n        System.out.println(\"Logging in to LOLA\");\n        try {\n            String data = URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_email(), \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"pw\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_pw(), \"UTF-8\");\n            URL url = new URL(URL_LOLA + FILE_LOGIN);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line, sessid;\n            line = rd.readLine();\n            sessid = get_sessid(line);\n            this.set_session(sessid);\n            wr.close();\n            rd.close();\n            return sessid;\n        } catch (Exception e) {\n            System.out.println(\"Login Error\");\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["getDebugUrl", "downloadWebPages", "getwebPages", "getLivePage", "downloadwebUrl", "downloadWebUrl", "getwebPage", "getDebugPage", "downloadWebpage", "downloadwebpage", "getLivePages", "getDebugpage", "getwebpage", "getWebUrl", "getWebPages", "downloadwebPage", "getDebugPages", "downloadWebPage", "getwebUrl", "getWebpage", "downloadwebPages", "getLivepage", "getLiveUrl"], "urlObj": ["logInfo", "uriobj", " urlOb", "UrlObject", " urlObject", " urlobj", "httpOb", "urlInd", "uriObj", "UrlOnce", "urlOb", "logOb", " urlInfo", "httpObject", "Urlobj", "urlOnce", "uriOnce", "UrlInd", "httpObj", "UrlCtrl", "uriCtrl", "urlobj", " urlInd", "httpInfo", "urlObject", "urlCtrl", "UrlObj", "uriInd", "uriObject", " urlOnce", " urlCtrl", "urlInfo", "logObj", "logObject"], "content": ["read", "empty", "cont", "document", "Content", "equ", "object", "raw", "value", "reason", "ce", "address", "articles", "message", "buffer", "sequence", "context", "article", "wrapper", "layout", "temp", "write", "comments", "source", "clean", "str", "code", "output", "txt", "complete", "page", "load", "string", "template", "title", "section", "continue", "core", "current", "body", "ext", "cm", "html", "comment", "ontent", "data", "header", "view", "response", "format", "display", "text", "command", "result"], "is": ["sis", "err", "c", "se", "isi", "e", "iss", "isf", "by", "rys", "ris", "as", "isa", "net", "was", "ms", "sit", "isl", "where", "lis", "its", "isc", "his", "ists", "out", "ois", "nis", "iso", "web", "Is", "job", "and", "ir", "re", "other", "in", "ot", "or", "sels", "es", "when", "not", "res", "mis", "iris", "isin", "string", "more", "i", "ais", "ians", "os", "were", "a", "ios", "has", "be", "ism", "tis", "id", "name", "s", "being", "does", "ese", "fs", "ire", "ist", "rs", "internet", "ri", "\u00eds", "sys", "IS", "plays", "bis", "chain", "are"], "reader": ["editor", "row", "per", "read", "ocker", "in", "handler", "rar", "anger", "ner", "dra", "iper", "stream", "roller", "ser", "iterator", "buffer", "writer", "er", "runner", "io", "r", "ipper", "ro", "iter", "Reader", "ader", "inner", "dr", "ri", "reading", "file", "parser", "loader", "liner", "rr"], "line": ["record", "LINE", "row", "detail", "column", "email", "link", "sample", "lo", "eline", "range", "inline", "piece", "e", "block", "part", "cell", "message", "Line", "sequence", "l", "print", "nl", "lined", "ln", "stroke", "lin", "string", "page", "word", "section", "char", "zone", "le", "point", "el", "frame", "comment", "online", "file", "lane", "entry", "ine", "label", "text", "liner"]}}
{"id1": "20929570", "id2": "14785308", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"toMd5": ["toMmd512", "toMMD5", "toDm5", "toDdHash", "toMmd5", "toMMD512", "toMm4", "toMmdHash", "toDd4", "toDd5", "toDmHash", "toMmHash", "toMdHash", "toMd512", "toMm512", "toMMD4", "toMd4", "toDm4", "toMMDHash", "toDd512", "toDm512", "toMmd4", "toMm5"], "str": ["t", "w", "in", "utt", "b", "c", "ch", "a", "it", "Str", "e", "sp", "name", "this", "p", "v", "obj", "s", "print", "r", "out", "enc", "wr", "n", "st", "txt", "ctr", "cr", "string", "input", "char", "br", "data", "msg", "text", "STR", "arr"], "messageDigest": [" messageDiger", "applicationDigester", "Messagedigester", "messageDigse", "MessageDiger", "messageDigested", "messageDecester", "messageDesignests", "messageDigert", "messagedigested", " messageDert", "messageDecse", "messagedigester", "messageDigEST", "MessageDigEST", "MessagedigEST", "messageDse", "applicationdigested", "messagediger", "messageDert", "messagedigests", "Messagediger", "Messagedigests", "messageDecests", "messageDefer", "MessageDigse", "messageDigester", "messageDester", "messageDesignested", " messageDigester", "applicationDigse", "applicationDigest", "Messagedigse", "MessageDigests", "messageDesignse", "messageDefester", "messageDesignest", "messageDecest", " messageDigse", "applicationdigest", " messageDester", "applicationdigse", "messageDiger", "messagemdse", "MessageDigest", " messageDest", "messageDefist", "messagemdest", " messageDigist", "messageDigests", "messagedigest", "messageDefEST", "messagemdert", " messageDigert", "messagedigse", "applicationdigester", "messagedigert", "messageDesignester", "messagedigEST", "messageDecested", "Messagedigest", "messagedigist", "MessageDigester", "messageDigist", "messagemdester", "messageDefest", " messageDse", "messageDest", "applicationDigested"], "byteArray": ["resourceBuffer", "resourceStream", "basicBuffer", "fieldLength", "viewArray", "seBuffer", " byteBuffer", "basicArray", "basicString", "bytearray", " byteStream", "viewStream", "helloArray", "byteStream", "byteAddress", "bytesArray", "bytesRAY", "entityarray", "basicAddress", "byteList", " bytearray", " byteList", "byteLength", "helloBuffer", "byteString", "seArray", "basicList", " byteRAY", "bytesString", "fieldArray", " byteLength", "resourceArray", " byteAddress", "bytesLength", "byteRAY", "byteBuffer", "entityArray", "basicarray", "entityList", " byteString", "viewBuffer", "fieldRAY", "bytesAddress", "entityBuffer"], "md5StrBuff": ["md4StrPref", "md5StrCop", "md8StrBuff", "md5StrPref", "md5StBuff", "md5RatComp", "md5ObjVert", "md5TextComp", "md5StrBuffer", "md65StrBuffer", "md7StrBuff", "md5strBuffer", "md5BuffBuff", "md5strComp", "md5StringBuff", "md65TextComp", "md5strbuff", "md5strVert", "md5StringBu", "md5ObjComp", "md65TextBuffer", "md5StringCop", "md7StrBu", "md8StrComp", "md5RatBuff", "md65StrCop", "md5Strbuff", "md5StrDb", "md5StPref", "md5StringDb", "md7Strbuff", "md5StrBu", "md5StringPref", "md4StringDb", "md5StCop", "md4StrBuff", "md4StringBuff", "md4StrDb", "md7StringBu", "md7Stringbuff", "md5strBuff", "md5strBu", "md8RatBuff", "md5BuffDb", "md5ObjBuff", "md5Stringbuff", "md4Stringbuff", "md5StComp", "md5StBuffer", "md5TextCop", "md5RatBuffer", "md5StBu", "md5Stbuff", "md7StrPref", "md5RatVert", "md4Strbuff", "md5TextBuff", "md65TextCop", "md65StrComp", "md5StringBuffer", "md65TextBuff", "md65StrBuff", "md8RatBuffer", "md5BuffPref", "md5TextBuffer", "md8RatComp", "md8StrVert", "md5StringComp", "md5Buffbuff", "md8StrBuffer", "md5strDb", "md8RatVert", "md4StringPref", "md7StringPref", "md5StrComp", "md5StrVert", "md7StringBuff", "md5strPref", "md5ObjBuffer"], "i": ["info", "ji", "m", "go", "u", "ci", "t", "im", "in", "phi", "j", "gi", "ii", "gu", "c", "my", "I", "us", "mi", "h", "a", "batch", "o", "ti", "pi", "it", "e", "di", "ini", "ui", "ind", "hi", "list", "y", "v", "multi", "s", "ic", "uri", "l", "io", "ai", "q", "x", "n", "me", "iu", "bi", "ex", "ip", "cli", "si", "ki", "conv", "index", "slice", "json", "li", "ix", "gravity", "xi", "is", "cgi", "ei", "chain", "status", "major"]}}
{"id1": "19739421", "id2": "19251426", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownParameterClass", " UnknownOptionClass", " UnknownCommandException", " UnknownCommandHandler", "UnknownCommandError", "UnknownFormatException", " UnknownOptionHandler", "UnknownOptionClass", "UnknownOptionError", " UnknownCommandError", "UnknownOptionHandler", "UnknownParameterHandler", "UnknownParameterError", " UnknownOptionError", "UnknownParameterException", "UnknownCommandHandler", "UnknownFormatHandler", "UnknownCommandException", "UnknownCommandClass", "UnknownFormatClass", "UnknownFormatError", " UnknownCommandClass"], "cmdLineParser": ["cmdLBuilder", " cmdPageBuilder", "mdlineParser", "CmdlineBuilder", "CmdLineProvider", "cmdlineHandler", "cmdPageBuilder", "commandlineParser", "mdlineOptions", "cmdPageParser", "CmdLineReader", "commandlineReader", "cmdLineReader", "cmdlineLoader", "cmdFrameReader", "cmdFramePers", "commandLineBuilder", "cmdNetParser", "commandLineRunner", " cmdPageParser", "cmdlineStreamer", "cmdNetStreamer", "mdlineStreamer", "mdlineHandler", "cmdChainReader", "commandlineProvider", "cmdFrameParser", "commandlineRunner", "cmdlineParser", "CmdlineReader", "cmdListparser", "mdlineparser", " cmdPageReader", "cmdListBuilder", "mdLineReader", "commandlineBuilder", "cmdListParser", "mdlineReader", "cmdChainParser", "cmdBlockParser", "commandlinePers", "cmdLParser", "mdLineLoader", " cmdLineBuilder", "cmdChainarser", "mdLineBuilder", "cmdBlockHandler", "cmdlineReader", "cmdLinePers", "cmdlinearser", "cmdSetReader", "cmdLineProvider", "mdlineLoader", "cmdlineOptions", "cmdBlockReader", "cmdListReader", "cmdLineBuilder", "mdLineOptions", "cmdlineProvider", "cmdlineRunner", "cmdBlockOptions", "cmdlineparser", "cmdNetHandler", "commandLineReader", "cmdLineRunner", "mdLineHandler", "cmdLineLoader", "cmdChainLoader", "cmdPageReader", "cmdLineparser", "mdlineBuilder", "cmdFrameRunner", "commandLineProvider", "cmdLineHandler", "cmdlinePers", "mdlinearser", "cmdBlockProvider", "cmdSetparser", "CmdlineParser", "cmdBlockBuilder", "cmdLineStreamer", "CmdLineBuilder", "commandLinePers", "mdLineparser", "cmdLOptions", "mdLineParser", " cmdLineReader", "commandLineParser", "cmdLineOptions", "mdLinearser", "cmdLHandler", "cmdlineBuilder", "cmdLinearser", "cmdNetReader", "cmdPageProvider", "CmdlineProvider", "cmdSetParser", "mdLineStreamer", "cmdSetBuilder", "CmdLineParser"], "formatOption": ["filterOption", "formatEntry", "transformOption", "FormatOperation", "FormatOption", "filterEntry", " formatOptions", "formatOperation", "FormatOptions", " formatEntry", " formatOperation", "transformEntry", "transformOperation", "formatOptions", "transformOptions"], "outputEncodingOption": ["outputencappingOption", "outputencodingoption", "outputEncappingOption", "outputEncodingoption", "outputEncgingOption", "outputencachingOption", "outputEncamingOption", "outputEncamingOptions", "outputEncgingoption", "outputEncodingOptions", "outputencappingoption", "outputencachingOptions", "outputEncachingOption", "outputEncappingOptional", "outputEncamingOptional", "outputEncamingoption", "outputencachingOptional", "outputEncgingOptional", "outputencodingOptions", "outputEncachingOptions", "outputencodingOptional", "outputencodingOption", "outputEncachingOptional", "outputEncodingOptional", "outputencappingOptional", "outputEncappingoption", "outputEncappingOptions"], "inputEncodingOption": ["inputEncachingOptional", "inputEncappingAttribute", "inputEncappingOptional", "inputEncappingOption", "inputCodingOptional", "inputenclingAttribute", "inputenclingOption", "inputEncappingOptions", "inputEncordingoption", "inputEncodingOptional", "inputEnclingOptions", "inputEncachingOptions", "inputEnclingoption", "inputEncordingOption", "inputEncachingOption", "inputEncendingOptional", "inputCodingOptions", "inputencodingOption", "inputCachingOptions", "inputEnclingOption", "inputEncendingOptions", "inputenclingOptions", "inputEncodingAttribute", "inputenclingoption", "inputEncappingoption", "inputEncordingAttribute", "inputencodingoption", "inputencodingAttribute", "inputCachingOption", "inputEncordingOptions", "inputCachingOptional", "inputEncendingOption", "inputEncodingoption", "inputEnclingAttribute", "inputEncodingOptions", "inputCodingOption", "inputencodingOptions"], "format": ["pretty", "join", "what", "api", "module", "note", "parse", "Format", "tif", "table", "option", "get", "prefix", "pi", "it", "version", "sort", "scale", "filter", "use", "name", "fix", "error", "unit", "print", "f", "layout", "with", "transform", "term", "license", "source", "method", "output", "set", "language", "title", "string", "pattern", "template", "style", "export", "printf", "config", "at", "force", "form", "file", "type", "policy", "display", "filename", "status", "command", "accept"], "outputEncoding": ["responseEncryption", "outputDecling", "currentEncaching", "outputEngling", "outputEngacing", "currentEnaching", "outputEngaling", "publicEncaging", " outputEncacing", "outputCompryption", "outputencoding", " outputEncryption", "outputEncaling", "responseEncalling", " outputDecining", "outputencording", "publicEncoding", "outputEncording", "outputEncging", "currentEncling", "outputMessining", " outputEngoder", "outputEncaging", "outputencaging", "outputEngging", "outputEncling", "outputEnoding", "outputencling", "outputEnling", "outputDecalling", "outputEnoder", " outputDecoding", " outputEncining", "outputencaching", "outputEncaching", " outputEngaling", "publicEncording", " outputDecaming", "outputEncalling", "outputEnaling", " outputEncoder", "outputCompining", "outputEnaching", "outputEnging", "outputCompaming", "outputEncining", "currentEnoding", "outputEncoder", "outputEncryption", "responseEncoding", " outputEngoding", " outputEncaming", "outputDecoding", "outputMessoding", "outputDecining", "outputEncacing", "outputEngoder", "outputencging", "outputMessryption", "outputDecaming", "outputMessaming", "responseEncling", "currentEncging", "outputEnacing", "outputEngoding", "publicEncling", "currentEnling", " outputEncaling", " outputDecryption", "outputEnaging", "outputDecryption", "outputEngaching", "outputEnryption", "currentEncoding", "currentEnging", " outputEngacing", "outputEnalling", "outputCompoding", "outputEncaming", "outputEnording"], "inputEncoding": ["outputEnging", "sourceEncoding", "outputEncging", "inputPackale", "inputencoder", "inputEncling", "sourceEnoding", "inputEncoder", "contextEncoding", "sourceEncacing", "contextEncacing", "inputencacing", "inputEncale", "inputEngale", "outputEncoder", "inputEnging", "contextEnale", "inputEncacing", "contextEnoder", "sourceEnling", "inputEning", "inputCodacing", "outputEnoding", "inputencling", "inputEnoding", "contextEncoder", "inputChoding", "inputPackoder", "outputEnoder", "sourceEnacing", "contextEnoding", "inputPackging", "contextEncale", "outputEncale", "inputEncing", "inputencoding", "sourceEncling", "inputEnale", "contextEnacing", "sourceEning", "inputEnacing", "inputCododing", "inputEngging", "inputEnoder", "inputEngoding", "sourceEncing", "inputChacing", "inputPackoding", "inputCodling", "inputencing", "inputChale", "inputCoding", "inputEngoder", "outputEnale", "inputencale", "inputChoder", "inputEnling", "inputEncging"], "remainingArgs": ["remainingParts", "remainJs", "mainingJs", "remainingBlocks", "mainingGS", "mainingParts", "remistingLinks", "mainedGS", "remainingFrames", "remainingItems", "remainsGS", "remgoingargs", "remainedParts", "remgoingArgs", "remainingargs", "removalArgs", "remistingGS", "remainsArgs", "remainingGS", "resainingGS", "remgoingParts", "remainGS", "resainedItems", "remainingJs", "trainingArgs", "resainingLinks", "trainItems", "remainedArgs", "remendingItems", "trainGS", "removalGS", "remainedBlocks", "mainingArgs", "resainedargs", "remendingGS", "resainingBlocks", "remgoingJs", "remainedParameters", "remainedFrames", "remainFrames", "trainFrames", "trainingGS", "mainedArgs", "remainedItems", "removalBlocks", "resainedBlocks", "remistingBlocks", "resainedArgs", "remendingArgs", "trainArgs", "resainingargs", "trainingFrames", "remainsParameters", "resainingItems", "remainingParameters", "remgoingGS", "removalParameters", "resainingArgs", "remainedJs", "remainArgs", "remainingLinks", "remainLinks", "remainsBlocks", "remainItems", "remainedLinks", "remainBlocks", "resainingParameters", "resainedLinks", "remistingArgs", "remainParts", "remendingFrames", "mainedJs", "trainingItems", "remainedargs", "remainedGS", "resainedParameters", "mainedParts", "resainedGS", "remgoingItems", "remainargs"], "inputFile": [" inputLike", "acceptfile", " inputFILE", "InputPlace", "outputPath", "requestFILE", "inputPath", "hiddenFile", " inputPath", "acceptFile", "hiddenfile", "inputFILE", " inputfile", " inputLine", "Inputfile", "requestPath", "acceptPlace", "acceptLine", "InputFile", " inputPlace", "outputfile", "hiddenPath", "inputLine", "outputLike", "hiddenLike", "requestfile", "inputfile", "requestFile", "InputPath", "InputLine", "inputPlace", "InputFILE", "inputLike"], "outputFile": [" outputFiles", "outputDo", "inputFilename", "clientDir", " outputfile", "outputFiles", "coinDo", "writeFolder", "cachefile", "clientFile", "cacheFilename", "writeDo", "coinfile", "coinFile", " outputDo", "outputFolder", "outputDir", "cacheDir", "outputfile", "OutputFile", " outputDir", "clientFiles", "cacheFile", "OutputDo", "OutputFilename", "clientDo", "OutputDir", "writeFile", "Outputfile", "inputfile", "writefile", "inputDir", " outputFolder", "coinFolder", "OutputFiles", "outputFilename"], "out": ["pretty", "null", "err", "in", "up", "aos", "on", "gr", "inf", "ser", "list", "error", "writer", "obj", "ins", "outs", "print", "log", "io", "report", "temp", "conn", "n", "res", "ln", "user", "output", "ex", "init", "Out", "inter", "inner", "all", "cfg", "con", "screen", "outer", "ou", "inv", "session", "manager", "sys", "gen", "msg", "OUT", "dir", "net"]}}
{"id1": "4937535", "id2": "13783898", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadProproperties", "loadproperties", "loadprops", "loadPrps", "loadPropperties", "initPrdates", "initPrps", "initProps", "initPrproperties", "loadProdates", "loadPrdates", "loadprodates", "loadPrperties", "loadPropproperties", "initProproperties", "initPrperties", "loadProps", "initProperties", "initProdates", "loadPropdates", "loadPropps", "loadPrproperties", "loadproproperties"], "properties": ["modules", "details", "notes", "packages", "params", "features", "jobs", "where", "property", "rows", "facts", "prop", "people", "results", "relations", "poses", "states", "settings", "abilities", "this", "values", "to", "prints", "members", "comments", "pro", "sheets", "rules", "papers", "organisms", "objects", "metadata", "keys", "holders", "types", "ports", "units", "database", "marks", "terms", "reports", "changes", "names", "parts", "projects", "perties", "posts", "tests", "builders", "beans", "policy", "options", "bugs", "ps"], "url": ["ret", "browser", "bel", "ur", "u", "http", "b", "ref", "open", "ls", "build", "address", "id", "p", "context", "resource", "obj", "uri", "l", "f", "sl", "nl", "rl", "service", "str", "rect", "mount", "user", "location", "sb", "char", "kl", "Url", "abs", "config", "file", "ll", "dl", "loader", "URL", "result"]}}
{"id1": "21491791", "id2": "8452134", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "label": 0, "substitutes": {"run": ["process", "exit", "exec", "un", "su", "runs", "use", "system", "name", "runner", "unit", "call", "running", "apply", "Run", "pre", "test", "cmd", "eval", "work", "don", "par", "fun", "execute", "command"], "input": ["info", "before", "feed", " inputs", "upload", "http", "in", "active", "read", "parse", "audio", "table", "cont", "back", "stream", "it", "history", "internal", "system", "address", "client", "context", "image", "background", "print", "io", "readable", "out", "request", "Input", "source", "action", "select", "hub", "from", "iter", "local", "start", "inner", "state", "partial", "index", "json", "config", "xml", "form", "initial", "file", "data", "view", "hello", "text"], "output": ["memory", "column", "exit", "update", "binary", "table", "o", "Output", "stream", "success", "block", "four", "oe", "connection", "image", "generated", "port", "filename", "log", "print", "directory", "io", "hidden", "write", "out", "put", "admin", "source", "console", "you", "export", "network", "outer", "target", "ou", "web", "config", "latest", "header", "ilo", "file", "data", "response", "external", "format", "display", "text", "command", "result", "net"], "reader": ["row", "rw", "in", "read", "table", "handler", "rar", "driver", "stream", "worker", "iterator", "system", "client", "context", "er", "resource", "owner", "wrapper", "readable", "r", "proc", "window", "controller", "ro", "iter", "Reader", "rx", "inner", "dr", "usr", "manager", "draw", "ter", "data", "penter", "file", "reading", "parser", "entry", "loader", "builder"], "writer": ["adder", "processor", "creator", "storage", "rw", "w", "written", "handler", "variable", "close", "driver", "holder", "worker", "ser", "store", "wrote", "iterator", "client", "connection", "yard", "riter", "wrapper", "writing", "write", "service", "out", "window", "widget", "caster", "word", "writers", "server", "network", "writ", "player", "wire", "outer", "target", "pipe", "draw", "manager", "ter", "Writer", "println", "penter", "file", "loader", "handle", "builder"], "pump": [" pong", "peter", "pemp", " pumps", "cump", "peumps", " pUMP", "dump", "prump", "psamp", " pipe", "cUMP", "Pumps", "pumps", "podge", "psump", " pamp", "pripe", "Pump", " peter", "Pamp", "psumper", "deter", "Pmp", " pumper", "pamp", "Peter", "Pumper", " podge", "peump", " pmp", "cumper", "pmp", "damp", "Pipe", "pumper", "dumper", "Podge", "prodge", "pipe", "psipe", "pUMP", "peumper", "PUMP", "camp", "Pong", "pong", "prong"], "counter": ["column", "cookie", "system", "context", "frequency", "number", "code", "encrypted", "random", "second", "average", "index", "hash", "row", "processor", "responsible", "amount", "currency", "timer", "common", "cell", "client", "Counter", "card", "term", "console", "continue", "ter", "loop", "key", "thread", "record", "memory", "total", "zero", "batch", "ounter", "condition", "scope", "unique", "history", "peer", "buster", "pointer", "seen", "controller", "recorded", "current", "outer", "const", "book", "radius", "collection", "phrase", "count", "parent", "message", "sequence", "created", "ctr", "clock", "page", "inner", "container", "conv", "walker", "description", "comment", "entry", "time", "loader", "vector"], "buffer": ["row", "phrase", "binary", "buff", "length", "b", "uffer", "table", "document", "batch", "base", "block", "value", "Buffer", "address", "message", "context", "sequence", "uf", "queue", "source", "buf", "bytes", "header", "data", "size", "key", "text", "command", "result", "vector"], "off": ["before", "offer", "pos", "shift", "offs", " offset", "un", "end", "offset", "Off", "after", "OFF", "now", "ff", "ow", "hand", "aff", "Offset", "of", "op", " OFF", " Off", "no", "cmd", "set", "ip", "origin", "att", "art", "oct", "def", "fun", "eff", "oa", "ap"], "len": ["pos", "written", "Len", "length", "alt", "lvl", "ld", "val", "end", "offset", "coll", "ls", "bf", "line", "mem", "mult", "cond", "vec", "lon", "pent", "l", "fl", "nl", "cl", "enc", "buf", "rel", "ln", "lp", "en", "all", "lib", "lf", "body", "kl", "fun", "le", "compl", "eff", "mat", "wl", "lan", "bytes", "vol", "size", "ll", "fin", "elt", "del"], "rd": ["rt", "lr", "rw", "ard", "ld", "rc", "rand", "dra", "xd", "mr", "nd", "RD", "ind", "dig", "cd", "md", "mn", "r", "bd", "rl", "R", "hr", "sd", "rs", "rod", "cr", "dr", "rb", "adr", "rid", "ri", "udd", "sr", "ird", "rr", "ptr", "rez", "red", "rn", "rh", "dd", "d"]}}
{"id1": "8747840", "id2": "10795866", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "upload", " copying", "read", "link", "gc", "Copy", "add", "delete", "cp", "map", "sync", "write", " replicate", "cat", "create", "csv", " cp", " mirror", "move", "save", "clip", "slice", "transfer", "clone", " Copy", "download", "load"], "src": ["sit", "sc", "bs", "rc", "pkg", "syn", "cont", "urg", "ser", "sq", "ins", "req", "sf", "cur", "source", "rel", "st", "txt", "rs", "start", "sb", "rx", "init", "from", "ctr", "iv", "sec", "img", "input", "usr", "sin", "sr", "via", "sys", "Source", "inst", "sur", "ipl", "obs"], "dest": ["sit", "null", "orig", "d", "Dest", "gt", "https", "opt", "cont", "end", "mk", "trans", "way", "pas", "decl", "rest", "master", "spec", "deg", "req", "temp", "dist", "source", "th", "test", "st", "good", "mm", "origin", "usr", "nt", "tmp", "target", "nom", "des", "nw", "self", "loc", "pub", "est", "del"], "in": ["info", "gin", "im", "old", "rc", "up", "cin", "on", "it", "inf", "inn", "ind", "id", "ze", "ain", "ins", "ic", "rin", "inc", "ai", "al", "source", "impl", "ln", "iter", "mm", "from", "IN", "init", "en", "isin", "inner", "bin", "con", "input", "din", "i", "inside", "ar", "In"], "out": ["os", "t", "err", "gt", "end", "ot", "ch", "o", "aos", "it", "on", "client", "p", "writer", "can", "obj", "to", "outs", "by", "io", "over", "write", "conn", "not", "dis", "n", "g", "res", "output", "ex", "Out", "en", "bin", "inner", "con", "nt", "outer", "conv", "sum", "ou", "oss", "at", "sys", "auto", "OUT", "co", "ne", "net"], "buf": ["bar", "bh", "buff", "b", "bs", "cap", "mu", "pkg", "stab", "ref", "batch", "block", "Buffer", "used", "vec", "fb", "buffer", "uf", "log", "tab", "mb", "temp", "queue", "str", "Buff", "seq", "aka", "cmd", "bl", "cat", "good", "bag", "cam", "rb", "br", "conv", "bed", "db", "cb", "gen", "cv", "bytes", "box", "data", "msg", "col", "fg", "bus", "prop", "arr"], "c": ["nc", "m", "ci", "t", "z", "gc", "b", "ec", "cont", "rc", "ch", "C", "mc", "a", "lc", "count", "ct", "cc", "cp", "ce", "cs", "dc", "cd", "l", "k", "cod", "call", "uc", "dec", "cache", "n", "code", "unc", "cos", "cf", "fc", "cr", "cu", "conf", "i", "cm", "cb", "co", "ca", "jc", " C", "bc", "ac", "d"]}}
{"id1": "4686922", "id2": "9236363", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResources2Files", "extractResourceTofile", "extractResourceAsStream", "extractResourceFromFile", "extractResourceFromFiles", "extractResourceToFiles", "extractResource2Files", "extractResource2Stream", "extractResourceAsFiles", "extractResourceFromfile", "extractResources2File", "extractResourceToStream", "extractResources2Stream", "extractResourcesToFile", "extractResource2File", "extractResourcesToFiles", "extractResourcesToStream", "extractResourceAsFile", "extractResourceFromStream", "extractResources2file", "extractResource2file", "extractResourceAsfile", "extractResourcesTofile"], "resourcePath": ["templateIn", "attributePath", " resourcepath", "templateName", "templatePath", " resourceIn", "uriUrl", "resourceName", "resourceLocation", "Resourcepath", "attributeLocation", "ResourceIn", "ResourcePath", "uriPath", "attributeUrl", "ResourceName", "uriName", "resourcepath", "templatepath", "resourceUrl", "attributeName", "uriLocation", "resourceIn", "ResourceLocation", "ResourceUrl", " resourceName"], "dest": ["src", "null", "orig", "w", "Dest", "opt", "cont", "end", "desc", "trans", "mem", "parent", "home", "sp", "decl", "coord", "this", "rest", "to", "temp", "dist", "source", "output", "good", "cat", "gov", "etc", "origin", "dat", "img", "tmp", "target", "nom", "lit", "des", "loc", "self", "comb", "prop", "result", "dir"], "in": ["gin", "m", "re", " din", "mc", "mi", "up", "cin", "it", "on", "raw", "or", "none", "ini", "inf", "inn", "ind", "id", "resource", "ins", "l", "rin", "f", "r", "inc", "al", "source", "ln", "no", "IN", "from", "iter", "local", "init", "isin", "bin", "inner", "all", "con", "input", "conf", "sin", "din", "i", "inside", "file", "is", "ne", "In"], "out": ["os", "cn", "null", "t", "note", "w", "exit", "b", "ot", "ch", "o", "aos", "na", "it", "on", "client", "v", "writer", "can", "obj", "to", "outs", "print", "f", "io", "stable", "cache", "write", "n", "res", "no", "output", "Out", "en", "inner", "con", "again", "nt", "conv", "tmp", "outer", "ou", "oss", "i", "at", "sys", "pool", " Out", "OUT", "co", "ne", "cos", "col", "net"]}}
{"id1": "21754659", "id2": "19868933", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getbuttonSonico", "getButtonDonida", "getButtonLeonico", "getbuttonSonilo", "getButtonDonido", "getButtonSonico", "getButtonDonico", "getButtonLeonida", "getButtonLeonilo", "getbuttonSonida", "getbuttonSonido", "getButtonSonida", "getButtonSonilo", "getButtonDonilo", "getButtonLeonido"], "buttonSonido": ["buttonSONida", "keySonilo", "buttonJonidable", "buttonSon\u00ed", "buttonsoningo", "fieldSonido", "positionJonico", "buttonSonico", "buttonSonicho", "buttonJonida", "positionSonito", "buttonBonilo", "fieldsonido", "buttonSynidable", "buttonBonano", "buttonsonida", "keyson\u00ed", "buttonNorthida", "secondSonito", "buttonSynicho", "labelSonila", "buttonSunito", "buttonBon\u00ed", "secondSynito", "buttonHonido", "secondSonicho", "buttonHonilo", "buttonSynphp", "buttonsonido", "buttonJonido", "buttonBonida", "buttonNorthano", "buttonJonilo", "buttonSonito", "keySon\u00ed", "buttonJonico", "buttonSonila", "fieldSonida", "buttonBonido", "buttonSonano", "buttonSONphp", "buttonSynida", "buttonSonilo", "buttonSonata", "buttonJonicho", "buttonJonito", "buttonSunata", "fieldSoningo", "buttonDenito", "buttonSunilo", "buttonBonardo", "positionJonito", "fieldSonano", "buttonBonao", "buttonSunico", "buttonBonata", "positionSonido", "fieldsoningo", "ButtonSunao", "labelSonphp", "labelSONphp", "buttonSONito", "positionSonilo", "positionJonilo", "buttonSONico", "buttonSONila", "ButtonSonao", "buttonJonphp", "buttonSoningo", "buttonSunao", "buttonSONido", "labelSONido", "buttonDenidable", "secondSynidable", "buttonSonphp", "buttonSONilo", "fieldsonano", "buttonJonao", "keySonido", "buttonsonilo", "ButtonSonico", "buttonSynido", "secondSonido", "buttonJonata", "buttonNorthido", "ButtonSunata", "keysonardo", "buttonson\u00ed", "secondSonidable", "ButtonSonata", "labelSonida", "buttonDenicho", "keysonilo", "buttonHon\u00ed", "keysonido", "ButtonSonido", "labelSONila", "buttonSynito", "keySonardo", "buttonsonardo", "buttonSynila", "secondSynido", "buttonSonao", "fieldsonida", "secondSynicho", "buttonSunido", "buttonJonila", "buttonSonardo", "buttonBoningo", "buttonBonico", "ButtonSunido", "buttonNorthingo", "ButtonSunico", "buttonSonidable", "positionSonico", "buttonsonano", "buttonHonardo", "buttonSonida", "positionJonido", "buttonDenido", "labelSonido", "labelSONida"], "e": ["t", " ke", "ee", " pe", " fe", "a", "ed", "es", "AE", " ate", "er", "ae", "ED", "ing", "ese", "ev", "E", " ge", "me", "pe", "act", "ie", " ve", "te", " ie", " who", " sent", "event"], "fc": ["nc", "tc", "gc", "fn", "fab", "mac", "ec", "RFC", "c", "rc", "fp", "abc", "coll", "mc", "WC", "ifa", "fm", "lc", "soc", "bf", "isc", "cc", "fb", "dc", "ic", "f", "fl", "uc", "inc", "rl", "fs", "cf", "icc", "anc", "pc", "vc", "etc", "con", "lf", "conv", "irc", "cv", "tf", "fd", "fi", "fa", "bc", "ctrl", "FC"], "returnVal": ["ReturnVal", "returnValue", "Returnval", " returnval", " returnVAL", "resultVAL", "retValue", "ReturnVAL", "retVal", "retval", "resultVal", "retVAL", "returnval", "resultValue", " returnValue", "returnVAL", "resultval", "ReturnValue"], "file": ["info", "full", "File", "null", "ile", "http", "FILE", "disk", "link", "table", "document", "fp", "path", "url", "get", "base", "block", "files", "parent", "valid", "fe", "name", "this", "message", "image", "resource", "buffer", "spec", "to", "uri", "f", "io", "source", "single", "user", "output", "create", "local", "stat", "page", "tree", "template", "input", "word", "show", "form", "data", "channel", "format", "time", "type", "handle", "dir"], "rutaGlobal": ["rutiDefault", "rutaglobal", "rutoLocal", "rutenFile", "RutaLocal", "rutiGlobal", "redutanLocal", "rutaDefault", "rutenGlobal", "rutenStatic", "rutaGeneral", "rutaRemote", "rutoFile", "rutaLocal", "rutiStatic", "RutoStatic", "rutoglobal", "rontoGlobal", "redutanGlobal", "rontoGeneral", "rutenLocal", "rontoLocal", "RutaGlobal", "RutoGlobal", "rutoRemote", "RutoRemote", "rutiglobal", "rutoStatic", "RutaRemote", "rutiRemote", "redutanDefault", "rutiLocal", "rutenglobal", "rontoDefault", "redutaDefault", "redutaGeneral", "rutiGeneral", "rutanDefault", "RutoLocal", "redutaLocal", "rutaFile", "RutoFile", "rutaStatic", "Rutoglobal", "redutaGlobal", "RutaFile", "RutaStatic", "rutanLocal", "Rutaglobal", "rutanGlobal", "rutoGlobal", "rutenRemote", "rutiFile", "redutanGeneral", "rutanGeneral"], "rutaRelativa": ["rutaRelitivo", "rutaRELativo", "rutaRELitiva", "rutaRelATivo", "rutaRELitivas", "rutaRELativas", "rutaRELativa", "rutaRelatiiv", "rutaRELATivas", "rutaRelatiivas", "rutaRELitiv", "rutaRelativ", "rutaRELATivo", "rutaRelitiv", "rutaRelitivas", "rutaRelativas", "rutaRelantivo", "rutaRELATiva", "rutaRelativo", "rutaRelATiva", "rutaRELativ", "rutaRelantiv", "rutaRelATiv", "rutaRelatiiva", "rutaRELitivo", "rutaRelatiivo", "rutaRelATivas", "rutaRELATiv", "rutaRelantiva", "rutaRelitiva", "rutaRelantivas"], "fis": ["dfisa", "ros", " fisc", "vois", " f\u00eds", "f\u00eds", "viss", "fys", "flis", "lfisa", "flos", "fiss", "flisc", " fisa", "df\u00eds", "fais", "lf\u00eds", " fys", "dfois", "rys", " fiss", "vais", "dfiss", "flys", "risc", "ris", "fisc", "fois", "fisa", "dfis", "vis", "lfis", " fais", "dfais", " fois", "lfiss"], "fos": [" fops", "voes", "wios", "fdoes", "hios", "mows", "foes", "fdos", "fdoss", " foes", "ioss", " fows", "hoses", "ios", "fows", "moes", "ioses", "woses", "wos", "mops", "waos", "mos", "woss", "fios", "faos", " foss", "iios", "fdaos", "hoss", "vos", "vows", "hos", "foss", "foses", "woes", "fops", " faos", "vops"], "canalFuente": ["canalfuent", "canalFaelia", "canallfuencia", "canalPotencia", "canalfuante", "canalFucer", "canalFuencia", "canallFuent", "canalFient", "canallFuestro", "canallfuper", "canalPotper", "canallfumelon", "canelFuante", "canallfucer", "canalfuencia", "canalFaante", "canallFuente", "canalfuestro", "canalFraencia", "canalFuestro", "canalfuente", "canalFUent", "canalFiente", "canallfuente", "canalFraper", "canallFuencia", "canalFumelon", "canalFUante", "canalFUente", "canalFramelon", "canalPotmelon", "canalFUelia", "canalfuelia", "canalFaent", "canallfuestro", "canalFiestro", "canalFuent", "canalPotente", "canalfuper", "canalFuper", "canelFuent", "canalfumelon", "canalFaente", "canelFaelia", "canelFaent", "canelFaente", "canalFacer", "canalFraente", "canalFaestro", "canallFumelon", "canalFuelia", "canalfucer", "canallFuper", "canelFuelia", "canallFucer", "canalFuante", "canalFicer", "canallfuent", "canelFuente", "canelFaante"], "canalDestino": ["canaldOrigina", "canaldDestination", "canaldDestina", "canaldOrigino", "canalDestina", "canalOrigination", "canalNegino", "canalOrigino", "canalsdestino", "canaldestino", "canalsDestino", "canalDestinian", "canalNegina", "canaldestination", "canaldOrigination", "canalOrigine", "canaldestinian", "canalNeginian", "canalDescina", "canalsDestinian", "canalOrigina", "canalsdestina", "canaldDestino", "canalDescino", "canalDescination", "canalsDestina", "canaldDestine", "canaldOrigine", "canalsdestinian", "canalNegination", "canalDestine", "canalDestination", "canalDescine", "canalsdestination", "canalsDestination", "canaldestina"]}}
{"id1": "18238468", "id2": "19113613", "code1": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testLoadSource": [" testloadSourceFile", " testAddFile", "testloadSourceFile", " testLoadSourceFile", " testAddSources", " testLoadSources", "testloadSource", " testloadSource", " testloadSources", "testloadSources", "testLoadSources", " testLoadFile", " testAddSourceFile", " testloadFile", "testLoadFile", "testloadFile", " testAddSource", "testLoadSourceFile"], "metadata": ["info", "m", "details", "ad", "detail", "about", "params", "df", "sample", "document", "managed", "mk", "my", "sheet", "default", "definition", "desc", "valid", "common", "iterator", "activity", "message", "md", "directory", "article", "map", "mt", "primary", "password", "layout", "summary", "content", "report", "wrapper", "payment", "unknown", "license", "still", "basic", "cmd", "met", "dirty", "template", "properties", "pdf", "meta", "tmp", "material", "json", "adata", "manager", "config", "xml", "header", "data", "parser", "policy", "dd"], "inputStream": ["thisView", "formStream", "thisSteam", " inputView", "currentSteam", "dataStream", "loadStore", " inputstream", "currentStreamer", "inputPort", "dataSteam", "InputForm", "formForm", "inputPresent", "loadSteam", "InputView", "inputSteam", "thisStream", " inputPort", "inputStreamer", "inputView", " inputSteam", " inputForm", "loadstream", "loadStream", "inputStore", "currentStream", "InputSteam", "formSteam", "thisPresent", "inputstream", "dataPort", " inputStore", "dataStreamer", "InputStream", "inputForm", "Inputstream", "InputStore", "currentPort", "InputPresent", " inputPresent", " inputStreamer"], "writer": ["editor", "adder", "creator", "storage", "counter", "null", "w", "written", "unsigned", "handler", "WR", "wright", "stream", "worker", "maker", "rew", "wrote", "iterator", "buffer", "riter", "master", "wrapper", "writing", "to", "reader", "write", "out", "temp", "window", "console", "order", "output", "caster", "inner", "string", "operator", "writers", "network", "wire", "writ", "outer", "walker", "manager", "her", "Writer", "woman", "channel", "loader", "event", "builder"], "contents": ["Contodes", " CONTENT", "utfented", " CONTodes", "Contented", "Content", " CONTens", "CONTented", "utfent", " CONTents", "content", " contens", "ContENT", "CONTent", "Contents", " contENT", "contens", "contodes", "Contens", "utfents", "CONTents", "contented", "contENT", " contodes"]}}
{"id1": "7276377", "id2": "17856064", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"checksum": ["csest", "cksam", " checksume", "checksest", "csume", "csam", "cksume", "cksum", "checksam", "cksest", " checksam", " checksest", "csum", "checksume"], "url": ["domain", "bel", "ur", "u", "email", "http", "link", "https", "document", "path", "ls", "host", "base", "get", "gl", "dll", "build", "address", "name", "image", "uri", "log", "l", "nl", "request", "q", "str", "rect", "mount", "rel", "location", "ssl", "string", "pattern", "char", "Url", "web", "mail", "config", "el", "html", "ul", "xml", "file", "loc", "ll", "dl", "key", "URL", "browser"], "algorithm": ["Alculus", " algo", "Algorith", "alignment", "approculus", "maliment", "operabet", "palgorithm", "aliment", "malgo", "opergorithm", "alculus", "opergo", "palter", "alterignment", "Alter", "malignment", "palgo", " algorith", "palabet", "alabet", "malgorithm", "approgorith", "approgorithm", "algo", "operter", "alter", "approgo", "altergorithm", "alteriment", "Algo", " alculus", "Alignment", "algorith", "altergo", "Aliment", "Alabet", "Algorithm"], "messageDigest": ["messageCheckse", "messageDiger", " messageDiger", "MessageDigse", "MessageDigest", "messageDebuger", "applicationDigests", "messageCheckest", "Messagedigest", "applicationDigester", "messagedigist", "messageDigester", "messageHasests", "messagedigum", "messageDigse", "messageDigum", "MessageDiger", "messageDum", "messagedigidate", " messageDigist", "messageDigist", "applicationDesignester", "messageCheckum", "messageDigests", " messageDigidate", "messageDesignests", "messageDebugest", "messageChecker", "messageMerist", "messagedigest", "messagedigester", "applicationDigest", "Messagedigse", "applicationDesigner", "messageHaser", "messageDse", "messageMerse", "messagedigse", "messageDesignest", "messageDebugidate", "applicationDiger", "messagediger", "messageDebugse", "applicationDesignest", "messageDesignester", " messageDigse", "messageHasester", "messageMerest", "applicationDesignests", "MessageDigum", "messageDer", "Messagedigum", "messageDigidate", "messagedigests", "Messagediger", "messageHasest", "messageDesigner", "messageDest"], "bytes": ["frames", "notes", "words", "ones", "eps", "bs", "jobs", "Bytes", "services", "versions", "vs", "pages", "resources", "rows", "bes", "tes", "its", "bps", "files", "es", "ies", "seconds", "users", "values", "outs", "items", "checks", "blocks", "pieces", "ces", "lines", "bits", "out", "gs", "gb", "groups", "vals", "pointers", "types", "bos", "units", "steps", "terms", "names", "parts", "gets", "strings", "classes", "images", "ions"], "in": ["gin", "info", "m", "re", "null", "t", "nin", "oin", "mc", "o", "h", "mi", "up", "cin", "it", "on", "or", "pi", "check", "inf", "socket", "inn", "ind", "name", "client", "p", "ain", "can", "ins", "l", "rin", "io", "reader", "by", "inc", "ai", "out", "al", "proc", "source", "one", "n", "impl", "IN", "from", "init", "en", "isin", "bin", "inner", "con", "input", "conf", "again", "din", "asin", "ma", "i", "form", "is", "co", "serv", "handle", "In"], "nBytesRead": [" nBytesread", "nFramesSupported", "nItemsWritten", "nTokensRead", "nFilesRead", " nItemsReader", "nFramesRead", "NRsRun", "nBytesReader", "nFilesread", "nBytesRun", " nItemsFound", "nItemsFound", "NBytesread", "nTokensread", "nbytesWritten", "NBytesRead", "nbytesSupported", "nbytesread", " nRsWritten", "nFilesRun", "nRsRead", "nItemsReader", "nFilesWritten", "nFramesFound", "NRsWritten", "NRsread", "nRsread", " nRsread", "nRsReader", " nBytesReader", "nItemsRead", " nBytesFound", "NBytesRun", " nBytesWritten", "nFramesWritten", "nTokensWritten", "nRsWritten", " nItemsWritten", "NRsRead", "nRsRun", "nBytesFound", "nBytesSupported", " nBytesSupported", " nRsSupported", "nTokensRun", "nBytesread", "nRsFound", "nFramesReader", "nBytesWritten", " nItemsRead", "NBytesWritten", "nRsSupported", " nRsRead", "nbytesRead", "nFramesread"], "checksumValue": ["checksamVal", "checksumedValue", "checksummVal", "checksumValues", "checksUMModel", " checksamDocument", " checksumDocument", "checksumvalue", " checksumvalue", "checksumedDocument", "checksummModel", "checksumDocument", "checksummvalue", "checksummData", " checksummvalue", "checksumData", "checksumVal", " checksumVal", "checksumerModel", " checksumValues", "checksUMvalue", "checksamDocument", "checksumerValues", " checksummValue", "checksamValue", " checksummModel", "checksamData", "checksummValues", "checksumModel", "checksUMValues", "checksummDocument", "checksumervalue", " checksamValue", "checksumerValue", "checksUMValue", "checksumedVal", " checksumData", "checksumedData", " checksamData", " checksamVal", " checksumModel", " checksummValues", "checksummValue"]}}
{"id1": "3330775", "id2": "6558022", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 1, "substitutes": {"getJSONData": ["loadjsonData", "loadJSONObject", "getJResponse", "getBasicObject", "getjsonContent", "getJSONObject", "getjsonObject", "getJData", "getBasicData", "getJSONResponse", "loadJSONData", "getBasicResponse", "loadjsonContent", "getJContent", "loadjsonObject", "loadJSONContent", "getjsonData", "loadJSONResponse", "getJSONContent", "getBasicContent", "getJObject", "getjsonResponse", "loadjsonResponse"], "url": ["ret", "pl", "item", "ur", "http", "link", "b", "href", "path", "ls", "host", "util", "base", "lim", "address", "id", "name", "l", "log", "sl", "nl", "str", "rel", "location", "string", "ssl", "pattern", "json", "Url", "i", "web", "ul", "addr", "file", "loc", "ll", "remote", "dl", "URL", "result"], "jObject": ["jsonNull", "objObj", "jsonData", "jObj", " jObj", "reportData", "jsonObject", "reportObj", " jNull", "reportDocument", "jData", "objObject", " jobject", "jDocument", "jobject", " jAnonymous", "jAnonymous", "jsonAnonymous", "jpNull", "jpobject", "jpObject", "jsonObj", "jpAnonymous", "jsonobject", "objDocument", " jDocument", "jsonDocument", "reportObject", "objData", " jData", "jNull"], "data": ["details", "api", "ad", "feed", "ata", "sample", "done", "mu", "DATA", "stream", "raw", "results", "aw", "block", "value", "trans", "or", "media", "error", "name", "message", "buffer", "image", "resource", "sequence", "content", "cache", "source", "window", "no", "output", "dat", "dev", "string", "input", "area", "body", "session", "json", "html", "bytes", "size", "ne", "text", "result"], "httpClient": [" httpclient", "httpsContext", "ttpclient", " httpControl", "HttpContext", "ttpContext", "httpsControl", "HttpGet", "httpsclient", "ttpClient", "HttpBuilder", "httpContext", "HttpClient", "Httpclient", "httpBuilder", "httpclient", "ttpGet", "HttpControl", "httpsBuilder", "httpsGet", "httpsClient", " httpBuilder", "httpControl"], "uri": ["domain", "ur", "u", "api", "http", "URI", "phi", "link", "archive", "qi", " URI", "path", "ref", "du", "util", "range", "base", "pi", "host", "lu", " ur", "ui", "cp", "address", "hi", "client", "connection", "resource", "directory", "hu", "uu", "term", "iri", "source", "nu", "hub", "ip", "location", "origin", "ri", "char", "server", "point", "i", "Url", "via", "manager", "ilo", "subject", "remote", "uni", "qu", "URL"], "httpGet": [" httpGET", "HTTPQuery", "hGET", "HTTPGET", " httpQuery", "hGate", "httpGate", "htmlGate", "HTTPGet", "htmlGET", "hGet", "httpPut", "hQuery", "htmlPut", " httpPut", "httpGET", " httpGate", "htmlQuery", "HTTPPut", "htmlGet", "httpQuery"], "response": ["answer", "successful", "pos", "http", "opening", "resp", "document", "object", "onse", "success", "version", "block", "socket", "client", "connection", "message", "image", "resource", "yes", "context", "report", "service", "request", "respond", "still", "application", "output", "page", "reply", "server", "Response", "body", "next", "json", "frame", "description", "hello", "remote", "resolution", "status", "result"], "line": ["LINE", "row", "column", "phrase", "link", "sample", "eline", "key", "inline", " Line", "e", "block", "ice", "part", "liner", "error", "cell", "name", "message", "Line", "sequence", "l", "log", "print", "nl", "number", "code", "ln", "user", "stroke", "entity", "lin", "page", "word", "next", "point", "frame", "comment", "header", "file", "online", "entry", "len", "ine", "label", "text", "chain", "status", "field"], "builder": ["bar", "join", "full", "row", "ener", "built", "b", "length", "atter", " builders", "alph", "upper", "bean", "oster", "base", "lu", "building", "board", "build", "name", "fb", "black", "buffer", "message", "writer", "uf", "er", "library", "control", "by", "sf", "number", "ender", "order", "Builder", "ward", "utils", "sb", "language", "lower", "inner", "operator", "der", "eng", "web", "trace", "BU", "builders", "parser", "loader"], "reader": ["dd", "record", "row", " read", "older", "per", "read", "handler", "where", "rar", "ner", "dra", "util", "range", "driver", "stream", "e", "roller", "worker", "peer", "iterator", "oder", "message", "buffer", "writer", "er", "runner", "bo", "wrapper", "r", "readable", "rl", "ro", "iter", "Reader", "dr", "inner", "ri", "ger", "river", " readers", "reading", "parser", "entry", "field", "loader", "ator", " writer", "mr"]}}
{"id1": "771802", "id2": "411595", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createOutputFile", "createInputSteam", " createFileStream", "createOutputSteam", " createOutputstream", " createOutSteam", " createOutStream", " createInputSteam", " createInputStream", " createOutputSteam", " createFileFile", " createInputFile", " createFileSteam", "createInputStream", "createInputFile", " createInputstream", "createInputstream", " createOutputFile", " createFilestream", "createOutputstream", " createOutFile", " createOutstream"], "inFile": [" infile", "dinFile", " inPort", "inputPath", "ninFile", "inputPort", "dinPath", "outFilename", "dinPort", "inPort", "ninfile", "ninFilename", "outfile", " inDir", "infile", "inPath", "inputFile", "dinDir", "outPath", "ninPath", "inDir", "inputDir", " inFilename", "inFilename", " inPath"], "outFile": ["toFilename", "Outfile", "toPort", "exFilename", "outFilename", "outPort", "exFile", "newFilename", "inPort", "OutFilename", "outfile", "infile", "outputFile", "newFile", "outputfile", "tofile", "toFile", "outputPlace", "OutFile", "exfile", "newPlace", "OutPort", "inFilename", "newfile", "outputFilename", "outPlace", "exPlace"], "k_blockSize": ["k_BlockTime", "k4BlockStyle", "k4blockName", "k2byteCount", "k4BlockSize", "k2byteSize", "k2blockSize", "k4blockStyle", "k_byteTime", "k_byteCount", "k_batchCount", "k_blockCount", "k_byteSize", "k4BlockCount", "k_BlockStyle", "k4BlockName", "k_batchSize", "k2byteLength", "k_batchTime", "k_blockName", "k2blockLength", "k4blockCount", "k_blockTime", "k_byteStyle", "k_batchLength", "k2blockCount", "k2byteTime", "k_blockLength", "k4blockSize", "k_byteLength", "k_blockStyle", "k_BlockSize", "k2blockTime", "k_BlockName", "k_BlockCount", "k_BlockLength", "k_byteName"], "byteCount": ["blockCounter", " byteCounter", "charCount", "wordN", "bitCheck", "bytecount", "byteN", "blockCount", " byteCheck", "bbCount", "bitLength", "bitCounter", " bytePtr", " bytecount", "bbCode", "bbSize", "wordCount", "lineLength", "linePtr", "linecount", "byteLength", "charcount", "blockCheck", "wordSize", "bbN", "wordCode", "charLength", "bytePtr", "byteCheck", "byteSize", " byteLength", "lineCount", "byteCode", "bitCode", "blockLength", "byteCounter", "charPtr", "bitSize", "bitCount", "bitN"], "buf": ["bg", "buff", "b", "bn", "cap", "pkg", "alph", "batch", "raw", "block", "mem", "Buffer", "vec", "buffer", "uf", "pb", "doc", "queue", "cur", "proc", "str", "Buff", "seq", "cmd", "bl", "txt", "cat", "ctr", "exp", "ctx", "bag", "rb", "img", "conv", "db", "cb", "cv", "bytes", "msg", "tx", "cast", "fg", "bc", "arr"], "ofp": ["ofd", "owlP", "OFP", "ofl", "OFp", " ofd", " ofP", "OFd", "ofP", "Ofl", "Ofd", " ofl", "owlp", "Ofp", "OfP", "owlpa", "Ofpa", " ofpa", "ofpa", "OFl", "owld"], "zos": ["zen", "os", "sis", "zin", "zh", "zip", "z", "hz", "bs", "zag", "eros", "ws", "cz", "css", "bes", "sch", "osi", "ossus", "tis", "python", "ps", "es", "settings", "socket", "zi", "zl", "zik", "ze", "zo", "zon", "amia", "enos", "zy", "std", "rose", "gs", "nz", "esa", "js", "zers", "los", "init", "ez", "rss", "zb", "sbm", "jp", "hess", "za", "jas", "zzle", "zes", "oss", "rez", "LOS", "zona", "south", "zer", "webkit", "cos", "zu", "psy"], "osw": ["ossW", "cosew", " osd", "sysrw", "aosw", "cosw", "aosrw", "aosws", "cosws", "isW", "owa", " osW", "ossw", "osrw", "osd", "aoswd", "ow", "oswd", "osW", "aosew", "sysw", "aoswa", "oW", "osws", "ospace", "osew", "osssw", " osew", "osswd", "aospace", "oswx", "osswx", "cosd", "ossrw", "issw", "syswd", "sysW", "osipace", " ossw", " oswx", " osws", "isw", "opace", "oswa", "osiW", "osiw", "iswx", "osiwa", "aosW", "aosd"], "bw": ["bwk", " bz", "pbwy", "bex", "wbx", "bbex", "obsw", "obw", "bbwp", " bex", "wbw", "obwb", "sbw", "bwb", "bwe", "bew", "bbws", "obwl", " bend", "pbew", "bbz", "bbend", "bx", "sbwt", "bewl", "wbend", "bsw", "bwy", "wbwt", "wbz", "bbem", "abwe", "nbwe", "abw", "pbwe", " bem", "pbw", "rbz", " bwp", " bsw", " bwl", "bbwt", "nbw", " bws", "pbwb", "pbz", "nbwy", "obwt", " bwt", "obwk", "sbz", "obz", "rbws", " bx", "bend", "bwt", "pbwt", "nbew", "bewk", "bbx", "bem", "abwy", "bws", "rbex", "sbwb", "wbem", "bwl", "bz", " bwk", "bbw", "rbw", "bwp", "abew", "wbwp", "besw"], "zot": ["zerot", "zerote", " zo", "Zote", " ziot", "zero", "ziat", "ziot", "zhot", " zote", "Zit", "zipiot", "zipot", "zoonet", " zhot", "zeriot", "zeriat", "zo", "zoo", "zote", "zoor", " zott", "zerit", "zeronet", "ziphot", " zonet", "zonet", "zipiat", "zott", "zor", " ziat", "zoot", "zerott", " zor", "zeror", "Zot", "Zott", "zerhot"], "ifp": [" ifr", " iftp", "iwr", "ihr", "iwp", " ifP", "isth", "IfP", "ifd", "ihd", " ifth", "iwtp", "isp", "isjp", "iwd", "ifth", "ihtp", "ifjp", "Ifp", "ihp", "iftp", " ifjp", " ifd", "ifP", "isP", "ifr", "Ifjp", "Ifth"], "zis": ["ezis", "zipIS", "ezi", "ziiss", " zisc", "zipic", "ziisa", "eziss", " zIS", "izinit", "izisa", "iziss", "zisa", "zi", "zoisa", "ziinit", "zipis", " zic", " zi", "zoiss", "izi", "zIS", "ziis", "zeris", "zoinit", "zerIS", "ziss", "ezisc", "zois", "zeric", "izisc", "zic", " ziss", "zisc", "zinit", "izis"], "isr": ["isalpr", "iossr", "issrs", "isscr", "itssr", "iscr", "sisrs", "isalstr", "sisrc", " isrs", "itsr", "issr", "ispr", "iosr", "iosstr", "issrc", "isrs", "iospr", "sisr", " isrc", "isrc", " iscr", "isalr", "isstr", "itsstr", "isalsr", "siscr", "itspr"], "br": ["bt", "bh", "shr", " Br", "lr", "Fr", "b", "bn", "obl", "Br", "bf", "gr", "bm", "ba", "yr", "bd", "r", "wr", "hr", "str", "js", "rel", "bl", "bi", "ctr", "cr", "dr", "rb", "bro", "tr", "BR", "bp", "sr", "pr", "ptr", "fr", "kr", "ber", "vr", "bj", "mr"], "zit": ["ezIT", "zipist", "izip", "lexIT", "zIT", "zip", "ozunit", "oziti", "zeip", "ziti", "ozip", "ezite", " zop", "zeit", "zeot", "zIt", "zipIt", "cziti", " zite", "zipite", "lexit", "izit", "zist", "zite", "ziIT", "czit", "lexIt", " zip", "zipit", "iziti", "ziIt", "ozit", "czot", "czunit", "izunit", "zipIT", "ziist", "zop", "ezlit", "ezit", "czip", "zeop", "zunit", "ziit", "ziplit", "czop", " zIT", " zlit", "lexist", "zlit"]}}
{"id1": "3756429", "id2": "5049453", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"scramble": ["scrimbles", "scambling", " unscrambles", " unscreambles", "scrimbled", " unscramble", "screambles", "scrimble", "scrambled", "scrambling", "scambles", "scamble", " unscreamble", " unscreambling", " unscrambling", " unscreambled", "screambled", "scrambles", "scambled", "screamble", "scrimbling", "screambling", " unscrambled"], "text": ["Text", "tt", "t", "read", "cont", "document", "path", "object", "TEXT", "value", "now", "name", "message", "buffer", "log", "print", "content", "source", "str", "th", "code", "test", "txt", "output", "act", "string", "title", "pattern", "template", "input", "word", "char", "nt", "body", "ext", "html", "config", "aut", "data", "msg", "command"], "md": ["mod", "m", "ms", "det", "pd", "df", "ld", " MD", "mk", "dh", "mc", "pm", "add", "MD", "sh", "ind", "rm", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "me", "cmd", "dm", "mm", "met", "dr", "def", "pdf", "der", "nt", "sha", "material", "ma", "hd", "red", " Md", "mand", "grad", "mo", "mp", "dd", "d"], "sb": ["bt", "bh", "bg", "bs", "obb", "erb", "ab", "bf", "soc", "kb", "bb", "sq", "sp", "ib", "pb", "sl", "bd", "mb", "sf", "gb", "sth", "lp", "ub", "eb", "sg", "ssl", "zb", "rb", "SB", "sa", "bp", "gob", "nb", "db", "abs", "cb", "ob", "xb", "lb", "bis", "bsp", "bj", "shell", "obs"], "b": ["m", "bt", "u", "wb", "t", "z", "bs", "j", "c", "ab", "bit", "o", "a", "be", "kb", "bb", "ib", "B", "v", "fb", "obj", "s", "f", "k", "r", "gb", "n", "g", "code", "bi", "eb", "rb", "br", "bp", "i", "db", "cb", "nb", "bc", "bu", "d"]}}
{"id1": "647224", "id2": "23452437", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"uploadFile": ["putFiles", "uploadFiles", "putfile", "uploadfile", "savefile", "saveFile", "putImage", "saveFiles", " uploadfile", " uploadFiles", " uploadImage", "saveImage", "putFile", "uploadImage"], "inputFile": [" inputOne", "inputFilename", "fromResource", "targetFILE", " inputFILE", "inputResource", "inFILE", "outputFiles", " inputFiles", "outputPath", "evalFILE", "inputPath", "updateLe", " inputPath", "infoFile", " inputLe", "thisfile", "inputOne", "inputFILE", "evalField", "targetField", " inputLine", " inputfile", "thisLine", "imgFile", "thisFile", "Inputfile", "inputFiles", "updateFile", "infoFILE", "fromFILE", "fromFile", "targetResource", "inLine", "inFile", "evalFile", "updateOne", "InputFile", "InputFiles", "evalResource", "updateLine", "outputfile", "outputLine", "inputLine", "inputField", "inputfile", "thisPath", "imgOne", "infoLine", "inFilename", "infoFilename", "imgLine", " inputFilename", "InputLine", "fromField", "imgLe", "inputLe"], "targetFile": ["targetDir", "targetPath", " targetFilename", "sourceFolder", " targetPath", "targetFilename", "targetFILE", "sourceFile", "TargetPath", "outputFiles", "TargetFile", "outputPath", "detailDir", "sourceDir", "targetfile", "targetFolder", "targetDate", "toFolder", "targetFiles", "TargetString", " targetDir", "TargetDir", " targetDate", "outputFolder", "TargetFiles", "detailFile", "outputDir", "detailFILE", "sourcefile", "detailString", " targetFILE", "outputfile", "TargetFILE", "sourcePath", "tofile", "sourceFiles", "outputDate", "toFile", "toDir", " targetString", "targetString", "sourceFilename", "sourceDate", "outputFilename"], "outputFile": [" outputFiles", "outputDo", "targetDir", " outputDirectory", " outputStore", "inputFilename", "targetFilename", "sourceFile", " outputPlace", "outStyle", " outputfile", "outputFiles", "sourceDir", "outFile", "putPlace", "noPlace", "targetfile", " outputStyle", "displayStore", "putGe", "targetFiles", "outModel", "displayFILE", " outputModel", "nullfile", "inputFiles", "noFile", "nullModel", "outFiles", "displayFile", "targetModel", " outputDo", "putFile", " outputFilename", "removeStore", " outputLog", "inputModel", "removePlace", "outfile", "targetLog", "removeFILE", "outputDir", "putfile", "inputDo", "outputModel", "sourcefile", "nullStyle", "outputfile", "displayPlace", "outDo", " outputDir", "outputLog", "noGe", "inputDirectory", "targetDirectory", "outputFILE", "outputStore", "inputfile", "nullFile", "inputDir", "sourceFiles", "outputStyle", "outputPlace", "nofile", "outputGe", "outputFilename", "outDir", "outputDirectory", " outputFILE", " outputGe", "removeFile", "inputLog"], "in": ["info", "im", "per", "read", "mc", "cin", "on", "it", "ini", "inf", "inn", "ind", "ze", "ain", "ins", "l", "rin", "ic", "by", "io", "inc", "ai", "al", "source", "like", "ro", "IN", "iter", "act", "mm", "init", "en", "inner", "isin", "bin", "con", "input", "ri", "din", "inside", "i", "el", "is", "ar", "In"], "out": ["os", "cn", "null", "t", "err", "b", "end", "ot", "writer", "o", "up", "aos", "it", "on", "obj", "list", "name", "client", "v", "can", "s", "to", "log", "print", "report", "io", "by", "outs", "write", "put", "cache", "dis", "n", "g", "res", "console", "ln", "cos", "output", "IN", "ex", "Out", "inner", "all", "conf", "screen", "con", "and", "nt", "outer", "sum", "ou", "at", "sys", "println", "auto", "OUT", "co", "vol", "we", "net"], "line": ["record", "LINE", "row", "detail", "column", "phrase", "link", "sample", "lo", "rule", "eline", "range", "inline", "block", "ide", "cell", "message", "Line", "sequence", "log", "l", "nl", "node", "code", "ln", "stroke", "entity", "lin", "page", "word", "edge", "point", "query", "frame", "comment", "lock", "lane", "entry", "field", "ine", "label", "chain", "command"], "bytes": ["cells", "frames", "ales", "ices", "ones", "bs", "Bytes", "xes", "pages", "odes", "ls", "rows", "amples", "bes", "tes", "bps", "files", "oms", "otes", "es", "ips", "lements", "ies", "errors", "books", "seconds", "values", "reads", "ows", "outs", "blocks", "bits", "lines", "bles", "comments", "gs", "les", "nets", "sofar", "uses", "vals", "units", "steps", "ends", "terms", "times", "parts", "gets", "ges", "classes", "ites", "comes", "gments"]}}
{"id1": "2642914", "id2": "7458833", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarBw", "addFileToTarGt", "addFileToTarBt", "addFileToTarJw", "addFileToTarGez", "addFileToTarGst", "addFileToTarRw", "addFileToTarRzip", "addFileToTarGsp", "addFileToTarBz", "addFileToTarJx", "addFileToTarRx", "addFileToTarGet", "addFileToTarGsz", "addFileToTarBx", "addFileToTarGx", "addFileToTarGw", "addFileToTarBp", "addFileToTarGszip", "addFileToTarGp", "addFileToTarJz", "addFileToTarGzip", "addFileToTarRz", "addFileToTarJzip", "addFileToTarGep", "addFileToTarBzip", "addFileToTarGezip"], "taro": [" tarro", "ttaro", "tro", "Tamo", "temparo", "thara", " tory", "stro", "starro", "retaco", "toa", "staco", "ttosa", "staro", "tolan", "Tro", " tosa", " taco", "ktarro", "ktrar", "Taro", "qtolan", "tary", "retara", "thamo", "tamo", "ttamo", "qtaro", "qtory", "tharo", "stoa", "Tara", " tamo", "tempro", "maro", "waro", "ktara", "tara", "targo", "tosa", "tory", "tharro", " tro", "Tory", "ktaro", "troa", "Tolan", "Targo", "traro", " tary", "thosa", "tempamo", "taco", "margo", "tempargo", "retaro", "stary", "mro", "wargo", " targo", "wro", " trar", "stamo", "stargo", "Tarro", "qtro", "thrar", "trary", " tolan", "tarro", "marro", " tara", " toa", "trro", "warro", "ttara", "retamo", "trar", "Taco"], "path": ["full", "project", "m", "w", "ath", "c", "h", "url", "ref", "pi", "PATH", "history", "binding", "name", "p", "print", "doc", "transform", "clean", "th", "mount", "ex", "local", "string", "pattern", "core", "kind", "root", "Path", "parts", "file", "entry", "key", "text", "chain", "dir"], "base": ["full", "shadow", "bad", "ase", "b", "bare", "based", "default", "bf", "prefix", "pad", "Base", "part", "parent", "check", "common", "build", "binding", "name", "buffer", "normal", "reset", "padding", "basic", "create", "start", "extra", "relative", "alias", "template", "server", "bas", "root", "db", "absolute", "file", "family"], "f": ["perm", "fed", "far", "ft", "t", "w", "fab", "df", "b", "c", "fp", "F", "h", "o", "fm", "bf", "alf", "e", "life", "inf", "fe", "fb", "v", "y", "p", "uf", "l", "fl", "r", "rf", "sf", "fo", "fs", "fx", "g", "cf", "fc", "lf", "fac", "i", "fr", "elf", "form", "af", "file", "tf", "fi", "fd", "fg", "xf", "fa", "d"], "entryName": ["EntryKey", " entryLetter", "elementPath", "rowLetter", "rowType", "cueType", "elementKey", "ryLetter", "elementname", "ryname", "EntryType", "cueName", "entryLetter", "rowName", " entryname", "ryName", "entryKey", "entryname", "Entryname", "cueKey", " entryKey", "EntryPath", "elementName", "EntryName", "cuename", "entryPath", "rowname", "ryType", " entryPath", " entryType", "entryType"], "goIn": [" goOut", "geIns", "GoIns", "Goin", "moin", "GoIn", "goOut", " goIN", "goIN", "moIn", "poin", "GoOut", "moIN", "goIns", "moIns", "moInput", "poIn", "GoIN", "poOut", "poIN", "geInput", " goIns", " goInput", " goin", "gein", "geIn", "goin", "goInput"], "tarEntry": ["warComponent", "warItem", "warEntry", "tarComponent", "tarItem", " tarEnt", "tarEnt", "tarentry", "rarComponent", "carentry", "rarItem", "carCategory", "tarCategory", " tarComponent", "carEnt", " tarItem", " tarCategory", "rarentry", "warEnt", "carEntry", "rarCategory", "rarEnt", " tarentry", "rarEntry"], "children": ["modules", "each", "packages", "cloud", "kids", "jobs", "pages", "resources", "balls", "batch", "ls", "aos", "roots", "hawks", "files", "many", "parent", "ml", "they", "cs", "users", "these", "items", "blocks", "cache", "members", "fs", "los", "Children", "groups", "gall", "objects", "follow", "all", "keys", "ports", "stories", "json", "reports", "wn", "names", "ul", "ren", "ll", "parents", "ps"], "child": ["row", "pixel", "zip", "close", "c", "ch", "batch", "block", "parent", "count", "name", "cell", "id", "label", "client", "last", "l", "background", "cache", "q", "follow", "page", "lf", "shell", "char", "ph", "Child", "brother", "friend", "fr", "uncle", "comment", "file", "fd", "ll", "job", "entry", "key", "cow", "handle", "col"]}}
{"id1": "19520541", "id2": "2398448", "code1": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"getDirectoryListing": ["getFileListING", "getFilelistings", "getFileListList", "getDirectoryProcessning", "getDirectoryLning", "getFileListings", "getDirectorylistList", "getDirectoryListning", "getDirectoryLging", "getDirectoryListging", "getFilelistning", "getFilelistList", "getDirectoryProcessing", "getDirectoryProcessList", "getFileListging", "getDirectoryLing", "getDirectoryListList", "getDirectoryListings", "getDirectorylistging", "getFilelisting", "getDirectoryLings", "getDirectorylisting", "getFilelistING", "getDirectorylistings", "getFileListning", "getDirectoryProcessING", "getFilelistging", "getDirectorylistING", "getDirectorylistning", "getFileListing", "getDirectoryListING"], "url": ["ret", "pl", "domain", "sql", "bel", "ur", "u", "null", "err", "http", "hl", "link", "b", "https", "un", "il", "path", "back", "ref", "ls", "host", "base", "gl", "get", "util", "github", "it", "ml", "build", "address", "id", "name", "this", "uri", "l", "log", "sl", "r", "f", "print", "call", "rl", "nl", "cl", "q", "fl", "str", "request", "mount", "rel", "location", "ssl", "string", "all", "server", "kl", "Url", "web", "mail", "html", "ob", "addr", "ul", "el", "xml", "loc", "job", "ll", "dl", "key", "cert", "URL"], "CancelledOperationException": ["CanceuledOperation ", "CancelledActionException", "CancelledOperationWarning", "CancelledRequestWarning", "CanceuledRequestException", "CancelledRuntimeError", "CancelledRequestError", "CancelledRuntimeWarning", "CancelledRuntime ", "CanceuledOperationError", "CancelledActionError", "CancelledOperationError", "CancelledAction ", "CancelledRequestException", "CanceuledOperationException", "CancelledOperation ", "CancelledRuntimeException", "CanceuledRequestError", "CancelledActionWarning", "CanceuledRequest ", "CancelledRequest ", "CanceuledOperationWarning", "CanceuledRequestWarning"], "file": ["info", "full", "project", "module", "File", "null", "ile", "FILE", "length", "table", "fp", "path", "base", "part", "use", "address", "name", "id", "message", "buffer", "image", "resource", "uri", "print", "f", "folder", "source", "local", "string", "title", "page", "template", "class", "body", "web", "db", "task", "comment", "data", "size", "format", "family", "key", "filename", "handle", "dir"], "userInfo": ["UserInf", "verInfo", " userInf", "UserInfo", "USERStatus", " userStatus", "userData", "usernameInfo", "userinfo", "authorInf", "userINFO", "Userinfo", "usersData", "USERInfo", "verINFO", "authorInfo", "usernameStatus", " userData", "userInf", "verData", "userStatus", "usersINFO", "UserINFO", "usernameINFO", " userinfo", "usersInfo", "USERINFO", "UserData", "verInf", "usersInf", "authorinfo", "authorData", " userINFO"], "urlConnection": ["dbLine", "xmlConnection", "urlConnect", " urlConnect", " urlconnection", "jsonConnection", "xmlConnect", "fileCurrent", "jsonconnection", "fileConnector", "xmlconnection", "fileConfiguration", "urlCurrent", "httpConnector", "implConnection", "httpconnection", "implLine", "httpConn", " urlLine", "cmdConnector", "urlLine", "httpCurrent", "urlAction", " urlAction", "cmdConnection", "httpConfiguration", "xmlCurrent", "jsonConnect", "userConfiguration", "urlConn", " urlCurrent", "implconnection", "cmdConn", "httpAction", "urlConfiguration", "jsonAction", "fileConnection", "urlconnection", "dbConnector", "httpConnect", "dbconnection", "userConnector", "implConnector", "fileConnect", "fileConn", "userConnection", "httpConnection", "dbConnection", "urlConnector", "cmdConnect", "userCurrent", " urlConnector"], "encode": ["enableify", " enCode", " enize", "Enpack", "enccode", "encCode", " enify", "Enode", "enode", "enize", "Encode", "enCode", "encify", "enableode", "enablecode", "enify", " enode", "enpack", " enpack", "encize", "EnCode", "encpack", "enableize"], "urlStream": [" urlSteam", "rowWindow", "fileSteam", "rowStream", "logstream", "httpstream", "urlSteam", "logStreamer", "urlstream", "xmlStream", " urlStreamer", "inputSteam", "urlStreamer", "httpStream", "UrlSteam", "rowConnection", "urlWindow", "logStream", "inputStreamer", "xmlstream", "fileConnection", "rowSteam", "UrlStream", "fileWindow", "httpSteam", " urlstream", "fileStream", "Urlstream", " urlWindow", "xmlSteam", "UrlStreamer", "inputstream", "xmlStreamer", "httpStreamer", "inputStream", "logSteam"]}}
{"id1": "21642215", "id2": "7846688", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"addIDs": [" addNames", "setIDS", "setNames", "processIDS", "processNames", "addID", "setID", " addIDS", "processID", " addID", "setIDs", "addIDS", "addNames", "processIDs"], "row": ["record", "item", "ack", "rank", "table", "rows", "batch", "raw", "pair", "block", "board", "error", "cell", "list", "ow", "buffer", "post", "ows", "group", "report", "skip", "week", "r", "out", "node", "user", "ro", "roll", "instance", "tr", "star", "Row", "rown", "ry", "box", "channel", "job", "entry", "col", "result"], "name": ["NAME", "item", "text", "Name", "path", "key", "a", "prefix", "version", "value", "address", "question", "image", "password", "source", "n", "create", "named", "title", "search", "string", "template", "word", "query", "ame", "description", "file", "format", "type", "label", "filename"], "in": ["gin", "m", "sql", "re", "t", "vin", " IN", "update", "nin", "il", "mc", "get", "up", "cin", "it", "on", "check", "inf", "ini", "inn", "ain", "er", "ins", "s", "l", "rin", "log", "ic", "reader", "r", "pin", "inc", "conn", "out", "al", "source", "scan", "n", "ln", "IN", "local", "ex", "win", "init", "copy", "en", "bin", "ssl", "inner", "isin", "con", "input", "again", "conf", "din", "i", "db", "at", "el", "xml", "form", "file", "is", "serv", "In"], "urlName": ["UrlNAME", " urlNames", "urlNAME", "logname", "logNAME", "lPath", "urlname", "lKey", "logKey", "implname", "urlPath", "Urlname", "implNames", "UrlName", " urlNAME", "lNAME", "implNAME", "lName", "implName", "logName", " urlname", "urlKey", "UrlNames", "UrlKey", " urlPath", "lNames", "implPath", "urlNames", "lname"], "url": ["ret", "ur", "t", "http", "link", "b", "il", "ref", "ls", "base", "gl", "client", "resource", "l", "uri", "sl", "r", "nl", "reader", "rl", "cl", "loader", "str", "rel", "mount", " URL", "ssl", "result", "con", "char", "Url", "web", "ul", "el", "file", "ll", "channel", "open", "URL", "browser"], "inputLine": [" inputFrame", "listLine", "inputL", "singleLine", " inputPage", "dataFrame", "InputL", "operationLINE", "viewLine", "intLin", " inputEntry", "tableLink", "statusLINE", "intLine", "inL", "statusline", " inputPort", " inputLin", "dataLink", "InputFile", "patternLINE", "sourceLine", "inputNet", "firstBlock", "inputLINE", "latRecord", " InputLine", " inputRecord", "InputLINE", "formBlock", "dataPort", "inputline", "InputRow", "latline", " InputLINE", "latLINE", "intBlock", "commandBlock", " inputRow", "tableLINE", "tableLine", "statusLine", " inputLINE", "submitLine", "inputLin", "dataNet", "inputPort", " inputFile", "submitBlock", "statusFile", "inputDe", "inLine", " inputLink", "cacheNode", "commandLine", "sourcePage", "listLINE", "inputFile", "contextLine", "inputPage", " inputBlock", "keyL", "latLine", "inputBlock", "patternLine", "helloEntry", " inputNet", "inputNode", "patternline", "Inputline", "operationLine", "inputRecord", "tempLINE", "InputBlock", "dataBlock", "singleDe", " InputLin", "templine", "dataFile", "cachePage", "helloLine", "dataline", "keyLINE", "contextRow", "sourceLINE", "dataLine", "operationNet", "listEntry", "formLINE", "inputLink", "singleLINE", "submitLINE", " inputDe", "inputEntry", "viewRow", "intline", "formFrame", "inputRow", "tablePort", "helloPort", "firstLINE", "cacheLINE", " Inputline", "patternRow", "inline", "keyline", "sourceNode", "firstLine", "viewLINE", "inputFrame", "singleBlock", " inputline", "commandLINE", "cacheLine", "inLINE", "contextLINE", "listPort", "keyLine", "submitDe", "intLINE", "formLine", "inRecord", "helloLINE", "dataLINE", " inputNode", "tempLine", "InputLine"], "score": ["sc", "err", "goal", "confidence", "length", "rank", "success", "weight", "value", "count", "check", "level", "scale", "error", "rate", "message", "grade", "report", "loss", "strength", "depth", "scoring", " Score", "scroll", "source", "scan", "test", "set", "distance", "search", "style", "price", "core", "average", "index", "sum", "draw", " scores", "Score", "match", "display", "status", "result"], "metaboliteID": ["metaboliteId", "metabolteUID", "metabolitateInfo", "metaboliceId", "metabiliterName", "metabolicitationID", "metabiliterid", "metaboliterId", "metaboliteid", "metabolicitationid", "metabolitionName", "metabolitationType", "metaboliterName", "metabiliteUID", "metabiliteid", "metabolitableId", "metabolteID", "metabolitateID", "metmbolitationID", "metabolicitationInfo", "metmboliteIN", "metabiliterHandle", "metaboliterHandle", "metaboliciteType", "metabolitationId", "metaboliterID", "metaboliteHandle", "metaboliciteName", "metabolitationID", "metabiliteId", "metabolisticIN", "metaboliciteID", "metabolITEID", "metmbolitationId", "metaboliceid", "metmbolitationIN", "metabolisticID", "metabolitateId", "metabolitionid", "metabolitesid", "metabolitationIN", "metabolicITEName", "metaboliterUID", "metabolitionID", "metabolitationName", "metabolitationid", "metabolITEType", "metabiliteID", "metabolitableUID", "metaboliterIN", "metabiliteName", "metaboliciteId", "metabolisticId", "metaboliteInfo", "metabolitateid", "metabolITEName", "metabolITEId", "metaboliteType", "metaboliceID", "metaboliciteid", "metaboliteName", "metabiliterUID", "metabolicITEType", "metabolteId", "metaboliterType", "metabolteHandle", "metabolitesName", "metabolicITEID", "metaboliterid", "metmboliteID", "metabolitableID", "metabolicitationId", "metaboliciteInfo", "metabolicITEId", "metabiliterId", "metaboliteIN", "metabolitableHandle", "metaboliceInfo", "metabolitesID", "metabiliterID", "metabolitationInfo", "metmboliteId", "metabiliteHandle", "metaboliteUID"], "dataScore": [" dataSpeed", "parentTest", "dataTransfer", "dataAge", "dataStyle", "deviceTransfer", "relationScore", "arrayScore", " datascore", "relationWeight", "relationSize", "datascore", "arrayStyle", "blockSpeed", "arrayAge", "errorscore", "parentRank", "relationscore", "tdScore", "arraySpeed", "blockSc", "DataScore", "deviceSize", "arraySc", " dataTransfer", "DataSize", " dataWeight", " dataSc", "blockScore", "ataSc", " dataRank", "parentScore", "divSc", "dataSpeed", "DataRank", "deviceSc", "DATARank", "DataSc", "errorSize", "dataSc", "ataScore", "dataSize", "ataTransfer", "dataRank", "divRank", "errorWeight", " dataSize", "DATATest", "dataTest", "DATASc", "DATAScore", "divSize", "parentSc", "dataWeight", "tdAge", "blockStyle", "errorScore", "deviceScore", " dataTest", "ataSize", "tdSc", " dataStyle", " dataAge", "divScore"], "data": ["info", "hex", "details", "words", "ata", "params", "table", "mu", "zero", "supported", "DATA", "batch", "base", "raw", "results", "value", "none", "valid", "available", "rew", "space", "ns", "buffer", "image", "users", "values", "map", "content", "cache", "lines", "window", "video", "set", "step", "dat", "extra", "missing", "td", "string", "keys", "all", "json", "draw", "hash", "html", "bytes", "description", "size", "array", "text", "chain", "multiple", "series"], "molecularWeight": ["moleularData", "molellularweight", "molellularWeight", "mleularweight", "moleudoScore", "moleculeFont", "molecularScore", "moleudoWeight", "molecularData", "mlecularData", "molecularWater", "moleularweight", "moleularWater", "mleularScore", "mlecularWeight", "mlecularweight", "moleculeWeight", "molecularFont", "moleularWeight", "moleuralScore", "mleularFont", "mleularWater", "mlecularWater", "moleuralWater", "moleculeData", "molellularData", "mlecularScore", "mleularWeight", "moleculeweight", "mleularData", "moleularFont", "molellularFont", "mlecularFont", "moleularScore", "moleudoWater", "moleuralWeight", "molecularweight"]}}
{"id1": "9449064", "id2": "7948308", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 0, "substitutes": {"readExp": ["readProp", "ReadLoc", "checkexp", "passExp", " readEXP", " readEx", "Readexp", "readExpress", "readerProp", "readEXP", " readExpress", "readerExp", "readExpl", "ReadEXP", "ReadExp", "readerEXP", "readEx", "readerexp", " readProp", "checkExpress", "checkExpl", "passExpress", "ReadEx", "readerEx", "readerLoc", "passexp", "readexp", "ReadProp", "checkExp", " readLoc", " readexp", "readLoc", " readExpl", "passExpl"], "writeExp": [" writeexp", "writExp", "applyEx", "applyEXP", "riteExp", "riteEv", "writeEv", "applyExp", "writEXP", " writeEXP", "updateExt", " writeReg", "writeConf", " writeExt", "writeEXP", "writexp", "riteEXP", "riteexp", "riteConf", " writeXP", "updateExp", " writeEx", "writeEx", "riteExt", "writConf", "updateReg", "writeExt", "applyXP", " writeConf", "writeexp", "writeReg", "riteReg", "writXP", " writeEv", "writEx", "updateEv", "writeXP"], "expFile": ["exFiles", "expField", "xpName", "mxFilename", "exprName", "Expfile", "xpFiles", " expPlace", "exFilename", "exprFILE", "repPath", "xpField", "mxName", "ExpFile", "expName", "exFile", "expFilename", "ExpDir", "repFILE", "expDir", "xpFile", "repField", "mxFILE", "exprDir", "expFILE", "exprFile", "docField", "exFILE", "expPlace", "xpFilename", "expfile", "expFiles", " expFiles", "docPath", "xpPath", "xpfile", "exprfile", " expDir", "repFile", " expfile", "mxFile", "docFILE", " expFilename", "exfile", " expFILE", "docFile", "expPath", "exprFilename", "xpFILE", "docPlace", "docFilename", "exPlace"], "exp": ["rep", "pl", " est", " resp", "ox", "sc", "eps", " expansion", "ent", " exc", "expression", " disp", " exponent", "pp", "resp", "zero", "opt", "wx", " extr", " expand", "esp", "dem", "lim", "expr", " lim", "acc", "raw", "inf", "eq", " imp", "xp", "expl", " xp", "isp", "obj", "f", " op", " np", " ep", "ev", "plus", "nz", " sc", " vec", " inst", " ne", "Exp", "prov", "ez", " expr", "comm", "def", "push", "jp", " doc", " rap", "ef", " ev", "imp", "ext", "bed", "pr", "comp", "inst", "EXP", " expanded", "ps", " dj"], "fi": ["ico", "obi", "eric", "ffe", "ci", "phi", "gi", "ii", "qi", "uci", "mi", "ti", "ati", "aci", "pi", "wi", "osi", "isi", "ini", "fe", "zi", "uti", "flo", "zo", "abi", "Fi", "iri", "ni", "cci", "si", "lf", "ki", "ri", "FI", "li", "i", "ista", "fif", "fty", "xf", "ei", "fa"], "oi": ["ico", "obi", "eric", "ci", "ivo", "ii", "uci", "oin", "igi", "mi", "ti", "ati", "osi", "isi", "ini", "uta", "uti", "flo", "multi", "io", "vi", "obo", "ovi", "iri", "ta", "ori", "uo", "ni", "bi", "odi", "ki", "ri", "ita", "iso", "i", "asi", "oa", "ami", "rio", "eni", "ink", "oni", "bis", "ei", "avi"], "jf": ["jjF", "gc", "bjf", "Jxf", "jjfm", "jjfp", "jcb", "Jfx", "Jbf", "Jfd", "bjfm", "jfc", " jc", " jif", "bjfp", "Jif", "djxf", "jcfm", " jv", "jsxf", "jbf", "JF", "Jsf", " jsf", "jsbf", "jfx", "gfc", "bjv", "jssf", "jjf", "jjv", " jfm", " jF", "Jb", " jb", "jF", "jfm", "jackf", "gf", "jjif", "djf", "djbf", "djfd", "jxf", " jfx", "jackxf", "jackfd", "jcsf", " jxf", "gfm", "jjfc", "Jf", "jb", "jcxf", "jfd", "jackbf", " jfc", " jbf", "jcf", "jv", "jjc", "jfp", " jfp", "jsf", "jif", "jcfx", "jc", "Jfm"], "sp": ["rep", "pl", "sc", "spe", "pp", "span", "esp", "se", "space", "sh", "cp", "spl", "p", "isp", "pb", "op", "spr", "sw", "sf", "sam", "sm", "asp", "lp", "sv", "Sp", "st", "vp", "sb", "osp", "sg", "si", "ep", "jp", "par", "bp", "SP", " esp", "sk", "so", "tp", "bsp", "ap", "ps", "pt"], "e": ["m", "re", "t", "w", "ee", "a", "it", "ed", "fe", "name", "v", "p", "er", "s", "f", "ev", "x", "E", "n", "pe", "ie", " ev", "i", "el", "event", "d"], "fo": ["ico", "po", "hea", "tif", "lo", "ti", "o", "wi", "opa", "oe", "bo", "zo", "tto", "flo", "uf", "io", "obo", "ato", "uo", "cf", "aco", "ro", "eno", "oos", "ki", "olf", "wo", "fif", "wt", "folio", "tf", "co", "so", "mo", "xf", "fa", "FO", "ooo"], "oo": ["ico", "cro", "ox", "olo", "po", "ollo", "goo", "lo", "OO", "o", "opa", "oid", "oe", "oes", "ora", "bo", "flo", "zo", "obo", "ato", "elo", "ao", "ta", "uo", "oco", "ero", "aco", "ro", "aha", "oos", "ko", "oto", "yo", "ano", "oooo", "wo", "oa", "folio", "ola", "ilo", "co", "so", "mo", "oooooooo", "foo", "ooo"], "ex": ["hex", "rex", "re", "six", "ox", "err", "px", "ax", "spe", " exc", "EX", "wx", "or", "none", "su", "exe", "es", "sex", "ic", "log", "pex", "Exc", "x", "example", "aux", "pers", "except", "de", "act", "tex", "iox", "cre", "ctx", "def", "exc", "ext", "com", "te", "ix", "ry", "nex", "el", "xe", "des", "external", "tx", "ac", "ception", "lex", "status", "event", "Ex"]}}
{"id1": "18211588", "id2": "18974466", "code1": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copyTextFile": [" copiedTextSourceFile", " copyFilePhoto", " copyRemoteFile", " copyFileFile", " copyStringSourceFile", " copyFileSourceFile", " copyTextSourceFile", " copyRemotePhoto", " copyTextPhoto", " copyStringFile", " copiedTextPhoto", " copiedRemotePhoto", " copyRemoteSourceFile", " copiedRemoteFile", " copyStringPhoto", " copiedTextFile", " copiedRemoteSourceFile"], "src": ["sit", "rt", "sc", "upload", "bs", "sel", "rc", "ser", "sq", "ins", "req", "sf", "rl", "cur", "source", "js", "st", "from", "rs", "txt", "sb", "rx", "sn", "start", "iris", "ctr", "init", "iv", "dest", "sec", "input", "usr", "sin", "sr", "via", "sys", "Source", "inst", "ipl"], "dst": ["Dnd", "pgt", "ldest", "lst", "bnt", " dnt", "lgt", "dnt", "lnd", "pst", "dgt", "ddest", "Ddest", "dnd", "bnd", " ddest", "Dgt", "pdest", "bst", " dnd", "pnd", "bdest", "Dnt", "Dst"], "bis": ["fits", "sit", "bh", "lbs", "bs", "stri", "oi", "mi", "bes", "lis", "cin", "bf", "ios", "isi", "bps", "zo", "mos", "pins", "vi", "pin", "bits", "bid", "fs", "los", "mis", "bi", "iris", "nis", "onis", "lin", "isin", "ubis", "ri", "sin", "ris", "bil", "conv", "pse", "oss", "is", "ais", "webkit", "opus", "cos", "avi", "obs"], "bos": ["rots", "os", "ms", "bh", "bones", "bs", "oops", "eros", "ls", "bes", "aos", "ios", "base", "tes", "soc", "boards", "mus", "bol", "uts", "ts", "bo", "zo", "vas", "ows", "mos", "pins", "bits", "fs", "los", "bi", "ods", "BS", "acs", "ols", "bin", "oos", "ubis", "bas", "jas", "oss", "uds", "sys", "nos", "bytes", "cos", "dos", "obs"], "buf": ["bg", "buff", "b", "cap", "mu", "pkg", "ref", "batch", "raw", "block", "nm", "Buffer", "cp", "vec", "fb", "buffer", "uf", "log", "begin", "tab", "var", "cur", "Buff", "seq", "cf", "cmd", "bl", "cat", "good", "act", "feat", "bag", "bin", "cam", "rb", "img", "br", "conv", "db", "cb", "norm", "cv", "bytes", "box", "msg", "data", "gen", "tx", "fg", "bus", "prop", "arr"], "readsize": ["READscope", "READsize", "lengthsize", " readSize", "writelen", "readneeded", " readscope", "READnumber", " Readscope", "Readsize", " Readsize", "readscope", "lengthlength", "lengthlen", "lengthSize", " readcount", "writeSize", "readlen", " readlength", "READSize", "writelength", "readnumber", " readnumber", "writesize", " readneeded", "Readnumber", " ReadSize", "READneeded", "Readcount", "ReadSize", "readcount", "readlength", " Readneeded", " readlen", "READcount", "readSize"]}}
{"id1": "4593011", "id2": "810342", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"loadDDL": ["readDDDL", "loadPDL", "loadDDDL", "readDDL", "loadPDLS", "loadSDDL", "loadDSLS", "loadSDLS", "readPDl", "readPDDL", "readDDl", "loadPDl", "loadDDLS", "readPDL", "loadDSl", "loadPDDL", "readDDLS", "loadSDL", "loadSDl", "readPDLS", "loadDSL", "loadDDl", "loadDSDL"], "stmt": ["sttr", " Stmt", " stdo", " superstMT", "tmt", "Stmm", "strmb", " Stm", " stmb", "steMT", "strmn", "STmt", "strmt", " stm", "Sttr", "STMT", "strMT", "ttr", " Stpt", "stm", "tMT", "sttx", " stMT", "stem", " sttr", "StMT", "Stdo", "Stm", " stmn", "tmm", "stMT", "stmb", " stmm", " superstmt", "stedo", "Stmn", "STtx", " superstm", " stpt", "stmm", "Stmb", "Stmt", " sttx", " superstpt", " StMT", "STm", "stmn", "stemt", "stpt", "stdo", "Sttx"], "qry": ["qries", "Qrys", " qries", "sqries", "qri", "sqri", "quries", "Qri", "quri", "qutry", " qtry", "qrys", "sqtry", "qtry", " qri", " qrys", "Qry", "Qries", "qury", "sqry", "sqrys"], "q": ["iq", "m", "u", "dq", "t", "z", "w", "j", "c", "qi", "pkg", " sq", "h", "o", "e", "quest", "sq", "Q", "v", "p", "y", "l", "k", "f", "n", "g", "qv", "qt", "query", "i", "ry", "qa", "qu", "qq", "qs", "ql", "d"]}}
{"id1": "5620792", "id2": "8064604", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"SHA1": [" SHAOne", "SHA2", "sha1", "HS1", "shaOne", "sha2", "HS256", "SHA256", " SHA256", " SHA2", "HS2", "sha256", "SHAOne", "HSOne"], "text": ["Text", "t", "read", "document", "cont", "path", "url", "TEXT", "prefix", "value", "ct", "name", "message", "password", "print", "content", "out", "q", "term", "str", "source", "select", "code", "test", "txt", "output", "act", "string", "pattern", "template", "input", "word", "current", "nt", "ext", "config", "form", "comment", "data", "msg", "subject", "tx", "translation", "key", "event", "pt"], "HASH_VALUE_SIZE": ["HASH_VALUE_NO", "HASH_VALUE_NAME", "HASH_value_SIZE", "HASH_VALUE_Size", "HASH_VAL_SIZE", "HASH_value_TYPE", "HASH_VALUE_SOURCE", "HASH_VALUE_TYPE", "HASH_VAL_NAME", "HASH_VALUE_DIR", "HASH_value_DIR", "HASH_VAL_NO", "HASH_value_SOURCE", "HASH_VAL_Size"], "md": [" ms", " ma", "mod", "m", "ms", " mm", " dd", "ad", "det", "df", "pd", "ld", "mode", "mk", " man", "dh", "h", "mc", "mond", "hm", "nd", "add", "MD", " del", "cond", "ind", "rm", "dig", "cd", "mn", "mt", "od", "bd", "mb", " mo", "sm", " mc", "mg", "sd", "js", " sd", "cmd", "dm", "mm", "ctr", "metadata", "td", "ds", "and", "der", " rm", "hd", " Md", " cd", "mand", "grad", "mp", " cmd", "dd", "dir", "d"], "sha1hash": ["ha1Hash", " SHA1hash", " SHA31have", "sha2hex", "ha2Hash", "SHA1hex", "sha2str", "shaoneresult", "shaoneHash", "ha2result", "sha1sum", "SHA1hash", "sha7Hash", "sha5hash", "sha7str", "SHA2hex", "ha1sum", "sha1str", "ha2sum", "sha3str", "SHA2Hash", "sha2result", "sha31sum", " SHA31hash", "sha1hex", "sha31have", " SHA31value", "shaonesum", "sha5have", "ha2hash", "SHA1str", "shaonehash", "sha5sum", " SHA1have", " SHA31sum", "SHA2str", "sha31hash", "sha3hash", "sha7hex", "sha2hash", "sha31value", "sha1value", "sha2sum", "SHA1Hash", "sha3Hash", " SHA1value", "sha3hex", "sha1have", "ha1result", "sha7hash", "SHA2hash", "sha2have", "sha1Hash", "ha1hash", " SHA1sum", "sha5value", "sha2Hash", "sha2value", "sha1result"]}}
{"id1": "822452", "id2": "23452437", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "13595251", "id2": "12766394", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"descargarArchivo": [" descargoMotive", " descargarActiv", " descargarArchico", " descargoMotico", " descargarMotiv", " descargoArchico", " descargoArchivo", " descargarRico", " descargarArchive", " descargarMotico", " descargarActive", " descargarRive", " descargoMotiv", " descargarActivo", " descargarRiv", " descargarArchiv", " descargarActico", " descargarMotivo", " descargarMotive", " descargoArchiv", " descargoArchive", " descargoMotivo", " descargarRivo"], "fis": ["dfos", "Fos", "ufris", "ufos", "ffris", "fiiss", "fiix", "fiios", "Fris", "fix", " fios", "fiss", " fris", "dfris", " fiss", "fios", "ffix", "dfiss", "fiis", "ffos", "ufiss", "ffis", " fix", "Fiss", "ffios", "dfis", "ufis", "Fis", "fris", "ffiss"], "fos": ["voes", "foes", " foes", "fedbos", "fOS", " fows", "infos", "fows", "woses", "flos", "fedos", "lfoses", "wos", "wows", "waos", "fedOS", "woss", "floses", "flaos", "wbos", "flbos", "lfos", "fbos", "infOs", "faos", " foss", " fOS", "voss", "lfbos", "lfaos", " fbos", "vos", "vows", "fedOs", " fOs", "foss", "infbos", "woes", "foses", "infOS", "fOs"], "inChannel": ["aichannel", "inchannel", "innChan", "innerButton", "inputChan", "inputGray", "inButton", "aiRow", "inConnection", "outRow", "initChan", "inRow", " inchannel", "inputConnection", "innRow", "initChannel", " inChan", "aiChannel", "innerChannel", "InButton", " inButton", "innerChan", "innchannel", "initConnection", "aiChan", "outchannel", "initGray", "inputChannel", "InGray", "InChan", "inGray", "outChan", "innChannel", "Inchannel", "inChan", "InConnection", "innerchannel", "InChannel"], "outChannel": ["inchannel", "OUTChan", "inButton", " outButton", "OUTStream", "OUTConsole", " outConsole", " outStream", "outStream", "OUTButton", "OUTchannel", "outButton", "outchannel", "inConsole", "OUTChannel", "outConsole", " outChan", " outchannel", "outChan", "inStream", "inChan"]}}
{"id1": "4618237", "id2": "13063241", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFile2Disk", "writeFileAsStream", "writeFile2Files", "writeFilesToDisk", "writeFileAndFile", "writeFileToFiles", "writeFilesToFile", "writeFileToDisk", "writeFiles2Stream", "writeFileAsDisk", "writeFileAndDisk", "writeFile2Stream", "writeFileToStream", "writeFiles2Files", "writeFilesToStream", "writeFileAndFiles", "writeFileAsFile", "writeFileAsFiles", "writeFile2File", "writeFilesToFiles", "writeFiles2File", "writeFileAndStream", "writeFiles2Disk"], "fin": ["Fin", "details", "in", "fn", "lo", "mid", "fw", "syn", "fp", "ini", "fur", "normal", "mn", "raf", "ic", "rin", "focus", "f", "rf", "fl", "kin", "n", "ln", "fc", "init", "lin", "en", "lf", "irm", "din", "FIN", "inv", "fil", "fr", "jen", "han", "mil", "fre", "fd", "fi", "ran", "fa"], "fout": ["tOut", "Fin", " fpo", "kpo", "FOut", "ffOut", " foutput", " fOut", "fbout", "fou", "Fout", "ffou", "fboutput", "ffin", "ffout", "koutput", "fbpo", "fbOut", "kOut", "foutput", "kout", "tout", "tin", "fOut", "Fou", "fpo", "tou"], "append": ["join", "equal", "pend", "send", "note", "update", "allow", "buff", "include", "end", "grow", "batch", "add", "bold", "flat", "ind", "ended", "animate", "seed", "folder", "express", "apply", "vert", "replace", "csv", "string", "push", "printf", "app", "ext", "ends", "force", "absolute", "insert", "fail", "command"], "inChannel": ["inchannel", "rinCategory", "iChannel", "inListener", "inputChan", "inButton", " inStream", "iCommand", "inCommand", "intClient", "inConnection", "intChan", "pinMachine", "outCommand", "iChan", " inCategory", "insideChan", " inchannel", "sinChannel", " inListener", "pinCategory", "InStream", "rinChannel", "intChannel", "rinListener", "inCategory", " inChan", "sinButton", "pinButton", " inConnection", "innButton", "iStream", "insideSession", "sinMachine", "outConnection", "insideClient", "inputListener", "InConnection", "rinChan", "outStream", " inCommand", " inSession", "intSession", "outchannel", "pinChannel", "inSession", "inClient", "inputCategory", "inputChannel", "innMachine", "outChan", "innCategory", "innChannel", "inMachine", "inStream", "inChan", "Inchannel", "sinCategory", "insideChannel", " inClient", "InChannel"], "outChannel": ["outCh", "inchannel", "invCh", "invChannel", "outMember", "nameChan", " outController", "netChannel", "OUTChan", "invMember", " outScope", "outScope", " outConnection", "nameConnection", "outputConnection", "netMember", "outController", "userCh", "outputScope", "netController", "outputCh", " outCh", "userMember", "outputChan", "netchannel", "outConnection", "netChan", "inCh", "nameScope", "userChannel", "OUTchannel", "outchannel", "OUTChannel", "outputChannel", "outputchannel", " outChan", "nameChannel", " outchannel", "outChan", "netCh", "inChan", "OUTController"]}}
{"id1": "17522011", "id2": "6840241", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["info", "process", "text", "Read", "link", "parse", "run", "close", "open", "get", "stream", "it", "raw", "rd", "required", "reflect", "check", "build", "php", "READ", "resource", "report", "print", "req", "reader", "readable", "content", "sync", "write", "transform", "select", "test", "iter", "create", "find", "input", "word", "show", "config", "walk", "reading", "view", "file", "hello", "format", "download", "reads", "handle", "load"], "classLoader": ["moduleLoader", "moduleloader", "ClassLoading", "ClassReader", "ClassPath", "fileManager", "thisLoader", " classManager", "fileReader", "thisloader", "moduleReader", "classReader", "classPath", "classManager", " classPath", "fileLoader", "Classloader", "fileLoading", " classReader", "ClassLoader", "ClassManager", "classLoading", "thisPath", "classloader", " classloader", " classLoading", "thisReader", "moduleLoading"], "name": ["m", "NAME", "null", "Name", "old", "path", "ref", "key", "base", "prefix", "nm", "part", "parent", "common", "id", "message", "resource", "password", "l", "source", "n", "order", "local", "named", "missing", "title", "string", "alias", "search", "word", "current", "root", "names", "ame", "description", "file", "size", "family", "type", "label", "filename"], "all": ["full", "m", "each", "null", "active", "empty", "also", "total", "collection", "default", "All", "none", "many", "valid", "required", "list", "enabled", "multi", "both", "only", "n", "local", "allowed", "ALL", "optional", "oll", "first", "force", "latest", "global", "always", "loop", "and", "multiple", "attribute", "any"], "sm": ["m", "ms", "hem", "sem", "arms", "mph", "hm", "pm", "ism", "mem", "bm", "nm", "sp", "arm", "sym", "wm", "imm", "md", "mn", "mt", "km", "mb", "sam", "sf", "mg", "asm", "dm", "sy", "mm", "sbm", "rpm", "igm", "sim", "gm", "esm", "cm", "ym", "tm", "sk", "Sm", "model", "SM", "tem", "rm", "shell"], "enu": ["eru", "atteniu", " enus", "eniu", "denuu", " enui", "Enui", "Encu", "enpu", "attenuu", "ennu", "annu", "encu", "enui", "denu", "erpu", "erui", "Enu", " encu", "ancu", "Enus", "enuu", " enpu", "EnU", " ennu", " enuu", " eniu", "attenu", " enfu", "anu", "Ennu", "deniu", "anus", "Enpu", "attenfu", "enU", " enU", "enus", "denfu", "erU", "enfu"], "url": ["pl", "bel", "ur", "http", "link", "b", "pkg", "il", "path", "ref", "ls", "open", "base", "gl", "add", "sp", "build", "v", "resource", "ol", "l", "uri", "f", "sl", "r", "nl", "log", "rl", "mount", "rel", "user", "bl", "sb", "arl", "char", "Url", "web", "db", "ob", "ll", "dl", "job", "key", "cert", "URL", "browser", "net"], "is": ["was", "ms", "sis", "os", "isl", "im", "in", "gc", "bs", "vs", "mi", "ls", "lis", "has", "ios", "it", "isi", "its", "ism", "isc", "tis", "es", "ps", "iss", "mus", "obs", "ins", "rest", "isf", "mos", "bits", "out", "ois", "ir", "dis", "fs", "js", "mis", "iris", "iter", "ip", "act", "init", "nis", "isin", "ri", "ris", "iso", "sim", "oss", "i", "abs", "sys", "ires", "vis", "Is", "IS", "ais", "ims", "bis", "isa", "are"], "s": ["join", "ags", "ms", "sql", "less", "os", "m", "t", "b", "c", "h", "ws", "ls", "ss", "css", "ves", "arts", "tes", "its", "results", "es", "ns", "ies", "ists", "uts", "cs", "ts", "y", "v", "p", "ains", "l", "f", "prints", "ings", "gs", "ats", "str", "js", "fs", "sv", "S", "n", "g", "sol", "set", "rs", "csv", "sb", "ols", "sts", "string", "ds", "conv", "hs", "abs", "parts", "gets", "stats", "ries", "qs", "ps"]}}
{"id1": "12066447", "id2": "11562173", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 1, "substitutes": {"truncate": ["truncicate", "extuncate", "trvalidation", "extuncation", "truncize", "trvalidicate", "trunize", "extuncicate", "trunation", "extvalidation", "extvalidicate", "extuncize", "trunicate", "trculate", "extvalidate", "truncation", "trculation", "trunate", "trculize", "trvalidate", "trvalidize", "trculicate", "extvalidize"], "file": ["full", "info", "module", "File", "null", "ile", "zip", "FILE", "link", "table", "run", "fp", "path", "object", "range", "get", "base", "line", "be", "block", "or", "e", "files", "parent", "use", "name", "message", "image", "resource", "port", "spec", "this", "log", "report", "f", "io", "to", "attribute", "out", "source", "user", "local", "create", "from", "tree", "page", "template", "class", "work", "word", "current", "foo", "le", "frame", "model", "data", "lock", "channel", "size", "time", "type", "format", "filename", "handle", "event", "dir"], "backupRoot": ["backupidBox", "workupidHome", " backupidBox", "BackupidDir", " backupidDir", "BackupidFolder", " backupBox", "workupidBoot", "backmpDir", "backureDir", "workupHome", " backuproot", "backumproot", "workupDir", "backupidRoot", "backdownFolder", "BackupidRoot", "backuproot", "backupFolder", "backupsroot", "backupBox", "backuperHome", "backflowFolder", " backupidRoot", "backflowRoot", "backflowDir", "backdownRoot", "backureRoot", "BackupDir", "workupidDir", "backupBoot", "workupidRoot", "workupidroot", "backupsBox", "backuperroot", "backumpBox", "backupHome", "workupRoot", "BackupRoot", "backmpRoot", "workuproot", " backupDir", "backmpBoot", "backupidDir", "backuperRoot", "backupsDir", "BackupFolder", " backupidroot", "backumpDir", "backumpRoot", "backdownDir", "backupDir", "backupidroot", "backureHome", "backmproot", "backupsRoot", "workupBoot", "backuperDir", "backupidHome", "backureroot", "backureBoot", "backupidBoot", "backupidFolder"], "df": ["gd", "NF", "pd", "tif", "Def", "dx", "du", "bf", "di", "dc", "cd", "md", "raf", "uf", " pdf", "f", "sf", "sd", "cf", "dm", "dp", "mm", "dr", "ds", "def", "lf", "pdf", "dep", "deb", "fun", "dim", "db", "hd", "dt", "DF", "fd", "dl", "tf", "format", "dd", "d"], "date": ["month", " Date", "module", "note", "update", "run", "cal", "default", "future", "get", "today", "range", "version", "value", "daily", "day", "Date", "when", "name", "now", "message", " day", "resource", "grade", "content", "number", "down", "standard", "output", "create", "dates", "due", "dat", "start", "string", "save", "ate", "zone", "sum", "tag", "age", "frame", "data", "match", "dt", "days", "format", "time", "dated", "year", "late", "event", "duration"], "zipFile": ["pdffile", "logStore", "zipStore", "pdfFile", "logPath", "jsonStore", "logFilename", "ZipStream", "logStream", "jsonFile", "ZipFile", "jsonFilename", "jsonfile", "logfile", "zipFilename", "Zipfile", "zFilename", "pdfStream", "zipStream", "pdfPath", "zipfile", "zfile", "zipPath", "logFile", "zStore", "zFile", "ZipPath"], "zos": ["zan", "zen", "os", "sis", "tz", "zin", "ros", "z", "ones", "hz", "bs", "oses", "zag", "Sax", "eros", "estro", "cz", "sch", "css", " sands", "bes", "ss", "shed", "zi", "asio", "zik", "ze", "zo", "zon", "enos", "ozo", "ses", "sol", "nz", "js", "zers", "cos", "los", "ez", "zb", "sbm", "hess", "za", "jas", "hs", "zzle", "zes", "oss", "esm", "rez", "zar", "zona", "south", "asar", "enz", "zer", "webkit", "stice"], "fis": ["ofisc", "fits", "lia", "foia", "fier", " fib", "sfiss", "fib", "cfis", "ofits", "f\u00eds", "efis", "efisc", "sfis", "ofib", "dfier", "fiiss", "sfIs", "lis", "fiib", "fIs", "ofiss", "sfisc", "foIs", "fia", "FIs", "sfits", "fiss", "ofis", "cfiss", "if\u00eds", "sfier", "Fia", "Fier", "Fi", "Fisc", "ifIs", " fiss", "fiis", "dfiss", "ofois", "ef\u00eds", "Fiss", "ifis", "fisc", "F\u00eds", "fiois", "dfIs", "li", "fois", "lIs", "efIs", "dfis", "foi", "Fis", "fi", "cfisc", "ifisc", "cfits", " fois"], "entry": ["record", "ace", "row", "zip", "office", "Entry", "ion", "option", "object", "sheet", "se", "add", "e", "or", "delete", "ment", "internal", "ce", "cell", "connection", "resource", "obj", "zo", "element", "ary", "member", "cue", "de", "set", "tex", "entity", "search", "ie", "def", "deep", "section", "word", "char", "and", "rance", "ry", "comment", "xml", "data", "escape", "description", "command", "insert", "key", "ent", "event", "attribute"], "buffer": ["bar", "memory", "paste", "phrase", "binary", "length", "buff", "table", "sample", "variable", "document", "zero", "letter", "batch", "category", "base", "block", "Buffer", "available", "message", "sequence", "library", "cache", "queue", "temp", "padding", "window", "buf", "code", "iter", "page", "template", "word", "screen", "char", "frame", "comment", "header", "view", "button", "volume", "command", "stack", "attribute", "append"], "readed": ["Readed", "indexed", "findied", "indexented", "counter", "readd", "readeded", "READer", "Readied", "countED", "Readd", "ReadED", "Readared", "indexeded", "readableared", "readED", " readeded", " readented", "counted", "countd", "reader", "findared", "reded", "readableied", "READED", "READed", "readableed", "Reader", "READd", "findED", "readared", "readied", "readented", "indexED", "readableED", "rededed", "redented", " readED", "finded", "redED"]}}
{"id1": "4602568", "id2": "6379126", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"storeImage": ["StoreImage", "saveImages", "StoreImages", "storePicture", "saveFile", "savePicture", "StorePicture", " storeImages", "storeFile", "storeImages", " storePicture", "saveImage", "StoreFile", " storeFile"], "inStream": ["inSteam", "cinFile", "fileSteam", "cinSteam", "outForm", "inView", "cinStream", "outFile", " inSteam", "inForm", "inputSteam", "inFile", "inputView", " inView", "inputFile", "fileForm", "cinView", " inFile", "fileFile", " inForm", "fileStream", "outSteam", "inputStream"], "fileName": [" filename", "resourcePath", "fileTime", " fileInfo", " filePath", "FileType", "resourceName", "FILEName", "FileTime", "imageInfo", "imageName", "FILEPath", "fileInfo", "FileInfo", "FilePath", "fileType", "FILEInfo", " fileType", "FILEname", "resourceType", "resourceTime", "FileName", "imagePath", "imagename", "filePath", "imageType", "Filename", "imageTime", "filename"], "resize": ["Ressize", "Resizes", "ressize", "Resized", "rensize", " resizes", "renizes", "renize", "resizes", "resized", "renized", " ressize", "Resize", " resized"], "rightNow": ["westFuture", " RightNOW", "RightToday", "rightCurrent", "westCurrent", " RightThen", "westNow", "correctNOW", "westToday", " rightCurrent", "RightCurrent", "rightThen", " rightServer", " rightThen", "correctToday", " rightNOW", " rightFuture", "rToday", "rightNOW", "rNow", "rServer", "rightServer", "rNOW", " RightCurrent", "rightToday", "correctNow", "RightNow", "rightFuture", "RightFuture", "correctFuture", " RightNow", "westServer", "westThen", " rightToday", "westNOW"], "dayNamedFolderName": ["dayNamedThemeSize", "dayNamingFolderSize", "dayNamedThemePath", "dayNamingFolderPath", "dayNamedThemeName", "dayNamingFolderNames", "dayNamedArea1", "dayNamingFileNames", "dayNamingDirectoryName", "dayNamingFolderName", "dayNamedfolderPath", "dayNamedfolder1", "dayNamedFolderPath", "dayNamedAreaNames", "dayNamedfolderName", "dayNamedFolderNames", "dayNamingDirectory1", "dayNamedFileName", "dayNamedfoldername", "dayNamingFilename", "dayNamingFilePath", "dayNamingDirectoryname", "dayNamedAreaname", "dayNamingFileName", "dayNamedDirectoryNames", "dayNamedfolderNames", "dayNamedFolder1", "dayNamedFileNames", "dayNamedAreaName", "dayNamedFilename", "dayNamingFileSize", "dayNamingFolder1", "dayNamingDirectoryNames", "dayNamingFoldername", "dayNamedThemeNames", "dayNamedFoldername", "dayNamedThemename", "dayNamedDirectoryname", "dayNamedFileSize", "dayNamedFolderSize", "dayNamedDirectoryName", "dayNamedFilePath", "dayNamedDirectory1"], "uploadDirRoot": ["uploadDbCover", "UploadDirRoot", " uploadDirroot", "uploaddirRoot", "UploadDbRoot", "uploadDbBase", "saveDirParent", "uploadFolderroot", "uploaddirroot", "uploadNetRoot", "uploadDbRoot", "uploadUrlBase", "UploadDbroot", "UploadDirBase", "uploadUrlRoot", "uploadFolderBase", "saveDbParent", "uploaddirCover", " uploadRelroot", "uploadUrlroot", " uploadRelPath", "UploadDbBase", "saveDirroot", " uploadRelBase", "uploadDirCover", "uploadUrlPath", "uploadDbroot", "uploadFolderPath", " uploadRelRoot", "saveDbRoot", "uploadDirBase", "uploadDirroot", "uploadRelroot", "uploadNetCover", "uploadRelBase", "UploadDirCover", "uploadDirectoryRoot", "uploadDirectoryParent", " uploadDirBase", "uploadUrlParent", "uploadRelRoot", "uploaddirBase", "uploadNetroot", "uploadDirPath", "uploadFolderRoot", "uploadDbParent", "UploadDbCover", " uploadDirPath", "uploadRelPath", "uploadDirectoryroot", "saveDirRoot", "UploadDirroot", "uploadDirParent", "uploadNetBase", "saveDbroot"], "file": ["full", "project", "File", "null", "t", "ile", "FILE", "link", "table", "run", "il", "h", "key", "get", "base", "top", "up", "parent", "name", "port", "resource", "image", "to", "f", "op", "folder", "source", "node", "no", "local", "entity", "page", "tree", "class", "work", "force", "el", "pool", "task", "channel", "type", "time", "open", "handle", "dir"], "extension": ["xtended", "dimention", "EXTension", "expensions", "extended", "expended", "exendant", "xtention", "dimension", "xtension", "expension", "xtend", "dimensions", "extention", "exension", "extend", "EXTention", "extensions", "EXTended", "exensions", "expendant", "expention", "dimendant", "expend", "exention", "EXTend", "extendant"], "outFileName": ["outFileNames", "outImageName", "OUTLogname", "outFileInfo", " outLogNames", "OUTLogKey", "outLogVersion", " outLogVersion", "outFilenameType", "outDirPath", "outFieldSize", "outFilesname", "outImageKey", "outFieldName", "outfileVersion", "inFileSize", " outLogName", "outFilenamename", "inFileType", "OutfileKey", "inFilename", "OUTFileName", "inFileName", "OUTLogName", "OUTFileKey", "outFieldType", "Outfilename", "infileType", " outLinePath", "outfilePath", "infileName", "outfileNames", "OUTFieldPath", "outLineName", "outFieldPath", "outLinename", "outLogNames", " outFilename", "OutFilename", "outLinePath", " outLogname", "outImageNames", " outFileVersion", "OutFileKey", " outFilePath", "outFileType", "OutFilePath", "outFileKey", " outLineNames", "OUTFieldname", "outFilenameNames", "outLineKey", "infileSize", "outFilenameName", "outFilenameVersion", "outfileName", "OUTFilename", "outfilename", "outLogName", "outFieldname", "outDirname", "outFilenamePath", "outLogKey", "outFilenameSize", "outFileVersion", "outLogname", " outLineInfo", " outLineName", "outFilenameKey", "outFilenameInfo", "infilename", "outImagePath", "OUTFieldName", " outFileInfo", "outDirName", "OutfilePath", "outImagename", "OutFileName", "OUTFilePath", "outfileSize", "outFileSize", "outFilename", "outFilesPath", "outLineNames", "outfileType", "outfileKey", "OUTLogPath", "outFilesName", "outImageInfo", "outLogPath", " outFileNames", "outFilePath", "OutfileName", "outLineInfo"], "outPathAndName": ["outPathandSize", "outLocationandSize", "outPathOrNames", "outPortButKey", "outPortButPath", "outPortAndPath", "outLocationAndKey", "outLocationAndName", "outPathandPath", "outTimeButPath", "outTimeButLike", "outPathOrName", "outTimeAndPath", "outPathandName", "outPathandKey", "outTimeAndTime", "outPathButPath", "outTimeAndLike", "outPathButLike", "outLocationandName", "outPathOrPath", "outPathANDPath", "outPathANDTime", "outLocationandNames", "outPathAndPath", "outPathButTime", "outPathAndLike", "outPortAndName", "outPathOrTime", "outPathOrLike", "outTimeButTime", "outPathButName", "outPathAndNames", "outPathANDName", "outPathandNames", "outPortButName", "outPathAndSize", "outPathAndTime", "outPathButKey", "outPathANDLike", "outLocationAndNames", "outTimeButName", "outTimeAndName", "outLocationAndSize", "outPathAndKey", "outPathOrSize", "outPathOrKey", "outPortAndKey", "outLocationandKey"], "uploadedFile": ["uploadmedPlace", "uploadedGlobal", "uploadededGlobal", "uploaderFILE", "uploadedPlace", "uploadtedFILE", "uploadashedField", "uploadtedField", "uploadiedUnit", " UploadedFile", "uploadpedFile", "uploadredFormat", "uploadredPlace", "uploadashedFILE", "uploadiedF", "uploadredGlobal", "presenttedFILE", "uploadpedUnit", "uploadiedFile", "presenttedfile", "presenttedField", "uploadiedLine", " UploadmedFormat", "uploadashedFile", " UploadedFormat", "uploadashedfile", "presentedField", " UploadedGlobal", " uploadededFile", "presentedFILE", "uploadpedLine", "uploadifiedUnit", "uploadedLine", " uploadedifiedUnit", "uploadedFormat", "uploadpedF", "uploadifiedLine", "uploadededPlace", "uploadmedFile", " uploadededF", "uploadtedfile", "uploadedF", "presenttedFile", "uploadedField", "presentedFile", " uploadededLine", " UploadmedFile", "uploadredFile", "uploadifiedFile", " UploadmedPlace", "presentedfile", " uploadedifiedLine", " UploadedPlace", " UploadmedGlobal", "uploadtedFile", "uploadedUnit", "uploadededFile", "uploadmedFormat", "uploadedfile", "uploadedFILE", "uploaderfile", "uploaderFile", "uploadmedGlobal", "uploadededFormat", "uploaderField", " uploadedifiedF", "uploadifiedF", " uploadedifiedFile", " uploadededUnit"], "outStream": ["oView", "inSteam", "_", "inView", "oStream", "outFile", " outView", "outView", " outFile", "inFile", "outSteam", "oFile", "oSteam", " outSteam"]}}
{"id1": "9826240", "id2": "17158020", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"checkHashBack": [" checkhashDown", " checkhashUp", "checkhashUp", "checkClearDown", " checkHashback", "checkClearBack", "checkHashUp", "checkHashDown", " checkHashDown", "checkLockUp", "checkLockDown", "checkClearback", " checkhashBack", "checkhashDown", "checkLockBack", "checkLockback", "checkhashBack", " checkHashUp", "checkClearUp", "checkHashback", " checkhashback", "checkhashback"], "facade": ["Facace", "glace", "latace", "famacet", "Faclegate", "Facader", "facader", "Facades", "facades", "faclegate", "formace", "famace", "servade", "Facaded", "formacet", "Facacet", "funcace", "glade", "facaded", "famificate", "funcage", "servage", " facage", "latlegate", "Facade", "Facage", "facificate", "funclegate", "glader", "formade", "facace", "funcade", "latader", "servades", " facades", "facacet", "facage", "Facificate", " facaded", "glage", "latade", "funcader", "famade", "formificate", "servaded"], "req": ["err", "http", "params", "Requ", "forced", "resp", "attr", "pkg", "wx", "urg", "require", "gr", "e", "desc", "quest", "required", "sq", "queue", "p", "obj", "r", "needed", "out", "request", "q", "cur", "proc", "aux", "org", "res", "rec", "cmd", "good", "ctr", "ctx", "etc", "uj", "rb", "forge", "jp", "rpm", "work", "qt", "body", "compl", "reg", "requ", "msg", "data", "Request", "tx", "wcs", "Resp", "qq", "rh", "qs", "mr"], "txtTransactionID": ["txtTransactionName", "xtTransactionID", "txtTxId", "xtTxID", "xtTxName", "txtTransactionKey", "txtTXId", "txtTxID", "txtOrderKey", "txtTxName", "textTxID", "txtOrderId", "txtOrderName", "xtTransactionName", "txtTransID", "txtTXName", "xtTransactionId", "txtTransKey", "txtTxKey", "txtTXID", "txtOrderID", "txtTransactionId", "xtTransactionKey", "textTxName", "textTransactionID", "xtTxKey", "textTransactionName", "txtTransId", "xtTxId", "txtTransName", "textTxId", "textTransactionId"], "txtOrderTotal": ["txtOrderInfo", "txtOrderComplete", "xtOrderId", "txtTransactionBase", "txtOrdSum", "txtJobTotal", "txtOrderSum", "strTransactionTotal", "txtTradeTotal", "strOrderTotal", "txtOrdBase", "strTransactionComplete", "txtOrdTotal", "strOrderBase", "xtOrdInfo", "txtOrderId", "txtOrdId", "txtTradeComplete", "strTransactionBase", "xtOrdTotal", "txtJobSum", "strOrderComplete", "txtArticleInfo", "txtArticleId", "txtArticleTotal", "txtOrdInfo", "xtOrderInfo", "txtTradeBase", "txtTransactionTotal", "xtOrdId", "xtOrderSum", "txtOrdComplete", "txtJobId", "xtOrdSum", "xtOrderTotal", "txtTransactionComplete", "txtOrderBase", "txtArticleSum", "txtJobInfo"], "txtShopId": ["txtSiteid", "txtShopid", "txtSiteAid", "txtSiteId", "xtSiteid", "txtStoreId", "xtShopId", "txtSiteID", "txtForgeAid", "xtSiteAid", "txtStreetById", "txtShopById", "xtShopID", "txtServerId", "txtStoreID", "textStoreById", "txtStreetid", "textShopID", "txtForgeid", "textStoreid", "xtSiteId", "textStoreID", "xtShopAid", "textStoreId", "textShopById", "txtServerAid", "txtStreetID", "txtForgeID", "txtServerID", "txtForgeId", "txtShopAid", "xtShopid", "txtShopID", "txtStoreid", "txtStreetId", "txtServerid", "txtStoreById", "xtSiteID", "textShopid", "textShopId", "txtSiteById"], "txtArtCurrency": ["txtArticleCcurrency", "txtArticleCurrencies", "txtArtCurrencies", "txtArtColategories", "txtArticleCocurrency", "txtArtCoulture", "txtArticleConcurrency", "txtArticleConurrency", "txtArticleCourrencies", "txtArticleCategories", "txtArticleCoulture", "txtArtColcurrency", "txtArtCategories", "txtArticleCulture", "txtArtConulture", "txtArtCcurrency", "txtArtCourrency", "txtArtCourrencies", "txtArtConurrency", "txtArtColurrency", "txtArticleCourrency", "txtArtCocurrency", "txtArtConurrencies", "txtArticleCurrency", "txtArtCoategories", "txtArticleConategories", "txtArtConcurrency", "txtArtConategories", "txtArtCulture"], "txtHashBack": ["textHashValue", "txtHelpBACK", "txtFilterback", "txtHashback", "txtLockBack", "texthashValue", "textHashback", "texthashBACK", "txthashBack", "txtHashFront", "txtFilterBack", "xtHashFront", "txtHelpback", "txtStockFront", "txtRawValue", "txtRawback", "xtStockBACK", "txtRawBack", "txtClearBack", "txtStockBACK", "texthashBack", "txthashValue", "txthashBACK", "txtLockFront", "txtFilterBACK", "texthashFront", "txthashback", "txtStockback", "txtFilterFront", "txtHashValue", "txtLockback", "txtHelpFront", "xtHashBACK", "txthashFront", "txtLockBACK", "txtClearBACK", "txtHelpBack", "xtHashback", "txtClearFront", "txtHashBACK", "xtStockback", "txtRawBACK", "textHashBACK", "xtStockBack", "xtStockFront", "xtHashBack", "txtStockBack", "txtClearback", "textHashBack", "textHashFront", "texthashback"], "hashSeed": [" hashSeiper", "hashSleed", "hoSep", "hoSeder", "hashAseder", "hashSlee", "hashSetter", "hashAsep", "hashSeiper", "hashSeeeds", "hashSeee", "hashSeder", "hashSourceetter", " hashSeeds", "hoAseed", "hoAsetter", " hashSiper", "hashSeeds", "hoAseder", "hashSee", "hashSourceeder", "hashFeder", "hashSliper", "hashSleeds", "hashSourceeed", "hashSiper", "hashAsetter", "hashSep", " hashSeeed", "hashSeeed", "hoAsep", "hashFetter", "hoSetter", " hashSeeeds", " hashSee", "hashAseed", "hashFeed", "hashFep", " hashSeee", "hashSourceep", "hoSeed"], "securityValue": ["SecurityData", "secValue", "SecurityValues", "securityValues", "securityData", "securityVal", " securityValues", "secVal", "SecurityValue", "secValues", "secData", " securityVal", "SecurityVal", " securityData"], "digest": ["digse", "macester", "contests", "Digse", "Digested", "dester", "dependester", "digested", "Diger", "dEST", "equester", " diger", "digester", "Diget", "digests", "diget", "macested", "Digests", "macgest", "contested", "DigEST", "dested", "diger", "contse", "contest", "dest", "equet", "Diggest", "dependgest", " digested", "dependest", "diggest", " digse", "der", "dependested", "equest", " diget", " digEST", "Digest", "Digester", "digEST", "macest", "equse", " digester", " digests", "dse"], "array": ["record", "av", "bar", "iq", "row", "binary", "length", "audio", "archive", "our", "collection", "object", "arr", "range", "a", "batch", "ray", "pair", "raw", "ash", "vector", "RAY", "now", "list", "buffer", "v", "map", "stage", "number", " Array", "angular", "rays", "ashes", "arrow", "string", "export", "Array", "share", "instance", "sha", "area", "view", "response", "ar", "max", "attribute", "shape", "angle"], "sb": ["bh", "bt", "bg", "wb", "rob", "gc", "bs", "obb", "erb", "stab", "ls", "bf", "soc", "kb", "bps", "bb", "sq", "ib", "pb", "rub", "sam", "sf", "abb", "gb", "bsp", "sv", "lp", "eb", "sn", "sg", "ctrl", "ssl", "zb", "SB", "rb", "sbm", "sa", "gob", "abs", "ob", "cb", "esm", "lb", "bis", "orb", "nb", "bj", "shell", "obs"], "j": ["ji", "_", "z", "jo", "it", "gr", "ind", "kj", "v", "jit", "obj", "k", "J", "q", "x", "jet", "ja", "js", "oj", "g", "n", "yy", "from", "att", "uj", "jj", "state", "ij", "jp", "dj", "jl", "br", "json", "i", "ix", "bot", "el", "msg", "aj", "job", "key", "jc", "ody", "bj", "jump"], "b": ["bar", "bg", "bt", "binary", "bs", "ab", "bit", "h", "base", "bf", "be", "bb", "ib", "ba", "B", "v", "fb", "bound", "beta", "k", "bd", "mb", "gb", "bi", "eb", "rb", "BB", "bp", "br", "db", "cb", "bis", "nb", "bc", "bu"], "hash": ["hex", "bh", "ah", "hz", "sample", "crypt", "where", "href", "total", "h", "url", "oh", "uh", "ash", "value", "version", "check", "flash", "block", "filter", "address", "message", "password", "report", "buster", "rh", "cache", "height", "ashes", "test", "ASH", "search", "title", "ssl", "string", "sha", "Hash", "sum", "json", "tag", "html", "header", "data", "response", "format", "key", "handle", "result"]}}
{"id1": "646016", "id2": "5683576", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"elimina": ["alimisa", "elimisa", "eligisa", "eligine", "alimine", "elitisa", "alimino", "allimina", "ellimino", "elitine", "alimina", "ellimine", "elitino", "elitina", "allimine", "allimino", "allimisa", "ellimisa", "elimine", "eligino", "eligina", "ellimina", "elimino"], "cli": [" cl", "eric", "dial", " CLI", "ci", "gil", "c", "uci", "ctl", "util", "aci", "lc", "pi", "cho", "e", "clus", "lu", "ui", "udi", "client", "multi", "grid", "l", "conn", "coni", "cl", "GUI", "Client", "gui", "console", "ln", "cmd", "cci", "cfg", "cu", "prot", "Cl", "li", "i", "cgi", "dl", "idi", "exe", "coe", "ctrl"], "id": ["info", "ad", "null", "in", "pid", "mid", "end", "rand", "aid", "url", "Id", "h", "ref", "key", "it", "e", "value", "ide", "wid", "oid", "del", "name", "md", "kid", " fid", "sid", "vid", "with", "f", "out", "ida", "bid", "sd", "iden", "ids", "code", "did", "uid", "no", "ID", "res", "start", "ip", "rid", "num", "index", "i", "mail", "db", "hash", "is", "ident", "type", "and", "status", "d"], "sql": ["what", "ms", "scl", "details", "eps", "sal", "fn", "expression", "pp", "https", "pkg", "security", "services", " SQL", "util", "QL", "url", "ls", "pel", "ips", "socket", "sq", "ns", "owl", "sp", "s", "spec", "ping", "sl", "nl", "spr", "sol", "sd", "js", "sv", "ln", "csv", "sb", "ssl", "string", "ds", "shell", "SQL", "xs", "json", "query", "inv", "mail", "db", "html", "sys", "lua", "xml", "sk", "msg", "lock", "dl", "ship", "format", "wal", "ll", "lex", "software", "ps", "ql"], "stmt": ["tmt", "Stmm", " sttm", "strmb", " stmb", "STmt", "sctm", "scmt", "strmt", " stm", "STMT", "STmm", "strMT", "scm", "strm", "stm", "scmm", " stMT", "Sttm", "StMT", "Stm", "sttm", " stmn", "tmm", "ttm", "stMT", "stmb", " stmm", "Stmn", "stmm", "Stmb", "Stmt", "tm", "STm", "STmn", "stmn"]}}
{"id1": "22560224", "id2": "13333160", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 0, "substitutes": {"hashStringMD5": [" hashStringMT5", " hashStringSHA0", " hashStringSHA5", " hashStringSHAHash", " hashStringMDHash", " hashStringSMHash", " hashBytesMT1", " hashBytesMDHash", " hashBytesMD0", " hashStringMD0", " hashBytesMTHash", " hashStringMT1", " hashBytesMD5", " hashStringSM5", " hashBytesMD1", " hashBytesMT0", " hashStringMTHash", " hashBytesMT5", " hashStringMD1", " hashStringSHA1", " hashStringMT0", " hashStringSM1", " hashStringSM0"], "string": ["sql", "null", "text", "object", "host", "prefix", "value", "space", "list", "name", "address", "message", "buffer", "sequence", "v", "spec", "password", "s", "print", "content", "ring", "setting", "number", "service", "source", "str", "function", "test", "site", "input", "word", "char", "comment", "data", "file", "strings", "array", "format", "ident", "filename", "result"], "md": ["mod", "m", "ms", "ad", "det", "pd", "df", "amd", "ld", " MD", "mode", "mk", "dh", "mc", "add", "nd", "desc", "MD", "di", "ind", "cond", "cd", "mn", "mt", "od", "bd", "mb", "dist", "sm", "sd", "de", "cmd", "dm", "mm", "dr", "Cmd", "pdf", "der", "nt", "alg", "hd", " Md", "red", "mand", "grad", "down", "and", "dd", "dir", "d"], "byteData": ["phraseDat", "seeLens", "chardata", "viewdata", "componentData", "nodeData", " ByteData", "bytedata", "displayData", "ByteDat", " byteDATA", " byteBuffer", "phraseData", "helloBytes", "phraseBytes", "nodeForm", "seeForm", "viewCount", "byteForm", "charData", "byteDo", "displayCount", "ByteData", " ByteForm", "displayDo", "phraseDo", "ByteBuffer", "wordData", "helloDo", "displaydata", "ByteBytes", "byteBytes", "byteParts", " byteBytes", "helloData", " ByteLens", " bytedata", "wordDATA", " byteCount", "componentParts", "charDATA", "nodeLens", "viewData", " ByteBuffer", "componentBuffer", "ByteDo", "byteDat", "componentBytes", " byteParts", "viewDo", "byteBuffer", "nodeBuffer", "byteLens", "seeBuffer", "ByteParts", "helloDat", "byteCount", "seeData", "byteDATA", "worddata", " byteDo"], "sb": ["src", "bt", "bh", "sc", "bg", "bs", "b", "erb", "alph", "ws", "bf", "soc", "kb", "bb", "sh", "sq", "sp", "ib", "pb", "sam", "sf", "sw", "mb", "sync", "gb", "sth", "sv", "eb", "sg", "ssl", "zb", "rb", "SB", "bash", "sa", "nb", "web", "cb", "xb", "lb", "bsp", "bj", "shell"], "i": ["info", "m", "err", "c", "us", "span", "I", "oi", "y", "io", "me", "init", "ie", "json", "cgi", "series", "j", "gi", "o", "pi", "it", "di", "zi", "client", "kj", "er", "print", "ai", "\u0438", "q", "bi", "li", "im", "z", "in", "phi", "ii", "qi", "my", "ti", "batch", "ini", "history", "ski", "list", "hi", "this", "v", "multi", "iy", "uri", "iu", "ip", "cli", "ij", "ki", "xi", "remote", "ei", "ji", "iq", "ci", "gu", "mi", "base", "ui", "id", "name", "ic", "g", "set", "ex", "si", "ri", "conv", "point", "ix", "yi", "chain", "ity", "any"], "hexString": [" hexScreen", "alphaScreen", "hexSite", "exText", "pexList", "hexText", "alphaString", "hexStatement", "serialString", "serialStr", "exStr", " hexSet", " hexStr", "expBuffer", "pexStatement", "exString", "hexScreen", "exSocket", "serialBuffer", "exBuffer", "sexList", "httpString", " hexSite", "viewNumber", "viewBuffer", "expSet", "hexNumber", "hexStr", "alphaSite", "serialText", "viewString", "httpScreen", "sexSocket", "hexSet", "hexList", "exStatement", " hexText", "exList", "pexString", "sexString", "hexSocket", "hexBuffer", "httpSite", "viewSet", "alphaStr", "expString", "sexStatement", " hexBuffer", "expNumber", "httpStr", "pexSocket", " hexNumber"], "hex": ["full", "handle", "rex", "hw", "cmp", "zh", "hl", "hz", "buff", "dump", "cont", "h", "prop", "raw", "none", "sh", "hi", "sex", "print", "pex", "x", "term", "aux", " sex", "sv", "ex", "cat", "tex", "ip", "exp", "oct", "def", " Hex", " ex", "char", "com", "ph", "hp", "ext", "json", "comp", "lit", "html", "des", "hash", "form", "he", "tx", "hello", "xf", "rh"]}}
{"id1": "12055086", "id2": "14191679", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeleving", " copydeletving", " copyDeletting", " copyDeeleting", " copydeletging", " copydeleving", " copydeleing", " copyDeletging", " copydeleging", " copyDelingging", " copydeletting", " copyDeleing", " copyDeeleving", " copyDelingving", " copyDelingting", " copyDeeleing", " copydeleting", " copyDeletving", " copyDelinging", " copyDeeleging", " copyDeleging"], "source": ["ace", "src", "sql", "sample", "SOURCE", "back", "base", "se", "scope", "parent", "store", "sp", "ce", "image", "resource", "spec", "seed", "service", "ource", "site", "from", "local", "start", "init", "origin", "search", "template", "style", "input", "original", "body", "target", "query", "oss", "Source", "form"], "dest": ["tom", "src", "cas", "null", "orig", "w", "Dest", "https", "end", "it", "trans", "way", "del", "pas", "sp", "decl", "port", "rest", "master", "temp", "dist", "th", "st", "cat", "mm", "exp", "origin", "bin", "img", "them", "target", "nom", "lit", "loc", "pub", "comb", "est", "dir", "d"], "buf": ["bh", "buff", "b", "bs", "cap", "pkg", "alph", "ref", "batch", "block", "Buffer", "cp", "comb", "vec", "fb", "buffer", "uf", "tab", "cur", "pause", "str", "Buff", "seq", "aka", "cf", "cmd", "bl", "cat", "eb", "bag", "rb", "img", "br", "conv", "capt", "db", "cb", "cv", "bytes", "box", "data", "cast", "tx", "fg", "bus", "meg", "bc", "prop", "arr"], "in": ["gin", "info", "per", "read", "un", "cin", "on", "it", "or", "ini", "inf", "inn", "ind", "ze", "ins", "ic", "rin", "by", "inc", "ai", "al", "user", "iter", "mm", "from", "IN", "init", "en", "isin", "bin", "inner", "con", "input", "ri", "din", "inside", "i", "el", "is", "In"], "out": ["os", "cn", "t", "end", "ion", "o", "up", "aos", "on", "client", "v", "writer", "can", "obj", "to", "outs", "flush", "log", "by", "io", "write", "conn", "dis", "n", "res", "output", "Out", "en", "inner", "page", "con", "nt", "conv", "outer", "sum", "ou", "oss", "i", "at", "sys", "auto", "OUT", "co", "ne", "net"], "count": ["counter", "t", "z", "read", "cloud", "length", "total", "c", "cont", "cap", "ch", "coll", "amount", "Count", "span", "batch", "add", "acc", "found", "ct", "check", "cc", "ind", "common", "cond", "now", "number", "q", "n", "code", "ount", "ctr", "start", "deep", "conf", "core", "char", "current", "nt", "num", "index", "sum", "comment", "size", "len", "max", "nb"]}}
{"id1": "4468255", "id2": "15409512", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "pixel", "zip", "parse", "link", "gc", "archive", "Copy", "get", "opy", "delete", "cp", "map", "print", "sync", "write", "Cop", "single", "cat", "create", "replace", "csv", "crop", "move", "save", "share", "core", "clip", "slice", "split", "transfer", "clone", "file", "py", "remote", "cop", "download"], "from": ["orig", "empty", "simple", "se", "add", "part", "f", "by", "th", "str", "org", "low", "left", "init", "input", "star", "el", "as", "vol", "self", "old", "path", "raw", "normal", "bound", "with", "ing", "source", "st", "query", "html", "config", "form", "view", "and", "dir", "link", "un", "range", "on", "or", "when", "this", "From", "without", "fr", "db", "initial", "file", "so", "remote", "zip", "cont", "url", "a", "base", "stream", "name", "false", "of", "only", "no", "local", "start", "small", "original", "at", "data", "entry"], "to": ["that", "t", "b", "back", "color", "by", "io", "op", "toc", "one", "te", "into", "po", "table", "o", "temp", "pro", "annot", "st", "two", "please", "ont", "et", "dir", "pt", "go", "phi", "total", "zero", "ot", "on", "or", "list", "not", "dis", "tu", "To", "will", "all", "too", "tmp", "tool", "format", "TO", "tom", "process", "null", "top", "base", "eto", "let", "must", "p", "only", "no", "output", "title", "dest", "xy", "nt", "target", "auto", "size", "data", "tty"], "result": ["details", "success", "block", "mate", "confirmed", "mask", "same", "product", "profile", "debug", "ful", "brace", "relation", "json", "important", "Result", "match", "perm", "goal", "table", "su", "region", "nil", "bool", "ure", "report", "r", "flag", "feature", "request", "term", "console", "continue", "launch", "functional", "status", "answer", "successful", "zero", "power", "there", "buffer", "date", "res", "test", "current", "br", "then", "response", "successfully", "duration", "true", "null", "rue", "journal", "stay", "rule", "results", "valid", "message", "false", "sequence", "cache", "only", "either", " successful", "description", "comment", "contact", "type", "chain", "event", "complete"], "subFiles": ["ubFiles", "ubNames", "singPosts", "subPosts", "ubfiles", "newFiles", "ubKeys", "newItems", " subImages", "ubPosts", "selFiles", "singValues", " subfiles", "subImages", "subNames", "newfiles", "selFile", " subpItems", "latImages", "supFiles", "selNames", " subOps", "subfiles", "subFile", "subValues", " subKeys", " subpfiles", " subValues", "subItems", " subCharacters", " subNames", "ubTags", "ubCharacters", "subOps", "ubFile", "subCharacters", " subItems", " subpDir", "singKeys", " subPosts", "ubItems", "ubValues", "singFiles", "subDir", "supOps", "ubDir", "latFiles", "supfiles", "subKeys", " subpFiles", "selDir", "ubOps", " subFile", " subTags", "supFile", "ubImages", "latfiles", " subDir", "latCharacters", "subTags", "newTags"], "i": ["info", "ji", "iq", "ms", "m", "go", "ci", "u", "t", "im", "phi", "j", "ii", "gi", "gu", "qi", "c", "my", "I", "us", "mi", "ti", "oi", "batch", "base", "gl", "pi", "h", "e", "di", "ui", "ind", "hi", "id", "zi", " I", "y", "v", "multi", "iy", "ic", "print", "uri", "ai", "q", "x", "ori", "g", "me", "bi", "iter", "ip", "exp", "init", "si", "ie", "ij", "ri", "index", "point", "sim", "li", "ix", "json", "ami", "task", "xi", "is", "job", "key", "chain"], "newDir": ["newsDir", " newNet", "newJar", "Newdir", "nextDir", " newComp", "NewDir", "newdir", "nextFile", "nextFolder", "subFolder", "subJar", "newObj", "NEWdir", "subServ", " newRel", "newRel", "subFile", " newFolder", "nextComp", "NewObj", "subdir", "subNet", "nextRel", "NewRel", "newFile", "newNet", " newFile", "NewNet", "newServ", "NEWJar", "newsRel", " newJar", "NewFile", "subDir", " newObj", "newsFile", "newsServ", "NewServ", "newComp", " newdir", "subRel", "newFolder", "NEWFile", "newsObj", "subComp", "nextdir", "NEWDir", "newsNet"], "in": ["gin", "info", "m", "read", "mc", "mi", "cin", "pi", "on", "it", "ini", "inf", "inn", "ind", "internal", "ain", "ins", "l", "rin", "print", "io", "doc", "ai", "inc", "al", "proc", "source", "ln", "iter", "IN", "win", "init", "local", "en", "inner", "isin", "bin", "con", "input", "din", "body", "asin", "ma", "inside", "is", "ar", "In", "net"], "out": ["os", "cn", "t", "w", "note", "err", "b", "end", "ion", "o", "up", "aos", "it", "on", "client", "p", "v", "writer", "can", "obj", "log", "outs", "flush", "io", "print", "write", "cache", "one", "n", "res", "ln", "cmd", "user", "output", "ex", "Out", "init", "en", "inner", "con", "nt", "conv", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "cos", "net"], "fileLength": ["fileFamily", "ileDuration", "pageENGTH", "FileENGTH", " fileFamily", "treelength", "FileDuration", "Filelength", "pageLength", "fileENGTH", "ileLength", "pagelength", "FileLength", "ileConstruction", "treeConstruction", "fileDuration", "treeLength", "treeDuration", "pageFamily", "fileConstruction", "FileFamily", "filelength", "ilelength", "FileConstruction", " fileENGTH", " filelength"], "charBuff": ["charbuff", "CharBuff", " charbuff", "CharBuffer", "Charbuff", "intBuffer", "Charbuffer", "intbuff", "intBuff", " charbuffer", " charBuffer", "intbuffer", "charBuffer", "charbuffer"], "len": ["cmp", "pos", "Len", "length", "cap", "val", "syn", "ref", "ls", "line", "e", "mem", "name", "l", "cl", "str", "ln", "set", "start", "en", "char", "el", "gen", "ll", "fin", "et"], "oneChar": ["onceCr", "OneCr", "onceChar", " oneCh", " oneCr", " oneInt", "OneCharacter", "onechar", "oneCharacter", " oneByte", "Onechar", "oneInt", "OneChar", "onceCharacter", " onechar", "oneByte", "oneCr", "OneByte", "OneInt", "OneCh", " oneCharacter", "oneCh", "onceCh"]}}
{"id1": "11477906", "id2": "22264586", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadDefaultsettings", "loadDefaultValues", "loaddefaultSetting", "readdefaultSettings", "readDefaultSettings", "readdefaultsettings", "readDefaultSetting", "loadFAULTSetting", "readdefaultValues", "loadDefaultSetting", "loaddefaultSettings", "readDefaultValues", "loadFAULTSettings", "loadFAULTsettings", "readdefaultSetting", "loaddefaultValues", "loaddefaultsettings", "readDefaultsettings", "loadFAULTValues"], "configFileName": ["configFilename", "configFileLocation", "configStreamname", "confFilenamename", "configFilenameNames", "configfileNames", "configPagename", "configPageNames", "conffileNames", "configPagePath", "conffilePath", "confFilenameLocation", "conffileName", "confFileName", "configFILEname", "configFilePath", "configFILEPath", "confFilenamePath", "configFILEName", "configStreamLocation", "configPageName", "confFilenameName", "configFilenamePath", "configFilenamename", "configfilePath", "configfilename", "configStreamName", "configFilenameLocation", "confFilename", "configFileNames", "confFilePath", "conffilename", "configFilenameName", "configStreamPath", "confFileLocation", "configfileName", "confFileNames", "configFILELocation"], "in": ["gin", "info", "m", "re", "ad", "t", "im", "run", " din", "mc", "o", "mi", "ls", "up", "cin", "it", "on", "e", "or", "ini", "inf", "check", "inn", "ind", "id", "ze", "ain", "ins", "l", "rin", "doc", "ai", "al", "source", "n", "user", "ro", "IN", "from", "init", "en", "bin", "inner", "isin", "con", "input", "din", "ma", "i", "is", "ar", "In"], "out": ["cn", "m", "t", "w", "up", "aos", "port", "can", "log", "io", "user", "init", "en", "oss", "des", "OU", "OUT", "co", "net", "po", "gc", "ge", "o", "it", "raw", "ind", "client", "to", "ing", "off", "de", "ou", "read", "update", "gt", "ion", "ot", "or", "check", "store", "v", "obj", "not", "n", "res", "all", "server", "file", "ne", "ent", "os", "null", "writer", "ins", "outs", "over", "cache", "une", "output", "ex", "Out", "copy", "con", "nt", "conv", "at", "sys", "auto", "handle", "are"]}}
{"id1": "1586662", "id2": "4593012", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doOne": [" Do1", "DoOnce", " DoOnce", "do1", "doApp", " DoApp", " doOnce", "Do1", " DoOne", "doOnce", "DoApp", " do1", " doApp", "DoOne"], "bid": ["fed", "bh", "bt", "sat", "bs", "bn", "b", "pid", "mid", "bat", "based", "hn", "batch", "base", "bf", "bm", "oid", "bb", "wid", "buy", "ind", "id", "sid", "vid", "bd", "bank", "hid", "did", "berry", "uid", "bi", "sb", "bin", "rid", "bas", "db", "cb", "tx", "wed", "bus", "bis", "bc", "fin"], "tid": ["tide", "tbid", "intid", "Tidem", "tidem", "Tid", "trid", "pid", "ttbid", " tbid", "intide", " tpid", "ppid", "ttrid", "tId", "intidem", "pId", "tpid", "pids", "ttids", " tids", "ttid", " trid", "tids", "intId", "pbid", " tId", "Tbid", " tide", "Tide", "prid", "TId", "Tpid", " tidem"], "aid": ["aa", "ace", "tt", "iat", "ad", "cas", "ard", "sat", "med", "Aid", "ia", "ance", "mid", "pid", "lay", "ab", "a", "alpha", "na", "acc", "aw", "oid", "bb", "wan", "ay", "ared", "id", "activity", "aud", "kid", "ae", "sid", "vid", "authorized", "bank", "van", "ida", "said", "card", "ta", "bind", "esa", "aka", "did", "uid", "auth", "pa", "sn", "dev", "alias", "am", "sha", "aida", "ma", "hd", "sys", "aic", "af", "lan", "ant", "antis", "ar", "ident", "ca", "da", "ity", "dd", "ac"], "delta": [" dta", "Dbid", "Dota", "sdelta", "sdota", "sdelt", "sdacl", "Dapter", "adelt", " delt", "Duration", "furation", "retime", "delt", " detime", " dacl", "detime", "felt", " dota", "adota", "dbid", "rta", "Dta", "relta", " dbid", "felta", "relt", "fapter", "Delt", "adetime", "adacl", "dta", "dota", "fota", " duration", "dapter", " dapter", "rota", "dacl", "dabid", "adelta", "duration", "Delta"], "aBalance": ["cabalance", "aTransfer", "saDelta", "aaBalance", "eBal", "aaTransfer", "aStatus", "aDelta", "abalance", "saBalance", "aaStatus", "sabalance", "Abalance", "aAmount", "aaBal", "caBalance", "caDelta", "aaAmount", "aStock", " aBal", " aStock", "ATransfer", "ABal", " aTransfer", "caStock", "saStock", "eStatus", " aStatus", "ABalance", "eAmount", "aabalance", " abalance", " aDelta", " aAmount", "aBal", "eBalance"], "RS": ["RT", "RC", "HS", "ILS", "RB", "Res", "RM", "GC", "LS", "TS", "PS", "ERS", "SS", "RD", "ALS", "Rs", "RR", "HR", "CS", "OSS", "RW", "RE", "VR", "ARS", "JS", "ATS", "MR", "SR", "R", "NRS", "WS", "RO", "PRES", "DR", "BS", "rs", "USER", "VS", "FS", "MS", "GS", "ADS", "RES", "IS", "RP", "YS", "DS", "OS", "KS", "NS", "US"], "Stmt": ["STmp", "stmp", "Stmm", " Stm", "STmt", " stm", "STMT", "STmm", " Stmp", "stmt", " stmp", "stm", " stmt", " stMT", "StMT", "Stmp", "Stm", "stMT", "stmm", "STm", " StMT", " Stmm"], "Query": ["Body", "Spec", "Remote", "Make", "Conn", "Template", "Menu", "Action", "Exp", "Rule", "Question", "When", "Version", "Test", "Clean", "Code", "ERY", "Command", "Function", "Package", "Unit", "Event", "QL", "Message", "Link", "Q", "Get", "Update", "Core", "Policy", "Description", "Service", "q", "IQ", "Host", "Notice", "Form", "General", "Post", "SQL", "query", "Statement", "Request", "Chain", "Module", "Comment", "Format", "Find", "Term", "Send", "Check", "Report", " query", "And", "Activity", "Do", "URI", "Force", "Call", "Str", "Init", "Line", "Size", "Wait", "Config", "Filter", "Fix", "Qu", "Lock", "Where", "Script"], "res": ["ret", "re", "row", "Res", "VAL", "resp", "ares", "rc", "val", "cons", "Cons", "rows", "results", "ns", "cond", "ows", "ress", "req", "conn", "sol", "set", "rs", "vals", "ptr", "rez", "RES", "resh", "result"]}}
{"id1": "8164056", "id2": "17111859", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"encode": ["Encode", "genode", " encenc", "enoder", "enode", "Enode", "Enoder", "genenc", "gencode", " enccode", "Enenc", " encoder", "enenc", "genoder"], "str": ["m", "t", "w", "b", "c", "coll", "it", "Str", "e", "sp", "name", "this", "v", "p", "obj", "spec", "print", "r", "enc", "wr", "n", "res", "st", "txt", "ctr", "string", "comm", "oct", "input", "char", "tr", "br", "conv", "data", "msg", "strings", "text", "STR", "arr"], "buf": ["bar", "av", "hung", "bh", "bg", "buff", "bn", "b", "cap", "mu", "pkg", "batch", "block", "Buffer", "aer", "buffer", "bo", "uf", "pb", "bound", "obj", "que", "var", "queue", "cur", "proc", "temp", "agg", "np", "Buff", "cf", "cmd", "txt", "iter", "output", "bag", "rb", "printf", "br", "bp", "tmp", "next", "db", "ob", "cb", "pool", "cv", "box", "msg", "foo", "bc", "aux"], "md5": [" Md3", "mdct", " MD3", "MD3", "md3", " md45", "dig2", "MD5", " mdlet", "dd8", "md45", "dig45", "MD12", "dd5", " mdct", "md2", " md12", "md8", "dig3", " MD5", " md3", " MDct", "md12", "MD2", " MDlet", "mdlet", "dig12", " md8", " Mdct", "dig8", " md2", "dig5", "dd3", " Md5", "dd45", " Mdlet"], "bytes": [" chunks", "frames", "words", "binary", "bs", "b", "Bytes", "vs", "services", "pages", "ios", " tmp", "bes", "clips", "tes", "its", "bps", "files", "iers", "es", "seconds", "values", "outs", "pieces", "blocks", "bits", "bles", "gs", "gb", "js", " pixels", "bis", "ashes", "vals", "pointers", "xy", " slices", " b", " buffers", "tmp", "xs", "terms", "steps", "fixes", "names", "parts", "sites", "cb", "gets", "classes", "ings", "fps"], "i": ["ji", "info", "m", "ci", "u", "im", "in", "phi", "j", "b", "gi", "gu", "qi", "c", "ii", "I", "us", "mi", "ti", "a", "batch", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "y", "v", "multi", "ic", "uri", "io", "ai", "\u0438", "q", "x", "n", "me", "iu", "bi", "ex", "ip", "cli", "init", "si", "ie", "ij", "ki", "conv", "index", "point", "sim", "li", "ix", "json", "xi", "is", "key", "chain", "major"], "s": ["join", "os", "sql", "t", "z", "b", "j", "h", "ls", "ss", "se", "sq", "ns", "sp", "ts", "v", "p", "y", "spec", "l", "f", "sl", "r", "sw", "sf", "gs", "sol", "n", "js", "sv", "S", "g", "fs", "single", "txt", "rs", "set", "sb", "string", "ds", "conv", "hs", "abs", "gets", "is", "ps"]}}
{"id1": "21063400", "id2": "5148212", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doItemImageProcess", "doImageWork", "doImagesprocess", " doImagesWork", "doMediaprocess", "doImageprocess", "doImageSort", "doImagesWork", "doMediaWork", " doImagesSort", "doItemImageWork", "doImagesProcess", " doImageSort", " doImagesprocess", " doImageWork", "doItemImageprocess", "doMediaSort", "doImagesSort", "doItemImageSort", " doImagesProcess", "doMediaProcess", " doImageprocess"], "request": ["re", "QUEST", "document", "reference", "version", "quest", "address", "client", "question", "context", "image", "resource", "message", "select", "application", "start", "template", "input", "server", "query", "session", "frame", "model", "view", "Request", "command", "attribute"], "response": ["answer", "re", "detail", "http", "exit", "resp", "document", "fire", "onse", "success", "block", "version", "parent", "list", "message", "connection", "image", "sequence", "report", "reset", "print", "ve", "content", "write", "cache", "respond", "one", "window", "application", "res", "console", "site", "user", "output", "page", "tree", "reply", "search", "position", "server", "continue", "Response", "network", "next", "json", "relation", "query", "hash", "frame", "description", "xml", "model", "view", "entry", "format", "display", "status", "result", "collection"], "imgSize": [" imgInfo", "certSize", "dimsize", "appInfo", "appShape", "propName", "imgSIZE", "augsize", " imgsize", "dimSIZE", " imgType", "appOwner", " imgShape", "propsize", "appType", "imgError", "appsize", "propError", " imgStyle", "imgOwner", "imagsize", "imgsize", "imageStyle", "imageInfo", "augShape", "divSIZE", "certScale", "imageName", " imgOwner", "propSize", "imageSize", "imgShape", "certName", "imagError", "dimSize", "imgType", "appStyle", "augOwner", " imgError", "imgInfo", "augSize", "imageScale", "certSIZE", "imagName", "imageSIZE", "divsize", " imgSIZE", "imgStyle", "divSize", " imgScale", "imageType", "appSize", "imagSize", "imgScale", "imgName", " imgName"], "imageInputStream": ["imageRawstream", "imageInterfacestream", "imageIntStream", "mediaInputStream", "fileInputstream", "fileRawStream", "imageStreamPath", " imageInputPath", "imageOutputStream", "imageInputView", "imageInputPath", "imageByteStream", "imageRawSteam", "mediaInputReader", "imageStreamStream", " imageInputSteam", "imageOutputForm", "photoIntSteam", "imageRawStream", "imageIntSteam", "imageInterfaceSteam", "imageInputForm", "imageInterfaceView", "fileRawstream", "imageInputstream", "fileRawView", "fileInputStream", "fileInputView", "imageInputSteam", " imageStreamPath", " imageStreamStream", "imageInSteam", "mediaInputSteam", "imageOutputstream", "imageOutputReader", "imageByteForm", " imageStreamSteam", "photoIntStream", "fileInputSteam", "imageIntPath", "imageInStream", "imageInterfaceStream", "imageOutputSteam", "imageInView", "imageRawView", "imageStreamSteam", "imageInstream", "photoInputstream", "photoInputStream", "imageIntstream", "imageByteSteam", "imageInputReader", "fileRawSteam", "imageByteReader", "photoIntstream", "photoInputSteam", "mediaInputForm"], "imageBytes": ["pictureBytes", "imageParts", " imageBs", "issueBytes", "imgBs", "issueGs", "imgParts", "issueParts", "photoByte", "pictureGs", "imgSeries", "photoGs", " imageByte", "audioBs", "imageByte", "pictureByte", "photoBytes", "audioBytes", "imageKeys", "imgKeys", "audioSeries", "imageSeries", "imageBs", "photoKeys", "imgGs", "imgBytes", " imageSeries", "audioParts", "photoParts", "pictureParts", " imageParts", "imageGs", " imageGs", "issueKeys"]}}
{"id1": "4938100", "id2": "4798332", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"sha1": ["SHA1", "a2", "a1", "SHA3", "md3", "SHA256", "a3", "md1", "md2", "md256", "sha2", "sha3", "sha256", "SHA2", "a256"], "text": ["Text", "t", "w", "read", "document", "cont", "path", "url", "TEXT", "prefix", "value", "ct", "now", "name", "message", "buffer", "context", "password", "print", "content", "event", "out", "q", "x", "str", "term", "select", "source", "code", "test", "txt", "output", "act", "string", "title", "pattern", "template", "input", "word", "nt", "ext", "body", "form", "comment", "data", "msg", "aut", "tx", "translation", "subject", "command", "pt"], "UnsupportedEncodingException": ["UnsupportedChodingError", "UnsupportedChoderException", "UnsupportedChoderElement", "UnsupportedChodingElement", "UnsupportedEncodingEx", "UnsupportedChoderError", "UnsupportedEncodingError", "UnsupportedEncgorithmError", "UnsupportedEncgorithmElement", "UnsupportedEncoderElement", "UnsupportedEncoderError", "UnsupportedChodingException", "UnsupportedEncgorithmException", "UnsupportedEncoderException", "UnsupportedEncgorithmEx", "UnsupportedEncodingElement", "UnsupportedChodingEx", "UnsupportedChoderEx", "UnsupportedEncoderEx"], "md": [" ms", "mod", "m", "ms", " mm", " dd", "ad", "t", "det", "df", "pd", "ld", "pkg", " man", "dh", "mc", "h", "mk", "mond", "bf", "nd", "add", "MD", "di", "ind", "rm", "cd", " df", "mn", "mt", "od", "bd", "mb", " mo", " mc", "mg", "sd", " sd", "cmd", "dm", "mm", "ctr", "td", "der", " rm", "sha", "hd", " Md", "red", " cd", "mand", "grad", "mp", " cmd", "dd", "dir", "d"], "sha1hash": [" SHA1hash", "sha5Hash", "aoneHash", "haonesha", "sha1result", "shaoneresult", "a1hash", "aonesum", "shaoneHash", "sha1sum", "haonehash", "sha5hash", "haonesum", "sha81hex", "sha5hex", "sha3result", "aonesha", "sha5href", " SHA1Hash", "ha1sum", "sha1href", "ha1sha", " SHA81hash", "shaonesha", " SHA81hex", "sha1hex", "shaonesum", "haoneresult", "shaonehash", "a1sum", "sha5sum", "sha2sha", " SHA1hex", "sha3hash", "a1Hash", "sha3sha", "sha2hash", "aonehash", " SHA81Hash", "sha2sum", "sha3Hash", "sha3hex", "ha1result", "sha81Hash", "sha3href", " SHA1href", "sha5result", "sha1sha", " SHA81href", "sha81hash", "a1sha", "sha5sha", "sha81href", "sha1Hash", "ha1hash", "sha2Hash", "sha3sum"]}}
{"id1": "16079868", "id2": "5676111", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"readIntoList": ["readintoList", "readIntToMenu", "readintintolist", "readIntTolist", "readintintoMenu", "readIntintoMenu", "readIntIntlist", "readintolist", "readintintoList", "readIntIntList", "readIntIntMenu", "readIntolist", "readIntintolist", "readIntToList", "readintintoMap", "readIntintoList", "readintoMap", "readIntintoMap", "readIntoMenu", "readIntToMap", "readIntIntMap", "readIntoMap", "readintoMenu"], "url": ["ret", "domain", "bel", "ur", "http", "link", "b", "ref", "address", "name", "id", "image", "resource", "uri", "l", "log", "f", "r", "nl", "str", "window", "mol", "rect", "mount", "hub", "from", "location", "ssl", "string", "input", "char", "Url", "web", "mail", "el", "xml", "file", "loc", "ll", "dl", "open", "cert", "URL", "browser"], "list": ["info", "record", "dict", "m", "module", "detail", "t", "table", "batch", "top", "get", "add", "block", "part", "parent", "level", "name", "p", "port", "summary", "map", "l", "print", "group", "v", "out", "cache", "only", "n", "test", "st", "set", "state", "all", "tree", "network", "show", "relation", "pool", "view", "LIST", "listed", "is", "format", "type", "label", "status", "rm", "lists", "collection"], "in": ["gin", "re", "read", " din", "val", "get", "up", "cin", "add", "on", "line", "check", "inf", "inn", "ill", "mn", "ins", "er", "ic", "rin", "by", "reader", "r", "pin", "inc", "doc", "out", "source", "IN", "from", "en", "isin", "bin", "inner", "all", "con", "input", "conf", "din", "sum", "i", "file", "is", "and", "In"], "inputLine": ["inputL", "contextline", "htmlLINE", "textLin", "httpL", "formline", "nextText", "selectText", "inputLINE", "nameline", "httpLINE", "InputLINE", "nameBlock", "formBlock", "inputline", "nameLINE", "latLINE", " inputRow", " inputLINE", "nameLine", "inputLin", "textL", "commandLine", "nextLine", "htmlBlock", "contextLine", "outputLine", " inputBlock", "nextLINE", "latLine", "inputBlock", "attLINE", "Inputline", "selectLINE", "textLINE", "nextRow", "helloLin", "InputBlock", "outputline", "textLine", "selectRow", "commandline", "helloLine", "actLine", "dataLine", "formLINE", "activeLINE", "htmlline", "inputRow", "attLine", " inputText", "actLINE", "httpLine", "actline", "httpLin", " inputline", "activeLine", "commandLINE", "contextLINE", "outputLINE", "selectLine", "formLine", "helloLINE", "dataLINE", "helloL", "inputText", "InputLine", "htmlLine"], "commandNameBegin": ["commandnamebegin", "commandFamilyBeg", "commandTypebegin", "commandNameStart", "commandNAMEMon", "commandNamesBeginning", "commandNamesbegin", " commandNamebegin", "commandFamilyMon", "commandTypeStart", "commandSizeBeg", " commandNameBeginning", "commandNameBeginning", "commandNameMon", "commandNamebegin", "commandSizeMorning", "commandNameEGIN", "commandNameInitial", "CommandNameStart", "commandnameBeginning", " commandNameEGIN", "commandnameBegin", " commandOrderStart", "commandFamilyInitial", "commandNAMEBegin", "commandLineBegin", " commandSizeMorning", " commandSizeBegin", "CommandNamebegin", "commandLineStart", "commandTypeBeginning", "CommandNameBegin", "commandFamilyBegin", " commandNameMon", "commandFamilyEGIN", "commandNAMEInitial", "CommandNamesBeginning", "commandOrderbegin", "commandFamilyBeginning", "commandOrderBeginning", "commandnameEGIN", "CommandNamesStart", "CommandNamesbegin", "commandnameBeg", "commandNamesStart", "commandSizeEGIN", "commandLinebegin", " commandOrderBeginning", "commandFamilyMorning", "commandNameMorning", " commandNameMorning", " commandNameInitial", "commandOrderStart", " commandSizeBeg", "commandOrderBegin", "CommandNamesBegin", " commandSizeEGIN", "commandLineBeginning", " commandOrderBegin", "commandSizeBegin", "commandnameStart", "commandNameBeg", " commandOrderbegin", " commandNameBeg", "commandNamesBegin", "commandnameMorning", "CommandNameBeginning", "commandNAMEBeginning", "commandTypeBegin", " commandNameStart"], "commandNameEnd": [" commandNamesEnd", " commandNameend", "commandStringEND", "formNameEND", "formNameStart", "commandNamesEND", " commandLineend", "commandNameStart", "commandSizeStart", "commandNamesStart", "commandStringEnd", "cmdNameEnd", "cmdTimeEnd", " commandNameEND", "commandLineEND", "commandNamesend", "commandLineend", "cmdNameend", " commandNamesEND", "commandNamesBegin", "commandTypeend", " commandLineEnd", "cmdNameEND", "cmdTimeend", "formNameEnd", "commandStringBegin", "cmdTimeEND", "commandnameend", "commandnameEnd", " commandNamesBegin", "formNameend", " commandLineEND", "commandTypeStart", "formSizeStart", "commandTypeEnd", "formSizeEND", "commandSizeEnd", "commandTimeEND", "commandNamesEnd", "commandLineEnd", "commandTypeEND", "commandSizeEND", "commandnameEND", "commandNameEND", "commandNameend", "commandTimeEnd", "formSizeEnd", "commandTimeend", "commandSizeend", "commandTypeBegin", " commandNamesStart", "formSizeend", " commandNameStart", "commandStringStart"], "item": ["info", "bar", "m", "row", "module", "im", "other", "link", "handler", "this", "rule", "object", "option", "Item", "base", "mix", "it", "add", "or", "mem", "check", "store", "question", "p", "image", "unit", "obj", "article", "owner", "element", "menu", "group", "items", "event", "member", "hit", "em", "iter", "mm", "local", "exp", "widget", "page", "title", "inner", "template", "tree", "app", "instance", "related", "index", "sim", "li", "i", "monitor", "el", "task", "match", "type", "entry", "button", "key", "label", "command"], "e": ["m", "re", "u", "t", "err", "w", "ent", "ee", "b", "ec", "c", "end", "eur", "ge", "h", "o", "a", "se", "be", "ed", "es", "fe", "oe", "ce", "error", "v", "p", "ze", "er", "ae", "l", "f", "ve", "r", "ea", "ev", "x", "q", "E", "n", "g", "one", "de", "pe", "eb", "ex", "eeee", "en", "ie", "ef", "le", "te", "i", "eg", "el", "eu", "ne", "ue", "event", "et", "d"]}}
{"id1": "4417943", "id2": "1586662", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"test": ["full", "install", "testing", "sample", " TEST", " benchmark", "base", "evaluate", "ping", "Example", " check", "example", " sample", " tests", "debug", "init", "server", "launch", " Test", "Test", "index", "tests", " testing", "execute", "hello", "foo", "status"], "query": ["sql", "params", "poll", "prefix", "condition", "quest", "Q", "filter", "quote", "question", "sequence", "menu", "spec", "password", "q", "term", "select", "code", "Query", "search", "string", "pattern", "random", "page", "input", "body", "index", "qa", "comment", "form", "qu", "view", "field", "type", "text", "qs", "command", "ql"], "url": ["pl", "sql", "ur", "api", "u", "http", "link", "https", "path", "ref", "ls", "base", "raw", "build", "address", "id", "name", "l", "print", "uri", "sl", "r", "nl", "log", "out", "q", "term", "str", "mount", "www", "location", "string", "title", "pattern", "pr", "Url", "web", "ul", "html", "xml", "dl", "ll", "format", "URL", "result"], "urlObj": ["lIt", "httpobj", "lObj", "lobj", " urlOb", "UrlOb", " urlobj", "httpOb", "urlOb", "nlobj", "nlIt", " urlIt", "Urlobj", "nlObj", "httpObj", "urlobj", "UrlObj", "urlIt", "lOb", "nlOb"], "con": ["nc", "cn", "dial", "pos", "in", "fn", "c", "cont", "un", "syn", "pen", "mc", "open", "ver", "cone", "soc", "Con", "cond", "connection", "ain", "obj", "can", "conn", "cur", "cl", "Conn", "ln", "cf", "fc", "win", "conf", "don", "sin", "conv", "com", "CON", "compl", "num", "connect", "canon", "co", "ran", "len", "const", "cons", "cos", "bc", "fin", "ctrl"], "model": ["record", "mod", "m", "re", "Model", "module", "zip", "link", "table", "object", "mi", "base", "value", "cell", "message", "buffer", "map", "transform", "sm", "me", "impl", "controller", "de", "dm", "set", "tree", "state", "save", "body", "gp", "man", "le", "sim", "cm", "el", "frame", "xml", "data", "vm", "models", "response", "dl", "job", "fine"]}}
{"id1": "1180878", "id2": "20924119", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchStringdata", "fectUrldata", "fetchUrlStream", "fetchStringStream", "fetchURLFrame", "fectUrlStream", "fetchURLStream", "fetchGETdata", "fectURLFrame", "fectURLStream", "fectUrlData", "fectURLdata", "fetchGETFrame", "fectUrlFrame", "fetchStringFrame", "fetchURLdata", "fectURLData", "fetchUrldata", "fetchGETData", "fetchUrlFrame", "fetchGETStream", "fetchUrlData", "fetchStringData"], "url": ["full", "pl", "domain", "sql", "ur", "null", "http", "link", "b", "https", "path", "ref", "ls", "host", "base", "default", "lim", "gl", "address", "name", "resource", "uri", "l", "log", "sl", "print", "nl", "cl", "rel", "mount", "location", "ssl", "string", "pattern", "Url", "mail", "web", "html", "ul", "el", "xml", "file", "loc", "dl", "ll", "URL"], "proxyHost": ["proxyUrl", "slaveLabel", " proxyCheck", "roxyOver", "serverHost", " proxyOver", "slaveAddress", " proxyhost", "serverName", "proxyOver", "roxyhost", "Proxyhost", "proxyLabel", "roxyHost", "proxyhost", "ProxyHost", "roxyLabel", "ProxyPort", "roxyCheck", "roxyUrl", "roxyAddress", "ProxyLabel", "proxyName", "ProxyName", " proxyAddress", " proxyName", "slaveCheck", "slaveUrl", "ProxyUrl", "proxyAddress", "serverhost", "slavehost", "proxyCheck", "serverPort", "slaveHost", "slaveOver"], "proxyPort": ["serverport", "aliasAddress", "Proxyport", "aliasHost", "serverHost", "aliasport", "ProxyHost", "ProxyPort", " proxyport", "serverPORT", "proxyport", " proxyAddress", " proxyPORT", "proxyPORT", "serverAddress", "ProxyPORT", "proxyAddress", "aliasPort", "serverPort"], "con": ["nc", "non", "cn", "go", "dial", "po", "close", "cal", "c", "un", "cont", "gate", "pen", "xc", "mc", "syn", "open", "ver", "cone", "func", "trans", "pan", "cc", "ocon", "Con", "cp", "cond", "cover", "client", "connection", "cs", "bo", "ain", "can", "call", "conn", "cur", "Conn", "sub", "proc", "rec", "ln", "cf", "cmd", "cat", "fc", "ex", "pc", "act", "en", "comm", "conf", "don", "conv", "com", "CON", "fac", "connect", "canon", "col", "co", "cgi", "ran", "lock", "mo", "cons", "cos", "bc", "fin", "ctrl", "const"], "is": ["was", "os", "ms", "sis", "isl", "im", "eps", "in", "bs", "us", "ios", "lis", "has", "its", "isi", "isc", "es", "ps", "iss", "ists", "cs", "ts", "ains", "isp", "ins", "s", "isf", "bits", "ois", "dis", "fs", "mis", "ist", "iris", "iter", "ip", "rs", "init", "isin", "si", "ri", "ris", "ys", "iso", "xs", "oss", "i", "abs", "sys", "as", "Is", "IS", "gets", "ais", "ims", "bis", "isa", "are"], "u": ["ur", "mu", "un", "c", "us", "ut", "o", "pu", "up", "su", "lu", "au", "ui", "uv", "uf", "hu", "uri", "uu", "yu", "fu", "g", "tu", "nu", "iu", "U", "ru", "uid", "user", "uj", " nu", "cu", "ou", "i", "ul", "eu", "uni", "ue", "ud", "bu"], "proxy": ["shadow", "project", "echo", "go", "domain", "cas", "null", " proxies", "zip", "po", "PRO", "http", "link", "https", "host", "base", "cone", "pi", "Proxy", "version", "XY", "socket", "cp", "phone", "slave", "address", "client", "connection", "port", "bo", "ping", "map", "password", "library", "pin", "pointer", "cache", "pro", "x", "pre", "pe", "aco", "profile", "ip", "timeout", "ssl", "alias", "xy", "token", "jp", "server", "gp", "pipe", "pse", "prime", "embed", "web", "friend", "via", "roxy", "pool", "py", "translation", "policy", " prox", "browser"], "baos": [" bao", "naos", "BAo", "BAos", " baows", " baOS", "baows", "poos", "nao", "vaos", "aoos", " baose", "BAOs", "vaoS", " baoss", "baoss", " baOs", "bao", "aoOS", "vaOS", "poOs", "vais", "poo", " bais", "baose", " baoS", "aois", "BAoss", "BAose", "baOs", "poose", "naoss", "naows", "BAows", "aooS", "bais", "baoS", "baOS"]}}
{"id1": "17296916", "id2": "411595", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"logging": [" logStorage", " logger", "loging", "Logger", "LogStorage", "logger", "logStorage", "Loging", " loging", "debuging", "debugging", "debugStorage", "Logging", "debugger"], "wrap": ["handle", "ad", "w", "zip", "parse", "link", "read", "gate", "wx", "ws", "grow", "get", "W", "pad", "add", " wrapped", "aw", "wind", "python", "store", "sp", "build", "use", "message", "ow", "wrapper", "reset", "sw", "transform", "x", "window", "me", "ew", " wrapper", "safe", "find", "pack", "create", "start", "inter", "work", "word", "wire", "root", "wra", "rap", "web", "force", "box", "wa", "form", "chain", "nw", "format", "xf", "we", "shape"], "buffer": ["bar", "memory", "row", "note", "phrase", "binary", "buff", "table", "surface", "document", "batch", "base", "reference", "line", "block", "Buffer", "bb", "flash", "store", "quote", "message", "sequence", "writer", "bo", "pb", "directory", "report", "print", "library", "wrapper", "reset", "flag", "queue", "cache", "window", "buf", "console", "builder", "output", "profile", "iter", "reply", "template", "word", "position", "screen", "bridge", "body", "database", "ob", "trace", "face", "frame", "header", "size", "view", "layer", "button", "display", "command", "complete", "attribute", "append"], "encoding": ["enumging", "Encoding", "enaling", "enging", "clanguage", "enoding", "cododing", "enlanguage", "cododed", "encging", "enoded", "ecoding", "enclanguage", "enryption", "Encryption", "coding", "ecoded", "encoded", "caling", "enumoder", "cging", "cryption", "encaling", "encoder", "ecryption", "encryption", "coder", "enumlanguage", "enoder", "ecoder", "cododer", "Encoder", "codryption", "Encaling", "enumoding"], "getEncoding": ["getEncling", "getEnging", "getExpging", "getEnling", "getEncination", "getOrigoding", "getencling", "getOrigination", " getEnging", "getOrigling", "getEnination", " getEncging", "getEnression", "getExpryption", " getEnoding", " getEncryption", "getencryption", "getencoding", "getencination", " getEncression", "getOrigryption", " getEnling", " getEnryption", "getEncression", "getExpression", " getEnression", "getEnoding", " getEncling", "getExpoding", "getencging", "getEncryption", "getencression", " getEnination", "getEncging", " getEncination", "getEnryption"], "headers": ["styles", "modules", "frames", "params", "authors", "codes", "ctors", "relations", "values", "users", "ers", "pins", "heads", "checks", "blocks", "fields", "comments", "members", "ilers", "ids", "caps", "weights", "rs", "groups", "objects", "boxes", "keys", "holders", "ports", "writers", "drivers", "properties", "head", "terms", "reports", "pres", "names", "header", "builders", "chains", "ppers", "limits", "images", "tags", "ters"], "is": ["was", "os", "sis", "ms", "isl", "in", "bs", "us", "ios", "lis", "has", "osi", "isi", "its", "or", "isc", "tis", "ui", "iss", "ists", "ins", "ic", "isf", "does", "ois", "dis", "fs", "mis", "ist", "iris", "nis", "ip", "isin", "si", "ri", "\u00eds", "ris", "ys", "iso", "isd", "i", "sys", "as", "Is", "IS", "ais", "ims", "bis", "isa", "obs"], "bos": ["fits", "os", "ms", "bh", "bones", "ones", "bs", "oops", "banks", "eros", "bes", "aos", "ios", "soc", "tes", "isi", "boards", "lets", "tis", "ui", "uts", "ts", "cs", "bo", "ows", "bits", "oids", "ses", "js", "fs", "los", "bi", "ods", "ols", "bin", "oos", "ubis", "bas", "tops", "jas", "ys", "windows", "pod", "oss", "uds", "bot", "sys", "des", "nos", "bytes", "ots", "stats", "bis", "cos", "dos", "ps", "obs"], "e": ["m", "re", "t", "err", "ee", "c", "ge", "o", "h", "a", "se", "ed", "es", "oe", "error", "p", "v", "er", "ae", "f", "r", "ev", "x", "E", "n", "g", "me", "de", "ex", "eeee", "en", "ie", "exc", "ate", "le", "i", "ne", "d"]}}
{"id1": "13666876", "id2": "6421904", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["transformsingleModel", "transformMultiFile", "TransformSingleFile", "TransformSingleRecord", "transformSingleModel", "TransformSimpleModel", "transformOneFile", "transformSingleFiles", "processSingleFile", "transformsingleFile", "transformsingleFiles", "processSingleFiles", "transformMultiFiles", "transformSimplePage", "transformSinglefile", "processsingleFiles", "transformsinglePage", "TransformSimpleFile", "transformMultiModel", "processsingleFile", "transformOneSourceFile", "transformMultiSourceFile", "transformsingleRecord", "transformSimpleModel", "TransformSinglePage", "transformSinglePage", "transformOneFiles", "transformSimpleRecord", "transformsingleSourceFile", "processsinglefile", "transformsinglefile", "transformMultiPage", "transformSimpleFile", "TransformSingleModel", "transformMultifile", "transformSingleRecord", "transformOnefile", "transformMultiRecord", "processSinglefile", "transformSingleSourceFile", "processSingleSourceFile", "processsingleSourceFile", "TransformSimplePage", "TransformSimpleRecord"], "xed": ["rxed", "rxeds", "xied", "wxred", "passEd", "passED", "exED", "pxeded", "Xeded", "xeded", "exeded", "xented", "txed", " xented", "xred", "uxied", "exeds", "passred", "wxEd", "xED", "Xed", "pxED", "exed", "pxeds", "rxED", "Xer", "rxer", " xED", "pxed", "wxied", "passed", "xeds", "txED", "XED", "wxed", " xred", " xEd", "wxented", "xer", "uxED", "wxED", "Xeds", "txer", " xied", "uxented", "xEd", "uxed", "txeds"], "node": ["process", "row", "note", "link", "ode", "our", "object", "component", "Node", "range", "line", "parent", "day", "name", "right", "hand", "image", "directory", "resource", "post", "map", "seed", "stage", "feature", "one", "n", "station", "no", "de", "set", "create", "entity", "tree", "word", "index", "edge", "scene", "view", "channel", "array", "remote", "job", "entry", "and", "event", "load"], "dob": ["dobar", " dab", "dobb", "Doy", "adobar", "Dab", "adab", "diob", " doy", "dod", " dobar", "adob", "drobb", "adoy", "dab", "Dobar", "drod", "diod", "drab", "doy", " dod", "Dob", "drob", " dobb", "diab", "diobb"], "mySrc": ["mySourcerc", " mySfc", "MySRC", "myInsrc", "mySsrc", "mySelsrc", "mySource", "mySfc", "myDesrc", " mySsrc", "myDesources", "mySingrc", "mySourceRC", "myDesRC", " mySRC", "mySources", "myAsRC", "mySRC", "mySingfc", "mySingsrc", "myInssrc", "myInsfc", "myAsource", "MySrc", "MySources", "mySourceource", "mySingRC", "mySelrc", "MySource", "MySsrc", "myInsRC", "myAssrc", "mySourcesrc", "myAsrc", "mySelRC", "myDessrc", "mySelources"], "mySrcF": ["myMourceV", "mySrcV", "mySufO", "mySRCP", "mySrtI", "myMrcFP", "mySsrcF", "mySsrcI", "mySrcC", "mySufV", "mySRCF", "myMourceF", "mySourceV", "mySrcO", "myMrcO", "myMourceFP", "mySourceFP", "mySufFP", "mySRCI", "mySsrcFP", "mySourceO", "mySrcI", "mySsrcP", "mySRCC", "mySsrcO", "mySsrcV", "mySrtF", "myMrcF", "mySsrcC", "myMourceO", "mySrtP", "mySufF", "mySourceF", "mySrtC", "mySrcP", "myMrcV", "mySrcFP"], "myOutF": ["myoutC", "mysNetL", "myOutputE", "MyInFs", " myoutF", "myOutputFile", "myArtFL", "mysNetW", "myOutputFs", " myOutV", "myObjFile", "myOutL", "myOutV", "myOutputC", "myOutputF", "myOutE", "myOffFile", "myOutputV", "myOffF", "mysOutL", "myOutW", " myoutL", "myOutputL", "MyOutFs", "myCoL", "myoutL", "myOutFile", "myoutF", "myArtL", "myInF", "myArtF", "myObjV", "myInV", "myOutputDF", "myOffDF", "myOutC", "MyInF", "myInFs", "mysOutW", "mysNetFL", " myoutV", "mysOutF", "MyOutV", "mysOutFL", "myObjFs", "myOutDF", "myNetF", " myOutL", "myCoW", "MyOutF", "MyInFile", "myInFile", "myArtW", "myoutV", "myNetFile", "myInL", "myNetL", " myOutE", "myNetW", "myCoF", "myNetE", "MyOutFile", "myOutFL", " myNetFile", "myInC", " myNetF", "myObjF", " myOutFile", "myNetDF", "MyInV", " myoutC", "myOffE", "myOutFs", " myOutC", " myNetDF", "myCoFL", "mysNetF", "myNetFL", " myOutDF", " myNetE"], "co": ["ico", "nc", "ace", "go", "ci", "oc", "po", "roc", "gc", "lo", "cal", "c", "coll", "xc", "o", "lc", "soc", "cho", "cc", "ce", "cover", "coord", "cs", "yes", "flo", "can", "obj", "io", "cache", "fo", "cl", " Co", "CO", "no", "aco", "ro", "fc", "copy", "ror", "cu", "ko", "con", "ck", "com", "ho", "wo", "Co", "cm", "cv", "loc", "so", "cop", "mo", "ca", "cod", "cos", "col", "ctrl"], "x3dvFile": ["x3dvsPath", "x3dvsFile", "x3dbString", "x3dbFile", "x3pdbFile", "x3cdvFilename", "x3dbFilename", "x3pdvFilename", "x3dvString", "x3dtFilename", "x3dvFilename", "x3pdbfile", "x3cdVFilename", "x3dVString", "x3dbfile", "x3dVPath", "x3dVfile", "x3cdVFile", "x3dVFilename", "x3pdvString", "x3dtString", "x3pdvfile", "x3dtFile", "x3cdvPath", "x3pdbString", "x3cdvFile", "x3dtfile", "x3pdbFilename", "x3dvPath", "x3dvsFilename", "x3pdvFile", "x3davFilename", "x3cdVPath", "x3davPath", "x3dVFile", "x3dvfile", "x3davFile"], "fis": ["bisi", " fisi", "fie", "biss", "bie", "fileires", " fie", "flis", " fiz", "fliss", "frie", "fiss", " fires", "fisi", "frisi", "fires", " fiss", "fiz", "fileiss", "fileis", "flires", "fliz", "fris", "bis", "friss", "fileiz"], "gzos": ["gzoss", "go", "ggoes", "gtoss", "gtops", "gaos", "zies", "ziposs", "gzaos", "gsops", "gtos", "zipnos", "ggos", "gties", "zo", "zops", "ggops", "gtnos", "gtoes", "gsos", "gzies", "zoss", "gzo", "gznos", "gzoes", "zoes", "gzops", "goss", "sslos", "zos", "gos", "sslaos", "sslo", "zipops", "ggies", "gsnos", "ssloss", "zaos", "gsoss", "zipos"], "buf": ["bar", "wb", "orig", "buff", "b", "cap", "pkg", "mu", "ref", "batch", "font", "raw", "block", "mem", "Buffer", "vec", "fb", "buffer", "uf", "emb", "tab", "var", "cur", "Buff", "seq", "aka", "cf", "cmd", "cat", "good", "bag", "cam", "rb", "img", "br", "conv", "cb", "box", "cv", "bytes", "cast", "max", "bus", "arr"], "ret": ["rt", "re", "pret", "ft", "err", "alt", "gt", "val", "end", "cont", "back", "RET", "ref", "repl", "v", "arg", "obj", "mt", "deg", "print", "r", "rets", "out", " Ret", "res", "test", "cmd", "iter", "ctr", "att", "inter", "def", "continue", "tr", "nt", "ext", "ptr", "ry", "ter", "red", "Ret", "len", "cert", "aux", "elt", "et"]}}
{"id1": "18451704", "id2": "22993368", "code1": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"isValidPage": ["isCompleteRow", "isCompletePage", "isValidRow", "isSupportedRow", " isAvailablePoint", "isAvailablePage", "isCompletePoint", "isCompletepage", " isValidpage", "isSupportedpage", "isAvailablepage", "isAvailableRow", " isValidRow", " isAvailablePage", " isAvailablepage", " isAvailableRow", " isValidPoint", "isValidpage", "isAvailablePoint", "isSupportedPoint", "isSupportedPage", "isValidPoint"], "page": ["property", "e", "block", "version", "address", "port", "article", "log", "code", "node", "me", "see", "wikipedia", "word", "channel", "display", "attribute", "project", "row", "table", "pp", "post", "to", "report", "password", "layout", "out", "request", "site", "age", "web", "config", "header", "key", "result", "record", "office", "link", "document", "pg", "peer", "Page", "application", "pe", "server", "file", "book", "collection", "true", "item", "module", "phrase", "rule", "object", "base", "be", "parent", "name", "message", "p", "image", "resource", "content", "cache", "admin", "window", "create", "language", "title", "instance", "bp", "frame", "data", "entry", "policy", "chain", "event", "complete"], "panel": ["bar", "join", "dial", "spin", "chart", "table", "cal", "span", "bean", "sheet", "desktop", "Panel", "block", "pan", "peer", "list", "addon", "cell", "menu", "summary", "login", "group", "layout", "tab", "window", "plugin", "console", "controller", "local", "profile", "widget", "plan", "pal", "container", "within", "title", "inner", "notice", "player", "bridge", "manager", "el", "frame", "view", "tool", "label", "radius"], "isValid": ["isPublic", "imOk", "setOk", "formAvailable", " isPresent", "IsOk", "hasOk", " isvalid", "imValid", " isVal", "ISInvalid", " isFound", "IsAvailable", "ISValid", "setActive", "isInvalid", "tracevalid", "isFound", "lisOk", "lisValid", "lisPublic", " isAvailable", " isActive", "lisInvalid", "isOk", "hasValid", "stillValid", "ISVal", "isAvailable", "ISFound", "IsValid", "formValid", "formvalid", "ISOk", "issValid", "traceValid", "setValid", "traceAvailable", "isVal", "IsFound", "stillVal", "imAvailable", " isInvalid", "stillInvalid", "isvalid", "ISAvailable", "hasPublic", "isPresent", "hasInvalid", "issVal", "issOk", "IsInvalid", "traceInvalid", "IsActive", "formInvalid", " isOk", "imInvalid", "setPresent", " isPublic", "IsPresent", "issInvalid", "isActive", "stillOk"], "url": ["ur", "u", "null", "http", "email", "link", "b", "https", "ml", "build", "address", "name", "resource", "uri", "l", "f", "sl", "r", "nl", "rl", "str", "window", "mount", "user", "sb", "location", "ssl", "string", "char", "Url", "mail", "abs", "ul", "external", "file", "ll", "dl", "tool", "open", "cert", "URL", "browser"]}}
{"id1": "5951610", "id2": "18238468", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testApplicationURL", "testNetURL", "testApplicationHTML", "TestNetworkURL", "testNetHTML", "TestNetworkHTML", "TestNetURL", "TestNetHTTP", "TestNetHTML", "testNetworkHTML", "TestNetworkHTTP", "testNetworkURL", "testApplicationHTTP", "testNetHTTP"], "url": ["ret", "pl", "m", "lr", "u", "ur", "t", "http", "hl", "email", "link", "b", "https", "il", "path", "back", "ref", "ls", "util", "base", "gl", "get", "github", "host", "ml", "address", "resource", "obj", "l", "log", "print", "sl", "r", "nl", "fl", "rl", "conn", "cl", "term", "str", "org", "rel", "blog", "mount", "www", "impl", "bl", "uri", "console", "location", "pull", "ssl", "all", "ocl", "lt", "Url", "mail", "web", "html", "el", "ul", "norm", "dl", "loc", "ll", "lb", "channel", "acl", "cert", "URL"], "urlConnection": ["httpHandler", "methodConnection", "utilService", "lsConnect", "sslConn", "lrConn", "urlDiscussion", "implConnection", "httpSet", "managerConnect", " urlHandler", "managerConnector", "consoleConnection", "railListener", " urlMachine", "resourceConnection", "mlConn", "implConnector", "sslConnection", "managerInfo", "browserConnection", "mlConnection", "emailConnect", "utilConn", "lsConn", "sslPosition", "urlConnect", "urlListener", "railConnection", "httpService", "urlHandler", "consoleConn", "httpConnector", "managerConnection", "httpListener", "urlService", " urlInfo", " urlCon", "railHandler", "urlMachine", " urlDiscussion", "urlConn", "fileConnection", " urlResponse", "resourceConnector", "fileConnect", "fileConn", "mlCon", "urlSet", " urlConnector", "emailConnection", "implConnect", " urlService", "urlInfo", "dbConnect", "urlResponse", "methodConnector", " urlConnect", "dbPosition", "utilConnection", "resourceResponse", "browserConn", "sslConnector", "dbConn", "emailConnector", " urlConn", " urlPosition", "railConnect", "nameConnector", "resourceConn", "fileDiscussion", "urlPosition", "httpConnection", "sslConnect", "utilConnect", "sslDiscussion", "utilListener", "nameConnection", "methodConn", "lrConnection", "lsConnection", "mlMachine", "nameConnect", "utilSet", "lrConnector", "httpConn", "implConn", "methodConnect", "urlCon", "nameConn", "lsConnector", "lrResponse", "httpConnect", "httpInfo", " urlListener", " urlSet", "consoleMachine", "dbConnection", "urlConnector", "browserConnect", "emailConn", "consoleCon", "utilConnector", "browserConnector"], "rd": ["rt", "lr", "rw", "gd", "rob", "rend", "ped", "ld", "rc", "rax", "rand", "dra", "repl", "xd", "drm", "mr", "erd", "nd", "ered", "RD", "rer", "ind", "rus", "rm", "dig", "ra", "r", "bd", "rl", "std", "rg", "wr", "hr", "ord", "rs", "rod", "rx", "nder", "dr", "ined", "rb", "art", "ck", "ri", "rid", "adr", "usr", "din", "ird", "rr", "fr", "rown", "ptr", "rez", "red", "ded", "grad", "fd", "rn", "rh", "dd", "dir", "d"], "line": ["record", "LINE", "row", "column", "email", "link", "length", "lo", "where", "stay", "eline", "range", "inline", "side", "block", "ice", "part", "check", "none", "error", "cell", "message", "buffer", "Line", "port", "l", "log", "nl", "number", "lines", "cl", "LIN", "node", " LINE", "ln", "iter", "set", "lin", "string", "page", "continue", "next", "zone", "point", "le", "pipe", "edge", "frame", "comment", "status", "file", "online", "loop", "channel", "lock", "entry", "time", "ine", "len", "liner", "load"]}}
{"id1": "20208819", "id2": "23517481", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hash": [" Hash", "update", "read", "dump", "run", " fingerprint", "h", "get", "value", "check", "name", "id", "message", "password", "print", "uri", " hashing", "code", "sign", " sum", "render", "sha", "Hash", "sum", "tag", "format", "key"], "input": [" inputs", "null", "in", "active", "sample", "empty", "bit", "url", "prefix", "raw", "value", "valid", "message", "buffer", "image", "p", "this", "sequence", "password", "out", "request", "Input", "source", "q", "example", "select", "output", "string", "pattern", "current", "char", "lat", "config", "form", "data", "hello", "text", "command", "accept"], "algorithm": ["alphgo", "alphabet", "alometry", "assometry", "arometry", "assgorithm", "alphgorithm", "argo", " Algorithm", "assabet", " Aloch", "validgorithm", "alabet", "arabet", "validometry", "aloch", "algo", "argorithm", " Algo", "Aloch", " Alabet", "Algo", "assgo", "validgo", "Alabet", "validabet", "alphoch", "Algorithm"], "dig": ["dd", "mod", "plug", "df", "rip", "ld", "dh", " Dig", "add", "nd", "rd", "ng", "desc", "dash", "del", "ind", "cd", "md", "deg", "od", "ve", "bd", "dec", "enc", "sd", "g", "pers", "de", "round", "find", "dat", "cr", "comm", "dep", "div", "fun", "alg", "dim", "db", "des", "her", "grad", "fin", "cong", "Dig", "dir", "d"], "result": ["ret", "make", "join", "answer", "true", "mark", "pixel", "run", "total", "rc", "component", "currency", "up", "prefix", "pair", "success", "results", "region", "reason", "part", "use", "this", "summary", "mate", "group", "report", "print", "wrapper", "r", "out", "proc", "created", "term", "date", "res", "ral", "user", "output", "product", "profile", "create", "dat", "complete", "continue", "position", "render", "current", "br", "next", "relation", "Result", "comment", "description", "match", "response", "display", "event"], "digest": [" digate", "digse", "hasenge", " digenge", "equested", "Digested", "Digse", "hasate", "digtest", "displayEST", "definedest", "definedgest", "digested", "digenge", "equgest", "displayested", "Digtest", "dist", "DigEST", "digate", "Digist", "dested", "displayist", "dest", "Diggest", "Digenge", " digested", "diggest", "definedse", "displayest", "hasested", "equest", " digEST", "digist", "Digate", "Digest", "displaytest", "digEST", "dgest", "equse", "displaygest", "hasest", "definedested", " digtest"], "hex": ["hist", "full", "rex", "hw", "row", "solid", "hl", "zip", "wh", "https", "zero", "alph", "ch", "h", "key", "prop", "alpha", "utf", "raw", "nuts", "sh", "check", "color", "serial", "sex", "print", "pex", "ape", "x", "term", "sv", "ex", "percent", "tex", "exp", "iter", "oct", "def", " Hex", "char", "com", "ph", "index", "json", "comp", "html", "des", "form", "tx", "xf"], "i": ["info", "ji", "m", "ci", "im", "z", "phi", "j", "ii", "gi", "qi", "I", "mi", "ti", "a", "batch", "pi", "it", "e", "di", "ini", "ui", "ind", "zi", "id", "hi", "y", "v", "multi", "ic", "uri", "k", "print", "io", "f", "ai", "\u0438", "x", "n", "g", "me", "iu", "bi", "ip", "cli", "si", "ij", "ki", "ri", "conv", "index", "li", "ix", "xi", "ei", "status"], "u": ["ur", "t", "unsigned", "b", "mu", "c", "us", "ut", "h", "util", "pu", "up", "su", "lu", "au", "ui", "v", "uv", "hu", "uu", "f", "uc", "um", "q", "fu", "uint", "tu", "nu", "iu", "U", "uid", "user", "you", "uj", "cu", "num", "ou", "ul", "eu", "uni", "ue", "bu", "d"], "highCount": ["topCode", "HighPtr", "hiFlag", "highCode", "lowcount", "lowCast", " highFlag", "higherAmount", "topCount", "higherCast", "Highcount", "highCast", " highPtr", "highFlag", "hiCount", " highcount", "lowLength", "hiLength", " highCode", "topPtr", "lowFlag", "lowAmount", "hiCast", "highPtr", "HighCode", "highercount", "higherCount", " highLength", "highAmount", " highAmount", "highLength", "topcount", " highCast", "HighCount", "highcount"], "lowCount": ["ownCold", "midCountry", "littleCount", "littleLength", " lowCold", "midCold", "littleCountry", "littleCounter", "midSum", "midCounter", "lowCountry", "lowButton", "lowCold", "midCount", "lowLength", " lowSum", "lowSum", " lowButton", "ownSum", "midLength", "ownCount", "highCountry", "ownButton", "highLength", "highCounter", "midButton", "lowCounter"]}}
{"id1": "8490710", "id2": "13233761", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"actualizar": [" actualizear", " actualizeer", " actualisAR", "ualizaer", " actualizeAR", "ualizAR", " actualiziar", " actualizer", " actualisar", "ualizaiar", " actualizaiar", "ualiziar", " actualizAR", "ualizer", "ualizaAR", " actualizaAR", " actualizeiar", " actualisiar", " actualizaar", "ualizar", " actualizaer", " actualiser", "ualizaar"], "ClassNotFoundException": ["ClassNotPresentError", "ClassNotfoundException", "ClassNotfoundError", "ClassNotFoundError", "ClassNotPresentException"], "Exception": ["File", "Operation", "End", "EX", "Event", "I", "Interface", "Throw", "Message", "Configuration", "Connection", " exception", "Error", "Type", "Option", "Application", "None", "Exc", "Example", "E", "T", "Index", "Time", "Class", "Warning", "Response", "Null", "Context", "Transaction", "Result", "Status", "Instance", "Handler", "Exit", "ception", "Un", "ION", "Ex"], "conn": ["nc", "cn", "sql", "sc", "exec", "ec", "gate", "c", "close", "rc", "ch", "mc", "pen", "ws", "cc", "ct", "pg", "socket", "ns", "Con", "cp", "pas", "Connection", "connection", "yes", "client", "obj", "mt", "yn", "Conn", "Connect", "enc", "org", "js", "n", "ln", "cmd", "die", "rs", "act", "ctx", "ens", "init", "en", "comm", "ks", "con", "jp", "conf", "nt", "session", "oss", "db", "config", "pool", "connect", "cb", "ann", "sys", " con", "open", "ont", "cert", "ctrl"], "ms": ["mod", "m", "ants", "os", "eds", "eps", "mp", "cms", "arms", "bs", "ents", "vs", "mc", "ws", "mi", "pm", "uns", "ml", "ns", "ies", "uts", "ts", "cs", "mill", "md", "mn", "s", "mt", "ins", "mys", "mes", "mos", "ces", "Ms", "sm", "ats", "js", "fs", "mic", "res", "ocks", "pers", "mm", "rs", "mx", "ks", "MS", "ys", "windows", "xs", "terms", "ma", "inv", "posts", "sys", "ems", "is", "ims", "qs", "ps", "cus"], "fechaSystem": ["fechoaServer", "fechasystem", "fechaSTEM", "fechaeServer", "fechaServer", "fechoSys", "fetaSys", "feshoServer", "fechoaSys", "feshaServer", "fetaeSys", "fetasystem", "fechoasystem", "feshoSystem", "fechaeSTEM", "fetaesystem", "fechoaSystem", "fechoSTEM", "fechaeSystem", "fochaSystem", "feshosystem", "fochaServer", "feshasystem", "fechtaServer", "feshaSystem", "fechtaSystem", "fechtaSTEM", "fechiSys", "fochtaServer", "fetiSystem", "fetaSystem", "fetaeSystem", "fechlaSystem", "fechosystem", "fechisystem", "fechaeSys", "fechlasystem", "fechoServer", "fochaSTEM", "fechaesystem", "fetisystem", "fechlaSys", "fechaSys", "fechoSystem", "fochtaSTEM", "fetiSys", "fochtaSystem", "fechiSystem"], "aaaammdd": ["aaammdd", "aaaaammd", "aaaammds", "aaammd", "aammd", "aaaammmd", "aammdd", "aaammmm", "aaaammm", "aaaaamd", "aaaammmm", "aaaamds", "aaaaummd", "aaaamd", "aammds", "aaaaumd", "aaaammd", "aaaamdd", "aaaaamdd", "aaaaammm", "aaaamld", "aaaaammdd", "aaammds", "aaaaumdd", "aaaaumds", "aammmd", "aaaamldd", "aaammmd", "aaaamlmm", "aaaaammmm"], "fzafsis": ["fzajesi", "fzeajesi", "fzeajses", "fzamsis", "fzamses", "fzahesi", "fzamsi", "fzeajsi", "fzamesi", "fzafsi", "fzajses", "fzajsi", "fzeafses", "fzahses", "fzeajsis", "fzajsis", "fzafesi", "fzeafsis", "fzafses", "fzeafesi", "fzahsi", "fzeafsi"], "hhmmss": ["hhmbse", "hhmmmse", "hhmbs", "hmmbess", "hmmmss", "hmmms", "hhmms", "hhmmess", "HHMMms", "hhmbess", "hmmbse", "HHmmms", "hhmmmms", "hhMMss", "hhmmms", "hhMMse", "hhMMess", "HHMMss", "hhmmmss", "hmmbs", "hhMMps", "hhmmmps", "hhMMms", "HHmmps", "hhmmps", "hhmps", "hhmbss", "hhmmmess", "HHMMps", "hhmmse", "hmmbss", "hmmmess", "hhMMs", "hhmss", "HHmmss", "hmmmse", "HHmms", "HHMMs", "hhms"], "sss": ["ssn", "rssss", "ssss", "isss", "rsses", "ossss", " ssss", "esses", "essl", " ssn", "isses", "esss", " ssjs", "rssl", "osss", "ssl", "ssjs", "essn", "ossjs", "ossn", "rsss", "issl", "sses", "essjs", "issss", "essss"], "ss": ["pass", "styles", "sql", "less", "tz", "tt", "pps", "bs", "https", "ws", "css", "SS", "se", "su", "sh", "sq", "ns", "iss", "cs", "ts", "s", "ress", "sl", "sf", "ses", "str", "sd", "js", "sv", "\u00df", "txt", "rs", "good", "sb", "rss", "lower", "string", "si", "ds", "ssl", "xx", "ius", "hess", "ys", "hs", "pse", "oss", "pres", "ass", "sys", "ess", "tx", "stats", "ps"], "fzahsis": ["fizafses", "fzaforus", "fzahorus", "fzabsi", "fizafsi", "fzafsi", "fizaforus", "fzabsis", "fzaborus", "fzaqsi", "fzahses", "fizahses", "fizafsis", "fzaqsis", "fzafses", "fzaqses", "fizahorus", "fzaqorus", "fzabses", "fzahsi", "fizahsi", "fizahsis"], "afectados": ["affECTados", "affECTado", "afelectulas", "affettulas", "afelectados", "afittulas", "affettados", "afettators", "afectarians", "afECTado", "afectionarians", "afittadas", "afettadas", "afecturated", "afECTados", "affectulas", "afitectarians", "affettators", "affectadas", "afittados", "affectarians", "afectionados", "afittators", "affectado", "afitecturated", "afectators", "affectators", "afectado", "afectadas", "afelectators", "afECTarians", "afECTurated", "afettados", "affecturated", "afitectado", "afectionurated", "affectados", "affettadas", "afectionado", "affECTarians", "afitectados", "afettulas", "afectulas", "afelectadas", "affECTurated"]}}
{"id1": "17786231", "id2": "807346", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "label": 0, "substitutes": {"downloadFile": ["transferFile", "getfile", "downloadfile", "transferfile", "getFile", "loadContent", "loadfile", "transferResource", "downloadResource", "loadResource", "loadFile", "downloadContent", "getContent", "getResource", "transferContent"], "downloadUrl": [" downloadURL", "transferWar", "linkUr", "linkUrl", "downloadURL", "DownloadUrl", "installUrl", "reportUrl", "reportURL", "DownloadURL", "downloadUr", "downloadWar", " downloadUr", "installUr", "installURL", "DownloadWar", "transferUrl", " downloadLink", "reportUr", "reportWar", "DownloadUr", "transferUr", "linkLink", "downloadLink", "transferURL", "installLink", "linkURL"], "destinationFile": ["destiningFile", "destarationFolder", "coordacementFile", "coordinationFolder", "destiningSourceFile", " destinationDir", "coordinationFile", "destinationDir", " destificationFile", "destiningDir", "coordinationfile", "destiningPath", "destinationPath", "destacementName", " destificationPath", " destinationPath", " destinationSourceFile", "destarationSourceFile", "destinationFolder", "destinatedFolder", "coordacementFolder", "destificationPath", " destificationDir", "destinatedFile", "destarationfile", "destinationName", "destificationDir", "destarationName", "destacementfile", "coordacementfile", "coordacementName", "destarationDir", "destacementFolder", "destificationSourceFile", "destinationSourceFile", " destificationSourceFile", "destacementFile", "destarationFile", "destinationfile", "coordinationName", "destinatedName", "destinatedfile", "destificationFile", "destarationPath"], "client": ["ci", "tc", "api", "http", "https", "url", "key", "system", "connection", "context", "resource", "wrapper", "uri", "call", "io", "cache", "service", "cl", "conn", "request", "console", "cli", "google", "template", "server", "network", "query", "city", "pool", "cm", "force", "co", "channel", "remote", "contact", "phone", "Client", "net", "collection"], "httpGet": [" httpGET", "hget", " httpQuery", "HttpPut", "utilGet", "hGet", "httpPut", "HttpGet", " httpPut", "httpGET", "HttpGET", "utilGET", "ttpget", "hPut", "HttpQuery", "utilQuery", "ttpPut", "ttpGet", "httpQuery", "Httpget", "utilPut", "httpget"], "outputFile": ["OutputPlace", "betaFILE", "tempFILE", "tempStream", "seeFILE", "outFile", "regionStream", "outputPoint", "betaFile", "seeFile", "OutputStream", "outPoint", "tempFile", "newStream", "newFile", "OutputPoint", "OutputFile", "outStream", "regionFile", "outputFILE", "outPlace", "newPoint", "outputPlace", "newPlace", "regionFILE", " outputFILE"], "outputStream": ["coinStreamer", "responseStyle", "coinStyle", "coinSteam", "outputForm", "putStyle", " outputstream", " outputForm", "outputSteam", " outputStyle", "OutputStream", "responseStream", "outputstream", "printFile", "inputSteam", "printForm", "OutputStyle", "putStreamer", "responseSteam", "inputStreamer", "inputView", "inputFile", "putStream", "inputStyle", "printSteam", "Outputstream", "coinStream", "putSteam", "OutputView", "inputstream", "OutputSteam", " outputView", " outputStreamer", "outputView", "outputStyle", "outputStreamer", "responseStreamer", " outputSteam", "printStream", "inputForm"], "response": ["answer", "details", "http", "resp", "document", "onse", "version", "block", "message", "connection", "image", "resource", "yes", "post", "content", "service", "request", "example", "still", "application", "output", "given", "page", "reply", "server", "Response", "body", "json", "description", "data", "initial", "entry", "remote", "status", "result", "attribute"], "entity": ["info", "details", "person", "detail", "note", "email", "existent", "total", "document", "security", "object", "component", "secure", "line", "e", "unique", "valid", "peer", "quote", "activity", "error", "image", "resource", "obj", "buffer", "group", "message", "content", "account", "member", "cache", "enc", "pe", "local", "profile", "name", "metadata", "associated", "encrypted", "instance", "properties", "existing", "body", "iso", "json", "Entity", "ity", "el", "xml", "comment", "data", "ilo", "translation", "entry", "type", "ent", "status", "event", "result", "attribute"], "inputStream": ["imagestream", "sourcestream", "imageStream", "outputForm", "thisSteam", " inputView", "outputSteam", " inputstream", "InputForm", "thisStyle", "readStream", "InputStyle", "readForm", "imageView", "outputstream", "evalSteam", "inputSteam", "evalView", "thisStream", "inputStreamer", "sourceSteam", "inputView", " inputForm", " inputSteam", "evalStreamer", "upForm", "activeStreamer", "upSteam", "upStream", "inputStyle", "sourceView", "readstream", "readSteam", "upstream", "inputstream", "InputSteam", "outputView", "outputStyle", "sourceStream", "activeView", "evalStream", "imageSteam", "InputStream", "inputForm", "Inputstream", "activeSteam", "activeStream", " inputStreamer", "thisForm"], "callback": ["browser", "processor", "creator", "facebook", "update", "gc", "handler", "back", "CB", "func", "cc", "binding", "consumer", "cell", "filter", "message", "wrapper", "background", "call", "library", "backs", "Callback", "window", "function", "soon", "pattern", "alias", "token", "continue", "lambda", "display", "manager", "actor", "cb", "closure", "policy", "job", "parser", "hook", "loader", "sound", "finder", "builder"], "copiedLength": ["copifiedNumber", "CopedDuration", "CopiedLength", "copedLen", "copySize", "copifiedLength", "copiedNumber", "copiedLen", "CopedNumber", "CopedSize", "copifiedDuration", "CopiedDuration", "copifiedLen", "copedNumber", "CopedLen", "copedLength", "copedSize", "copiedDuration", "copiedSize", "copIEDDuration", "CopiedNumber", "copIEDNumber", "copyDuration", "CopiedLen", "copIEDLength", "copyLength", "copedDuration", "CopiedSize", "CopedLength", "copifiedSize", "copyLen"], "percentage": [" percenture", "CENTages", "capages", "CENTage", "capale", "CENTure", "Percenture", "percenture", "Percentage", "Percentale", "capage", "percentages", " percentaging", "Percentages", "Percentaging", " percentale", "capaging", "percentaging", "percentale", " percentages"]}}
{"id1": "15896098", "id2": "21489105", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Checkums", "getSHA256Checkchecksum", "getSHA256Checksums", "getSHA256Checksam", "getSHA256Checkchecksums", "getSHA256Checkume", "getSHA256Chechecksums", "getSHA256Checkchecksam", "getSHA256Checsums", "getSHA256Checkum", "getSHA256Chechecksum", "getSHA256Checkchecksume", "getSHA256Chechecksam", "getSHA256Checksume", "getSHA256Checsume", "getSHA256Checkcksume", "getSHA256Checkam", "getSHA256Checsam", "getSHA256Checkcksam", "getSHA256Checkcksum", "getSHA256Checsum", "getSHA256Checkcksums", "getSHA256Chechecksume"], "source": ["src", "secret", "text", "in", "sample", "SOURCE", "path", "url", "base", "raw", "value", "reason", "name", "message", "buffer", "image", "context", "this", "s", "sequence", "seed", "content", "out", "ource", "from", "output", "string", "template", "style", "input", "body", "target", "Source", "data", "file", "subject", "format", "filename", "status"], "checksum": [" checksume", "checkim", "checksumb", " checksim", "checkums", " checksumb", "csim", "cksumb", " checksums", "cssum", "checkume", "cksums", "checkssum", "cksim", "checkum", "csum", "checksume", "ckssum", "checkumb", "csume", "checksim", "cksume", "checksums", "cksum", " checkssum"], "md": ["mod", "m", "ms", "ad", "mp", "det", "pd", "df", "ld", " MD", "mk", "dh", "mc", "pm", "MD", "di", "ind", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "def", "Cmd", "pdf", "der", "nt", "hd", " Md", "red", "mand", "grad", "mo", "down", "wd", "dd", "d"], "byteData": ["ByteDATA", " byteDat", "sliceDat", "wordBytes", "bleParts", "bleRel", "bytedata", "channelParts", "routeDat", "phraseParts", " byteDATA", "channelData", "phraseData", "routeData", "phraseBytes", "routeCount", " byteArray", "reverseDATA", "ByteData", "bytesArray", "sliceList", "wordData", "bytesBytes", "phraseDATA", "byteList", "wordArray", " byteList", "byteParts", "byteBytes", "byteArray", "ByteBytes", "bytesDATA", " byteBytes", "ioDat", " bytedata", "wordDATA", "reverseDat", " byteCount", "ioData", "sliceData", "bledata", "ioDATA", "bleData", "byteRel", "byteDat", "bytesData", " byteParts", "routeDATA", "reverseCount", " byteRel", "ByteParts", "byteCount", "channeldata", "ioList", "reverseData", "byteDATA", "channelRel", "sliceDATA"], "sb": ["bt", "bh", "bg", "wb", "bs", "b", "obb", "erb", "bf", "SF", "kb", "bps", "bb", "sh", "sq", "sp", "ib", "pb", "sam", "sf", "sw", "mb", "sm", "gb", "sv", "lp", "ub", "eb", "sg", "ssl", "zb", "rb", "SB", "si", "sbm", "bash", "sa", "nb", "db", "ob", "cb", "xb", "lb", "bis", "bsp", "bj", "shell"], "i": ["info", "m", "err", "I", "oi", "y", "io", "me", "init", "ie", "json", "series", "ms", "u", "j", "gi", "o", "pi", "it", "di", "ind", "client", "er", "to", "print", "ai", "\u0438", "q", "bi", "li", "loop", "major", "im", "phi", "ii", "qi", "my", "ion", "ti", "life", "ini", "history", "ski", "hi", "list", "this", "multi", "iy", "uri", "iu", "ip", "cli", "ij", "ki", "xi", "remote", "ei", "ji", "iq", "ci", "ime", "gu", "mi", "ui", "id", "ic", "l", "g", "set", "si", "ri", "point", "sim", "ix", "ims", "chain", "ity", "any"], "hexString": ["hexResource", "shortString", "exstring", "fullstring", "hexstring", "htmlArray", "hashArray", "htmlString", "htmlBuffer", "shortstring", "fullStore", "hexArray", "hashString", " hexstring", "hashBuffer", " HexResource", "exString", "htmlstring", "shortBuffer", "fullString", "exBuffer", " hexResource", "shortResource", " HexBuffer", " Hexstring", " hexStore", " hexArray", "shortArray", " HexString", "exStore", "hashstring", "hexStore", "hexBuffer", "fullBuffer", " hexBuffer", "exArray"], "hex": ["full", "rex", "zh", "solid", "hl", "dump", "cont", "alph", "h", "prop", "mix", "raw", "none", "flash", "sh", "php", "sex", "pex", "temp", "x", "term", " sex", "ex", "cat", "tex", "exp", "oct", "def", "alias", " Hex", " ex", "com", "ph", "ext", "json", "comp", "lit", "html", "des", "form", "rendered", "tx", "hello", "he", "rh"]}}
{"id1": "873012", "id2": "8069594", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["pl", "domain", "sql", "bel", "ur", "http", "link", "b", "ld", "un", "path", "ref", "ls", "get", "base", "gl", "util", "default", "address", "name", "resource", "uri", "l", "log", "sl", "r", "nl", "rl", "cl", "q", "term", "str", "mount", "impl", "location", "string", "ssl", "page", "pattern", "char", "Url", "web", "config", "el", "html", "xml", "external", "file", "loc", "job", "dl", "ll", "key", "URL", "browser"], "in": ["gin", "m", "null", "include", "read", "nin", "update", " din", "c", "oin", "mc", "o", "mi", "In", "cin", "line", "on", "check", "inn", "name", "min", "ins", "login", "l", "rin", "f", "s", "reader", "ai", "out", "al", "source", "n", "ln", "IN", "from", "init", "en", "isin", "bin", "inner", "con", "input", "again", "din", "body", "ma", "i", "online", "is", "serv", "vin"]}}
{"id1": "9275622", "id2": "19784131", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyStream", " cpStream", " duplicatefile", " cpfile", " copyfile", " duplicateFiles", "copyfile", " cpFiles", " copyFiles", " duplicateStream", " duplicateFile", "copyFiles", "copyStream", " cpFile"], "_file1": ["_files1", "_filesOne", "_ileFirst", "_File2", "_ile1", "_files2", "_FileOne", "_fileInit", "_ile2", "_link2", "_linkInit", "_ileOne", "_FileInit", "_ileInit", "_File1", "_link1", "_FileFirst", "_filesFirst", "_fileOne", "_linkOne", "_fileFirst"], "_file2": ["_FILE02", "_fileb", " _FILE2", " _File2", " _File1", "_FILEb", "_FILE1", "_File2", "_image2", "_filetwo", "_linkTwo", "_File02", "_FILE2", " _fileTwo", " _FileTwo", "_linktwo", " _Filetwo", "_link2", "_imageb", " _FILE1", "_file02", "_Filetwo", "_FileTwo", "_Fileb", "_File1", "_image02", "_link1", " _filetwo", " _FILE02", " _file02", " _fileb", "_image1", " _FILEb", "_fileTwo"], "fis": ["Fos", "kais", "cfis", "flis", "cis", "cais", "cfris", "Fris", " fios", "fliss", "fiss", " fris", "cfiss", "fais", "cfois", "flios", "kis", "ufi", " fiss", "fios", "ufios", "qiss", "fli", "Fios", "ufiss", "Fiss", "kios", "qos", "fois", "Fois", "qios", "ufis", "Fis", "fi", "kos", " fi", "qis", " fais", "fris", "cos", " fois", "cios"], "fos": ["mows", "foes", "sfose", " foes", " fows", "flis", "fows", "sfos", "flos", "maos", "wos", "floes", "wows", "ffoes", "hoes", "waos", "mos", "woss", "floss", "fose", "hose", "sfoes", "faos", " foss", "ffos", "hoss", "ffis", "wis", "hos", "foss", " fose", "woes", "sfoss", " faos", "ffoss", "moes"], "canalFuente": ["canalfuent", "canalKuje", "canallFuenza", "canallfuje", "canallfueree", "canallFuent", "canalKuperor", "canalKuente", "canallFuperor", "canalFient", "canallFuestro", "canallFueree", "canalTenent", "canalfuenza", "canalFuje", "canalFalperor", "canalTenperor", "canalFaleree", "canalfueree", "canallFuente", "canalfuestro", "canalKuent", "canalFuestro", "canalfuente", "canalFalente", "canallfuperor", "canalUtestro", "canalFueree", "canallfuente", "canalFiente", "canalFienza", "canalTenenza", "canalFuent", "canalUtent", "canallfuestro", "canalfuperor", "canalFiperor", "canalFalestro", "canalUteree", "canalTenente", "canallfuenza", "canalFuenza", "canalUtente", "canallFuje", "canalFuperor", "canalFalent", "canallfuent", "canalFalje", "canalfuje"]}}
{"id1": "21489105", "id2": "7761195", "code1": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"md5": ["md6", "mn5", "mg2", "MD3", "mn6", "md3", " md45", "dig2", "MD5", "md45", "MD64", " Md45", "mnle", " Md5", " mdle", " Md6", "mg3", "MD6", "md2", "sha2", "md64", "mg64", "md8", "sha5", "dig3", "mg5", "dig5", " md3", "MD2", "MDle", "sha6", " md8", "mn45", " md64", " Mdle", "digle", "dig8", "MD8", " md2", "mdle", "sha3", " md6"], "message": ["memory", "m", "go", "email", "phrase", "empty", "document", "object", "default", "Message", "raw", "value", "reason", "plain", "address", "name", "buffer", "sequence", "to", "password", "report", "content", "mess", "number", "request", "example", "application", "code", "output", "language", "string", "template", "token", "word", "body", "mail", "essage", "frame", "description", "msg", "data", "subject", "response", "hello", "format", "translation", "channel", "text", "command"], "base64": ["base48", "based62", "Base62", "base24", " base24", "Base16", "bat64", "bat16", "Base24", "Base48", "bat62", "bat66", "base62", "based24", "based48", "Base66", "Base64", "base16", "based16", "based66", "based64", " base48", "base66"], "digest": ["digse", "longest", "longester", " digum", "longse", " digester", "decast", "displayEST", "dester", "dependester", "mdEST", "digested", "dependEST", " digesting", "mdest", "mdesting", "displayested", "digester", "decest", "longested", "digesting", "digum", " digast", "guesting", "mdested", "DigEST", "Digum", "guest", "dested", "dependast", "dependgest", "dest", " digested", "dependest", "diggest", "decester", "displayest", "dependested", "mdse", "guse", " digse", "guested", " digEST", "decested", "mdester", " diggest", "Digest", "Digester", "digast", "digEST", "displaygest", "mdum", "dse"], "digestData": ["digesterDATA", "displayestData", "digestedArray", "digaceArray", "digistData", "digestedDATA", "digESTBytes", " digestBytes", "digestedBytes", " digestArray", "diguteDATA", " digESTDATA", "digesterData", "displayesteddata", " digesterArray", "digESTData", "digesterArray", "digestBytes", "displayestedDATA", " digesterData", "digutedata", " digESTBytes", "digestDATA", " digestdata", "digistdata", "digistDATA", "diggestdata", " digESTData", "digesteddata", "diguteData", "digaceData", "diggestData", "digistBytes", " digestDATA", "displayestdata", "digESTDATA", "digestdata", "digaceDATA", " digesterDATA", "digestedData", "digESTdata", "diggestDATA", "digestArray", " digESTdata", "displayestDATA", "displayestedData"], "enc": ["nc", "rot", "erc", "oc", "ack", "mac", "ec", "c", "rc", "alph", "coll", "xc", "acc", "ct", "oder", "ic", "cod", "inc", "conn", "cur", "rec", "buf", "code", "ex", "fc", "pack", "ens", "act", "pc", "en", "Enc", "arc", "oct", "sec", "exc", "nt", "conv", "eng", "comp", "ENC", "sys", "env", "ent", "col", "ac", "et", "arr"]}}
{"id1": "20275821", "id2": "9033639", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"getAttribute": ["getAttributes", "getAtt", "fileAtt", "Getattribute", "readDirectory", "readAtt", "GetAttribute", "readAttributes", "GetAtt", " getDirectory", "getattribute", " getattribute", "fileAttribute", "fileAttributes", "readAttribute", "getDirectory", " getAtt", " getAttributes", "readattribute", "fileattribute", "GetDirectory"], "url": ["pl", "sql", "ur", "u", "null", "http", "link", "b", "https", "document", "il", "path", "ref", "ls", "host", "base", "gl", "address", "name", "connection", "resource", "l", "uri", "log", "sl", "r", "call", "nl", "rl", "conn", "cl", "q", "str", "user", "ssl", "string", "page", "char", "server", "conv", "Url", "web", "abs", "ul", "el", "file", "ll", "loc", "dl", "job", "URL"], "con": ["nc", "cn", "dial", "go", "re", "pos", "po", "close", "c", "un", "cont", "cal", "pen", "mc", "bean", "free", "ver", "cone", "soc", "on", "trans", "cc", "ct", "Con", "cp", "client", "connection", "ain", "can", "fl", "conn", "cur", "proc", "Conn", "clean", "ln", "cf", "fc", "pc", "en", "comm", "conf", "don", "bon", "conv", "com", "CON", "num", "cm", "connect", "canon", "col", "co", "ran", "open", "cons", "bc", "fin", "ctrl", "const"], "response": ["os", "usage", "pos", "http", "resp", "total", "zero", "amount", "onse", "esp", "compliance", "se", "success", "version", "e", "none", "esi", "es", "roads", "when", "error", "client", "connection", "yes", "sequence", "message", "reset", "number", "country", "request", "code", "application", "res", "respons", "relative", "state", "def", "position", "server", "network", "Response", "body", "index", "next", "json", "trace", "des", "description", "entry", "status", "result", "net"], "redirect": [" Redind", "predirection", "predirect", "rewind", "Reditional", " redind", "Redir", "Redirection", "redir", " redrict", "redrict", "redirection", "preditional", "rewirect", "rewirection", "rewrict", " redir", "Redirect", " redirection", " reditional", " Redirect", " Redrict", "reditional", "redind", " Redirection", "predir"], "location": ["details", "usage", "slot", "phrase", "link", "sample", "where", "document", "path", "reference", "holder", "region", "history", "ocation", "address", "Location", "system", "directory", "resource", "direction", "uri", "layout", "pointer", "operation", "LOC", "local", "relative", "origin", "language", "template", "position", "area", "zone", "relation", "comment", "behavior", "loc", "translation", "remote", "filename", "command", "hold"]}}
{"id1": "8135072", "id2": "6421904", "code1": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setImg": ["getImG", "setImgs", "setImagegs", "setIMg", "setImagegn", "setimgn", "setIMG", "setIMgn", "getImgn", "setImageG", "getImgs", "getIMgn", "getIMgs", "setImG", "setimg", "getIMg", "setImgn", "setimgs", "getImg", "setImageg", "setIMgs", "getIMG", "setimG"], "jFileChooser1": ["jFileChoerOne", "jFileCompickerControl", "jFileChooserOnce", "jFileSeose1", "jFileComposerFirst", "jFileChoser1", "jFileChooser0", "jFileSeose0", "jFileSeose2", "jFileChopter1", "jFileChoickerOnce", "jFileChoicerOnce", "jFileChooseOnce", "jFileChoose2", "jFileChoer4", "jFileChoser2", "jFileChopterControl", "jFileChooseOne", "jFileChoester1", "jFileChoicer2", "jFileChoikerFirst", "jFileChoister1", "jFileChoester0", "jFileChoicker2", "jFileSeoser2", "jFileChoicer1", "jFileComper2", "jFileChoester2", "jFileChooserControl", "jFileChooserFirst", "jFileComposerOne", "jFileChicker1", "jFileComposerControl", "jFileComperOne", "jFileChopterOne", "jFileChicker2", "jFileComper1", "jFileChoister2", "jFileChooser4", "jFileCompickerOne", "jFileChoikerOne", "jFileChoister0", "jFileComposer1", "jFileComposer2", "jFileChoicker1", "jFileChoikerControl", "jFileCompicker1", "jFileChickerOnce", "jFileCompickerFirst", "jFileChoicer4", "jFileSeoser1", "jFileChickerOne", "jFileSeoser0", "jFileComposer4", "jFileChoserOne", "jFileChoicerOne", "jFileChoose1", "jFileComper4", "jFileChooserOne", "jFileChoickerOne", "jFileChoserOnce", "jFileChoose0", "jFileChoiker1", "jFileChoose4", "jFileChoickerControl", "jFileChoer2", "jFileChoickerFirst", "jFileChopterFirst", "jFileChoer1", "jFileChooser2"], "separator": [" separate", "separater", "semate", "separacer", " separater", "terminator", "splacer", "termininator", "separigator", "generATOR", "semitter", "collate", " separacer", "separate", " separativity", "seitter", "varioder", "generate", "splator", " separitter", "separinator", "terminativity", " separinator", "seATOR", "splater", "semator", "semATOR", "variate", "variator", " separATOR", "seator", "terminATOR", "collATOR", "collativity", "seinator", "separATOR", "terminoder", "separoder", "separitter", "terminate", "terminigator", "splATOR", "seigator", "generoder", "generacer", "separativity", "generator", " separigator", "collator", "terminater", "variater", "generater", "seate"], "dirImg": ["dirIMm", "DirIMic", "dirIvg", "dirIg", "folderIMg", "dirIfg", "dirimm", "dirIfig", "dirIfgs", "dirImic", "DirImm", "dirIMg", "folderImge", "dirImig", "dirimgs", "dirimg", "folderImvg", "dirIMic", "DirImgs", "dirIfG", "folderImgs", "folderIMG", "dirimge", "dirIMvg", "dirImvg", "dirImm", "dirIMig", "folderIMge", "DirIMm", "dirIfic", "dirIMge", "dirImG", "dirimig", "DirIMig", "DirIMG", "folderIMgs", "dirIMG", "DirImic", "dirIgs", "DirIMgs", "DirImg", "DirImG", "DirIMg", "dirIG", "dirimG", "folderImg", "folderIMvg", "dirIfm", "DirImig", "dirIMgs", "dirImgs", "dirImge", "folderImG"], "index": ["info", "pos", "exit", "length", "diff", "zero", "ion", "open", "success", "add", "condition", "value", "count", "ind", "level", "address", "axis", "seed", "number", "height", "sol", "n", "test", "Index", "sign", "ex", "find", "exp", "set", "start", "timeout", "all", "position", "second", "num", "point", "IND", "i", "draw", "connect", "match", "max", "key"], "imgName": [" imgPath", "htmlNo", "htmlPath", "animPath", "jpgName", "animname", "jpgname", " imgname", " imgType", "imgId", "jpgNo", "imgNo", "htmlType", " imgNo", "imgname", "animName", "jpgPath", "animId", "imgType", "imgPath", "jpgId", "jpgType", " imgId", "htmlName"], "newPath": ["validUrl", " newFormat", "newsPart", "NEWTime", "newsTh", " newTime", "validName", " newUrl", " newpath", "oldTime", "uniquePath", "newName", "newpath", "newTh", "NewPath", "oldTh", "newTime", "uniquePart", "newsPath", "NewName", "uniqueTh", "newDir", "uniquePassword", "oldPath", "validpath", "oldFormat", "newFormat", "NEWFormat", "NewUrl", "newPassword", "newUrl", "newsPassword", "Newpath", "oldPassword", " newName", " newDir", "validPath", "oldPart", "NEWDir", "newPart", "oldDir", "NEWPath"], "inputFile": ["importPlace", " inputBe", "acceptBe", "saveFile", "acceptfile", "importFile", "inFILE", "saveFILE", "createPlace", "inputPath", "createfile", " inputPath", "acceptFile", "inputFILE", " inputfile", "acceptPlace", "inputBe", "createBe", "inPlace", "inFile", "importPath", "inPath", " inputStream", " inputPlace", "createFile", "outputFILE", "outputStream", "inputfile", "inputPlace", "inStream", "saveStream", "inputStream", "importStream"], "outputFile": ["outputBe", "outputPage", "outputDisk", "newBe", " outputfile", "inputFormat", "outFile", "putModel", "putDisk", "displayStream", "outModel", "outFormat", " outputStream", "displayBe", "displayFile", "putFile", "newStream", "inputModel", "outfile", "outputDir", "newFile", "outputModel", "putPage", "outputfile", "OutputFile", "OutputFormat", "inputPage", "outDisk", "outPage", "displayfile", "outputStream", "OutputDir", "Outputfile", "inputfile", "inputDir", "outputFormat", "newfile", "inputDisk", "outDir", " outputBe"], "in": ["per", "read", " din", "up", "it", "cin", "ini", "inn", "ind", "ain", "ins", "ic", "rin", "by", "io", "inc", "al", "source", "from", "IN", "iter", "ex", "init", "en", "inner", "isin", "bin", "con", "input", "sin", "din", "inside", "i", "el", "is", "ar", "In"], "out": ["os", "cn", "t", "end", "o", "aos", "it", "gr", "on", "list", "v", "help", "writer", "can", "to", "outs", "log", "io", "write", "put", "cache", "dis", "n", "cmd", "output", "ex", "Out", "en", "inner", "con", "screen", "nt", "outer", "sum", "ou", "at", "sys", "OU", "auto", "OUT", "co", "ne", "cos", "net"], "c": ["nc", "m", "go", "u", "sc", "t", "z", "gc", "ec", "rc", "cont", "ch", "C", "mc", "a", "lc", "e", "count", "ct", "cc", "cp", "ce", "cs", "v", "cd", "dc", "l", "k", "f", "r", "uc", "cl", "q", "n", "code", "unc", "ex", "cat", "cr", "arc", "cu", "char", "com", "i", "cm", "cut", "max", "cod", "chain", "bc", "col", "ac", "d"], "bckImg": ["bckImgs", "bckIfge", "bckIMgs", "bkgImg", "bkgIMn", "bkgIMge", "bckImn", "bckimgs", "bckIfg", "bckIfgs", "bckIfn", "bckIMge", "bckimg", "bkgImgs", "bckimn", "bckImge", "bckIMg", "bkgIMgs", "bkgImge", "bckimge", "bckIMn", "bkgIMg", "bkgImn"]}}
{"id1": "20995534", "id2": "13122204", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromclassloader", "loadPropertiesFromClassPath", "loadPropertiesfromclassloader", "loadPropertiesFromFileloader", "loadPropertiesfromclassPath", "loadPropertiesFromClassname", "loadPropertiesFromclassname", "loadPropertiesfromClassname", "loadPropertiesFromFilePath", "loadPropertiesfromclassname", "loadPropertiesFromFilepath", "loadPropertiesfromClassPath", "loadPropertiesfromClasspath", "loadPropertiesFromFilename", "loadPropertiesFromClassloader", "loadPropertiesfromclasspath", "loadPropertiesFromclasspath", "loadPropertiesFromclassPath", "loadPropertiesfromClassloader"], "path": ["full", "hex", "item", "module", "w", "zip", "ath", "empty", "base", "prefix", "PATH", "name", "p", "filename", "resource", "context", "directory", "log", "transform", "str", "mount", "test", "txt", "location", "string", "pattern", "template", "root", "Path", "config", "program", "xml", "file", "data", "policy", "type", "entry", "format", "key", "text", "chain", "prop", "dir", "pt"], "locations": [" locATIONS", "Locations", "lococations", "locifications", "localATION", "equators", "locATIONS", "LOCifications", "localifications", "Locators", "LOCATIONS", "LocATION", "locators", " locifications", "Lococations", " locATION", "equATIONS", "equifications", " lococations", "localations", " locates", "plATIONS", " locators", "plations", "localates", "Locifications", "plates", "Locates", "LOCations", "locates", "locATION", "LOCocations", "LOCators", "LOCates", "equations", "plocations"], "props": [" properties", "roperties", "propperties", "proports", "probs", "propgs", "preports", "Prors", "Properties", "rops", "prodates", "rogs", "peps", "Probs", " prors", "preps", "prors", "privperties", "preperties", "Props", "peperties", "Proports", "robs", "privps", "properties", "pebs", "pegs", "Progs", "Prodates", "privdates", "progs", "propports", "propps", "privrs", "pregs", " prodates"], "url": ["row", "bel", "ur", "http", "link", "ref", "ls", "gl", "address", "name", "resource", "l", "log", "f", "sl", "r", "nl", "uri", "element", "rl", "mb", "term", "str", "org", "rel", "mount", "user", "location", "string", "page", "pattern", "server", "char", "Url", "web", "mail", "config", "ob", "el", "html", "xml", "file", "loc", "ll", "dl", "key", "URL", "browser"], "in": ["gin", "info", "cn", "sql", "vin", "read", "sample", "mc", "mi", "stream", "cin", "on", "inn", "ind", "media", "mn", "ins", "io", "reader", "inc", "out", "source", "ln", "from", "IN", "init", "en", "isin", "bin", "inner", "con", "input", "din", "body", "sum", "ma", "i", "mat", "cm", "as", "data", "file", "is", "and", "mr", "In"]}}
{"id1": "20724937", "id2": "17557289", "code1": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 0, "substitutes": {"getTopicMap": ["getMessageTree", "getThreadList", " getTopicsTree", "getThreadTree", "getEventMap", "getEventTree", "getThreadInfo", "getTopicTree", " getTopicsInfo", "getTopicsInfo", " getThreadMap", "getTopicList", " getTopicTree", " getThreadList", " getTopicsList", " getTopicList", "getTopicsList", " getThreadTree", "getMessageList", "getEventList", "getThreadMap", "getTopicsTree", "getTopicInfo", "getMessageMap", " getThreadInfo", "getMessageInfo", " getTopicsMap", "getEventInfo", " getTopicInfo", "getTopicsMap"], "url": ["pl", "domain", "item", "lr", "ur", "null", "u", "http", "parse", "link", "b", "document", "ref", "ls", "host", "base", "gl", "build", "address", "name", "id", "resource", "uri", "l", "log", "nl", "cl", "request", "str", "mount", "location", "ssl", "page", "string", "pattern", "server", "char", "Url", "mail", "web", "html", "xml", "file", "loc", "ll", "job", "dl", "URL", "browser"], "baseURI": ["baseU", "BaseUR", "BaseURI", "basedU", " baseURL", "baseUR", " baseU", " baseUR", "basedURL", "BaseURL", "basedUR", "BaseU", "basedURI", "baseURL"], "inputStream": ["openPort", " inputView", "unsignedStreamer", " inputstream", "inputPort", "unsignedstream", "openFile", " inputFile", "InputView", "inputSteam", "openStream", "unsignedSteam", " inputPort", "inputStreamer", "inputView", "InputFile", " inputSteam", "inputFile", "InputPort", "openStack", "inputstream", "InputSteam", "openSteam", "inputStack", "openView", "InputStream", "InputStreamer", "Inputstream", "unsignedStream", " inputStack", " inputStreamer", "InputStack"]}}
{"id1": "20019847", "id2": "13891080", "code1": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " CopyFiles", " cpStream", " cpfile", " CopyStream", "copyfile", " cpFiles", "Copyfile", "CopyFiles", "copyFiles", " Copyfile", "copyStream", "CopyStream", " cpFile", "CopyFile"], "source": ["ace", "src", "sql", "details", "sample", "SOURCE", "archive", "base", "se", "it", "scope", "space", "check", "parent", "store", "ce", "name", "sequence", "resource", "spec", "seed", "service", "ource", "site", "from", "start", "init", "origin", "copy", "search", "string", "style", "template", "input", "query", "config", "Source", "scene", "file", "subject", "view", "size", "format", "filename", "series"], "target": ["join", "project", "that", "t", "stop", "goal", "link", "mac", "tif", "gt", "table", "get", "top", "base", "it", "parent", "delete", "check", "arg", "resource", "to", "Target", "print", "test", "bolt", "output", "replace", "touch", "copy", "dest", "pattern", "template", "alias", "next", "arget", "file", "match", "result"], "in": ["gin", "info", "re", "im", " din", "up", "cin", "it", "inf", "inn", "ind", "internal", "id", "client", "ain", "ins", "ic", "rin", "inc", "ai", "al", "from", "iter", "IN", "init", "en", "bin", "isin", "inner", "con", "input", "sin", "din", "inside", "i", "is", "ar", "In"], "out": ["cn", "t", "b", "gt", "c", "ot", "ch", "o", "up", "aos", "it", "on", "or", "client", "v", "can", "to", "l", "outs", "io", "by", "conn", "n", "g", "cmd", "user", "output", "ex", "Out", "en", "con", "nt", "ou", "i", "at", "sys", "auto", "msg", "OUT", "co", "channel", "ne", "and", "result", "net"]}}
{"id1": "19652200", "id2": "4921631", "code1": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"init": ["info", "update", "read", "run", "empty", " constructor", "get", "release", "store", "Init", "reset", "construct", " intern", " Init", "create", "start", "save", "launch", "index", " initiate", " initialization", " relocate", "config", "connect", "initial", "load"], "file": ["info", "full", "File", "null", "upload", "ile", "http", "binary", "FILE", "link", "disk", "table", "document", "il", "rule", "path", "base", "line", "be", "name", "message", "buffer", "image", "resource", "this", "port", "uri", "log", "f", "io", "report", "attribute", "source", "user", "local", "output", "create", "page", "tree", "real", "current", "body", "le", "fil", "form", "data", "format", "open", "filename", "handle", "load", "dir"], "url": ["ur", "api", "u", "http", "link", "b", "path", "util", "host", "base", "gl", "get", "address", "name", "resource", "uri", "l", "f", "sl", "r", "nl", "q", "cl", "str", "rel", "mount", "location", "ssl", "string", "char", "Url", "web", "mail", "i", "abs", "ll", "loc", "open", "URL", "browser"], "stream": ["Stream", "link", "engine", "path", "open", "ream", "socket", "message", "buffer", "context", "port", "resource", "source", "console", "page", "input", "session", "pool", "form", "view", "chain", "channel", "download", "handle", "status", "stack"], "byteArray": ["byteString", "ByteString", "charArray", "byteList", "charString", "ByteArray", " byteString", "charList", " byteList", "ByteList"], "content": ["cont", "Content", "path", "raw", "version", "value", "media", "message", "summary", "comments", "source", "action", "code", "title", "page", "template", "section", "body", "json", "hash", "config", "comment", "header", "data", "size", "format", "text", "status"]}}
{"id1": "9257487", "id2": "12306305", "code1": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": ["DownloadResource", "updateResource", "downloadfile", "DownloadFile", " downloadResource", "downloadResource", "downloadFiles", "updateFile", "updatefile", "DownloadFiles", "updateFiles", "Downloadfile", " downloadFiles", " downloadfile"], "from": ["src", "os", "old", "simple", "un", "path", "range", "a", "base", "se", "add", "or", "part", "name", "ol", "From", "reset", "uri", "by", "fl", "of", "with", "rom", "request", "source", "term", "st", "input", "original", "fr", "html", "config", "form", "initial", "vol", "view", "entry"], "to": ["pretty", "tom", "tt", "t", "po", "done", "o", "top", "base", "pi", "delete", "eto", "name", "p", "by", "ato", "temp", "toc", "ta", "tu", "To", "output", "title", "dest", "template", "oto", "too", "tmp", "target", "te", "into", "auto", "file", "tty", "TO", "fully"], "pm": ["pl", "m", "ms", " mm", "po", "sem", "progress", "pp", "mc", "mi", "hm", "dem", "PM", "pi", "fm", "bm", "ps", "arm", "rm", "wm", "p", "mt", "mon", "km", "asm", "em", "dm", "mm", "pc", "pa", "mx", "am", "jp", "rpm", "aph", "meter", "nom", "pr", " ppm", "gm", "rem", "cm", "monitor", "vm", "mp", "mr", "pt"], "out": ["pretty", "os", "t", "w", "ot", "o", "aos", "gr", "on", "oe", "client", "p", "writer", "can", "obj", "outs", "log", "f", "io", "flush", "op", "write", "cache", "n", "res", "output", "ex", "Out", "en", "con", "nt", "body", "ou", "oss", "i", "at", "OU", "auto", "file", "OUT", "co", "ne", "we", "net"], "url": ["ret", "re", "bel", "ur", "http", "hl", "link", "b", "https", "il", "ch", "ls", "host", "base", "ver", "client", "p", "l", "uri", "f", "sl", "fl", "nl", "r", "str", "res", "rel", "user", "ssl", "char", "conv", "li", "Url", "web", "ul", "dl", "loc", "ll", "job", "open", "cert", "URL", "net"], "conn": ["nc", "cn", "gate", "c", "close", "https", "ch", "cc", "cp", "ns", "client", "connection", "l", "nl", "Conn", "enc", "cur", "iw", "yn", "cmd", "ctx", "nec", "comm", "con", "nt", "conv", "com", "cm", "cb", "connect", "addr", "serv", "open", "cert", "col", "net"], "in": ["gin", "nin", " din", "il", "oin", "up", "cin", "it", "on", "inf", "inn", "ind", "ill", "ain", "ins", "ic", "rin", "io", "reader", "inc", "ai", "IN", "iter", "init", "en", "inner", "isin", "bin", "input", "ri", "sin", "din", "i", "inside", "el", "is", "ar", "and", "In"], "buffer": ["bar", "memory", "paste", "row", "detail", "column", "phrase", "binary", "buff", "sample", "table", "length", "variable", "document", "batch", "base", "pad", "se", "raw", "block", "value", "reason", "Buffer", "mem", "cell", "message", "sequence", "library", "number", "cache", "temp", "window", "buf", "iter", "tree", "template", "word", "char", "frame", "initial", "view", "entry", "button", "chain", "command", "stack", "attribute", "append"], "read": ["download", "row", "t", "send", "w", "Read", "length", "run", "old", "end", "ok", "val", "get", "score", "stream", "add", "raw", "mem", "used", "check", "count", "ind", "ready", "READ", "reads", "last", "skip", "req", "print", "log", "reader", "readable", "sync", "write", "q", "scan", "bind", "select", "n", "pe", "iter", "find", "start", "output", "push", " Read", "input", "seek", "head", "num", "index", "next", "query", "ke", "i", "draw", "connect", "size", "reading", "gets", "hello", "len", "open", "text", "handle", "load", "hold"]}}
{"id1": "22410173", "id2": "15465293", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"Usage:  URLDumper <URL> <file>\");\n            System.exit(1);\n        }\n        String location = args[0];\n        String file = args[1];\n        URL url = new URL(location);\n        FileOutputStream fos = new FileOutputStream(file);\n        byte[] bytes = new byte[4096];\n        InputStream is = url.openStream();\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            fos.write(bytes, 0, read);\n        }\n        is.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFile", "transferStream", " cpStream", "transferfile", "transferFiles", " cpfile", "cpFiles", "cpStream", "copyfile", "cpFile", " cpFiles", "copyFiles", "cpfile", "copyStream", " cpFile"], "source": ["src", "sample", "SOURCE", "base", "se", "scope", "space", "parent", "sp", "ce", "resource", "spec", "s", "seed", "service", "me", "ource", "site", "from", "local", "start", "iter", "init", "origin", "copy", "search", "style", "template", "input", "original", "target", "query", "Source", "scene", "file", "subject", "so"], "dest": ["tom", "src", "that", "null", "orig", "dir", "d", "Dest", "cont", "it", "trans", "desc", "home", "way", "sp", "rest", "master", "deg", "temp", "dist", "de", "test", "st", "good", "exp", "origin", "search", "img", "pot", "usr", "them", "tmp", "nom", "target", "lit", "des", "nw", "loc", "pub", "est", "crit", "del"], "in": ["gin", "m", "re", "ci", "vin", " IN", "read", "local", "ch", "mi", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "internal", "client", "ain", "can", "ins", "l", "rin", "r", "doc", "pin", "inc", "conn", "ai", "al", "n", "ln", " input", "from", "IN", "an", "win", "init", "iter", "en", "bin", "inner", "isin", "all", "con", "input", "sin", "din", "ma", "i", "inside", "is", "co", "ar", "ca", "and", "In", "net"], "out": ["os", "cn", "null", "t", "w", "note", "gt", "un", "ion", "ot", "ch", "o", "up", "aos", "na", "it", "on", "ns", "client", "v", "can", "obj", "to", "log", "outs", "io", "nl", "off", "write", "conn", "not", "dis", "n", "cos", "cmd", "user", "output", "ex", "Out", "en", "inner", "con", "again", "nt", "outer", "conv", "sum", "ou", "oss", "rem", "at", "OU", "OUT", "co", "channel", "chain", "ne", "ent", "ac", "net"]}}
{"id1": "12172485", "id2": "16825994", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsfile", "decodeFileToString", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFileFileFile", "decodeStringToString", "decodeStringToFiles", "decodeString2file", "decodeFileTofile", "decodeFile2String", "decodeStringToFile", "decodeString2String", "decodeString2File", "decodeFileFileFiles", "decodeFileAsFiles", "decodeFile2File", "decodeFile2Files", "decodeString2Files", "decodeFileFileString", "decodeFileToFiles", "decodeFile2file", "decodeFileAsString"], "infile": ["isinfolder", "isinfile", "inputname", "Inbase", "outFile", "outfolder", "InFile", "outfilename", "inname", "isinname", "fromFile", "outname", "Infile", "infolder", "frombase", "inFile", "inputFile", "inbase", "fromfilename", "infilename", "inputfile", "isinFile", "fromfile", "Infilename", "inputfolder", "outbase"], "outfile": [" outname", "inFILE", "Outfilename", "Outfile", "outFile", "otname", "outfilename", "otfile", "inname", " outFile", "outname", "todir", "outdir", "otFILE", "tofilename", "inFile", "outFILE", "indir", "tofile", "Outdir", "infilename", "toFile", "OutFile", " outFILE", "otFile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "variable", "total", "document", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "attribute", "cache", "number", "temp", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "shape", "append"], "read": ["before", "each", "text", "send", "shift", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", " succeed", "ok", "submit", "ratulations", " succ", "condition", "scope", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "summary", "primary", "commit", "positive", "surv", "crit", "same", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", "unity", "please", " successes", "first", "support", "city", "exist", " successful", "ceed", "fail", "response", "successfully", "status", "result", " okay", "accept"]}}
{"id1": "1769771", "id2": "14877116", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " CopyFiles", " copyStream", " copyLine", " CopyStream", "CopyLine", " copyFiles", "CopyFiles", "copyLine", " CopyLine", "copyFiles", "copyStream", "CopyStream", "CopyFile"], "in": ["gin", "b", "old", "up", "cin", "on", "ini", "inf", "inn", "ind", "ins", "l", "rin", "ic", "io", "r", "inc", "source", " input", "IN", "from", "mm", "init", "en", "isin", "bin", "inner", "input", "din", "i", "el", "is", "In"], "out": ["os", "t", "err", "w", "update", "po", "b", "gt", "c", "ot", "o", "up", "it", "v", "help", "p", "s", "to", "outs", "log", "l", "io", "op", "n", "res", "output", "ex", "Out", "nt", "ou", "at", "file", "OUT", "msg", "serv", "net"], "inChannel": ["inchannel", "inButton", "inCommand", "inConnection", "intChan", "InCommand", "cinChannel", " inCase", "dinConnection", " inCategory", "insideScope", "sinCase", "ainChannel", " inchannel", "sinChannel", "cinCommand", "sinRoom", "innCase", "intChannel", "inCategory", " inChan", "intchannel", "sinButton", " inConnection", "innButton", "outConnection", "insideClient", "intCommand", "sinClient", "inScope", " inButton", "sinCommand", "ainCategory", " inCommand", "dinchannel", "inCase", "dinChan", "outchannel", "inClient", " inRoom", "inRoom", "insideCategory", "innClient", "ainClient", "cinRoom", "InChan", "outChan", "dinChannel", " inScope", "innChannel", "Inchannel", "ainScope", "inChan", "insideChannel", " inClient", "InChannel"], "outChannel": ["outCh", "inchannel", "outputManager", "outGate", "parentGate", "outMany", "outSection", "aosMember", "cnManager", "aosChannel", "neChannel", "blockChannel", "inMember", "cnChannel", "neChan", "outputCh", " outCh", "neMember", "inSection", "outputChan", "aosChan", " outManager", "outManager", "aosSection", "inCh", "parentChan", "neSection", "parentChannel", " outMany", "outchannel", "parentMany", "cnChan", "blockGate", "outputChannel", "blockMany", "outputchannel", "blockChan", " outChan", " outchannel", "outChan", "inChan", " outGate", "outMember"]}}
{"id1": "23672408", "id2": "3767903", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyiconfiles", "copyIndexDocuments", "copyIndexFiles", " copyiconImages", "copyiconFiles", "copyiconImages", "copyIconDocuments", "copyIndexfiles", "copyIconImages", "copyIconfiles", "copyiconDocuments", " copyIconDocuments", " copyiconDocuments", " copyIconImages", " copyIconfiles", " copyiconFiles", " copyiconfiles", "copyIndexImages"], "clazz": ["Clazz", "Close", "classe", "CLazz", " plub", "claz", "clus", "pkgashed", "classotted", "crazz", " clbean", "chojure", "classuddy", "scloser", "escazz", " closer", "callaz", "colluster", " clotted", "chace", " clojure", "collazz", " claz", "closer", "plasse", "pkgazz", "descaz", "Clab", "cluddy", "plazz", "plashed", "Clbo", "CLace", "Claz", "classazz", "clab", "callazz", "chotted", "relose", "clotted", "chazz", "clbean", "relab", "escotted", "collotted", "CLbean", "sclazz", "CLoser", "sclbean", "Clace", "relazz", "club", " club", "pkgaz", "relaz", " plaz", "plaz", "craz", "classuster", " clace", "callbo", "sclace", " clus", "descab", " classe", "close", " plus", " cluster", "descazz", "crub", "cluster", "escace", "escojure", "clace", " clashed", " clbo", "crus", " cluddy", "clbo", "pkgasse", " plazz", "callace", "colluddy", "clashed", "descose", "clojure"], "i16": ["pi16", "iri16", "liShort", "ini19", "pi6", "amiShort", "ri157", "i160", "i24", "ri6", "ii160", "ii216", "ami150", "ini24", "ii16", "iri6", "ini216", "iniShort", "i216", "ini2016", "ami6", "ri16", "li16", "ini160", " i216", "ji150", "iri157", " i24", "i6", "pi150", "i2016", " i157", "ii24", "ami16", "pi63", "ami2016", "i150", "li19", "ami63", "i157", "iri2016", "ji16", " i2016", "i19", " i160", "ji6", "i63", "li2016", "ji63", "iShort", "ri2016", " i6", "ini16", "ami19"], "fileType": ["eventList", "iletype", "relationFamily", "webTYPE", "formatValue", "FILEtype", "FILEType", "resourceUnit", " fileUnit", "fieldTYPE", "formType", "relationType", "webDef", "policyType", "policyFamily", "FileName", "relationHandler", "eventTYPE", "viewTYPE", "policyHandler", " filetype", "viewtype", "fileTime", "fieldType", "coreDef", "policyTyp", "coreHandler", "FileType", "fileName", "ilePattern", "coreTyp", " filePattern", " fileList", "formtype", " fileTime", "coreFamily", "relationTyp", "filetype", "coreType", "formName", "issuetype", "issueType", "filePattern", "coreTYPE", "resourceTYPE", "fileFamily", "formatTYPE", "issuePattern", "fileHandler", "treeType", "fileFormat", "fieldTyp", "fileDef", "ileTyp", "FILEName", "webType", "ileType", "formatType", "fileTYPE", "webTyp", "viewType", "eventUnit", "fileTyp", "fieldDef", " fileValue", "Filetype", "formatTime", "treetype", "formattype", "resourceFormat", "fileList", " fileFormat", "eventType", "eventFormat", "webList", "resourceType", "viewValue", "fileValue", " fileTyp", " fileTYPE", "issueTyp", "treeTYPE", "fileUnit", "treeTime"], "desti16": ["destgi16", "destui24", "destsi16", "resulti16", "resultii24", "resulti216", " destsi18", "destxi16", "desti2016", " desti18", "destii16", "desti160", "destsi160", "destxi32", "resulti24", "destui160", "destui16", "resulti2016", "destui32", " desti160", "destxi18", "desti216", "resultii2016", "resultii16", "destsi18", "destgi2016", "destui2016", "destii216", " destsi160", "resultii216", " destsi32", " destsi16", "destsi32", "destui18", "destgi24", "destui216", "destgi216", "desti18", "destii2016", "desti24", "destxi160", "destii24"], "src": ["sit", "bh", "isl", "sc", "cmp", "rob", "hl", "bg", "sel", "ctx", "rc", "cont", "syn", "pkg", "ls", "urg", "desc", "ser", "sq", "sp", "rest", "ins", "bin", "req", "sl", "nl", "iter", "sync", "rl", "cur", "std", "sub", "source", "sol", "gs", "rg", "proc", "scan", "rel", "ln", "st", "ibl", "txt", "rs", "ctr", "sb", "rx", "fc", "etc", "ssl", "inner", "rb", "iv", "sn", "sec", "input", "dest", "usr", "cli", "img", "sr", "tmp", "comp", "via", "ptr", "sys", "cb", "addr", "inst", "loc", "vr", "bc", "obs"], "dst": ["dLcut", "Dnd", "nput", " dmt", "ndsts", "ndest", "dmn", " ddr", "fdr", "dsot", "dddest", "fdest", "fnd", "dsst", "dLot", "tput", "nnd", "ndmt", "dsnet", "dbl", "rdest", "dLnet", "rcut", "dermn", "dmt", "ddnd", "dput", "dcut", " dbl", "dgt", "ddest", "Ddest", "dsts", "Ddr", "dnd", "dLest", " dsts", "derst", " ddest", " dcut", "dLbl", " dput", "tnd", "rdst", "dsest", " dest", "tst", "dest", "fst", "dnet", "rbl", "ngt", " dnd", "nst", "dLst", "ddr", "dernd", "derdest", " dgt", "rdmt", "dLdest", " dmn", "rdsts", "tgt", "ndst", "dot", "Dst", " dnet", "ddst", "ddmn", "rst", " dot"], "i32": ["xi22", "i31", "ini31", "i28", "i48", "ic40", "xi31", "ip31", "pi64", " i40", "ip34", "pi34", "i22", "pi31", "ic342", "i64", "ip64", "ic48", " i64", " i86", "pi32", "ini48", "ii342", "isi32", "i34", "ini32", "xi32", "ip32", "i86", "ic34", "ic64", "isi40", "i342", "isi64", "ic31", "ic22", "ii34", " i342", "ii28", "isi86", "ic32", "i40", "ic28", " i28", "ini22", " i34", "xi48", "ii32", "ic86", " i31"], "desti32": ["desti31", "Desti31", "destpi30", "destic30", "DestI90", "destu256", "destic32", "destu90", "destdi34", "targetpi34", "desti90", "destpi31", "destu32", "destpi34", "targeti34", "DestI256", "destI256", "desti30", "targeti30", "destI90", "targeti31", "destdi32", "DestI31", "targetpi31", "targetpi32", "desti256", "destdi30", "Desti256", "destu31", "desti34", "destdi31", "targetpi30", "destI32", "Desti90", "targeti32", "destpi32", "destic34", "destI31", "DestI32", "destic31", "Desti32"]}}
{"id1": "5760649", "id2": "22135199", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"createFile": ["uploadFiles", "createFiles", " createStream", "uploadFile", "uploadfile", "savefile", " createfile", "saveFile", "saveFiles", "uploadStream", " createFiles", "createStream", "saveStream", "createfile"], "src": ["sit", "sc", "SOURCE", "rc", "fp", "url", "stream", "SourceFile", "ser", "sq", "resource", "obj", "uri", "cur", "source", "str", "rect", "res", "st", "from", "rs", "txt", "sb", "rx", "start", "pour", "ctr", "dest", "fc", "sec", "input", "sr", "comp", "abs", "config", "sys", "inst", "is", "loc", "ipl"], "filename": ["FILE", "fn", "jpg", "FN", "fp", "path", "username", "prefix", "png", "bf", "SourceFile", "xxx", "nm", "name", "nil", "v", "ename", "nl", "stem", "n", "ln", "txt", "output", "location", "string", "title", "kl", "fil", "ren", "println", "file", "Filename", "subject", "family"], "fis": [" fisi", "afis", "Fos", "sfiss", "fIS", " fIS", "sfis", "bfiss", "Fisi", "afiss", " fios", "fiss", "fais", "bfios", "fisi", " fiss", "fios", "sfais", "ffos", "sfios", "Fios", "bfis", "ffis", "Fiss", "afios", "ffIS", "FIS", "bfos", "Fis", " fais", "ffisi", "afais"], "fos": ["wOS", "wios", "foes", "tos", "Fos", " foes", "vOS", "wor", "fOS", "flis", "woses", "tis", "flos", "voses", "Foes", "wos", "toss", "woss", "floss", "flios", "Foss", " foses", "tios", "boes", "fios", " foss", " fOS", "bos", "vos", "wis", "boss", "foss", "foses", "Fis", "bis", "vor"]}}
{"id1": "20855053", "id2": "1508930", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "label": 1, "substitutes": {"init": [" service", "initialized", "run", "activate", "register", " authorize", " login", " bind", "Init", " deploy", " abort", " construct", " reset", " initialized", " restart", "action", "construct", " initiation", " Init", "start", " prepare", " dispatch", "launch", " initiate", " initialization", "config", "execute", " refresh"], "context": ["null", "sc", "w", "c", "component", "h", "this", " contexts", "x", "application", "res", "txt", "ex", "ctx", "state", "exc", "X", "Context", "web", "config", "chain", "tx", "self", "bc", "event"], "classLoader": ["ClassReader", "classBuilder", "taskBuilder", "ClassPath", "fileManager", "ClassElf", " classManager", "fileReader", "ClassLess", " classBuilder", "ClassParser", " classLess", "ClassBuilder", "classReader", "urlPath", "taskElf", "classPath", "classLess", "classManager", "classElf", "taskLess", " classPath", "fileLoader", "Classloader", "urlReader", " classParser", " classReader", "ClassLoader", "classParser", "urlloader", " classElf", "urlLoader", "ClassManager", "fileParser", " classloader", "taskLoader", "classloader"], "urls": ["urlports", "limlets", " urlms", "norms", "limls", "sls", "slports", "urlies", "urps", "ls", "URLms", "longists", "lls", "urlgs", "urlps", "longs", "limms", "URLlets", "urlls", "urxs", "URLgs", " urlgs", "limgs", " urllets", "longports", "limxs", "longies", "slies", "limps", "urs", "urllets", "normports", "lxs", "lps", "urlms", "normies", "URLs", "lims", "normists", "urlists", "slists", "urlxs"], "url": ["ret", "re", "lr", "ur", "row", "bel", "http", "email", "link", "b", "path", "ref", "util", "ls", "base", "address", "name", "resource", "l", "uri", "f", "sl", "r", "nl", "uu", "req", "rl", "log", "str", "org", "res", "rel", "mount", "user", "location", "ssl", "page", "char", "li", "Url", "web", "mail", "ob", "el", "ul", "file", "ll", "job", "entry", "dl", "loc", "channel", "URL", "browser"], "reader": ["rot", "row", "older", "per", "read", "handler", "rar", "ner", "iper", "driver", "range", "stream", " Reader", "roller", "rer", "peer", "iterator", "buffer", "writer", "er", "resource", "runner", "r", "rl", "ro", "iter", "Reader", "rx", "inner", "input", "rr", "reading", "file", "layer", "parser", "entry", "loader", "dd"], "className": ["ClassLine", " classTitle", "ClassData", " classFull", "ClassString", " classNames", "clNo", "classPath", "titleName", " classPath", "playNo", "stringName", "ClassName", "partNAME", "titleLine", "clPath", "classType", "classStart", "packageData", "playName", "classRel", " classValue", " ClassTitle", "classToken", " classType", " classToken", "classData", "classNot", "packageName", "clRel", " classStart", "classLine", "completeName", " ClassFull", " classString", "cellToken", "completePath", "CLASSNames", "clName", "stringString", "CLASSFull", " classRel", " classData", "completeRel", "stringType", "CLASSName", "titleNot", "Classname", "logValue", "classValue", "classNames", "ClassToken", "cellRel", " classNot", " ClassName", "stringStart", "playBody", "moduleString", "playString", "classBody", " ClassNames", "moduleName", " classLine", "ClassPath", "classTitle", "classname", "classNo", "logname", "logNAME", "cellName", " classNo", "packagename", "cellString", "titleString", " classBody", "partName", "CLASSTitle", "moduleType", "clString", "clBody", "ClassRel", " classNAME", "packagePath", "partname", "logName", "classString", "ClassNot", "classFull", "classNAME", "moduleStart", "partValue", " classname"], "clazz": ["glace", "classazz", "lclass", "gluster", "glclass", "shazz", "classclass", "clclass", " cluster", "claz", " clade", "cluster", "clace", "glade", "lazz", "classass", "lass", "clade", "shace", "glaz", "glass", "shuster", "class", "laz", "classaz", " clace", "glazz", "shade"]}}
{"id1": "16511008", "id2": "4531653", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMessagesymbol", "createNewProfilingMessageSyntax", "createNewProfilingMessageCymbol", "createNewProfilingMsgSyntax", "createNewProfilingMessageSchentax", "createNewProfilingMessagesyntax", "createNewProfilingMessageCyntax", "createNewProfilingMessageSchembol", "createNewProfilingMsgSymbol", "createNewProfilingMsgSchentax", "createNewProfilingMsgSchembol"], "configID": ["componentOR", "confPK", "componentId", "confIDs", "configURI", "cfgID", "confID", "cfgURI", "caseID", "confId", "confURI", "configIDs", "caseURL", " configIDs", "configid", "cfgId", " configOR", "configML", "configPK", "caseML", " configURL", "confOR", "configOR", "configId", "caseid", "componentID", " configid", "configURL", "componentPK", "ConfigID", "Configid", " configURI", " configPK", " configId", "ConfigURL", "ConfigML", "cfgIDs", " configML"], "programMessageSymbolID": ["programMessageSyrorN", "programMessageSySyID", "programMessageSymbolValue", "programMessageSySyId", "programMessageSyElementId", "programMessageSyElementID", "programMessageSymmbolN", "programMessageSySyName", "programMessageSymmbolID", "programMessageSyTypeValue", "programMessageSyElementName", "programMessageSyptionID", "programMessageSymbID", "programMessageSymbolName", "programMessageSymbN", "programMessageSymbolN", "programMessageSymmbolName", "programMessageSyTypeName", "programMessageSyTypeId", "programMessageSymmbolId", "programMessageSyrorIDs", "programMessageSymbolIDs", "programMessageSymmbolid", "programMessageSySyid", "programMessageSyElementValue", "programMessageSyTypeID", "programMessageSymbId", "programMessageSymmbolIDs", "programMessageSyrorId", "programMessageSymmbolValue", "programMessageSymbIDs", "programMessageSymbolId", "programMessageSyptionName", "programMessageSyptionid", "programMessageSyptionId", "programMessageSymbolid", "programMessageSyrorID"], "profilingMessageSymbol": ["profilingMessageSysmbol", "profilingMessageSymntax", "profilingMessageSyols", "profilingMessagePyntax", "profilingMsgSyntax", "profilingMsgSymbol", "profilingMsgSyavior", "profilingMessageSYse", "profilingMessageSysmb", "profilingMsgSymavior", "profilingMessagesyols", "profilingMessageSyse", "profilingMessageCyntax", "profilingMessageSysols", "profilingMessagePyavior", "profilingMsgSymntax", "profilingMessagePymbol", "profilingMessageSymse", "profilingMessageSyavior", "profilingMessageSYmb", "profilingMsgSymmbol", "profilingMessageSymmb", "profilingMessagesymbol", "profilingMessageSymols", "profilingMessageCyavior", "profilingMessageSymavior", "profilingMessageSyntax", "profilingMessageCymbol", "profilingMessageSymb", "profilingMessageSYmbol", "profilingMessagesyse", "profilingMessagesymb", "profilingMessageSymmbol"], "connection": ["usage", "module", "note", "link", "table", "handler", "close", "document", "ion", "engine", "information", "reference", "cone", "character", "condition", "line", "established", "device", "socket", "settings", "ce", "system", "Connection", "client", "context", "resource", "directory", "bo", "sequence", "library", "writer", "conn", "operation", "connected", "created", "application", "function", "associated", "volume", "con", "current", "server", "network", "position", "database", "session", "relation", "communication", "city", "config", "connect", "db", "initial", "subject", "response", "generation", "entry", "channel", "open", "we", "command", "collection"], "statement": ["memory", "sql", "processor", "usage", "storage", "linger", "t", "note", " Statement", "phrase", "parse", "expression", "document", "journal", "rule", "reference", "se", "management", "condition", "ment", "EMENT", "sp", "list", "activity", "message", "sequence", "directory", "resource", "mt", "report", "print", "library", "bind", "application", "function", "set", "stat", "language", "state", "template", "position", "instance", "network", "database", "Statement", "session", "relation", "comment", "description", "stan", "execute", "response", "policy", "subject", "volume", "chain", "command", "shell"], "resultSet": ["eventList", "resultset", "resultPath", "traceList", " resultList", "Resultset", "resultHandle", "rowScan", "recordHandle", "ResultRow", "ResultPath", "rowset", "recordset", "ResultSet", "ResultHandle", " resultScan", "resultRow", " resultPath", "rowSet", "resultS", "traceSet", "rowRow", "ResultScan", "eventPath", "resultSource", "ResultS", "resultScan", "rowList", " resultset", "rowS", "resultList", " resultRow", "traceSource", "recordList", "eventset", "recordSet", "ResultList", "ResultSource", " resultSource", "traceset", "eventSet", " resultS", "rowHandle"], "query": ["join", "sql", "eries", "send", "note", "parse", "update", "read", "expression", "table", "where", "gate", "how", "ion", "key", "get", "condition", "scope", "quest", "check", "sq", "QU", "quote", "question", "message", "sequence", "menu", "spec", "password", "print", "call", "content", "q", "request", "transform", "scan", "select", "code", "test", "Query", "find", "create", "init", "string", "title", "search", "show", "sum", "ERY", "comment", "script", "lock", "execute", "volume", "qu", "commit", "command", "ql"], "msg": ["m", "sql", "bg", "cmp", "err", "note", "med", "Msg", "rup", "pkg", "mu", "og", "meg", "gr", "warn", "nm", "mem", "e", "reason", "error", "name", "message", "ung", "md", "mn", "mt", "log", "mun", "req", "mess", "doc", "mb", "gem", "sm", "gs", "str", "mg", "term", "g", "em", "cmd", "txt", "ex", "sg", "title", "comm", "cfg", "char", "notice", "man", "ext", "sum", "nom", "mag", "gm", "mail", "html", "gen", "kg", "text", "ged"]}}
{"id1": "15202804", "id2": "2217889", "code1": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"getDigest": ["getdigested", "getMDests", "getdigest", "getDests", " getDigests", " getdigest", " getDigester", "getMDested", "getMDester", "getMDest", " getDigested", "getdigester", "getdigests", "getDester", " getdigester", "getDested", " getdigests", " getdigested", "getDest", "getDigested", "getDigests", "getDigester"], "user": ["project", "ome", "person", "http", "back", "host", "username", "User", "device", "use", "system", "name", "client", "role", "change", "post", "login", "owner", "by", "account", "admin", "org", "human", "me", "order", "from", "USER", "ip", "string", "word", "usr", "manager", "actor", "force", "form", "usa", "job", "author", "ud", "bug"], "realm": ["tenme", "calmid", "realmid", "Realm", "chemid", "alms", "almi", "Realme", "chem", "realme", "alme", "realmi", "alm", "Realms", "calm", "Realmi", "Realmn", "chemn", "tenmi", "realmn", "tenms", "Realmid", "calme", "calmn", "realms", "tenm", "cheme"], "password": ["pass", "paste", "words", "phrase", "Password", "crypt", "property", "productive", "username", "power", "device", "php", "message", "port", "sword", "post", "reset", "remember", "confirmed", "wordpress", "create", "encrypted", "word", "database", "session", "hash", "PASS", "description", "data", "form", "hello", "policy", "wd", "wp"], "method": ["process", "mod", "go", "module", "api", "http", "where", "mode", "path", "url", "property", "get", "util", "prop", "version", "eth", "message", "resource", "spec", "op", "verb", "service", "gem", "hod", "action", "select", "function", "Method", "class", "man", "METHOD", "hash", "force", "form", "view", "subject", "format", "time", "type", "command"], "uri": ["ur", "http", "URI", "phi", "archive", "https", " URI", "path", "url", "du", "util", "username", "range", "pi", "host", "ui", "address", "connection", "resource", "direction", "unit", "ouri", "term", "iri", "course", "location", "ri", "doi", "database", "query", "via", "i", "web", "subject"], "nonce": ["boncer", "noncer", "Noncause", "bonces", "Nonce", "doncer", "vincause", " noncer", "nonCE", "Noncer", "doncause", "donCE", " nonces", "NonCE", "vinCE", "nonced", "Nonces", "nonces", "vince", "bonced", "donce", "vincer", " nonced", "bonce", "noncause", "Nonced"], "digest1": ["digestedEx", "digist1", "digist0", "digester2", "digestedOne", "digest0", "digaceEx", "digESTOne", "Digestone", "digEST1", "digaceOne", "digested1", "DigEST1", "digistOne", "DigESTOne", "Digest2", "digester1", "digace1", "Digest1", "digestedone", "Digester1", "digested2", "DigESTone", "Digester2", "digester0", "digested0", "digESTone", "DigestOne", "digesterOne", "digaceone", "DigesterOne", "digestEx", "digESTEx", "DigestEx", "DigESTEx", "digestone", "Digester0", "Digest0", "digist2"], "digest2": ["Diggest2", "DiggestTwo", "digist1", "Diggesttwo", " digesterTwo", "digester2", "diggestTwo", "diggest2", "digested1", "Digest2", "digester1", "digistTwo", " digester1", " digester2", "Digest1", "digist3", "digist2", "digested2", " digester3", "diggest1", "digestertwo", "digesttwo", "diggesttwo", "digesterTwo", "DigestTwo", "Diggest1", "Digesttwo", "digester3", "digestedtwo", "diggest3", "digestedTwo"], "digestOne": ["digestedOnce", "DigesterSingle", "digistSingle", "digist1", "DigestOnce", "digestedOne", "digerOnce", "Digestone", "DigesterOnce", "digested1", "digseSingle", "digistOne", "digester1", "digesterone", "Digest1", "digseOnce", "diger1", "digerOne", "Digesterone", "digesterOnce", "digestedone", "digse1", "Digester1", "digerSingle", "DigestOne", "digesterOne", "digseOne", "digistone", "DigesterOne", "digestedSingle", "DigestSingle", "digestSingle", "digesterSingle", "digestone", "digistOnce", "digestOnce"], "hexDigestOne": ["hexDigested1", "hexdigistTwo", "hexDigseOnce", "hexdigseInit", "hexDigseOne", "hexDigestedOne", "hexdigseOne", "hexdigestName", "hexDigestedTwo", "hexDigest1", "hexDigistTwo", "hexDigistName", "hexdigest1", "hexDigistInit", "hexDigistOne", "hexdigse1", "hexdigestOne", "hexDigesterName", "hexDigestName", "hexdigestInit", "hexDigestedName", "hexDigseInit", "hexDigesterOne", "hexDigist1", "hexdigseOnce", "hexdigistOne", "hexDigestOnce", "hexdigestOnce", "hexDigestInit", "hexDigse1", "hexDigester1", "hexdigestTwo", "hexDigesterTwo", "hexdigistName", "hexDigestedOnce", "hexdigist1", "hexDigistOnce", "hexDigestedInit"], "digestTwo": ["ddestAnother", "ddestThree", "DigesterTwo", "digester2", "diggestTwo", "digrate2", "Digestertwo", "digestingTwo", "digisticTw", "diggest2", "mixseTw", "mixsetwo", "mixest2", "mixseTwo", "digrateThree", "mixesttwo", "digistAnother", "Digest2", "digestTaylor", "digisttwo", "digistictwo", "ddest2", "DigestTaylor", "digistTwo", "ddistAnother", "mixestTwo", "digestingTaylor", "digsetwo", "diggestThree", "digseTwo", "mixse2", "diggestTw", "digist2", "digisticTwo", "ddestTwo", "digrateAnother", "digesting2", "digestingtwo", "digestAnother", "digistTaylor", "digestertwo", "Digester2", "digesttwo", "ddist2", "diggesttwo", "digse2", "digrateTwo", "digesterTwo", "ddistThree", "diggestAnother", "DigestTwo", "DigesterTaylor", "Digesttwo", "digistThree", "digistic2", "digseTw", "digestTw", "digesterTaylor", "mixestTw", "ddistTwo"], "hexDigestTwo": ["hexdigestThree", "hexDigESTTwo", "hexDigestedOne", "hexDigistThree", "hexDigEST2", "hexDigesterAnd", "hexDigested2", "hexDigestaTwo", "hexDigestedTwo", "hexDigestedAnd", "hexDigistTwo", "hexDigist2", "hexdigesterThree", "hexDigestAnd", "hexdigestOne", "hexDigestaAnd", "hexdigesterAnd", "hexdigestAnd", "hexdigesterOne", "hexDigester2", "hexdigester2", "hexDigESTThree", "hexDigesterOne", "hexDigest2", "hexDigesta2", "hexDigestaOne", "hexDigesterThree", "hexdigesterTwo", "hexDigesterTwo", "hexdigestTwo", "hexdigest2"], "digest3": ["digesterThree", "diggestThird", "digESTThird", "Digester3", "digestThird", "diggestthree", "digetThree", "digistThird", "Digist3", "Digest3", "DigistThree", "digESTThree", "DigestThree", "digestthree", "digetThird", "Digester003", "diggest003", "diggestThree", "diget3", "DigesterThree", "digistthree", "digist3", "digester003", "DigesterThird", "Digest003", "Digistthree", "diget003", "digesterThird", "Digestthree", "digESTthree", "digester3", "digistThree", "DigestThird", "digest003", "diggest3", "DigistThird", "digEST3"], "digestThree": ["ddgestthree", "ddest3", "digester5", "digestingThree", "ddestThree", "Diggestthree", "DiggestThird", "diggestThird", "digesterThree", "ddestThird", "Digester3", "digestThird", "diggestthree", "Diggest3", "ddgestThird", "digistThird", "DiggestThree", "digesting3", "Digest3", "ddgestThree", "DigestThree", "digestthree", "digesterthree", "Digester5", "digest5", "diggestThree", "DigesterThree", "digistthree", "digist3", "ddgest3", "digseThree", "DigesterThird", "digsethree", "diggest5", "Digest5", "digesting5", "Digestthree", "digseThird", "digestingThird", "digester3", "digse3", "digistThree", "DigestThird", "diggest3", "digesterThird", "ddestthree"], "hexDigestThree": ["hexdigestThree", "hexDigest3", "hexDigested3", "hexDigistThree", "hexDigestRight", "hexdigist3", "hexDigestthree", "hexdigest3", "hexDigesting4", "hexDigist3", "hexdigestthree", "hexDigester3", "hexDigestedThird", "hexDigesterthree", "hexDigistRight", "hexDigesting3", "hexdigest4", "hexDigestedthree", "hexdigestsThird", "hexdigistRight", "hexdigistThree", "hexdigestThird", "hexDigestThird", "hexdigestRight", "hexDigesterRight", "hexDigesterThird", "hexDigestingThree", "hexDigest4", "hexDigestingRight", "hexDigestedThree", "hexdigist4", "hexDigesterThree", "hexdigests3", "hexDigester4", "hexdigestsThree", "hexDigist4", "hexdigeststhree", "hexDigestsThird", "hexDigeststhree", "hexDigestsThree", "hexDigests3"]}}
{"id1": "16820041", "id2": "8921716", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"encodePassword": ["encodePass", "encodedpassword", "encodepassword", "enotePass", "enccodePassword", "enodePassword", "enccodepassword", "enotepassword", "enotePassword", "enccodePass", "encodedPass", "enodePass", "enodepassword"], "_originalPassword": [" _originalWord", "_OriginalWord", "_OriginalPassword", "_modifiedString", "_originalText", "_originalToken", " _modifiedText", "_encryptedText", "_modifiedWord", "_originalWord", "_OriginalUser", "_originalString", "_OriginalString", "_encryptedWord", " _modifiedWord", " _originalUser", "_modifiedPassword", "_encryptedPassword", "_encryptedString", " _originalText", "_originalUser", "_modifiedText", " _OriginalString", "_encryptedUser", " _OriginalToken", "_OriginalText", "_encryptedToken", " _OriginalUser", " _originalToken", " _modifiedString", "_OriginalToken", " _originalString", "_modifiedUser", "_modifiedToken", " _OriginalPassword", " _modifiedPassword"], "md": ["mod", "m", "ms", "det", "pd", "df", "ld", "managed", "mk", "dh", "mc", "pm", "nd", "add", "MD", "di", "ng", "ind", " m", "dig", "cd", "mn", "mt", "od", "bd", "mb", " mo", "sm", " mc", "magic", "mg", "sd", "de", "cmd", "dm", "mm", "metadata", "dr", "ds", "def", "der", "sha", "nt", "material", "ma", "hd", "red", " Md", "mand", "grad", "mo", "mp", "dd", "d"], "encodedPassword": ["encressedConnection", "acodedPassword", "encachedString", "EncodedEmail", "encodedUser", "EncodingText", "encryptedpassword", "enccodedSecret", "ecryptedpassword", "enccodedString", "encodingPassword", "encodedpassword", "EncodedPassword", "encodedEmail", "encachedpassword", "encachedSecret", "encodedConnection", "EncodedText", "EncodingUser", "ecodedString", "encryptedText", "encressedPassword", "encressedpassword", "encatedConnection", "encodingEmail", "encachedPassword", "ecodedSecret", "acratedConnection", "encoderUser", "encratedConnection", "acratedpassword", "ecryptedString", "encryptedEmail", "encoderPassword", "encodedString", "ecryptedSecret", "acratedPassword", "encodedSecret", "encodedText", "EncodedUser", "encodingText", "encratedPassword", "encatedpassword", "encryptedString", "EncodingEmail", "encodingUser", "encryptedUser", "encryptedPassword", "encoderEmail", "encatedPassword", "encoderText", "acodedpassword", "ecryptedPassword", "enccodedpassword", "ecodedPassword", "acodedConnection", "encratedpassword", "encryptedSecret", "EncodingPassword", "enccodedPassword", "ecodedpassword"]}}
{"id1": "17161805", "id2": "771802", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"encode": ["Enforce", "encforce", "enscode", "enprocess", "enccode", "unode", "Enode", "enode", "ensforce", "unprocess", "uncode", "enforce", "Encode", "unforce", "ensprocess", "encprocess", "ensode"], "plaintext": ["plainText", " plainlat", "plainlat", "mainText", "maintext", "formmessage", " plainth", " plainText", "formdata", "plaindata", "prontext", "formText", "pronlat", "ainText", "aintext", "formtext", "plainth", "plainmessage", "ainmessage", "pronText", " plaindata", "mainth", " plainmessage", "aindata", "pronth", "mainlat"], "md": ["mod", "m", "ms", "med", "det", "pd", "df", "amd", "ld", " MD", "managed", "mk", "dh", "mc", "pm", "add", "MD", "ng", "del", "ind", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "pdf", "sha", "der", "nt", "hd", " Md", "red", "mand", "grad", "msg", "mo", "mp", "dd", "d"], "raw": ["full", "hex", "row", " Raw", "orig", "read", "unsigned", "custom", "bare", "strip", "value", "mem", "aw", "valid", "sh", "message", "bound", "map", "stable", "wrap", " RAW", "clean", "unknown", "n", "buf", "cmd", "pack", "inner", "Raw", "def", "input", "cooked", "modified", "RAW", "json", "des", "bytes", "rendered", "serial", "derived"]}}
{"id1": "15797402", "id2": "1169642", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        String key = getKey();\n        synchronized (this.lauchedHTTPRequests) {\n            if (this.lauchedHTTPRequests.contains(key)) return;\n            this.lauchedHTTPRequests.add(key);\n        }\n        String st = this.dataSource.getTileURL(this.x, this.y, this.z);\n        URL url;\n        try {\n            url = new URL(st);\n        } catch (MalformedURLException e1) {\n            logger.warning(\"Error in URL: \" + st);\n            return;\n        }\n        String geoJSON = \"\";\n        try {\n            InputStream is;\n            if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else {\n                logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol());\n                return;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = in.readLine()) != null) geoJSON += line;\n            in.close();\n        } catch (FileNotFoundException e) {\n            return;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        VectorTile tile = new VectorTile(geoJSON, x, y, z);\n        Geometry[] geoms = new Geometry[tile.getPieces().size()];\n        int i = 0;\n        for (MfGeo geo : tile.getPieces()) {\n            if (geo.getGeoType() == GeoType.GEOMETRY) {\n                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();\n            } else if (geo.getGeoType() == GeoType.FEATURE) {\n                MfFeature mf = (MfFeature) geo;\n                geoms[i++] = mf.getMfGeometry().getInternalGeometry();\n            }\n        }\n        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);\n        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));\n        this.dataSource.getLayer().getDisplayCacheLoader().coin();\n        synchronized (this.lauchedHTTPRequests) {\n            this.lauchedHTTPRequests.remove(key);\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["process", "read", "dump", "close", "se", "add", "build", "filter", "scale", "php", "use", "p", "resource", "ping", "map", "print", "patch", "write", "transform", "apply", "pe", "create", "save", "render", "interpret", "slice", "split", "tag", "xml", "execute", "parser", "format", "handle", "load", "shape"], "stream": ["Stream", "upload", "zip", "in", "read", "http", "sample", "length", "archive", "document", "cont", "url", "open", "ream", "iterator", "message", "buffer", "sequence", "resource", "image", "reader", "content", "sync", "clean", "source", "window", "console", "test", "output", "input", "instance", "form", "file", "data", "chain", "channel", "response", "download", "handle", "event", "stack"], "handler": ["processor", "storage", "callback", "h", "host", "management", "worker", "address", "connection", "hand", "writer", "resource", "message", "password", "wrapper", "reader", "event", "service", "application", "controller", "function", "ctx", "server", "pool", "Handler", "parser", "policy", "loader", "hander", "handle", "shape"], "metadata": ["info", "memory", "m", "details", "module", "detail", "document", "managed", "property", "definition", "management", "tar", "general", "MD", "mem", "common", "iterator", "message", "image", "md", "mt", "content", "unknown", "still", "basic", "google", "met", "ctx", "dirty", "td", "template", "properties", "pdf", "meta", "java", "material", "json", "adata", "parts", "config", "manager", "xml", "header", "data", "policy", "handle", "dd", "hold"], "context": ["dict", "usage", "module", "null", "sc", "document", "component", "condition", "reason", "cc", "ce", "environment", "system", "connection", "sequence", "resource", "content", "set", "local", "ctx", "location", "state", "template", "instance", "current", "network", "Context", "config", "frame", "chain", "response", "translation", "command", "options", "event", "stack", "collection"], "name": ["pass", "NAME", "null", "Name", "old", "path", "url", "default", "base", "prefix", "on", "version", "nm", "value", "reason", "part", "common", "none", "system", "id", "client", "label", "image", "resource", "l", "nl", "service", "term", "source", "n", "no", "local", "create", "named", "lower", "title", "string", "alias", "all", "current", "body", "names", "ame", "comment", "description", "data", "size", "file", "channel", "type", "len", "family", "key", "time", "filename"], "out": ["cn", "null", "in", "po", "table", "lay", "us", "o", "url", "up", "aos", "it", "list", "v", "writer", "obj", "to", "outs", "print", "flush", "io", "one", "n", "res", "user", "cmd", "output", "ex", "Out", "all", "con", "conf", "conv", "outer", "sum", "ou", "oss", "sys", "OU", "gen", "external", "auto", "OUT", "co", "file", "serv", "cos", "col", "net"]}}
{"id1": "5998352", "id2": "14758866", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"testStandardTee": [" testStandardEette", " testStandardNe", " teststandardMee", " teststandardTe", " testStandardNee", " testStandardMees", " testStandardNette", " testStandardTe", " testStandardMee", " testStandardTette", " testStandardEee", " testStandardMette", " testStandardEe", " teststandardTette", " testStandardNees", " teststandardMette", " teststandardMe", " teststandardTee", " testStandardMe", " testStandardTees", " teststandardTees", " testStandardEees", " teststandardMees"], "reference": ["memory", "re", "note", "link", "sample", "expression", "document", "specified", "back", "ref", "key", "definition", "information", "prefix", "register", "condition", "value", "internal", "use", "address", "name", "Reference", "approximately", "message", "sequence", "directory", "library", "print", "report", "pointer", "service", "operation", "request", "argument", "example", "function", "test", "see", "relative", "using", "associated", "search", "string", "pattern", "template", "alias", "title", "section", "position", "word", "reverse", "resolution", "relation", "description", "external", "hello", "remote", "type", "filename", "attribute", "collection"], "source": ["src", "sql", "sample", "SOURCE", "get", "username", "base", "stream", "ser", "store", "iterator", "buffer", "sequence", "resource", "unit", "spec", "context", "seed", "reader", "service", "select", "console", "ource", "from", "copy", "inner", "template", "operator", "style", "input", "core", "instance", "target", "force", "Source", "file", "format", "loader", "shell"], "destination1": ["stination2", "destination01", "desturationOne", "desturationFirst", "destinator1", "stension2", "stinationFirst", "desturation1", "destinationsFirst", "destinatorOne", "destinationsOne", "DestinatorOne", "destregationone", "stension1", "destension1", "destificate01", "destinationOne", "Destinator01", "destregationName", "Destinatorone", "Destinator1", "stinationOne", "destinations1", "destinations2", "DestinatorName", "Destinationone", "destationOne", "destation1", "stensionOne", "Destination01", "destensionOne", "destinationName", "destinator01", "destificationone", "destificateOne", "destinationone", "destensionFirst", "destificate1", "destregationOne", "destificationName", "destificationOne", "stination1", "destation01", "stensionFirst", "destinatorName", "destension2", "destregation1", "Destination1", "desturation2", "DestinationOne", "DestinationName", "destinationFirst", "destinatorone", "destification1"], "destination2": ["destinition52", "destinator2", "destinator3", "Destension1", "desturation4", "destociationTwo", "estinition3", " destinationtwo", "destination4", "destinated2", "destination3", "destinate1", "Destension2", "destinator52", "destendanttwo", "destendant2", "destociation1", " desturation2", "destension4", "Destination2", "destensiontwo", " desturation4", "destensionB", "destinated3", "destendant4", "estinition52", "destensionTwo", "destinition3", "estination3", "destinationtwo", "destinationB", " desturationtwo", "destination52", "destinated52", "desturationB", "estination2", "DestensionTwo", "destociation2", "destinationTwo", "destension2", "destinate2", " destination4", " destinationB", "destendantB", "destinition2", "Destination1", "desturation2", " desturationB", "DestinationTwo", "destinateTwo", "desturationtwo", "estinition2", "estination52", "destension1"], "tee": ["ceee", "peE", "tete", "iete", "peoe", "cheee", "seE", "ieee", "ceE", "teoe", "cheea", "tees", "teea", "peer", "teE", "peee", " teee", "pees", "teee", "chee", "cees", "seoe", "pee", "ceer", "see", " teea", " teer", "seee", " teoe", " teE", " tete", " tees", "ieea", "iee", "teer", "ceoe", "chete", "cee"]}}
{"id1": "12389873", "id2": "4852691", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"load": [" fill", " read", " reload", " cleanup", " destroy", " register", " validate", " find", " parse", " construct", " ping", " fetch", " build", "construct", " startup", " ingest", " Init", "init", "save", " recover", " dump", " test", " scan", "insert", "execute", " search", " refresh"], "conn": ["dn", "nc", "cn", "gate", "c", "close", "coll", "mc", "ch", "pen", "cc", "ct", "pg", "pas", "cp", "ns", "Con", "Connection", "connection", "client", "obj", "mn", "mt", "cur", "Conn", "enc", "yn", "wr", "org", "n", "rel", "ln", "cmd", "die", "act", "ens", "ctx", "ctr", "en", "comm", "ds", "cfg", "con", "conf", "nt", "conv", "com", "db", "cb", "connect", "ann", "co", "open", "cert", "col", "pt"], "stmt": ["estgr", "stackpt", "constst", "putmm", "estmg", "restaddr", "stacktab", " staddr", "strmn", "Stmem", "esttx", "stytx", "STMT", "estgt", "ostgr", "stackmid", "ostmid", " stcmd", "staddr", " superststat", "Stst", " stMT", "styaddr", "histmt", "stackgt", "STmsg", " stmn", "restgr", "stMT", "puttab", "styMT", "stopmt", "restpt", "stackMT", " sttx", " stpt", "Stmb", "Stmt", "STmb", "putolt", " strm", "stmn", " superstmg", "stmem", "sttr", "stst", " stmem", "constMT", "stopmn", " stmsg", "Stmsg", "stoprm", "STgt", " stmb", " Stm", "Stgt", " stgr", "sttab", "stmg", "putmt", "ostmn", "strm", "resttx", "istgt", " stmg", " sttr", "puttx", " stst", "strmg", "stym", "ostmm", "constm", "osttab", " Sttr", " stmm", "stackmm", " stmid", "stopmm", "strstat", "putMT", "restmp", "ststat", " ststat", "restmg", " Stmt", "stackolt", " superstMT", "ostrm", "Stmm", "stackmt", "stcmd", "histcmd", "STmt", "strmt", " stm", "estm", "istMT", "stymem", "stolt", "restMT", "histtry", "stm", "stymg", "estmt", "ostpt", "sttry", "stmid", "Stm", "stymb", "ostolt", "Stcmd", " stgt", "putmp", "stgr", " superstmt", "histgt", "stmm", " StMT", "constmt", " superstmn", "stmp", "ostgt", "restmm", " stolt", "estmb", " stmp", "istmt", "sttx", "Sttry", "restgt", "stymsg", "Stgr", "StMT", "ostmem", "stygt", "restmt", "ostmt", "stmsg", "stmb", "STtx", " superstm", "stymt", "estmm", "stgt", " sttry", "stpt", " supersttr"]}}
{"id1": "14764852", "id2": "3806532", "code1": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"doRequest": [" doGet", "DoQuery", "runRequest", "DoRequest", "doQuery", " doQuery", "DoGet", "doGet", "runResponse", " doResponse", "runQuery", "doResponse", "runGet", "DoResponse"], "method": ["process", "mod", "m", "each", "module", "send", "http", "mid", "pkg", "end", "mode", "period", "path", "property", "url", "top", "history", "ind", "eth", "message", "right", "direct", "rest", "post", "verb", "request", "term", "th", "hod", "action", "mount", "agent", "met", "Method", "class", "tr", "head", "nom", "METHOD", "via", "rem", "type", "text", "command"], "headers": ["modules", "frames", "packages", "actions", "params", "authors", "codes", "rooms", "events", "mods", "files", "issues", "users", "ers", "heads", "checks", "blocks", "bits", "options", "members", "fields", "ilers", "weights", "groups", "dates", "boxes", "links", "keys", "holders", "ports", "writers", "drivers", "head", "xs", "terms", "reports", "names", "pres", "header", "ppers", "limits", "images", "tags", "ters"], "auth": ["upload", "http", "read", "crypt", "pkg", "ok", "mk", "authent", "util", "urg", "pas", "cp", "aud", "help", "uth", "login", "password", "ic", "Auth", "cmd", "act", "ip", "stat", "pub", "anon", "ssl", "iam", "xy", "img", "priv", "lit", "hd", "force", "cb", "aut", "form", "ht", "acl", "cert", "ac"], "target": ["src", "iat", "link", "table", "gt", "path", "url", "range", "host", "base", "top", "scope", "peer", "address", "client", "message", "eth", "arg", "resource", "to", "Target", "uri", "source", "rel", "ARGET", "profile", "ip", "location", "origin", "state", "dest", "template", "root", "proxy", "arget", "subject", "loc", "tx"], "body": ["Body", "bh", "null", " Body", "ODY", "note", "other", "pos", "params", "bs", "b", "object", "h", "any", "se", "be", "part", "plain", "message", "buffer", "post", "report", "news", "by", "content", "out", "source", "dis", "related", "reply", "json", "query", "parts", "ob", "db", "bill", "description", "comment", "data", "msg", "ne", "odies", "bytes", "subject", "vol", "options", "file", "text", "ody", "shell", "obs"], "con": ["nc", "cn", "dial", "go", "fn", "cal", "c", "un", "syn", "cont", "pen", "xc", "gate", "ch", "ver", "trans", "ca", "pan", "ct", "ocon", "pas", "Con", "ce", "cond", "cp", "bo", "ain", "can", "mon", "dec", "uc", "conn", "cur", "Conn", "rec", "ln", "cf", "cmd", "cat", "win", "dat", "cr", "en", "bur", "comm", "cu", "conf", "bon", "sin", "conv", "com", "CON", "compl", "cm", "cb", "connect", "co", "cgi", "ran", "cons", "cos", "col", "ctrl"], "res": ["ret", "rep", "ms", "re", "Res", "resp", "val", "us", " Res", "gr", "results", "pas", "ts", "cs", "rest", "obj", "ress", "reset", "news", "req", "out", "rel", "respons", "ex", "rs", "vals", "nt", "pr", "inv", "rem", "des", "reg", "red", "RES", "ne", "cons", "ps", "result"]}}
{"id1": "19652200", "id2": "9450274", "code1": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 0, "substitutes": {"init": ["info", "update", "read", "run", "empty", " constructor", "get", "release", "store", "Init", "reset", "construct", " intern", " Init", "create", "start", "save", "launch", "index", " initiate", " initialization", " relocate", "config", "connect", "initial", "load"], "file": ["info", "full", "File", "null", "upload", "ile", "http", "binary", "FILE", "link", "disk", "table", "document", "il", "rule", "path", "base", "line", "be", "name", "message", "buffer", "image", "resource", "this", "port", "uri", "log", "f", "io", "report", "attribute", "source", "user", "local", "output", "create", "page", "tree", "real", "current", "body", "le", "fil", "form", "data", "format", "open", "filename", "handle", "load", "dir"], "url": ["ur", "api", "u", "http", "link", "b", "path", "util", "host", "base", "gl", "get", "address", "name", "resource", "uri", "l", "f", "sl", "r", "nl", "q", "cl", "str", "rel", "mount", "location", "ssl", "string", "char", "Url", "web", "mail", "i", "abs", "ll", "loc", "open", "URL", "browser"], "stream": ["Stream", "link", "engine", "path", "open", "ream", "socket", "message", "buffer", "context", "port", "resource", "source", "console", "page", "input", "session", "pool", "form", "view", "chain", "channel", "download", "handle", "status", "stack"], "byteArray": ["byteString", "ByteString", "charArray", "byteList", "charString", "ByteArray", " byteString", "charList", " byteList", "ByteList"], "content": ["cont", "Content", "path", "raw", "version", "value", "media", "message", "summary", "comments", "source", "action", "code", "title", "page", "template", "section", "body", "json", "hash", "config", "comment", "header", "data", "size", "format", "text", "status"]}}
{"id1": "20267500", "id2": "18696387", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWavFromUrl", "getWapFromURI", "getWapfromString", "getWavByURI", "getWapfromUrl", "getWavfromUrl", "getWavfromURL", "getWavByString", "getWapFromUrl", "getWavFromString", "getWavfromURI", "getWavByURL", "getWavfromString", "getWavByUrl", "getWavFromURI", "getWapFromURL", "getWapFromString", "getWapfromURL", "getWapfromURI"], "urlstr": ["strr", "strSTR", " urlSTR", " urlr", "Urlstr", "strstring", "urlname", "Urlname", "URLstr", "URLSTR", "URLstring", "dlSTR", " urlname", "urlstring", "strstr", "Urlstring", "UrlSTR", "URLr", "urlr", "dlstr", "dlstring", "dlname", "urlSTR", " urlstring"], "url": ["pl", "lr", "ur", "u", "http", "hl", "cal", "https", "il", "path", "h", "ls", "host", "base", "gl", "ml", "cp", "build", "address", "uri", "l", "f", "sl", "r", "nl", "cl", "q", "str", "res", "rel", "mount", "cr", "ssl", "con", "char", "com", "Url", "web", "mail", "ul", "xml", "file", "ll", "loc", "dl", "job", "open", "URL", "load"], "ais": ["aa", "auc", "pai", "aim", "hz", "ia", "ahi", "us", "ava", "ei", "asis", "ws", "a", "lis", "aos", "osi", "aci", "wi", "nas", "au", "audi", "asio", "aer", "AI", "asia", "ai", "sam", "ois", "opus", "asm", "bis", "acs", " ain", "pa", "ua", "oos", "iam", " ado", "ias", "ris", "sa", "ras", "aida", "aus", "asi", "osa", "as", "ami", "is", "asar", "aba", " arra", "ca", "ians", "isa", "ac"], "c": ["nc", "tc", "ci", "b", "ec", "cont", "rc", "ch", "C", "mc", "coll", "lc", "cin", "cc", "ct", "cp", "ce", "cs", "v", "dc", "cd", "l", "f", "r", "cur", "cl", "enc", "n", "anc", "fc", "cr", "cu", "con", "conv", "com", "cm", "cb", "co", "ca", "cos", "bc", "col", "ac", "ctrl"], "stream": ["Stream", "m", "row", "t", "in", "read", "sample", "cont", "path", "ream", "store", "buffer", "v", "context", "resource", "port", "f", "io", "sl", "content", "reader", "sam", "out", "enc", "source", "console", "st", "output", "REAM", "iam", "input", "present", "pipe", "stack", "form", "data", "file", "is", "channel", "open", "chain", "result"]}}
{"id1": "8486429", "id2": "14691829", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadProproperties", "loadproperties", "loadprops", "loadPrps", "loadPropperties", "initPrdates", "initPrps", "initProps", "initPrproperties", "loadProdates", "loadPrdates", "loadprodates", "loadPrperties", "loadPropproperties", "initProproperties", "initPrperties", "loadProps", "initProperties", "initProdates", "loadPropdates", "loadPropps", "loadPrproperties", "loadproproperties"], "properties": ["modules", "details", "notes", "packages", "params", "features", "jobs", "where", "property", "rows", "facts", "prop", "people", "results", "relations", "poses", "states", "settings", "abilities", "this", "values", "to", "prints", "members", "comments", "pro", "sheets", "rules", "papers", "organisms", "objects", "metadata", "keys", "holders", "types", "ports", "units", "database", "marks", "terms", "reports", "changes", "names", "parts", "projects", "perties", "posts", "tests", "builders", "beans", "policy", "options", "bugs", "ps"], "url": ["ret", "browser", "bel", "ur", "u", "http", "b", "ref", "open", "ls", "build", "address", "id", "p", "context", "resource", "obj", "uri", "l", "f", "sl", "nl", "rl", "service", "str", "rect", "mount", "user", "location", "sb", "char", "kl", "Url", "abs", "config", "file", "ll", "dl", "loader", "URL", "result"]}}
{"id1": "12242903", "id2": "7499186", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"hashKey": ["updateLink", "updatekey", "processkey", "processLink", "processValue", "hashValue", "updateValue", "hashLink", "hashkey", " hashValue", " hashkey", "processKey", " hashLink", "updateKey"], "key": ["ace", "hex", "item", "secret", "null", "phrase", "link", "path", "prefix", "username", "base", "piece", "value", "name", "id", "message", "y", "this", "client", "port", "obj", "password", "k", "seed", "attribute", "cache", "service", "cert", "source", "code", "encrypted", "string", "title", "state", "template", "token", "conf", "KEY", "char", "foo", "json", "description", "sk", "data", "lock", "type", "hello", "entry", "Key", "text", "chain", "et"], "hashed": ["hushed", " hushed", "rhamped", "ahored", "hhed", "khash", "khhed", "hashing", "khrypted", "hamped", "hoted", "shhed", "hoashed", "ahushed", "hrypted", " hrypted", "shoted", "enhhed", "thushed", "rhashed", "thashed", "khashed", "shashed", "khashing", "ahashed", "hored", " hamped", "enhash", " hashing", "ahash", " hhed", "enhashed", "rhhed", "enhrypted", "thash", " hored", "thored", " hoted", "hohed", "shamped", "hoashing", "rhoted", "hoash"], "md5": ["det55", " MD3", "MD3", " MD45", "sha0", "md3", " md45", "MD5", "sha3", "md45", "md55", " MD2", "md2", "sha2", "dig55", " md55", "sha5", "dig3", " MD5", "MD0", " md3", "det3", "MD2", " md0", "det5", "md0", "MD45", " md2", "dig5"], "hash": ["hex", "ah", "shift", "hz", "sample", "length", "ssh", "total", "h", "score", "has", "uh", "ash", "block", "ashed", "check", "square", "sh", "sq", "count", "build", "message", "kernel", "trust", "number", "height", "search", "sha", "Hash", "hed", "index", "sum", "checked", "carry", "tag", "html", "always", "array", "handle", "radius", "shadow"]}}
{"id1": "23672408", "id2": "9805906", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyiconfiles", "copyIndexDocuments", "copyIndexFiles", " copyiconImages", "copyiconFiles", "copyiconImages", "copyIconDocuments", "copyIndexfiles", "copyIconImages", "copyIconfiles", "copyiconDocuments", " copyIconDocuments", " copyiconDocuments", " copyIconImages", " copyIconfiles", " copyiconFiles", " copyiconfiles", "copyIndexImages"], "clazz": ["Clazz", "Close", "classe", "CLazz", " plub", "claz", "clus", "pkgashed", "classotted", "crazz", " clbean", "chojure", "classuddy", "scloser", "escazz", " closer", "callaz", "colluster", " clotted", "chace", " clojure", "collazz", " claz", "closer", "plasse", "pkgazz", "descaz", "Clab", "cluddy", "plazz", "plashed", "Clbo", "CLace", "Claz", "classazz", "clab", "callazz", "chotted", "relose", "clotted", "chazz", "clbean", "relab", "escotted", "collotted", "CLbean", "sclazz", "CLoser", "sclbean", "Clace", "relazz", "club", " club", "pkgaz", "relaz", " plaz", "plaz", "craz", "classuster", " clace", "callbo", "sclace", " clus", "descab", " classe", "close", " plus", " cluster", "descazz", "crub", "cluster", "escace", "escojure", "clace", " clashed", " clbo", "crus", " cluddy", "clbo", "pkgasse", " plazz", "callace", "colluddy", "clashed", "descose", "clojure"], "i16": ["pi16", "iri16", "liShort", "ini19", "pi6", "amiShort", "ri157", "i160", "i24", "ri6", "ii160", "ii216", "ami150", "ini24", "ii16", "iri6", "ini216", "iniShort", "i216", "ini2016", "ami6", "ri16", "li16", "ini160", " i216", "ji150", "iri157", " i24", "i6", "pi150", "i2016", " i157", "ii24", "ami16", "pi63", "ami2016", "i150", "li19", "ami63", "i157", "iri2016", "ji16", " i2016", "i19", " i160", "ji6", "i63", "li2016", "ji63", "iShort", "ri2016", " i6", "ini16", "ami19"], "fileType": ["eventList", "iletype", "relationFamily", "webTYPE", "formatValue", "FILEtype", "FILEType", "resourceUnit", " fileUnit", "fieldTYPE", "formType", "relationType", "webDef", "policyType", "policyFamily", "FileName", "relationHandler", "eventTYPE", "viewTYPE", "policyHandler", " filetype", "viewtype", "fileTime", "fieldType", "coreDef", "policyTyp", "coreHandler", "FileType", "fileName", "ilePattern", "coreTyp", " filePattern", " fileList", "formtype", " fileTime", "coreFamily", "relationTyp", "filetype", "coreType", "formName", "issuetype", "issueType", "filePattern", "coreTYPE", "resourceTYPE", "fileFamily", "formatTYPE", "issuePattern", "fileHandler", "treeType", "fileFormat", "fieldTyp", "fileDef", "ileTyp", "FILEName", "webType", "ileType", "formatType", "fileTYPE", "webTyp", "viewType", "eventUnit", "fileTyp", "fieldDef", " fileValue", "Filetype", "formatTime", "treetype", "formattype", "resourceFormat", "fileList", " fileFormat", "eventType", "eventFormat", "webList", "resourceType", "viewValue", "fileValue", " fileTyp", " fileTYPE", "issueTyp", "treeTYPE", "fileUnit", "treeTime"], "desti16": ["destgi16", "destui24", "destsi16", "resulti16", "resultii24", "resulti216", " destsi18", "destxi16", "desti2016", " desti18", "destii16", "desti160", "destsi160", "destxi32", "resulti24", "destui160", "destui16", "resulti2016", "destui32", " desti160", "destxi18", "desti216", "resultii2016", "resultii16", "destsi18", "destgi2016", "destui2016", "destii216", " destsi160", "resultii216", " destsi32", " destsi16", "destsi32", "destui18", "destgi24", "destui216", "destgi216", "desti18", "destii2016", "desti24", "destxi160", "destii24"], "src": ["sit", "bh", "isl", "sc", "cmp", "rob", "hl", "bg", "sel", "ctx", "rc", "cont", "syn", "pkg", "ls", "urg", "desc", "ser", "sq", "sp", "rest", "ins", "bin", "req", "sl", "nl", "iter", "sync", "rl", "cur", "std", "sub", "source", "sol", "gs", "rg", "proc", "scan", "rel", "ln", "st", "ibl", "txt", "rs", "ctr", "sb", "rx", "fc", "etc", "ssl", "inner", "rb", "iv", "sn", "sec", "input", "dest", "usr", "cli", "img", "sr", "tmp", "comp", "via", "ptr", "sys", "cb", "addr", "inst", "loc", "vr", "bc", "obs"], "dst": ["dLcut", "Dnd", "nput", " dmt", "ndsts", "ndest", "dmn", " ddr", "fdr", "dsot", "dddest", "fdest", "fnd", "dsst", "dLot", "tput", "nnd", "ndmt", "dsnet", "dbl", "rdest", "dLnet", "rcut", "dermn", "dmt", "ddnd", "dput", "dcut", " dbl", "dgt", "ddest", "Ddest", "dsts", "Ddr", "dnd", "dLest", " dsts", "derst", " ddest", " dcut", "dLbl", " dput", "tnd", "rdst", "dsest", " dest", "tst", "dest", "fst", "dnet", "rbl", "ngt", " dnd", "nst", "dLst", "ddr", "dernd", "derdest", " dgt", "rdmt", "dLdest", " dmn", "rdsts", "tgt", "ndst", "dot", "Dst", " dnet", "ddst", "ddmn", "rst", " dot"], "i32": ["xi22", "i31", "ini31", "i28", "i48", "ic40", "xi31", "ip31", "pi64", " i40", "ip34", "pi34", "i22", "pi31", "ic342", "i64", "ip64", "ic48", " i64", " i86", "pi32", "ini48", "ii342", "isi32", "i34", "ini32", "xi32", "ip32", "i86", "ic34", "ic64", "isi40", "i342", "isi64", "ic31", "ic22", "ii34", " i342", "ii28", "isi86", "ic32", "i40", "ic28", " i28", "ini22", " i34", "xi48", "ii32", "ic86", " i31"], "desti32": ["desti31", "Desti31", "destpi30", "destic30", "DestI90", "destu256", "destic32", "destu90", "destdi34", "targetpi34", "desti90", "destpi31", "destu32", "destpi34", "targeti34", "DestI256", "destI256", "desti30", "targeti30", "destI90", "targeti31", "destdi32", "DestI31", "targetpi31", "targetpi32", "desti256", "destdi30", "Desti256", "destu31", "desti34", "destdi31", "targetpi30", "destI32", "Desti90", "targeti32", "destpi32", "destic34", "destI31", "DestI32", "destic31", "Desti32"]}}
{"id1": "5551393", "id2": "5744992", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMD2", "getmd5", "getmd4", "getMD4", "getmd3", "getmd2", " getMD4", "getMD3", "getSHA5", " getMD2", "getSHA3", "getSHA4", "getSHA2", " getMD3"], "source": ["src", "sample", "SOURCE", "object", "url", "base", "value", "reason", "space", "now", "name", "message", "context", "image", "filename", "sequence", "s", "spec", "resource", "seed", "content", "ource", "site", "from", "output", "start", "string", "template", "style", "input", "body", "target", "force", "config", "Source", "data", "file", "subject", "text"], "tmp": ["perm", "tt", "m", "src", "bt", "cmp", "t", "aaa", "po", "buff", "pp", "rup", "pkg", "attr", "managed", "mk", "resp", "tn", "cont", "tar", "nd", "found", "bb", "cp", "sp", "snap", "p", "obj", "mobi", "temp", "cache", "out", " mp", "gb", "np", "buf", "test", "txt", "output", "etc", "bag", "jp", "img", "input", "foo", "nt", "lambda", "db", "cb", "cv", "msg", "data", "MP", "mp", "Temp", "qq", "result"], "md": ["mod", "m", "ms", "ad", "det", "pd", "df", "mac", "amd", "ld", " MD", "mk", "dh", "pm", "nd", "desc", "MD", "di", "ind", "rm", "cd", "mn", "mt", "od", "bd", "sam", "mb", "sm", "sd", "de", "cmd", "dm", "mm", "dr", "td", "pdf", "der", "nt", "hd", "red", " Md", "mand", "mp", "wd", "and", "dd", "d"]}}
{"id1": "8430178", "id2": "3187685", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFiles", " copyLine", "CopyLine", "copyPath", " copyPath", "CopyFiles", "cpFile", " copyFiles", "copyLine", "CopyPath", "copyFiles", "cpPath", "cpLine", "CopyFile"], "source_name": ["source_link", "src_format", "sourceEname", "src_check", "src_file", "Source_name", "sourcePname", "source_names", "Source_NAME", "source09link", "sourcePNAME", "source_case", "sourceptname", "source_check", " source_word", "source_Name", "source_local", "src_link", "sourceEName", "sourceptcheck", "source09name", "sourceptnames", "Source_local", "src_name", "src_case", "sourceEcase", "source09file", "source_NAME", "src_Name", "sourceptName", "src_names", "sourcePlocal", "source_format", "source09names", "source_word", "sourceEnames", " source_names"], "dest_name": [" dest_key", "dest_common", "dest_min", "destaxynam", "dest_time", "destityName", "src_file", "startityadmin", "destipcreate", "dest_NAME", "dest_id", "source_names", "destationName", "Dest_admin", "dest_Name", "dest_names", " dest_min", "startityname", "Dest_group", "start_Name", "dest_create", "src_id", "dest_nam", "destationadmin", "destityname", "dest__name", "src_create", "Dest_Name", " dest_size", "startitycommon", "source_Name", "dest__key", "destityadmin", "destaxyname", "destationname", "source_nam", "start_name", "dest__names", " dest_no", "destipid", " dest_file", "dest_no", "dest_group", "dest__size", "destipname", "src_name", "dest_admin", "start_admin", "startityName", "dest9name", "destaxynames", "Dest_name", " dest_time", "start_common", "source_NAME", "dest9Name", "destationcommon", " dest_names", "destaxyName", "dest9admin", "dest_key", "dest9group", "dest_size", "destitycommon", " dest_Name", "dest_file", "destipfile"], "source_file": ["source_link", "site___le", "source_le", "sourceistname", "site___stream", "sourcepyfile", "site_stream", "src_path", "source_time", "src_file", "source1name", "source___le", "source_stream", "source1stream", "source___stream", "site_file", "source_service", "source___class", " source_link", "source_class", "source1file", "sourcephpstream", "sourcephpfile", "source___time", " source_id", "source_info", "sourcephple", "ource_File", "site_le", "sourcepyle", "sourcepyservice", "source___service", "ource_time", "sourcephpservice", "source___File", "source2info", "source2file", "source___file", "source_File", "site___file", "source_path", "source_id", "src_stream", "src_name", "sourceistid", "source_entry", "site_service", "ource_file", "source2entry", "source1path", "ource_class", " source_info", "sourceistfile", "sourceistlink", "site___service", "sourcepystream", " source_entry"], "destination_file": ["destrantJpath", "destination_File", "destinant____db", "destification_ile", "destinant____file", "destinant_domain", "destrantJimage", "destinant_db", "destrant_fp", "destrantJfile", "destrant_file", "destification_file", "destinate_dir", "destination____db", "destination_db", "destination____domain", "destinant_fp", "destination____File", "destinant_port", "destinationJfile", "destinant_file", "destinant____domain", "destination__file", "destinate_file", "destination_link", "destination_dir", "destrant_path", "destinationJimage", "destification_port", "destinationJfp", "destination_port", "destination_ile", "destinant____File", "destrant_image", "destination_image", "destination__db", "destinationJpath", "destinant_File", "destination_path", "destrantJfp", "destination_domain", "destinant_link", "destination____file", "destinate_do", "destification_path", "destination_fp", "destination_do", "destination__domain", "destination__File", "destinate_ile"], "source": ["join", "src", "secret", "note", "sample", "SOURCE", "object", "base", "scope", "or", "parent", "ser", "store", "ce", "system", "use", "client", "connection", "image", "directory", "resource", "master", "unit", "sequence", "reader", "content", "feature", "iter", "service", "out", "argument", "ource", "site", "set", "local", "start", "from", "product", "copy", "origin", "search", "dest", "title", "template", "ources", "ie", "input", "class", "server", "sin", "existing", "target", "proxy", "session", "query", "config", "Source", "cause", "script", "file", "tool", "volume", "status", "shadow", "major"], "destination": ["estination", "gestination", "destification", "Destinator", "destociation", "gestociation", "targetinations", "estinate", "methodinated", "terminociation", "Destion", "alterninator", "targetinator", " destation", "restinator", "termininator", "origininated", "restation", "targetinated", "Destinations", "methodinator", " destinate", "originification", " destinator", "gestinator", "restinated", "destation", "Destation", "destinations", " destification", "methodination", "Destination", "destion", "methodinate", "destication", "estinated", "alternination", "restion", "Destinated", "coordination", "origininator", "coordinate", "coordinated", "alterninate", "targetination", "restinate", "targetociation", "targetion", "estication", "destinator", "destinate", "termininated", " destinated", "destinated", "alterninated", "restination", "restinations", "targetification", " destication", "coordication", "terminination", "originination", "gestinated"], "buffer": ["paste", "binary", "read", "buff", "length", "table", "b", "document", "batch", "base", "stream", "block", "Buffer", "bb", "message", "sequence", "context", "cache", "window", "buf", "iter", "transfer", "frame", "comment", "text", "command", "append"], "bytes_read": ["bytesunwritten", "bytes2left", "bytes2Read", "bytes2written", "bytes_left", "bytes_written", "bytes_Read", "bytes2read", "bytesunRead", " bytes_left", " bytes_Read", "bytesunread", "bytesunleft", " bytes_written"], "in": ["gin", "t", "err", " IN", "read", "nin", "diff", "get", "stream", "cin", "it", "add", "ini", "inf", "inn", "ind", "id", "client", "p", "mn", "ins", "l", "ic", "rin", "io", "reader", "r", "log", "doc", "std", "out", "n", "user", "from", "IN", "mm", "en", "isin", "bin", "inner", "all", "con", "input", "conf", "din", "body", "sum", "file", "is", "ar", "In"], "response": ["answer", "echo", "offer", "exit", "sample", "resp", "zero", "choice", "onse", "line", "success", "version", "value", "block", "python", "message", "question", "connection", "sequence", "ping", "reset", "print", "bye", "remember", "request", "respond", "example", "one", "window", "res", "application", "respons", "output", "page", "reply", "continue", "network", "Response", "notice", "relation", "json", "query", "hash", "description", "data", "hello", "entry", "format", "status", "command", "result", "vector"], "parentdir": ["Parentdir", "Parentfile", " parentDir", "parentfolder", " parentfile", "parentdirect", "rootdirect", "ParentDir", " parentdirectory", " parentfolder", "Parentfolder", "fatdirect", "parentdirectory", "fatd", "rootd", "masterdirectory", "rootdir", "fatdirectory", "rootDir", "fatdir", " parentdirect", "parentd", "masterdir", " parentd", "masterDir", "parentDir", "masterfile", "rootdirectory", "parentfile", "rootfolder", "Parentdirectory"]}}
{"id1": "21316706", "id2": "4168534", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"openConnection": ["doConnect", "openChannel", "openConnect", " obtainConnection", " openConnect", " obtainChannel", " obtainConnect", " openChannel", "openconnection", "doConnection", "doconnection", "doChannel", " openconnection", " obtainconnection"], "url": ["ret", "domain", "re", "ur", "http", "parse", "link", "b", "un", "path", "ls", "host", "util", "build", "address", "name", "id", "uri", "l", "log", "sl", "r", "q", "str", "mount", "location", "ssl", "string", "all", "char", "server", "Url", "mail", "access", "config", "el", "addr", "ul", "xml", "web", "file", "ll", "loc", "job", "key", "URL", "browser"], "proxy": ["browser", "project", "module", "cas", "http", "po", "link", "property", "Proxy", "version", "none", "socket", "slave", "address", "client", "connection", "port", "resource", "ping", "password", "uri", "library", "report", "pointer", "cache", "service", "pro", "one", "pe", "profile", "timeout", "ssl", "token", "server", "pipe", "pse", "zone", "via", "manager", "force", "roxy", "policy", "shadow"]}}
{"id1": "14047629", "id2": "8815137", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 1, "substitutes": {"source": ["src", "sql", "in", "sample", "expression", "SOURCE", "stream", "se", "system", "iterator", "address", "message", "buffer", "image", "sequence", "resource", "seed", "reader", "content", "service", "proc", "request", "q", "console", "ource", "output", "from", "copy", "input", "position", "query", "Source", "file", "data", "channel", "format", "event", "result", "shell"], "process": ["make", "project", "memory", "processor", "parse", "exec", "link", "complex", "run", "pid", "pp", "component", "object", "pm", "se", "condition", "mem", "check", "store", "cp", "use", "build", "context", "p", "post", "call", "service", "proc", "term", "method", "node", "processing", "function", "console", "code", "flow", "cmd", "create", "init", "state", "Process", "class", "work", "place", "and", "network", "pipe", "session", "program", "connect", "frame", "task", "script", "file", "sys", "execute", "chain", "job", "handle", "status", "command", "thread"], "processStdOut": ["processStrdOut", "processStrrOut", "processStrEx", "processStrrEx", "processStstdIn", "processStdEr", "processStrdEr", "processStrdIn", "processStstEr", "processStstOut", "processStstdEx", "processStrOut", "processStrIn", "processStstdOut", "processStdEx", "processStstIn", "processStrrEr", "processStstdEr", "processStstEx", "processStrdEx", "processStrrIn", "processStrEr"], "processStdIn": ["processStdIN", "processStackdin", "processSTtIn", "processStackdsIN", "processStdIns", "processStdsOut", "processSTtIN", "processSTdIn", "processStrIN", "processStdsin", "processSTtIns", "processStrIns", "processSTdIN", "processStackdsIn", "processStackdsin", "processStsIN", "processSttIns", "processStrOut", "processStackdOut", "processStrIn", "processSTdOut", "processStdsIns", "processStdsIN", "processStackdsOut", "processSttIn", "processSTdIns", "processSttIN", "processSttOut", "processStdsIn", "processStackdIn", "processStsin", "processStsIn", "processSTtOut", "processStdin", "processStsOut", "processStrin", "processStackdIN"]}}
{"id1": "5998352", "id2": "8754809", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"testStandardTee": [" testStandardEette", " testStandardNe", " teststandardMee", " teststandardTe", " testStandardNee", " testStandardMees", " testStandardNette", " testStandardTe", " testStandardMee", " testStandardTette", " testStandardEee", " testStandardMette", " testStandardEe", " teststandardTette", " testStandardNees", " teststandardMette", " teststandardMe", " teststandardTee", " testStandardMe", " testStandardTees", " teststandardTees", " testStandardEees", " teststandardMees"], "reference": ["memory", "re", "note", "link", "sample", "expression", "document", "specified", "back", "ref", "key", "definition", "information", "prefix", "register", "condition", "value", "internal", "use", "address", "name", "Reference", "approximately", "message", "sequence", "directory", "library", "print", "report", "pointer", "service", "operation", "request", "argument", "example", "function", "test", "see", "relative", "using", "associated", "search", "string", "pattern", "template", "alias", "title", "section", "position", "word", "reverse", "resolution", "relation", "description", "external", "hello", "remote", "type", "filename", "attribute", "collection"], "source": ["src", "sql", "sample", "SOURCE", "get", "username", "base", "stream", "ser", "store", "iterator", "buffer", "sequence", "resource", "unit", "spec", "context", "seed", "reader", "service", "select", "console", "ource", "from", "copy", "inner", "template", "operator", "style", "input", "core", "instance", "target", "force", "Source", "file", "format", "loader", "shell"], "destination1": ["stination2", "destination01", "desturationOne", "desturationFirst", "destinator1", "stension2", "stinationFirst", "desturation1", "destinationsFirst", "destinatorOne", "destinationsOne", "DestinatorOne", "destregationone", "stension1", "destension1", "destificate01", "destinationOne", "Destinator01", "destregationName", "Destinatorone", "Destinator1", "stinationOne", "destinations1", "destinations2", "DestinatorName", "Destinationone", "destationOne", "destation1", "stensionOne", "Destination01", "destensionOne", "destinationName", "destinator01", "destificationone", "destificateOne", "destinationone", "destensionFirst", "destificate1", "destregationOne", "destificationName", "destificationOne", "stination1", "destation01", "stensionFirst", "destinatorName", "destension2", "destregation1", "Destination1", "desturation2", "DestinationOne", "DestinationName", "destinationFirst", "destinatorone", "destification1"], "destination2": ["destinition52", "destinator2", "destinator3", "Destension1", "desturation4", "destociationTwo", "estinition3", " destinationtwo", "destination4", "destinated2", "destination3", "destinate1", "Destension2", "destinator52", "destendanttwo", "destendant2", "destociation1", " desturation2", "destension4", "Destination2", "destensiontwo", " desturation4", "destensionB", "destinated3", "destendant4", "estinition52", "destensionTwo", "destinition3", "estination3", "destinationtwo", "destinationB", " desturationtwo", "destination52", "destinated52", "desturationB", "estination2", "DestensionTwo", "destociation2", "destinationTwo", "destension2", "destinate2", " destination4", " destinationB", "destendantB", "destinition2", "Destination1", "desturation2", " desturationB", "DestinationTwo", "destinateTwo", "desturationtwo", "estinition2", "estination52", "destension1"], "tee": ["ceee", "peE", "tete", "iete", "peoe", "cheee", "seE", "ieee", "ceE", "teoe", "cheea", "tees", "teea", "peer", "teE", "peee", " teee", "pees", "teee", "chee", "cees", "seoe", "pee", "ceer", "see", " teea", " teer", "seee", " teoe", " teE", " tete", " tees", "ieea", "iee", "teer", "ceoe", "chete", "cee"]}}
{"id1": "1421557", "id2": "15645004", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToDisk", "encodeStringToFiles", "encodeStringAsFile", "encodeStringToFile", "encodeStringAsStream", "encodeFiletoDisk", "encodeStringToStream", "encodeFiletoFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileAsStream", "encodeFileAsFiles", "encodeFiletoFiles", "encodeStringAsFiles", "encodeFileFromFile", "encodeFileAsFile", "encodeFileFromDisk", "encodeFiletoStream", "encodeStringAsDisk", "encodeFileToStream", "encodeFileAsDisk", "encodeFileFromFiles", "encodeFileToFiles"], "infile": ["Inbase", "inpath", "outFile", "outfilename", "InFile", "outpath", " infilename", "Infile", " inbase", "inFile", "inputFile", "inbase", " inFile", "inputpath", "infilename", " inpath", "inputfile", "inputfilename", "Inpath", "outbase"], "outfile": ["outfp", " outname", "infp", "outFile", "newname", "outfilename", "newfilename", "inname", " outFile", "fromFile", "outname", "todir", "outdir", "inFile", " outfilename", "newFile", "fromdir", "tofp", "indir", "fromfp", "tofile", "infilename", "fromfile", "toFile", "newfile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "image", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "ro", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "up", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "total", "variable", "document", "length", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "cache", "number", "temp", "queue", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "attribute", "append"], "read": ["before", "each", "text", "send", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", "ok", "submit", "ratulations", " succ", "condition", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "ith", " Success", "summary", "primary", "commit", "positive", "surv", "same", "good", "safe", "complete", "continue", "second", "sufficient", "democracy", "town", " okay", "warning", "unity", "please", " successes", "first", "support", "city", " successful", "ceed", "fail", "response", "successfully", "status", "result", "crit", "accept"]}}
{"id1": "23161545", "id2": "17161805", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomUid", "getRandGUID", "getRandomUUID", "getRandUID", "getRandomCID", "getRandomSUID", "getRandomSID", "getRandomCuid", "getRandGuid", "getRandomGid", "getRandomGuid", "getRandomUuid", "getRandGid", "getRandomCid", "getRandomSuid", "getRandomSid", "getRandUid", "getRandomGID", "getRandUUID", "getRandomCUID", "getRandUuid", "getRandomUID", "getRandGID"], "secure": [" insecure", "pretty", "secret", "http", "active", "https", "security", "Secure", "nice", " securely", "client", "trust", " Secure", "stable", "quiet", "sync", "service", "confirmed", "strong", "safe", "google", "encrypted", "ssl", "dirty", "ie", "sensitive", "sec", "protect", "server", "sr", "prime", "force", "sys", "weak", "clear", "status"], "md5": ["md6", "MD3", "md3", "metadata3", " md45", "MD5", "MD512", "sha3", "md45", " md512", " md4", " mdle", "metadata5", "MD6", "md2", "md512", "sha2", "sha5", "dig3", "metadata45", "dig4", " md3", "sha512", "MD2", "MDle", "MD4", "sha6", "md4", "digle", "MD45", " md2", "metadata2", "mdle", "dig5", " md6"], "sbValueBeforeMD5": ["sbValueBeforeMDLeft", "sbValueBeforeMD65", "sbValueBeforeLM5", "sbValueWithoutDD5", "sbValueBeforeOLD5", "sbValueAfterND5", "sbValueBeforeAMDson", "sbValueBeforeMAC65", "sbValueBeforeMAC5", "sbValueAfterMD65", "sbValueAfterMD2", "sbValueAfterMD4", "sbValueBeforeMPLeft", "sbValueBeforeMS3", "sbValueBeforeMACFive", "sbValueBeforeLM2", "sbValueBeforeMS2", "sbValueBeforeMAC2", "sbValueBeforeMT2", "sbValueBeforeMP2", "sbValueBeforeND4", "sbValueAfterNDson", "sbValueAfterMD5", "sbValueBeforemd5", "sbValueBeforeMD512", "sbValueBeforemdson", "sbValueBeforeIM5", "sbValueWithoutMD5", "sbValueBeforeAMDFound", "sbValueBeforeSM2", "sbValueBeforeMT4", "sbValueAfterMDLeft", "sbValueBeforeND2", "sbValueBeforeIM1", "sbValueBeforeAMD2", "sbValueBeforeDD65", "sbValueBeforeOLD512", "sbValueAfterMDFive", "sbValueAfterMDson", "sbValueBeforeDD5", "sbValueAfterMD3", "sbValueBeforemd2", "sbValueBeforeIM2", "sbValueBeforeMS5", "sbValueBeforeMD4", "sbValueBeforeSMson", "sbValueBeforeMD1", "sbValueBeforeDS5", "sbValueWithoutMD2", "sbValueWithoutDD2", "sbValueBeforeOLD2", "sbValueAfterND4", "sbValueAfterND2", "sbValueBeforeAMD5", "sbValueBeforeDS2", "sbValueBeforeDD512", "sbValueBeforeMD3", "sbValueAfterMD1", "sbValueBeforeDS512", "sbValueBeforeIMLeft", "sbValueBeforeMT5", "sbValueWithoutDD512", "sbValueBeforemdFound", "sbValueBeforeSM4", "sbValueBeforeMP1", "sbValueBeforeMS1", "sbValueBeforeMDFive", "sbValueBeforeDD2", "sbValueBeforeMOD1", "sbValueAfterMDFound", "sbValueBeforeNDson", "sbValueBeforeMOD5", "sbValueBeforeDDFive", "sbValueBeforeLM512", "sbValueWithoutMD512", "sbValueBeforeND5", "sbValueBeforeMD2", "sbValueBeforeMP5", "sbValueBeforeMDFound", "sbValueBeforeMOD3", "sbValueBeforeMDson", "sbValueBeforeMOD2", "sbValueBeforeSM5", "sbValueBeforeMTson"], "time": ["tim", "counter", "t", "hour", "length", "ime", "total", "runtime", "top", "today", "timer", "value", "etime", "history", "now", "system", "id", "race", "rate", "name", "ts", "estamp", "client", "when", "date", "user", "set", "start", "timeout", "Time", "clock", "work", "current", "times", "age", "frame", "ty", "size", "year", "est", "duration", "TIME"], "rand": ["rot", "rt", "rev", "z", "sample", "gz", "rank", "mid", "gt", "rc", "pid", "range", "pick", "Rand", "nd", "rd", "ng", "rate", "id", "frac", "rad", "rh", "seed", "sid", "r", "sam", "std", "dist", "res", "did", "round", "uid", "init", "rss", "cr", "random", "dr", "rid", "nt", "inv", "hash", "quant", "reg", "gen", "red", "grad", "and", "serial", "roll"], "valueBeforeMD5": ["valueBeforeMOD7", "valueBeforeMOD5", "valueAfterMD3", "valueBeforeND5", "valueBeforeMOD3", "valueBeforeMT2", "valueBeforeMT3", "valueAfterND2", "valueBeforeMT5", "valueBeforeMOD2", "valueBeforeMC7", "valueAfterMD2", "valueAfterMD7", "valueBeforeND7", "valueAfterND3", "valueBeforeMD25", "valueAfterND5", "valueAfterND7", "valueBeforeMC3", "valueBeforeMC5", "valueBeforeMD3", "valueBeforeMC2", "valueBeforeND2", "valueBeforeMT25", "valueBeforeMD2", "valueBeforeMD7", "valueBeforeMC25", "valueBeforeND3"], "array": ["record", "av", "row", "storage", "binary", "sample", "audio", "expression", "archive", "our", "length", "collection", "arr", "object", "range", "a", "batch", "ray", "pair", "raw", "ash", "RAY", "sh", "list", "address", "buffer", "image", "map", "ary", "feature", "var", "number", " Array", "atomic", "angular", "rays", "arrow", "random", "Array", "app", "instance", "share", "area", "hash", "external", "data", "response", "attribute", "vector", "angle"], "sb": ["bh", "bg", "bt", "wb", "rob", "gc", "bs", "erb", "bf", "soc", "kb", "bps", "bb", "sh", "sq", "ib", "pb", "sw", "sf", "abb", "gb", "sth", "lp", "sv", "ub", "eb", "sg", "ssl", "SB", "zb", "rb", "si", "sa", "sr", "bp", "nb", "hs", "db", "ob", "cb", "xb", "lb", "bis", "bsp", "ctrl", "obs"], "j": ["ji", "m", "t", "z", "_", "jo", "us", "__", "it", "ct", "ind", "jack", "v", "kj", "jit", "obj", "k", "off", "J", "q", "str", "ja", "js", "g", "oj", "yy", "je", "ju", "uj", "att", "jj", "ij", "jp", "dj", "jl", "br", "index", "json", "i", "ix", "bot", "msg", "aj", "job", "key", "jc", "bj", "jump"], "b": ["bar", "bg", "u", "bt", "bs", "ab", "a", "bf", "be", "bb", "ib", "ba", "v", "B", "y", "fb", "bound", "beta", "k", "bd", "mb", "gb", "bi", "eb", "rb", "bp", "br", "db", "cb", "xb", "bis", "nb", "bc", "bu", "d"], "valueAfterMD5": ["valueAfterMD3", "valueAftermd5", "valueAftermd7", "valueAfterID2", "valueAftermd2", "valueAfterID7", "valueAfterID5", "valueAfterMD2", "valueAfterMD7", "valueAfterID3", "valueAftermd3", "valueBeforeMD3", "valueBeforeMD2", "valueBeforeMD7"]}}
{"id1": "949327", "id2": "13891080", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"f": ["ret", "info", "m", "fed", "ft", "t", "w", "fab", "fn", "df", "b", "j", "c", "fw", "fp", "F", "path", "o", "h", "base", "fm", "bf", "it", "e", "name", "fb", "v", "p", "y", "l", "rf", "r", "fo", "sf", "q", "n", "fs", "g", "fx", "cf", "test", "fc", "exp", "def", "lf", "fac", "fax", "fr", "elf", "form", "tf", "file", "fd", "fi", "filename", "fa", "dir", "d"], "in": ["gin", "make", "info", "m", "log", "re", "t", " IN", "im", "nin", " din", "thin", "lo", "oin", "o", "h", "get", "up", "cin", "it", "add", "pi", "on", "inf", "init", "inn", "ind", "er", "ins", "l", "rin", "io", "r", "reader", "inc", "ai", "al", "by", "n", "IN", "from", "iter", "local", "ex", "mm", "en", "inner", "bin", "isin", "all", "con", "input", "again", "din", "ma", "at", "ic", "is", "ac", "In"], "cbuf": ["rboff", "rbbuf", "bcuff", "cff", "cduf", "rbuffy", "cbuff", "bcbuf", "cdbuf", "bcuf", "CBuf", "abbuf", "nbfg", "sbbuf", "CBbuf", "CBuffy", "cbather", "CBbf", "bcather", "cbbuf", "CBuff", "cdoff", "bcoff", "rbather", "sbather", "cbf", "rbdf", "cfuff", "sbuf", "cduff", "nbuf", "rbfg", "nbuff", "cfuf", "cbuffy", "gbuf", "CBf", "nbbuf", "abbbuf", "cduffy", "rbuf", "cbdf", "bcfg", "abbfg", "cfbf", "gbf", "gbuff", "abbdf", "sbuff", "bcdf", "cbfg", "rbuff", "gbbf", "cboff", "cbbf"], "read": ["orig", "Read", "get", "ank", "se", "add", "ed", "log", "io", "x", "pre", "dev", " Read", "input", "saw", "index", "fail", "reading", "chain", "hello", "ink", "reads", "load", "row", "feed", "parse", "old", "end", "default", "it", "raw", "ind", "error", "ready", "report", "print", "r", "burst", "depth", "ai", "play", "q", "scan", "select", "find", "pack", "Reader", "ly", "seek", "query", "ke", "wait", "view", "clear", "key", "open", "roll", "record", "ret", "re", "link", "length", "rank", "give", "ok", "range", "think", "mix", "check", "rate", "buffer", "skip", "trust", "fill", "sync", "height", "bind", "n", "pe", "test", "iter", "ip", "slow", "current", "miss", "connect", "is", "text", "est", "send", "shift", "allow", "run", "close", "poll", "stream", "value", "mem", "count", "need", "READ", "k", "reader", "readable", "write", "ead", "set", "start", "core", "ignore", "reach", "ext", "data", "handle", "hold"], "totRead": [" totalBuild", "atotFill", "notWrite", "retotReader", "retottWrit", "taotCheck", "totConnect", "tootCheck", "retottPrint", "letotRead", "notalPrint", "tfatWrite", "totaPrint", "ltotLoad", "letotWrite", "notalLoad", "tcotCheck", "atotaHave", "tootDisplay", "tottRead", "atotaRead", "notPrint", "toteAdd", "ttotRead", "tobyNeed", "totalLoad", "retottRead", "totFill", "totWrite", "tootSend", "totRun", "atotaPrint", "taotConnect", "tfatLoad", "notaReader", "ptOTLoad", "taotDisplay", "totaAdd", "tottedReader", "totalLength", "tiatLoad", "ltotBuild", "totaNeed", "trotSee", "totaCheck", "tobyWrite", "totaFind", "totalCheck", "ttottAdd", "tottWrite", "tiatRead", "ttotNeed", "totaWrite", "ttottWrite", "toteRun", "tottPrint", "totSee", "toiotVal", "tfatRead", "tobyRead", "totaLoad", "ltotaRead", "toticRead", "letrotSee", "tiatVal", "toteWrite", "letotSee", "retottReader", "tottReader", "notaWrite", "tobyPrint", "tiatSend", "totaDisplay", "toteLoad", "tOTRead", "ptotRead", "totVal", " totWrite", "tiotVal", "ltotaBuild", "totFind", "totaConnect", "tacotDisplay", "notalRead", "ptotFind", "totBuild", "totalFind", "totalPrint", "totWrit", "tottAdd", "tootBreak", "notLoad", "tiotBreak", "tokWrite", "tottNeed", "tiotFill", "totalNeed", " toteRead", "tiotRead", "toteLength", "trotFind", "toiotRead", "ptOTWrite", "notaLoad", "retotPrint", "totalWrite", "tottRun", "notalWrite", "ptotLoad", "totaSee", "tcotSend", "trotRead", "letrotFind", "totDisplay", "totBreak", "tiotPrint", "retotWrit", "totaHave", " toteFind", "tiotReader", "notalCheck", " totFind", "tiotSend", " totLength", "notaRead", "letrotWrite", "tokFind", "ltotFill", "ltotRead", "toteFill", "retotRead", "toiotBreak", "ttotAdd", "totCheck", "totSend", "letotFind", "notalNeed", "totedRead", "tiatBreak", " totBuild", "totaFill", "toticRun", " totRun", "totNeed", "tOTWrite", "tiotWrit", "ptOTFind", "totAdd", "atotaFill", "tootVal", "totPrint", "toteNeed", "ltotaLoad", "tootConnect", "tacotConnect", "atotPrint", "tcotBreak", "tOTLoad", "tOTNeed", "notRead", "totalRead", "atotRead", "totReader", "tokLoad", " totalLength", "tOTFind", "tottFind", "tacotRead", "taotRead", "atotHave", "tottWrit", "toticWrite", "notCheck", "tobyCheck", "notNeed", "tfatReader", "tcotRead", "tcotDisplay", "toteFind", "tobyLoad", "tokRead", "toteRead", "totalBuild", "ttotWrite", "totLoad", "toiotSend", "totalSee", "totHave", "tacotCheck", "tottedWrit", "totaRead", "tottedPrint", " totalRead", "toteReader", " toteWrite", "ttottNeed", "totedHave", "totaReader", "tootRead", "totLength", "toteBuild", "tcotVal", " toteRun", "totaLength", "totedFill", "tottedRead", "toticFind", "totaBuild", "tcotConnect", "ltotaFill", "totedPrint", "ptotWrite", "tiatFill", "tiotHave", "ptOTRead", "ttottRead", "tiatBuild", "trotWrite", "letrotRead", "notReader", " totalWrite"], "out": ["os", "t", "w", "b", "c", "end", "ch", "o", "up", "aos", "or", "v", "writer", "obj", "s", "to", "outs", "log", "io", "r", "write", "n", "g", "res", "output", "ex", "Out", "con", "conv", "ou", "oss", "at", "sys", "OU", "auto", "OUT", "co", "we", "net"], "i": ["info", "ico", "m", "t", "b", "c", "I", "us", "oi", "e", "y", "io", "x", "me", "init", "ie", "index", "ia", "j", "gi", "o", "pi", "it", "ice", "di", "ind", "zi", "client", "to", "print", "r", "ai", "um", "q", "\u0438", "bi", "you", "mm", "PI", "li", "status", "iii", "im", "phi", "ii", "qi", "ion", "my", "ti", "integer", "ini", "ski", "php", "hi", " I", "v", "this", "multi", "iy", "uri", "iu", "ip", "cli", "dr", "ij", "ki", "xi", "is", "ei", "ji", "iq", "ci", "mi", "ui", "id", "p", "s", "ic", "l", "g", "set", "si", "ri", "point", "sim", "ix", "ami", "ims", "chain", "ity", "any"]}}
{"id1": "1443205", "id2": "15737836", "code1": "    private void redirect(TargetApp app, HttpServletRequest request, HttpServletResponse response) throws IOException {\n        URL url = new URL(app.getUrl() + request.getRequestURI());\n        s_log.debug(\"Redirecting to \" + url);\n        URLConnection urlConnection = url.openConnection();\n        Map<String, List<String>> fields = urlConnection.getHeaderFields();\n        for (String key : fields.keySet()) {\n            StringBuffer values = new StringBuffer();\n            boolean comma = false;\n            for (String value : fields.get(key)) {\n                if (comma) {\n                    values.append(\", \");\n                }\n                values.append(value);\n                comma = true;\n            }\n            if (key != null) {\n                response.setHeader(key, values.toString());\n            } else {\n                response.setStatus(Integer.parseInt(values.toString().split(\" \")[1]));\n            }\n        }\n        InputStream in = urlConnection.getInputStream();\n        try {\n            ServletOutputStream out = response.getOutputStream();\n            byte[] buff = new byte[1024];\n            int len;\n            while ((len = in.read(buff)) != -1) {\n                out.write(buff, 0, len);\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"redirect": ["redir", "Redirection", " redir", "Redirect", "adir", "Redurl", "redirection", "adirection", " redirection", "adurl", "redurl", "Redir", "adirect", " redurl"], "app": ["process", "project", "m", "os", "http", "cms", "b", "pp", "pkg", "base", "up", "be", "bb", "App", "APP", "port", "map", "framework", "Application", "service", "conn", "atom", "org", "apply", "application", "g", "exp", "ip", "comm", "server", "com", "comp", "access", "web", "db", "abs", "apps", "ac", "display", "ca", "ap", "browser"], "request": ["process", "project", "re", "each", "setup", "get", "reference", "raw", "quest", "now", "address", "question", "change", "message", "context", "reset", "req", "report", "event", "application", "create", "input", "current", "position", "query", "first", "trip", "task", "frame", "form", "initial", "view", "Request", "hello", "command", "complete", "attribute", "accept"], "response": ["send", "http", "exit", "resp", "document", "fire", "onse", "soc", "success", "version", "block", "release", "socket", "sp", "message", "connection", "image", "sequence", "context", "report", "print", "reset", "content", "write", "service", "respond", "window", "application", "res", "respons", "output", "tree", "page", "reply", "position", "server", "network", "Response", "continue", "index", "next", "json", "relation", "ren", "frame", "description", "model", "view", "format", "display", "we", "status", "result"], "url": ["ret", "pl", "re", "bel", "ur", "http", "hl", "email", "link", "https", "path", "ref", "ls", "get", "base", "gl", "util", "build", "address", "name", "uri", "l", "f", "sl", "r", "nl", "service", "str", "org", "mount", "rel", "www", "ssl", "Url", "web", "mail", "ob", "ul", "abs", "el", "xml", "dl", "ll", "acl", "cert", "URL"], "urlConnection": ["urlConnect", " urlConnect", " urlconnection", "urlClient", "httpconnection", "httpOpen", "UrlPosition", "httpClient", "sslconnection", "UrlConnect", " urlPosition", "sslClient", "UrlConnection", "urlconnection", "Urlconnection", "urlPosition", "httpConnect", "UrlClient", " urlOpen", "httpConnection", "UrlOpen", "sslConnect", "sslConnection", "urlOpen", "httpPosition"], "fields": ["faces", "ms", "details", "words", "forms", "services", "pages", "rows", "balls", "ls", "sections", "files", "relations", "packs", "users", "views", "workers", "heads", "checks", "uploads", "lines", "members", "flags", "fs", "vers", "sets", "rules", "loads", "hips", "groups", "headers", "dates", "keys", "holders", "types", "ports", "phones", "masters", "drivers", "keepers", "levels", "terms", "orders", "changes", "names", "gets", "lights", "atts", "tags", "lists", "boxes"], "key": ["info", "what", "row", "item", "null", "column", "phrase", "variable", "pkg", "val", "rule", "option", "default", "property", "prefix", "base", "part", "parent", "id", "name", "y", "kid", "primary", "owner", "er", "k", "by", "attribute", "var", "source", "code", "date", "sign", "set", "step", "tip", "title", "keys", "pattern", "string", "token", "word", "KEY", "char", "kind", "index", "json", "ke", "tag", "important", "hash", "description", "Key", "type", "entry", "field", "label", "chain", "et", "major"], "values": ["cells", "lists", "actions", "versions", "services", "vs", "forms", "rows", "ups", "videos", "results", "files", "lets", "states", "settings", "errors", "uts", "users", "pins", "items", "checks", "places", "blocks", "lines", "flags", "members", "sets", "als", "csv", "boxes", "objects", "vals", "keys", "ports", "phones", "drivers", "units", "marks", "ends", "terms", "times", "changes", "Values", "bytes", "gets", "strings", "beans", "options", "tags", "maps", "obs"], "value": ["null", "other", "sample", "variable", "val", "object", "default", "property", "VALUE", "pair", "version", "block", "vector", "python", "name", "cell", "message", "v", "sequence", "unit", "password", "element", "feature", "example", "node", "test", "widget", "create", "language", "string", "state", "style", "database", "Value", "point", "json", "zone", "description", "data", "hello", "entry", "field", "label", "ue", "attribute"], "comma": ["COMpa", "cma", "compma", "qualma", "compota", "comenta", "cumenta", "commonota", "centa", "schepa", "commonmission", "commission", "comda", "scheenta", "qualenta", "COMma", "cpa", "compenta", "schema", "comota", "scheMA", "compda", "cMA", "compa", "comMA", "commonenta", "calda", "calma", "cumma", "commonma", "compmission", "qualota", "COMMA", "combo", "calenta", "compbo", "cumbo", "qualmission", "calbo", "cumda", "COMenta"], "in": ["info", "t", "read", "old", "o", "get", "up", "stream", "cin", "it", "on", "pi", "ini", "inf", "inn", "ind", "ain", "ins", "ic", "f", "io", "r", "reader", "inc", "ai", "al", "conn", "n", "IN", "from", "iter", "init", "en", "inner", "isin", "con", "input", "din", "body", "i", "inside", "form", "file", "is", "In"], "out": ["cn", "os", "t", "w", "b", "end", "o", "aos", "on", "e", "v", "writer", "to", "outs", "print", "flush", "io", "r", "write", "n", "res", "output", "Out", "en", "inner", "con", "nt", "outer", "ou", "inv", "i", "oss", "at", "sys", "OU", "external", "OUT", "co", "ne", "we", "net"], "buff": ["hex", "bg", " buf", "b", "bs", "grow", "batch", "bf", "nd", "mem", "bb", "ind", "ff", "fb", "buffer", "bo", "uf", "pb", "bound", "cod", "tab", "Buff", "seq", "buf", "cmd", "bl", "txt", "dat", "qq", "xx", "oct", "ck", "lf", "printf", "ext", "tmp", "bed", "fac", "comp", "fr", "ob", "hd", "uff", "box", "cb", "butt", "stack", "obs"], "len": ["lif", "pl", "full", "cmp", "t", "err", "z", "Len", "pos", "length", "ld", "cap", "val", "end", "coll", "ls", "gl", "lim", "mem", "count", "ind", "vec", "lon", "l", "cod", "cl", "str", "n", "js", "seq", "buf", "ln", "bl", "exp", "en", "all", "lib", "lf", "nt", "num", "fun", "el", "lan", "vol", "ll", "dl", "ell", "fin", "elt", "del"]}}
{"id1": "13233761", "id2": "6371589", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"executeUpdateTransaction": ["executeQueryTask", "startUpdateTx", "executeInsertStatement", "startQueryStatement", "executeWriteTx", "executeInsertTx", "executeWriteTransaction", "startQueryTask", "executeUpdateTx", "executeQueryStatement", "executeUpdateStatement", "startQueryTx", "startUpdateTask", "executeQueryTransaction", "executeWriteTask", "executeUpdateTask", "executeInsertTransaction", "startUpdateStatement", "startQueryTransaction", "executeQueryTx", "executeInsertTask", "executeWriteStatement", "startUpdateTransaction"], "queries": ["Quarks", " Queries", "quands", "aquenges", "aquiries", "qualiries", "aquands", "qualenges", "Queries", "gallands", "gallenges", " Quarks", "Quands", "queeries", "quues", "aqueries", "quarks", " Quands", "quearks", "queands", "quenges", "galliries", "qualeries", "qualands", "queues", "Quues", " Quues", "galleries", "quiries"], "autoCommit": ["autoDebist", "automaticCompit", "autoCommits", "autoCommmit", "autoDebit", "AutoCommit", "AutoCommits", "autoAmits", "automaticCompate", "autoAmmit", "autoClmit", "autoAmit", "autoCompcommit", "autoAbsist", "autoCompate", "AutoCommmit", "autoCommist", "autoDebcommit", "autoAbscommit", "autoBeport", "autoAbsate", "autoCompist", "autoCommcommit", "AutoCommport", "autoCompit", "autoClits", "autoBeit", "autoClit", "automaticCompcommit", "autoCommate", "autoBemit", "autoBeits", "automaticCommist", "automaticCommate", "autoCommport", "autoAmport", "autoClport", "automaticCommit", "AutoClport", "automaticCompist", "AutoClits", "autoAbsit", "AutoClmit", "autoDebate", "automaticCommcommit", "AutoClit"], "iterator": ["udder", "processor", "starter", "storage", "encer", "creator", "taker", "sample", "zero", "upper", "pie", "ner", "rows", "Iterator", "information", "started", "stream", "integer", "issues", "ski", "list", "seconds", "values", "sequence", "writer", "menu", "runner", "finder", "directory", "reader", "gener", "folder", "number", "members", "video", "pee", "iter", "set", "former", "pour", "inner", "page", "pler", "operator", "internet", "current", "instance", "continue", "rounder", "outer", "next", "river", "walker", "trace", "ter", "giving", "loop", "interstitial", "size", "loader", "bis", "immigrant", "ator", "liner", "series", "oser", "vector", "collection"], "query": ["join", "sql", "row", "parse", "update", "table", "prefix", "condition", "version", "quest", "check", "sq", "quote", "name", "question", "message", "sequence", "resource", "menu", "password", "request", "q", "term", "code", "test", "Query", "string", "title", "task", "comment", "description", "script", "subject", "execute", "lock", "command", "escape", "family", "key", "qu", "series", "result"], "statement": ["sql", "usage", "slot", "phrase", "parse", "binary", "expression", "table", "fire", "rule", "batch", "line", "condition", "block", "minute", "ment", "quote", "system", "message", "connection", "sequence", "resource", "mt", "group", "print", "call", "confirmed", "set", "state", "template", "word", "continue", "Statement", "session", "task", "comment", "description", "execute", "status", "command", "shell"]}}
{"id1": "16388708", "id2": "2834524", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsfile", "decodeFileToString", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFileFileFile", "decodeStringToString", "decodeStringToFiles", "decodeString2file", "decodeFileTofile", "decodeFile2String", "decodeStringToFile", "decodeString2String", "decodeString2File", "decodeFileFileFiles", "decodeFileAsFiles", "decodeFile2File", "decodeFile2Files", "decodeString2Files", "decodeFileFileString", "decodeFileToFiles", "decodeFile2file", "decodeFileAsString"], "infile": ["isinfolder", "isinfile", "inputname", "Inbase", "outFile", "outfolder", "InFile", "outfilename", "inname", "isinname", "fromFile", "outname", "Infile", "infolder", "frombase", "inFile", "inputFile", "inbase", "fromfilename", "infilename", "inputfile", "isinFile", "fromfile", "Infilename", "inputfolder", "outbase"], "outfile": [" outname", "inFILE", "Outfilename", "Outfile", "outFile", "otname", "outfilename", "otfile", "inname", " outFile", "outname", "todir", "outdir", "otFILE", "tofilename", "inFile", "outFILE", "indir", "tofile", "Outdir", "infilename", "toFile", "OutFile", " outFILE", "otFile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "variable", "total", "document", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "attribute", "cache", "number", "temp", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "shape", "append"], "read": ["before", "each", "text", "send", "shift", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", " succeed", "ok", "submit", "ratulations", " succ", "condition", "scope", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "summary", "primary", "commit", "positive", "surv", "crit", "same", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", "unity", "please", " successes", "first", "support", "city", "exist", " successful", "ceed", "fail", "response", "successfully", "status", "result", " okay", "accept"]}}
{"id1": "8973505", "id2": "11341711", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["writefileType", "writeContentInfo", "writePageType", "writeFileName", "writeContentName", "readFileInfo", "writePagetype", "readfileName", "writeContentType", "readFiletype", "writefileName", "readFileName", "writeFileInfo", "writeFiletype", "writeContenttype", "writePageName", "writefiletype", "readfiletype", "writefileInfo", "readFileType", "readfileInfo", "writePageInfo", "readfileType"], "uriFile": ["uriFilename", "URIData", "rangeFILE", "filenameFilename", "URIFile", "uriFiles", "rangefile", "fileFiles", "filenameFile", "uriData", "filenamefile", "iriData", "URIFiles", "rangeData", "filefile", "URIfile", "URIFILE", "uriFILE", "iriFile", "filenameFiles", "fileFile", "fileFilename", "rangeFile", "irifile", "URIFilename", "iriFILE", "urifile"], "outputfile": ["imagefile", "imageport", "outf", " outputFile", "outFile", "inputFILE", " outputf", "outputport", "outfile", "imageFile", "outputFile", "inputFile", "Outputport", "inputbase", "OutputFile", "inputf", "imageFILE", " outputbase", "outputFILE", "Outputfile", "inputfile", "outputf", "outputbase", "inputport", "OutputFILE", "outbase"], "num": ["m", "cmp", "done", "total", "end", "alph", "zero", "Number", "add", "nm", "count", "required", "mult", "check", "multi", "NUM", "mon", "um", "number", "x", "n", "np", "Num", "no", "random", "all", "con", "current", "index", "nom", "nam", "max", "nb"], "writer": ["w", "handler", "worker", "flush", "operator", "author", "commit", "editor", "processor", "linger", "table", "wright", "timer", "liner", "client", "runner", "er", "to", "service", "term", "console", "utils", "Reader", "caster", "writers", "writ", "Writer", "record", "memory", "creator", "read", "link", "variable", "document", "driver", "width", "iterator", "connection", "buffer", "usher", "RW", "function", "test", "will", "server", "wire", "external", "file", "format", "ender", "ener", "storage", "written", "journal", "ner", "stream", "maker", "resource", "riter", "owner", "wrapper", "writing", "write", "window", "builder", "widget", "thus", "inner", "network", "player", "manager", "comment", "data", "layer", "entry", "loader", "event", "director"], "uri": ["details", "umi", "http", "href", " URI", "wiki", "address", "obo", "basic", "user", "hyper", "subject", "channel", "qu", "filename", "sofar", "domain", "pi", "unit", "uu", "verb", "queue", "source", "iri", "uid", "location", "query", "form", "uni", "ugi", "ir", "result", "link", "phi", "qi", "ref", "range", "iterator", "hi", "connection", "directory", "multi", "folder", "bid", "ip", "rid", "doi", "i", "file", "remote", "ei", "ur", "phrase", "URI", "https", "mi", "du", "username", "reference", "prefix", "general", "ui", "id", "image", "resource", "ource", "ni", "copy", "origin", "inner", "ri", "via", "description", "uno", "chain", "browser"], "counter": ["editor", "memory", "processor", "creator", "nr", "phrase", "cms", "cookie", "ier", "total", "amount", "coll", "currency", "key", "TER", "ounter", "timer", "scope", "count", "common", "cover", "system", "iterator", "message", "context", "sequence", "buffer", "mill", "finder", "frequency", "pointer", "number", "Counter", "card", "loader", "term", "controller", "order", "ctr", "mer", "clock", "random", "inner", "container", "another", "money", "continue", "instance", "meter", "index", "outer", "conv", "walker", "manager", "ter", "norm", "loop", "entry", "machine", "const", "time", "book", "mr", "browser"], "reader": ["editor", "yer", "row", "processor", "older", "read", "handler", "document", "rar", "journal", "ner", "upper", "driver", "timer", "roller", "iterator", "address", "buffer", "context", "resource", "er", "runner", "r", "redo", "rl", "method", "ro", "iter", "Reader", "rx", "inner", "input", "server", "player", "file", "layer", "parser", "entry", "loader", "liner", "dd", "builder"], "url": ["re", "bel", "ur", "http", "hl", "link", "https", "il", "github", "ref", "get", "base", "gl", "build", "address", "name", "client", "resource", "l", "sl", "r", "nl", "str", "rel", "mount", "www", "google", "location", "ssl", "char", "li", "Url", "mail", "web", "loc", "ll", "dl", "open", "URL", "browser"], "myConnection": [" myConnector", "newLink", "thisConnection", "myConn", " myconnection", "thisConn", "myConnector", "myconnection", "Myconnection", "MyLink", "yourConnection", "thisConnect", "MyConnector", " myConn", "newConnection", "MyConnection", "newConnect", "yourConnector", " myLink", "myConnect", "yourLink", "thisLink", "yourconnection", "myLink", " myConnect", "newConn"], "myReader": ["MyParser", " myWriter", "yReader", "MyRead", "yourWriter", " myParser", " myRead", "MyWriter", " myFr", "myParser", "yFr", "mxReader", " mySer", "yourReader", "yWriter", "mySer", "myWriter", "yourParser", "mxWriter", "yourRead", "myFr", "ySer", "mxFr", "myRead", "mxSer", "MyReader"], "line": ["LINE", "row", "detail", "email", "link", "sample", "lo", "ode", "ge", "rule", "eline", "range", "definition", "inline", " Line", "raw", "block", "side", "ole", "part", "cell", "message", "Line", "sequence", "normal", "l", "log", "one", "code", " LINE", "ln", "no", "user", "stroke", "iter", "ip", "cli", "lin", "page", "style", "word", "char", "body", "edge", "point", "le", "trace", "frame", "comment", "online", "lane", "channel", "entry", "ine", "label", "text", "liner"], "linecount": [" lineamount", "LineCount", "linercount", "strokeamount", " lineconst", "Lineconfig", "elineconst", "lineconfig", " lineconfig", "linefound", "linerCount", " lineconsider", "Linefound", "linenumber", "linelength", "inlinelength", "linconsider", "strokenumber", "linerfound", " linecounter", "lineamount", " lineCount", "linecounter", "elinecount", "inlinecount", "lineconsider", "elinelength", "inlineconst", "strokecount", "strokeconsider", " linelength", "elinecounter", "lineconst", "lineCount", "linnumber", " linenumber", "linamount", "linerconfig", "Linecount", "inlinecounter", " linefound", "lincount"], "hasOWL": ["hasRONL", "hasOWSL", "hasEWS", "hasOWNR", " hasOWSL", "hasROLP", "hasOWLS", "hasSOL", " hasOWLP", " hasOWSNL", " hasEWR", "hasROR", "hasOWNLP", "HasOWB", "HasOWS", " hasOWLS", "hasROL", " hasOWR", "hasOWR", "hasOHS", "HasOWL", "hasOWLP", "hasSOLS", "hasOWNNL", "hasOWSLP", " hasOWSR", "hasOWSB", "HasOWSL", "hasEWLP", "hasOWSS", " hasOWSLP", "hasEWR", "HasOWSS", "hasOWS", "hasOWSR", "hasOWSLS", "hasSOLP", " hasEWLP", " hasEWL", "hasOHB", "HasOWSLP", "hasEWLS", "HasOWLP", "hasOWB", " hasEWLS", "hasEWL", "hasSOR", "hasOHL", "hasEWB", " hasOWNL", "hasOHLP", "HasOWSB", "hasOWNL", "hasOWSNL"], "hasRDFS": ["hasSRDFCS", "hasRdfM", "hasRNFM", "hasORDSDS", "hasRdfs", "hasRDFB", "hasRdfB", "hasRNFS", "hasSRDSs", "hasRDFCS", "hasRDSCS", "hasRRIs", "hasRRICS", "hasSRDFs", "hasRNFDS", "hasRMLM", "hasRdfS", "hasXDFS", "hasRDFDS", "hasRMLDS", "hasRDSS", "hasXDFDS", "hasRDSDS", "hasSRDSS", "hasORDSs", "hasXDFs", "hasXDFM", "hasRRIB", "hasORDSS", "hasSRDSB", "hasRMLS", "hasXDSM", "hasRRIS", "hasRDFs", "hasORDFDS", "hasRMLs", "hasORDFS", "hasRDSB", "hasRdfCS", "hasXDSS", "hasXDSDS", "hasORDFM", "hasRdfDS", "hasRDFM", "hasSRDFS", "hasXDSs", "hasSRDSCS", "hasRDSs", "hasORDFs", "hasSRDFB", "hasORDSM", "hasRNFs", "hasRDSM"], "hasRDF": ["hasRCDF", "hsRDT", "hasRRDS", "hasRDS", "hasRRCD", " hasRNF", " hasRdf", "hasDCD", "hasRCCD", "hasRTDF", "hsRRDI", "hasRADI", " hasRDR", " hasDDF", "hasREDI", "hasRTDR", "hasRTDS", " hasRCD", "hasRNF", "hasDdf", " hasDdf", "hasREDS", "hasORNF", "hasREDF", " hasRDS", "hsRRDT", "hasRCNF", "hasRCdf", "hasRTNF", "hasRRNF", "hasRRDR", " hasDCD", "hasORDS", "hasRDI", "hasRRDF", "hsRRDF", "hasRRdf", "hasRADS", "hasREDT", "hasRDT", "hasRADT", " hasRRNF", "hasRRDT", "hasRRDI", " hasDNF", "hasDNF", "hasRCD", "hasRdf", "hsRDS", "hasRADF", "hsRRDS", "hsRDF", "hasORDR", "hsRDI", " hasRRDF", " hasRRDS", " hasRRDR", "hasRDR", "hasDDF", "hasORDF"]}}
{"id1": "7458833", "id2": "18748516", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFiletoCodeFile", " copyParseFiletoCodeTable", " copyParseFileToGofile", " copyParseFileToInfoFile", " copyParseFileToInfofile", " copyParseFileTocodefile", " copyParseFileToGoFiles", " copyParseFiletocodeTable", " copyParseFiletocodefile", " copyParseFileToCodefile", " copyParseFiletocodeFile", " copyParseFileToInfoTable", " copyParseFiletoCodeFiles", " copyParseFileTocodeTable", " copyParseFileTocodeFile", " copyParseFiletocodeFiles", " copyParseFileToGoTable", " copyParseFileToCodeTable", " copyParseFileToGoFile", " copyParseFileToCodeFiles", " copyParseFileTocodeFiles", " copyParseFiletoCodefile", " copyParseFileToInfoFiles"], "in": ["gin", "info", "ad", "im", "read", "up", "cin", "it", "on", "check", "inf", "ini", "inn", "ind", "ze", "ain", "ins", "ic", "rin", "io", "ai", "inc", "al", "iter", "from", "IN", "act", "init", "mm", "en", "isin", "inner", "bin", "con", "input", "din", "inside", "i", "is", "ar", "ir", "In"], "out": ["os", "cn", "null", "t", "ot", "o", "up", "aos", "it", "on", "check", "client", "v", "writer", "can", "obj", "to", "outs", "io", "by", "write", "one", "dis", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "and", "nt", "conv", "outer", "ou", "oss", "i", "at", "sys", "auto", "OUT", "co", "ne", "cos", "net"], "buffer": ["bar", "memory", "paste", "row", "phrase", "binary", "buff", "table", "sample", "variable", "document", "component", "batch", "character", "pad", "block", "reason", "Buffer", "history", "cell", "message", "sequence", "resource", "print", "queue", "cache", "temp", "window", "buf", "iter", "template", "result", "word", "char", "bridge", "database", "frame", "comment", "initial", "view", "button", "display", "bone", "command", "stack", "attribute", "append"], "length": ["enth", "full", "join", "bow", "t", "stop", "total", "capacity", "how", "ENGTH", "component", "collection", "amount", "integer", "count", "available", "history", "binding", "message", "sequence", "maximum", "frequency", "l", "print", "number", "padding", "height", "availability", "impl", "start", "distance", "deep", "ength", "position", "present", "Length", "lambda", "database", "point", "frame", "closure", "data", "reading", "size", "hello", "len", "duration", "volume", "family", "load", "shape", "angle"]}}
{"id1": "18370075", "id2": "4458076", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public InputStream getInputStream() throws TGBrowserException {\n        try {\n            if (!this.isFolder()) {\n                URL url = new URL(this.url);\n                InputStream stream = url.openStream();\n                return stream;\n            }\n        } catch (Throwable throwable) {\n            throw new TGBrowserException(throwable);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"createPasswordDigest": ["createPasswordDester", "createPasswordDigests", "createPasswordDigum", "createPasswordDest", "createPasswordDigester", "createPassworddigest", "createPassworddigester", "createPassworddigum", "createPasswordDum", "createPassworddigests", "createPasswordDests"], "password": ["pass", "secret", "words", "email", "phrase", "Password", "username", "value", "address", "name", "message", "sword", "login", "reset", "padding", "user", "auth", "string", "pattern", "token", "word", "present", "database", "session", "hash", "description", "data", "response", "hello", "entry", "key", "wd", "command", "shadow", "attribute"], "salt": ["sesave", "paint", " sig", "tol", "taint", "Saint", "sesalt", "sesALT", " sALT", "palt", "sALT", "Save", "pALT", "Salt", "talt", "sol", "save", "Sig", "Sol", "sesig", " save", "SALT", "pol", "sig", "tALT", "saint"], "md": ["mod", "m", "ms", "ad", "det", "pd", "df", "ld", "amd", "mode", "mk", "mc", "pm", "add", "nd", "desc", "MD", "di", "ct", "ind", "rm", "cd", "mn", "mt", "od", "bd", "sam", "mb", "sm", "mg", "sd", "js", "strong", "cmd", "dm", "mm", "metadata", "dr", "td", "def", "pdf", "der", "nt", "hd", "red", "mand", "mp", "and", "dd", "d"], "digest": ["degested", " digidate", "signum", " digum", "designester", "degesting", "designest", "degest", "digute", " digist", "mdEST", "digested", "Digidate", "designesting", " digute", "mdest", "mdesting", "mdist", "digester", "signidate", "degester", "digesting", "digum", "digidate", "DigEST", "signest", "designested", "Digum", "Digist", "Digute", " digEST", "digist", "mdester", "signute", "Digest", "digEST", "mdested", "mdum"]}}
{"id1": "11716816", "id2": "2642914", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"updateFile": ["UpdateSourceFile", "updatePage", "UpdateContent", "downloadFile", "downloadContent", "updateContent", "downloadPage", "archiveContent", "UpdatePage", "archiveSourceFile", "updateSourceFile", "downloadSourceFile", "archiveFile", "archivePage", "UpdateFile"], "file": ["info", "full", "File", "t", "null", "ile", "FILE", "link", "table", "document", "fp", "rule", "path", "h", "url", "get", "base", "line", "e", "use", "name", "message", "issue", "image", "resource", "port", "p", "log", "report", "f", "io", "content", "source", "output", "local", "page", "title", "input", "le", "db", "data", "channel", "format", "entry", "type", "filename", "handle", "attribute"], "IOException": ["IOProblem", "OperationError", " IOError", " IOProblem", "OperationException", "SecurityException", "IOError", "OperationProblem", "SecurityError", "SecurityProblem"], "destFile": ["targetPath", "targetDir", "sourceFolder", "optFolder", "Destfile", "optPlace", "destPage", "sourceFile", "destDir", "DestFile", "declSourceFile", "destfile", " destinationDir", "destEmail", "tempPath", "sourceDir", " destEmail", "optFile", "optPage", "targetFolder", "tempDir", "declile", " DestFile", " destPage", "destile", "DestPath", " destPath", " destinationEmail", "Destile", " destinationFile", "tempfile", " destDir", "tempFile", " destfile", " destFolder", " destDo", "DestPage", " DestDo", "sourcePath", "destFolder", " destPlace", "declFile", "DestFolder", " DestDir", " destSourceFile", "destPath", "DestPlace", "destSourceFile", " DestEmail", "DestDir", "destPlace", "targetFile", "declFolder", "DestSourceFile", " destinationDo", " destile", "destDo"], "in": ["gin", "pass", "info", "m", "re", "im", "read", " IN", "local", " din", "oin", "mi", "up", "cin", "it", "on", "raw", "ini", "inf", "inn", "ind", "ain", "ins", "s", "ic", "rin", "f", "io", "r", "l", "ai", "inc", "al", "n", "ln", "IN", "mm", "from", "iter", "init", "act", "en", "bin", "isin", "inner", "ie", "all", "con", "input", "edIn", "sin", "din", "i", "inside", "is", "ne", "In", "net"], "out": ["cn", "os", "null", "t", "note", "fn", "b", "gt", "ion", "ot", "ch", "o", "up", "aos", "it", "or", "oe", "client", "v", "obj", "s", "to", "outs", "can", "log", "io", "flush", "write", "conn", "cache", "one", "n", "g", "no", "cmd", "output", "ex", " OUT", "Out", "en", "con", "jp", "again", "nt", "conv", "outer", "ou", "oss", "at", "sys", "OU", "msg", "OUT", "co", "channel", "chain", "ne", "cos", "result", "net"]}}
{"id1": "13657527", "id2": "19134229", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getDatasetsList": ["getDatisetsResult", "getDatisetStatus", "getDatasetStatus", "getDatasesStatus", "getDatasetsResult", "getDatisetsList", "getDatasesList", "getDatisetList", "getDatasuresResult", "getDatisetsStatus", "getDatasuresStatus", "getDatasetResult", "getDatasetList", "getDatasetsStatus", "getDatasesResult", "getDatasuresList", "getDatisetResult"], "surl": ["lsurl", "lsuri", "slim", "sURL", "jsUrl", "esUrl", "stsurl", "sUrl", "sysserver", "lsUrl", "lsmail", "esurl", "suri", "ssuri", "slt", "esURL", "lslt", "jslim", "esuri", "sserver", " suri", "jsuri", " sUrl", " sname", "jsurl", "sslim", "sysuri", "sysurl", "ssURL", "syslt", "ssUrl", "ssurl", "esname", "lsserver", "stsuri", "sname", "smail", " smail", "stsserver", "stslt"], "datasetsList": ["datassetslist", "datasamesSet", "datasagesSet", "datmassetsList", "datasureslist", "datasuresMap", "datasetSet", "datasagesData", "datasetslist", "datisetsGroup", "datisetsMap", "datasETSList", "datassetsLock", "datasenslist", "datassetsMap", "datasameslist", "datisetName", "datasamesMap", "datasourcesTable", "datasagesTable", "datmasetsLock", "datassetsTable", "datisetsList", "datasETSGroup", "datisetsName", "datasetsMap", "datmasetsMap", "datarsetsMap", "datarsetlist", "datarsetsList", "datmasetsData", "datarssetsList", "datarsetsLock", "datarssetsSet", "datarsetsSet", "datasetMap", "datarssetsLock", "dataselinesGroup", "datarssetsTable", "datasourcesList", "dataselinesList", "datasensMap", "datasagesMap", "datasetsSet", "datmassetsLock", "datasamesList", "datmassetsData", "datasetsName", "dataselinesMap", "datasetlist", "datasETSMap", "datasetGroup", "datasourcesSet", "datasagesList", "datarsetsTable", "datasuresList", "datmasetsList", "datasetsLock", "datmassetsMap", "datisetList", "datarsetList", "dataselinesName", "datasetsData", "datassetsList", "datisetMap", "datasETSName", "datarsetslist", "datasetsGroup", "datasourcesLock", "datasetName", "datasuresSet", "datisetGroup", "datasagesLock", "datasetData", "datarsetMap", "datasetsTable", "datassetsSet", "datasetLock", "datarsetSet", "datassetsData", "datasensList", "datasetList"], "result": ["record", "ret", "answer", "details", "successful", "detail", "table", "diff", "default", "success", "results", "found", "valid", "there", "message", "buffer", "sequence", "menu", "report", "folder", "cert", "res", "test", "set", "complete", "search", "def", "relation", "first", "exist", "Result", "comment", "form", "description", "chain", "response", "contact", "successfully", "status"], "reader": ["row", "older", "per", "read", "handler", "rar", "ner", "upper", "range", "driver", "stream", "mr", "timer", "rd", "roller", "ser", "rer", "socket", "peer", "iterator", "READ", "client", "buffer", "writer", "resource", "er", "runner", "bo", "wrapper", "r", "redo", "rl", "test", "ro", "iter", "Reader", "dr", "inner", "operator", "body", "river", "query", "via", "reading", "file", "layer", "parser", "field", "loader", "author", "handle", "liner", "rr"], "url": ["lr", "ur", "row", "null", "http", "link", "il", "ls", "key", "stream", "address", "id", "client", "resource", "l", "uri", "sl", "r", "nl", "rl", "str", "org", "mount", "user", "location", "ssl", "char", "Url", "web", "mail", "ul", "file", "dl", "ll", "loader", "URL", "browser"], "s": ["full", "ms", "os", "less", "sql", "t", "sample", "b", "bs", "us", "h", "ws", "ls", "ss", "has", "tes", "its", "es", "sq", "ns", "sym", "ts", "y", "series", "cs", "v", "ins", "l", "r", "sw", "gs", "str", "source", "js", "n", "sv", "ids", "ats", "S", "still", "rs", "csv", "sb", "sts", "string", "ds", "hs", "i", "abs", "as", "gets", "strings", "is", "qs", "ps"], "list": ["pretty", "join", "full", "detail", "note", "table", "cont", "ls", "batch", "top", "add", "block", "part", "ml", "php", "sequence", "group", "log", "l", "print", "layout", "member", "test", "left", "ist", "local", "set", "st", "single", "L", "all", "def", "word", "li", "pool", "form", "LIST", "array", "ll", "dl", "format", "listed", "chain", "stack", "lists", "collection"]}}
{"id1": "16798376", "id2": "8430178", "code1": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"run": ["process", "go", "exec", "stop", "submit", "block", "runs", "runner", "call", "service", "invoke", " Run", "apply", "Run", "test", "cmd", "profile", "start", "work", "launch", "show", "task", "execute", "hello", "handle", "command"], "ftp": ["gitping", " fttp", "fth", "wtcp", " ftjp", "ftt", " ftping", "afttp", "ftxp", "ftop", "iftjp", "aft", "ctcp", "ctl", " ftop", "aftl", " ftxp", "fttp", " ftcp", "iftz", "iftr", "ftjp", "iftphp", "aftc", "ftr", "ftc", "ctp", "wth", "iftop", "aftxp", "ffcp", "aff", "wtping", "aftf", "gitt", "afl", "ftphp", "afping", " ftt", "afc", "afp", "aftr", "gitp", " ftz", "ftping", "aftping", "iftt", " ftphp", "iftxp", "fft", "afth", "aftphp", "iftp", "ftf", " ftf", "aftp", "aftt", " ftl", "wtp", "ftl", " fth", " ftr", "aftz", " ftc", "aftjp", "ffp", "aftcp", "fftp", "iftf", "cttp", "gitf", "ftcp", "aftop", "ftz"]}}
{"id1": "12242903", "id2": "2525897", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 1, "substitutes": {"hashKey": ["updateLink", "updatekey", "processkey", "processLink", "processValue", "hashValue", "updateValue", "hashLink", "hashkey", " hashValue", " hashkey", "processKey", " hashLink", "updateKey"], "key": ["ace", "hex", "item", "secret", "null", "phrase", "link", "path", "prefix", "username", "base", "piece", "value", "name", "id", "message", "y", "this", "client", "port", "obj", "password", "k", "seed", "attribute", "cache", "service", "cert", "source", "code", "encrypted", "string", "title", "state", "template", "token", "conf", "KEY", "char", "foo", "json", "description", "sk", "data", "lock", "type", "hello", "entry", "Key", "text", "chain", "et"], "hashed": ["hushed", " hushed", "rhamped", "ahored", "hhed", "khash", "khhed", "hashing", "khrypted", "hamped", "hoted", "shhed", "hoashed", "ahushed", "hrypted", " hrypted", "shoted", "enhhed", "thushed", "rhashed", "thashed", "khashed", "shashed", "khashing", "ahashed", "hored", " hamped", "enhash", " hashing", "ahash", " hhed", "enhashed", "rhhed", "enhrypted", "thash", " hored", "thored", " hoted", "hohed", "shamped", "hoashing", "rhoted", "hoash"], "md5": ["det55", " MD3", "MD3", " MD45", "sha0", "md3", " md45", "MD5", "sha3", "md45", "md55", " MD2", "md2", "sha2", "dig55", " md55", "sha5", "dig3", " MD5", "MD0", " md3", "det3", "MD2", " md0", "det5", "md0", "MD45", " md2", "dig5"], "hash": ["hex", "ah", "shift", "hz", "sample", "length", "ssh", "total", "h", "score", "has", "uh", "ash", "block", "ashed", "check", "square", "sh", "sq", "count", "build", "message", "kernel", "trust", "number", "height", "search", "sha", "Hash", "hed", "index", "sum", "checked", "carry", "tag", "html", "always", "array", "handle", "radius", "shadow"]}}
{"id1": "804637", "id2": "13333160", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "7396682", "id2": "16623181", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["pixel", "upload", "zip", "read", "link", "gc", "fit", "archive", "Copy", "repeat", "opy", "delete", "cp", "php", "cross", "map", "sync", "write", "Cop", "cat", "create", "replace", "crop", "move", "share", "core", "clip", "slice", "proxy", "split", "transfer", "clone", "py", "cop", "download", "load"], "srcFS": ["sourceFS", "srcOS", "rcFs", "sourceOS", "srcVS", "srcFs", "srcSF", "sysOS", " srcVS", "sysFs", "sysFS", "srcfs", "sourceCS", "rcFS", " srcFs", "srcCS", "sourceFs", "rcMS", "srFs", "rcfs", " srcfs", "sysVS", "sourcefs", "srcMS", " srcOS", " srcCS", " srcSF", "sourceVS", "sourceSF", "rcVS", "srfs", "srFS", " srcMS", "rcOS", "srMS", "rcCS", "rcSF"], "src": ["sit", "RC", "sc", "http", "SOURCE", "selected", "https", "rc", "cont", "syn", "pkg", "path", "url", "secure", "pri", "desc", "check", "ser", "sq", "nil", "resource", "obj", "spec", "uri", "req", "boot", "sync", "sub", "cur", "proc", "source", "str", "th", "node", "rel", "st", "from", "txt", "start", "sb", "rx", "sn", "ctr", "rs", "dest", "supp", "iv", "init", "sec", "input", "img", "usr", "sin", "sr", "tmp", "target", "comp", "via", "sys", "addr", "Source", "sci", "inst", "subject", "loc", "lb", "filename", "dir", "obs"], "dst": ["dslt", " dDest", "ldest", "lst", "deest", "Dest", "dddest", "dsdest", "dsst", "Dlt", "dDest", "dedest", "lgt", "dhdest", "ddnd", "ddlt", "dST", "dgt", "ddest", "Ddest", "degt", "deslt", "dnd", "dsST", "dhDest", "dsnd", "DST", " ddest", "desdest", "dsest", "desnd", " dest", "dsgt", "DDest", "dest", "lest", " dST", "dlt", "Dst", "desst", " dlt", "ddst", "dhst", "dhlt"], "deleteSource": [" deleteSources", "closeSource", "destroySource", "leteDest", "updateSOURCE", " deleteResult", "removeSource", "removeParent", "DeleteSourceFile", "closeSourceFile", "DeleteSOURCE", "updateSite", "leteResult", "delParent", "DeleteSource", "leteSource", "deleteSOURCE", "destroySources", "leteSOURCE", "deleteSite", "removeSOURCE", "removeDest", "delSource", "leteParent", "delSOURCE", "leteSources", " deleteTarget", "deleteTarget", "updateSource", "destroyResult", "deleteSources", "deleteDest", "DeleteSite", "deleteParent", "closeSite", "deleteSourceFile", "delDest", "destroyTarget", "updateSourceFile", "leteTarget", "closeSOURCE", "deleteResult"], "conf": ["info", "m", "cn", "params", "cms", "ch", "ref", "css", "acc", "check", "cc", "ban", "map", "report", "req", "f", "log", "cache", "conn", "q", "scan", "fs", "param", "ln", "cf", "mm", "plan", "ctx", "comm", "cfg", "def", "lib", "con", "irm", "conv", "com", "hash", "config", "cm", "cb", "pool", "comment", "co", "job", "ca", "Conf", "prop"], "contents": ["Contodes", "contants", " Contents", "CONTresses", " contterms", "constends", " contresses", "CONTENT", "CONTants", " Contresses", "Content", "CONTodes", "constENTS", " content", "contENTS", "CONTends", " ContENTS", " contants", "constaves", " contENTS", "CONTaves", "content", "contaves", "contterms", "CONTent", "ContENT", "CONTENTS", "Contents", " Content", " contENT", "Contterms", "CONTterms", " contends", "Contants", "contresses", "CONTents", "contodes", "contENT", " contodes", "constents", " contaves", "contends"], "i": ["ji", "m", "ms", "iq", "ci", "u", "im", "phi", "j", "ii", "gi", "qi", "my", "I", "us", "span", "o", "key", "mi", "ti", "oi", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "client", "y", "multi", "ic", "ai", "\u0438", "q", "x", "n", "ori", "me", "bi", "iter", "ip", "cli", "init", "inner", "si", "ie", "ij", "ki", "index", "sim", "li", "ix", "docker", "json", "ami", "xi", "is", "ims", "ei", "chain"], "in": ["sql", "re", "read", "sample", " din", "mc", "cin", "add", "raw", "ini", "inf", "check", "inn", "ind", "ze", "ins", "by", "r", "reader", "inc", "doc", "out", "source", "from", "IN", "en", "bin", "inner", "isin", "con", "input", "char", "din", "body", "xml", "is", "and", "In"]}}
{"id1": "6906419", "id2": "9081749", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptionPassword", "encryptedPass", "enccryptPassword", "enccryptString", "decryptpassword", "encryptedpassword", "decryptedPassword", "encryptPass", "enccryptPass", "decryptedString", "encryptionpassword", "decryptPass", "decryptString", "decryptPassword", "encryptpassword", "enccryptpassword", "encryptionString", "encryptedString", "encryptedPassword", "encryptString", "decryptedpassword", "decryptedPass", "encryptionPass"], "password": ["pass", "secret", "email", "phrase", "Password", "default", "username", "prefix", "value", "address", "name", "message", "sword", "login", "print", "reset", "padding", "wordpress", "user", "auth", "string", "pattern", "token", "word", "input", "database", "description", "data", "hello", "key", "wd", "text", "command", "shadow", "attribute"], "digest": ["digse", "hashse", "decse", "Digse", "Digested", "dester", "digested", "minist", "digester", "decest", "hashester", "persest", "minester", "DigEST", "hashest", "hashEST", "dested", "Digist", "persested", "dest", " digested", "persist", "decester", " digse", " digEST", "decested", "digist", "minested", "Digest", "Digester", "digEST", "minest", " digester", "persester", "dse"], "hash": ["hist", "memory", "hex", "ah", "shift", "hz", "have", "table", "mac", "alt", "where", "total", "h", "oh", "has", "score", "host", "stock", "ash", "block", "check", "sh", "square", "history", "address", "filter", "dig", "map", "report", "print", "rh", "here", "cache", "mask", "height", "ashes", "test", "search", "all", "share", "sha", "esh", "Hash", "hed", "sum", "query", "html", "her", "match", "array", "handle", "attribute"], "buf": ["bar", "hung", "bh", "bg", "buff", "b", "cap", "mu", "pkg", "alph", "font", "batch", "func", "block", "Buffer", "vec", "fb", "buffer", "bo", "uf", "pb", "off", "mb", "queue", "var", "agg", "window", "Buff", "np", "cf", "cmd", "txt", "etc", "bag", "rb", "forge", "printf", "img", "usr", "fam", "br", "conv", "tmp", "db", "ob", "cb", "pool", "cv", "box", "msg", "foo", "nb", "bc", "bu"], "i": ["info", "ji", "m", "iq", "go", "ci", "u", "t", "im", "in", "phi", "b", "ii", "j", "gi", "qi", "c", "my", "I", "mi", "ti", "a", "oi", "get", "pi", "it", "e", "di", "ini", "ui", "ski", "ind", "hi", "id", "zi", "v", "y", "multi", "to", "ic", "print", "f", "uri", "io", "ai", "\u0438", "q", "x", "n", "g", "me", "iu", "bi", "ex", "ip", "exp", "init", "cli", "si", "ie", "ri", "conv", "index", "slice", "point", "sim", "li", "ix", "json", "xi", "is", "key", "ei", "major"], "halfbyte": ["phypair", " halfletter", "Halfcoin", " halfpiece", " halfbytes", " halfpage", "quarterletter", "Halfletter", "halfcoin", " halfchar", " halfcoin", " halfpair", "halfletter", " halfchannel", "quartercoin", "halfpixel", "phypixel", "leftnode", "quarterpixel", "halfchannel", "halfchar", "Halfchannel", "leftchar", "halfpair", "phybyte", "leftbyte", "halfbuffer", "phychar", "quarterpage", "quarterlen", "quarterchar", "halfword", "phypiece", "Halfpage", "Halfpiece", "halfpiece", " halfpixel", "halfbytes", "phylen", "halfpage", "quarterpair", "halflen", "halfnode", "phybytes", " halfbuffer", "Halfbytes", "Halfbyte", " halfword", "Halfbuffer", "Halfnode", " halfnode", "Halfchar", "Halfword", "quarterbyte", "leftbuffer", " halflen", "quarterword", "Halfpixel", "quarterchannel"], "two_halfs": ["two_turnls", "two_halfi", "two_parenups", "two_ledss", "two_roundups", "two_roundi", "two_parens", "two_pareni", "two_shakesets", "two_shakes", "two_halfls", "two_halfisters", "two_halfsets", "two_shakess", "two_rounds", "two_turnups", "two_enthals", "two_leds", "two_shakeisters", "two_halfss", "two_enthalss", "two_ledsets", "two_roundls", "two_turni", "two_halfups", "two_ledisters", "two_enthalsets", "two_turns", "two_enthalisters", "two_parenls"]}}
{"id1": "23246123", "id2": "17029388", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createDialogBox", " createDialogAction", " createWindowarea", " createDialogarea", "CreateDialogArea", "CreateDialogueBar", "createDialogueArea", "createFramearea", "createWindowArea", " createDialogBox", " createWindowArea", "CreateDialogarea", "createFrameArea", "createDialogueBar", "createEditorBar", "CreateDialogueArea", "createDialogarea", " createWindowBox", "createFrameBar", "createImageBox", "createImageArea", "createEditorAction", "CreateDialogBar", "CreateDialoguearea", "createEditorBox", "createWindowAction", "createDialoguearea", "createDialogAction", "createImageAction", "createImagearea", "createEditorArea", "createEditorarea", "createWindowBox", " createWindowAction", "createWindowarea", "createDialogBar"], "parent": ["null", "params", "document", "component", "default", "base", "block", "Parent", "part", "cp", "sp", "this", "context", "p", "port", "parents", " parents", "g", "child", "pc", "page", "container", "template", "tree", "instance", "server", "par", "root", "comp", "pool", "form", "self", "ca", "ps", "pt"], "composite": ["Compositable", "compposites", "composesitor", "compositionite", "Composite", "conposite", "completite", "completitor", "conpositor", "Comosite", "completites", "composites", "Composert", "comositable", "conposesites", "conposesitor", "compoites", "completited", "composit", "compoite", "comosert", "composesite", "Comosert", "compposit", "compositionitable", "compositionit", "conposesited", "comositor", "Comositable", "composesited", "conposited", "comosite", "composesites", "Comosites", "compositionites", "composesert", "conposites", "compositionert", "composert", "compoit", "composited", "conposesite", "comppositable", "compposite", "comosites", "comosit", "compositor", "composesitable", "compositable", "Composites", "compoitable", "comosited"], "content": ["null", "c", "cont", "document", "Content", "object", "component", "path", "get", "version", "value", "ct", "settings", "media", "ce", "cp", "message", "context", "this", "image", "article", "control", "wrapper", "cache", "license", "action", "application", "console", "code", "cf", "child", "widget", "ctx", "create", "copy", "container", "page", "title", "template", "con", "section", "current", "instance", "core", "java", "body", "cm", "city", "pool", "html", "comment", "xml", "form", "view", "header", "format", "wp", "load"], "ncol": [" ncl", "nccl", " ncolumn", " nCol", "nCol", "nrow", "ncCol", "Ncol", "Ncolumn", "ncolumn", "numcolumn", "nccolumn", " nrow", "numcl", "nccol", "Nrow", "numrow", "numcol", "ncl", "NCol", "numCol"], "layout": ["join", "slot", "setup", "lay", "sheet", "batch", "management", "rang", "block", "settings", "list", "system", "unit", "grid", "group", "l", "library", "background", "tab", "cache", "padding", "height", "scroll", "Layout", "window", "flow", "set", "widget", "language", "style", "template", "def", "shell", "position", "display", "draw", "pool", "loop", "view", "layer", "format", "loader", "shadow", "shape", "hold"], "numColumns": ["numcolumnS", "numberCols", "numberColumnS", "numcolumnd", "numberCold", "numberColumnes", "numcolumnes", "numColumnd", "numViewd", "numColumnes", "numCols", "numberColumns", "numCold", "numColes", "numberColumnd", "numViews", "numberColes", "numberColS", "numcolumns", "numColumnS", "numViewS", "numColS", "numViewes"], "browser": ["editor", "bar", "storage", "http", "callback", "b", "rar", "og", "back", "driver", "ver", "be", "erer", "aster", "roller", "bor", "or", "bb", "flash", "there", "client", "fb", "mobile", "buffer", "runner", "er", "writer", "chrome", "uri", "abl", "wrapper", "by", "io", "hr", "window", "console", "test", "user", "widget", "google", "theme", "rame", "caster", "page", "gg", "core", "server", "bridge", "root", "ger", "br", "river", "sim", "web", "manager", "html", "Browser", "vis", "platform", "orer", "ler", "vr", "loader", "webkit", "book", "remote"], "text": ["Text", "editor", "tt", "t", "note", "binary", "read", "cont", "object", "font", "TEXT", "ct", "message", "context", "image", "writer", "article", "print", "out", "source", "str", "term", "license", "x", "code", "utils", "txt", "output", "widget", "language", "string", "title", "page", "template", "word", "pdf", "nt", "ext", "config", "html", "xml", "comment", "data", "view", "description", "translation", "format", "ont", "label", "net"], "url": ["domain", "re", "bel", "ur", "lr", "http", "link", "b", "https", "il", "get", "gl", "dll", "address", "name", "resource", "uri", "l", "sl", "nl", "rl", "str", "window", "res", "rel", "location", "ssl", "result", "char", "Url", "web", "html", "file", "ll", "dl", "open", "URL"], "in": ["gin", "m", "t", "err", "nin", "b", "ner", "mc", "o", "mi", "stream", "cin", "it", "on", "mr", "or", "ini", "inf", "inn", "ind", "ain", "er", "ins", "s", "l", "rin", "f", "io", "reader", "inc", "out", "source", "n", "ln", "IN", "iter", "mm", "from", "init", "en", "bin", "inner", "dr", "all", "ie", "con", "input", "din", "i", "inside", "fr", "el", "file", "is", "ar", "ir", "In", "net"], "r": ["rt", "re", "lr", "ur", "err", "nr", "b", "j", "c", "rc", "rar", "mr", "rd", "or", "rer", "rus", "rm", "rate", "right", "p", "er", "l", "ra", "reader", "rf", "rl", "rg", "R", "hr", "n", "rect", "res", "rel", "ro", "rs", "rx", "cr", "dr", "rb", "ri", "tr", "sr", "br", "i", "rem", "fr", "ry", "reg", "ren", "kr", "rn", "vr", "rr", "d"], "sb": ["bt", "wb", "bh", "bg", "rob", "gc", "bs", "b", "erb", "stab", "ws", "kb", "bps", "bb", "sq", "sp", "ib", "pb", "sw", "sf", "mb", "sm", "gb", "sth", "sv", "lp", "bsp", "buf", "ub", "eb", "ibl", "txt", "sg", "ssl", "zb", "rb", "SB", "si", " SB", "sa", "bp", "gob", "cb", "xb", "lb", "bis", "nb", "obs"], "line": ["LINE", "re", "row", "ile", "phrase", "link", "sample", "rule", "eline", "range", "inline", "block", "ice", "part", "cell", "name", "Line", "sequence", "l", "print", "log", "number", "term", "str", "source", "code", "ln", "no", "user", "stroke", "iter", "entity", "lin", "page", "string", "word", "char", "body", "le", "frame", "comment", "header", "file", "entry", "field", "ine", "chain", "liner"], "e": ["ome", "m", "re", "t", "ent", "ee", "ec", "c", "ge", "o", "a", "se", "be", "ed", "es", "oe", "fe", "ce", "error", "v", "ze", "p", "er", "ae", "l", "f", "ve", "ev", "E", "je", "g", "me", "pe", "de", "eb", "die", "eeee", "exp", "en", "ie", "ger", "le", "ke", "te", "i", "eg", "el", "xe", "entry", "ne", "ue", "event", "et"]}}
{"id1": "7545002", "id2": "23666867", "code1": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 0, "substitutes": {"POST": [" post", "PUT", "EDIT", " posted", "PS", "TEXT", "GET", "Upload", "UT", "READ", "Posted", "post", "SELECT", " GET", "Patch", "HTTP", "ADD", "Post", " HEAD", "RAW", " Post", "METHOD", "HEAD", "JSON", "Request", " posting", "URL", "LOAD"], "url": ["ret", "pl", "ur", "http", "link", "https", "un", "path", "ref", "ls", "host", "base", "build", "address", "id", "uri", "l", "sl", "nl", "rl", "out", "cl", "str", "mount", "cmd", "location", "ssl", "string", "pattern", "Url", "web", "abs", "ul", "el", "addr", "file", "loc", "dl", "ll", "job", "key", "URL"], "props": ["Prots", " properties", "proPS", "probs", "Profs", "comrs", "Prors", "prts", "Properties", "combs", "comPS", "peps", "comps", "Probs", "prots", "prers", " prors", "Propl", "preps", "pers", "prefs", "prrs", " profs", "prperties", " proPS", "prors", "prps", "Props", "peperties", "pePS", "comperties", "properties", "pebs", "profs", "propl", "ProPS", "prepl", "comts", " propl"], "conn": ["nc", "rot", "cn", "err", "exec", "j", "gate", "ld", "pkg", "syn", "ch", "tn", "ct", "pg", "pas", "cp", "socket", "ns", "client", "connection", "obj", "req", "call", "quit", "lang", "cur", "Conn", "enc", "yn", "org", "res", "cmd", "nn", "cat", "act", "ctx", "init", "en", "comm", "forge", "con", "jp", "conf", "nt", "conv", "priv", "wn", "db", "cb", "connect", "canon", "ann", "reg", "addr", "sys", "nw", "loc", "open", "cert", "apt", "col", "net"], "i": ["info", "m", "ci", "u", "im", "in", "phi", "j", "gi", "ii", "gu", "qi", "c", "my", "I", "us", "span", "mi", "o", "ti", "oi", "pi", "it", "di", "ini", "ui", "ind", "hi", "id", "y", "v", "multi", "ic", "uri", "io", "ai", "x", "n", "g", "me", "ori", "bi", "ex", "ip", "init", "si", "ie", "ri", "index", "sim", "li", "ix", "ami", "xi", "is", "fi", "key", "ei"]}}
{"id1": "18891988", "id2": "15445861", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["selectString", "getfile", "GetFile", "createFilename", "Getfile", "GetString", "getString", "selectFilename", "selectfile", "createString", "GetFilename", "selectFile", "createfile", "createFile", "getFilename"], "serviceName": [" serviceNames", "ServiceNames", "serviceType", "serverType", "libraryName", "serverName", " serviceType", "ServiceCode", "serviceFamily", " serviceCode", " serviceFamily", "libraryFamily", "serviceNames", "libraryNames", "ServiceType", "ServiceName", "serverCode", "ServiceFamily", "serviceCode", "libraryType"], "wsdlLocation": ["wslLoc", "awsdLocation", "wsolURL", "wsolLoc", "wsDLlocation", "awsdlocation", "wdlPath", "wslLocation", "wssdlocation", "wsdLoc", "wssdPath", "awsdlLoc", "awsollocation", "awsdllocation", "wsdlocation", "wdlLoc", "wsollocation", "awsdLoc", "awsolURL", "awsdlURL", "wsdlFolder", "wslPath", "wlLocation", "wsDLFolder", "wdlFolder", "wsDLLocation", "awsolLoc", "wsolLocation", "wlFolder", "awsdlLocation", "wssdLoc", "wsDLLoc", "wssdLocation", "wsdlURL", "wsdllocation", "awsolLocation", "wsdlPath", "wdlLocation", "wslFolder", "wsDLURL", "wlLoc", "wlPath", "wssdFolder", "wsDLPath", "wsdURL", "wsdLocation", "awsdURL", "wssdURL", "wsdlLoc"], "endpoint": ["beginpoint", "beginword", "startword", "bindpoint", "endpoints", "idline", "startpoint", "endPoint", "endport", "idpoints", "beginpoints", " endpoints", "EndPoint", "endline", " endline", "Endpoint", "startPoint", "Endpoints", " endPoint", "idPoint", "bindPoint", "Endword", " endport", "endword", "idpoint", "Endport", "bindpoints", "beginPoint", "startline", "startpoints", "bindport"], "fileLocation": ["filelocation", "Filelocation", "filePosition", " filelocation", "fileLoc", "FileLocation", " fileLoc", "FileLoc", "documentLoc", " filePosition", "documentPosition", "documentlocation", "FilePosition", "documentLocation"], "tempDir": [" tempDirectory", " tempdir", "tmpdir", "tmpPath", "tempPath", "TempFolder", " tempPath", "tempDirectory", "tmpUrl", "tempdir", "tmpFolder", "Tempdir", "tempFolder", "TempDirectory", " tempFolder", "TempDir", "tmpDirectory", "TempPath", " tempUrl", "TempUrl", "tempUrl", "tmpDir"], "url": ["ret", "pl", "m", "re", "bel", "ur", "http", "link", "https", "un", "il", "github", "ls", "up", "base", "gl", "socket", "cp", "build", "l", "uri", "f", "sl", "r", "nl", "service", "conn", "str", "window", "rel", "mount", "location", "cr", "ssl", "char", "li", "Url", "mail", "web", "ul", "sur", "ll", "loc", "job", "dl", "open", "cert", "URL", "browser", "ctrl"], "WSDLFile": ["WSDLSFile", "WHDDLFILE", "WSDLSfile", "WIDLType", "WIDDLString", "WSDLLFilename", "WHDLfile", "WNDLfile", "WHDDLfile", "WSDLType", "WSDELFILE", "WHDDLFile", "WSDELFilename", "WIDLfile", "WSDLLString", "WSDLLFile", "WSDMLFILE", "WSDMLfile", "WSDQLfile", "WSDDLType", "WSDDLString", "WIDLFile", "WSDLLFILE", "WSDELFile", "WSDDLfile", "WSDDLFile", "WNDDLFilename", "WSDLLfile", "WSDLSString", "WSDLString", "WSDELfile", "WHDLFile", "WNDLFilename", "WSDLFILE", "WNDDLFILE", "WSDLFilename", "WSDQLFile", "WSDDLFILE", "WSDLSType", "WSDLLType", "WNDLFile", "WHDLFILE", "WNDLFILE", "WNDDLfile", "WSDLfile", "WIDDLFile", "WSDQLFILE", "WSDDLFilename", "WNDDLFile", "WIDDLfile", "WIDLString", "WIDDLType", "WSDMLFile"], "tmpWSDLFile": ["tmpWSDLLFilename", "tmpWIDDLfile", "tmpWSDLDFilename", "tmpWSDLfile", "tmpWSDLDfile", "tmpWSDLDFile", "tmpWSDLFiles", "tmpWIDLFilename", "tmpWIDDLFILE", "tmpWNDLFile", "tmpWIDLFile", "tmpWIDDLFilename", "tmpWSDLFILE", "tmpWSDDLfile", "tmpWNDDLfile", "tmpWSDDLFILE", "tmpWSDLLFILE", "tmpWIDLFILE", "tmpWNDLfile", "tmpWIDDLFile", "tmpWSDlFilename", "tmpWSDLLfile", "tmpWSDlFile", "tmpWSDDLFiles", "tmpWSDLLFiles", "tmpWNDDLFilename", "tmpWSDLLFile", "tmpWSDlFiles", "tmpWSDDLFile", "tmpWNDDLFiles", "tmpWNDLFiles", "tmpWIDLfile", "tmpWSDLFilename", "tmpWSDlfile", "tmpWNDLFilename", "tmpWNDDLFile", "tmpWSDDLFilename", "tmpWSDLDFILE"], "inputFile": [" inputFILE", "InputDo", " inputFiles", "tmpPlace", "inputPath", " inputPath", "tmpSourceFile", "inputFILE", "indexFILE", " inputfile", "clientFile", " inputDo", "inputSourceFile", "Inputfile", "inputFiles", "clientFILE", " inputSourceFile", "inDo", "clientPath", "tmpStream", "intfile", "interfaceSourceFile", "interfacePlace", "indexfile", "inFile", "errorFILE", "InputFile", "InputFiles", "infile", "outputFile", "inPath", "inputDo", "indexStream", "tmpfile", "interfaceFile", " inputPlace", "interfacefile", "clientFiles", "outputfile", "intFiles", "outputFILE", "outputStream", "indexFile", "inputfile", "intFile", "errorStream", "InputStream", "intFILE", "InputPath", "inputPlace", "tmpFILE", "InputFILE", "errorFile", "inputStream", "errorfile"], "tmpFile": ["inputFilename", "mpfile", "tempFILE", "tmpPath", " tmpFiles", " tmpfile", "tempPath", "empFilename", "empFILE", "tempFilename", "inputFILE", " tmpPath", "empFile", "mpFile", "tmpFiles", "tempFiles", "tempfile", "tempFile", "mpFiles", "tmpFilename", "tmpfile", "mpPath", "empfile", "inputfile", "tmpFILE"], "in": ["t", "c", "cont", "ch", "o", "mi", "stream", "cin", "it", "ini", "inf", "inn", "ind", "id", "client", "ain", "ins", "ic", "rin", "io", "r", "ai", "conn", "inc", "source", "n", "ln", "IN", "from", "init", "en", "bin", "inner", "isin", "input", "ri", "sin", "din", "inv", "file", "is", "ar", "In"], "out": ["os", "null", "t", "w", "c", "ch", "o", "aos", "on", "client", "connection", "buffer", "this", "writer", "can", "obj", "to", "outs", "log", "group", "io", "by", "conn", "write", "cache", "ao", "n", "output", "ex", "Out", "en", "all", "conf", "outer", "tmp", "conv", "ou", "inv", "oss", "at", "pool", "OU", "cm", "sys", "auto", "file", "OUT", "co", "lock", "ne", "we", "net"], "con": ["nc", "cn", "re", "tc", "fn", "cal", "c", "un", "ch", "mc", "ws", "acon", "cone", "cin", "func", "soc", "Con", "cp", "connection", "ain", "can", "login", "conn", "cur", "Conn", "ln", "cf", "fc", "win", "conf", "sec", "exc", "conv", "com", "CON", "num", "cm", "connect", "co", "ran", "const", "cons", "cos"], "fileLength": ["fileLen", "ileDuration", "channelSize", " fileLen", "fileFontSize", "ileLength", "objectSize", " fileSize", "channelLength", "ileLen", " fileDuration", "fileDuration", "FILELen", "fileSize", "objectFontSize", "FILEDuration", "channelFontSize", "channelDuration", " fileFontSize", "FILELength", "objectLength", "ileSize", "objectDuration", "FILESize"], "channelIn": ["chanIn", "channelSet", " channeledIn", "channeledIn", "ChannelIN", "ChannelOut", "consoleIn", "ChanneledIn", "chanSet", " channelIN", "clientIN", "chanOut", " channelin", "clientSet", "consoleOut", "clientin", "Channelin", "consoleIN", "consoleedIn", "channelIN", "clientOut", "ChannelIn", "channelin", "ChannelSet", "clientIn", "chanIN"], "channelOut": ["courseIn", "consoleout", "chanConn", "chanIn", "courseOUT", "ChannelOut", "chanout", "Channelout", " channelout", "chanOut", "channelOUT", "consoleOut", " channelConn", "channelConn", "ChannelOUT", "courseOut", "consoleOUT", "ChannelConn", "courseout", "channelout", "ChannelIn", "consoleIn", " channelOUT"], "tmpDocument": ["tpMedia", "tmDoc", "tempDocument", " tmpMedia", "tpDocument", "mkdocument", "tmdocument", "cpDocument", "mpDoc", "npMedia", "tpDocuments", " tmpdocument", "npDocument", "tmpDocuments", " tmpDoc", "tmpdocument", "mpDocument", "tempdocument", "tmpMedia", "cpDoc", "mkDoc", "tpFile", "mkDocument", "npFile", "tempDoc", "cpdocument", "tmDocument", "npDocuments", "tmpDoc", " tmpDocuments", "mpdocument"], "nl1": ["rnOne", "ln3", "NL2", "nl9", "sol1", "ln01", "nrOne", "pelOne", "nelOne", "rn6", "ln0", "nel3", "NL1", "rn1", "rn3", "nl6", "nr1", "sol2", "ln1", "pel1", "nr01", "ln2", "pel01", "nlOne", "NL0", "nl2", "lnOne", "nl0", "sol9", "NL9", "nel6", "sol0", "nl01", "nel1", "ln6", "nl3", "ln9"], "i": ["info", "ji", "m", "ms", "ci", "u", "j", "gi", "ii", "mu", "qi", "I", "us", "span", "mi", "key", "a", "ti", "o", "pi", "it", "di", "ini", "ui", "hi", "id", "y", "v", "multi", "ic", "k", "io", "ai", "\u0438", "x", "n", "ori", "me", "bi", "ip", "cli", "init", "si", "ie", "ij", "ri", "index", "sim", "li", "ix", "xi", "ami", "is", "ims"], "node1": ["Node2", "nodeOne", "componentOne", "node2", "node0", "ode1", "component1", "n1", "nOne", "node001", "layerOne", "Node001", "node91", "layer1", "component2", " node001", "ode0", " nodeOne", "n0", " node91", "layer91", "layer0", "NodeOne", "ode001", "ode2", "n91", " node2", " node0", "Node1", "Node0", "component0"], "tmpOut": ["mpout", "cmpIn", "npIn", "tempIn", "TempOUT", "empout", " tmpObj", "mpIn", "cmpOut", "tmpIn", "npOut", "mpOut", "npObj", "tempOUT", "tmpObj", "TempOut", "tempout", "TempObj", " tmpOUT", "tmpIs", "mpObj", "tempObj", "tempIs", " tmpIn", "npout", " tmpout", "empOut", "empIs", "TempIn", "tmpOUT", "tmpout", " tmpIs", "tempOut", "cmpout"], "retVal": ["retTrue", "returnval", " retval", "RetTrue", " retTrue", " retValue", "Retval", "RetVal", "retval", "RetValue", "returnValue", "returnTrue", "returnVal", "retValue"]}}
{"id1": "7044153", "id2": "7458833", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptiontoClient", "sendErrortoClient", "sendExceptiontoHost", "sendErrortoServer", "sendErrorToClient", "sendErrortoHost", "sendErrorToServer", "sendExceptionTOHost", "sendExceptionToHost", "sendExceptionTOClient", "sendExceptionToClient", "sendExceptiontoServer", "sendExceptionTOServer", "sendErrorToHost"], "server": ["null", "email", "erver", "base", "ver", "host", "version", "value", "ser", "store", "address", "client", "v", "port", "password", "service", "code", "test", "site", "string", "Server", "localhost", "description", "channel", "remote", "serv", "env"], "ex": ["hex", "rex", "re", "ox", "err", "exit", "Exception", "EX", "wx", "xc", "it", "e", "or", "none", "exe", "error", "eas", "expl", "obj", "ic", "pex", "event", "Exc", "exclusive", "x", "one", "example", "except", "test", "an", "exp", "rx", "exc", "ext", "com", "ix", "el", "nex", "ry", "fail", "tx", "ception", "lex", "aux", "Ex", "any"], "config": ["text", "params", "c", "rc", "ct", "Configuration", "settings", "figure", "context", "control", "password", "log", "content", "cache", "service", "Config", "param", "debug", "cfg", "conf", "input", "form", "channel", "fig", "env", "cert", "auth"], "prob": [" prbes", "probe", "prbe", "Prob", "Probe", "probj", "Probj", " prbj", " prbe", "prbj", " prb", "prbes", "Probes", "prb", "probes"], "dataSB": ["partialGB", "cacheBW", "joinsb", "imageSR", " dataHB", "keyBS", "relationSN", "ataEB", "imageSN", "ataSN", " dataBP", "imageSB", "resourceSI", "jsonSF", " dataSM", "imageNB", "DATASB", " dataMB", "debugSF", "mapSN", "joinMB", "dataSN", "valueSW", "relationSF", "nextSF", "ataBS", "datSL", "ataSL", " dataSN", "relBS", "dataSM", " dataGB", " dataSA", "joinSF", "listSB", "dataSquare", "mapSB", "contentNB", "contentSR", "resourcesb", "relSB", "relationSquare", "defSB", "dataSF", "divSquare", "jsonSw", "ataSW", "DATASF", "resourceSB", "imageSL", "partialBB", "ataQB", "joinWB", "imagesb", "relationSL", "windowBS", "dataRB", "dataSA", "relationSB", "dataEB", "dataBS", "dataSI", "listBB", "dataSW", "windowSF", "valueBB", "keyBB", "dateBu", "datMB", "jsonsb", "divSF", "datasb", "contentSF", "relationRB", "ataBP", "nextBB", " dataSI", "ataSF", "dataQB", "nextSB", "divSN", "dateQB", " dataSquare", "cacheSA", "reasonSB", "divBS", "datSB", "relationQB", "jsonSB", "defBB", "partialSL", "divNB", "defQB", "windowSB", "listEB", "imageSF", "mapHB", " dataSF", "relSW", "windowBB", "mapGB", "mapBS", " dataBS", "dataHB", "dataBu", "imageBS", "listSI", "mapSF", "reasonBS", "dataWB", "reasonSF", "listSF", "imageBP", "debugRB", " dataSw", "DATABS", "listsb", "ataWB", "cacheSF", "relationBB", "debugSB", "dateBS", " dataSL", "ataBu", "divBW", " dataEB", "cacheSB", "dataSL", "ataSB", "defGB", "divBB", " dataNB", "contentSN", "reasonSW", "mapBB", " dataRB", "relationNB", "imageHB", "ataMB", "dataBW", "ataNB", "imageSM", "dataBP", "dataGB", "nextQB", " dataBW", "cacheBS", "dateSB", " dataQB", "cacheSM", "dataSw", "listMB", "ataSR", "contentBS", "datWB", "dataSR", "nextGB", "keySL", "imageBB", "valueSB", "joinSL", "DATASW", "relationBS", "dataNB", "joinSB", " dataSW", "valueBS", "relBB", "imageSw", "relationBu", "keySB", "atasb", "cacheBB", "debugBB", " datasb", "ataBB", "windowSN", "partialSB", "contentSB", "windowSL", "resourceSF", "dataBB", "imageQB", "mapSL", "nextBS", "relationMB", " dataBB", "divSB", "cachesb", "ataSA", "dataMB"], "trace": ["ace", "true", "detail", "sample", "dump", "table", "fake", "span", " Trace", "range", "tile", "batch", "stream", "se", "be", "history", "store", "address", "race", "role", "buffer", "message", "sequence", "list", "mt", "report", "log", "track", "stable", "feature", "temp", "transform", "th", "test", "debug", "profile", "create", "style", "network", "tr", "body", "te", "frame", "comment", "tm", "data", "tty", "time", "chain", "stack", "thread"]}}
{"id1": "12197169", "id2": "2668853", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"read": ["record", " reads", "Read", "gc", " replay", "run", "close", " reopen", "open", "stream", " request", " seek", "log", "reader", " retrieve", " ingest", "find", "start", "init", " Read", " reader", " recover", "next", "connect", "reading", "hello", "download", " download", "load"], "in": ["info", "record", "re", "update", " din", "run", "o", "url", "get", "stream", "cin", "it", "on", "add", "check", "inf", "or", "inn", "when", "name", "message", "ill", "er", "ins", "log", "l", "f", "io", "reader", "r", "by", "ing", "with", "out", "during", "inc", "source", "al", "ro", "IN", "from", "isin", "bin", "inner", "all", "con", "input", "conf", "again", "din", "body", "index", "via", "at", "as", "file", "is", "entry", "and", "In"], "line": ["record", "LINE", "row", "detail", "link", "sample", "lo", "path", "eline", "url", "inline", "piece", "stream", "se", "e", "block", "part", "cell", "message", "Line", "sequence", "log", "l", "code", "ln", "stroke", "lin", "page", "string", "word", "char", "body", "le", "point", "frame", "comment", "file", "data", "lane", "entry", "ine", "text", "chain", "liner"], "i": ["m", "ci", "u", "t", "im", "z", "phi", "j", "ii", "qi", "c", "I", "mi", "oi", "ti", "o", "base", "pi", "di", "ind", "zi", "id", "hi", "y", "sequence", "multi", "p", "to", "l", "v", "f", "ai", "x", "n", "ori", "me", "bi", "iter", "cli", "si", "conv", "index", "sim", "li", "ix", "xi", "is", "ei", "d"], "logDatum": [" logDictionary", "logTrum", "logTrummy", "logRummy", " logDummy", "logDoummy", "logDoump", "logDum", " logBictionary", "logDummy", "logTrata", "LogDummy", "LogDum", "logBatum", "logDictionary", "logBictionary", "logRictionary", "logDoatum", "Logdum", " logDump", "logdata", " logBump", "Logdatum", "LogData", "logBummy", "logdummy", " logBatum", " logBummy", "logRump", "logDoictionary", "logdum", "logdatum", "logBump", "logRatum", "logTratum", "Logdata", "LogDatum", "Logdummy", "logDump", "logData"]}}
{"id1": "5977352", "id2": "13333160", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpFolder", "cpFolder", " cpfile", "cpFiles", " copyfile", "copyfile", "cpFile", " cpFiles", " copyFiles", "copyFolder", "copyFiles", "cpfile", " cpFile", " copyFolder"], "src": ["sit", "sc", "orig", "SOURCE", "rc", "pkg", "cont", "ser", "sq", "rest", "ins", "req", "sf", "rl", "cur", "source", "rel", "st", "from", "rs", "start", "sb", "init", "ctr", "sec", "input", "img", "usr", "sr", "via", "sys", "Source", "inst", "loc", "ipl"], "dest": ["tom", "sit", " dst", "null", "orig", "Dest", "tif", "gt", "opt", "cont", "end", "mk", "desc", "trans", "none", "parent", "sp", "cp", "name", "coord", "decl", "port", "rest", "master", "spec", "temp", "dist", "th", "source", "test", "st", "de", "good", "cat", "txt", "dat", "origin", "copy", "etc", "result", "them", "usr", "nt", "tmp", "target", "nom", "comp", "lit", "foreign", "nw", "self", "loc", "comb", "est", "dir", "del"], "bufSize": [" bufSIZE", "fontNum", " bufferSIZE", "bufNum", "bcSIZE", "bcSize", "ufLen", "fontSIZE", " bufNum", "bcLen", " bufLen", "bufSIZE", "bufLen", "ufNum", " bufferSize", "ufSize", "fontSize", " bufferNum", "bcNum", "ufSIZE"], "force": ["fast", "send", "allow", "forced", "close", "Force", "rule", "default", "base", "enable", "raise", "require", "check", "ce", "error", "quote", "use", "reset", "print", "f", "fill", "flag", "write", "only", "apply", "kill", "forces", "cmd", "safe", "replace", " Force", "forge", "draw", "stall", "frame", "form", "auto", "always", "co", "forcing", "remote", "command"], "buffer": ["paste", "memory", "row", "phrase", "binary", "buff", "length", "table", "sample", "variable", "total", "document", "batch", "base", "block", "mem", "Buffer", "device", "history", "quote", "message", "sequence", "library", "print", "limit", "queue", "cache", "number", "temp", "window", "buf", "tree", "template", "word", "frame", "comment", "view", "display", "text", "attribute", "command", "stack", "shape"], "read": ["pass", "record", "before", "row", "feed", "t", "im", "w", "Read", "length", "send", "run", "allow", "give", "parse", "end", "range", "get", "stream", "add", "raw", "check", "count", "valid", "ind", "need", "READ", "reads", "req", "print", "reader", "readable", "fill", "r", "write", "request", "height", "q", "str", "scan", "bind", "pe", "iter", "find", "start", "set", "push", " Read", "input", "word", "index", "next", "query", "wait", "through", "i", "connect", "size", "reading", "hello", "len", "open", "text", "load", "shape", "hold"], "in": ["gin", "info", "m", "cn", "t", "include", "im", "per", "mi", "o", "get", "up", "cin", "it", "on", "or", "ini", "inf", "check", "inn", "ind", "internal", "ain", "ins", "ic", "rin", "l", "doc", "inc", "al", "source", "n", "ln", "IN", "iter", "mm", "from", "init", "local", "en", "inner", "isin", "bin", "ie", "all", "con", "input", "sin", "din", "irm", "ma", "i", "inside", "is", "co", "ar", "In"], "out": ["cn", "os", "t", "b", "gt", "end", "ot", "ch", "o", "up", "aos", "it", "on", "mit", "or", "oe", "ns", "list", "client", "v", "writer", "obj", "can", "to", "flush", "outs", "l", "io", "op", "write", "conn", "cache", "not", "one", "n", "g", "ln", "cos", "cmd", "output", "ex", "om", "Out", "inner", "all", "con", "again", "nt", "outer", "conv", "br", "sum", "ou", "oss", "at", "sys", "file", "OUT", "co", "ne", "ent", "net"]}}
{"id1": "3514286", "id2": "20267500", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "label": 0, "substitutes": {"getHashedPassword": ["getHackedUser", "getShashedPassword", "getShashedSecret", "getHashedSecret", "getHackedPassword", "getHashesSecret", "getHashesUser", "getShashUser", "getHackedSecret", "getHashespassword", "getShashedUser", "getHashPassword", "getHashesPassword", "getHashpassword", "getHackedpassword", "getHashedUser", "getHashSecret", "getHashedpassword", "getShashedpassword", "getHashUser", "getShashPassword", "getShashpassword", "getShashSecret"], "password": ["pass", "secret", "email", "phrase", "Password", "default", "username", "prefix", "raw", "value", "address", "name", "message", "sword", "login", "reset", "padding", "wordpress", "user", "string", "pattern", "token", "word", "input", "REDACTED", "database", "hash", "description", "data", "key", "wd", "text", "command", "shadow", "attribute"], "digest": ["digse", "hashse", " Digester", "Digse", "Digested", "dests", "digested", "mdest", "digester", "hashester", "digests", " Digest", "mdests", "Digests", "hashested", "hashest", "dested", "dest", " digested", " digse", "mdse", "hashests", "mdester", "Digest", "Digester", " digester", " digests", " Digse"], "hashedInt": ["hcheckedINT", "hashingINT", "hashashingInt", "hhedInt", "hashedINT", "hhedId", "hashedInteger", "hhedInteger", " hushedId", "hcheckedInteger", "hashashedInteger", "hashingInt", "hcheckedInt", " hushedTx", " hushedInt", "hashashedInt", "hashINT", "hushedInt", "happedInt", "hashashedINT", "happedId", "hashedTx", "hhedTx", "hashInteger", "hashashingInteger", "happedInteger", "hushedTx", " hushedInteger", " hashedInteger", "hushedId", "hashInt", "happedTx", " hashedTx", "hashingInteger", " hashedId", "hashedId", "hushedInteger", "hashashingINT"]}}
{"id1": "16353490", "id2": "8588992", "code1": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"executePost": [" performpost", " performPOST", "executePOST", " executeGet", " executePOST", "execGet", " executepost", "executepost", "execPOST", " performGet", "execpost", " performPost", "executeGet", "execPost"], "targetURL": ["targetUrl", "templateUrl", "TargetURL", "baseUrl", "TargetUrl", "sourceLocation", "sourceUrl", "baseLocation", "baseID", " targetID", "baseUR", "targetURI", "templateURL", " targetUrl", "targetID", "targetUR", "sourceURL", "templateID", "targetLocation", "templateURI", "TargetUR", "sourceUR", " targetURI", "baseURI", "baseURL", "TargetLocation"], "urlParameters": [" urlNames", "URLParameter", " urlTypes", "rowRequirements", "urlTypes", "rowParameter", "rowNames", "URLTypes", "URLParameters", "UrlParameters", "UrlParameter", "uriParameter", " urlDetails", "uriParameters", "urlParameter", "uriArgs", "UrlArgs", "rowParameters", "UrlTypes", "UrlNames", "urlArgs", " urlParameter", " urlRequirements", "UrlDetails", "urlRequirements", " urlArgs", "URLDetails", "urlDetails", "urlNames", "UrlRequirements"], "url": ["pl", "ur", "u", "t", "http", "hl", "link", "https", "document", "il", "path", "github", "ref", "ls", "host", "get", "gl", "base", "ml", "build", "address", "name", "resource", "uri", "l", "log", "sl", "r", "nl", "rl", "loader", "org", "str", "mount", "www", "location", "ssl", "Url", "web", "mail", "ul", "file", "ll", "dl", "open", "URL"], "connection": ["c", "government", "socket", "system", "context", "bo", "library", "io", "operation", "number", "license", "still", "node", "user", "see", "database", "relation", "closure", "subject", "channel", "generation", "attribute", "nc", "note", "Connection", "client", "conn", "console", "you", "location", "session", "query", "city", "open", "command", "creator", "office", "link", "document", "ion", "option", "component", "termination", "statement", "creation", "condition", "or", "when", "directory", "pointer", "application", "controller", "function", "current", "position", "communication", "connect", "initial", "remote", "collection", "close", "engine", "object", "character", "reference", "cone", "information", "general", "device", "message", "resource", "writer", "cache", "write", "connected", "method", "no", "set", "create", "associated", "language", "container", "con", "network", "description", "entry", "volume"], "wr": ["bh", "rw", "wb", "shr", "tw", "w", "WR", "dx", "mk", "rew", "wid", "wrote", "rus", "wm", "writer", "RW", "mt", "r", "spr", "ocr", "sw", "iw", "hr", "mg", "ln", "ru", "writ", "wn", "Wr", "wy", "wer", "fr", "inv", "pr", "ptr", "wt", "kr", "wa", "nw", "wk", "vr", "we", "mr", "vet", "adr"], "is": ["os", "sit", "ms", "sis", "isl", "im", "in", "isa", "ii", "ios", "lis", "se", "isi", "its", "isc", "iss", "ins", "s", "does", "ai", "ih", "still", "iris", "nis", "rs", "si", "ri", "\u00eds", "ris", "iso", "xs", "i", "sys", "IS", "Is", "ais", "bis", "ir", "are"], "rd": ["rt", "lr", "rw", "dq", "rob", "ld", "rar", "rand", "mr", "erd", "nd", "RD", "rer", "rus", "rm", "ra", "r", "reader", "rl", "rg", "hr", "rect", "ru", "rs", "rx", "cr", "nder", "dr", "rb", "rpm", "ri", "rid", "sr", "ird", "din", "rr", "fr", "ptr", "ry", "red", "rn", "rh", "dd"], "line": ["record", "LINE", "row", "column", "phrase", "link", "sample", "ode", "ge", "rule", "eline", "range", "inline", "se", "e", "block", "ice", "error", "name", "cell", "message", "list", "Line", "sequence", "buffer", "l", "print", "log", "code", "ln", "stroke", "lin", "page", "string", "word", "point", "mail", "frame", "comment", "header", "file", "lane", "entry", "ine", "label", "text", "liner", "command"], "response": ["answer", "detail", "resp", "object", "onse", "success", "version", "value", "block", "message", "buffer", "sequence", "image", "summary", "report", "print", "reset", "content", "service", "request", "example", "application", "res", "respons", "output", "csv", "tree", "reply", "position", "render", "network", "Response", "server", "continue", "next", "json", "relation", "html", "frame", "description", "model", "view", "entry", "format", "display", "command", "result", "vector", "collection"]}}
{"id1": "442381", "id2": "20210699", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doFeaturecheck", "doVersionTest", " doVersionscheck", "doImageTest", "doVersionInfo", "doFeatureInfo", " doApplicationTest", " doApplicationInfo", "doVersioncheck", "doBuildTest", "doFeatureTest", "doVersionscheck", "doImageQuery", " doVersionsTest", "doApplicationCheck", " doVersionInfo", " doApplicationCheck", "doVersionsUpdate", "doApplicationQuery", " doVersioncheck", "doBuildCheck", " doVersionQuery", " doVersionTest", "doBuildcheck", "doFeatureUpdate", " doVersionsCheck", "doVersionsCheck", " doApplicationQuery", "doApplicationTest", "doBuildUpdate", " doVersionUpdate", "doFeatureQuery", "doImageCheck", "doFeatureCheck", "doImageInfo", " doVersionsUpdate", "doVersionsTest", "doApplicationInfo", "doVersionUpdate", "doVersionQuery"], "view": ["iew", "project", "row", "http", "update", "document", "engine", "component", "h", "version", "block", "check", "ml", "cell", "client", "this", "buffer", "image", "v", "views", "context", "port", "report", "print", "layout", "call", "q", "window", "controller", "see", "widget", "View", "page", "tree", "VIEW", "virtual", "input", "server", "show", "index", "query", "review", "manager", "html", "tv", "pool", "cv", "form", "model", "file", "subject", "box", "vm", "self", "lock", "display", "eye", "browser"], "url": ["pl", "domain", "bel", "ur", "oul", "http", "hl", "link", "b", "ref", "host", "get", "gl", "build", "address", "client", "v", "uri", "l", "f", "sl", "r", "nl", "log", "rl", "str", "rel", "mount", "ssl", "char", "Url", "mail", "ul", "html", "file", "loc", "lb", "ll", "dl", "job", "URL", "browser"], "in": ["gin", "info", " IN", " din", "In", "stream", "cin", "on", "inf", "inn", "ain", "mn", "ins", "can", "rin", "f", "l", "reader", "inc", "out", "source", "n", "ln", "IN", "from", "init", "isin", "inner", "input", "sin", "din", "body", "asin", "i", "mat", "is", "vin"], "bin": ["gin", "re", "bg", "spin", "binary", "buff", "b", "thin", " din", " bins", "ebin", "bn", "cin", "stock", "inn", "brain", "buffer", "ins", "rin", "mon", "by", "reader", "sam", "obin", "out", "cache", "ln", "cos", "bi", "bl", "local", "win", "init", "bur", "rb", "inner", "lib", "con", "all", "jin", "sin", "din", "body", "abin", " Bin", "bed", "session", "conv", "db", "cb", "file", "ran", "len", "nb"], "line": ["record", "LINE", "row", "detail", "column", "err", "parse", "link", "sample", "lo", "rule", "stay", "eline", "range", "tile", "inline", "base", "stream", "block", "ice", "part", " block", "ine", "cell", "message", "Line", "sequence", "port", "l", "log", "print", "lines", "code", "ln", "cmd", "iter", "cat", "lin", "string", "page", "style", "section", "word", "char", "next", "le", "point", "zone", "trace", "frame", "comment", "status", "file", "lane", "channel", "job", "entry", "field", "key", "chain", "liner"], "develBuild": ["deployBuilt", "devBuilder", "desVELBuild", "deffBuild", "deffbuild", "DeVELBuild", "devBuild", "deVELLog", "develBuilt", "desVELbuild", "desvelBuild", "duffBuilt", "DevelBuild", "DeVELbuild", "devLog", "deffBuilder", "depoBuild", "duVELBuilder", "duVELBoot", "Develbuild", "develbuild", "develBoot", "deVELbuild", "deploybuild", "duffBuild", "duvelBuilder", "deployBuild", "duVELBuild", "devbuild", "DevelLog", "duvelbuild", "develLoad", "desVELRelease", "duffBuilder", "develLog", "deeltaBuild", "duffbuild", "desvelRelease", "DeVELBuilt", "deeltaRelease", "desvelLoad", "deployRelease", "duvelBuilt", "deVELBuild", "duVELbuild", "deVELLoad", "depobuild", "depoBuilt", "desVELLoad", "deeltabuild", "deeltaLoad", "deVELBuilt", "deployLoad", "DevelBuilt", "deffBuilt", "deployBoot", "duvelBoot", "depoLog", "deVELBoot", "DeVELLog", "develBuilder", "devBuilt", "develRelease", "devBoot", "duvelBuild", "desvelbuild", "deVELBuilder", "deployBuilder", "deVELRelease"], "stableBuild": ["devBuilder", "secureBuild", "devBuild", " unstableCraft", " stablebuild", " stableBuilder", "activeBuild", "secureCraft", " unstableLong", "stableBoot", " stableLong", " unstablebuild", " unstableBuild", " stableBind", " unstableBind", "stableBind", "devbuild", "securebuild", "activeMake", "stablebuild", " stableBoot", "confirmedLong", "confirmedbuild", " unstableBoot", "devMake", "stableBuilder", "stableLong", "activeBuilder", "confirmedBoot", "confirmedBuild", "stableCraft", "activebuild", " stableCraft", " stableMake", "secureBuilder", " unstableBuilder", "devBind", "stableMake"]}}
{"id1": "2461169", "id2": "9450274", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileAsfile", "decodeFileToString", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFileFileFile", "decodeStringToString", "decodeStringToFiles", "decodeString2file", "decodeFileTofile", "decodeFile2String", "decodeStringToFile", "decodeString2String", "decodeString2File", "decodeFileFileFiles", "decodeFileAsFiles", "decodeFile2File", "decodeFile2Files", "decodeString2Files", "decodeFileFileString", "decodeFileToFiles", "decodeFile2file", "decodeFileAsString"], "infile": ["isinfolder", "isinfile", "inputname", "Inbase", "outFile", "outfolder", "InFile", "outfilename", "inname", "isinname", "fromFile", "outname", "Infile", "infolder", "frombase", "inFile", "inputFile", "inbase", "fromfilename", "infilename", "inputfile", "isinFile", "fromfile", "Infilename", "inputfolder", "outbase"], "outfile": [" outname", "inFILE", "Outfilename", "Outfile", "outFile", "otname", "outfilename", "otfile", "inname", " outFile", "outname", "todir", "outdir", "otFILE", "tofilename", "inFile", "outFILE", "indir", "tofile", "Outdir", "infilename", "toFile", "OutFile", " outFILE", "otFile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "variable", "total", "document", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "attribute", "cache", "number", "temp", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "shape", "append"], "read": ["before", "each", "text", "send", "shift", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", " succeed", "ok", "submit", "ratulations", " succ", "condition", "scope", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "summary", "primary", "commit", "positive", "surv", "crit", "same", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", "unity", "please", " successes", "first", "support", "city", "exist", " successful", "ceed", "fail", "response", "successfully", "status", "result", " okay", "accept"]}}
{"id1": "21363911", "id2": "19006212", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"testTransactions": ["testTacts", " testTransitions", " testtransaction", " testtransacts", "testTactions", "testTaction", "testTransitions", "testtransaction", " testtransactions", "testTransacts", "testtransactions", " testtransitions", "testTransaction", " testTransacts", "testtransitions", "testTitions", " testTransaction", "testtransacts"], "con": ["cn", "tc", "gate", "c", "coll", "xc", "util", "bo", "can", "cur", "anc", "ctx", "en", "conf", "co", "ac", "nc", "dial", "po", "gc", "bn", "rc", "client", "conn", "enc", "rec", "console", "ln", "act", "don", "CON", "config", "ran", "open", "pt", "dn", "go", "re", "sc", "fn", "un", "pen", "mc", "on", "cc", "ct", "cp", "connection", "ain", "fl", "res", "cf", "fc", "ens", "db", "cm", "connect", "cv", "gen", "bc", "ctrl", "pl", "cal", "cont", "ch", "Con", "ic", "cache", "win", "pc", "conv", "com", "ren", "sur", "cons"], "st": ["tt", "rt", "bt", "ft", "sc", "t", "stop", "ld", "sty", "ste", "ut", "statement", "h", "it", "nd", "stre", "ct", "ost", "sp", "ast", "ts", "must", "St", "bo", "rest", "s", "mt", "l", "obj", "sl", "stage", "sw", "std", "et", "cl", "put", "th", "sol", "str", "sth", "ln", "ist", "start", "sb", "sn", "stat", "sts", "cr", "ust", "art", "step", "stra", "nt", "sta", "irst", " superst", "fr", "wt", "inst", "stan", "co", "so", "const", "est", "ST", "pt"], "rs": ["ubs", "ws", "ts", "rys", "ris", "RS", "ires", "vr", "mr", "rt", "ms", "bs", "rc", "els", "ss", "its", "cs", "ress", "r", "ats", "sts", "ds", "usr", "ys", "sr", "rates", "hs", "ras", "pres", "ars", "abs", "ems", "acks", "qs", "irms", "rots", "re", "aps", "arms", "rows", "rd", "ns", "ows", "rets", "gs", "hr", "res", "vers", "rel", "rss", "dr", "ks", "ges", "cases", "ps", "rr", "ags", "ros", "rings", "vs", "ls", "arts", "Rs", "rus", "s", "ins", "ues", "rl", "js", "pc", "rx", "ics", "ri", "xs", "times", "sys", "dds", "stats", "ims", "icks", "rm"]}}
{"id1": "17947247", "id2": "13657103", "code1": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"postURL": [" postURI", "getPage", "postPage", " postUR", "postURI", " postPage", "getUR", "getURL", "POSTPage", "POSTUR", "postUR", "POSTURL", "POSTURI", "getURI"], "urlLocation": ["urlLoc", "logLocation", "UrlLoc", "logLoc", " urlDescription", "URLlocation", "strlocation", "urlLocated", "lDescription", "urllocation", "implHistory", "urlName", "strLocated", "urlHistory", "urlLocal", "UrlLocation", "llLoc", "pathLocation", "URLDescription", "UrlName", "loglocation", "lLocation", " urlLoc", "UrlLocated", "Urllocation", "llLocal", "pathLocated", "llDescription", "logLocated", " urlHistory", "urlDescription", "implLoc", "URLLocation", "lLocal", "URLName", "implLocation", "URLLoc", "llLocation", " urlLocal", " urllocation", "implDescription", "URLLocated", "strLocation", " urlLocated", "URLHistory", "pathName", "lLoc", "strLoc"], "headers": ["modules", "frames", " collectors", "http", "actions", "qs", "authors", " trailers", "codes", "ctors", "events", "resources", "files", "relations", "history", "errors", "articles", "users", "ers", "workers", "heads", "checks", "items", "blocks", "bits", "members", "comments", "ancers", "ilers", "ids", "ters", "weights", "caps", "dates", "objects", "keys", "holders", "types", "masters", "writers", "drivers", "properties", "head", "archives", "terms", "orders", "times", "names", "pres", "months", "strings", "ppers", "ors", "images", "tags", "ackers", "boxes"], "content": ["gc", "empty", "cont", "document", "Content", "default", "get", "any", "property", "raw", "version", "settings", "now", "ce", "name", "address", "message", "context", "connection", "sequence", "layout", "padding", "request", "source", "str", "code", "output", " Content", "title", "string", "page", "template", "current", "core", "present", "body", "json", "html", "hash", "comment", "ontent", "script", "data", "description", "xml", "response", "time", "text", "command", "accept"], "postVariables": ["postvariables", "postParates", "postVams", "postVariants", "postVabilities", "PostVariants", "PostVables", "postVariableates", "postvariabilities", "postsVants", "postVarams", " postVariates", "PostVariables", "postsVables", "PostVants", "PostVams", "postVariableants", " postVariableates", "putVariams", "putVants", "postVariabilities", "PostVariams", " postVariableams", "postsVabilities", "postParables", " postVariams", "postsVariants", "postVariableables", "putVables", "postsVams", "PostVariabilities", "putVams", "postsVariabilities", "postVants", " postVariableables", "PostVabilities", "postVarates", "postParams", "postsVariables", "postVables", "putVariables", "postvariams", "postvariants", "postVarables", "postVariableams", "putVariants", "postVariams", "postsVariams", "postVariableabilities", "postVariates"], "c": ["nc", " cc", "m", "tc", "t", "w", "gc", "b", "ec", "mc", "C", "h", "o", "e", "cc", "ct", "dc", "p", "v", "context", "l", "f", "r", " ec", "cache", " e", "n", "g", "code", "fc", "ctx", " cr", "config", "cb", "chain", " C", "bc"], "postContent": ["PostCopy", "putValue", "uploadcontent", "PostData", "printContent", " postMessage", "uploadContent", "PostText", "postText", "PostMessage", "POSTContents", "putText", "preValue", "uploadContents", " postContents", "postCopy", "putCopy", "prettyContent", "postcontent", "prettyData", "Postcontent", "putContents", "prettyContents", "ostContents", "putcontent", "postData", "prettyMessage", "postContents", "putData", "printContents", " postText", "printValue", "ostData", "preContents", "preCopy", " postCopy", " postcontent", "putContent", "preData", "POSTValue", "POSTCopy", "PostContents", " postValue", "ostContent", "PostContent", "preContent", "postMessage", "POSTContent", "uploadData", "postValue", " postData", "printcontent"], "elements": ["elelements", "engils", "eslements", "eppers", "estons", "Efaces", "peles", "Elements", "leles", "lelem", "engonents", "edlements", "elelem", "seles", "erils", "evers", "Elem", "severs", "edumbers", "edtons", "pelem", "eonents", "erlements", "eumbers", "eils", "englements", "entityonents", "elevers", "entityils", " etons", "eronents", "elefaces", "erumbers", "Evers", "pelements", "edppers", "leumbers", "lelements", "seumbers", "esumbers", "entitylements", " eumbers", "selements", "efaces", "entityumbers", " eppers", "eles", "selem", "elem", "peumbers", "engumbers", "etons", "esppers", "sefaces"], "key": ["info", "ox", "column", "cookie", "pkg", "property", "pair", "part", "y", "by", "member", "code", "param", "typ", "tip", "ie", "keys", "char", "index", "important", "hash", "col", "attribute", "where", "ver", "ice", "ind", "feature", "step", "search", "query", "ke", "Key", "label", "et", "ek", "link", "variable", "my", "option", "check", "kid", "primary", "event", "test", "string", "def", "KEY", "tag", "item", "phrase", "mac", "base", "prefix", "count", "parent", "cond", "name", "id", "p", "owner", "k", "tab", "var", "no", "set", "title", "token", "core", "description", "entry", "field", "type", "chain", "prop"], "val": ["ret", "pl", "item", "VAL", "sel", "alt", "cal", "pet", "ver", "valid", "az", "ind", "v", "values", "unit", "element", "von", "var", "crit", "str", "seq", "res", "buf", "test", "vals", "dev", "eval", "def", "Value", "Val", "aval", "rol", "el", "data", "vol", "ival", "tx", "pol", "serv", "label", "text", "col", "elt", "vet", "pt"], "firstElement": ["nextToken", "Firstelement", "secondElement", "lastEle", "currentEle", "FirstToken", " firstEle", "nextElement", "secondEle", "firstEle", " firstEntry", "FirstElement", " firstelement", "secondKey", " firstKey", "currentelement", "firstelement", "lastKey", "currentElement", "FirstKey", "secondEntry", "lastEntry", "firstEntry", "lastElement", "nextelement", "FirstEle", " firstToken", "nextKey", "firstToken", "currentKey", "firstKey"], "url": ["m", "bel", "u", "ur", "t", "http", "hl", "link", "b", "https", "pkg", "il", "github", "ls", "host", "get", "gl", "ml", "cp", "address", "name", "connection", "acl", "resource", "l", "log", "sl", "r", "nl", "rl", "str", "org", "g", "rel", "blog", "location", "ssl", "con", "lt", "atl", "Url", "mail", "web", "ul", "el", "ll", "dl", "loc", "ocl", "cert", "URL", "browser"], "lines": [" ss", " cc", " resp", " params", " values", " text", " strings", " str", " request", " rows", "buffer", " temp", " state", " results", " sp", " res", " sql", " req", " input", " code", " cp", " buff", " buffers", " raw", " msg", " rc", " br", " context"], "conn": ["nc", "cn", "err", "http", "po", "resp", "close", "ch", "cc", "ct", "socket", "pg", "cp", "ns", "pas", "Connection", "connection", "client", "obj", "cur", "Conn", "enc", "iw", "connected", "org", "n", "js", "res", "cmd", "txt", "ctx", "auth", "nec", "comm", "con", "conf", "jp", "nt", "conv", "config", "cb", "connect", "addr", "ann", "canon", "open", "ca", "cert", "bc", "aux"], "i": ["info", "ji", "m", "iq", "ci", "u", "im", "gi", "ii", "j", "qi", "mu", "I", "us", "mi", "ti", "oi", "pi", "it", "di", "ini", "ui", "ski", "ind", "hi", "id", "v", "y", "multi", "ic", "ai", "\u0438", "x", "ori", "me", "iu", "bi", "ex", "cli", "inner", "si", "ie", "ij", "ki", "ri", "index", "sim", "li", "ix", "xi", "ami", "is", "yi", "ims", "ei"], "header": ["info", "item", "detail", "column", "http", "heading", "cookie", "table", "handler", "variable", "component", "h", "property", "response", "host", "holder", "prefix", "block", "version", "part", "history", "filter", "address", "client", "buffer", "port", "context", "er", "wrapper", "element", "border", "hidden", "padding", "request", "magic", "argument", "code", "Header", "init", "metadata", "title", "string", "dr", "token", "section", "server", "head", "body", "query", "tag", "first", "hash", "html", "frame", "comment", "initial", "subject", "layer", "protection", "policy", "format", "field", "entry", "text", "handle", "status", "event", "attribute"], "value": ["browser", "true", "cas", "null", "sample", "expression", "total", "option", "default", "ver", "VALUE", "pair", "add", "block", "valid", "python", "cell", "name", "message", "v", "values", "unit", "ow", "buffer", "address", "element", "number", "term", "function", "test", "local", "vp", "widget", "csv", "language", "title", "Value", "json", "des", "description", "comment", "hello", "field", "label", "text", "ue", "event", "result", "attribute"], "contentLengthFound": ["timeLengthRequired", "timeLengthValid", "contentTypeChanged", "timelengthPresent", " contentLengthChanged", " contentTypeFound", "timelengthValid", " contentLengthPresent", "contentTypeRequired", "contentlengthPresent", "contentTypeFound", "contentTypefound", "contentContentPresent", "contentLenValid", "timelengthFound", " contentLengthValid", "contentContentRequired", "contentLenFound", " contentTypeValid", "contentLenPresent", "contentLengthValid", "contentContentFound", "contentlengthRequired", "contentSizeFound", " contentLenPresent", " contentLenValid", "contentlengthValid", "contentLenfound", "contentLenChanged", "contentLenRequired", "contentlengthfound", "timeLengthFound", "contentLengthRequired", "contentLengthfound", "timelengthRequired", "contentLengthChanged", "contentTypePresent", "contentContentValid", " contentLenFound", "contentSizeChanged", "contentLengthPresent", "timeLengthPresent", "contentTypeValid", " contentTypeRequired", " contentTypeChanged", " contentLengthfound", " contentLenfound", " contentLengthRequired", "contentSizeRequired", "contentlengthFound", "contentSizeValid"]}}
{"id1": "2017833", "id2": "6517139", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["hex", "parse", "update", "read", "dump", " fingerprint", "check", "message", "to", "print", "write", "transform", " hashing", "str", "code", "test", "sign", "replace", "string", "render", "sha", " digest", "Hash", "sum", "tag", "hello", "format"], "text": ["Text", "t", "read", "document", "cont", "path", "url", "TEXT", "prefix", "value", "ct", "now", "name", "message", "buffer", "v", "password", "print", "log", "content", "event", "out", "q", "source", "str", "select", "code", "test", "txt", "output", "act", "title", "string", "pattern", "input", "word", "nt", "ext", "body", "config", "form", "comment", "data", "msg", "aut", "tx", "translation", "format", "command", "pt"], "UnsupportedEncodingException": ["UnsupportedEncryptionException", "UnsupportedEncryptionError", "UnsupportedEncoderFailure", "UnsupportedEncodingError", "UnsupportedEncensionError", "UnsupportedEncodingFailure", "UnsupportedDecodingFailure", "UnsupportedEncoderError", "UnsupportedDecodingError", "UnsupportedEncryptionFailure", "UnsupportedDecoderException", "UnsupportedDecoderFailure", "UnsupportedDecoderError", "UnsupportedEncoderException", "UnsupportedEncensionException", "UnsupportedDecodingException", "UnsupportedEncensionFailure"], "md": ["mod", "m", "ms", "ad", "det", "pd", "df", "amd", "ld", "mk", "dh", "mc", "h", "pm", "add", "MD", "di", "ct", "ind", "rm", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "pdf", "sha", "der", "hd", " Md", "red", "mand", "grad", "and", "dd", "dir", "d"], "sha1hash": ["ha3hash", "ha1Hash", "sha512h", "sha5Hash", "sha512dig", "sha2hex", "sha1h", "haonehex", "ha2Hash", "shaoneHash", "sha512hash", "sha1sum", "ha3sum", "haonehash", "sha5hash", "haonesum", "sha512Hash", "ha3Hash", "sha5hex", "sha11hash", "ha1h", "sha11Hash", "sha1hex", "shaonesum", "ha2hash", "sha2h", "shaonehash", "sha5sum", "ha3key", "ha1dig", "sha3key", "sha1key", "shaonehex", "sha3hash", "ha1hex", "sha1dig", "sha11h", "ha1key", "sha2hash", "sha5key", "sha2sum", "sha2dig", "ha1hash", "sha3Hash", "sha11dig", "sha3sum", "haoneHash", "sha1Hash", "sha2key", "sha2Hash", "ha2h", "ha2dig", "ha1sum"]}}
{"id1": "9081749", "id2": "20663364", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"encrypt": ["Encrypt", "compress", "comprypt", "cress", "Encress", "crypted", "encryption", "compryption", "encrypted", "crypt", "cryption", "comprypted", "encress", "Encryption", "Encrypted"], "password": ["pass", "secret", "email", "phrase", "picture", "expression", "Password", "total", "path", "default", "username", "prefix", "secure", "value", "address", "name", "message", "p", "sword", "reset", "account", "padding", "confirmed", "request", "source", "wordpress", "user", "string", "pattern", "push", "token", "word", "input", "database", "past", "PASS", "description", "comment", "hello", "key", "wd", "text", "chain", "command", "shadow", "attribute"], "encryptType": ["encjectType", "encryptionClass", "encryptTy", "encreatTy", "encreatype", "escryptionype", "encreatStyle", "ethryptType", "ethjectTYPE", "encjectTYPE", "encrypttype", "encryptionTy", "encribeTy", "encryptionStyle", "ethrypttype", "encveyType", "encryptClass", "ethryptTYPE", "encribeStyle", "encryptiontype", "escryptStyle", "encribeType", "encveytype", "encryptionType", "encribeype", "encveyClass", "escryptTy", "encryptionype", "escryptionStyle", "encjecttype", "encveyTYPE", "encryptionTYPE", "ethjectClass", "ethjecttype", "escryptionType", "encreatType", "ethryptClass", "encjectClass", "encryptStyle", "ethjectType", "encryptTYPE", "encryptype", "escryptype", "escryptionTy", "escryptType"], "md": ["mod", "m", "ms", "ad", "det", "pd", "df", "ld", " MD", "mk", "dh", "mc", "add", "nd", "rd", "MD", "di", "ct", "del", "ind", "cd", "mn", "obj", "mt", "od", "bd", "mb", "sm", "sd", "me", "de", "cmd", "dm", "mm", "metadata", "dr", "ds", "pdf", "der", "nt", "man", "hd", "red", " Md", "mand", "grad", "down", "dd", "dir", "d"], "hash": ["handle", "hex", "shift", "hz", "length", "mac", "sample", "total", "where", "how", "h", "oh", "has", "score", "host", "stock", "ash", "block", "check", "sh", "square", "sort", "address", "color", "filter", "dig", "map", "print", "here", "cache", "number", "mask", "height", "window", "ashes", "test", "replace", "search", "all", "style", "char", "sha", "esh", "Hash", "show", "sum", "query", "html", "her", "box", "match", "array", "hello", "rh", "stack"], "hexString": ["exstring", "jsonString", "hexstring", " hexResult", "hashArray", "pexList", "hexResult", "octStatement", " HexStr", "octArray", "xfstring", "hexArray", "hexStatement", " hexList", "exResult", "hashString", "exService", "exStr", "xfStatement", " hexService", " hexstring", " hexStr", " HexResult", "octstring", "hashBuffer", "exString", "exBuffer", "octString", "jsonArray", "hexStr", " Hexstring", "xfString", "hexService", "pexService", " hexArray", "hexList", "xfArray", "exStatement", " HexString", "pexArray", "exList", "pexString", "hexBuffer", "jsonBuffer", "hashStr", "exArray", "jsonStr"], "i": ["info", "ji", "m", "iq", "ci", "u", "im", "in", "phi", "j", "gi", "ii", "gu", "qi", "c", "my", "I", "mi", "ti", "a", "oi", "pi", "it", "e", "di", "ui", "ski", "list", "id", "this", "y", "v", "multi", "ic", "uri", "io", "ai", "\u0438", "x", "n", "me", "iu", "bi", "set", "ex", "ip", "cli", "init", "exp", "si", "ie", "ki", "index", "point", "sim", "li", "ix", "gravity", "json", "xi", "ami", "is", "ei", "major"]}}
{"id1": "16621499", "id2": "23199071", "code1": "    public static byte[] loadURLToBuffer(URL url) throws IOException {\n        byte[] buf = new byte[4096];\n        byte[] data = null;\n        byte[] temp = null;\n        int iCount = 0;\n        int iTotal = 0;\n        BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480);\n        while ((iCount = in.read(buf, 0, buf.length)) != -1) {\n            if (iTotal == 0) {\n                data = new byte[iCount];\n                System.arraycopy(buf, 0, data, 0, iCount);\n                iTotal = iCount;\n            } else {\n                temp = new byte[iCount + iTotal];\n                System.arraycopy(data, 0, temp, 0, iTotal);\n                System.arraycopy(buf, 0, temp, iTotal, iCount);\n                data = temp;\n                iTotal = iTotal + iCount;\n            }\n        }\n        in.close();\n        return data;\n    }\n", "code2": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "label": 0, "substitutes": {"loadURLToBuffer": ["loadUrlToBytes", "loadURL2Bytes", "loadURLToBuff", "loadUrl2Buff", "loadURLtoBuff", "loadUrlToBuffer", "loadUrlToBuff", "loadURLToBytes", "loadURL2Buffer", "loadURLtoBytes", "loadUrl2Bytes", "loadUrl2Buffer", "loadURLtoBuffer", "loadURL2Buff"], "url": ["pl", "bel", "ur", "http", "link", "b", "ls", "base", "gl", "address", "name", "uri", "l", "log", "sl", "r", "nl", "str", "loader", "location", "ssl", "page", "char", "Url", "web", "mail", "html", "el", "ul", "xml", "file", "ll", "job", "dl", "open", "cert", "URL", "browser"], "buf": ["bar", "bh", "bt", "buff", "b", "bn", "bs", "cap", "mu", "pkg", "batch", "font", "desc", "Buffer", "mus", "vec", "fb", "buffer", "bo", "uf", "log", "queue", "str", "Buff", "seq", "cmd", "bl", "txt", "cat", "ctx", "dat", "bag", "rb", "img", "tr", "br", "conv", "tmp", "div", "capt", "nt", "bp", "db", "cb", "cv", "bytes", "box", "msg", "BU", "tx", "axe", "nb", "bc", "bu", "arr"], "data": ["info", "ata", "buff", "part", "bo", "str", "json", "type", "done", "table", "DATA", "default", "it", "raw", "di", "map", "to", "out", "action", "step", "dat", "bytes", "result", "ret", "length", "total", "mu", "zero", "batch", "list", "this", "buffer", "obj", "rel", "res", "good", "txt", "all", "def", "br", "tmp", "next", "initial", "msg", "format", "text", "arr", "item", "null", "a", "results", "value", "count", "name", "message", "p", "image", "content", "dec", "cache", "only", "no", "set", "output", " DATA", "missing", "bin", "partial", "nt", "div", "size", "bus"], "temp": ["ret", "porary", "tt", "tim", "mod", "tc", "null", "t", "pos", "buff", "alt", "variable", "fake", "util", "font", "tar", "EMP", "mem", "buffer", "v", "unit", "deg", "cache", "emp", "term", " Temp", "ta", "pre", "em", "test", "txt", "mm", "unt", "dat", "met", "copy", "dest", "template", "partial", "current", "tr", "tmp", "nom", "div", "ptr", "rem", "tm", "mont", "vol", "tem", "mp", "Temp", "result", "pt"], "iCount": ["iniCount", "iriNow", "uiCount", "iuTotal", "jTotal", "piCounter", "jCount", "biTotal", "piTotal", "giCount", "iCall", "iiTotal", " iNumber", "iriProcess", "iLength", "iuCounter", "iiCall", "uiTotal", "liTotal", "biCheck", "iriCount", "giCounter", " iCounter", "iiCategory", "liCall", "intCategory", " iCode", "biCode", "ciCounter", "ciCP", "piLength", "iiProcess", "iNumber", "iiCounter", "ciCount", "jcount", " iCheck", "aicount", "aiLength", "iCheck", "iCP", "iMark", "aiTotal", "intProcess", "diTotal", "giLength", "phiMark", "uiCounter", "iProcess", "liCounter", "phiCount", " icount", "phiLength", "iiCount", "iNow", "iCategory", "iCounter", " iLength", "icount", "iuCP", "diCounter", "diCount", "iuCount", "iniMark", "aiCount", " iMark", "piCP", "liCount", "intCount", "dicount", "jLength", "phiNumber", "ciTotal", "uiCall", "iriCategory", "intNow", "iCode", "giTotal", "giCode", "piCount", "iniNumber", "iniLength", "iiNow", "aiCounter", "biCount", "giCheck"], "iTotal": ["jNow", "jZero", "mitotal", " iParent", "miNew", "iuTotal", "jTotal", "diNow", "jCount", "iFull", "piTotal", "ciAll", "liNew", " iTemp", "miAll", "iuTarget", "iZero", "iParent", "iuLast", "aiToken", "miComplete", "iiTotal", " iZero", "uiTotal", "liTotal", "phiLast", "iitotal", "miToken", "imtotal", " iNow", "iToken", "liTemp", "ciToken", " iLast", "miZero", "iDone", "iiZero", "liParent", "aiTotal", "iTarget", " iFull", " iCurrent", "uiDone", "diTotal", "piFull", "phiTemp", "imCount", "iLast", "ditotal", " itotal", "ciComplete", " iNew", "itotal", " iTarget", "iiCount", "jtotal", "iComplete", "miTotal", "phiTotal", "iNow", "imZero", "iNew", "jCurrent", "iAll", "diCount", "imTotal", "aiAll", "liCount", "phiNew", "ciTotal", "liLast", "aiComplete", "miTarget", "piCount", "piDone", "iTemp", "piParent", "iuNew", "uiFull", "miLast", " iDone", "iCurrent", "miCurrent"], "in": ["info", "re", "per", "b", " din", "mc", "h", "get", "up", "cin", "it", "on", "add", "or", "check", "inf", "inn", "ind", "v", "mn", "ins", "l", "ic", "io", "r", "by", "reader", "inc", "out", "al", "IN", "from", "mm", "en", "isin", "bin", "inner", "con", "input", "conf", "din", "sum", "ma", "i", "is", "serv", "and", "In"]}}
{"id1": "2668634", "id2": "9846843", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"inputName": ["inputNames", "inputFilename", "interfaceFilename", "outputPath", "inputPath", "InputNames", " inputPath", "interfacePath", "InputName", " inputFile", "interfaceName", "InputFilename", "InputFile", "outputFile", "inputFile", "interfaceFile", " inputNames", "outputNames", "InputPath", "outputFilename"], "outputName": ["OutputName", "inputNames", " outputNames", "outputPath", "inputPath", " outputPath", "outputPort", "inputPort", "OutputPort", "outputType", " outputType", "OutputNames", "outputDir", "OutputPath", " outputDir", "OutputDir", "inputDir", "outputNames", "inputType", "OutputType", " outputPort"], "stripLoggers": ["stripDebugReferences", "skipLogger", "stripPathReferences", "skiploggers", "striploggers", "stripDebugger", "skiplogReferences", "skipLogging", "stripDebugging", "skipLogReferences", "striplogReferences", "stripPathgers", "striplogger", "stripPathger", "stripLogger", "stripLogging", "stripPathging", "skiplogger", "stripLogReferences", "stripDebuggers", "striplogging", "skipLoggers", "skiplogging"], "tempFile": [" tempDirectory", "TempFile", "tempField", " temporaryDirectory", " tempfile", "tmpPath", "tempPath", "tmpPlace", "Tempfile", " tempPath", "empField", "temFile", "tempDir", "tempDirectory", "empFile", " temporaryfile", " tempDir", "tempfile", " temporaryDir", "tmpFile", "tmpField", "tmpfile", "empLock", " temporaryField", "TempPlace", "tmpLock", "TempDirectory", "tempPlace", "empfile", "TempDir", " tempPlace", "temDir", "TempPath", "temPath", " temporaryLock", "tempLock", " temporaryFile", "temfile", "tmpDir"], "jin": ["gin", "jon", "lah", "zin", "pai", "spin", "zip", "nin", "olin", "yang", "thin", "lig", "jo", "erb", "rake", "cin", "pak", " inj", "lu", "ini", "quin", "zon", "rir", "rin", "von", "pin", "kin", "inx", "jet", "ja", "ln", "jiang", "nu", "ju", "txt", "lin", "bin", "jp", "jad", "alin", "tin", "jl", "din", "jing", "john", "tan", "rison", "json", "via", "jen", "jac", "xi", "JR", " Jin", "ran", "jc", "vin", "nik"], "jout": [" jou", "jpout", "zout", "zou", "qaos", "jsin", " jio", "qou", "jou", " jaos", "jpin", "qout", "jsout", "zio", "jOut", "jaos", " jOut", "qio", "zaos", "jsOut", "jpOut", "jio"], "srcChannel": ["sourceCh", "srcCh", "srcchannel", "sourcechannel", " srcchannel", "sourceChannel", "rcCh", " srcChan", "srcChan", "rcChannel", "rcchannel", "sourceChan", "rcChan", " srcCh"], "dstChannel": ["ddestCh", "dgtChannel", " ddestCh", "ddestChannel", "dstCh", " dstChan", "doutChannel", "dgtFile", "doutFile", "dgtCh", " ddestFile", "dstChan", "ddestFile", "doutChan", "ddestChan", " ddestChannel", "dstFile", " dstFile", " dstCh", "dgtChan", " ddestChan", "doutCh"], "portletApplicationName": ["portletApplicationCode", "portletCollectionCode", "portletCollectionName", "portableApplicationType", "portletApplicationType", "portletServiceName", "portletApplicationOrder", "portableAppOrder", "portletapplicationKey", "portletapplicationName", "portableApplicationCode", "portletAppValue", "portableApplicationKey", "portletApplicationKey", "portletAppCode", "portableApplicationName", "portableAppName", "portletServiceOrder", "portletCollectionValue", "portletAppOrder", "portletAppName", "portableAppKey", "portableApplicationValue", "portletAppType", "portableAppType", "portletapplicationType", "portableApplicationOrder", "portletCollectionType", "portletServiceKey", "portletAppKey", "portletApplicationValue", "portletServiceType", "portletapplicationOrder"], "webXml": ["webXm", "webXMxml", "webMom", "webExxml", "webXMm", "webTxlim", "webTxML", "webTxm", "webYom", "WebTxpl", " webYaml", " webXaml", " webTxlim", "webXlim", "webXMaml", " webTxml", "webWorkxml", "WebTxm", "webTxpl", "webTxml", " webYml", "webMML", "WebTxxml", " webXom", "webWorkml", "webExml", "webXom", " webYom", "webXMlim", "webXpl", "WebXpl", "webMml", "webMaml", "WebXML", " webTxML", "webExML", "WebXxml", "WebTxML", " webTxxml", "webExm", " webXML", "webWorklim", "webYaml", "webYpl", "webXMom", "webWorkML", " webXlim", "webYML", "webXMml", "WebTxml", "webXML", "webXxml", "webTxxml", "webYxml", "webXMpl", "WebXm", "WebXml", "webXaml", "webYml", "webXMML", " webXxml", " webYML"], "portletXml": ["portletExml", "portletEbl", "portantXml", "portletYql", "portableXml", "portletHeng", "portableYxml", "portvetXMml", "portvetXMxml", "portletYxml", "portletEml", "portletXMml", "portableYql", "portletTxxml", "portletHexml", "portletEng", "portableXML", "portletXMbl", "portletHeML", "portletTxml", "portantXxml", "portantTxxml", "portvetXml", "portletYML", "portletTxql", "portantTxml", "portvetXxml", "portletTxML", "portletXMML", "portantTxML", "portletXMxml", "portvetXMbl", "portletXMql", "portvetXng", "portableYML", "portableXql", "portableYml", "portvetXMng", "portletYng", "portletYbl", "portletXng", "portletXML", "portletXxml", "portletHeml", "portletYml", "portletXMng", "portletTxng", "portableXxml", "portletXbl", "portantXng", "portvetXbl", "portletXql", "portantTxng", "portantXML"], "contextXml": ["contextCaml", "contextXtml", "contextYaml", "contextCML", "ctxXiML", "ctxXtml", "contextAxmx", "contextCml", "ctxXiaml", "ctxXaml", "ctxXiml", "contextEml", "ctxXML", "contextXiML", "componentYmm", "contextXML", "componentYML", "ctxXml", "contextYtml", "contextAxML", "contextEmm", "contextEmx", "contextCtml", "contextXitml", "componentXmm", "componentYml", "contextAxmm", "contextYml", "contextAxml", "ctxXitml", "contextXiaml", "contextYmx", "componentYmx", "contextYmm", "componentXML", "contextEML", "contextXmx", "componentXml", "componentXmx", "contextXaml", "contextYML", "contextXmm", "contextXiml"], "src": ["sit", "bh", "sc", "sing", "rob", "zh", "SOURCE", "sel", "https", "rc", "cont", "syn", "url", "secure", "scope", "su", "desc", "ser", "sq", "sp", "ind", "resource", "obj", " sou", "buster", "sl", "cur", "proc", "sol", "sup", "str", "rel", "ln", "st", "from", "txt", "ctr", "sb", "sn", "kk", "dest", "ie", "supp", "sec", "usr", "sr", "tmp", "slice", "comp", "via", "sys", "addr", "Source", "inst", "loc", "skin", "entry", "ident", "filename", "crit"], "source": ["sql", "null", "zip", "in", "sample", "table", "SOURCE", "get", "base", "stream", "se", "it", "scope", "raw", "secure", "parent", "ser", "store", "check", "sp", "iterator", "context", "sequence", "resource", "unit", "buffer", "spec", "image", "seed", "reader", "feature", "service", "console", "ource", "single", "site", "set", "iter", "start", "from", "origin", "copy", "state", "inner", "style", "template", "tree", "ie", "input", "instance", "dest", "sum", "query", "session", "Source", "file", "size", "channel", "format", "entry", "status", "series", "result", "shell"], "zipEntries": ["ipEires", "zipEables", "zoneEnries", "ZipEntries", "Zipentries", "zipEntities", "zipEnies", "zipEities", "zoneEnies", "zipEntarts", "zoneEntities", "zipEntriers", "zipEntryires", "zipErs", "zipenties", "ipEntires", "zipEnities", "zipentities", "zoneEnables", "ZipEntrs", "zoneEnities", "zipEntires", "zipEriers", "ZipEntriers", "zipEnts", "zipentrs", "zipIntrs", "zipEnties", "ipEntarts", "zipEnires", "zipentriers", "zipentries", "Zipenties", "ZipEnties", "zipIntriers", "zipEntrys", "ipEries", "zipEarts", "ipEarts", "zipEnarts", "Zipentrs", "zoneEntries", "ipEntries", "zipEnables", "zipEntryries", "zipEies", "zoneEnties", "zipEntryarts", "Zipentriers", "ipEs", "zipEires", "zipEs", "zipEns", "zipIntries", "zipEntables", "zipEntrs", "zipentables", "zipInties", "zoneEntables", "zipEnries", "ipEnts", "zipEries"], "target": ["project", "module", "t", "text", "goal", "table", "tif", "gt", "pkg", "url", "host", "top", "compatible", "base", "scope", "version", "parent", "peer", "name", "arg", "buffer", "resource", "primary", "owner", "Target", "layout", "route", "term", "rel", "controller", "test", "bolt", "local", "location", "title", "alias", "template", "pattern", "class", "tag", "task", "arget", "match", "chain", "tool", "format", "family", "type", "label", "filename", "handle", "prop", "result"], "webRewriter": ["webRebactor", "webRewrite", "webWriter", "File", "_", "webRewactor", "Entry", "webWactor", "cont", "WebWriter", "WebRewler", "webRewler", "get", "aos", "webWler", "Supp", "New", "log", "webRepactor", "Input", "Log", "webRepriter", "webRebler", "impl", "WebWrite", "WebRewriter", "webWrite", "webRebrite", "webRepler", "WebRewrite", "webRebriter", "WebWler", "webReprite", "json", "println", "WebWactor", "WebRewactor", "entry"]}}
{"id1": "9550506", "id2": "4852691", "code1": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"cookieString": ["cookieStr", " cryptByte", " challengeStr", " cryptHash", "cookieHash", " challengeByte", " cookieStr", " cryptBytes", " cookieByte", " cookieHash", " cookieBytes", "cookieBytes", " cryptStr", " challengeBytes", " challengeHash", "cookieByte"], "url": ["domain", "lr", "ur", "api", "http", "hl", "https", "path", "ls", "host", "get", "gl", "util", "home", "address", "uri", "l", "log", "sl", "mount", "www", "ssl", "Url", "mail", "web", "ul", "el", "addr", "file", "ll", "loc", "remote", "dl", "URL", "browser"], "ip": ["domain", "api", "zip", "email", "http", "mac", "pkg", "path", "host", "secure", "prefix", "ips", "cp", "sp", "address", "id", "name", "client", "p", "port", "uri", "password", "skip", "chip", "origin", "tip", "ep", "iv", "app", "i", "addr", "arp", "loc", "IP", "et", "net"], "md": [" ms", " ma", "m", "ms", " mm", " dd", "det", "pd", "df", "ld", " MD", "managed", "mk", "dh", "mc", "hm", "pm", "nd", "MD", "mem", "ng", "del", " del", "ind", " m", "cd", "mn", "mt", "od", "bd", " mo", "sm", " mc", "mg", "sd", " mt", " sd", "cmd", "dm", "mm", "met", "metadata", "dr", "td", "def", "der", "sha", "nt", "ma", "ke", "hd", "red", " Md", " sm", "grad", "mp", " cmd", "dd", "d"], "hash": ["bh", "sample", "mac", "amd", "total", "h", "ref", "has", "uh", "ash", "check", "sh", "sq", "message", "this", "kernel", "password", "sam", "cache", "mask", "magic", "sha", "Hash", "hed", "index", "sum", "checked", "tag", "hd", "html", "her", "key", "rh", "shadow", "ho"]}}
{"id1": "10936821", "id2": "13233761", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"doIt": ["DoWhat", " doWhat", "doThis", " doWhatever", "DoThis", " doThis", "makeWhatever", "makeThis", "DoWhatever", "doWhatever", "makeWhat", "doWhat", "DoIt", "makeIt"], "client": ["dial", "api", "http", "cloud", "simple", "close", "key", "url", "open", "secure", "util", "cc", "ct", "socket", "parent", "cell", "connection", "resource", "to", "control", "wrapper", "call", "service", "conn", "cl", "cache", "console", "quick", "cmd", "utils", "local", "cli", "google", "ssl", "pattern", "template", "lib", "con", "core", "server", "network", "web", "cm", "pool", "connect", "force", "co", "channel", "response", "remote", "contact", "phone", "Client", "net"], "ff": ["ft", "fact", "df", "buff", "tif", "pp", "fp", "aft", "bf", "nd", "alf", "xff", "fm", "aff", "uf", " fid", "FF", "off", "sf", "fo", "cl", "fx", "cf", "fc", "ck", "lf", "ef", "ph", "ffer", "eff", "cb", "uff", "af", "tf", "fd", "fi", "fg", "dd"], "jfc": [" jcf", " jFC", "Jpc", "tcf", "Jfc", "lvc", "jsfc", "fcf", "ncf", "flc", "jsFC", "npc", "lcf", "jFC", "nfc", " jvc", " jpc", " jlc", "JFC", "tFC", "nFC", "jspc", "jpc", " jmc", "jsmc", "jlc", "lfc", "ffc", "llc", "qFC", "fvc", "tpc", "tfc", "jcf", "jvc", "jmc", "Jmc", "qcf", "Jcf", "qpc", "qfc"], "f": ["m", "t", "w", "fab", "df", "b", "c", "F", "h", "bf", "e", "inf", "v", "p", "l", "rf", "sf", "fo", "only", "fs", "g", "fx", "cf", "fc", "lf", "ef", "i", "file", "fd", "fi", "tf", "fg", "xf", "fa"], "selection": ["ification", "which", "slot", "opening", "selected", "sel", " selecting", "where", "security", "ion", "choice", "election", "soc", "xxx", " selected", "binding", "connection", "SELECT", "focus", "finding", "ing", "lection", "select", " Selection", "from", "location", "sea", "search", "state", "icing", "position", "something", "elect", "wa", "reading", "pling", "ION"], "msg": ["info", "ms", "bg", "cmp", "Msg", "resp", "cal", "mu", "pkg", "og", "mk", "wx", "gr", "desc", "nm", "mem", "message", "md", "mn", "summary", "map", "log", "print", "news", "mess", "doc", "mb", "sm", "gs", "mg", "str", "g", "cmd", "dm", "txt", "init", "sg", "comm", "cfg", "ck", "conf", "notice", "irm", "body", "sum", "alg", "gm", "mail", "html", "sys", "task", "comment", "gent", "crit"]}}
{"id1": "873012", "id2": "23152865", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"url": ["pl", "domain", "sql", "bel", "ur", "http", "link", "b", "ld", "un", "path", "ref", "ls", "get", "base", "gl", "util", "default", "address", "name", "resource", "uri", "l", "log", "sl", "r", "nl", "rl", "cl", "q", "term", "str", "mount", "impl", "location", "string", "ssl", "page", "pattern", "char", "Url", "web", "config", "el", "html", "xml", "external", "file", "loc", "job", "dl", "ll", "key", "URL", "browser"], "in": ["gin", "m", "null", "include", "read", "nin", "update", " din", "c", "oin", "mc", "o", "mi", "In", "cin", "line", "on", "check", "inn", "name", "min", "ins", "login", "l", "rin", "f", "s", "reader", "ai", "out", "al", "source", "n", "ln", "IN", "from", "init", "en", "isin", "bin", "inner", "con", "input", "again", "din", "body", "ma", "i", "online", "is", "serv", "vin"]}}
{"id1": "14688886", "id2": "22264586", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"populateResources": ["popureFiles", "PopureResources", "PopureResource", "populatedReferences", "populatedResource", "populateReferences", "populatesResource", "popureReferences", "populatesReferences", "populateFiles", "populatedFiles", "PopureReferences", "populatesResources", "popureResources", "PopulateResource", "PopureFiles", "populatesFiles", "populatedResources", "PopulateReferences", "populateResource", "PopulateFiles", "PopulateResources", "popureResource"], "templates": ["tctions", "memables", "tmples", "memeters", "tplates", " temables", "temports", "tmplates", "temctions", "temmen", "temeters", "tables", "memples", "Temmen", "filplates", "temporary", "teters", "tyables", "Temples", "temables", "filports", "filples", " temctions", "sequeters", "tmports", "sequplates", "sequporary", "tples", "filmen", "tenplates", "tenctions", "temiles", "timplates", "tmmen", "timporary", "Templates", "timples", " temiles", "Temports", "sequples", "tenables", "typlates", "memplates", "tiles", "teniles", "typles", "timeters", "temples", "tmporary", "tmeters", "tyeters"], "url": ["pl", "m", "row", "item", "u", "ur", "http", "link", "b", "path", "ref", "a", "get", "base", "gl", "e", "ml", "address", "name", "p", "resource", "uri", "l", "f", "sl", "r", "nl", "mb", "rl", "term", "n", "res", "rel", "mount", "rect", "location", "ssl", "string", "pattern", "char", "li", "Url", "mail", "web", "html", "file", "dl", "ll", "entry", "key", "handle", "URL", "browser"], "fileName": ["filenamePart", " filename", " fileKey", "familyTime", "fileBody", "filePart", "filenameName", "nameParent", "blockTime", "nameName", "FILEname", "urlKey", "FileName", "filenamename", "templatename", "FileKey", "resourceKey", "filename", "ilePath", "ilename", " fileFamily", "tilename", "fileLine", "fileTime", "FileString", "moduleTitle", " filePath", " filePart", "urlPath", "FILECopy", " fileString", " fileTime", "namename", " fileParent", "ileLine", "FileFamily", "ileFull", "fileFull", "filePath", "fileParent", "fileString", "fileFamily", " fileTitle", "familyLoad", "tileName", "templateName", "templatePath", "blockName", "blockLoad", "fileCopy", "FILELine", "ileCopy", "FILEName", " fileLoad", "fileLoad", "templateString", "fileType", "resourceTitle", " fileType", "blockname", "fBody", "fPath", "tileCopy", "FilePart", "Filename", "FileBody", "moduleKey", "fName", "ileName", " fileBody", "moduleName", "ilePart", "urlName", "fileTitle", "namePart", "familyName", "resourceName", "fileKey", "moduleType", "FilePath", "FileFull", "urlFamily", "resourceType", "familyname", "fname", " fileFull", "tileLine", "filenameParent"], "templateResource": ["TemplateResource", "resourceEntry", " templateEntry", "TemplateResources", "documentResource", " templateProperty", "TemplateProperty", "resourceRole", "componentResources", " templateReference", "resourceRes", " templateResources", " templateRole", "documentRes", " templateRes", "templateReference", "resourceResource", "resourceProperty", "templateEntry", "documentRole", "templateRes", "componentRes", "TemplateEntry", "componentResource", "TemplateRes", "templateResources", "templateRole", "templateProperty", "componentReference", "TemplateReference"], "is": ["os", "sis", "isl", "im", "in", "bs", "us", "ios", "lis", "isi", "its", "isc", "sels", "es", "iss", "ins", "ic", "isf", "ir", "fs", "rys", "iris", "nis", "rs", "ri", "\u00eds", "ris", "iso", "fr", "sys", "as", "IS", "Is", "ais", "bis", "isa", "are"], "strBuff": ["strComp", "brBuff", "arrBas", "strbuff", "StrBuffer", " strComp", "brBuffer", " strBuffer", " strComb", "strBuffer", "arrFac", "stringComb", "strBu", "arrComb", "strFac", "stringBas", "strBas", "Strbuff", " strFac", "arrBuff", "stringBuffer", " strBu", "strComb", "stringBuff", "brComp", "StrFac", " strbuff", "arrbuff", "StrBuff", "brBu", "drBuffer", "arrBuffer", "drBuff", "drBu", " strBas", "drComp"], "br": ["bt", "bg", "bh", "shr", "lr", "bs", "b", "bn", "ch", "Br", "bf", "gr", "bm", "yr", "er", "r", "bd", "wr", "hr", "buf", "bi", "bl", "ctr", "cr", "dr", "rb", "bro", "tr", "BR", "sr", "bp", "next", "pr", "fr", "kr", "ber", "vr", "bc", "mr"], "str": ["t", "err", "cont", "coll", "Str", "gr", "del", "sp", "name", "list", "cs", "p", "St", "obj", "s", "spec", "print", "stable", "r", "sl", "ocr", "n", "g", "res", "seq", "st", "bl", "set", "txt", "ctr", "cr", "sts", "string", "pt", "dr", "ust", "tr", "pr", "draw", "fr", "msg", "chain", "text", "cert", "STR", "arr"], "images": ["faces", "styles", "modules", "ms", "frames", "eds", "eps", "actions", "ages", "arms", "versions", "rooms", "vs", "raphics", "resources", "pages", "ups", "videos", "files", "media", "amps", "views", "image", "ins", "items", "pins", "uploads", "blocks", "Images", "assets", "games", "ids", "thumbnails", "scripts", "types", " pictures", " photos", "photos", "xs", "reports", "times", " Images", "Textures", "names", "apps", "atts", "ims", "boxes"], "i": ["info", "m", "http", "I", "us", "get", "y", "io", "x", "me", "ie", "index", "u", "Exception", "gi", "j", "pi", "it", "di", "ai", "bi", "li", "key", "status", "im", "phi", "ii", "mu", "qi", "my", "ti", "ini", "hi", "this", "v", "multi", "n", "ip", "cli", "def", "ij", "ki", "xi", "ei", "ci", "_", "gu", "mi", "ui", "id", "name", "p", "si", "sim", "ix", "ami"], "img": ["av", "src", "m", "bg", "gd", "im", "Image", "pic", "jpg", "j", "pkg", "mk", "a", "fm", "png", "aug", "pg", "p", "image", "md", "obj", "amp", "f", "r", "medium", "anim", "g", "mg", "buf", "bl", "att", "iam", "small", "gif", "imp", "ij", "tmp", "div", "li", "gm", "html", "ami", "file", "fig", "mp"], "imgProperty": [" tmpImage", " tmpPro", " tmpProperty", "imageProp", "imagePro", " imgProp", "imgImage", "imgProp", "imageImage", " tmpProp", " imgImage", " imgPro", "imgPro", "imageProperty"]}}
{"id1": "5551393", "id2": "1097146", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD2", "getmd5", "getmd4", "getMD4", "getmd3", "getmd2", " getMD4", "getMD3", "getSHA5", " getMD2", "getSHA3", "getSHA4", "getSHA2", " getMD3"], "source": ["src", "sample", "SOURCE", "object", "url", "base", "value", "reason", "space", "now", "name", "message", "context", "image", "filename", "sequence", "s", "spec", "resource", "seed", "content", "ource", "site", "from", "output", "start", "string", "template", "style", "input", "body", "target", "force", "config", "Source", "data", "file", "subject", "text"], "tmp": ["perm", "tt", "m", "src", "bt", "cmp", "t", "aaa", "po", "buff", "pp", "rup", "pkg", "attr", "managed", "mk", "resp", "tn", "cont", "tar", "nd", "found", "bb", "cp", "sp", "snap", "p", "obj", "mobi", "temp", "cache", "out", " mp", "gb", "np", "buf", "test", "txt", "output", "etc", "bag", "jp", "img", "input", "foo", "nt", "lambda", "db", "cb", "cv", "msg", "data", "MP", "mp", "Temp", "qq", "result"], "md": ["mod", "m", "ms", "ad", "det", "pd", "df", "mac", "amd", "ld", " MD", "mk", "dh", "pm", "nd", "desc", "MD", "di", "ind", "rm", "cd", "mn", "mt", "od", "bd", "sam", "mb", "sm", "sd", "de", "cmd", "dm", "mm", "dr", "td", "pdf", "der", "nt", "hd", "red", " Md", "mand", "mp", "wd", "and", "dd", "d"]}}
{"id1": "13657103", "id2": "20920051", "code1": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"forBundle": [" manageBunch", " processEmbasket", " processRebundle", " processEmbunch", " processRebunch", " manageRebranch", " processPasket", " processPundle", " processBunch", " manageRebunch", " manageRebundle", " processBranch", " processBasket", " processPunch", " processEmbranch", " processPranch", " processEmbundle", " manageRebasket", " manageBranch", " processRebranch", " manageBundle", " manageBasket", " processBundle", " processRebasket"], "manip": ["Manip", " ManIP", "manop", "emanip", "emanipper", " Manap", "managerip", " Manip", "Manup", "manipper", "emaniper", "manIP", "manips", " manap", "MANap", "MANIP", "emanIP", "emanap", "damipper", "emanup", " maniper", "managerop", "Manips", "MANip", "emanop", "manap", "Manop", "Manap", "maniper", "damiper", " Manips", "damip", "managerup", " manipper", "MANips", "managerIP", "ManIP", "damap", "manup"], "bout": ["bbio", "bbouts", "zin", " boff", "zOUT", "bOut", "zou", "zOut", "bbOut", "wpool", "bOUT", " bio", "boff", " bou", "bbop", "BOUT", "Bout", " bin", "bpool", "zouts", "wop", "wou", "wout", "Boff", "bouts", "bio", "bou", "bin", "Bin", "zoff", "zio", " bOUT", " bOut", "bbpool", "bbout", " bpool", " bop", "wOut", " bouts", "bop"], "zout": ["tzout", "zin", "zerouts", "zoend", "zOUT", "zou", "zippool", " zin", " zoss", "ezOUT", " zouts", "zend", " zos", "zOut", "zoneout", "wpool", "ozoss", "zoneouts", "zoent", "zoneOut", "azout", "azouts", "ezout", "zeOut", "ozou", "zipouts", "ezos", "zeout", " zaos", "zerout", "zouts", " zou", "zipin", " zent", "wout", "ozout", "ozos", "azOut", "zipnet", " zall", "zoss", "zent", "tzOUT", "zall", "win", "zoouts", "zos", "ozOUT", "zein", "zoout", "zenet", "zoneaos", "zpool", "zipaos", "ozall", "azin", " zend", "znet", "zipOut", "wouts", "zaos", " znet", " zOUT", " zOut", "tzoss", "zerend", "zipout", "wOut", " zpool", "zerent", "tzall", "ezou"], "bundle": ["brundle", "pbkg", "pbulk", "bigration", "masket", "boigration", "brasket", "sbound", "rbkg", " bund", "mond", "rbundle", "mbund", "abulk", "rbulk", "bond", " bulk", "bund", "sbasket", "mund", " bond", "abigration", "bound", "bkg", "lasket", "pbundle", "sbund", " basket", "boulk", "abundle", "rbasket", "boasket", "basket", "mbasket", " bkg", "abasket", "sbundle", "boundle", "brulk", "mbond", "brigration", "lundle", " bound", "pbasket", "lound", "bulk", "mundle", "mbundle", "lund"], "files": ["faces", "styles", "bees", "actions", "features", "forms", "pages", "Files", "balls", "ls", "resources", "rows", "facts", "roots", "lets", "results", "runs", "issues", "books", "ails", "seconds", "users", "values", "ures", "stores", "items", "lines", "fields", "assets", "fs", "les", "ids", "rules", "groups", "headers", "organisms", "links", "objects", "plates", "keys", "ds", "types", "ports", "photos", "leases", "iles", "reports", "fixes", "names", "sites", "times", "bytes", "file", "chains", "classes", "images", "ions", "obs"], "url": ["m", "re", "bel", "ur", "http", "link", "b", "path", "ls", "gl", "ml", "sp", "buffer", "resource", "l", "uri", "f", "sl", "r", "nl", "fl", "mb", "str", "rel", "mount", "user", "sb", "location", "char", "li", "Url", "mail", "web", "ob", "el", "norm", "html", "file", "dl", "ll", "entry", "loc", "key", "cert", "URL", "browser"], "name": ["info", "full", "m", "NAME", "length", "Name", "run", "path", "default", "prefix", "on", "version", "nm", "none", "part", "common", "internal", "id", "address", "normal", "f", "source", "str", "one", "n", "me", "code", "term", "no", "order", "node", "local", "named", "string", "title", "all", "alias", "word", "num", "names", "hash", "ame", "comment", "file", "data", "type", "size", "format", "family", "key", "label", "filename", "len", "event"], "mf": [" mfo", "manF", "manff", "Mfo", " Mf", "Mif", "Mf", "Mfy", "manfy", "mnf", "mfo", " Mff", "mnfo", "mnif", "manf", "Mff", "mF", "mif", " Mfy", " mif", " mF", "mff", " MF", "mnF", "mfy", "MF"], "tmpFile": ["tempName", "tmpCheck", "TempFile", "mpfile", " tmpFiles", " tmpfile", "tmpPlace", "Tempfile", "tempDir", "potFiles", "tmpName", "mpDir", "tarfile", "mpFile", "potPlace", "tmpFiles", "tarFile", "TempF", "tempFiles", "tempfile", "tempFile", "tarCheck", "tarName", " tmpPlace", "tmpfile", "TempCheck", "tempF", "TempName", "potfile", "tempPlace", "TempDir", "mpF", "potFile", "tempCheck", "tmpF", "tmpDir"], "ref": ["ret", " reg", "rep", "REF", "re", "nav", "rev", " referred", " pref", "link", "pid", "resp", "rc", "href", "pkg", " href", "range", "reference", " refer", "prefix", " references", "mem", "rm", "id", "Reference", "port", "req", "f", "r", "tab", "service", "pro", " req", "rel", "eb", " ret", "def", "conf", " val", "br", " id", "rem", " re", "af", "Ref", "prop"]}}
{"id1": "15510198", "id2": "4778473", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"buildParser": ["newParser", "newReader", "BuildProxy", "BuildParser", "Buildparser", "createParser", "buildparser", "createReader", "buildProxy", "buildReader", "newparser", "newProxy", "createparser", "BuildReader", "createProxy"], "url": ["pl", "domain", "http", "email", "link", "b", "run", "document", "path", "ref", "ls", "host", "base", "util", "build", "address", "name", "resource", "uri", "l", "log", "sl", "str", "mount", "location", "ssl", "string", "page", "char", "Url", "web", "mail", "ul", "file", "ll", "job", "dl", "URL"], "ParserException": ["ParserError", "parseEvent", "ParserEvent", "ParserWarning", "ReaderError", "parseWarning", "parseError", "parserException", "parserError", "ReaderException", "parseException", "ReaderEvent", "parserEvent", "ReaderWarning", "parserWarning"], "parser": ["payer", "asser", "could", "processor", "parse", "taker", " scanner", "handler", "document", "fp", " soup", "util", "driver", "pair", "worker", "peer", "jack", "php", "consumer", "message", "p", "runner", "er", "master", " parse", "library", "writer", " provider", "reader", "bank", "Parser", "still", "lp", "arson", "language", "inner", "jp", "instance", "json", "arser", "manager", "pool", "program", "xml", "layer", " parsed", " parsing", "policy", "loader", "job", "format", "builder"], "connection": ["computer", "currently", "http", "link", "handler", "close", "c", "document", "ion", "creation", "character", "cone", "condition", "established", "now", "Connection", "client", "message", "resource", "directory", "to", "pointer", "conn", "connected", "created", "still", "application", "associated", "con", "current", "position", "network", "instance", "server", "database", "session", "relation", "communication", "pool", "connect", "closed", "response", "channel", "generation", "entry", "open", "remote", "command"]}}
{"id1": "160739", "id2": "2642914", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createOutputFile", "createInputSteam", " createFileStream", "createOutputSteam", " createOutputstream", " createOutSteam", " createOutStream", " createInputSteam", " createInputStream", " createOutputSteam", " createFileFile", " createInputFile", " createFileSteam", "createInputStream", "createInputFile", " createInputstream", "createInputstream", " createOutputFile", " createFilestream", "createOutputstream", " createOutFile", " createOutstream"], "inFile": [" infile", "dinFile", " inPort", "inputPath", "ninFile", "inputPort", "dinPath", "outFilename", "dinPort", "inPort", "ninfile", "ninFilename", "outfile", " inDir", "infile", "inPath", "inputFile", "dinDir", "outPath", "ninPath", "inDir", "inputDir", " inFilename", "inFilename", " inPath"], "outFile": ["toFilename", "Outfile", "toPort", "exFilename", "outFilename", "outPort", "exFile", "newFilename", "inPort", "OutFilename", "outfile", "infile", "outputFile", "newFile", "outputfile", "tofile", "toFile", "outputPlace", "OutFile", "exfile", "newPlace", "OutPort", "inFilename", "newfile", "outputFilename", "outPlace", "exPlace"], "k_blockSize": ["k_BlockTime", "k4BlockStyle", "k4blockName", "k2byteCount", "k4BlockSize", "k2byteSize", "k2blockSize", "k4blockStyle", "k_byteTime", "k_byteCount", "k_batchCount", "k_blockCount", "k_byteSize", "k4BlockCount", "k_BlockStyle", "k4BlockName", "k_batchSize", "k2byteLength", "k_batchTime", "k_blockName", "k2blockLength", "k4blockCount", "k_blockTime", "k_byteStyle", "k_batchLength", "k2blockCount", "k2byteTime", "k_blockLength", "k4blockSize", "k_byteLength", "k_blockStyle", "k_BlockSize", "k2blockTime", "k_BlockName", "k_BlockCount", "k_BlockLength", "k_byteName"], "byteCount": ["blockCounter", " byteCounter", "charCount", "wordN", "bitCheck", "bytecount", "byteN", "blockCount", " byteCheck", "bbCount", "bitLength", "bitCounter", " bytePtr", " bytecount", "bbCode", "bbSize", "wordCount", "lineLength", "linePtr", "linecount", "byteLength", "charcount", "blockCheck", "wordSize", "bbN", "wordCode", "charLength", "bytePtr", "byteCheck", "byteSize", " byteLength", "lineCount", "byteCode", "bitCode", "blockLength", "byteCounter", "charPtr", "bitSize", "bitCount", "bitN"], "buf": ["bg", "buff", "b", "bn", "cap", "pkg", "alph", "batch", "raw", "block", "mem", "Buffer", "vec", "buffer", "uf", "pb", "doc", "queue", "cur", "proc", "str", "Buff", "seq", "cmd", "bl", "txt", "cat", "ctr", "exp", "ctx", "bag", "rb", "img", "conv", "db", "cb", "cv", "bytes", "msg", "tx", "cast", "fg", "bc", "arr"], "ofp": ["ofd", "owlP", "OFP", "ofl", "OFp", " ofd", " ofP", "OFd", "ofP", "Ofl", "Ofd", " ofl", "owlp", "Ofp", "OfP", "owlpa", "Ofpa", " ofpa", "ofpa", "OFl", "owld"], "zos": ["zen", "os", "sis", "zin", "zh", "zip", "z", "hz", "bs", "zag", "eros", "ws", "cz", "css", "bes", "sch", "osi", "ossus", "tis", "python", "ps", "es", "settings", "socket", "zi", "zl", "zik", "ze", "zo", "zon", "amia", "enos", "zy", "std", "rose", "gs", "nz", "esa", "js", "zers", "los", "init", "ez", "rss", "zb", "sbm", "jp", "hess", "za", "jas", "zzle", "zes", "oss", "rez", "LOS", "zona", "south", "zer", "webkit", "cos", "zu", "psy"], "osw": ["ossW", "cosew", " osd", "sysrw", "aosw", "cosw", "aosrw", "aosws", "cosws", "isW", "owa", " osW", "ossw", "osrw", "osd", "aoswd", "ow", "oswd", "osW", "aosew", "sysw", "aoswa", "oW", "osws", "ospace", "osew", "osssw", " osew", "osswd", "aospace", "oswx", "osswx", "cosd", "ossrw", "issw", "syswd", "sysW", "osipace", " ossw", " oswx", " osws", "isw", "opace", "oswa", "osiW", "osiw", "iswx", "osiwa", "aosW", "aosd"], "bw": ["bwk", " bz", "pbwy", "bex", "wbx", "bbex", "obsw", "obw", "bbwp", " bex", "wbw", "obwb", "sbw", "bwb", "bwe", "bew", "bbws", "obwl", " bend", "pbew", "bbz", "bbend", "bx", "sbwt", "bewl", "wbend", "bsw", "bwy", "wbwt", "wbz", "bbem", "abwe", "nbwe", "abw", "pbwe", " bem", "pbw", "rbz", " bwp", " bsw", " bwl", "bbwt", "nbw", " bws", "pbwb", "pbz", "nbwy", "obwt", " bwt", "obwk", "sbz", "obz", "rbws", " bx", "bend", "bwt", "pbwt", "nbew", "bewk", "bbx", "bem", "abwy", "bws", "rbex", "sbwb", "wbem", "bwl", "bz", " bwk", "bbw", "rbw", "bwp", "abew", "wbwp", "besw"], "zot": ["zerot", "zerote", " zo", "Zote", " ziot", "zero", "ziat", "ziot", "zhot", " zote", "Zit", "zipiot", "zipot", "zoonet", " zhot", "zeriot", "zeriat", "zo", "zoo", "zote", "zoor", " zott", "zerit", "zeronet", "ziphot", " zonet", "zonet", "zipiat", "zott", "zor", " ziat", "zoot", "zerott", " zor", "zeror", "Zot", "Zott", "zerhot"], "ifp": [" ifr", " iftp", "iwr", "ihr", "iwp", " ifP", "isth", "IfP", "ifd", "ihd", " ifth", "iwtp", "isp", "isjp", "iwd", "ifth", "ihtp", "ifjp", "Ifp", "ihp", "iftp", " ifjp", " ifd", "ifP", "isP", "ifr", "Ifjp", "Ifth"], "zis": ["ezis", "zipIS", "ezi", "ziiss", " zisc", "zipic", "ziisa", "eziss", " zIS", "izinit", "izisa", "iziss", "zisa", "zi", "zoisa", "ziinit", "zipis", " zic", " zi", "zoiss", "izi", "zIS", "ziis", "zeris", "zoinit", "zerIS", "ziss", "ezisc", "zois", "zeric", "izisc", "zic", " ziss", "zisc", "zinit", "izis"], "isr": ["isalpr", "iossr", "issrs", "isscr", "itssr", "iscr", "sisrs", "isalstr", "sisrc", " isrs", "itsr", "issr", "ispr", "iosr", "iosstr", "issrc", "isrs", "iospr", "sisr", " isrc", "isrc", " iscr", "isalr", "isstr", "itsstr", "isalsr", "siscr", "itspr"], "br": ["bt", "bh", "shr", " Br", "lr", "Fr", "b", "bn", "obl", "Br", "bf", "gr", "bm", "ba", "yr", "bd", "r", "wr", "hr", "str", "js", "rel", "bl", "bi", "ctr", "cr", "dr", "rb", "bro", "tr", "BR", "bp", "sr", "pr", "ptr", "fr", "kr", "ber", "vr", "bj", "mr"], "zit": ["ezIT", "zipist", "izip", "lexIT", "zIT", "zip", "ozunit", "oziti", "zeip", "ziti", "ozip", "ezite", " zop", "zeit", "zeot", "zIt", "zipIt", "cziti", " zite", "zipite", "lexit", "izit", "zist", "zite", "ziIT", "czit", "lexIt", " zip", "zipit", "iziti", "ziIt", "ozit", "czot", "czunit", "izunit", "zipIT", "ziist", "zop", "ezlit", "ezit", "czip", "zeop", "zunit", "ziit", "ziplit", "czop", " zIT", " zlit", "lexist", "zlit"]}}
{"id1": "3801655", "id2": "22977189", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"helper": ["hoter", "helphel", "hoper", "heler", "transter", "duporter", "duper", "hyhel", "hyporter", "helhel", "helpmer", "hyper", "helpter", "transper", "hoer", "helporter", "homer", "transmer", "transer", "duhel", "helpporter", "helter", "hyter", "helmer", "duter", "helpper"], "dataset": ["datbasetic", "datassets", "Datassets", "datassset", "dataasetter", "dataasset", "datbasET", "Datassetter", "datassetter", "datisets", "Datassset", "datisetic", "databaseset", "Datasetter", "datarsets", "datasET", "datbaset", "dataassets", "Datasset", "dataasets", "datarset", "dataasetic", "datassetic", "datatset", "datasset", "dataassset", "datassET", "datisset", "datasetter", "datatets", "Dataset", "datatet", "databasesset", "datisetter", "Datasets", "datarsET", "dataassET", "datatetter", "databasesET", "dataassetter", "dataasET", "datisET", "datasets", "databasesets", "dataaset", "dataassetic", "datiset", "datbasetter", "datarsset", "datasetic"], "zip": ["project", "Zip", "feed", "install", "module", "z", "link", "archive", "pkg", "zero", "rar", "sheet", "tar", "se", "system", "ze", "directory", "zo", "io", "folder", "wrap", "code", "cf", "xf", "jar", "pack", "ip", "sea", "bag", "lib", "pdf", "zone", "json", "comp", "mail", "box", "xml", "file", "lock", "download", "lex", "handle", "dir"], "entries": ["Enters", "contries", "entsents", "curables", "entsries", "Entrs", "Entlements", "contires", "enters", "entables", "tables", "Entresses", "tries", "curries", "Entrys", "currys", "entires", "getrys", "enresses", "entlements", "Entires", "Entities", "getlements", "currs", "contrys", "geters", "attrys", "entslements", "attents", "entrs", "Entents", "attries", "entresses", "entities", "entents", "trs", "entrys", "contresses", "getries", "Entables", "trys", "Entries", "enires", "enrys", "attities", "entsers", "enries", "entsrys", "entsities"], "performance": ["storage", "fit", "capacity", "util", "speed", "mult", "evaluate", "scale", "dimension", "maximum", "grade", "spec", "log", "test", "minimum", "due", "step", "expected", "load", "work", "sum", "split", "cost", "force", "ul", "union", "volume", "duration", "shape"], "index": ["pos", "update", "length", "j", "total", "capacity", "offset", "open", "value", "count", "available", "ind", "level", "connection", "limit", "number", "x", "Index", "order", "set", "seek", "loop", "size", "lock", "max", "type"], "entry": ["record", "ace", "row", "item", "module", "office", "link", "Entry", "archive", "cont", "sheet", "se", "add", "it", "e", "or", "part", "internal", "cell", "name", "context", "resource", "keeper", "element", "io", "enter", "member", "test", "jar", "ie", "word", "instance", "char", "next", "ry", "xml", "data", "match", "channel", "job", "key", "ent", "result"], "temp": ["porary", "mod", "tim", " temporary", "tc", "null", "t", "orig", "mp", "dir", "table", "empty", "fake", "mk", "tar", " tmp", "EMP", "base", "mem", "parent", "cp", "this", "mt", "wrapper", "tab", "wrap", "created", "emp", "stem", "pre", "test", "txt", "create", "local", "copy", "dest", "template", "partial", "current", "tr", "pdf", "root", "tmp", "tm", "file", "tx", "tem", "mint", "Temp", "por", "thread", "pt"], "writer": ["creator", "rw", "null", "w", "handler", "variable", "document", "ner", "driver", "stream", "worker", "maker", "parent", "wrote", "iterator", "system", "connection", "message", "er", "riter", "master", "writing", "print", "wrapper", "owner", "write", "service", "window", "console", "output", "Reader", "iter", "writers", "server", "network", "writ", "player", "wire", "ger", "walker", "ter", "Writer", "external", "penter", "file", "ler", "loader", "wp", "browser", "thread", "builder"], "reader": ["rot", "row", "feed", "ard", "handler", "rar", "ner", "driver", "stream", "roller", "rer", "peer", "iterator", "er", "runner", "wrapper", "r", "readable", "ro", "iter", "Reader", "rx", "volume", "dr", "inner", "input", "ri", "ry", "file", "reading", "loader", "handle", "rr", "builder"], "buffer": ["bar", "memory", "row", "null", "column", "phrase", "binary", "buff", "length", "table", "sample", "variable", "document", "capacity", "batch", "font", "block", "Buffer", "history", "message", "sequence", "background", "cache", "queue", "scroll", "padding", "window", "buf", "stroke", "iter", "template", "word", "char", "database", "frame", "header", "command", "stack", "vector", "append"], "read": ["before", "each", "send", "text", "Read", "parse", "length", "run", "old", "close", "give", "end", "take", "get", "mix", "stream", "add", "enable", "raw", "mem", "check", "count", "used", "build", "READ", "ready", "need", "report", "print", "skip", "readable", "fill", "write", "q", "source", "like", "select", "bind", "test", "set", "find", "start", "create", "iter", "tell", "en", " Read", "input", "seek", "word", "next", "query", "reading", "size", "format", "time", "open", "len", "reads", "handle", "load", "hold"], "outfile": ["inchannel", "initstream", " outstream", "initfile", "outFile", "initfolder", "outfolder", "outputfolder", "outputstream", " outFile", "OUTfile", "infolder", "inFile", "instream", "inbuffer", "initFile", "infile", "outputFile", "inputFile", "outputfile", "outbuffer", "OUTchannel", "outchannel", "inputstream", "inputfile", "inputbuffer", " outchannel", " outbuffer", "outstream", "OUTFile"], "line": ["LINE", "train", "row", "detail", "note", "column", "phrase", "link", "sample", "lo", "eline", "range", "statement", "inline", "block", "e", "cell", "message", "Line", "sequence", "port", "l", "log", "lines", "code", "ln", "iter", "lin", "string", "page", "word", "section", "char", "le", "point", "frame", "online", "header", "file", "msg", "comment", "ine", "text", "chain", "liner"], "parser": ["asser", "processor", "parse", "handler", " scanner", "ner", "pair", "worker", "maker", "rer", "system", "iterator", "er", "runner", "bank", "Parser", "magic", "lp", "builder", "cer", "operator", "conv", "walker", "arser", "xml", "auto", "file", "penter", "layer", "policy", "format", "ler", "loader", "hander", "uler", "finder", "music"], "list": ["record", "dict", "detail", "null", "table", "range", "batch", "part", "parent", "level", "menu", "sequence", "map", "group", "l", "print", "out", "member", "queue", "ist", "left", "output", "all", "li", "pool", "data", "file", "LIST", "array", "listed", "match", "chain", "result", "lists", "collection"], "rule": ["record", "row", "re", "module", "item", "parse", "rank", "run", "table", "ULE", "statement", "range", "definition", "block", "value", "filter", "role", "r", "feature", "rl", "play", "node", "function", "Rule", "style", "ule", "relation", "rol", "force", "file", "match", "field", "policy", "command", "chain", "rr", "result"], "measure": ["peMeasure", "Measured", "MEasuring", "peasured", "MEasured", "meMeasure", "measuring", "Measuring", "MEasure", "peasuring", "peasure", "Measure", "MEMeasure", "measured", "MeMeasure"]}}
{"id1": "20028790", "id2": "13783549", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBundleDataNames", "setBundleInfoLabel", "setBundleDataName", "setBundleFileLabel", "setBundleInfName", "setBundleInfTitle", "setBundleFileNames", "setBundleDataLabel", "setBundleDataTitle", "setBundleInfNames", "setBundleFileName", "setBundleInfoNames", "setBundleInfLabel", "setBundleFileTitle", "setBundleInfoTitle"], "location": ["where", "document", "path", "reference", "history", "ocation", "address", "Location", "name", "message", "color", "directory", "resource", "uri", "library", "l", "layout", "country", "availability", "LOC", "local", "language", "template", "position", "area", "point", "program", "localhost", "comment", "description", "loc", "translation", "remote", "filename", "command"], "list": ["m", "detail", "table", "batch", "add", "block", "level", "name", "v", "sequence", "p", "map", "l", "print", "spec", "out", "n", "ist", "set", "local", "missing", "L", "all", "pool", "LIST", "dl", "listed", "net", "chain", "status", "stack", "lists", "collection"], "url": ["pl", "bel", "lr", "ur", "http", "hl", "link", "b", "ref", "open", "base", "build", "l", "uri", "f", "sl", "r", "nl", "rl", "str", "gb", "rel", "mount", "google", "sb", "ssl", "char", "Url", "mail", "abs", "html", "ul", "el", "loc", "ll", "lb", "dl", "job", "URL", "browser"], "br": ["bt", "lr", "bh", "read", "bs", "b", "ch", "Br", "be", "gr", "er", "r", "nl", "bd", "wr", "hr", "gb", "str", "buf", "rel", "bl", "cr", "dr", "rb", "bro", "tr", "BR", "bp", "bridge", "next", "sr", "div", "pr", "fr", "kr", "ber", "mr", "browser"], "line": ["record", "handle", "LINE", "sql", "row", "detail", "note", "phrase", "link", "sample", "lo", "stay", "rule", "eline", "inline", "piece", "se", "block", "part", "store", "cell", "name", "message", "buffer", "Line", "sequence", "linux", "l", "print", "log", "nl", "source", "code", "ln", "iter", "lin", "page", "string", "style", "word", "char", "body", "next", "le", "point", "trace", "frame", "online", "header", "data", "comment", "lock", "entry", "ine", "label", "text", "chain", "liner"], "pos1": ["poOne", "pos2", "position2", "po3", "POS1", "POSOne", "indexOne", "pos0", "Pos1", "positionOne", "pos3", "POS2", "posOne", "po1", "Pos2", "Pos0", "posone", "index3", "index1", "indexone", "poone", " pos2", "position3", "position1", " pos0", " posOne", "POS0", "positionone", "position0", "PosOne"], "bundleSymbolicName": ["bundleSymbolicFamily", "bundleSymbicName", "bundleSymbolicalFamily", "bundleSymbicalType", "bundleSyMBolicname", "bundleSymbularFamily", "bundleSymbicalNames", "bundleSymbicNames", "bundleSymbularname", "bundleSymbolicNames", "bundleSymbolicalName", "bundleSyMBolicVersion", "bundleSyMBolicNames", "bundleSyMBicalname", "bundleSymbololicNames", "bundleSyMBicalName", "bundleSymbololicName", "bundleSymbularNames", "bundleSymboryVersion", "bundleSymbolicalType", "bundleSymbicalFamily", "bundleSymbololicFamily", "bundleSyMBolicCode", "bundleSymbicalname", "bundleSymbolicname", "bundleSymbolicVersion", "bundleSymbicCode", "bundleSyMBicalCode", "bundleSymboryName", "bundleSyMBolicType", "bundleSymbicalVersion", "bundleSymboryNames", "bundleSymboryname", "bundleSymbololicType", "bundleSyMBicalType", "bundleSymbolicalNames", "bundleSymbicalName", "bundleSyMBicalVersion", "bundleSymbularType", "bundleSymboryType", "bundleSymbolicCode", "bundleSymboryCode", "bundleSymbularName", "bundleSymbolicType", "bundleSyMBolicName", "bundleSymbicVersion", "bundleSyMBicalNames", "bundleSymbicalCode"], "bundleName": ["fundleType", "basketname", "fasketType", "branchInfo", "bachmentName", "fasketName", "banchname", "fundlename", "bundlename", "bundleVersion", "bowerInfo", "brundleInfo", "bundleString", "fasketVersion", "baleVersion", "bundleInfo", "balename", "branchString", "fasketname", "basketName", "brundlename", "banchInfo", "banchString", "bundleType", "bowername", "banchName", " banchName", "basketVersion", "fundleVersion", "bachmentname", "brundleName", "bowerString", "baleType", "basketType", "baleName", " banchname", "baleInfo", "bachmentInfo", "branchName", "bowerType", "fundleName", "branchname", " banchInfo", "bowerName", " bundleInfo", " bundlename", "brundleString", "bowerVersion"], "info": ["INFO", "details", "item", "detail", "note", "http", "update", "fit", "information", "block", "value", "check", "inf", "history", "now", "error", "context", "image", "summary", "obj", "report", "f", "fo", "me", "user", "iter", "local", "tip", "state", "dev", "all", "def", "inner", "conf", "alias", "instance", "iso", "index", "ext", "json", "te", "i", "query", "comment", "data", "Info", "match", "tf", "self", "job", "entry", "status", "event"]}}
{"id1": "701029", "id2": "8069594", "code1": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadSourceCode": ["loadsourceSource", "loadSourceData", " loadsourceFile", "loadSourceFileSource", "loadBaseFile", " loadSourceFile", "loadSourceFileFile", "loadSourceFileCode", " loadsourceSource", " loadSourceSource", "loadSourceSource", "loadBaseSource", "loadBaseCode", "loadsourceData", "loadsourceFile", "loadBaseData", "loadsourceCode", " loadsourceData", "loadSourceFileData", " loadSourceData", " loadsourceCode", "loadSourceFile"], "length": ["join", "download", "t", "text", "read", " Length", "dump", "total", "capacity", "ENGTH", "end", "path", "amount", "h", "default", "SIZE", "count", "available", "width", "name", "message", "maximum", "buffer", "sequence", " lengths", "limit", "library", "l", "f", "readable", "number", "write", "height", "code", "no", "string", "load", "title", "ength", "position", "Length", "loop", "description", "size", "type", "max", "len", "volume", "family", "filename", "format", "duration", "shape", "collection"], "file": ["full", "File", "ile", "po", "FILE", "table", "fp", "il", "path", "ref", "base", "e", "parent", "list", "name", "connection", "buffer", "image", "resource", "port", "f", "io", "sf", "al", "source", "set", "output", "local", "page", "le", "fil", "db", "el", "pool", "face", "frame", "size", "channel", "remote", "format", "filename", "handle"], "buff": [" buf", "read", "b", "j", "end", "alph", "ch", "ref", "font", "mem", "Buffer", "bb", "buffer", "uf", "f", "mb", " buffer", "Buff", "buf", "cmd", "txt", " buffers", "ph", "tmp", "fr", "ob", "append"], "is": ["os", "isl", "il", "us", "mi", "ls", "ios", "lis", "has", "it", "isi", "its", "isc", "ser", "es", "iss", "ists", "ins", "s", "bits", "ois", "ir", "fs", "ist", "iris", "iter", "ip", "rs", "si", "ri", "\u00eds", "ris", "iso", "sim", "oss", "i", "sys", "IS", "Is", "vis", "ais", "ims", "bis", "isa", "are"], "isr": [" isl", "rissr", "isl", "oissr", "essr", "esar", "issrs", "Isvr", "risar", "Isr", " isrs", "oisr", "isar", "Ispr", "risr", "oisrs", "issr", "ispr", "esr", "isvr", "risrs", "rispr", "Isrs", "isrs", "isspr", "risl", " ispr", "issl", " isvr", "oisar", "esrs", "issvr"], "cv": ["nc", "av", "cn", "bt", "tc", "sc", "rev", "hw", "CV", "c", "rc", "vs", "xc", "nv", "bm", "cc", "cp", "v", "cd", "uv", "uf", "pb", "tk", "cur", "lv", "sv", "buf", "cf", "txt", "fc", "vp", "ctx", "vc", "cam", "rpm", "qt", "conv", "cm", "cb", "tv", "vm", "vr"], "url": ["ret", "re", "bel", "ur", "http", "link", "https", "il", "github", "ref", "get", "gl", "or", "dll", "address", "name", "resource", "uri", "l", "sl", "r", "nl", "io", "rl", "str", "res", "impl", "mount", "rel", "location", "ssl", "string", "atl", "Url", "web", "mail", "ul", "el", "addr", "abs", "html", "loc", "ll", "dl", "key", "URL", "browser"], "reader": ["editor", "info", "row", "older", "read", "handler", "rc", "rar", "dra", "ner", "upper", "range", "driver", "stream", "roller", "ser", "rer", "history", "iterator", "buffer", "writer", "er", "runner", "resource", "wrapper", "r", "rl", "ipper", "ro", "iter", "Reader", "rs", "rx", "dr", "inner", "ri", "body", "fr", "her", "data", "reading", "parser", "loader", "liner", "builder"], "sourceCode": ["SourceForce", "SourceScript", " sourceMessage", "relationCount", " sourceData", " sourceCount", "SourceName", "codeMessage", "SourceTree", "codeCode", "sourceCount", "sourceName", "componentCode", "sourceForce", " sourceComment", " sourceForce", "sourceData", "relationCode", "relationData", "relationLine", "componentLine", "sourceTree", "SourceCode", "relationName", " sourceName", "componentComment", "sourceMessage", "SourceLine", "SourceCount", "relationForce", "sourceLine", "sourceComment", " sourceTree", "sourceScript", "codeData", "SourceMessage", " sourceLine", "codeTree", "SourceComment", " sourceScript", "SourceData", "componentScript"], "line": ["LINE", "row", "phrase", "link", "sample", "lo", "eline", "range", "key", "inline", "se", "block", "e", "cell", "message", "Line", "port", "l", "print", "log", "nl", "number", "lines", "source", "lined", "str", "code", "ln", "pe", "stroke", "iter", "lin", "page", "string", "word", "body", "le", "point", "trace", "frame", "online", "comment", "data", "ne", "lock", "entry", "ine", "label", "text", "chain", "liner"]}}
{"id1": "4417943", "id2": "4272289", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static int[] sortstring(int[] a1) {\n        int temp;\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        return a1;\n    }\n", "label": 0, "substitutes": {"test": ["full", "install", "testing", "sample", " TEST", " benchmark", "base", "evaluate", "ping", "Example", " check", "example", " sample", " tests", "debug", "init", "server", "launch", " Test", "Test", "index", "tests", " testing", "execute", "hello", "foo", "status"], "query": ["sql", "params", "poll", "prefix", "condition", "quest", "Q", "filter", "quote", "question", "sequence", "menu", "spec", "password", "q", "term", "select", "code", "Query", "search", "string", "pattern", "random", "page", "input", "body", "index", "qa", "comment", "form", "qu", "view", "field", "type", "text", "qs", "command", "ql"], "url": ["pl", "sql", "ur", "api", "u", "http", "link", "https", "path", "ref", "ls", "base", "raw", "build", "address", "id", "name", "l", "print", "uri", "sl", "r", "nl", "log", "out", "q", "term", "str", "mount", "www", "location", "string", "title", "pattern", "pr", "Url", "web", "ul", "html", "xml", "dl", "ll", "format", "URL", "result"], "urlObj": ["lIt", "httpobj", "lObj", "lobj", " urlOb", "UrlOb", " urlobj", "httpOb", "urlOb", "nlobj", "nlIt", " urlIt", "Urlobj", "nlObj", "httpObj", "urlobj", "UrlObj", "urlIt", "lOb", "nlOb"], "con": ["nc", "cn", "dial", "pos", "in", "fn", "c", "cont", "un", "syn", "pen", "mc", "open", "ver", "cone", "soc", "Con", "cond", "connection", "ain", "obj", "can", "conn", "cur", "cl", "Conn", "ln", "cf", "fc", "win", "conf", "don", "sin", "conv", "com", "CON", "compl", "num", "connect", "canon", "co", "ran", "len", "const", "cons", "cos", "bc", "fin", "ctrl"], "model": ["record", "mod", "m", "re", "Model", "module", "zip", "link", "table", "object", "mi", "base", "value", "cell", "message", "buffer", "map", "transform", "sm", "me", "impl", "controller", "de", "dm", "set", "tree", "state", "save", "body", "gp", "man", "le", "sim", "cm", "el", "frame", "xml", "data", "vm", "models", "response", "dl", "job", "fine"]}}
{"id1": "14473781", "id2": "9718328", "code1": "        @Override\n        protected String doInBackground(Void... params) {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpContext localContext = new BasicHttpContext();\n            HttpPost httpPost = new HttpPost(urlFormated);\n            try {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for (int index = 0; index < POSTparamList.size(); index++) {\n                    if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) {\n                        entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue())));\n                    } else {\n                        entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue()));\n                    }\n                }\n                httpPost.setEntity(entity);\n                HttpResponse response = httpClient.execute(httpPost, localContext);\n                return processAnswer(response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doOnBackground", " doAsRequest", " doInsideAsync", " doInAsync", " doOnRequest", " doAsFuture", " doInFuture", "doAsRequest", "doInAsync", "doInRequest", " doAsAsync", "doAsBackground", "doAsFuture", "doAsAsync", " doOnAsync", "doInFuture", " doInRequest", " doAsBackground", " doInsideBackground", " doInsideFuture", " doInsideRequest", " doOnFuture"], "params": ["Param", "details", "sql", "cas", "services", "files", "settings", "list", "errors", "values", "proc", "param", "Parameters", "ctx", "vals", "conf", "properties", "terms", "ams", "parts", "config", "posts", "data", "options", "images", "tags", "ps"], "httpClient": [" httpclient", "httpsSystem", "httpsContext", "ttpclient", " httpSystem", "ttpSystem", "htmlClient", "httpsControl", " httpConnection", "httpSystem", "httpsclient", "ttpClient", "httpContext", "hoverSystem", "htmlContext", "hoverContext", "httpclient", "htmlSystem", "ttpConnection", "httpConnection", "hoverClient", "htmlControl", "httpsConnection", "httpsClient", "hoverControl", "httpControl"], "localContext": ["localcontext", " localState", " localcontext", "privateContext", "LocalPort", " localCase", "LocalState", "sessionCondition", "localPort", "sessionState", "localCase", "sessionCase", "localState", "currentContext", "privateState", "currentCondition", "currentCase", "localCondition", " localCondition", "Localcontext", "privatePort", "privatecontext", " localPort", "currentState", "sessionContext", "LocalContext"], "httpPost": [" httppost", "ttppost", "httpsPOST", "hoverPOST", "HttpPut", "httppost", " httpPOST", "httpPut", "ttpPOST", "workPut", " httpPut", "workPost", " httpPre", "httpsPre", "ttpPre", "ttpPost", "workPre", "workPOST", "HttpPOST", "httpPOST", "ttpPut", "httpPre", "httpsPut", "hoverpost", "HttpPost", "hoverPost", "httpsPost", "HttpPre"], "entity": ["eme", "details", "person", "note", "email", "complex", "table", "empty", "total", "orm", "document", "security", "rule", "object", "component", "collection", "secure", "base", "intent", "line", "unique", "or", "oe", "internal", "ce", "quote", "activity", "ment", "image", "unit", "group", "needed", "put", "created", "member", "one", "pe", "output", "create", "local", "metadata", "encrypted", "iam", "template", "and", "body", "Entity", "el", "comment", "xml", "data", "auto", "channel", "translation", "entry", "command", "policy", "ell", "ent", "event", "result", "net"], "index": ["ox", "column", "ax", "empty", "coll", "get", "success", "add", "version", "address", "context", "axis", "inc", "number", "x", "Index", "see", "num", "IND", "draw", "insert", "match", "display", "author", "row", "pos", "note", "active", "EX", "capacity", "eight", "ind", "scale", "error", "layout", "request", "select", "find", "search", "seek", "access", "config", "loop", "loc", "max", "open", "key", "shape", "major", "go", "each", "update", "length", "zero", "document", "offset", "mix", "condition", "check", "sync", "height", "unknown", "date", "mount", "iter", "all", "position", "i", "connect", "initial", "ask", "prefix", "osit", "name", "sequence", "image", "scroll", "stick", "ex", "set", "exp", "create", "state", "instance", "slice", "point", "ix", "size", "lex"], "response": ["answer", "api", "pos", "resp", "document", "object", "onse", "e", "value", "results", "message", "connection", "image", "sequence", "context", "social", "content", "service", "request", "respond", "still", "res", "application", "respons", "output", "tree", "page", "reply", "Response", "body", "zone", "json", "frame", "xml", "data", "view", "hello", "entry", "result"]}}
{"id1": "9267602", "id2": "10212189", "code1": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"urltext": [" urlTEXT", "dlText", "urlText", "Urltext", " urltxt", "Urltxt", "dltxt", "ltxt", "dltext", "urltemplate", "httptemplate", "UrlTEXT", "httptext", "UrlText", "urltxt", "urlTEXT", "Urltemplate", "urlstring", "httptxt", "Urlstring", "lText", "dlstring", "httpTEXT", "ltext", "lstring", " urltemplate"], "url": ["pl", "bel", "ur", "null", "http", "link", "b", "ref", "ls", "host", "base", "key", "client", "resource", "ol", "l", "sl", "r", "nl", "out", "cl", "str", "window", "rel", "mount", "ssl", "char", "Url", "mail", "web", "ul", "db", "ll", "dl", "open", "cert", "URL", "browser"], "in": ["info", "re", "update", "read", "b", " din", "cal", "mc", "get", "cin", "it", "add", "on", "check", "inf", "inn", "ill", "mn", "ins", "er", "ic", "l", "io", "reader", "r", "inc", "out", "al", "IN", "from", "iter", "init", "en", "isin", "bin", "inner", "all", "con", "input", "conf", "again", "din", "sum", "i", "el", "file", "is", "and", "In"], "inputLine": ["textLINE", "jsonData", " inputRow", "outputBlock", " inputData", "outputLe", " inputLINE", "inputData", "inputRow", "templateLe", "textRow", " inputLe", "charRow", "outputline", "jsonRow", "jsonLine", "textLine", "textData", "charLINE", "charLine", " inputline", "templateLine", "outputLine", " inputBlock", "inputLINE", "inputBlock", "InputLINE", "templateBlock", "InputRow", "inputline", "jsonLINE", "Inputline", "charline", "InputLine", "templateline", "inputLe"]}}
{"id1": "8320469", "id2": "8024375", "code1": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"md5": ["sha5", "md6", " md4", "sha4", "MD4", "sha6", "md4", "MD5", "MD6", " md2", "MD2", "md2", "sha2", " md6"], "text": ["Text", "hex", "secret", "t", "email", "binary", "read", "document", "path", "font", "TEXT", "prefix", "required", "name", "message", "buffer", "image", "published", "bound", "password", "print", "log", "content", "confirmed", "source", "str", "code", "txt", "output", "string", "title", "pattern", "input", "word", "nt", "ext", "config", "aut", "data", "msg", "translation", "event", "pt"], "encrypted": ["initialized", "hex", "approved", "ebook", "secret", "rypted", "updated", "written", " secured", "unsigned", "empty", "Secure", "qualified", "secure", "ed", "used", "required", "plain", "message", "ended", "generated", "password", "seed", "confirmed", "connected", "enc", "created", "sent", "colored", "tested", "interrupted", "marked", "verified", "printed", "rounded", "pdf", "installed", "checked", "loaded", "signed", "bytes", "rendered", "packed", "locked", "added", "ressed"], "md": ["mod", "m", "ms", "med", "mp", "exec", "det", "pd", "df", "amd", "ld", "managed", "mk", "dh", "mc", "pm", "nd", "MD", "ng", "di", "del", "ind", "rm", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "cmd", "dm", "mm", "met", "dr", "ds", "der", "db", "hd", "red", "mand", "grad", "msg", "down", "and", "dd", "dir", "d"]}}
{"id1": "7372311", "id2": "1097147", "code1": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"generateDeviceUUID": ["generateDeviceUName", "generateDevUUL", "generateDeviceOUUID", "generateDevUniqueUL", "generateDeviceOUuid", "generateDeviceUuid", "generateDeviceUUName", "generateDevUniqueName", "generateDevUUID", "generateDeviceOUUL", "generateDeviceUUUL", "generateDevUuid", "generateDeviceOUName", "generateDeviceUniqueUL", "generateDeviceUUUID", "generateDeviceUniqueuid", "generateDeviceUUuid", "generateDeviceUniqueUID", "generateDeviceUUL", "generateDevUniqueUID", "generateDeviceUniqueName", "generateDevUniqueuid", "generateDevUName"], "md5": ["MD25", " Md55", "MD3", " MD4", "md3", "mand45", " md45", "md25", " md25", "MD5", " mdlet", "mand5", "md55", "md45", " md512", " md4", "mm7", " MD512", "mdma", " md7", "MD7", "md512", " Md512", "md2", "sha2", " MDma", " md55", "sha25", "sha5", " Md4", "mand7", " MD55", " MD5", " md3", "mm5", "mand3", "MD2", "md7", " MDlet", "mdlet", " MD7", " Md7", "md4", " mdma", " Mdma", "MD45", " md2", "sha3", " Md5", " Mdlet"], "hexString": ["serialstring", "exstring", "textField", "hexstring", "hexSite", " HexStr", "hexArray", "serialString", "textString", " HexField", "serialArray", " hexStr", " hexstring", "pexSite", " hexField", "exString", "textStr", "exBuffer", "serialBuffer", " hexSite", "hexField", " HexBuffer", "hexStr", "phpSite", " hexArray", "phpString", " HexString", "textBuffer", "pexString", "hexBuffer", " hexBuffer", "exArray"], "digest": ["mdate", " digester", "Digested", "Digress", "mdEST", "digested", "Diger", "hexest", "mdest", "digester", "digests", "decest", "hashester", "mdests", "Digests", "decests", "diffEST", "DigEST", "hashest", "hashested", "hashEST", "diffester", "digate", "hexress", "mder", "diger", "hasher", "hashate", "mdress", " digested", "diffest", "hashests", "decester", "diffests", "hexested", " digEST", "digress", "Digate", "Digest", "decEST", "Digester", "digEST", "hexEST", "mdested"], "i": ["ji", "m", "u", "ci", "im", "z", "in", "phi", "j", "gi", "ii", "gu", "qi", "mu", "my", "I", "us", "c", "mi", "ti", "a", "o", "pi", "it", "e", "di", "ui", "ind", "y", "v", "multi", "to", "ic", "l", "f", "io", "ai", "\u0438", "q", "x", "n", "me", "bi", "set", "ip", "si", "ri", "index", "ims", "sim", "li", "ix", "is", "yi", "key"], "uuid": ["iqID", "uID", "uniqueid", "uId", "uniqueID", "iquid", "uid", "iqId", "uuID", "iqid", "uniqueuid", "uniqueId", "uuuid", "uuId"], "runTimeEx": [" runTimeEX", "runTypeEx", "runtimeEx", "runTimesException", "runTimeex", "runTypeex", "runTimeException", "runTimesEX", "runTimeEX", "runTimesExt", " runTimeex", " runTypeException", "runtimeException", " runTypeex", "runTimesex", "runTypeException", " runTimeExt", "runtimeEX", " runTimeException", " runTypeEx", "runTimesEx", "runTimeExt", "runtimeExt", "runtimeex"]}}
{"id1": "13783898", "id2": "23611770", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToDisk", "encodeStringToFiles", "encodeStringAsFile", "encodeStringToFile", "encodeStringAsStream", "encodeFiletoDisk", "encodeStringToStream", "encodeFiletoFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileAsStream", "encodeFileAsFiles", "encodeFiletoFiles", "encodeStringAsFiles", "encodeFileFromFile", "encodeFileAsFile", "encodeFileFromDisk", "encodeFiletoStream", "encodeStringAsDisk", "encodeFileToStream", "encodeFileAsDisk", "encodeFileFromFiles", "encodeFileToFiles"], "infile": ["Inbase", "inpath", "outFile", "outfilename", "InFile", "outpath", " infilename", "Infile", " inbase", "inFile", "inputFile", "inbase", " inFile", "inputpath", "infilename", " inpath", "inputfile", "inputfilename", "Inpath", "outbase"], "outfile": ["outfp", " outname", "infp", "outFile", "newname", "outfilename", "newfilename", "inname", " outFile", "fromFile", "outname", "todir", "outdir", "inFile", " outfilename", "newFile", "fromdir", "tofp", "indir", "fromfp", "tofile", "infilename", "fromfile", "toFile", "newfile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "image", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "ro", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "up", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "total", "variable", "document", "length", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "cache", "number", "temp", "queue", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "attribute", "append"], "read": ["before", "each", "text", "send", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", "ok", "submit", "ratulations", " succ", "condition", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "ith", " Success", "summary", "primary", "commit", "positive", "surv", "same", "good", "safe", "complete", "continue", "second", "sufficient", "democracy", "town", " okay", "warning", "unity", "please", " successes", "first", "support", "city", " successful", "ceed", "fail", "response", "successfully", "status", "result", "crit", "accept"]}}
{"id1": "2668634", "id2": "18164929", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"inputName": ["inputNames", "inputFilename", "interfaceFilename", "outputPath", "inputPath", "InputNames", " inputPath", "interfacePath", "InputName", " inputFile", "interfaceName", "InputFilename", "InputFile", "outputFile", "inputFile", "interfaceFile", " inputNames", "outputNames", "InputPath", "outputFilename"], "outputName": ["OutputName", "inputNames", " outputNames", "outputPath", "inputPath", " outputPath", "outputPort", "inputPort", "OutputPort", "outputType", " outputType", "OutputNames", "outputDir", "OutputPath", " outputDir", "OutputDir", "inputDir", "outputNames", "inputType", "OutputType", " outputPort"], "stripLoggers": ["stripDebugReferences", "skipLogger", "stripPathReferences", "skiploggers", "striploggers", "stripDebugger", "skiplogReferences", "skipLogging", "stripDebugging", "skipLogReferences", "striplogReferences", "stripPathgers", "striplogger", "stripPathger", "stripLogger", "stripLogging", "stripPathging", "skiplogger", "stripLogReferences", "stripDebuggers", "striplogging", "skipLoggers", "skiplogging"], "tempFile": [" tempDirectory", "TempFile", "tempField", " temporaryDirectory", " tempfile", "tmpPath", "tempPath", "tmpPlace", "Tempfile", " tempPath", "empField", "temFile", "tempDir", "tempDirectory", "empFile", " temporaryfile", " tempDir", "tempfile", " temporaryDir", "tmpFile", "tmpField", "tmpfile", "empLock", " temporaryField", "TempPlace", "tmpLock", "TempDirectory", "tempPlace", "empfile", "TempDir", " tempPlace", "temDir", "TempPath", "temPath", " temporaryLock", "tempLock", " temporaryFile", "temfile", "tmpDir"], "jin": ["gin", "jon", "lah", "zin", "pai", "spin", "zip", "nin", "olin", "yang", "thin", "lig", "jo", "erb", "rake", "cin", "pak", " inj", "lu", "ini", "quin", "zon", "rir", "rin", "von", "pin", "kin", "inx", "jet", "ja", "ln", "jiang", "nu", "ju", "txt", "lin", "bin", "jp", "jad", "alin", "tin", "jl", "din", "jing", "john", "tan", "rison", "json", "via", "jen", "jac", "xi", "JR", " Jin", "ran", "jc", "vin", "nik"], "jout": [" jou", "jpout", "zout", "zou", "qaos", "jsin", " jio", "qou", "jou", " jaos", "jpin", "qout", "jsout", "zio", "jOut", "jaos", " jOut", "qio", "zaos", "jsOut", "jpOut", "jio"], "srcChannel": ["sourceCh", "srcCh", "srcchannel", "sourcechannel", " srcchannel", "sourceChannel", "rcCh", " srcChan", "srcChan", "rcChannel", "rcchannel", "sourceChan", "rcChan", " srcCh"], "dstChannel": ["ddestCh", "dgtChannel", " ddestCh", "ddestChannel", "dstCh", " dstChan", "doutChannel", "dgtFile", "doutFile", "dgtCh", " ddestFile", "dstChan", "ddestFile", "doutChan", "ddestChan", " ddestChannel", "dstFile", " dstFile", " dstCh", "dgtChan", " ddestChan", "doutCh"], "portletApplicationName": ["portletApplicationCode", "portletCollectionCode", "portletCollectionName", "portableApplicationType", "portletApplicationType", "portletServiceName", "portletApplicationOrder", "portableAppOrder", "portletapplicationKey", "portletapplicationName", "portableApplicationCode", "portletAppValue", "portableApplicationKey", "portletApplicationKey", "portletAppCode", "portableApplicationName", "portableAppName", "portletServiceOrder", "portletCollectionValue", "portletAppOrder", "portletAppName", "portableAppKey", "portableApplicationValue", "portletAppType", "portableAppType", "portletapplicationType", "portableApplicationOrder", "portletCollectionType", "portletServiceKey", "portletAppKey", "portletApplicationValue", "portletServiceType", "portletapplicationOrder"], "webXml": ["webXm", "webXMxml", "webMom", "webExxml", "webXMm", "webTxlim", "webTxML", "webTxm", "webYom", "WebTxpl", " webYaml", " webXaml", " webTxlim", "webXlim", "webXMaml", " webTxml", "webWorkxml", "WebTxm", "webTxpl", "webTxml", " webYml", "webMML", "WebTxxml", " webXom", "webWorkml", "webExml", "webXom", " webYom", "webXMlim", "webXpl", "WebXpl", "webMml", "webMaml", "WebXML", " webTxML", "webExML", "WebXxml", "WebTxML", " webTxxml", "webExm", " webXML", "webWorklim", "webYaml", "webYpl", "webXMom", "webWorkML", " webXlim", "webYML", "webXMml", "WebTxml", "webXML", "webXxml", "webTxxml", "webYxml", "webXMpl", "WebXm", "WebXml", "webXaml", "webYml", "webXMML", " webXxml", " webYML"], "portletXml": ["portletExml", "portletEbl", "portantXml", "portletYql", "portableXml", "portletHeng", "portableYxml", "portvetXMml", "portvetXMxml", "portletYxml", "portletEml", "portletXMml", "portableYql", "portletTxxml", "portletHexml", "portletEng", "portableXML", "portletXMbl", "portletHeML", "portletTxml", "portantXxml", "portantTxxml", "portvetXml", "portletYML", "portletTxql", "portantTxml", "portvetXxml", "portletTxML", "portletXMML", "portantTxML", "portletXMxml", "portvetXMbl", "portletXMql", "portvetXng", "portableYML", "portableXql", "portableYml", "portvetXMng", "portletYng", "portletYbl", "portletXng", "portletXML", "portletXxml", "portletHeml", "portletYml", "portletXMng", "portletTxng", "portableXxml", "portletXbl", "portantXng", "portvetXbl", "portletXql", "portantTxng", "portantXML"], "contextXml": ["contextCaml", "contextXtml", "contextYaml", "contextCML", "ctxXiML", "ctxXtml", "contextAxmx", "contextCml", "ctxXiaml", "ctxXaml", "ctxXiml", "contextEml", "ctxXML", "contextXiML", "componentYmm", "contextXML", "componentYML", "ctxXml", "contextYtml", "contextAxML", "contextEmm", "contextEmx", "contextCtml", "contextXitml", "componentXmm", "componentYml", "contextAxmm", "contextYml", "contextAxml", "ctxXitml", "contextXiaml", "contextYmx", "componentYmx", "contextYmm", "componentXML", "contextEML", "contextXmx", "componentXml", "componentXmx", "contextXaml", "contextYML", "contextXmm", "contextXiml"], "src": ["sit", "bh", "sc", "sing", "rob", "zh", "SOURCE", "sel", "https", "rc", "cont", "syn", "url", "secure", "scope", "su", "desc", "ser", "sq", "sp", "ind", "resource", "obj", " sou", "buster", "sl", "cur", "proc", "sol", "sup", "str", "rel", "ln", "st", "from", "txt", "ctr", "sb", "sn", "kk", "dest", "ie", "supp", "sec", "usr", "sr", "tmp", "slice", "comp", "via", "sys", "addr", "Source", "inst", "loc", "skin", "entry", "ident", "filename", "crit"], "source": ["sql", "null", "zip", "in", "sample", "table", "SOURCE", "get", "base", "stream", "se", "it", "scope", "raw", "secure", "parent", "ser", "store", "check", "sp", "iterator", "context", "sequence", "resource", "unit", "buffer", "spec", "image", "seed", "reader", "feature", "service", "console", "ource", "single", "site", "set", "iter", "start", "from", "origin", "copy", "state", "inner", "style", "template", "tree", "ie", "input", "instance", "dest", "sum", "query", "session", "Source", "file", "size", "channel", "format", "entry", "status", "series", "result", "shell"], "zipEntries": ["ipEires", "zipEables", "zoneEnries", "ZipEntries", "Zipentries", "zipEntities", "zipEnies", "zipEities", "zoneEnies", "zipEntarts", "zoneEntities", "zipEntriers", "zipEntryires", "zipErs", "zipenties", "ipEntires", "zipEnities", "zipentities", "zoneEnables", "ZipEntrs", "zoneEnities", "zipEntires", "zipEriers", "ZipEntriers", "zipEnts", "zipentrs", "zipIntrs", "zipEnties", "ipEntarts", "zipEnires", "zipentriers", "zipentries", "Zipenties", "ZipEnties", "zipIntriers", "zipEntrys", "ipEries", "zipEarts", "ipEarts", "zipEnarts", "Zipentrs", "zoneEntries", "ipEntries", "zipEnables", "zipEntryries", "zipEies", "zoneEnties", "zipEntryarts", "Zipentriers", "ipEs", "zipEires", "zipEs", "zipEns", "zipIntries", "zipEntables", "zipEntrs", "zipentables", "zipInties", "zoneEntables", "zipEnries", "ipEnts", "zipEries"], "target": ["project", "module", "t", "text", "goal", "table", "tif", "gt", "pkg", "url", "host", "top", "compatible", "base", "scope", "version", "parent", "peer", "name", "arg", "buffer", "resource", "primary", "owner", "Target", "layout", "route", "term", "rel", "controller", "test", "bolt", "local", "location", "title", "alias", "template", "pattern", "class", "tag", "task", "arget", "match", "chain", "tool", "format", "family", "type", "label", "filename", "handle", "prop", "result"], "webRewriter": ["webRebactor", "webRewrite", "webWriter", "File", "_", "webRewactor", "Entry", "webWactor", "cont", "WebWriter", "WebRewler", "webRewler", "get", "aos", "webWler", "Supp", "New", "log", "webRepactor", "Input", "Log", "webRepriter", "webRebler", "impl", "WebWrite", "WebRewriter", "webWrite", "webRebrite", "webRepler", "WebRewrite", "webRebriter", "WebWler", "webReprite", "json", "println", "WebWactor", "WebRewactor", "entry"]}}
{"id1": "22536033", "id2": "12783713", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"setPayload": ["setMessagements", "getPayload", "Setpayments", "setpayment", "Setpayload", "setMessageLoad", "setPayment", "SetpayLoad", "setHeadloads", "setShipload", "SetPayload", "setShipment", "setpayments", "setPayLoad", "setpayloads", "SetPayLoad", "getPayloads", "Setpayment", "setHeadline", "getPayline", "setpayload", "setMessagement", "setShipLoad", "setHeadLoad", "setPayments", "setMessageload", "setpayline", "setPayloads", "SetPayment", "setPayline", "SetPayments", "setpayLoad", "getPayLoad", "setShipments", "setHeadload"], "fos": ["sfic", "haos", "sfis", "foic", "sfos", "his", "wos", "waos", "fooss", "woss", "faos", " foss", "hoss", "wis", "hos", "foss", "fois", "sfoss", " faos", "foos"], "fis": ["xfsis", "Fos", "sfiss", "sfic", "flsis", "sfis", "flis", " fics", "sfos", "fiss", " fsis", "Fic", "flics", "fsis", " fiss", "fics", "xfis", "Fiss", "xfics", "Fis", "xfic", "flic"], "fic": ["affic", "cfics", "bfics", "fico", "affics", "bfico", "sfics", "fric", "sfic", "Foc", "ufic", "afftic", " fics", "ufoc", "fci", "ufci", "sfico", "cficc", "sfric", "uficc", " fico", "cfic", "Ftic", " fric", "bfci", " ficc", "ftic", "Fic", "fics", "ficc", "ufics", "bfic", "Fics", "affoc", " fci", "cfoc", "ufico", "ufric", " ftic"], "foc": [" foco", "sfoc", "sfic", "Foc", "foco", " fac", "cfic", "sfoca", " fot", " froc", "froc", "flot", "Fic", "cfot", "flroc", "foca", "flac", " foca", "Froc", "floco", "fac", "Fot", "floca", "cfoco", "cfoc", "fot", "flic", "floc", "sfac"], "Index": ["Weight", "Unique", "Socket", "Name", "Loop", "Pos", "Current", "I", "Mass", "Count", "Id", "Thread", "Present", "Insert", "Link", "Series", "Location", "Connection", "Update", "State", "Section", "Iter", "Ind", "Offset", "Handle", "Counter", "Size", "Loc", "Se", "Foot", "Num", "Position", "Exp", "Time", "Out", "Left", "Rank", "Other", "Prime", "Now", "Label", "Limit", "Length", "Column", "Zero", "index", "Row", "Value", "Version", "Fix", "Max", "Next", "Is", "Lock", "Instance", "Info", "Request", "Port", "Key", "Found", "In", "Delta"]}}
{"id1": "13086936", "id2": "3197876", "code1": "            public void run() {\n                waiting(200);\n                txtinfo.post(new Runnable() {\n\n                    public void run() {\n                        txtinfo.setText(\"Searching\");\n                    }\n                });\n                try {\n                    URL url = new URL(urlAddress);\n                    SAXParserFactory spf = SAXParserFactory.newInstance();\n                    SAXParser sp = spf.newSAXParser();\n                    XMLReader xr = sp.getXMLReader();\n                    XMLHandlerReviews myXMLHandler = new XMLHandlerReviews();\n                    xr.setContentHandler(myXMLHandler);\n                    xr.parse(new InputSource(url.openStream()));\n                    if (statuscode != 200 && statuscode != 206) {\n                        throw new Exception();\n                    }\n                    nReviewsOnPage = myXMLHandler.nItems;\n                    statuscode = myXMLHandler.statuscode;\n                    if (nReviewsOnPage > 0) {\n                        authors = new String[nReviewsOnPage];\n                        reviews = new String[nReviewsOnPage];\n                        ratings = new String[nReviewsOnPage];\n                        titles = new String[nReviewsOnPage];\n                        listtext = new String[nReviewsOnPage];\n                        for (int i = 0; i < nReviewsOnPage; i++) {\n                            reviews[i] = myXMLHandler.reviews[i];\n                            authors[i] = myXMLHandler.authors[i];\n                            titles[i] = myXMLHandler.titles[i];\n                            ratings[i] = myXMLHandler.ratings[i];\n                            if (authors[i] == null || authors[i] == \"\") {\n                                authors[i] = \"Anonymous\";\n                            }\n                            if (ratings[i] == null || ratings[i] == \"\") {\n                                listtext[i] = titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            } else {\n                                listtext[i] = \"Score: \" + ratings[i] + \" - \" + titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            }\n                        }\n                        nTotalReviews = myXMLHandler.nTotalItems;\n                        final int fnmin = iFirstReviewOnPage;\n                        final int fnmax = iFirstReviewOnPage + nReviewsOnPage - 1;\n                        final int fntotalitems = nTotalReviews;\n                        if (nTotalReviews > fnmax) {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(0);\n                                }\n                            });\n                        } else {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(8);\n                                }\n                            });\n                        }\n                        if (iFirstReviewOnPage > 1) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(0);\n                                }\n                            });\n                        } else if (nTotalReviews > fnmax) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(8);\n                                }\n                            });\n                        } else {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(4);\n                                }\n                            });\n                        }\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                if (title != null && title != \"\") {\n                                    txtinfo.setText(title + \"\\n\" + getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                } else {\n                                    txtinfo.setText(getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                }\n                            }\n                        });\n                        handlerSetList.sendEmptyMessage(0);\n                    } else {\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                txtinfo.setText(title + getString(R.string.no_reviews_for_this_album));\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    final Exception ef = e;\n                    txtinfo.post(new Runnable() {\n\n                        public void run() {\n                            txtinfo.setText(R.string.search_failed);\n                        }\n                    });\n                }\n                dialog.dismiss();\n                handlerDoneLoading.sendEmptyMessage(0);\n            }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"run": ["pass", "process", "exit", "exec", "update", "fn", "un", "val", "get", "func", "runs", "name", "runner", "print", "call", "r", "play", "running", "apply", "invoke", "Run", "pre", "test", "function", "method", "start", "def", "work", "render", "show", "fun", "loop", "execute", "job", "ran", "thread"], "url": ["ret", "pl", "bel", "ur", "http", "link", "b", "https", "ref", "ls", "base", "gl", "address", "p", "l", "f", "sl", "r", "nl", "rl", "str", "org", "rel", "www", "sb", "location", "ssl", "Url", "web", "mail", "html", "abs", "xml", "loc", "ll", "dl", "open", "URL", "browser"], "spf": ["Spf", " spfr", " spv", "Spcf", "ppcf", "lpcf", "prf", "prcf", "Sph", "ppc", "spc", "spfr", " spc", "prfr", "spcf", "ppf", " sph", "lpf", "lpv", "prc", "Spv", "spv", "ppfr", " spcf", "lph", "sph"], "sp": ["pl", "sc", "parse", "spe", "pp", "esp", "se", "space", "spl", "p", "isp", "op", "spr", "sw", "sf", "service", "sol", "asp", "prep", "lp", "sv", "Sp", "st", "sb", "si", "jp", "par", "bp", "SP", "ph", "pse", "pr", "sk", "xml", "so", "serv", "tp", "bsp", "ps", "pt"], "xr": ["axer", " xer", "xxr", "xxrs", "Xrb", "ixrd", "xR", "axr", "ixrs", "ixer", "Xr", " xrb", "xrd", "axrs", "xrs", "Xer", "xmlr", "xxer", "xrb", "wxr", "wxrb", "wxR", "XR", "xmler", " xR", "xxrd", " xrs", "wxer", "xer", " xrd", "ixr", "axrd", "xmlrd", "xmlrs"], "myXMLHandler": ["myXMmlFilter", "myXHTMLParser", "myXDFStore", "myXCLHandle", "myXMMLParser", "myXSLFilter", "myXLILHandle", "myXILFilter", "myXENTObj", "myXPLHandler", "myYMLFilter", "myXDFHandle", "myXPLParser", "myXXILFilter", "myXILHandle", "myXHTMLReader", "myXXMLHandle", "myXMMLReader", "myXULLDef", "myXMMLDef", "myXmlReader", "myYSLReader", "myXMmlDef", "myXMXHandle", "myXXILParser", "myXmlDef", "myXMXFilter", "myXmlObj", "myXHTMLHandler", "myXILParser", "myXSLParser", "myXMmlHandle", "myXMSLHandler", "myLmlRunner", "myXMLHand", "myYMLHand", "myXMLHandle", "myXXILHandler", "myYMLHandler", "myLmlHandler", "myXILDef", "myXSLHandle", "myXXMLParser", "myLMLRunner", "myXMLDef", "myXCLFilter", "myYMLReader", "myXPLRunner", "myLMLParser", "myXMmlParser", "myXmlParser", "myXMLStore", "myXmlHandle", "myXULLHandle", "myXXSLHandle", "myXMLObj", "myXILHand", "myXMLRunner", "myXDFHandler", "myXCLHandler", "myXMMLFilter", "myXMMLHandler", "myLMLHandler", "myXXSLParser", "myXMMLStore", "myYSLHand", "myXILHandler", "myXMmlHandler", "myXENTHandler", "myXLMLHandle", "myYSLHandler", "myXULLHandler", "myXSLHand", "myXMLParser", "myXLMLObj", "myLmlParser", "myXSLReader", "myXMXParser", "myXMSLHandle", "myXmlRunner", "myXMSLStore", "myXmlHandler", "myXLMLHandler", "myXMXHandler", "myXCLStore", "myXLILHandler", "myXMLFilter", "myXMLReader", "myXILReader", "myXENTHandle", "myXMMLHandle", "myYSLFilter", "myXSLStore", "myXXMLFilter", "myXCLParser", "myXmlHand", "myXLILObj", "myXMmlReader", "myXXMLHandler", "myXXSLFilter", "myXXSLHandler", "myXSLHandler", "myXILObj", "myXmlFilter"], "nReviewsOnPage": ["nReviewmentsInLine", "nReviewsOffPage", "nReviewsAllChild", "nReviewSOnPages", "nReviewsOffBand", "nReviewItemsONPage", "nReviewsInPage", "nReviewsOffpage", "nReviewsMinLine", "nReviewsOnLink", "nReviewsAllLine", "nReviewmentsOnPages", "nReviewsOnlineFrame", "nReviewsonLine", "nReviewsMaxPage", "nReviewsONDisk", "nReviewsOnLine", "nReviewsInpage", "nReviewsONFrame", "nReviewsInLine", "nReviewsMaxLine", "nReviewsONpage", "nReviewmentsInPage", "nReviewsSetpage", "nReviewsonFrame", "nReviewsOnlineDisk", "nReviewsMaxLink", "nReviewsOffLine", "nReviewItemsONLine", "nReviewItemsONpage", "nReviewSOnLine", "nReviewedsOnBand", "nReviewsONPage", "nReviewsFromPage", "nReviewsInBand", "nReviewsAllLink", "nReviewmentsInChild", "nReviewsInChild", "nReviewsOnpage", "nReviewsInColumn", "nReviewsonPage", "nReviewsAllPage", "nReviewsEnColumn", "nReviewsOnBand", "nReviewsOnPages", "nReviewsOnlinePage", "nReviewedsOnpage", "nReviewsOnFrame", "nReviewsEnLine", "nReviewItemsOnpage", "nReviewmentsOnLink", "nReviewmentsInLink", "nReviewedsOffpage", "nReviewsONLine", "nReviewsMinPage", "nReviewmentsOnLine", "nReviewsEnPage", "nReviewsOnDisk", "nReviewsFromLine", "nReviewItemsOnPage", "nReviewsFrompage", "nReviewsonPages", "nReviewsSetBand", "nReviewsInLink", "nReviewsMinPages", "nReviewmentsOnFrame", "nReviewsSetPage", "nReviewsOnColumn", "nReviewsonpage", "nReviewedsOnPage", "nReviewItemsOnLine", "nReviewsOnChild", "nReviewSOnPage", "nReviewedsOffBand", "nReviewmentsOnChild", "nReviewsMaxChild", "nReviewedsOffPage", "nReviewmentsOnPage"], "statuscode": ["scoretext", "statuscase", "scalecode", "compliancecode", "doctag", "atuscode", "statuscache", "atuscount", "versioncount", "statustext", "reasonme", "statusmessage", "reasoncode", "scoretag", "responsekey", "statuskey", "versioncode", "doctext", " statusclose", "atuscoe", "scoremessage", "compliancecache", "doccode", "statustag", "responsecode", "reasonkey", "versiontag", "atusclose", "statuscount", "statusme", "versionmessage", "docmessage", " statuscount", " statuscache", "scorecode", "versionsign", " statussign", "atussign", "versiontext", "statussign", "responseme", "statuscoe", "responsecase", "atuscache", "versionclose", "scalecase", "reasoncase", "scaleme", "statusclose", "compliancecoe", "scalekey", " statuscoe"], "authors": ["history", "leaders", "approved", "notes", "creator", "offs", "codes", "ctors", "versions", "owners", "mods", "rights", "people", "agents", "relations", "artifacts", "issues", "ores", "books", "letters", "mates", "articles", "iers", "chairs", "users", "ians", "cars", "ers", "ins", "rals", "achers", "workers", "casters", "pins", "testers", "uploads", "checks", "sers", "acers", "vers", "weights", "papers", "inals", "headers", "scripts", "abilities", "types", "Users", "phones", "writers", "drivers", "masters", "units", "eers", "runners", "keepers", "archives", "Investigators", "orders", "reports", "names", "terms", "ippers", "rers", "reads", "builders", "lights", "atts", "ors", "icators", "makers", "author", "players"], "reviews": ["servings", "reviewses", "Reviewes", "findes", "defaulteds", "returnses", "replers", "feedses", "returns", "feedjs", "serveds", "Reviewers", "calls", "feeds", "servments", "advings", "advses", "findings", "respondjs", "Reviewments", "servs", "reviewments", "calles", "Reviewses", "reviewes", "rolls", "robments", "rolljs", "Reviews", "Reviewings", "responds", "repls", "finds", "respondses", "revieweds", "robeds", "robs", "reviewjs", "advs", "reviewers", "returnings", "defaulters", "rollses", "reviewings", "defaults", "robings", "callings", "repleds", "Revieweds"], "ratings": [" ratrings", "raties", "statrors", "rankables", "roting", "writios", "rotings", "rubments", "rankies", "statings", "rataries", "reviewios", "rotaries", "ratables", "rankings", "stations", "statuments", "rotiffs", "replains", "ratiffs", "ratuments", "rations", "Ratuments", "ratments", "rubings", "writs", "ratsies", "ratrors", "replies", "ratests", "writing", "ratrings", "ratsings", "statments", "replrors", "requiffs", " raties", "reviewing", "replests", " ratests", "replings", "rubions", " ratiffs", " rating", "Ratios", "repls", "requaries", "writings", "staties", "ratios", "Rating", "ratsrings", "requing", "Rations", "rubuments", "Ratments", "Ratings", "rats", "Ratains", "replions", "ratains", "statests", "statains", "reviewings", " rataries", "Rats", " ratrors", "stats", "ratsables", "rankrings", "requings", "rating", " ratables"], "titles": ["stitles", "tales", " tables", "Tales", "tails", "ttls", " tiles", " turers", "Titles", " tires", "turers", "tyitles", "pitled", " tails", "atables", "tables", "itributes", " tributes", "ttires", "atiles", "stires", "atitles", "sturers", "tls", "Tickets", " tales", "ttitles", "otitles", "atales", "tredits", "Titled", "ttredits", " tredits", "pems", "piles", "tributes", "Tails", "atails", " tls", "pitles", " tickets", "otiles", "titled", "ititles", "ttales", "tyales", "itables", "atributes", "Tiles", "otitled", "tems", "tires", "tyls", "tiles", "tickets", "Tems", "tyredits", "itiles", "tturers", "stiles", "ttiles", "otems", "atickets"], "listtext": ["sharetext", " listinfo", "listpage", "ListText", "listinfo", "printinfo", "listbutton", " listcontent", "listext", "Listoutput", "searchbutton", "shareext", " listbutton", " listText", "printText", " listext", "Listpage", " listoutput", "searchText", "Listmessage", "printtext", "Listtext", "searchtext", "printcontent", "listcontent", "listoutput", "Listext", "sharemessage", "listText", "shareoutput", "Listinfo", "Listbutton", " listpage", "searchpage", "listmessage", " listmessage", "Listcontent"], "i": ["info", "m", "t", "err", "b", "I", "oi", "y", "menu", "f", "io", "x", "me", "init", "ie", "index", "json", "cgi", "u", "gi", "j", "o", "pi", "it", "di", "zi", "ai", "\u0438", "q", "iri", "bi", "li", "loop", "key", "go", "z", "in", "phi", "ii", "qi", "ti", "batch", "ini", "history", "hi", "this", "v", "multi", "iu", "ip", "cli", "ij", "ki", "xi", "is", "fi", "ei", "ji", "iq", "ci", "mi", "h", "ui", "id", "s", "ic", "l", "g", "si", "ri", "point", "ix", "ami", "chain"], "nTotalReviews": ["nTotalReadings", "nMaxReviews", "nTotalViewings", "nMaxReviewers", "nMaxViewItems", "nTotalViewers", "nTotalReaders", "nTotalViewItems", "nTotalReadItems", "nTotalReviewItems", "nTotalReviewings", "nMaxViews", "nTotalObjecters", "nTotalObjects", "nMaxViewers", "nTotalViews", "nTotalObjectings", "nTotalReads", "nMaxReviewItems", "nTotalReviewers", "nMaxViewings", "nMaxReviewings", "nTotalObjectItems"], "fnmin": [" fnpos", "finmin", "fMin", " fnMin", "fmin", "finpos", " fncount", "fpos", "finMin", "fcount", "fincount"]}}
{"id1": "15241397", "id2": "15797402", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", " doPut", "doGET", "Doget", "DoGet", "handleget", " doget", "doget", " doGET", "DoGET", "handlePut", "DoPut", "doPut", "handleGET"], "request": ["re", "each", "QUEST", "forward", "http", "in", "setup", "document", "get", "reference", "quest", "address", "client", "question", "message", "the", "context", "connection", "reset", "report", "req", "transform", "application", "user", "create", "start", "input", "position", "server", "current", "query", "first", "frame", "initial", "Request", "hello", "command", "complete", "attribute"], "response": ["answer", "send", "http", "exit", "resp", "document", "fire", "object", "onse", "success", "version", "block", "ce", "connection", "message", "image", "context", "resource", "sequence", "report", "print", "reset", "ve", "content", "write", "service", "respond", "application", "res", "console", "site", "output", "page", "reply", "position", "server", "network", "Response", "body", "next", "json", "session", "frame", "description", "xml", "view", "form", "status", "result"], "rewrittenQueryString": ["rewrittenQueryStr", "rewwrittenqueryQuery", "rewrittenURLStr", "rewrittenqueryString", "rewwrittenQueryStr", "rewrittenQuStr", "rewrittenQueryQuery", "rewrittenQuString", "rewrittenqueryQuery", "rewliedqueryStr", "rewartedQueryStr", "rewrittenCurrentQuery", "rewliedqueryString", "rewartedQueryString", "rewwrittenQuerystring", "rewwrittenqueryStr", "rewrittenQustring", "rewartedQuerystring", "rewrittenqueryStr", "rewliedQueryStream", "rewrittenQueryStream", "rewrittenRequeststring", "rewrittenQuerystring", "rewrittenHeaderStream", "rewrittenquerystring", "rewrittenRequestString", "rewwrittenquerystring", "rewrittenRequestQuery", "rewrittenURLstring", "rewrittenHeaderStr", "rewartedHeaderString", "rewrittenCurrentstring", "rewartedHeaderStream", "rewartedHeaderStr", "rewwrittenQueryString", "rewrittenURLString", "rewwrittenQueryQuery", "rewartedHeaderstring", "rewrittenQuestionStream", "rewrittenCurrentString", "rewrittenHeaderstring", "rewliedQueryString", "rewrittenQuestionStr", "rewwrittenqueryString", "rewrittenQuStream", "rewrittenRequestStr", "rewrittenQuestionString", "rewliedQueryStr", "rewliedqueryStream", "rewrittenHeaderString", "rewartedQueryStream", "rewrittenCurrentStr", "rewrittenURLStream", "rewrittenqueryStream"], "rewrittenUrl": ["rewriteUrl", "RewwrittenString", "rewittenurl", "rewrittenurl", "rewwrittenLink", "RewrittenUr", "RewwrittenUr", "rewriterUr", "RewwrittenURL", "rewwrittenURL", "rewriddenURL", "rewrotePosition", "rewroteUrl", "rewroteURL", "rewriteURL", "Rewrittenurl", "rewrownUr", "rewrittenString", "rewrittenLink", "RewrittenLink", "rewadjustedPort", "RewrittenPosition", "rewrittenPosition", "rewroteUr", "rewartedPosition", "Rewwrittenurl", "RewwrittenLink", "rewittenUrl", "rewadjustedUrl", "RewrittenUrl", "rewwrittenString", "rewedURL", "rewrownURL", "RewrittenString", "rewartedUr", "rewriddenUrl", "rewrownUrl", "RewwrittenPort", "rewriddenPosition", "rewartedUrl", "RewrittenURL", "rewrapedURL", "RewrittenPort", "rewwrittenPosition", "rewroteLink", "rewartedURL", "rewriteUr", "rewrittenPort", "rewrownPosition", "rewriterString", "rewartedurl", "rewadjustedUr", "rewedUrl", "rewriterUrl", "rewittenURL", "rewriterURL", "rewwrittenPort", "rewrapedUr", "RewwrittenPosition", "RewwrittenUrl", "rewwrittenUr", "rewedString", "rewittenLink", "rewrittenURL", "rewriddenUr", "rewwrittenUrl", "rewedUr", "rewriteurl", "rewroteurl", "rewadjustedURL", "rewrittenUr", "rewwrittenurl", "rewrapedPort", "rewrapedUrl"], "httpURLConnection": ["httpRLConnect", " httpUrlconnection", "httpHTTPApplication", "HttpUrlConnect", "ttpUrlApplication", "httpFileConn", "ttpURLControl", "httpSRconnection", "httpRLconnection", "httpUrlConnection", " httpURLConnect", "ttpURLConnection", "httpUrlConnect", "httpUrlConfiguration", "httpRLApplication", "httpMLConnection", "HttpHTTPConnect", "httpUrlControl", "httpURLConn", "httpHTTPConn", "HttpUrlconnection", "HttpURLApplication", "ttpURLApplication", "ttpUrlControl", "httpURLConnect", "HttpURLConfiguration", "ttpUrlConnect", "httpHTTPConnection", "HttpURLConnection", "ttpURLconnection", "ttpUrlConn", "httpHTTPconnection", "httpUrlConn", "httpMLConnect", " httpUrlApplication", "httpRLConnection", "HttpHTTPConnection", " httpURLconnection", "httpURLControl", "HttpURLConnect", "httpSRApplication", "HttpURLconnection", "HttpUrlConnection", "httpURLConfiguration", "ttpURLConn", "httpHTTPControl", "ttpUrlconnection", "httpFileConnect", "httpSRConfiguration", " httpURLApplication", "httpURLconnection", "httpSRControl", "HttpHTTPApplication", "httpURLApplication", " httpUrlConnection", "httpSRConnect", "httpHTTPConnect", "httpMLApplication", "ttpUrlConnection", "HttpHTTPConfiguration", "ttpURLConnect", "HttpHTTPconnection", " httpUrlConnect", "httpFileApplication", "httpHTTPConfiguration", "httpUrlApplication", "httpSRConnection", "httpMLconnection", "httpFileConnection", "httpUrlconnection"], "header": ["info", "detail", "column", "shift", "heading", "handler", "variable", "rule", "component", "option", "h", "holder", "line", "prefix", "version", "block", "part", "check", "device", "peer", "filter", "address", "client", "buffer", "port", "er", "wrapper", "feature", "hidden", "padding", "term", "argument", "user", "Header", "headers", "init", "metadata", "dr", "page", "title", "state", "token", "operator", "section", "core", "head", "meta", "zone", "query", "relation", "tag", "hash", "ter", "comment", "layer", "field", "format", "policy", "handle", "status", "event", "attribute"], "value": ["record", "email", "sample", "expression", "val", "property", "default", "VALUE", "pair", "version", "python", "address", "name", "message", "values", "v", "sequence", "unit", "password", "element", "content", "example", "sv", "test", "see", "create", "language", "string", "save", "instance", "server", "current", "Value", "zone", "json", "hash", "des", "description", "comment", "data", "ue", "hello", "entry", "field", "key", "label", "text", "attribute", "job", "format", "vector"], "inputStream": ["outputLoop", " inputView", "InputLoop", "InputThread", "errorSteam", "errorWindow", " inputstream", "outputSteam", "inputThread", " inputWindow", " inputLoop", "inputLoop", "outputstream", "InputView", "inputSteam", "outputWindow", "errorstream", "inputView", " inputSteam", " inputThread", "inputstream", "outputView", "errorStream", "InputStream", "inputWindow", "outputThread"], "outputStream": ["responseForm", "outputForm", " outputForm", " outputstream", "OutputLength", "outputLength", "outputSteam", "displayStream", "OutputStream", "responseStream", "displaySteam", "outputstream", "inputSteam", "OutputForm", "responseSteam", "inputView", "responseLength", "displaystream", " outputView", "inputstream", "OutputSteam", "outputView", " outputLength", " outputSteam", "displayView"]}}
{"id1": "12389873", "id2": "20210699", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"load": [" fill", " read", " reload", " cleanup", " destroy", " register", " validate", " find", " parse", " construct", " ping", " fetch", " build", "construct", " startup", " ingest", " Init", "init", "save", " recover", " dump", " test", " scan", "insert", "execute", " search", " refresh"], "conn": ["dn", "nc", "cn", "gate", "c", "close", "coll", "mc", "ch", "pen", "cc", "ct", "pg", "pas", "cp", "ns", "Con", "Connection", "connection", "client", "obj", "mn", "mt", "cur", "Conn", "enc", "yn", "wr", "org", "n", "rel", "ln", "cmd", "die", "act", "ens", "ctx", "ctr", "en", "comm", "ds", "cfg", "con", "conf", "nt", "conv", "com", "db", "cb", "connect", "ann", "co", "open", "cert", "col", "pt"], "stmt": ["estgr", "stackpt", "constst", "putmm", "estmg", "restaddr", "stacktab", " staddr", "strmn", "Stmem", "esttx", "stytx", "STMT", "estgt", "ostgr", "stackmid", "ostmid", " stcmd", "staddr", " superststat", "Stst", " stMT", "styaddr", "histmt", "stackgt", "STmsg", " stmn", "restgr", "stMT", "puttab", "styMT", "stopmt", "restpt", "stackMT", " sttx", " stpt", "Stmb", "Stmt", "STmb", "putolt", " strm", "stmn", " superstmg", "stmem", "sttr", "stst", " stmem", "constMT", "stopmn", " stmsg", "Stmsg", "stoprm", "STgt", " stmb", " Stm", "Stgt", " stgr", "sttab", "stmg", "putmt", "ostmn", "strm", "resttx", "istgt", " stmg", " sttr", "puttx", " stst", "strmg", "stym", "ostmm", "constm", "osttab", " Sttr", " stmm", "stackmm", " stmid", "stopmm", "strstat", "putMT", "restmp", "ststat", " ststat", "restmg", " Stmt", "stackolt", " superstMT", "ostrm", "Stmm", "stackmt", "stcmd", "histcmd", "STmt", "strmt", " stm", "estm", "istMT", "stymem", "stolt", "restMT", "histtry", "stm", "stymg", "estmt", "ostpt", "sttry", "stmid", "Stm", "stymb", "ostolt", "Stcmd", " stgt", "putmp", "stgr", " superstmt", "histgt", "stmm", " StMT", "constmt", " superstmn", "stmp", "ostgt", "restmm", " stolt", "estmb", " stmp", "istmt", "sttx", "Sttry", "restgt", "stymsg", "Stgr", "StMT", "ostmem", "stygt", "restmt", "ostmt", "stmsg", "stmb", "STtx", " superstm", "stymt", "estmm", "stgt", " sttry", "stpt", " supersttr"]}}
{"id1": "21181542", "id2": "10436471", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public Cal3dModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        Cal3dModel model = new Cal3dModel(getFlags());\n        loadCal3dModel(getBaseURL(), url.toExternalForm(), new InputStreamReader(url.openStream()), model);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteResourceType", "deleteResourceTyp", "deleteGroupType", "deleteRoleTypes", "deleteGroupTyp", "DeleteRoleType", "DeleteRoleTyp", "deleteRoleTyp", "DeleteRoleTypes", "deleteResourceTypes", "deleteGroupTypes"], "id": ["info", "t", "orig", "in", "link", "pid", "mid", "val", "ion", "end", "path", "aid", "ref", "Id", "h", "hide", "url", "key", "it", "add", "ide", "part", "oid", "name", "p", "kid", "l", "sid", "vid", "created", "only", "like", "x", "bid", "iden", "ids", "node", "no", "uid", "ID", " pid", "create", " tid", "def", "instance", "rid", "show", "index", "i", "edit", "hash", "is", "ident", "type", "time", "and", "event", "d"], "namespaceId": ["workspaceRef", "namesadeAnd", "workshipId", " namespaceID", "nameshipKey", "worksplaceid", "namesaceKey", "namesspaceId", " namesiteIdent", "typespaceID", "namesACEAnd", "namespaceAnd", "namespacesRef", "namesetId", "namesenceOr", "nameshipID", "namesaceId", "namesplaceRef", "namesiteLog", "namesspaceID", "worksetID", "namesiteId", "namesspaceAnd", "workspaceID", "typesACEID", "worksetAnd", "namesiteOr", " namesiteLog", "namespacesId", "namespointId", "namesenceIdent", "typesACEId", "workshipKey", "namespacesid", "namespaceID", "namespointAnd", "namespointRef", "namespaceRef", "namespaceid", " namespaceOr", "namesaceID", "namesistenceIdent", "namesenceLog", "namesiteIdent", "workshipid", "namespaceBirth", "worksplaceName", "namesistenceLog", "workspaceAnd", "namespaceOr", "namesetAnd", "namesositoryID", "worksetid", "namesenceBirth", "namespaceIdent", "namespacesID", " namesenceBirth", "namesplaceId", "namesadeId", "namesositoryId", "workspaceId", "namespacesKey", "nameshipid", "namespaceName", "namesspaceid", "namesplaceid", "typespaceAnd", " namesiteId", "workspaceid", "workshipID", "namesadeID", "workspaceName", " namespaceLog", "namespointID", "namespointName", " namespaceIdent", "namesistenceId", " namesenceId", "namesACEId", "namespaceLog", " namesiteOr", "namesistenceOr", "typesACEAnd", " namespaceBirth", "worksetId", "worksplaceId", "namespaceKey", "workspaceKey", "namesenceID", "namespacesName", "typespaceId", "namesetID", "namesenceId", "namespointid", "namesositoryBirth", "namesetid", " namesenceID", "namesplaceName", "worksplaceRef", "namesACEID", "nameshipId", "namesaceid", "namespacesBirth", "namespacesAnd"], "removeReferencesInRoleTypes": ["removeReferencesInMultipleType", "removeReferencesInRoleNames", "removeReferencesInRuleNames", "removeReferencesInRightNames", "removeReferencesInMultipleTypes", "removeReferencesFromRoleNames", "removeReferencesInMultipleNames", "removeReferencesFromMultipleNames", "removeReferencesInroleNames", "removeReferencesInRoleFiles", "removeReferencesInRuleTypes", "removeReferencesInMultipleFiles", "removeReferencesFromRoleTypes", "removeReferencesInRightTypes", "removeReferencesInRightType", "removeReferencesFromMultipleTypes", "removeReferencesInRuleFiles", "removeReferencesInRuleType", "removeReferencesFromMultipleFiles", "removeReferencesFromroleFiles", "removeReferencesFromroleNames", "removeReferencesInroleFiles", "removeReferencesFromroleType", "removeReferencesFromroleTypes", "removeReferencesInroleTypes", "removeReferencesFromMultipleType", "removeReferencesInRightFiles", "removeReferencesFromRoleType", "removeReferencesFromRoleFiles", "removeReferencesInroleType", "removeReferencesInRoleType"], "permit": ["permiss", "promit", "Permiss", "PERmitted", "proMIT", "PERmission", "perMIT", "PERMIT", " perMIT", "PERmit", "Permitted", "promitted", " permitted", "PERmiss", "PerMIT", "permission", " permiss", "permitted", "promission", "Permission", "Permit"], "exist": ["purpose", "mark", "meet", "include", "have", "existent", "cont", "icate", "register", "require", "add", "keep", "there", "ready", "use", "list", "filename", "login", "remember", "write", "respond", "same", "define", "ist", "see", "create", "find", "missing", "establish", "save", "alias", "know", "current", "present", "existing", "ext", "connect", "attach", "existence", " extant", "status"], "msgBuf": [" msgRbuf", " msgRbuff", " msgMbuf", "messagePuff", "messageBfg", "messagePbuf", "messageRuf", "msgMbuff", "msgCuff", "msgGbuf", "messagePuf", "msgRlim", "messageMuf", " msgBlim", "msgBsuf", "msgAbuf", " msgMuf", "msgPlf", "msgRuff", "msgGbuff", "messageBlf", "msgPbuf", "messageBuff", "messageBbuff", " msgCuff", "msgBsfg", "msgCbuf", "messageRuff", " msgCfg", "msgBbuf", "msgBeuf", "msgBfg", " msgBbuff", " msgRlim", "msgBsuff", "msgBeuff", "messageRbuff", "messageMbuff", "msgBbuff", "msgBsbuf", "msgRfg", "msgPuff", "msgPbuff", " msgBfg", " msgBuff", " msgBbuf", "msgBuff", " msgMuff", "messageRlf", "messageRbuf", " msgCbuf", "msgCuf", "msgAuff", "msgCfg", "msgCbuff", "msgPuf", " msgMbuff", " msgCuf", "msgBlf", "messageMuff", "msgPfg", "msgVuf", "msgBlim", "msgVbuf", "msgMbuf", "msgBefg", "msgBebuf", "msgRbuf", "msgRlf", "msgGuf", "msgRbuff", "msgAbuff", "messageMbuf", "messagePfg", "msgVuff", "msgAuf", "messageBbuf", "messageBuf", "msgVbuff", "msgMuf", "msgMuff", " msgRuf", "msgRuf", "msgGlim"], "objects": ["faces", "frames", "packages", "jobs", "authors", "versions", "codes", "pages", "resources", "docs", "points", "files", "relations", "artifacts", "books", "errors", "articles", "values", "workers", "flows", "items", "uploads", "blocks", "bits", "oids", "lines", "assets", "ids", "airs", "headers", "links", "organisms", "keys", "ports", "locks", "products", "units", "plugins", "tools", "parts", "projects", "apps", "builders", "models", "beans", "classes", "ors", "images", "obs"], "sqlRightId": [" sqlrightRef", "sqlrightid", " sqlRightid", "qlRightId", " sqlrightid", "qlRightid", "sqlHeadid", "sqlrightById", "sqlLeftName", "qlrightid", "sqlRightName", "sqlrightId", "sqlRightRef", "sqlRightid", "sqlHeadRef", " sqlRightRef", "qlRightName", "sqlLeftId", "sqlrightRef", "qlrightId", "sqlRightById", " sqlRightById", "sqlHeadById", "sqlrightName", "qlrightName", " sqlrightId", "sqlLeftid", " sqlrightById", "sqlHeadId"], "sqlParent": ["sysOwner", "sqlOwner", "sqlChild", "sprparent", "invparent", "sprChild", "sprParent", "sprOwner", "invOwner", "invChild", "sysParent", "sqlparent", "invParent", "sysChild", "sysparent"], "sql": ["drop", "params", "diff", "orm", "security", "statement", "md", "spec", "password", "term", "action", "cmd", "cfg", "template", "SQL", "body", "json", "session", "db", "sys", "comment", "description", "data", "execute", "dl", "acl", "command", "ql"], "pstmt": ["pctmp", "pastmm", "pastMT", "pondStatement", "pctms", "pthms", "pstatmm", " pstmp", "pstatms", "context", "pstem", "PStm", "pstmk", "pStm", "postm", "Pstr", "insert", " pstms", "pstatem", "pstng", "pstm", "pstartr", "PStng", "pthem", " pstatmp", "Pstatmm", "Exception", "Pstmt", " pstatmt", "pastmk", "pndMT", "Pstm", "postMT", "pthmp", "pondmm", "pondm", "NULL", "pstStatement", "PstatStatement", "wpastmt", "Pstatm", "pStng", "postmt", "pstmp", "wpastm", "tx", "Pstng", "postmk", "pastm", "pastmt", "Pstmm", "pstMT", " pstatem", "pctmt", "pstatmt", "PStr", "Delete", "pstmm", "wpstmt", "pstartng", "pondmt", "wpstmk", "PStmt", "pstms", "pctem", "pthmt", "def", "pstr", " pstem", "wpastMT", "PstStatement", "pstatmp", "pstatStatement", "_", "pndm", "wpstm", "Pstatmt", "pstatm", "NEW", "wpastmk", "pStmt", "pstartmt", "create", "pastStatement", "pstartm", "pndmt", "nt", "pStr", " pstatms", "wpstMT", "pndmk"], "typeGid": ["typeCid", "typeRegid", "typeGuids", " typeGno", " typeCid", "typeGID", "TypeCid", "typeGId", "TypeCID", "typeGuID", "typeGuid", " typeCids", "typeCno", "typeCId", "typeRegId", "typeGuno", "typeGenid", "typeGenids", "typeCID", "typeRegID", "TypeGid", "typeCids", "typeGno", "TypeCId", "typeGuId", "typeGids", " typeGids", "TypeGID", " typeCno", "TypeGId", "typeGenno"], "defaultLevel": ["DefaultLevel", " defaultMode", "Defaultlevel", "DefaultMode", "defaultDepth", "errorlevel", "defaultlevel", "defaultMode", "errorLevel", "DefaultDepth", " defaultlevel", " defaultDepth", "errorDepth", "errorMode"], "success": ["info", "pass", "failed", "successful", "Success", "progress", "close", "rc", " succeed", "ok", "submit", "warn", "error", "summary", "primary", "unknown", "good", "undo", "state", "save", "continue", "first", "fail", "successfully", "status", "result", "accept"]}}
{"id1": "17583193", "id2": "4398382", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "label": 0, "substitutes": {"populateRecord": ["populaterecord", "populateRec", "populatesData", "populatesrecord", " populatesRec", "populatesRecord", "populatedRec", "populatesRec", " populaterecord", "populatedData", "popupdaterecord", "popupdateRec", " populateData", "populatedRecord", " populatesrecord", " populateRec", "populateData", " populatesRecord", "populatedrecord", "popupdateData", " populatesData", "popupdateRecord"], "attrIDs": ["attrEMS", "adjUES", "adjIDs", "rmIDs", "aaaIDs", "attrLS", "permIDs", "immID", "rmIDS", "arrIDS", "attributeFiles", "addrKids", "attID", "immIDs", "attFiles", "sortKids", "errUES", "aaaLS", "attIDs", "cmpIDS", "sortids", "rmById", "cmpIDs", "attById", "permID", "filterids", "attIDS", "attrById", "attFS", "attributeKids", "attributeIDS", "immEMS", "filterIDs", "urgIDs", "permIDS", "attributeID", "attrUES", "attributeById", "addrUES", "attributeFS", "urgENTS", "errIDS", "permFS", "addrIDs", "arrKids", "filterKids", "immIDS", "arrIDs", "urgIDS", "attEMS", "attrIDS", "urgLS", "filterIDS", "aaaENTS", "attrENTS", "attrID", "sortFiles", "sortID", "arrids", "attributeids", "errIDs", "rmID", "attributeENTS", "addrids", "attrFS", "adjIDS", "attrFiles", "attrids", "addrIDS", "attributeEMS", "attrKids", "attributeIDs", "attributeLS", "aaaIDS", "sortIDS"], "i": ["info", "m", "err", "c", "iti", "us", "I", "e", "y", "f", "io", "x", "ori", "me", "init", "ie", "ik", "index", "eu", "d", "u", "ia", "gi", "o", "pi", "it", "di", "ind", "zi", "er", "print", "ai", "\u0438", "q", "bi", "li", "status", "ir", "im", "z", "in", "phi", "ii", "qi", "my", "ti", "ini", "hi", "list", "v", "multi", "uri", "n", "iu", "iter", "ip", "cli", "ij", "ki", "xi", "is", "ei", "ji", "iq", "ci", "mi", "h", "base", "wi", "parent", "ui", "name", "p", "ic", "l", "g", "ni", "si", "ri", "sim", "ix", "ami", "ims", "chain", "ity", "any"], "sortIDs": ["sortLS", "sortUES", "SortLS", "successDOS", "attrEMS", "saveIDS", "SortIDS", "ortDocuments", "SortIDs", " sortIDS", "servID", "ortIDS", "attrLS", "parseIDS", "saveMS", "ortDetails", "shareDOS", "servMembers", "sortKids", "syncIDS", "saveResults", " sortKids", "servIDs", "sortDetails", " sortIDES", "sortids", "SortMembers", "altKids", "sortDOS", "altEMS", " sortTags", "filterDocuments", " sortBs", "sortEMS", "ortBs", "sortMS", "parseIDs", "successIDs", "altIDS", "sortMembers", "updateEMS", "successTags", "altIDs", "servResults", "saveLS", "servensions", "servTags", "attrMS", "orderIDs", "servFiles", "saveIDs", "filterIDs", "saveIDES", "SortEMS", "sortVs", "ortIDs", "ordIDs", "updateIDS", " sortID", "orderDOS", "sortBs", "sortensions", " sortDetails", " sortVs", " sortFiles", "successKids", "altBytes", "saveKids", " sortBS", "sortBytes", "servids", " sortResults", "ortResults", "ortID", "ordids", "sortResults", "successEMS", "sortIDES", " sortensions", "relationMembers", "relationIDS", "orderUES", " sortMS", " sortMembers", "sortTags", "updateIDs", "saveIE", "filterKids", " sortBytes", "shareKids", "successUES", "syncIDs", "syncBytes", "shareIDs", "servDetails", "attrIDS", "orderKids", "filterIDS", "sortDocuments", "syncEMS", " sortids", "shareUES", "ordIDS", "SortIE", "servEMS", "attrID", "sortFiles", "parseIDES", " sortEMS", "successIDES", "sortID", "filterBs", "updateMembers", "sortBS", " sortDocuments", "successIDS", "attrFiles", "attrids", "servIDS", "servKids", "sortIE", "ordEMS", "ortVs", "relationensions", "altIDES", "filterIDES", "attrKids", "attrIE", "servVs", "servBS", "ortids", "sortIDS", "parseKids", "relationIDs", "ortBS"], "j": ["ji", "m", "err", "z", "other", "d", "b", "c", "jo", "it", "e", "ind", "adj", "kj", "y", "v", "obj", "jit", "er", "l", "bo", "k", "by", "r", "beta", "J", "out", "q", "x", "jet", "ja", "js", "oj", "g", "rel", "n", "je", "uj", "jj", "ij", "jp", "dj", "jl", "tr", "br", "next", "json", "pr", "ix", "fr", "el", "jac", "aj", "job", "jc", "bj", "jump", "pt"], "temp": ["porary", "tt", "tim", "perm", "mod", "tc", "t", "orig", "read", "length", "alt", "variable", "fake", " tmp", "EMP", "mem", "buffer", "emp", " Temp", "term", "pre", "test", "txt", "set", "unt", "template", "current", "tmp", "prime", "cum", "rem", "ptr", "wait", "tm", "tty", "tem", "mp", "Temp", "thread"]}}
{"id1": "7872659", "id2": "10451698", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndVideoIndexFiles", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndVideoindexfile", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndVideoindexTable"], "completePath": ["completeDir", " completesLocation", "totalPod", "CompleteLocation", " completesDirectory", "COMPLEScript", " completeDirectory", "CompleteDirectory", "fullPod", "completeScript", "CompleteProject", "pletionPath", "totalRoot", "completePod", "completeProject", "completeNow", "COMPLEDir", "COMPLEPath", "pleteScript", " completeDir", "fullPath", "pleteNow", "CompletePath", "CompleteLog", "fullRoot", "totalLocation", "completeRoot", "pleteProject", "pletionProject", "pletePath", "pleteLog", "CompleteDir", "completeLocation", "pletePod", "totalPath", "CompleteNow", "pletionNow", "pletionDir", "completeLog", " completeLocation", "pleteDir", "completeDirectory", "fullLocation", "pleteLocation", " completesDir", "pleteRoot", " completesPath", "CompleteScript", "COMPLELog"], "masterFile": ["managerfile", " masterFilename", "managerFilename", "currentFile", "MasterFile", "masterPath", "masterName", "managerPath", "MasterFilename", " masterPath", " masterfile", "MasterPath", "completeName", "managerFile", "currentName", "completeFile", "masterfile", "masterFilename", "Masterfile", "currentfile", "currentPath", "MasterName", "completefile"], "CustRatingFileName": ["CustRatingFileNames", "CustRatingFilenameName", "CustRatingFilenameType", "CustRatingTablename", "CustRatingFileType", "CustRatedFileNames", "CustRankFilename", "CustRankFilesname", "CustRatingTableName", "CustRankFileInfo", "CustRankFilesInfo", "CustRatedfileName", "CustRatedFileName", "CustRatedFileSet", "CustRatingfileSet", "CustRatingfileName", "CustRatingFilenameSet", "CustRatingfileNames", "CustRankFilesName", "CustRankFileType", "CustRatingFileInfo", "CustRankFileName", "CustRatingFieldInfo", "CustRatingTableType", "CustRatedfileNames", "CustRatingTableSet", "CustRatingTableInfo", "CustRatingFilename", "CustRatingFilesInfo", "CustRatingFieldName", "CustRatingFieldType", "CustRatingFieldname", "CustRatingFileSet", "CustRatingfileType", "CustRatedFileType", "CustRatedfileType", "CustRatedfileSet", "CustRatingFilesname", "CustRatingTableNames", "CustRankFilesType", "CustRatingFilenameNames", "CustRatingFilesType", "CustRatingFilesName"], "MovieIndexFileName": ["MovieindexfileNumber", "MovieindexFileKey", "MovieIndexfileType", "MovieIndexTableName", "MovieIndexFieldKey", "MovieindexFileType", "MovieIndexFILENumber", "MovieindexFileName", "MovieIndexTableNames", "MovieIndexFieldName", "MovieIndexTableType", "MovieIndexFileKey", "MovieIndexFileType", "MovieIndexFileNumber", "MovieIndexFILEType", "MovieindexFileNames", "MovieIndexFieldType", "MovieIndexFileNames", "MovieindexfileName", "MovieindexfileNames", "MovieIndexFILEName", "MovieIndexTableKey", "MovieindexFileNumber", "MovieIndexfileNames", "MovieIndexFILENames", "MovieIndexfileKey", "MovieindexfileKey", "MovieIndexFieldNames", "MovieIndexfileName", "MovieindexfileType", "MovieIndexfileNumber"], "inFile": [" infile", "localFILE", "localFile", "localfile", "inFILE", "INFile", "outFile", "localC", "INC", "INfile", "INF", "outfile", "infile", "INFILE", "outC", " inFILE", "inF", "outF", " inF"], "inC": ["iR", " inCS", "outG", "outCL", "outFile", "inCI", "inputC", " outC", "intCI", " inR", "iCI", " outL", "inL", " inL", "intR", "iC", "inG", " inCL", "inCL", "iCS", " outF", " inCI", "inputFile", " outCL", "inputG", "outC", "intC", "intCS", " inG", "inR", "inputF", "inF", "outF", "inCS", "outL", " inF"], "outFile1": ["outputFileOnce", "outChannel1", "outFILE2", "outfile1", " outfile6", " outfile1", "outFile6", "outFileOnce", "outfile6", " outFile6", "outChannelOnce", "outFile0", "outputPageOne", " outfile2", "outPageOne", "outFILE1", "outFileOne", "outfile0", "outPage1", "outputFile9", "outFILE0", "outPageOnce", "outPage0", "outputPage9", "outPage2", "outputPageOnce", "outFILE6", "outChannel9", "outputPage1", "outputFileOne", "outPage9", "outFile9", " outfile0", "outPage6", " outFile0", "outChannelOne", "outputFile1", "outfile2"], "outC1": ["inC3", "outCB1", "outc2", "outR3", "inFile2", "outc1", "inC2", "outCB0", "outROne", "outC3", "outCB3", "inC0", "outPOne", "outFileOne", "outCB2", "outC0", "outR1", "outP1", "outc3", "outCOne", "inC1", "outP2", "outR2", "inFile3", "inCOne", "outc0", "inFileOne", "outP3", "inFile1", "outFile3"], "outFile2": ["exChannel3", "outTable3", "outChannel1", " outFile3", "outfile1", "outTableTwo", "outFile0", "outFile02", "exFile2", "outTable02", "outChannel0", "outfile0", "outTable2", "exChannel1", "outfile2", "exChannel2", "outF2", " outFile02", "outF0", "exChannel0", "outfileTwo", "exFile3", "exFile1", "outChannel3", "exFile0", "outChannel2", " outFileTwo", "outF1", "outFileTwo", "outF3", "outfile3", "outfile02", "outFile3"], "outC2": ["OutR4", "outBTwo", "outR3", "allB22", "outB3", "outS2", "outS22", "outCTwo", "outE4", "OutR1", "OutC1", "OutC3", "outE3", "allC3", "allBTwo", "outC3", "outE2", "OutR2", "allC2", "outE1", "outS3", "outR4", "outB22", "OutR3", "outM3", "outR1", "outSTwo", "outC22", "OutC4", "outM2", "allB2", "outB2", "outC4", "allB3", "outM22", "allC22", "outMTwo", "outR2", "OutC2", "allCTwo"], "fileSize": ["byteSIZE", "baseName", "issueSize", "baseSIZE", "fileSIZE", "fileLength", "FileSize", " fileCount", "issueLength", "baseCount", "fileName", "FileSIZE", " fileName", "FileLength", "baseSize", "fileCount", " fileSIZE", "byteLength", "FileCount", "issueSIZE", "issueName", "byteSize", "byteName", "FileName", " fileLength"], "totalNoDataRows": ["totalNodataRecows", "totalNoDataSloles", "totalNoDataSlocks", "totalNoDataRoles", "totalNodataRecoles", "totalNodataRecocks", "totalNodataRows", "totalNoDataRecues", "totalNoDataSlows", "totalNoDataBoles", "totalNoDataRecoles", "totalNoDataRocks", "totalNoDataBows", "totalNoDataRues", "totalNoDataRecocks", "totalNodataRecues", "totalNoDataBocks", "totalNodataRocks", "totalNoDataRecows", "totalNodataRues", "totalNodataRoles", "totalNoDataBues", "totalNoDataSlues"], "mappedBuffer": ["mapedbuffer", " mappedCounter", " mapperCounter", "MappedBB", " mapperQueue", "mmappingbuffer", "mapedCallback", "matchedQueue", "mapedData", "MapedBuffer", "mressedFB", " mappedCallback", "MappedBuff", "mmappedBuff", "mapperCounter", "mmappingBuff", "mapperbuffer", "mapperBB", " mapedCallback", "MapperBB", "mappingQueue", "mapBuff", "mapedQueue", " mapedBuff", "maphBuffer", "matchedCounter", "mappedCounter", "maphFB", "mapedFB", "mappingbuffer", "mappedCallback", " mappedBuff", "mapBuffer", "mappingBB", "MapedBB", "mmappedBuffer", "mmappedbuffer", "mressedBuffer", " mappedFB", "MapperBuffer", "mappingBuff", "maphCallback", " mappedQueue", "mapedBuff", "mapperBuffer", "mappedQueue", "mmappingBuffer", "MapperBuff", "MapedBuff", "mappedData", "mmappingQueue", " mapperBuffer", "matchedBuff", "mapedBB", "mattedBB", "mattedBuffer", "mattedBuff", "MappedData", "matchedBuffer", " mapedBuffer", "mressedBuff", "mapBB", "mappedbuffer", "mappingBuffer", "mappedBB", "mappedBuff", "mapedBuffer", "mappingCounter", "mappingData", "mressedCallback", "mapperQueue", "mmappedQueue", " mapedFB", "maphBuff", "mappedFB", "mapperBuff", " mapperBuff", "mattedData", "MappedBuffer", "MapedData"], "startIndex": [" startindex", "endIndex", "currentPoint", "Startindex", " startPos", "startPage", "StartPos", "currentIndex", "StartIter", "currentPosition", " startIter", "StartPage", "firstInd", "startindex", "StartPoint", "startPoint", "StartIndex", " startPosition", " startInd", "initPosition", " startPoint", "endIter", "endPage", "firstIndex", "startPosition", "initIndex", "firstPosition", "firstindex", "currentPos", "StartInd", "startInd", "endPosition", " startPage", "StartPosition", "startIter", "startPos", "initindex"], "count": ["info", "process", "counter", "cloud", "length", "total", "c", "amount", "coll", "Count", "batch", "category", "add", "found", "check", "ind", "now", "list", "name", "id", "last", "limit", "call", "depth", "number", "created", "n", "code", "mount", "ount", "order", "user", "find", "ctr", "act", "start", "state", "page", "conf", "con", "core", "current", "continue", "num", "index", "next", "sum", "more", "i", "first", "force", "size", "cast", "max", "type", "status", "result"], "currentMovie": ["currentImage", "activeSpider", " currentHero", " currentMusic", "activePlayer", "currentMedia", "presentImage", "firstDate", "currentDate", "firstMouse", " currentSpider", "primaryHero", "primaryMovie", " currentMouse", "currentVideo", "firstMovie", "primaryVideo", "currentlyMonster", "currentMonster", " currentMonster", "reportedMouse", "currentlyVideo", "currentlyDate", "firstVideo", "reportedImage", "reportedMusic", "currentMusic", " currentMedia", " currentVideo", "presentMusic", " currentImage", "currentHero", "currentlySpider", "currentSpider", "primaryDate", "currentlyHero", "presentHero", "reportedMedia", "firstHero", "firstMonster", "reportedMovie", "currentlyPlayer", "reportedHero", "currentMouse", "activeMovie", "firstMedia", "currentPlayer", "activeVideo", " currentPlayer", "currentlyMovie", "presentMovie"], "movieName": ["httpNAME", "ovieNAME", "filmNAME", "filmType", "monstername", "mpegGroup", " movieNAME", "movieNAME", "movieGroup", "mpegname", "movieType", "httpName", " moviename", "oviename", "filmGroup", "mpegNAME", " movieType", "filmname", "filmName", "Moviename", "ovieName", " movieTitle", "mpegName", "ovieGroup", "monsterNAME", "MovieType", "MovieTitle", "monsterName", "moviename", "movieTitle", "MovieName", "httpname", "filmTitle"], "customer": ["Customer", "customER", "developator", "customity", "developizer", " customER", " customator", "customorder", "ustomER", "Customity", "stickity", "developER", "stickER", "CustomER", "ustomator", "ustomorder", "developer", "customizer", "developity", "developorder", "sticker", "ustomer", " customorder", "stickizer", "customator", "Customizer"], "rating": ["rage", "heading", "testing", "rank", "option", " Rating", "playing", "score", "weight", "reporting", "scale", "error", "rate", "ating", "ping", "ranking", "strength", "setting", "scoring", "term", "card", "boarding", "credit", "user", "having", "core", "Rating", "average", "review", "tag", "rat", "reading", "translation", "format", "type", "saving", "rated", "attribute"], "outBuf1": ["outBufOne", "outBlf2", "outBuf0", "outBuc1", "outBuffy1", "outDuf0", "outBBuff3", "outBufone", "outBurg0", "outBuf11", "outBbufOne", "outRbuf0", "outBbuf0", "outBlf1", "outBoolone", "outBBuff0", "outDuf1", "outBuff1", "outBlf0", "outRbufOne", "outBulpOnce", "outBooll", "outDbuf1", "outBbuf11", "outBbufOnce", "outBool3", "outBuff0", "outBuf64", "outBurg1", "outBlf3", "outBufl", "outBfx3", "outBuf3", "outRbuf5", "outBbuf18", "outDbuf11", "outBucOne", "outBbufone", "outBurg18", "outBuf18", "outBuffyl", "outBuffy18", "outBfx11", "outBulp1", "outRuf3", "outBBuff1", "outBdf3", "outBbuf5", "outBool1", "outRuf5", "outRuf0", "outDbuf0", "outBuffyone", "outRuf1", "outRufOne", "outBdf64", "outBdfOnce", "outBuc0", "outDuf11", "outBfx1", "outBbuf3", "outRbuf1", "outBuc5", "outRbuf3", "outBbuf1", "outBBuff11", "outBuf5", "outBdf1", "outBulp64", "outRuf18", "outBufOnce", "outBfx0", "outRbuf18", "outBuff2", "outBbufl", "outDbuf3", "outBuffy3", "outBuffy0", "outBulp3", "outBuff3", "outDuf3", "outBurg3", "outBbuf64"], "outBuf2": ["outBuf15", "outBbufTwo", "outMbuf2", "outBbuf1", "outBuf42", "outMbuf15", "outBuff4", "outBbuff15", "outBfg02", "outBbuffj", "outBuffyTwo", "outBfx2", "outBuffy02", "outBuffy2", "outBufj", "outFuf4", "outFuf02", "outBuffy4", "outBbuff4", "outFbuf4", "outFbuf2", "outBuffj", "outBfx3", "outBbuf42", "outMuf2", "outBuf3", "outMbuf1", "outBfg4", "outBbuf02", "outBuff2", "outBuf02", "outFufTwo", "outFuf2", "outBuff42", "outBbufj", "outBbuf4", "outBbuff42", "outBfg2", "outFbufTwo", "outBbuf15", "outBufTwo", "outBbuff2", "outFbuf02", "outBfgTwo", "outMuf15", "outBfx1", "outBbuf3", "outBfx15", "outBbuf2", "outBbuff3", "outMuf3", "outBuffy3", "outBbuff1", "outMuf1", "outBuf4", "outBuff3", "outMbuf3", "outBuff1", "outBuffTwo"], "endOfIndexFile": ["endofIndexFiles", "endOFindexFile", "endOfindexLine", "endofindexfile", "endOfIndexLine", "EndFile", "endofIndexTable", "endOFindexLine", "endOfIndLine", "endofindexFile", "endOfIndfile", "endOfIndexfile", "endOFIndexLine", "endOfErrorF", "endOfPositionFile", "endedFile", "endofIndexFile", "endFile", "endOfIndFile", "endofindexFiles", "endOfindexF", "endofIndexF", "endOFIndexFile", "endOfPositionfile", "endOfindexFile", "endOfPositionTable", " endFile", "endOfindexTable", "endOfErrorfile", "endOfErrorFile", "endOFIndexfile", "endOfErrorFiles", "endOfIndexTable", "endofindexF", "endOFindexfile", "endofIndexfile", "endofindexTable", "endOfindexFiles", "endOfPositionFiles", "endOfIndexFiles", "endOfindexfile", "endOfIndexF"]}}
{"id1": "5148212", "id2": "15768167", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyImage", "copfile", " copyfile", "copyfile", "copyImage", "cloneFile", "copImage", "clonefile", "cloneImage", "copFile"], "src": ["sit", "ur", "sc", "attr", "rc", "pkg", "syn", "path", "url", "ls", "urg", "usc", "ost", "ser", "sq", "rest", "ins", "obj", "req", "inc", "sf", "cur", "source", "str", "rel", "ource", "st", "from", "rs", "start", "iter", "init", "txt", "ie", "iv", "sec", "img", "input", "usr", "sr", "lit", "sys", "Source", "inst", "file", "sur", "ipl", "loc", "ident", "filename"], "dest": ["orig", "mk", "trans", "way", "decl", "port", "master", "doc", "ord", "them", "comp", "des", "foreign", "vol", "nw", "comb", "d", "sit", "tif", "end", "path", "desc", "delete", "min", "to", "temp", "dist", "source", "sup", "de", "st", "gov", "dat", "etc", "usr", "loc", "ident", "result", "dir", "Dest", "gt", "opt", "this", "v", "obj", "spec", "test", "good", "iter", "cat", "tr", "nom", "fr", "file", "est", "crit", "tom", "null", "cont", "nd", "parent", "fe", "sp", "coord", "rest", "deg", "req", "output", "origin", "img", "target", "lit", "data", "prop"], "bufSize": [" bufSIZE", " bufInfo", "boxSIZE", "BufferCount", "bufsize", "fontInfo", "ufInfo", "boxSize", "BufferSize", "queueLen", "fontsize", "bufCount", "BufferLen", "bufLength", "boxsize", "buffersize", "fontSIZE", "queueCount", "bufSIZE", "bufferSize", "bufferLength", "bufLen", "bufInfo", "BufferLength", "queueSize", "queueLength", "ufSize", "fontSize", "ufsize", "bufferSIZE", "bufferLen", " bufsize", "bufferCount", "ufSIZE"], "force": [" confirm", "ace", "fast", "send", "allow", "update", "forced", " override", "Force", "rule", "default", "secure", "func", "require", "raise", "enable", "e", "reason", "cp", "ce", "error", "use", "quote", "yes", "flush", "print", "seed", "flag", "sync", "write", "only", "like", "apply", "fx", "cmd", "replace", "start", "vert", "dirty", "forge", "ignore", "pdf", "frame", "always", "auto", "fail", "form", "external", "ghost", "forcing", "remote", "open", "handle", " enforce", "append"], "f": ["m", "t", "w", "df", "b", "c", "fp", "F", "h", "bf", "fm", "e", "part", "ct", "inf", "p", "v", "uf", "s", "l", "rf", "r", "of", "sf", "fo", "fs", "g", "cf", "fc", "exp", "lf", "conf", "ef", "fac", "fr", "elf", "file", "fi", "xf", "dir", "d"], "buffer": ["paste", "memory", "bar", "row", "parse", "binary", "buff", "length", "table", "sample", "variable", "phrase", "document", "batch", "base", "line", "block", "Buffer", "history", "filter", "message", "sequence", "library", "print", "password", "cache", "number", "queue", "write", "temp", "window", "buf", "iter", "stroke", "template", "result", "word", "char", "index", "database", "frame", "text", "attribute", "command", "stack", "shape", "append"], "read": ["info", "record", "before", "feed", "t", "im", "w", "Read", "length", "send", "run", "parse", "give", "allow", "end", "take", "range", "key", "get", "stream", "add", "it", "raw", "mem", "check", "count", "valid", "ind", "need", "READ", "skip", "print", "log", "reader", "readable", "fill", "write", "q", "height", "like", "str", "bind", "select", "pe", "iter", "find", "ip", "start", "en", " Read", "input", "word", "seek", "char", "index", "query", "ke", "i", "size", "gets", "reading", "hello", "len", "time", "open", "reads", "load", "shape"], "in": ["gin", "m", "im", "per", "oin", "mi", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "internal", "client", "image", "ain", "ins", "to", "l", "rin", "ic", "by", "io", "inc", "al", "source", "ln", "IN", "mm", "iter", "from", "ex", "local", "en", "inner", "isin", "bin", "ie", "init", "con", "input", "din", "irm", "ma", "inside", "i", "is", "ar", "ir", "In", "net"], "out": ["full", "cn", "os", "t", "note", "b", "end", "ion", "ot", "o", "up", "aos", "it", "on", "or", "parent", "oe", "list", "client", "v", "writer", "obj", "can", "to", "outs", "print", "flush", "io", "conn", "write", "not", "cache", "one", "n", "ln", "user", "output", "ex", "Out", "bin", "inner", "con", "nt", "conv", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "cos", "net"]}}
{"id1": "397240", "id2": "7911686", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "22611968", "id2": "18613870", "code1": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"retrieveBitmap": ["retrieveHeatimage", "retrieveBitimage", "retrieveHeatMap", "retrievebitMap", "retDownloadBitmap", "retDownloadBitimage", "retrievebitimage", "retDownloadBitMap", "retDownloadHeatimage", "retrieveBitMap", "retDownloadHeatmap", "retrievebitmap", "retDownloadHeatMap", "retrieveHeatmap"], "urlString": ["grabstring", " urlSTR", "UrlList", "urlList", "grabStr", "imageRest", "uriString", "UrlStr", "grabSTR", "urlStr", "namestring", "uriStr", "grabString", "urlstring", "imageString", "nameStr", " urlStr", " urlRest", "imagestring", "Urlstring", "UrlSTR", "UrlString", "urlSTR", "uriList", "nameString", "urlRest", " urlList", "imageStr", " urlstring", "nameRest"], "bitmap": [" bitsample", "bitcode", "bitsMap", "bitmaps", "bitsmaps", "Bitap", " bitmaps", "bitMap", "Bitmap", " bitimage", "bitsample", "BITap", "Bitcode", "BITscreen", "bitimage", " bitap", " bitcode", "BITsample", "BITmap", "BITcode", "bitsimage", "Bitscreen", "Bitsample", "BitMap", "BITimage", " bitscreen", "bitsmap", "Bitmaps", "Bitimage", "bitap", " bitMap", "BITMap", "bitscreen"], "url": ["bel", "ur", "http", "link", "b", "https", "il", "ls", "get", "cp", "build", "name", "client", "resource", "ol", "l", "uri", "f", "sl", "r", "nl", "log", "service", "str", "cmd", "ssl", "con", "char", "atl", "Url", "abs", "ul", "ll", "loc", "dl", "open", "cert", "URL", "browser"], "conn": ["nc", "cn", "dial", "pos", "exec", "resp", "close", "c", "cont", "syn", "ch", "coll", "soc", "ct", "socket", "pas", "cp", "client", "connection", "Connection", "to", "cur", "Conn", "enc", "proc", "out", "res", "cmd", "act", "ctx", "dat", "init", "ssl", "comm", "con", "jp", "nt", "conv", "cb", "connect", "sys", "addr", "fin", "serv", "open", "cons", "cert", "col"]}}
{"id1": "8216539", "id2": "18696387", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileTextAsString", "getFileContentasString", "getFileTextAsText", "getFileContentAsStr", "getFileContentasText", "getFileTextAsStr", "getFileContentasStr", "getFileContentAsText"], "filePath": ["baseName", "filePATH", " fileInfo", "FileString", "fileName", "fileDef", "baseString", "basePath", " fileName", "entryPATH", "FILEpath", "ileInfo", " fileDef", "FILEName", " fileString", "ilePath", "basepath", "FILEPath", "FilePATH", "FileInfo", "FilePath", "fileInfo", "filepath", "entrypath", "FileDef", " filepath", "FileName", "entryPath", "ileDef", "entryName", "FILEPATH", "Filepath", "ileName", "fileString"], "encoding": ["ENCordering", "Encoding", "enoding", "unicode", "characteraching", "unicoding", "ENCaching", "enode", "Encuing", "encging", "ENCging", "encuing", "Encging", "characteroding", "ENCoding", "Encode", "characterging", "encordering", "unicuing", "enuing", "Encordering", "characterordering", "Encaching", "unicaching", "encaching", "enaching", "encode"], "testURL": ["checkURL", " testRE", "testedUrl", "TestURL", "TestUrl", "testedRE", "checkUrl", "testingURL", "testRE", "testUrl", "TestUR", " testUrl", "testedUR", "testingSR", "checkUR", "testingUrl", " testSR", "testingUR", "testingRE", "testSR", " testUR", "checkSR", "testUR", "testedURL", "TestSR"], "input": ["empty", "get", "up", "add", "address", "context", "can", "op", "cur", "from", "pull", "init", "eval", "json", "qa", "channel", "hello", "feed", "active", "sample", "unsigned", "submit", "it", "raw", "client", "q", "source", "act", "config", "xml", "form", "view", "open", "acl", "command", "PUT", "in", "read", "audio", "batch", "list", "iterator", "quick", "iter", "ip", "current", "lat", "tmp", "file", "upload", "exec", "cont", "url", "has", "stream", "image", "focus", "reader", "quit", "hidden", "Input", "output", "start", "missing", "inner", "exist", "comment", "data", "accept"], "sw": ["was", "hw", "tw", "sc", "w", "sem", "wh", "Sw", " Sw", "fw", "ws", "su", "aw", "rew", "sh", "sp", "ow", "ews", "ows", "sl", "sf", "enc", "iw", "sm", "wr", "kw", "sv", "ew", "sb", "sn", "igm", "sa", "SW", "wn", "wra", "wo", "wl", "sk", "wa", "sur", "nw", "we"]}}
{"id1": "4938100", "id2": "22552318", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"sha1": ["SHA1", "a2", "a1", "SHA3", "md3", "SHA256", "a3", "md1", "md2", "md256", "sha2", "sha3", "sha256", "SHA2", "a256"], "text": ["Text", "t", "w", "read", "document", "cont", "path", "url", "TEXT", "prefix", "value", "ct", "now", "name", "message", "buffer", "context", "password", "print", "content", "event", "out", "q", "x", "str", "term", "select", "source", "code", "test", "txt", "output", "act", "string", "title", "pattern", "template", "input", "word", "nt", "ext", "body", "form", "comment", "data", "msg", "aut", "tx", "translation", "subject", "command", "pt"], "UnsupportedEncodingException": ["UnsupportedChodingError", "UnsupportedChoderException", "UnsupportedChoderElement", "UnsupportedChodingElement", "UnsupportedEncodingEx", "UnsupportedChoderError", "UnsupportedEncodingError", "UnsupportedEncgorithmError", "UnsupportedEncgorithmElement", "UnsupportedEncoderElement", "UnsupportedEncoderError", "UnsupportedChodingException", "UnsupportedEncgorithmException", "UnsupportedEncoderException", "UnsupportedEncgorithmEx", "UnsupportedEncodingElement", "UnsupportedChodingEx", "UnsupportedChoderEx", "UnsupportedEncoderEx"], "md": [" ms", "mod", "m", "ms", " mm", " dd", "ad", "t", "det", "df", "pd", "ld", "pkg", " man", "dh", "mc", "h", "mk", "mond", "bf", "nd", "add", "MD", "di", "ind", "rm", "cd", " df", "mn", "mt", "od", "bd", "mb", " mo", " mc", "mg", "sd", " sd", "cmd", "dm", "mm", "ctr", "td", "der", " rm", "sha", "hd", " Md", "red", " cd", "mand", "grad", "mp", " cmd", "dd", "dir", "d"], "sha1hash": [" SHA1hash", "sha5Hash", "aoneHash", "haonesha", "sha1result", "shaoneresult", "a1hash", "aonesum", "shaoneHash", "sha1sum", "haonehash", "sha5hash", "haonesum", "sha81hex", "sha5hex", "sha3result", "aonesha", "sha5href", " SHA1Hash", "ha1sum", "sha1href", "ha1sha", " SHA81hash", "shaonesha", " SHA81hex", "sha1hex", "shaonesum", "haoneresult", "shaonehash", "a1sum", "sha5sum", "sha2sha", " SHA1hex", "sha3hash", "a1Hash", "sha3sha", "sha2hash", "aonehash", " SHA81Hash", "sha2sum", "sha3Hash", "sha3hex", "ha1result", "sha81Hash", "sha3href", " SHA1href", "sha5result", "sha1sha", " SHA81href", "sha81hash", "a1sha", "sha5sha", "sha81href", "sha1Hash", "ha1hash", "sha2Hash", "sha3sum"]}}
{"id1": "1362", "id2": "18974466", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubargeSort", "bubblesSort", "gobblingSort", "bubblesCompare", "gobblingLess", "bubbleCompare", "bubblingSort", "gobbleSort", "bubbleLess", "gobbleCompare", "bubblingCompare", "bubblesLess", "gobbleLess", "bubargeCompare", "bubblingLess", "bubargeLess", "gobblingCompare"], "a": ["aa", "go", "t", "aaa", "ata", "w", "ia", "va", "b", "isa", "z", "c", "ab", "h", "o", "alpha", "na", "ed", "au", "history", "ga", "es", "eas", "A", "list", "p", "v", "ae", "l", "f", "ea", "cache", "out", "ao", "window", "la", "g", "aka", "order", "aaaa", "an", "act", "att", "all", "app", "sa", "area", "ma", "changes", "trace", "el", "as", "apa", "form", "oa", "data", "era", "array", "da", "ap", "am", "ac", "arr"], "swapped": ["snaped", "swap", " swaps", "scaps", "Swaped", " swap", " swaped", " swapping", " snap", "SWap", "stickaps", "waped", "scaped", "snapped", "SWapped", "swaps", "SWaped", " snaped", "Swap", "snapping", " snapped", "wapping", "swaped", "stickaped", "Swapping", "snaps", "wapped", "Swapped", "SWapping", "scapping", "swapping", "stickapped", "waps", " snapping", "stickapping", "scapped"], "i": ["ji", "m", "ci", "u", "t", "im", "in", "phi", "j", "ii", "gi", "gu", "qi", "c", "my", "I", "us", "mi", "ti", "oi", "base", "pi", "it", "di", "ini", "ui", "ind", "zi", "id", "client", "hi", "y", "multi", "ic", "uri", "f", "io", "ai", "x", "iri", "ori", "me", "iu", "bi", "ip", "cli", "init", "origin", "si", "ie", "ij", "ki", "ri", "iso", "index", "sim", "li", "ix", "xi", "ami", "is", "uli", "key", "ei", "chain", "status", "ir"], "tmp": ["perm", "tt", "m", "mut", "cmp", "t", "orig", "attr", "pkg", "my", "mk", "managed", "prefix", "sq", "sp", "obj", "amp", "sam", "temp", "cache", "cur", "emp", "sup", "np", "same", "pre", "test", "txt", "ctx", "etc", "timeout", "td", "xy", "lib", "clip", "nom", "comp", "gm", "db", "tf", "tg", "MP", "mp", "nb", "result"]}}
{"id1": "841724", "id2": "8490297", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "7396682", "id2": "3330944", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "label": 1, "substitutes": {"copy": ["pixel", "upload", "zip", "read", "link", "gc", "fit", "archive", "Copy", "repeat", "opy", "delete", "cp", "php", "cross", "map", "sync", "write", "Cop", "cat", "create", "replace", "crop", "move", "share", "core", "clip", "slice", "proxy", "split", "transfer", "clone", "py", "cop", "download", "load"], "srcFS": ["sourceFS", "srcOS", "rcFs", "sourceOS", "srcVS", "srcFs", "srcSF", "sysOS", " srcVS", "sysFs", "sysFS", "srcfs", "sourceCS", "rcFS", " srcFs", "srcCS", "sourceFs", "rcMS", "srFs", "rcfs", " srcfs", "sysVS", "sourcefs", "srcMS", " srcOS", " srcCS", " srcSF", "sourceVS", "sourceSF", "rcVS", "srfs", "srFS", " srcMS", "rcOS", "srMS", "rcCS", "rcSF"], "src": ["sit", "RC", "sc", "http", "SOURCE", "selected", "https", "rc", "cont", "syn", "pkg", "path", "url", "secure", "pri", "desc", "check", "ser", "sq", "nil", "resource", "obj", "spec", "uri", "req", "boot", "sync", "sub", "cur", "proc", "source", "str", "th", "node", "rel", "st", "from", "txt", "start", "sb", "rx", "sn", "ctr", "rs", "dest", "supp", "iv", "init", "sec", "input", "img", "usr", "sin", "sr", "tmp", "target", "comp", "via", "sys", "addr", "Source", "sci", "inst", "subject", "loc", "lb", "filename", "dir", "obs"], "dst": ["dslt", " dDest", "ldest", "lst", "deest", "Dest", "dddest", "dsdest", "dsst", "Dlt", "dDest", "dedest", "lgt", "dhdest", "ddnd", "ddlt", "dST", "dgt", "ddest", "Ddest", "degt", "deslt", "dnd", "dsST", "dhDest", "dsnd", "DST", " ddest", "desdest", "dsest", "desnd", " dest", "dsgt", "DDest", "dest", "lest", " dST", "dlt", "Dst", "desst", " dlt", "ddst", "dhst", "dhlt"], "deleteSource": [" deleteSources", "closeSource", "destroySource", "leteDest", "updateSOURCE", " deleteResult", "removeSource", "removeParent", "DeleteSourceFile", "closeSourceFile", "DeleteSOURCE", "updateSite", "leteResult", "delParent", "DeleteSource", "leteSource", "deleteSOURCE", "destroySources", "leteSOURCE", "deleteSite", "removeSOURCE", "removeDest", "delSource", "leteParent", "delSOURCE", "leteSources", " deleteTarget", "deleteTarget", "updateSource", "destroyResult", "deleteSources", "deleteDest", "DeleteSite", "deleteParent", "closeSite", "deleteSourceFile", "delDest", "destroyTarget", "updateSourceFile", "leteTarget", "closeSOURCE", "deleteResult"], "conf": ["info", "m", "cn", "params", "cms", "ch", "ref", "css", "acc", "check", "cc", "ban", "map", "report", "req", "f", "log", "cache", "conn", "q", "scan", "fs", "param", "ln", "cf", "mm", "plan", "ctx", "comm", "cfg", "def", "lib", "con", "irm", "conv", "com", "hash", "config", "cm", "cb", "pool", "comment", "co", "job", "ca", "Conf", "prop"], "contents": ["Contodes", "contants", " Contents", "CONTresses", " contterms", "constends", " contresses", "CONTENT", "CONTants", " Contresses", "Content", "CONTodes", "constENTS", " content", "contENTS", "CONTends", " ContENTS", " contants", "constaves", " contENTS", "CONTaves", "content", "contaves", "contterms", "CONTent", "ContENT", "CONTENTS", "Contents", " Content", " contENT", "Contterms", "CONTterms", " contends", "Contants", "contresses", "CONTents", "contodes", "contENT", " contodes", "constents", " contaves", "contends"], "i": ["ji", "m", "ms", "iq", "ci", "u", "im", "phi", "j", "ii", "gi", "qi", "my", "I", "us", "span", "o", "key", "mi", "ti", "oi", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "client", "y", "multi", "ic", "ai", "\u0438", "q", "x", "n", "ori", "me", "bi", "iter", "ip", "cli", "init", "inner", "si", "ie", "ij", "ki", "index", "sim", "li", "ix", "docker", "json", "ami", "xi", "is", "ims", "ei", "chain"], "in": ["sql", "re", "read", "sample", " din", "mc", "cin", "add", "raw", "ini", "inf", "check", "inn", "ind", "ze", "ins", "by", "r", "reader", "inc", "doc", "out", "source", "from", "IN", "en", "bin", "inner", "isin", "con", "input", "char", "din", "body", "xml", "is", "and", "In"]}}
{"id1": "20623709", "id2": "9479502", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"split": ["join", "process", "upload", "parse", "read", "disk", "align", "Split", "batch", "part", "count", "scale", "use", "unit", "map", "sync", "write", "scan", "copy", "share", "seek", "slice", "transfer", "lock", "format", "open", "append"], "targetDirectory": ["targetDir", "localFile", "targetMemory", "baseMemory", "Targetdirectory", " targetLocation", "testLocation", " targetDirect", "baseDirect", " targetdirectory", "baseDir", "targetFolder", "testDirectory", " targetFolder", " targetDir", " targetMemory", "TargetDir", "baseDirectory", "baseFolder", "localDir", "targetdirectory", "basedirectory", "TargetDirectory", "TargetFolder", "TargetDirect", "TargetMemory", "targetDirect", "localDirectory", "baseFile", "targetLocation", "targetFile", "testDir", " targetFile", "localdirectory", "testDirect", "TargetLocation"], "prefix": ["PRE", "pkg", "zero", "path", "base", "username", "pi", "version", "fix", "name", "this", "p", "directory", "password", "uri", "FIX", "padding", "pre", " suffix", "title", "pattern", "fixed", "template", "alias", "Pref", "root", "index", "fixes", "tag", "ix", "pres", "localhost", "division", "size", "type", "format", "key", "filename", "status", "command"], "maxUnitBases": ["maxUnitLicas", "maxUnitbases", "maxUnityAliases", "maxUnitLounds", "maxUnitAliias", "maxUnitReplases", "maxUnitChades", "maxUnityLounds", "maxUnitReplicas", "maxUnitChias", "maxUnityAliades", "maxUnitReplounds", "maxUnitChicas", "maxUnityAliounds", "maxUnitChases", "maxUnitbias", "maxUnitbades", "maxUnitAliades", "maxUnityLases", "maxUnityLicas", "maxUnitReplages", "maxUnityBounds", "maxUnitbounds", "maxUnityBades", "maxUnitBages", "maxUnitLases", "maxUnitBounds", "maxUnitBades", "maxUnityBicas", "maxUnityLages", "maxUnitLages", "maxUnityBias", "maxUnityAliias", "maxUnitBicas", "maxUnitChages", "maxUnitBias", "maxUnityBages", "maxUnitAliounds", "maxUnityBases", "maxUnitChounds", "maxUnitAliases"], "maxUnitEntries": ["maxUnitErries", "maxUnitEntriers", "maxUnitentires", "maxUnitIntegires", "maxUnityEntries", "maxUnitIntegries", "maxUnityEntrs", "maxUnitentrs", "maxUnitErrys", "maxUnityEntires", "maxunitEntrys", "maxUnityentries", "maxUnityentrs", "maxUnitentries", "maxUnitEntrys", "maxUnitEntryires", "maxUnitEntryriers", "maxUnitEntrs", "maxUnitErrs", "maxUnitIntegriers", "maxUnitEntryrys", "maxunitEntries", "maxUnityentrys", "maxUnitIntegrys", "maxunitEntrs", "maxunitEntires", "maxUnitentrys", "maxUnitEntires", "maxUnitErires", "maxUnityEntrys", "maxUnitEntryries", "maxUnityentires"], "fis": ["ific", "Fii", "viss", "fic", " fii", "ifii", " fic", "fiss", "vi", "Fi", "Fic", " fiss", "fii", "Fiss", "ifis", "Fci", "vis", "ifci", "Fis", "fi", "vic", " fi"], "fci": ["fico", "cfis", " fai", "mco", "cfai", "Fini", "mcu", "fai", "fic", "tci", "Fco", "Fai", " fii", "cfco", " fico", "mci", " fic", "cfic", "tii", " fcu", "fini", "tcu", "Fico", "Fic", " fini", "fii", "cfci", "Fci", "cfico", "fcu", "mii", "tco", "Fis", "cfini"], "fos": ["wios", "Fos", "fOS", "ybos", "flos", " fios", "wos", "waos", "floss", "flaos", "Foss", "wbos", "flOS", "fbos", "yos", "fios", "faos", " foss", " fOS", " fbos", "Faos", "foss", "yios", "yaos", " faos", "FOS"], "fco": [" foco", "tcos", "cso", " fcon", "Foco", "pci", "fdo", "ccon", "cdo", "pso", " fdo", "foco", "Fco", "pcos", "cco", " fcos", "Fdo", "toco", "fso", "fcos", "Fci", " fso", "Fcos", "Fcon", "tco", "fcon", "tdo", "Fso", "pco"], "buffer": ["record", "memory", "row", "note", "phrase", "binary", "read", "buff", "length", "table", "sample", "document", "batch", "holder", "block", "Buffer", "address", "filter", "message", "black", "sequence", "library", "limit", "print", "reset", "flush", "event", "queue", "temp", "cache", "source", "pause", "padding", "window", "buf", "function", "order", "iter", "timeout", "complete", "template", "position", "char", "bridge", "database", "index", "stack", "comment", "data", "match", "channel", "entry", "button", "callback", "command", "result", "append"], "currentBasesCount": ["currentBasesLength", "currentbasesLength", "currentBaseCode", "currentBasedCode", "currentBaseLength", "currentBadesLength", "currentBasedLength", "currentbaseCode", "currentBasesCode", "currentbasesCode", "currentbaseLength", "currentbasesCount", "currentbaseCount", "currentBaseCount", "currentBasedCount", "currentBadesCode", "currentBadesCount"], "currentEntriesCount": ["currentEntiesCount", "currentEntrsFlag", "currentEntriesFlag", "currentEntiesCode", "currentEntrsCode", "currentEntrysFlag", "currentEntrsCount", "currentEntriesCode", "currentEntrysCount", "currentEntrysCode", "currentEntiesFlag"], "targetCount": ["argetAmount", "TargetNum", " targetAmount", " targetNum", " targetInfo", "TargetAmount", "targetAmount", "TargetCount", "targetInfo", "argetInfo", "targetNum", "argetCount", "TargetInfo", "argetNum"], "fastaChannel": ["fastoQueue", "fastaQueue", " fastoChannel", " fastoStream", "fastaiChannel", " fastoQueue", "fastoProvider", "fastaiStream", " fastaQueue", "fastityChan", "fastoButton", "fastityQueue", " fastaProvider", "fastpaProvider", "fastpaChannel", " fastaChan", "fastoStream", " fastaConnection", "fastaConnection", "fastaiChan", " fastaButton", "fastoChannel", " fastoChan", " fastaStream", "fastpaConnection", "fastoChan", "fastaProvider", "fastaChan", "fastityChannel", "fastoConnection", "fastpaButton", "fastaiQueue", "fastaStream", "fastityStream", "fastaButton"], "totalSeqCount": ["totalSegCode", "totalSeqsCount", "totalSeQCount", "totalSeqsCounter", "totalSeqsCode", "totalSeQSize", "totalSeQCode", "totalSegCounter", "totalSeQCounter", "totalSeqCode", "totalSeqCounter", "totalSegSize", "totalSegCount", "totalSeqsSize", "totalSeqSize"], "totalResiduesCount": ["totalResiduesFlag", "totalResiduationsCount", "totalResIdueFlag", "totalResIdueCount", "totalResidueCount", "totalResIdueCode", "totalResidusCode", "totalResidusCount", "totalResiduationsFlag", "totalResiduationsCode", "totalResIduesFlag", "totalResidueCode", "totalResidusFlag", "totalResiduesCode", "totalResIduesCount", "totalResidueFlag", "totalResIduesCode"], "prevTime": [" previousThread", "parT", "parThread", "parTime", "prevThread", " prevThread", "prevT", " previousTime", " prevT", " previousT"], "fastaFileSize": ["fastaTableSIZE", "fastAFileLength", "fastafileSIZE", "fastafileOwner", "fastoFileOwner", "fastoTableSize", "fastaFileSIZE", "fastaReaderHeight", "fastaChainOwner", "fastaTableSize", "fastoFileSIZE", "fastaReaderLength", "fastaFilesLength", "fastaTableHeight", "fastaFileLength", "fastaFilesName", "fastATableLength", "fastAFileName", "fastaReaderName", "fastAFileSize", "fastAFileHeight", "fastaChainSIZE", "fastaFileOwner", "fastaTableOwner", "fastaFilesSize", "fastoFileLength", "fastaReaderSize", "fastaFileName", "fastATableName", "fastafileLength", "fastaChainLength", "fastATableHeight", "fastoFileSize", "fastaTableLength", "fastoTableLength", "fastafileSize", "fastoTableOwner", "fastaFileHeight", "fastaFilesHeight", "fastoTableSIZE", "fastaTableName", "fastATableSize", "fastaChainSize"], "fastaFileReadOffset": ["fastaChainCurrentOffset", "fastaFileCurrentoffset", "fastaFileInputOffset", "fastaFileViewPos", "fastaFileViewAmount", "fastaFileWriteOrder", "fastaFilereadPos", "fastaFilesReadOffset", "fastaFileReadAmount", "fastaFileInputoffset", "fastaFilesReadLength", "fastaFileReadPosition", "fastaFileLoadOrder", "fastaPageLoadAmount", "fastaFileReadLocation", "fastaFileWriteAmount", "fastaFileReaderOffset", "fastaFilesReadAmount", "fastaFileInputLocation", "fastaFilesLoadOffset", "fastaFileLoadOffset", "fastaFileCurrentLocation", "fastaFileInputAmount", "fastaFileLoadPos", "fastaChainCurrentPosition", "fastaFileViewOrder", "fastaFileWriteLength", "fastaFileReadPos", "fastaFilesReadOrder", "fastaChainReadOffset", "fastaPageReadAmount", "fastaFileReaderLocation", "fastaFileViewOffset", "fastaChainReadoffset", "fastaFileInputPosition", "fastaChainReadPosition", "fastaChainCurrentLocation", "fastaFilesLoadLength", "fastaFileReadLength", "fastaFilesLoadOrder", "fastaFilesLoadAmount", "fastaPageLoadPos", "fastaPageLoadOrder", "fastaChainCurrentoffset", "fastaFileCurrentOffset", "fastaFilereadOrder", "fastaPageLoadOffset", "fastaFilereadAmount", "fastaFileReadOrder", "fastaPageReadOffset", "fastaFileWriteOffset", "fastaFileInputOrder", "fastaPageReadPos", "fastaFileReaderPosition", "fastaFileInputLength", "fastaFilereadOffset", "fastaFileCurrentPosition", "fastaFileLoadAmount", "fastaPageReadOrder", "fastaFileReadoffset", "fastaFileLoadLength", "fastaFileReaderoffset", "fastaChainReadLocation"], "partitionStartOffset": ["partitionDataPosition", "partitonStartPosition", "partitonStartingPosition", "partitonStartingPoint", "partitionStartingPoint", "partitionStartingOff", "partitionStartPosition", "partitonStartingOffset", "partitionDataPoint", "partitonStartOff", "partitionDataOff", "partitionStartingPosition", "partitionStartingOffset", "partitonStartPoint", "partitionStartPoint", "partitonStartingOff", "partitionStartOff", "partitionEndPoint", "partitionDataOffset", "partitionEndOff", "partitonStartOffset", "partitionEndPosition"], "bufferSize": ["sequenceCode", "bufferName", "tableLength", " bufferSIZE", "BufferSize", "tableSize", "buffName", "BufferName", "bufLength", "tableName", " bufferLength", "bufferCode", "bufSIZE", "bufferLength", "sequenceSIZE", "BufferSIZE", "buffSIZE", "bufSize", "buffSize", "tableSIZE", "BufferLength", "buffLength", "bufCode", " bufferCode", "sequenceSize", "bufferSIZE", "sequenceLength"], "fastaBuffer": ["wildanBuff", "fastoBuffer", "fastaQueue", "fastanRequest", "fastcaBuffer", "fastaDB", "fastmaCache", "fastasBuff", "wildaRequest", "fastsaQueue", " fastaMemory", "fastasQueue", "FastmaStore", "fastmaStore", "fastoStore", "fasteBuffer", " fastaBuilder", "wildaBuffer", "fastoQueue", "fastasBuilder", "FastaStore", "fastmaBuff", "fasteMemory", "fastalBuffer", "fastaRequest", "fastcaRequest", "fastsaBuffer", "fastaCache", "wildaCache", "fasteBuff", "fastsaChannel", "fastuMemory", "fastoCounter", "fastanCache", "FastmaBuff", "fastuBuffer", " fastoQueue", "wildanBuffer", "fastaBuilder", "fastasStore", "fastmaQueue", "fastmaBuffer", "fastmaBuilder", "fastasCounter", " fastoBuffer", "fastasBuffer", "fastasCache", " fastaCounter", "wildaBuff", "FastmaRequest", " fastaCache", "wildanCache", "fastuDB", "FastaBuff", "fastalQueue", "fastcaCache", "fastaStore", "fastoRequest", "fastoBuff", "fastasRequest", "fastsaBuff", " fastaQueue", "fastcaBuff", " fastaBuff", "fastanBuff", "FastmaBuffer", "fasteDB", "fastmaChannel", "fastaCounter", "fastuBuff", "fastmaRequest", " fastoCounter", "fastalBuff", "FastaBuffer", "FastaRequest", "fastalCounter", "fastaMemory", " fastoBuff", "fastanBuffer", " fastaDB", "fastaBuff", "wildanRequest"], "fastaReadState": ["fastaCurrentType", "fastaCurrentSTATE", "fastoReaderType", "fastaReaderStatus", "fastaCurrentState", "fastoReadState", "fastaReaderType", "fastoReaderSTATE", "fastaReadType", "fastaReadStatus", "fastaReadSTATE", "fastaReaderSTATE", "fastaLoadStatus", "fastoReaderStatus", "fastoReadType", "fastaLoadType", "fastoReadSTATE", "fastoReadStatus", "fastaReaderState", "fastaLoadSTATE", "fastaLoadState", "fastaCurrentStatus", "fastoReaderState"], "nBytes": ["nWords", " nItems", " nWords", "nrBytes", "nsBytes", " nBlocks", "nItems", "noBlocks", "nParts", " nParts", "nbytes", "NItems", "nNs", "nrItems", "noBytes", " nKeys", "nrbytes", "numBytes", " nbytes", "NKeys", "Nbytes", "numNs", "nobytes", "nsParts", "nrKeys", "NBytes", "nsbytes", "nKeys", "numbytes", "noNs", "nBlocks", " nNs", "NWords", "numBlocks", "NParts", "nsWords"]}}
{"id1": "15580610", "id2": "755203", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainObjectifier", " runClassifer", " runclassizer", " trainObjectifer", " trainclassifier", " trainModifer", " runclassification", " trainclassification", " runclassifier", " runclassifer", " trainClassizer", " trainObjectification", " trainModification", " trainClassification", " trainModifier", " trainModizer", " runClassizer", " runClassification", " trainclassifer", " trainclassizer", " runClassifier", " trainClassifer", " trainObjectizer"], "dir": ["dd", "src", "module", "null", "pos", "disk", "done", "pkg", "path", "url", "base", "prefix", "files", "this", "directory", "direct", "md", "report", "Dir", "log", "io", "rad", "doc", "DIR", "folder", "dist", "dm", "output", "local", "dr", "lib", " directory", "root", "tmp", "div", "db", "config", "addr", "data", "grad", "loc", "dl", "wd", "ir", "d"], "command": ["paste", "three", "pretty", "mpeg", "send", "column", "sudo", "binary", "link", "shift", "expression", "mac", "archive", "document", "option", "component", "statement", "key", "base", "condition", "power", "delete", "history", "message", "connection", "menu", "sequence", "directory", "buffer", "group", "control", "password", "call", "description", "content", "event", "operation", "request", "argument", "method", "application", "function", "cmd", "set", "relative", "volume", "string", "search", "pattern", "template", "requisite", "and", "position", "shell", "query", "config", "program", "force", "comment", "script", "Command", "initial", "execute", "response", "clear", "form", "button", "display", "text", "chain", "multiple", "attribute"], "length": ["full", "creator", "shift", "dump", "diff", "total", "ENGTH", "capacity", "end", "ctors", "upper", "prototype", "append", "character", "pad", "strip", "SIZE", "power", "value", "space", "count", "available", "needs", "bus", "level", "build", "now", "sequence", "last", "limit", "depth", "pieces", "number", "transform", "height", "factor", "given", "distance", "load", "deep", "ength", "position", "Length", "form", "size", "loc", "len", "max", "volume", "fleet", "duration", "shape", "collection"], "process": ["record", "processor", "mpeg", "exec", "parse", "link", "in", "complex", "run", "pid", "pp", "component", "object", "worker", "check", "cp", "use", "system", "message", "p", "post", "call", "service", "proc", "request", "term", "method", "node", "console", "processing", "function", "cmd", "flow", "output", "start", "search", "Process", "load", "class", "position", "network", "session", "program", "connect", "task", "script", "view", "channel", "display", "handle", "status", "event", "result", "thread"]}}
{"id1": "841724", "id2": "364438", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "4468255", "id2": "23452437", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"copy": ["paste", "pixel", "zip", "parse", "link", "gc", "archive", "Copy", "get", "opy", "delete", "cp", "map", "print", "sync", "write", "Cop", "single", "cat", "create", "replace", "csv", "crop", "move", "save", "share", "core", "clip", "slice", "split", "transfer", "clone", "file", "py", "remote", "cop", "download"], "from": ["orig", "empty", "simple", "se", "add", "part", "f", "by", "th", "str", "org", "low", "left", "init", "input", "star", "el", "as", "vol", "self", "old", "path", "raw", "normal", "bound", "with", "ing", "source", "st", "query", "html", "config", "form", "view", "and", "dir", "link", "un", "range", "on", "or", "when", "this", "From", "without", "fr", "db", "initial", "file", "so", "remote", "zip", "cont", "url", "a", "base", "stream", "name", "false", "of", "only", "no", "local", "start", "small", "original", "at", "data", "entry"], "to": ["that", "t", "b", "back", "color", "by", "io", "op", "toc", "one", "te", "into", "po", "table", "o", "temp", "pro", "annot", "st", "two", "please", "ont", "et", "dir", "pt", "go", "phi", "total", "zero", "ot", "on", "or", "list", "not", "dis", "tu", "To", "will", "all", "too", "tmp", "tool", "format", "TO", "tom", "process", "null", "top", "base", "eto", "let", "must", "p", "only", "no", "output", "title", "dest", "xy", "nt", "target", "auto", "size", "data", "tty"], "result": ["details", "success", "block", "mate", "confirmed", "mask", "same", "product", "profile", "debug", "ful", "brace", "relation", "json", "important", "Result", "match", "perm", "goal", "table", "su", "region", "nil", "bool", "ure", "report", "r", "flag", "feature", "request", "term", "console", "continue", "launch", "functional", "status", "answer", "successful", "zero", "power", "there", "buffer", "date", "res", "test", "current", "br", "then", "response", "successfully", "duration", "true", "null", "rue", "journal", "stay", "rule", "results", "valid", "message", "false", "sequence", "cache", "only", "either", " successful", "description", "comment", "contact", "type", "chain", "event", "complete"], "subFiles": ["ubFiles", "ubNames", "singPosts", "subPosts", "ubfiles", "newFiles", "ubKeys", "newItems", " subImages", "ubPosts", "selFiles", "singValues", " subfiles", "subImages", "subNames", "newfiles", "selFile", " subpItems", "latImages", "supFiles", "selNames", " subOps", "subfiles", "subFile", "subValues", " subKeys", " subpfiles", " subValues", "subItems", " subCharacters", " subNames", "ubTags", "ubCharacters", "subOps", "ubFile", "subCharacters", " subItems", " subpDir", "singKeys", " subPosts", "ubItems", "ubValues", "singFiles", "subDir", "supOps", "ubDir", "latFiles", "supfiles", "subKeys", " subpFiles", "selDir", "ubOps", " subFile", " subTags", "supFile", "ubImages", "latfiles", " subDir", "latCharacters", "subTags", "newTags"], "i": ["info", "ji", "iq", "ms", "m", "go", "ci", "u", "t", "im", "phi", "j", "ii", "gi", "gu", "qi", "c", "my", "I", "us", "mi", "ti", "oi", "batch", "base", "gl", "pi", "h", "e", "di", "ui", "ind", "hi", "id", "zi", " I", "y", "v", "multi", "iy", "ic", "print", "uri", "ai", "q", "x", "ori", "g", "me", "bi", "iter", "ip", "exp", "init", "si", "ie", "ij", "ri", "index", "point", "sim", "li", "ix", "json", "ami", "task", "xi", "is", "job", "key", "chain"], "newDir": ["newsDir", " newNet", "newJar", "Newdir", "nextDir", " newComp", "NewDir", "newdir", "nextFile", "nextFolder", "subFolder", "subJar", "newObj", "NEWdir", "subServ", " newRel", "newRel", "subFile", " newFolder", "nextComp", "NewObj", "subdir", "subNet", "nextRel", "NewRel", "newFile", "newNet", " newFile", "NewNet", "newServ", "NEWJar", "newsRel", " newJar", "NewFile", "subDir", " newObj", "newsFile", "newsServ", "NewServ", "newComp", " newdir", "subRel", "newFolder", "NEWFile", "newsObj", "subComp", "nextdir", "NEWDir", "newsNet"], "in": ["gin", "info", "m", "read", "mc", "mi", "cin", "pi", "on", "it", "ini", "inf", "inn", "ind", "internal", "ain", "ins", "l", "rin", "print", "io", "doc", "ai", "inc", "al", "proc", "source", "ln", "iter", "IN", "win", "init", "local", "en", "inner", "isin", "bin", "con", "input", "din", "body", "asin", "ma", "inside", "is", "ar", "In", "net"], "out": ["os", "cn", "t", "w", "note", "err", "b", "end", "ion", "o", "up", "aos", "it", "on", "client", "p", "v", "writer", "can", "obj", "log", "outs", "flush", "io", "print", "write", "cache", "one", "n", "res", "ln", "cmd", "user", "output", "ex", "Out", "init", "en", "inner", "con", "nt", "conv", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "cos", "net"], "fileLength": ["fileFamily", "ileDuration", "pageENGTH", "FileENGTH", " fileFamily", "treelength", "FileDuration", "Filelength", "pageLength", "fileENGTH", "ileLength", "pagelength", "FileLength", "ileConstruction", "treeConstruction", "fileDuration", "treeLength", "treeDuration", "pageFamily", "fileConstruction", "FileFamily", "filelength", "ilelength", "FileConstruction", " fileENGTH", " filelength"], "charBuff": ["charbuff", "CharBuff", " charbuff", "CharBuffer", "Charbuff", "intBuffer", "Charbuffer", "intbuff", "intBuff", " charbuffer", " charBuffer", "intbuffer", "charBuffer", "charbuffer"], "len": ["cmp", "pos", "Len", "length", "cap", "val", "syn", "ref", "ls", "line", "e", "mem", "name", "l", "cl", "str", "ln", "set", "start", "en", "char", "el", "gen", "ll", "fin", "et"], "oneChar": ["onceCr", "OneCr", "onceChar", " oneCh", " oneCr", " oneInt", "OneCharacter", "onechar", "oneCharacter", " oneByte", "Onechar", "oneInt", "OneChar", "onceCharacter", " onechar", "oneByte", "oneCr", "OneByte", "OneInt", "OneCh", " oneCharacter", "oneCh", "onceCh"]}}
{"id1": "13666876", "id2": "8216539", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["transformsingleModel", "transformMultiFile", "TransformSingleFile", "TransformSingleRecord", "transformSingleModel", "TransformSimpleModel", "transformOneFile", "transformSingleFiles", "processSingleFile", "transformsingleFile", "transformsingleFiles", "processSingleFiles", "transformMultiFiles", "transformSimplePage", "transformSinglefile", "processsingleFiles", "transformsinglePage", "TransformSimpleFile", "transformMultiModel", "processsingleFile", "transformOneSourceFile", "transformMultiSourceFile", "transformsingleRecord", "transformSimpleModel", "TransformSinglePage", "transformSinglePage", "transformOneFiles", "transformSimpleRecord", "transformsingleSourceFile", "processsinglefile", "transformsinglefile", "transformMultiPage", "transformSimpleFile", "TransformSingleModel", "transformMultifile", "transformSingleRecord", "transformOnefile", "transformMultiRecord", "processSinglefile", "transformSingleSourceFile", "processSingleSourceFile", "processsingleSourceFile", "TransformSimplePage", "TransformSimpleRecord"], "xed": ["rxed", "rxeds", "xied", "wxred", "passEd", "passED", "exED", "pxeded", "Xeded", "xeded", "exeded", "xented", "txed", " xented", "xred", "uxied", "exeds", "passred", "wxEd", "xED", "Xed", "pxED", "exed", "pxeds", "rxED", "Xer", "rxer", " xED", "pxed", "wxied", "passed", "xeds", "txED", "XED", "wxed", " xred", " xEd", "wxented", "xer", "uxED", "wxED", "Xeds", "txer", " xied", "uxented", "xEd", "uxed", "txeds"], "node": ["process", "row", "note", "link", "ode", "our", "object", "component", "Node", "range", "line", "parent", "day", "name", "right", "hand", "image", "directory", "resource", "post", "map", "seed", "stage", "feature", "one", "n", "station", "no", "de", "set", "create", "entity", "tree", "word", "index", "edge", "scene", "view", "channel", "array", "remote", "job", "entry", "and", "event", "load"], "dob": ["dobar", " dab", "dobb", "Doy", "adobar", "Dab", "adab", "diob", " doy", "dod", " dobar", "adob", "drobb", "adoy", "dab", "Dobar", "drod", "diod", "drab", "doy", " dod", "Dob", "drob", " dobb", "diab", "diobb"], "mySrc": ["mySourcerc", " mySfc", "MySRC", "myInsrc", "mySsrc", "mySelsrc", "mySource", "mySfc", "myDesrc", " mySsrc", "myDesources", "mySingrc", "mySourceRC", "myDesRC", " mySRC", "mySources", "myAsRC", "mySRC", "mySingfc", "mySingsrc", "myInssrc", "myInsfc", "myAsource", "MySrc", "MySources", "mySourceource", "mySingRC", "mySelrc", "MySource", "MySsrc", "myInsRC", "myAssrc", "mySourcesrc", "myAsrc", "mySelRC", "myDessrc", "mySelources"], "mySrcF": ["myMourceV", "mySrcV", "mySufO", "mySRCP", "mySrtI", "myMrcFP", "mySsrcF", "mySsrcI", "mySrcC", "mySufV", "mySRCF", "myMourceF", "mySourceV", "mySrcO", "myMrcO", "myMourceFP", "mySourceFP", "mySufFP", "mySRCI", "mySsrcFP", "mySourceO", "mySrcI", "mySsrcP", "mySRCC", "mySsrcO", "mySsrcV", "mySrtF", "myMrcF", "mySsrcC", "myMourceO", "mySrtP", "mySufF", "mySourceF", "mySrtC", "mySrcP", "myMrcV", "mySrcFP"], "myOutF": ["myoutC", "mysNetL", "myOutputE", "MyInFs", " myoutF", "myOutputFile", "myArtFL", "mysNetW", "myOutputFs", " myOutV", "myObjFile", "myOutL", "myOutV", "myOutputC", "myOutputF", "myOutE", "myOffFile", "myOutputV", "myOffF", "mysOutL", "myOutW", " myoutL", "myOutputL", "MyOutFs", "myCoL", "myoutL", "myOutFile", "myoutF", "myArtL", "myInF", "myArtF", "myObjV", "myInV", "myOutputDF", "myOffDF", "myOutC", "MyInF", "myInFs", "mysOutW", "mysNetFL", " myoutV", "mysOutF", "MyOutV", "mysOutFL", "myObjFs", "myOutDF", "myNetF", " myOutL", "myCoW", "MyOutF", "MyInFile", "myInFile", "myArtW", "myoutV", "myNetFile", "myInL", "myNetL", " myOutE", "myNetW", "myCoF", "myNetE", "MyOutFile", "myOutFL", " myNetFile", "myInC", " myNetF", "myObjF", " myOutFile", "myNetDF", "MyInV", " myoutC", "myOffE", "myOutFs", " myOutC", " myNetDF", "myCoFL", "mysNetF", "myNetFL", " myOutDF", " myNetE"], "co": ["ico", "nc", "ace", "go", "ci", "oc", "po", "roc", "gc", "lo", "cal", "c", "coll", "xc", "o", "lc", "soc", "cho", "cc", "ce", "cover", "coord", "cs", "yes", "flo", "can", "obj", "io", "cache", "fo", "cl", " Co", "CO", "no", "aco", "ro", "fc", "copy", "ror", "cu", "ko", "con", "ck", "com", "ho", "wo", "Co", "cm", "cv", "loc", "so", "cop", "mo", "ca", "cod", "cos", "col", "ctrl"], "x3dvFile": ["x3dvsPath", "x3dvsFile", "x3dbString", "x3dbFile", "x3pdbFile", "x3cdvFilename", "x3dbFilename", "x3pdvFilename", "x3dvString", "x3dtFilename", "x3dvFilename", "x3pdbfile", "x3cdVFilename", "x3dVString", "x3dbfile", "x3dVPath", "x3dVfile", "x3cdVFile", "x3dVFilename", "x3pdvString", "x3dtString", "x3pdvfile", "x3dtFile", "x3cdvPath", "x3pdbString", "x3cdvFile", "x3dtfile", "x3pdbFilename", "x3dvPath", "x3dvsFilename", "x3pdvFile", "x3davFilename", "x3cdVPath", "x3davPath", "x3dVFile", "x3dvfile", "x3davFile"], "fis": ["bisi", " fisi", "fie", "biss", "bie", "fileires", " fie", "flis", " fiz", "fliss", "frie", "fiss", " fires", "fisi", "frisi", "fires", " fiss", "fiz", "fileiss", "fileis", "flires", "fliz", "fris", "bis", "friss", "fileiz"], "gzos": ["gzoss", "go", "ggoes", "gtoss", "gtops", "gaos", "zies", "ziposs", "gzaos", "gsops", "gtos", "zipnos", "ggos", "gties", "zo", "zops", "ggops", "gtnos", "gtoes", "gsos", "gzies", "zoss", "gzo", "gznos", "gzoes", "zoes", "gzops", "goss", "sslos", "zos", "gos", "sslaos", "sslo", "zipops", "ggies", "gsnos", "ssloss", "zaos", "gsoss", "zipos"], "buf": ["bar", "wb", "orig", "buff", "b", "cap", "pkg", "mu", "ref", "batch", "font", "raw", "block", "mem", "Buffer", "vec", "fb", "buffer", "uf", "emb", "tab", "var", "cur", "Buff", "seq", "aka", "cf", "cmd", "cat", "good", "bag", "cam", "rb", "img", "br", "conv", "cb", "box", "cv", "bytes", "cast", "max", "bus", "arr"], "ret": ["rt", "re", "pret", "ft", "err", "alt", "gt", "val", "end", "cont", "back", "RET", "ref", "repl", "v", "arg", "obj", "mt", "deg", "print", "r", "rets", "out", " Ret", "res", "test", "cmd", "iter", "ctr", "att", "inter", "def", "continue", "tr", "nt", "ext", "ptr", "ry", "ter", "red", "Ret", "len", "cert", "aux", "elt", "et"]}}
{"id1": "11032546", "id2": "22536033", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": [" testcopyKnownSize", " testCopyKnownLength", " testCopyunknownsize", " testCopyUnknownShape", " testcopyUnknownLength", " testcopyUnknownSize", " testCopyunknownSize", " testcopyUnknownsize", " testCopyKnownSize", " testcopyKnownShape", " testcopyKnownsize", " testCopyUnknownLength", " testCopyUnknownsize", " testCopyDifferentsize", " testCopyunknownShape", " testcopyUnknownShape", " testcopyKnownLength", " testCopyDifferentLength", " testCopyKnownsize", " testCopyKnownShape", " testCopyDifferentSize", " testCopyDifferentShape", " testCopyunknownLength"], "in": ["gin", "null", "up", "cin", "it", "on", "inf", "inn", "ind", "ain", "ins", "log", "rin", "l", "r", "al", "source", "IN", "mm", "from", "copy", "en", "inner", "isin", "bin", "con", "input", "sin", "din", "inv", "inside", "i", "data", "file", "is", "In"], "out": ["os", "null", "t", "err", "b", "gt", "end", "o", "a", "up", "aos", "it", "on", "gr", "or", "check", "list", "client", "obj", "to", "log", "outs", "by", "io", "one", "n", "res", "cmd", "user", "output", " OUT", "ex", "Out", "all", "con", "sum", "ou", "inv", "at", "OU", "auto", " Out", "OUT", "co", "data", "result", "net"], "cpySize": ["cplysize", "Cplysize", "cdySize", "cpeCount", " cpysize", "cpesize", "CpySize", "CplySize", "CpyLength", "CplyLength", "Cpysize", "cpeLength", "cdyLength", "cdyCount", "cpeSize", "cfiCount", "cplyCount", "cfiSize", " cpyLength", "cplyLength", " cplyLength", " cpyCount", " cplySize", " cplyCount", "cdysize", "CpyCount", " cplysize", "cfiLength", "cplySize", "cpysize", "CplyCount", "cpyLength", "cpyCount", "cfisize"], "outArray": ["OUTObject", " outString", "listString", " outObject", "neObject", " outImpl", "inArray", " outarray", "OUTarray", " outArea", "inImpl", "OUTStream", "nearray", "inArea", "neStream", "OUTArray", " outStream", "inString", "outObject", "listImpl", "outStream", "listArray", "listArea", "outImpl", "neArray", "outarray", "outString", "outArea"]}}
{"id1": "11153282", "id2": "19109981", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"existsURL": ["existingHTTP", " existsHTTP", " existHTTP", " existURL", "existsUR", "existURL", "exitsHTTP", "existsUrl", "exitsUR", " existsUrl", "existingUR", "existHTTP", " existsUR", "existUrl", "existingUrl", "existUR", " existUrl", "existingURL", "exitsURL", " existUR", "exitsUrl", "existsHTTP"], "urlStr": [" urlSt", "urlObj", "urlSt", "UrlSt", "UrlSpec", "URLSpec", "URLString", "uriString", "UrlStr", "uriObj", "urlString", " urlWr", " urlSpec", "uriWr", "uriSpec", "URLStr", "uriSt", " urlObj", "urlSpec", "URLWr", "urlWr", "UrlObj", " urlString", "uriStr"], "url": ["pl", "bel", "ur", "null", "http", "link", "gc", "b", "https", "il", "ls", "base", "build", "name", "this", "p", "l", "uri", "log", "sl", "r", "nl", "rl", "conn", "str", "org", "mount", "arch", "arl", "ssl", "char", "Url", "abs", "ul", "file", "sur", "ll", "lb", "loc", "dl", "job", "acl", "URL"], "con": ["nc", "cn", "dial", "re", "fn", "close", "c", "un", "syn", "cont", "ch", "pen", "coll", "soc", "on", "Con", "cp", "cond", "client", "connection", "cs", "ain", "can", "conn", "cur", "Conn", "sub", "proc", "n", "rec", "res", "ln", "cf", "user", "fc", "en", "inner", "comm", "conf", "conv", "com", "CON", "num", "compl", "cm", "connect", "canon", "col", "co", "ran", "open", "cons", "cos", "bc", "fin", "ctrl"], "responseCode": ["ResponseMessage", "ResponseCode", "responseZone", "replyCode", " responseZone", " responseMessage", "answerType", "answerMap", "responseMap", "conditionZone", "answerCode", "conditionType", " responseType", "ResponseCount", "responsecode", "conditionMap", "conditionCode", " responseCount", " responseMap", "replyMessage", "Responsecode", "replyCount", "responseMessage", "replycode", "responseCount", "answerZone", "responseType", " responsecode"]}}
{"id1": "7764011", "id2": "3958807", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvViewerDoc", "readScalarpvviewersDoc", "readScalarpvviewingFile", "readScalarpvViewersDocument", "readScalarpvviewerDoc", "readScalarpvviewersdocument", "readScalarpvviewingdocument", "readScalarpvviewerdocument", "readScalarpvViewersdocument", "readScalarpvviewerFile", "readScalarpvviewingDocument", "readScalarpvviewingDoc", "readScalarpvviewersDocument", "readScalarpvViewersFile", "readScalarpvViewerdocument", "readScalarpvViewerDocument", "readScalarpvViewersDoc", "readScalarpvviewedDocument", "readScalarpvviewedDoc", "readScalarpvViewerFile", "readScalarpvvieweddocument", "readScalarpvviewersFile", "readScalarpvviewedFile"], "url": ["ret", "ur", "http", "link", "b", "document", "util", "ls", "address", "name", "id", "buffer", "resource", "uri", "l", "sl", "r", "nl", "rl", "str", "res", "mount", "rel", "rect", "location", "ssl", "char", "Url", "web", "mail", "ul", "xml", "file", "data", "loc", "ll", "dl", "open", "cert", "URL", "browser"], "xmlData": ["xmlName", "xmlPart", "jsonData", " xmlText", "mlName", "xpString", "xpdata", "phpName", "mlText", " xmlQuery", "xmlDat", "mlData", "phpPart", "mlPart", "xfDat", "logdata", "xmlText", "xfText", "phpData", " xmlDat", "xmlQuery", " xmlName", "xfQuery", "jsonQuery", " xmlString", "phpText", " xmlContent", "phpContent", "mldata", " xmldata", " xmlPart", "xpDat", "logString", "xmldata", "xpData", "xmlString", "xfData", "logData", "xmlContent", "jsonText", "mlContent", "jsonDat", "phpdata", "logDat"], "in": ["gin", "info", "m", "re", "thin", " din", "mc", "cin", "add", "inf", "inn", "ins", "rin", "reader", "r", "doc", "inc", "out", "IN", "from", "bin", "isin", "inner", "all", "con", "input", "ri", "conf", "din", "i", "as", "file", "is", "In"], "line": ["LINE", "column", "piece", "se", "block", "part", "port", "log", "str", "node", "code", "user", "lin", "word", "trace", "row", "note", "sample", "raw", "cell", "normal", "print", "source", "lined", "ln", "continue", "zone", "header", "ine", "record", "link", "length", "lo", "range", " Line", "check", "list", "change", "pe", "iter", "string", "next", "force", "file", "lock", "text", "item", "detail", "phrase", "stay", "eline", "inline", "message", "Line", "sequence", "l", "nl", "content", "lines", "no", "stroke", "page", "section", "le", "point", "frame", "comment", "online", "data", "entry", "field", "chain", "liner"], "cont": ["nav", "each", "cmp", "c", "coll", "circ", "valid", "ct", "mult", "count", "keep", "cond", "multi", "rest", "control", "content", "cur", "contained", "str", "cart", "code", "cmd", "iter", "txt", "ctr", "cat", "con", "continue", "current", "Cont", "conv", "next", "compl", "CONT", "first", "exist", "contin", "loop", "co", "ont", "const", "cons", "chain", "crit", "any"], "readAdp": ["readADping", "readAdping", "readAdamp", "readAmr", "readAdr", "ReadAdp", "ReadADr", "readadn", " readAdn", "Readadp", "readInterp", "readADj", " readADr", "readADn", "ReadADP", " readADlp", " readAdr", "readAdP", " readADn", "readAdj", "readAdlp", "readADr", " readADP", "readadj", "readadlp", "readADP", "readAmp", "ReadAdj", "readAdamP", "readadping", "Readadj", " readADping", " readAdping", " readAdj", " readAdP", "readAmlp", "readadP", "ReadAdr", "readadr", "readInterlp", "ReadADlp", "readAdn", "Readadlp", "readAdamn", "ReadadP", "readAdamping", "readInterj", "readADlp", " readADj", "ReadAdP", "ReadADp", "ReadAdlp", "readInterP", " readAdlp", " readADp", "readADp", "readadp", "readAmP"], "scalarpvviewerData_Adaptor": ["scalarpvviewerData2adapter", "scalarpvviewerData_Accepter", "scalarpvviewerData_Adaptr", "scalarpvviewerData_Adors", "scalarpvviewerData_adaptorer", "scalarpvviewerData_Adapter", "scalarpvviewerData_Ado", "scalarpvviewerData2Adaptor", "scalarpvviewerData2adaptors", "scalarpvviewerData_Archor", "scalarpvviewerData_Archable", "scalarpvviewerData_AdjustOR", "scalarpvviewerData_AxOR", "scalarpvviewerData_Adaptable", "scalarpvviewerData2adaptr", "scalarpvviewerData_Adaptorer", "scalarpvviewerData2adaptor", "scalarpvviewerData2adapto", "scalarpvviewerData_Accepto", "scalarpvviewerData2Adaptors", "scalarpvviewerData_Adaptors", "scalarpvviewerData_adaptor", "scalarpvviewerData_Axor", "scalarpvviewerData_Axable", "scalarpvviewerData_adapto", "scalarpvviewerData_Axorer", "scalarpvviewerData_adaptr", "scalarpvviewerData_Archorer", "scalarpvviewerData_AdOR", "scalarpvviewerData_Ader", "scalarpvviewerData_ConnectOR", "scalarpvviewerData2Adapter", "scalarpvviewerData_Acceptor", "scalarpvviewerData_Adjustors", "scalarpvviewerData_Adjustable", "scalarpvviewerData_Connector", "scalarpvviewerData_Adr", "scalarpvviewerData2Adaptr", "scalarpvviewerData_ArchOR", "scalarpvviewerData_Adapto", "scalarpvviewerData_adaptors", "scalarpvviewerData_adapter", "scalarpvviewerData_Acceptors", "scalarpvviewerData_Connectable", "scalarpvviewerData_Ador", "scalarpvviewerData2adaptOR", "scalarpvviewerData_Adjustor", "scalarpvviewerData_Connectors", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_adaptable", "scalarpvviewerData_adaptOR", "scalarpvviewerData2AdaptOR", "scalarpvviewerData2Adapto"], "params_font": [" params2system", " params_template", "params_style", "params7system", "params_tt", "params_brand", "params_ont", "params_pen", "params_text", "params12shadow", " params2font", "params6brand", "params_shadow", " params_ont", "params6font", "pretty_font", "params_Font", "params2font", "pretty_layout", "params2system", "params7Font", " params_shadow", " params2Font", "params2Font", "params12system", "params6pen", "params12font", "params2shadow", "params6layout", "pretty_pen", " params_text", " params_Font", "pretty_brand", " params_style", " params_system", "params_system", "params___text", "params_layout", "params___font", "params_template", "params___ont", "params___tt", "params7font", " params_tt", "params7shadow", " params2shadow", "params12Font"], "font_size": ["font_Size", "font_speed", "font_height", "font_family", "font_SIZE", " font_width", " font_speed", " font_Size", " font_family", "font_width", " font_height", " font_SIZE"], "style": ["styles", "Style", "less", " Style", "link", "margin", "sty", "mode", "font", "css", "weight", "value", "error", "color", "role", "stable", "layout", "padding", "country", "estyle", " styles", "height", "les", "stroke", "sche", "theme", "state", "pattern", "class", "position", "show", "script", "size", "format", "family", "type", "handle", "status", "shadow", "angle"], "font_Family": ["font_Name", "font_Style", "fontTypefamily", "font_family", "fontNameName", " font_Role", "font_Role", "family_Style", "fontTypeRole", " fontNameRole", "family_family", "family_Family", " font_family", "fontNamefamily", "fontNameFamily", " fontNameFamily", " fontNamefamily", "fontNameStyle", "fontNameRole", "family_Name", "fontTypeFamily"], "globalFont": ["generalFloat", "localFont", "generalFont", "globalONT", "commonFontSize", "globalFamily", " globalONT", "generalFontSize", "commonFont", "foreignFamily", "GlobalFloat", "commonFamily", "generalONT", "foreignFont", " globalFloat", "localFamily", "GlobalFont", "globalFloat", "GlobalONT", "globalFontSize", "GlobalFontSize", "foreignFontSize", "localFontSize", " globalFontSize"], "params_pts": ["params_nt5", "params_ptis", "params_pt5", "params_xtls", "params_xts", "params_nts", "params_iptes", "params_ptes", "params_cts", "params_ntjs", "params2ptjs", "params2ptts", "params_ctjs", "params2pts", "params_brts", "params_ptjs", "params2pties", "params_nties", "params_ntls", "params_ctes", "params_ptts", "params_ntts", "params2nts", "params_bries", "params_ntis", "params_xt5", "params_ntt", "params_iptt", "params_cties", "params_ptls", "params_brs", "params_iptm", "params_pties", "params_ptyis", "params_pty5", "params_xtis", "params2ntjs", "params_brjs", "params_ptt", "params2nties", "params_ptys", "params_ipts", "params_ntm", "params_ptm", "params_ptyls", "params_ntes", "params2ntts", "params_ctm", "params_ctts", "params_ctt"], "params_data": [" paramsPar", "paramsPar", " params_", "argsPar", "paramPar", "param_", "params_", "args_"]}}
{"id1": "7351534", "id2": "20011285", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSystemIdentifiers", "getStreamFromSysidentification", "getStreamFromSystemIdifier", "getStreamFromSysIdentifier", "getStreamFromSystemIdifer", "getStreamFromSystemidentifier", "getStreamFromSysIdentifiers", "getStreamFromSysidentifier", "getStreamFromSysIdentifer", "getStreamFromSystemIdentifer", "getStreamFromSysidentifer", "getStreamFromSystemIdentification", "getStreamFromSystemIdifiers", "getStreamFromSystemidentifiers", "getStreamFromSysidentifiers", "getStreamFromSystemIdification", "getStreamFromSystemidentifer", "getStreamFromSysIdentification", "getStreamFromSystemidentification"], "systemId": ["humanDoes", "sysById", "systemName", "localhostMid", "ystemIn", " systemName", "localhostStart", "publicId", "systemIn", "humanID", "systemDoes", "sysId", "systemid", "systemID", "humanId", "ystemIs", "publicid", "serverid", "publicIn", "ystemId", "sysID", " systemMid", "ystemid", "ystemName", "localhostId", " systemById", "cmsId", "publicMid", "publicById", "ystemID", "serverIn", "humanStart", "systemMid", "ystemById", "sysIs", "cmsStart", "publicName", "serverById", "systemById", "systemIs", "systemStart", "serverId", "cmsMid", "humanById", "localhostDoes", "cmsDoes", "humanMid", "ystemMid", "humanIs"], "resolver": [" reserver", "resolutionlove", "resanger", "reserver", "reerver", "relove", "perslove", " resolved", "reolved", "resolve", "reslove", "persolving", "resolved", "persolution", "persolved", "reolver", "resolutionolver", "resolutionolving", "rsolver", "reolution", "persolve", "persolver", "reolve", "rsolution", "rserver", "resolutionolution", "resolving", " resanger", "reolving", " resolution", "reanger", "rsanger", "resolution", " resolve"], "source": ["src", "sql", "storage", "null", "sample", "SOURCE", "table", "rule", "component", "object", "get", "base", "se", "scope", "raw", "parent", "ser", "store", "peer", "sp", "system", "ce", "iterator", "context", "image", "resource", "unit", "sequence", "spec", "uri", "seed", "reader", "service", "node", "console", "ource", "site", "from", "local", "create", "init", "copy", "missing", "inner", "origin", "supp", "template", "string", "style", "input", "instance", "target", "proxy", "relation", "via", "force", "Source", "cause", "file", "subject", "channel", "response", "remote", "attribute", "status", "series", "result", "shell"], "stream": ["http", "trans", "ream", "socket", "port", "control", "log", "proc", "impl", "encrypted", "REAM", "input", "channel", "load", "stack", "row", "feed", "progress", "sample", "temp", "out", "console", "body", "pipe", "pool", "loop", "form", "open", "result", "shape", "Stream", "read", "length", "batch", "peer", "iterator", "buffer", "sync", "sw", "clean", "mount", "test", "present", "next", "file", "response", "null", "upload", "zip", "our", "poll", "cont", "object", "valid", "message", "sequence", "resource", "wrapper", "reader", "content", "cache", "window", "output", "export", "ssl", "instance", "pod", "data", "download", "chain", "complete", "hold"], "url": ["ret", "bel", "ur", "null", "http", "hl", "link", "b", "back", "ref", "ls", "gl", "build", "system", "address", "resource", "l", "uri", "f", "sl", "r", "nl", "rl", "service", "term", "window", "rel", "mount", "location", "ssl", "char", "Url", "mail", "ul", "web", "external", "dl", "ll", "job", "key", "URL", "browser"]}}
{"id1": "1097146", "id2": "3536332", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getContentDigested", "getMessagedigester", "getMessageDecester", "getMessageDigester", "getMessageDecested", "getMessagedigests", "getContentDigester", "getMessageDigested", "getMessageDecest", "getMessagedigested", "getContentDigest", "getMessageDigests", "getMessageDecests", "getContentdigests", "getContentDigests", "getContentdigest", "getContentdigested", "getMessagedigest", "getContentdigester"], "input": ["null", "in", "active", "sample", "empty", "qi", "url", "get", "up", "it", "raw", "value", "required", "check", "valid", "address", "name", "this", "p", "image", "buffer", "password", "focus", "uu", "cur", "request", "Input", "source", "q", "out", "unknown", "cmd", "quick", "output", "from", "act", "missing", "state", "string", "pattern", "char", "config", "qa", "form", "xml", "data", "msg", "file", "initial", "hello", "format", "text", "human", "any"], "md": ["mod", "m", "ms", "ad", "med", "det", "pd", "df", "ld", "mu", "managed", "mk", "dh", "mc", "pm", "MD", "di", "cd", "mn", "mt", "od", "bd", "sam", "mb", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "ds", "def", "pdf", "der", "nt", "comp", "hd", "cm", " Md", "mand", "grad", "mp", "dd", "d"], "bytes": ["ms", "words", "binary", "bs", "b", "rings", "Bytes", "forms", "versions", "pages", "ls", "bags", "clips", "videos", "tes", "bps", "files", "es", "seconds", "values", "users", "s", "outs", "pieces", "bits", "blocks", "lines", "bles", "nets", "groups", "objects", "keys", "units", "windows", "steps", "terms", "reports", "parts", "latest", "strings", "classes", "ings", "qs"]}}
{"id1": "2381663", "id2": "20011285", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedAndrethrown", "malformedGadgetSpecIsCachedAndThThrow", "malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedandThows", "malformedGadgetSpecIsCachedAndthrown", "malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedAndrethThrow", "malformedGadgetSpecIsCachedandthows", "malformedGadgetSpecIsCachedAndthows", "malformedGadgetSpecIsCachedandthThrow", "malformedGadgetSpecIsCachedAndthrows", "malformedGadgetSpecIsCachedAndThows", "malformedGadgetSpecIsCachedAndthThrow", "malformedGadgetSpecIsCachedAndrethows", "malformedGadgetSpecIsCachedAndrethrows", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedandThThrow", "malformedGadgetSpecIsCachedandthrows"], "request": ["record", "project", "forward", "http", "parse", "document", "object", "url", "reference", "condition", "pair", "quest", "client", "message", "p", "context", "resource", "this", "question", "map", "req", "call", "report", "q", "create", "ip", "pull", "input", "instance", "next", "query", "first", "task", "xml", "requ", "frame", "initial", "Request", "response", "command", "result"]}}
{"id1": "22366505", "id2": "2668634", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"incluir": ["incluiier", "inCLUar", "incluiator", "inclUier", "inclUar", "incluar", "incluiar", "inCLuier", "inCLUier", "inclouar", "inclouier", "inclUator", "inclUir", "inCLuir", "incluator", "inCLuar", "inCLUator", "inclouir", "inclouator", "incluier", "inCLUir", "inCLuator", "incluiir"], "igreja": [" iggreva", "iggreva", "iggreje", " iggrej", " igcrej", " igreje", "igopenja", " igrej", "igvreje", "iggreji", "igarrejas", "iggreJa", " igcreJa", "igarrej", " igreJa", "iggreja", "igcreji", "igrejas", " igrejas", "igcreJa", "igcrej", "igopenva", "igreje", "igreva", "igarreje", "igvrej", " igreva", "igvrejas", "igarreva", "igarreja", " iggreji", " iggrejas", " iggreje", "igreJa", " iggreja", "igvreja", "igcreja", " igcreja", "igopenj", "igarreji", "iggrejas", "igrej", "iggrej", "igarreJa", " igcreji", "igreji", "igopenji", " igreji"], "connection": ["which", "computer", "creator", "link", "setup", "close", "c", "document", "ion", "engine", "gate", " Connection", "component", "statement", "reference", "management", "condition", "established", "socket", "settings", "system", "Connection", "client", "context", "directory", "resource", "to", "library", "message", "conn", "operation", "connected", "created", "n", "application", "function", "user", "language", "container", "con", "section", "instance", "server", "network", "position", "current", "database", "session", "relation", "query", "manager", "db", "city", "config", "connect", "pool", "communication", "description", "response", "generation", "open", "command", "collection"], "sql": ["pl", "scl", "install", "zip", "expression", "table", "statement", "url", "pel", "sq", "serial", "series", "normal", "login", "spec", "log", "seed", "nl", "spr", "sf", "q", "sol", "sd", "select", "sv", "ln", "cmd", "csv", "plan", "string", "title", "template", "shell", "SQL", "query", "inv", "sys", "sk", "xml", "description", "form", "lock", "san", "dl", "command", "ql"], "sql2": ["SQL2", "ql02", "sd2", "SQL3", "sql3", "sql1", "ql2", " sql02", "sd4", "SQL1", "ql3", "sql4", "sd02", " sql4", " sql1", "sd3", "sql02", "SQL4", " sql3", "SQL02", "ql1"], "stmt": ["restm", "statMT", "ststat", "statmn", " ststat", "Ststat", "tmt", "Stmm", " stmb", "strmb", "statm", "STmt", "strmt", "restmm", " stm", "STMT", "STmm", "estm", "strMT", "estmb", "reststat", "strm", "stm", "tMT", "statmt", " stMT", "estmt", "estMT", "StMT", "restmt", "Stm", "tmb", " stmn", "tmm", "stmb", "stMT", " stmm", "Stmn", "stmm", "Stmb", "Stmt", "STmb", "STm", "STmn", "stmn"], "stmt2": ["stmrtwo", "sttm3", "stMT1", "Stmt2", "Stmem2", " stmp4", " stmp3", "stmt02", " stMT3", "sttx3", "stmr4", "stmptwo", " stmt4", "stmTwo", "stmp2", "stmem1", "stmpTwo", "sttx1", "stmemTwo", " stMT1", "stm02", " stmt1", "Stmt1", " stmp2", "stmr2", " stmptwo", "stmp1", "sttm2", "stmr1", "sttm4", "stmem2", "stmt1", "stmp3", "stmt3", "stmt4", " stMT02", "stMTTwo", " stmpTwo", " stmt02", "stmem3", " stmtTwo", "stMT4", " stmt3", " stmttwo", "Stmem3", "stmttwo", "stmtTwo", "stMTtwo", " stmp1", "stMT2", "stm3", "Stmem1", "stmp4", "StmemTwo", "stMT02", " stMT2", "sttmTwo", "stm2", "stm1", "StmtTwo", "stMT3", "sttx02", "sttx2", "Stmt3"], "rs": ["rt", "ms", "ros", "eps", "bs", "rc", "vs", "ws", "rows", "ls", "ss", "mr", "rd", "results", "its", "Rs", "ns", "cs", "ts", "s", "ins", "ows", "r", "ats", "gs", "js", "fs", "res", "pers", "rys", "vers", "rss", "sts", "ds", "ks", "usr", "ris", "ys", "sr", "hs", "rates", "ras", "xs", "RS", "ars", "ims", "qs", "ps"], "retorno": ["montorno", "eltano", "eltorn", "altorn", "altano", " retogo", "montora", " retorn", "retrero", "retora", "altorno", " retora", "retorn", " retrero", "retogo", "eltogo", "gotorne", " retorne", "eltorno", "retorne", "altogo", "montrero", "gotorno", " retano", "gotora", "gotrero", "montorne", "retano"]}}
{"id1": "2834524", "id2": "23611770", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"write": ["zip", "read", "link", "update", "dump", "rite", "end", "add", "check", "filter", "Write", "flush", "print", "service", "apply", "create", "export", "save", " overwrite", "next", "println", "file", " rewrite", "lock", "download", "handle", "commit", "append"], "jarOut": ["jarStore", "jarOutput", "jarout", "JarOut", "jarOver", "JarGen", "browserOut", "jarIn", "jarNet", "javaOutput", "jarGen", "pkgOver", "jamIn", "jamOver", " jarOutput", "javaIn", "pkgNet", "browserIn", "JarOutput", "pkgIn", "browserout", "Jarout", "javaGen", "pkgOut", " jarStore", "browserOutput", " jarGen", " jarIn", "javaOut", "JarIn", " jarout", "jamNet", "JarStore", "JarOver", "JarNet", "javaStore", "javaout", "jamOut"], "allEntries": ["allEnts", "allEntryies", "allentlections", "allEnries", "allEntarts", "allenties", "allEntrys", "allEntryrys", " allEntrys", "allentries", " allentrys", " allenties", " allEntlections", "allENTies", "allEnties", "allEntryries", "allents", " allents", "allENTrys", " allEnts", "allENTlections", " allEntarts", " allentries", "allEntlections", "allentrys", "allEnrys", "allEnies", " allEnties", "allENTries", "allentarts", "allEnarts"], "iterator": ["starter", "creator", "counter", "sample", "table", "versions", "immigration", "pie", "inator", "rows", "Iterator", "range", "stream", "integer", "timer", "issues", "ski", "list", "values", "sequence", "writer", "runner", "menu", "reader", "iver", "pointer", "number", "members", "pee", "builder", "iter", "set", "former", "copy", "inner", "internet", "operator", "continue", "current", "instance", "ippy", "outer", "database", "next", "tmp", "river", "walker", "i", "iner", "trace", "ter", "loop", "size", "loader", "ator", "liner", "series", "finder", "vector", "collection"], "jar": ["module", "zip", "parse", "binary", "j", "archive", "bare", "pkg", "jo", "rar", "batch", "tar", "be", "sp", "cp", "resource", "library", "tab", "folder", "gem", "magic", "cf", "war", "pack", "bag", "jj", "lib", "jp", "class", "Jar", "car", "char", "java", "pod", "zone", "json", "file", "vol", "job", "entry", "cert", "browser", "dir"], "jarEntries": [" jarEntrys", "jarEarts", " jarentents", "jarMatries", "jarentries", "jarEntarts", "jarContities", " jarentries", "jarMaties", "jarIntrs", "JarEntrs", " jarEntarts", "JarEntires", "jarentrs", "jarMatrs", " jarContities", "jarAddies", "jarEnrys", "JarEntries", "Jarentries", "jarEntrs", " jarentarts", "jarAddents", " jarContrys", "Jarentires", "jarAddarts", "jarentents", "jarEntires", "jarContents", " jarEntents", "jarentarts", "jarEnities", "Jarentrs", "jarIntires", "jarEies", "jarEries", "jarEntents", "jarIntries", "jarContries", "jarContrys", "jarEnties", "jarEents", "jarInties", "jarEnries", "jarEntities", "JarEnties", "Jarenties", "jarenties", "jarMatires", "jarentires", " jarContries", "jarEnents", " jarEnties", " jarEntities", " jarContents", "jarAddries", " jarenties", "jarEntrys"], "o1": ["oOne", "eOne", "oone", "a1", "o5", "os1", "a0", "o0", " oOne", "eone", "oa10", "o512", " o2", " o8", "os5", " o6", "oa2", "ico512", "e0", "o6", " o5", "oa8", "oa1", "oa6", "co2", "os2", "oo8", "e2", "icoone", "ico2", "a2", " oone", "ico1", "oo1", "e5", "o2", "o11", "co1", " o512", " o10", " o11", "co6", "o10", "co11", "e512", "e1", "oo10", "aOne", "o8", "os512", " o0", "oa11"], "entryStream": ["resultPage", "entryForm", "EntrySteam", " entryPage", "rowStream", "enterForm", "entryPage", "enterStreamer", "entryPoint", "resultSteam", "enterSteam", "inputSteam", "enterStream", " entryPoint", "resultPoint", "inputStreamer", "EntryStream", "EntryStreamer", "rowSteam", "rowPoint", " entrySteam", "resultStream", "entryStreamer", "EntryForm", "entrySteam", "inputForm", "inputStream", "rowPage"]}}
{"id1": "17724879", "id2": "6517139", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 1, "substitutes": {"getDigest": [" getMDest", "getdigse", "getdigested", "getDigEST", " getMDested", "getdigest", "getDigse", "getHashEST", " getMDse", " getDigse", "getMDested", " getDigEST", "getMDest", " getDigested", "getHashest", "getHashested", "getDigested", "getHashse", " getMDEST", "getdigEST", "getMDse", "getMDEST"], "attribute": ["item", "each", "expression", "attr", "variable", "document", "option", "object", "property", "a", "information", "qualified", "definition", "character", "management", "add", "pair", "value", "space", "reference", "address", "name", "message", "directory", "article", "report", "element", "password", "Attribute", "event", "operation", "al", "request", "member", "argument", "application", "associated", "metadata", "att", "missing", "operator", "ribute", "input", "position", "word", "relation", "communication", "at", "description", "data", "subject", "policy", "entry", "ident", "type", "and", "command"], "digestAlgorithm": ["digesterAlgorithm", "digestsalgo", "digestSchegebra", "digesteralgorithm", "digestALgebra", "digestAlgo", "digesteralgebra", "digestSchegorithm", "digestsalgorithm", "digesterAlgorith", "digestPalgo", "digestsalgebra", "digesteralgorith", "digestPalgebra", "digesterAlgebra", "digestSchego", "digestsAlgo", "digestALgorithm", "digestsAlgorithm", "digestAlgebra", "digesteralgo", "digestAlgorith", "digestalgebra", "digesterAlgo", "digestPalgorith", "digestalgo", "digestALgorith", "digestsAlgebra", "digestPalgorithm", "digestalgorith", "digestALgo", "digestalgorithm"], "digest": ["digse", "equested", "diagnested", "designest", "Digested", "digend", "Digse", "digtest", "diagnest", "diagnitude", " digist", "digested", " digitude", "mdest", "digests", "designEST", "Digests", "Digend", "designist", "Digtest", "diagnse", "DigEST", "hashested", "hashest", "hashEST", "Digist", "designests", "hashend", "equEST", " digested", "mditude", " digse", "equend", "mdse", "digitude", "equest", " digEST", "digist", "Digest", "mdtest", "digEST", "mdested", " digests", " digtest"], "md": ["mod", "m", "ms", "det", "pd", "df", "mac", "amd", "ld", "managed", "mk", "dh", "mc", "pm", "nd", "MD", "di", "ct", "mind", "ind", "cond", "rm", "cd", "mn", "mt", "bd", "mb", "sm", "mg", "sd", "js", "strong", "cmd", "dm", "good", "mm", "met", "metadata", "pt", "dr", "ds", "rpm", "pdf", "der", "nt", "ma", "esm", "hd", "red", "grad", "fd", "wd", "ud", "dd", "d"]}}
{"id1": "9275622", "id2": "6988216", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", " cpStream", " duplicatefile", " cpfile", " copyfile", " duplicateFiles", "copyfile", " cpFiles", " copyFiles", " duplicateStream", " duplicateFile", "copyFiles", "copyStream", " cpFile"], "_file1": ["_files1", "_filesOne", "_ileFirst", "_File2", "_ile1", "_files2", "_FileOne", "_fileInit", "_ile2", "_link2", "_linkInit", "_ileOne", "_FileInit", "_ileInit", "_File1", "_link1", "_FileFirst", "_filesFirst", "_fileOne", "_linkOne", "_fileFirst"], "_file2": ["_FILE02", "_fileb", " _FILE2", " _File2", " _File1", "_FILEb", "_FILE1", "_File2", "_image2", "_filetwo", "_linkTwo", "_File02", "_FILE2", " _fileTwo", " _FileTwo", "_linktwo", " _Filetwo", "_link2", "_imageb", " _FILE1", "_file02", "_Filetwo", "_FileTwo", "_Fileb", "_File1", "_image02", "_link1", " _filetwo", " _FILE02", " _file02", " _fileb", "_image1", " _FILEb", "_fileTwo"], "fis": ["Fos", "kais", "cfis", "flis", "cis", "cais", "cfris", "Fris", " fios", "fliss", "fiss", " fris", "cfiss", "fais", "cfois", "flios", "kis", "ufi", " fiss", "fios", "ufios", "qiss", "fli", "Fios", "ufiss", "Fiss", "kios", "qos", "fois", "Fois", "qios", "ufis", "Fis", "fi", "kos", " fi", "qis", " fais", "fris", "cos", " fois", "cios"], "fos": ["mows", "foes", "sfose", " foes", " fows", "flis", "fows", "sfos", "flos", "maos", "wos", "floes", "wows", "ffoes", "hoes", "waos", "mos", "woss", "floss", "fose", "hose", "sfoes", "faos", " foss", "ffos", "hoss", "ffis", "wis", "hos", "foss", " fose", "woes", "sfoss", " faos", "ffoss", "moes"], "canalFuente": ["canalfuent", "canalKuje", "canallFuenza", "canallfuje", "canallfueree", "canallFuent", "canalKuperor", "canalKuente", "canallFuperor", "canalFient", "canallFuestro", "canallFueree", "canalTenent", "canalfuenza", "canalFuje", "canalFalperor", "canalTenperor", "canalFaleree", "canalfueree", "canallFuente", "canalfuestro", "canalKuent", "canalFuestro", "canalfuente", "canalFalente", "canallfuperor", "canalUtestro", "canalFueree", "canallfuente", "canalFiente", "canalFienza", "canalTenenza", "canalFuent", "canalUtent", "canallfuestro", "canalfuperor", "canalFiperor", "canalFalestro", "canalUteree", "canalTenente", "canallfuenza", "canalFuenza", "canalUtente", "canallFuje", "canalFuperor", "canalFalent", "canallfuent", "canalFalje", "canalfuje"]}}
{"id1": "10385815", "id2": "18164929", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"copy": ["paste", "upload", " copying", "read", "Copy", "delete", "opy", "cp", "sync", "write", "Cop", "cat", "create", "csv", "replace", "move", "save", "clip", "slice", " duplicate", "transfer", "clone", "file", "cop", "download", "rm", "load"], "fileFrom": ["FileObject", "ileFrom", "sampleA", "fileA", " fileA", "sampleStart", "fileObject", "sampleFrom", "projectStart", "FileFrom", "ileObject", "ileTo", "projectInitial", "fileStart", "fileForm", "ileForm", "FileTo", "FileForm", " fileStart", "inputTo", "sampleInitial", " fileInitial", "fileInitial", "projectFrom", "inputForm", "inputObject", "projectA", "inputFrom"], "fileTo": [" fileTO", "ileDest", "fileTarget", "FileTO", "ile2", "FileTarget", "fileDest", " fileTarget", "ileTo", "ileTarget", " fileDest", "modelTarget", "File2", "fileTO", "FileTo", " file2", "FileDest", "modelTo", "file2", "modelTO", "modelDest"], "inputStream": ["activeChannel", "imagestream", "imageStreamer", "imageStream", "importFile", "sourceSource", "InputChannel", "eventStreamer", "eventSteam", " inputFile", "imageChannel", "inputSteam", "audioSteam", "audioStreamer", "sourceChannel", "importSteam", "inputStreamer", "sourceSteam", "InputFile", " inputSteam", "audiostream", "eventstream", "inputSource", "audioStream", "inputFile", "inputstream", "InputSteam", " inputSource", "sourceStream", "imageSteam", "InputStream", "InputStreamer", "eventStream", "importChannel", "InputSource", "activeSteam", "activeStream", "importStream", "activeStreamer"], "outputStream": ["inputString", "writeSocket", " outputFile", "outputSocket", "outputSteam", "writeStream", "displayStream", "displayChannel", "OutputStream", "resultSteam", "OutputChannel", "displaySteam", "outputstream", "inputSteam", "webStream", " outputString", "resultSocket", "outputFile", "writeSteam", "OutputFile", "Outputstream", "displaystream", "outputString", "resultStream", "OutputSteam", "inputstream", "webSteam", "webString", "resultChannel", " outputSteam", "writeChannel", " outputSocket", "webFile", "webChannel"], "inputChannel": [" inputCategory", "operatorConnection", "inputCamera", "readChannel", "readableConnection", "inputChan", "localChannel", "createChannel", "InputChannel", " inputConnection", "currentChannel", "operatorStream", "outputSteam", "readableChannel", "readableChan", "readCategory", " inputCamera", "outputConnection", "inputConnection", "inputChain", "operatorCamera", "localChan", "InputCamera", "inputSteam", "createStream", "localConnection", "currentChain", "createSteam", "outputChan", " inputSteam", "InputConnection", " inputChan", "currentChan", "readChain", "readChan", "InputChan", "inputCategory", "operatorChannel", "currentCategory", "InputStream", " inputChain", "createChan"], "outputChannel": [" outputContext", "OutputConnection", "putChan", "updateChannel", "writeContext", "OutputContext", "Outputchannel", "OutputCategory", "outputContext", "putChannel", " outputConnection", "OutputStream", "outputConnection", "OutputChannel", "successConnection", "successChannel", " outputchannel", "updateCategory", " outputChan", "outputChan", "updateChan", "hiddenCategory", "hiddenChannel", "hiddenChan", "putStream", "outputCategory", "successStream", "updatechannel", "successchannel", "outputchannel", "putchannel", "writeConnection", "hiddenchannel", "OutputChan", "writeChan", "writeChannel"]}}
{"id1": "12236729", "id2": "23611770", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"copy": ["paste", " append", " copying", "read", " join", "Copy", " paste", " seek", " restore", "cp", " move", " delete", " dup", " transfer", " parallel", " operate", " replicate", " upload", " combine", " clone", " cp", " merge", " recover", " duplicate", "transfer", " Copy", " cat", " download"], "inputFile": ["inile", "configPost", "outputPath", "inputPath", " inputPath", " inputfile", "argumentPath", "configfile", "inputile", "configPath", " inputPost", "inputPost", " inputDir", "argumentfile", "inFile", "outputDir", "inPath", "argumentFile", "argumentPost", "inDir", "inputfile", "inputDir", " inputile", "outputile", "configFile"], "outputFile": ["targetPath", "targetDir", " outputPlace", "outputPath", "inputPath", "writeFilename", "outFile", "targetfile", "outFilename", " outputFilename", "writeDir", "outfile", "outputDir", "writePlace", "outPath", "outputfile", " outputDir", "writeFile", "inputfile", "inputDir", "outputPlace", "targetFile", "outputFilename", "outDir", "outPlace"], "in": ["gin", "info", "per", "read", " din", "old", "up", "cin", "it", "on", "ini", "inf", "inn", "ind", "ze", "min", "ins", "ic", "rin", "reader", "ai", "inc", "al", "iter", "IN", "from", "init", "en", "isin", "inner", "bin", "all", "con", "input", "ri", "sin", "din", "i", "inside", "is", "ir", "In"], "out": ["os", "cn", "null", "end", "ot", "o", "aos", "it", "on", "check", "client", "v", "writer", "can", "obj", "to", "outs", "print", "flush", "by", "io", "log", "cache", "write", "one", "dis", "n", "g", "res", "user", "output", "ex", "Out", "en", "con", "nt", "outer", "ou", "at", "sys", "auto", "OUT", "co", "ne", "cos", "net"], "c": ["nc", "u", "t", "z", "gc", "ec", "cap", "cont", "rc", "ch", "C", "mc", "character", "lc", "count", "cc", "ct", "cp", "ce", "cs", "v", "cd", "l", "k", "f", "r", "uc", "cache", "cl", "x", "n", "code", "unc", "cf", "cos", "pc", "cr", "cu", "arc", "conf", "con", "current", "char", "i", "cm", "cb", "cod", "chain", "bc", "ac", "d"]}}
{"id1": "19868933", "id2": "13891080", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingNHIE", "copyFromFileToFileUsingRIO", "copyFromFileToFileUsingNFile", "copyFromFileToFileusingRFile", "copyFromFileToFileusingRIF", "copyFromFileToFileUsingNHIF", "copyFromFileToFileusingNIE", "copyFromFileToFileUsingRIF", "copyFromFileToFileusingRIO", "copyFromFileToFileusingNIF", "copyFromFileToFileUsingMIO", "copyFromFileToFileUsingRIE", "copyFromFileToFileUsingNHFile", "copyFromFileToFileusingNIO", "copyFromFileToFileusingNFile", "copyFromFileToFileusingRIE", "copyFromFileToFileUsingRFile", "copyFromFileToFileUsingNHIO", "copyFromFileToFileUsingMIF", "copyFromFileToFileUsingNIF", "copyFromFileToFileUsingMFile", "copyFromFileToFileUsingMIE", "copyFromFileToFileUsingNIE"], "inputFile": ["outputPage", "loadfile", "importFile", " inputPage", "inputPath", " inputPath", " inputLe", "openPath", " inputfile", "openFile", "loadLe", "importByte", " inputByte", "openLe", "openfile", " inputStream", "loadFile", "importPage", "inputPage", "loadPath", "outputByte", "outputStream", "inputfile", "inputByte", "inputStream", "importStream", "inputLe"], "outputFile": [" outputFiles", " outputPlace", "resultFile", " outputfile", "outputFiles", "toFiles", "toStream", "resultFiles", "putFile", "putDir", "outputDir", "putfile", "outputfile", "resultPlace", " outputDir", "inputDirectory", "resultStream", "outputStream", "putDirectory", "inputfile", "inputDir", "toFile", "outputPlace", "outputDirectory", "toPlace", " outputDirectory", " outputStream"], "inputChannel": ["openConnection", "inputChuck", " inputchannel", "rawChan", " inputCategory", "openChan", "inputChan", "rawFile", "loadChannel", " inputConnection", "InputChannel", " inputScope", " inputListener", "tableChannel", "httpChan", "loadChuck", "outputConnection", "httpFile", "inputConnection", "inputManager", "inputchannel", "inputBuffer", " inputManager", "internalListener", "tableScope", "rawConnection", "outputChan", " inputBuffer", "tableBlock", "internalChannel", "InputConnection", "inputListener", "importManager", " inputStream", " inputChan", "loadCategory", " inputBlock", "loadManager", "InputBuffer", "httpChannel", "tableListener", "importChuck", "outputBuffer", "outputStream", "inputBlock", "inputCategory", "openChannel", "httpConnection", "outputchannel", "importCategory", "InputStream", "inputScope", "internalBlock", " inputChuck", "importChannel", "rawChannel", "inputStream", "openchannel", "internalScope"], "outputChannel": ["outputButton", "displaychannel", "languageChannel", "publicCow", "putChan", "consolechannel", "removeChannel", "consoleFile", "removechannel", "consoleCow", "putButton", "consoleStream", "consoleChannel", "hiddenCamera", "putChannel", "displayChannel", "OutputStream", "OutputChannel", "languageClient", " outputButton", "languageCategory", "publicchannel", " outputchannel", "displayCategory", " outputCategory", "displayClient", " outputChan", "outputChan", "outputClient", "hiddenChannel", "outputCamera", "hiddenChan", "removeCow", "publicChannel", "OutputFile", "hiddenButton", "outputCategory", "outputStream", "languagechannel", " outputCamera", " outputClient", "outputCow", "outputchannel", "putCamera", "OutputChan", "consoleChan", " outputStream"]}}
{"id1": "15822137", "id2": "19910627", "code1": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "code2": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "label": 0, "substitutes": {"raf": ["rep", "rt", "rw", "zip", "read", "df", "buff", "rc", "dal", "rar", "fp", "dra", "rand", "ref", "tar", "fm", "rain", "bang", "rd", "rm", "ora", "fb", "ain", "uf", "report", "rin", "ra", "req", "r", "rf", "ea", "log", "rl", "io", "proc", "crit", "aux", "fs", "res", "cmd", "ro", "flow", "fc", "act", "csv", "rx", "cr", "cat", "rb", "def", "fam", "ras", "orf", "ma", "ram", "rr", "fr", "db", "cb", "arp", "red", "rou", "form", "roo", "fd", "fin", "dl", "ran", "ar", "af", "ob", "file", "fa", "mr", "fal"], "version": ["sector", "table", "vision", "versions", "mode", "VERSION", "ver", "v", "sequence", "directory", "direction", "vid", "depth", "feature", "number", "action", "vers", "position", "server", "index", "Version", "hash", "description", "type", "format", "volume", "status"], "numTables": ["NumNables", " numLows", "numBabs", "numBables", " numLables", "numNools", " numNTable", "numRrees", " numTabs", "numTrees", "numtables", "numTries", "numBrees", "numTTable", "numTSools", "numLools", "NumNests", "numLabases", " numNables", "numTabases", " numTrees", "numLows", "numNests", "numLabs", "numLries", "numBows", " numTabases", "numTests", "numBabases", "numNrees", "numNables", " numNabs", "NumTables", "numTabs", "numTSries", "numtows", "numRables", "NumTrees", "NumTests", "numLrees", "numtrees", "numLables", "numNries", " numNries", "numNabs", " numLrees", " numNools", "numTows", " numTools", " numTTable", "numRries", "numTSTable", "numLTable", "NumTries", "numLests", "numNTable", "numTSables", " numTows", "NumNries", " numTries", "NumNrees", "numtabases", "numRests", " numNrees", "numBries", "numTools", " numLabases"], "searchRange": ["sourceRange", "resultQuery", "resultRange", "sourceQuery", " searchLength", "searchLength", "searchQuery", "resultRegion", "sourceLength", "resultLength", "searchRegion", " searchRegion", "sourceRegion", " searchQuery"], "entrySelector": ["entryselector", "searchselection", "searchselector", "entrySelectator", "searchSelection", "entryselection", "entryselectator", "entrySequator", "searchselectator", "entrySelection", "searchSelector", "searchSelectension", "entrySequor", "entryChor", "entryChator", "searchSelectator", "entryselectension", "entrySequension", "entrySequion", "entryChion", "searchselectension", "entryChension", "entrySelectension"], "rangeShift": ["rangeshift", " rangeshift", "RangeShift", "rowshift", "rowMask", "rowShift", " rangeMask", "Rangeshift", "RangeOffset", " rangeOffset", "rangeMask", "rangeOffset", "RangeMask", "rowOffset"], "entries": ["ENTriers", "ENTities", "entsries", "ntrys", "centrys", "Enties", "gentrys", "ENTries", "enries", "entables", "Entresses", "Entrils", "entrils", "Entrys", "entires", "entried", "enresses", "ntried", "entriers", "Entires", "entsried", "Entities", "ntables", "ENTresses", "gentried", "entsies", "ENTrys", "entsables", "Entried", "centrils", "entresses", "entities", "gentrils", "ENTried", "entrys", "gentries", "centried", "ntriers", "Entables", "ntries", "Entries", "enires", "enrys", "entsriers", "centries", "enties", "nties", "ENTires", "Entriers", "entsrys", "ntities", "entsities"], "i": ["info", "m", "t", "err", "c", "I", "oi", "y", "f", "io", "x", "ori", "me", "init", "ie", "ik", "index", "u", "j", "gi", "pi", "it", "di", "ind", "internal", "client", "print", "ai", "out", "q", "iri", "bi", "li", "asi", "status", "im", "in", "phi", "ii", "qi", "my", "ti", "batch", "ini", "used", "ski", "php", "hi", "multi", "iy", "uri", "iu", "iter", "ip", "cli", "ij", "ki", "xi", "is", "ei", "ji", "iq", "ci", "mi", "base", "ui", "id", "ic", "inx", "g", "set", "inner", "si", "jp", "point", "sim", "ix", "ami", "ims", "chain", "ity"], "modified": ["mod", "updated", "ported", "initialized", "approved", "module", "successful", "med", "mounted", "active", "ified", "update", "edited", "managed", "specified", "restricted", "documented", "success", "interesting", "valid", "called", "owned", "required", "used", "ended", "mediated", "generated", "provided", "readable", "confirmed", "connected", "created", "magic", "killed", "changed", "colored", "marked", "associated", "encrypted", "dirty", "related", "fixed", "adjusted", "checked", "rolled", "filled", "comment", "identified", "defined", "rendered", "made", "loaded", "locked", "shaped"], "temp": ["pretty", "porary", "perm", "m", "tim", "mod", "tc", "null", "orig", "j", "old", "pid", "fake", " tmp", "v", "buffer", "deg", "vt", "cur", "emp", "test", "txt", "output", "iter", "dat", "copy", "partial", "template", "current", "tr", "pdf", "tmp", "cum", "ptr", "tm", "mint", "tty", "tem", "mp", "Temp"]}}
{"id1": "8747840", "id2": "7458833", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "upload", " copying", "read", "link", "gc", "Copy", "add", "delete", "cp", "map", "sync", "write", " replicate", "cat", "create", "csv", " cp", " mirror", "move", "save", "clip", "slice", "transfer", "clone", " Copy", "download", "load"], "src": ["sit", "sc", "bs", "rc", "pkg", "syn", "cont", "urg", "ser", "sq", "ins", "req", "sf", "cur", "source", "rel", "st", "txt", "rs", "start", "sb", "rx", "init", "from", "ctr", "iv", "sec", "img", "input", "usr", "sin", "sr", "via", "sys", "Source", "inst", "sur", "ipl", "obs"], "dest": ["sit", "null", "orig", "d", "Dest", "gt", "https", "opt", "cont", "end", "mk", "trans", "way", "pas", "decl", "rest", "master", "spec", "deg", "req", "temp", "dist", "source", "th", "test", "st", "good", "mm", "origin", "usr", "nt", "tmp", "target", "nom", "des", "nw", "self", "loc", "pub", "est", "del"], "in": ["info", "gin", "im", "old", "rc", "up", "cin", "on", "it", "inf", "inn", "ind", "id", "ze", "ain", "ins", "ic", "rin", "inc", "ai", "al", "source", "impl", "ln", "iter", "mm", "from", "IN", "init", "en", "isin", "inner", "bin", "con", "input", "din", "i", "inside", "ar", "In"], "out": ["os", "t", "err", "gt", "end", "ot", "ch", "o", "aos", "it", "on", "client", "p", "writer", "can", "obj", "to", "outs", "by", "io", "over", "write", "conn", "not", "dis", "n", "g", "res", "output", "ex", "Out", "en", "bin", "inner", "con", "nt", "outer", "conv", "sum", "ou", "oss", "at", "sys", "auto", "OUT", "co", "ne", "net"], "buf": ["bar", "bh", "buff", "b", "bs", "cap", "mu", "pkg", "stab", "ref", "batch", "block", "Buffer", "used", "vec", "fb", "buffer", "uf", "log", "tab", "mb", "temp", "queue", "str", "Buff", "seq", "aka", "cmd", "bl", "cat", "good", "bag", "cam", "rb", "br", "conv", "bed", "db", "cb", "gen", "cv", "bytes", "box", "data", "msg", "col", "fg", "bus", "prop", "arr"], "c": ["nc", "m", "ci", "t", "z", "gc", "b", "ec", "cont", "rc", "ch", "C", "mc", "a", "lc", "count", "ct", "cc", "cp", "ce", "cs", "dc", "cd", "l", "k", "cod", "call", "uc", "dec", "cache", "n", "code", "unc", "cos", "cf", "fc", "cr", "cu", "conf", "i", "cm", "cb", "co", "ca", "jc", " C", "bc", "ac", "d"]}}
{"id1": "2461169", "id2": "6470716", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsfile", "decodeFileToString", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFileFileFile", "decodeStringToString", "decodeStringToFiles", "decodeString2file", "decodeFileTofile", "decodeFile2String", "decodeStringToFile", "decodeString2String", "decodeString2File", "decodeFileFileFiles", "decodeFileAsFiles", "decodeFile2File", "decodeFile2Files", "decodeString2Files", "decodeFileFileString", "decodeFileToFiles", "decodeFile2file", "decodeFileAsString"], "infile": ["isinfolder", "isinfile", "inputname", "Inbase", "outFile", "outfolder", "InFile", "outfilename", "inname", "isinname", "fromFile", "outname", "Infile", "infolder", "frombase", "inFile", "inputFile", "inbase", "fromfilename", "infilename", "inputfile", "isinFile", "fromfile", "Infilename", "inputfolder", "outbase"], "outfile": [" outname", "inFILE", "Outfilename", "Outfile", "outFile", "otname", "outfilename", "otfile", "inname", " outFile", "outname", "todir", "outdir", "otFILE", "tofilename", "inFile", "outFILE", "indir", "tofile", "Outdir", "infilename", "toFile", "OutFile", " outFILE", "otFile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "variable", "total", "document", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "attribute", "cache", "number", "temp", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "shape", "append"], "read": ["before", "each", "text", "send", "shift", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", " succeed", "ok", "submit", "ratulations", " succ", "condition", "scope", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "summary", "primary", "commit", "positive", "surv", "crit", "same", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", "unity", "please", " successes", "first", "support", "city", "exist", " successful", "ceed", "fail", "response", "successfully", "status", "result", " okay", "accept"]}}
{"id1": "12242903", "id2": "10715601", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"hashKey": ["updateLink", "updatekey", "processkey", "processLink", "processValue", "hashValue", "updateValue", "hashLink", "hashkey", " hashValue", " hashkey", "processKey", " hashLink", "updateKey"], "key": ["ace", "hex", "item", "secret", "null", "phrase", "link", "path", "prefix", "username", "base", "piece", "value", "name", "id", "message", "y", "this", "client", "port", "obj", "password", "k", "seed", "attribute", "cache", "service", "cert", "source", "code", "encrypted", "string", "title", "state", "template", "token", "conf", "KEY", "char", "foo", "json", "description", "sk", "data", "lock", "type", "hello", "entry", "Key", "text", "chain", "et"], "hashed": ["hushed", " hushed", "rhamped", "ahored", "hhed", "khash", "khhed", "hashing", "khrypted", "hamped", "hoted", "shhed", "hoashed", "ahushed", "hrypted", " hrypted", "shoted", "enhhed", "thushed", "rhashed", "thashed", "khashed", "shashed", "khashing", "ahashed", "hored", " hamped", "enhash", " hashing", "ahash", " hhed", "enhashed", "rhhed", "enhrypted", "thash", " hored", "thored", " hoted", "hohed", "shamped", "hoashing", "rhoted", "hoash"], "md5": ["det55", " MD3", "MD3", " MD45", "sha0", "md3", " md45", "MD5", "sha3", "md45", "md55", " MD2", "md2", "sha2", "dig55", " md55", "sha5", "dig3", " MD5", "MD0", " md3", "det3", "MD2", " md0", "det5", "md0", "MD45", " md2", "dig5"], "hash": ["hex", "ah", "shift", "hz", "sample", "length", "ssh", "total", "h", "score", "has", "uh", "ash", "block", "ashed", "check", "square", "sh", "sq", "count", "build", "message", "kernel", "trust", "number", "height", "search", "sha", "Hash", "hed", "index", "sum", "checked", "carry", "tag", "html", "always", "array", "handle", "radius", "shadow"]}}
{"id1": "7764011", "id2": "14758866", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvViewerDoc", "readScalarpvviewersDoc", "readScalarpvviewingFile", "readScalarpvViewersDocument", "readScalarpvviewerDoc", "readScalarpvviewersdocument", "readScalarpvviewingdocument", "readScalarpvviewerdocument", "readScalarpvViewersdocument", "readScalarpvviewerFile", "readScalarpvviewingDocument", "readScalarpvviewingDoc", "readScalarpvviewersDocument", "readScalarpvViewersFile", "readScalarpvViewerdocument", "readScalarpvViewerDocument", "readScalarpvViewersDoc", "readScalarpvviewedDocument", "readScalarpvviewedDoc", "readScalarpvViewerFile", "readScalarpvvieweddocument", "readScalarpvviewersFile", "readScalarpvviewedFile"], "url": ["ret", "ur", "http", "link", "b", "document", "util", "ls", "address", "name", "id", "buffer", "resource", "uri", "l", "sl", "r", "nl", "rl", "str", "res", "mount", "rel", "rect", "location", "ssl", "char", "Url", "web", "mail", "ul", "xml", "file", "data", "loc", "ll", "dl", "open", "cert", "URL", "browser"], "xmlData": ["xmlName", "xmlPart", "jsonData", " xmlText", "mlName", "xpString", "xpdata", "phpName", "mlText", " xmlQuery", "xmlDat", "mlData", "phpPart", "mlPart", "xfDat", "logdata", "xmlText", "xfText", "phpData", " xmlDat", "xmlQuery", " xmlName", "xfQuery", "jsonQuery", " xmlString", "phpText", " xmlContent", "phpContent", "mldata", " xmldata", " xmlPart", "xpDat", "logString", "xmldata", "xpData", "xmlString", "xfData", "logData", "xmlContent", "jsonText", "mlContent", "jsonDat", "phpdata", "logDat"], "in": ["gin", "info", "m", "re", "thin", " din", "mc", "cin", "add", "inf", "inn", "ins", "rin", "reader", "r", "doc", "inc", "out", "IN", "from", "bin", "isin", "inner", "all", "con", "input", "ri", "conf", "din", "i", "as", "file", "is", "In"], "line": ["LINE", "column", "piece", "se", "block", "part", "port", "log", "str", "node", "code", "user", "lin", "word", "trace", "row", "note", "sample", "raw", "cell", "normal", "print", "source", "lined", "ln", "continue", "zone", "header", "ine", "record", "link", "length", "lo", "range", " Line", "check", "list", "change", "pe", "iter", "string", "next", "force", "file", "lock", "text", "item", "detail", "phrase", "stay", "eline", "inline", "message", "Line", "sequence", "l", "nl", "content", "lines", "no", "stroke", "page", "section", "le", "point", "frame", "comment", "online", "data", "entry", "field", "chain", "liner"], "cont": ["nav", "each", "cmp", "c", "coll", "circ", "valid", "ct", "mult", "count", "keep", "cond", "multi", "rest", "control", "content", "cur", "contained", "str", "cart", "code", "cmd", "iter", "txt", "ctr", "cat", "con", "continue", "current", "Cont", "conv", "next", "compl", "CONT", "first", "exist", "contin", "loop", "co", "ont", "const", "cons", "chain", "crit", "any"], "readAdp": ["readADping", "readAdping", "readAdamp", "readAmr", "readAdr", "ReadAdp", "ReadADr", "readadn", " readAdn", "Readadp", "readInterp", "readADj", " readADr", "readADn", "ReadADP", " readADlp", " readAdr", "readAdP", " readADn", "readAdj", "readAdlp", "readADr", " readADP", "readadj", "readadlp", "readADP", "readAmp", "ReadAdj", "readAdamP", "readadping", "Readadj", " readADping", " readAdping", " readAdj", " readAdP", "readAmlp", "readadP", "ReadAdr", "readadr", "readInterlp", "ReadADlp", "readAdn", "Readadlp", "readAdamn", "ReadadP", "readAdamping", "readInterj", "readADlp", " readADj", "ReadAdP", "ReadADp", "ReadAdlp", "readInterP", " readAdlp", " readADp", "readADp", "readadp", "readAmP"], "scalarpvviewerData_Adaptor": ["scalarpvviewerData2adapter", "scalarpvviewerData_Accepter", "scalarpvviewerData_Adaptr", "scalarpvviewerData_Adors", "scalarpvviewerData_adaptorer", "scalarpvviewerData_Adapter", "scalarpvviewerData_Ado", "scalarpvviewerData2Adaptor", "scalarpvviewerData2adaptors", "scalarpvviewerData_Archor", "scalarpvviewerData_Archable", "scalarpvviewerData_AdjustOR", "scalarpvviewerData_AxOR", "scalarpvviewerData_Adaptable", "scalarpvviewerData2adaptr", "scalarpvviewerData_Adaptorer", "scalarpvviewerData2adaptor", "scalarpvviewerData2adapto", "scalarpvviewerData_Accepto", "scalarpvviewerData2Adaptors", "scalarpvviewerData_Adaptors", "scalarpvviewerData_adaptor", "scalarpvviewerData_Axor", "scalarpvviewerData_Axable", "scalarpvviewerData_adapto", "scalarpvviewerData_Axorer", "scalarpvviewerData_adaptr", "scalarpvviewerData_Archorer", "scalarpvviewerData_AdOR", "scalarpvviewerData_Ader", "scalarpvviewerData_ConnectOR", "scalarpvviewerData2Adapter", "scalarpvviewerData_Acceptor", "scalarpvviewerData_Adjustors", "scalarpvviewerData_Adjustable", "scalarpvviewerData_Connector", "scalarpvviewerData_Adr", "scalarpvviewerData2Adaptr", "scalarpvviewerData_ArchOR", "scalarpvviewerData_Adapto", "scalarpvviewerData_adaptors", "scalarpvviewerData_adapter", "scalarpvviewerData_Acceptors", "scalarpvviewerData_Connectable", "scalarpvviewerData_Ador", "scalarpvviewerData2adaptOR", "scalarpvviewerData_Adjustor", "scalarpvviewerData_Connectors", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_adaptable", "scalarpvviewerData_adaptOR", "scalarpvviewerData2AdaptOR", "scalarpvviewerData2Adapto"], "params_font": [" params2system", " params_template", "params_style", "params7system", "params_tt", "params_brand", "params_ont", "params_pen", "params_text", "params12shadow", " params2font", "params6brand", "params_shadow", " params_ont", "params6font", "pretty_font", "params_Font", "params2font", "pretty_layout", "params2system", "params7Font", " params_shadow", " params2Font", "params2Font", "params12system", "params6pen", "params12font", "params2shadow", "params6layout", "pretty_pen", " params_text", " params_Font", "pretty_brand", " params_style", " params_system", "params_system", "params___text", "params_layout", "params___font", "params_template", "params___ont", "params___tt", "params7font", " params_tt", "params7shadow", " params2shadow", "params12Font"], "font_size": ["font_Size", "font_speed", "font_height", "font_family", "font_SIZE", " font_width", " font_speed", " font_Size", " font_family", "font_width", " font_height", " font_SIZE"], "style": ["styles", "Style", "less", " Style", "link", "margin", "sty", "mode", "font", "css", "weight", "value", "error", "color", "role", "stable", "layout", "padding", "country", "estyle", " styles", "height", "les", "stroke", "sche", "theme", "state", "pattern", "class", "position", "show", "script", "size", "format", "family", "type", "handle", "status", "shadow", "angle"], "font_Family": ["font_Name", "font_Style", "fontTypefamily", "font_family", "fontNameName", " font_Role", "font_Role", "family_Style", "fontTypeRole", " fontNameRole", "family_family", "family_Family", " font_family", "fontNamefamily", "fontNameFamily", " fontNameFamily", " fontNamefamily", "fontNameStyle", "fontNameRole", "family_Name", "fontTypeFamily"], "globalFont": ["generalFloat", "localFont", "generalFont", "globalONT", "commonFontSize", "globalFamily", " globalONT", "generalFontSize", "commonFont", "foreignFamily", "GlobalFloat", "commonFamily", "generalONT", "foreignFont", " globalFloat", "localFamily", "GlobalFont", "globalFloat", "GlobalONT", "globalFontSize", "GlobalFontSize", "foreignFontSize", "localFontSize", " globalFontSize"], "params_pts": ["params_nt5", "params_ptis", "params_pt5", "params_xtls", "params_xts", "params_nts", "params_iptes", "params_ptes", "params_cts", "params_ntjs", "params2ptjs", "params2ptts", "params_ctjs", "params2pts", "params_brts", "params_ptjs", "params2pties", "params_nties", "params_ntls", "params_ctes", "params_ptts", "params_ntts", "params2nts", "params_bries", "params_ntis", "params_xt5", "params_ntt", "params_iptt", "params_cties", "params_ptls", "params_brs", "params_iptm", "params_pties", "params_ptyis", "params_pty5", "params_xtis", "params2ntjs", "params_brjs", "params_ptt", "params2nties", "params_ptys", "params_ipts", "params_ntm", "params_ptm", "params_ptyls", "params_ntes", "params2ntts", "params_ctm", "params_ctts", "params_ctt"], "params_data": [" paramsPar", "paramsPar", " params_", "argsPar", "paramPar", "param_", "params_", "args_"]}}
{"id1": "16232202", "id2": "6159896", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"doPost": ["doAdd", " doAdd", "handlepost", " doPOST", "handlePost", "DoAdd", "handleAdd", "DoPOST", " dopost", "DoPost", "handlePOST", "dopost", "doPOST", "Dopost"], "request": ["QUEST", "http", "get", "register", "require", "version", "quest", "worker", "address", "context", "claim", "user", "input", "subject", "attribute", "runtime", "raw", "client", "the", "post", "report", "print", "begin", "select", "order", "complete", "template", "query", "session", "law", "web", "remove", "xml", "requ", "view", "Request", "open", "command", "result", "record", "re", "have", "setup", "document", "condition", "media", "list", "connection", "directory", "call", "application", "controller", "pe", "work", "current", "position", "server", "first", "initial", "remote", "collection", "process", "forward", "url", "reference", "environment", "message", "reset", "req", "ire", "local", "create", "frame", "handle", "browser"], "response": ["answer", "re", "detail", "send", "http", "exit", "resp", "document", "security", "object", "onse", "e", "version", "esi", "settings", "environment", "message", "connection", "image", "sequence", "summary", "social", "report", "print", "ve", "service", "out", "respond", "application", "res", "console", "site", "video", "output", "profile", "location", "page", "reply", "position", "continue", "network", "Response", "render", "server", "next", "session", "description", "header", "view", "entry", "status", "event", "shell"], "cu": ["cn", "cro", "u", "ci", "tc", "ur", "cy", "umi", "cul", "UD", "CU", "c", "mu", "gu", "uci", "us", "ut", "util", "du", "pu", "chu", "lc", "lu", "su", "au", "ui", "ucc", "cp", "Cu", "bo", "angu", "hu", "uu", "uc", "ocr", "um", "yu", "uo", "tu", "nu", "ru", "aco", "ju", "unc", "ub", "U", "ctx", "ua", "cci", "gru", "ck", "cpu", "ou", "cum", "aus", "cm", "eu", "co", "hua", "cgi", "ue", "zu", "cus"], "ud": ["uda", "gd", "u", "ci", "ur", "ad", "UD", "htt", "pd", "gu", "ld", "us", "mud", "ut", "util", "du", "dk", " du", "uh", "su", "di", "ost", "udi", "ui", "cus", "aud", "edu", "urd", "ow", "od", "ku", "uu", "bd", "uc", "udo", "um", "eus", "gb", "ord", "tu", "ub", "unc", "uid", "zu", "unt", "rod", "td", "ck", "und", "udd", "oud", "uds", "aus", "hd", "eu", "dl", "vd", "dd", "d"], "returnTo": ["addTo", "ReturnTo", "renderTO", "returnTarget", "returnTO", "urnto", "urnTO", "addTarget", "addTO", "return2", "ReturnTO", "renderto", "urnTarget", "endto", "Returnto", "endTo", "urn2", "endTO", "renderTo", "urnTo", "Return2", "addto", "endTarget", "returnto", "render2"], "password": ["paste", "secret", "email", "phrase", "ssh", "Password", "crypt", "security", "default", "definition", "username", "prefix", "message", "sword", "login", "reset", "trust", "remember", "padding", "user", "profile", "auth", "pty", "pattern", "push", "token", "word", "database", "pool", "PASS", "description", "hello", "wd", "command", "shadow", "attribute"], "md": ["mod", "m", "ms", "det", "pd", "df", "mac", "amd", "ld", " MD", "mk", "dh", "mc", "nd", "MD", "cd", "mn", "mt", "od", "bd", "mb", "sm", "magic", "sd", "mg", "cmd", "dm", "mm", "td", "Cmd", "pdf", "der", "hd", " Md", "msg", "grad", "and", "dd", "d"], "hash": ["hex", "shift", "mac", "where", "rand", "h", "oh", "has", "raw", "ash", "flash", "check", "sh", "dig", "rh", "height", "str", "test", "ashes", "init", "result", "char", "tr", "sha", "Hash", "hed", "sum", "hd", "html", "her", "bytes", "data", "len", "key", "handle", "shadow", "ho"], "pass": ["secret", "pos", "zip", "ack", "read", "Pass", "pp", "pkg", "default", "prop", "add", "pg", "pas", "ps", " def", "conn", "mask", "test", "cat", "pack", "step", "act", "alias", "def", "push", "conf", "priv", "ph", "session", "tag", "ass", "pool", "PASS", "task", "fail", "ask", "wd", "handle", "auth"], "vis": ["info", "mod", "ha", "nav", "VIS", "gu", "cap", "val", "study", "key", "iz", "circ", "ver", "mit", "cond", "v", "vid", "rav", "var", "hidden", "str", "see", "vert", "visible", "stat", "tri", "att", "state", "feat", "cfg", "def", "virt", "comm", "miss", "priv", "display", "inv", "access", "pres", "wa", "vol", "is", "type", "view", "san", "serv", "Vis", "label", "act", "status"]}}
{"id1": "6371607", "id2": "15445861", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"removeRealm": ["remrealms", "removePerM", "remRealms", "removeRealms", "remrealm", "remRealm", "removePerm", "removerealM", "remrealmo", "removeScheM", "removePerarm", "removeAlms", "removeAlm", "removePerms", "removeSchem", "removerealmo", "remRealmo", "removeRealarm", "remRealM", "removeRealmo", "removePermo", "remRealarm", "remrealarm", "remrealM", "removeAlmo", "removeSchems", "removeRealM", "removerealm", "removerealarm", "removerealms", "removeSchemo", "removeAlarm"], "realmIds": ["realmsIdList", "realmIdList", "realmPathls", "realmidsList", "realmIdids", "realmsIdids", "realmsIdls", "realmIdParts", "realmsByIdids", "realmPathParts", "realmIDs", "realmidss", "realmidsParts", "realmsByIdParts", "realmIdNames", "realmByIdls", "realmIDList", "realmidsls", "realmidsids", "realmsIdNames", "realmsByIdList", "realmByIdNames", "realmByIds", "realmsIdParts", "realmIdls", "realmsByIdls", "realmsIds", "realmsByIdNames", "realmidsNames", "realmByIdParts", "realmByIdList", "realmByIdids", "realmPathids", "realmIDls", "realmPaths", "realmsByIds", "realmIDNames"], "psImpl": ["pseImpl", "PSImpl", " psObj", " psStack", "epsimpl", " psInstance", "ppsimpl", "epsObj", "ppsEl", "ppsInstance", "psEl", "psimpl", "psObj", "ppsExpl", "psStack", "psInstance", "psExpl", "PSExpl", "pseEl", "PSEl", "PSimpl", " psimpl", "epsExpl", "ppsStack", "epsImpl", " psEl", "pseInstance", "pseStack", "ppsImpl", " psExpl", "PSObj"], "iter": [" iv", "hex", "oper", "fer", "older", "nr", "per", "iller", "ner", "coll", "upper", "iz", "ver", "lim", "it", "ider", "its", "valid", "ser", "ind", "iterator", "er", "Iter", "gener", "ev", "ait", "ori", "vers", "cer", "ip", "former", "inter", " iterator", "iv", "outer", "ger", "li", "walker", "i", "ter", "iner", "gen", "loop", "vis", "inv", "her", "ptr", "loc", "liter", "ipper", "ator", "ir"], "realmId": ["balmId", "realvmID", "RealmId", "realMPath", "RealMId", "realomInd", "trvReference", "realnId", "palmid", "palmID", "trmId", "realvmId", "realnPath", "realgmId", "pallemid", "realmiInt", "realmeid", "RealMById", "balmid", "realomReference", "realomID", "reallemID", "realgmid", "realmid", "realvReference", "realvId", "RealmPath", "pallemID", "RealmRef", "RealmById", "realmeInt", "realvmIs", "realMId", "realmeID", "realgId", "balmID", "realvInd", "realomId", "reallemInt", "realmID", "trvInd", "trmInd", "realgRef", "realgmID", "realmiid", "trmID", "realvID", "realgById", "realmIs", "realgPath", "realmanInd", "realnRef", "realmRef", "trmReference", "palmInt", "realmeId", "realnById", "realmanID", "balmIs", "realmanReference", "reallemid", "trvID", "realmanId", "realgmIs", "realmReference", "pallemId", "realmiIs", "realmiId", "realmPath", "balgmid", "realmiID", "realmInd", "RealMPath", "pallemInt", "balgmID", "balgmIs", "realmById", "realMRef", "realmInt", "palmId", "realMById", "trvId", "realvmid", "RealMRef", "balgmId", "reallemId"]}}
{"id1": "14093044", "id2": "2199604", "code1": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"insert": ["sql", "exec", "update", "submit", "add", "Insert", "check", "delete", "login", "write", "put", "scan", "select", "set", "create", "replace", "init", "save", "push", "database", "index", "query", "execute", "commit", "load", "append"], "consulta": ["consaultA", "conscentae", "consultas", "consultA", "concentae", "conultsa", "Conscenta", "consultsa", "conscentana", "Consultas", "Consulta", "conscentla", "conultae", "conultar", "consaultae", "consaultana", "consultana", "Consumerana", "Conscentas", "conultas", "consumerA", "Consumeras", "conscentas", "consertas", "consulsaria", "consertar", "consumptionas", "consumptionar", "consulsa", "concentar", "Conscentla", "consultable", "consultsae", "conscentar", "conultsas", "consaulta", "conserta", "concentas", "consumea", "consaultaria", "consultae", "conscentable", "consumptionable", "consumptiona", "consertae", "Consultable", "consaultas", "conulta", "ConsultA", "conscentA", "consultar", "consulsas", "consumeas", "consultsas", "consumptionla", "consumera", "conscenta", "Consumera", "consultaria", "consumela", "Consultla", "conultsaria", "consumerana", "consumeable", "consumptionae", "Consultana", "consulsae", "ConsumerA", "concenta", "conultaria", "consumeras", "consultla", "consultsaria", "Conscentable", "conultsae"], "autocommit": ["autOCommulate", "autocondits", "autocomits", "autocondulate", "autOComits", "autocommmit", "autocondort", "autoccelermit", "autococomulate", "autocombit", "autoconombit", "autoconomate", "autocomulate", "autocomite", "autocompate", "autocompulate", "autoconomit", "autocomate", "autocumnmit", "autoconommate", "autOCommite", "autocumnate", "autocommits", "autocommbit", "autOComit", "autocondite", "autocondmit", "autocomort", "autoccelerulate", "autOCommort", "autocompmit", "autocubmit", "autOCommate", "autocompbit", "autOComort", "autOCommmit", "autoccelerit", "autococomit", "autocompit", "autoccelerort", "autocubit", "autococomate", "autocommulate", "autoconommmit", "autocommate", "autOComulate", "autocubits", "autOCommit", "autocumnit", "autOCommits", "autoconommit", "autocomit", "autocumnbit", "autOComite", "autococommit", "autocommort", "autoconommbit", "autOComate", "autocondit", "autocubite", "autocommite"], "transactionIsolation": ["transactionISola", "transceptionIolation", "transversionIsration", "transactionIensitivity", "transactionIolate", "transactionAsolated", "transactionISruption", "transactionInsolation", "transversionIdavior", "transactionInterola", "transactionStyleilon", "transactionIsularity", "transactionIsolated", "transceptionIOL", "transceptionIsilon", "transactionIsensitivity", "transpointIsruption", "transactionIulation", "transactionAsolate", "transceptionIolated", "transactionInterularity", "transactionInolate", "transactionInolation", "transactionIsulation", "transactionStyleensitivity", "transpointInterruption", "transactionAsularity", "transactionISOL", "transactionISulation", "transactionInterruption", "transversionIdolate", "transactionISilon", "transactionISolated", "transactionIsruption", "transversionIdration", "transceptionIularity", "transpointIsolation", "transactionIfolation", "transceptionIsensitivity", "transactionISavior", "transactionIolated", "transpointInterolation", "transactionIfruption", "transactionInterulation", "transactionIsOL", "transceptionIsolate", "transactionISration", "transactionIilon", "transactionStyleolate", "transactionInsavior", "transactionStyleolation", "transactionInolated", "transceptionIsOL", "transceptionIolate", "transactionIsration", "transactionISensitivity", "transceptionIensitivity", "transactionIsilon", "transactionInsolate", "transversionIsavior", "transactionIularity", "transpointIsola", "transversionIsolate", "transactionInterolation", "transactionISolate", "transactionAsolation", "transpointIsolated", "transactionInterolated", "transversionIdolation", "transactionInterolate", "transpointInterolated", "transactionIsola", "transceptionIilon", "transactionIdolate", "transactionInsration", "transactionIfolated", "transactionIOL", "transactionIsavior", "transactionInOL", "transversionIsolation", "transactionIdavior", "transceptionIulation", "transactionIdolation", "transceptionIsulation", "transpointInterola", "transactionIolation", "transceptionIsularity", "transactionIsolate", "transactionIdration", "transceptionIsolated", "transactionISolation", "transceptionIsolation", "transactionIfola"], "cx": [" cxi", "cxi", "actx", "ncX", "Cx", " ctx", "Cxi", "cxt", "cX", "CX", "acX", "ctx", "nctx", "Cxt", "acx", " cxt", "ncx", "ncxi", " cX", "acxt", "Ctx"], "filasInsert": ["filaDelete", "filasEnter", "filacsInsert", "filataImport", "folASRow", "filasaAdd", "filinasImport", " filasaInsert", "fundasInsert", "filataDelete", " filasUpdate", "folasImport", "filASRow", "filacsEnter", "filacsRow", "fundaInsert", "filASImport", "filASInsert", "filiasInsert", "folASImport", "filasDelete", "filrasUpdate", "filasaUpload", "filinasUpload", "filaInsert", "fundaImport", "folASInsert", " filasaUpload", "filASEnter", "folasEnter", "filiasImport", "fundaDelete", "filacsImport", "filasImport", " filasUpload", "filaImport", "filrasInsert", "folasRow", "filinasAdd", "fundasImport", "fundasDelete", "filasaInsert", "filasUpdate", " filasaAdd", "filinasRow", "folASEnter", "filasUpload", "filasAdd", " filasAdd", "filrasAdd", "filinasInsert", "filinasUpdate", "filasaUpdate", " filasaUpdate", "filasRow", "filrasUpload", "filataInsert", "filiasDelete", "folasInsert", "filinasEnter"], "tipoConsulta": ["tipoConsumeras", "tipoConsultsar", "tipoConsresenta", "tipoConsresentar", "tipoCoulsar", "tipoConsulsada", "tipoConsultsada", "tipoConsumerada", "tipoConsultada", "tipoconsulta", "tipoCoultar", "tipoConsulao", "tipoConsulara", "tipoconsultada", "tipoConsultao", "tipoConsulsas", "tipoConsultsas", "tipoConultara", "tipoConultas", "tipoconsultsada", "tipoConsultA", "tipoConsultsA", "tipoConsresentao", "tipoConista", "tipoConsista", "tipoConistara", "tipoconsultsa", "tipoConsumptiona", "tipoConsulas", "tipoCoulsa", "tipoConsultsao", "tipoConsultas", "tipoConsistas", "tipoConsumerA", "tipoConulta", "tipoCoulsada", "tipoConsulsa", "tipoconsultas", "tipoConsultsa", "tipoConsultara", "tipoConultao", "tipoConistao", "tipoCoultao", "tipoConsresentada", "tipoConsulsar", "tipoConsistara", "tipoConsula", "tipoConsumptionas", "tipoconsultsas", "tipoConsumptionao", "tipoConsumera", "tipoConsulsA", "tipoCoulta", "tipoConsultar", "tipoCoulsao", "tipoconsultsA", "tipoConistas", "tipoConsistao", "tipoconsultA", "tipoCoultada", "tipoConsumptionara", "tipoConsulsao"], "execConsulta": ["execConsaulta", "execConsaultas", "execConsumeas", "execConsortiuma", "execConsonseai", "execConsumear", "execCoertai", "execConsortiumai", "execCoertarea", "execConsortiumarea", "execConsonsearea", "execCoertalpha", "execConsultar", "execConsonsea", "execConsertai", "execConsultla", "execConultas", "execConsonsealpha", "execConsertalpha", "execCoultarea", "execConulta", "execConultla", "execConsultalpha", "execConsertarea", "execConsultarea", "execCoultalpha", "execCoulta", "execConsultai", "execConsaultar", "execConsortiumalpha", "execConsultas", "execCoultai", "execConserta", "execCoerta", "execConultar", "execConsumea", "execConsaultla", "execConsumela"], "conexion": ["coeuxinion", "conextION", "coneixression", "conexpison", "coexision", "coneuxion", "conexions", "coeexION", "coneexond", "coextion", "conextinion", "coexions", "coneplexison", "coneXion", "conexpione", "coneaxione", "cakexpison", "conenexions", "cakexison", "coeuxion", "conenexION", "coexinion", "caixION", "coneexible", "Colexpion", "coeuxION", "conexison", "Colexpison", "conexpond", "coneixION", "coneaxison", "caxison", "conextions", "caixion", "conenexison", "coneuxions", "conexpION", "conextison", "conenexone", "cakexione", "caixression", "conextision", "coneplexION", "conexpion", "Colexpone", "conenexinion", "conexione", "coneexION", "coneXION", "conexinion", "coexION", "cakexion", "caxion", "coextision", "coneixione", "coeexison", "coextison", "conextione", "Colexion", "conexond", "Colexison", "coneuxinion", "conexpions", "cakexpione", "coneexision", "conexible", "coneexone", "coexond", "conexpone", "coextione", "coneexione", "caxression", "coexison", "Colexone", "cakexION", "conexression", "coneaxision", "coneXible", "conenexression", "conenexion", "coneixison", "caxION", "coneexion", "conexION", "coneexison", "conenexione", "coneixion", "coeexion", "coneplexione", "cakexpION", "conexision", "coneXione", "coeuxions", "coneuxION", "conexone", "conextion", "coeexible", "conextression", "Colexpions", "coneplexion", "cakexpion", "coexione", "coeexond", "coneixond", "Colexions", "coneexions", "conenexible", "caixison", "coexible", "coneaxion", "coeexione", "coexion"], "st": ["src", "tt", " est", "sc", "t", "null", "stop", "sty", "end", "ste", "ut", "statement", "se", "it", "nd", "ct", "ost", "sh", "sp", "ts", "St", "obj", "rest", "mt", "sle", " ST", "stable", "sl", "stage", "sw", "std", "put", "cl", "sm", "str", "sth", "pe", "ist", "set", "start", "sn", "ust", "sts", "state", "stat", "tmp", "inst", "est", "ST", "pt"], "MySQL": ["mysQL", "MyQL", "mySQL", "myDB", "mysSQL", "MYDB", "myQL", "MYSQL", "mysDB", "MYQL", "MyDB"]}}
{"id1": "19912848", "id2": "22368133", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void testMapSource(MapSource mapSource, EastNorthCoordinate coordinate) {\n        try {\n            System.out.println(\"Testing \" + mapSource.toString());\n            int zoom = mapSource.getMinZoom() + ((mapSource.getMaxZoom() - mapSource.getMinZoom()) / 2);\n            MapSpace mapSpace = mapSource.getMapSpace();\n            int tilex = mapSpace.cLonToX(coordinate.lon, zoom) / mapSpace.getTileSize();\n            int tiley = mapSpace.cLatToY(coordinate.lat, zoom) / mapSpace.getTileSize();\n            url = new URL(mapSource.getTileUrl(zoom, tilex, tiley));\n            System.out.println(\"Sample url: \" + url);\n            c = (HttpURLConnection) url.openConnection();\n            System.out.println(\"Connecting...\");\n            c.connect();\n            System.out.println(\"Connection established - response HTTP \" + c.getResponseCode());\n            if (c.getResponseCode() != 200) return;\n            String contentType = c.getContentType();\n            System.out.print(\"Image format          : \");\n            if (\"image/png\".equals(contentType)) System.out.println(\"png\"); else if (\"image/jpeg\".equals(contentType)) System.out.println(\"jpg\"); else System.out.println(\"unknown\");\n            String eTag = c.getHeaderField(\"ETag\");\n            boolean eTagSupported = (eTag != null);\n            if (eTagSupported) {\n                System.out.println(\"eTag                  : \" + eTag);\n                testIfNoneMatch();\n            } else System.out.println(\"eTag                  : -\");\n            long date = c.getDate();\n            if (date == 0) System.out.println(\"Date time             : -\"); else System.out.println(\"Date time             : \" + new Date(date));\n            long exp = c.getExpiration();\n            if (exp == 0) System.out.println(\"Expiration time       : -\"); else System.out.println(\"Expiration time       : \" + new Date(exp));\n            long modified = c.getLastModified();\n            if (modified == 0) System.out.println(\"Last modified time    : not set\"); else System.out.println(\"Last modified time    : \" + new Date(modified));\n            testIfModified();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"\\n\");\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileAsfile", "decodeFileToString", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFileFileFile", "decodeStringToString", "decodeStringToFiles", "decodeString2file", "decodeFileTofile", "decodeFile2String", "decodeStringToFile", "decodeString2String", "decodeString2File", "decodeFileFileFiles", "decodeFileAsFiles", "decodeFile2File", "decodeFile2Files", "decodeString2Files", "decodeFileFileString", "decodeFileToFiles", "decodeFile2file", "decodeFileAsString"], "infile": ["isinfolder", "isinfile", "inputname", "Inbase", "outFile", "outfolder", "InFile", "outfilename", "inname", "isinname", "fromFile", "outname", "Infile", "infolder", "frombase", "inFile", "inputFile", "inbase", "fromfilename", "infilename", "inputfile", "isinFile", "fromfile", "Infilename", "inputfolder", "outbase"], "outfile": [" outname", "inFILE", "Outfilename", "Outfile", "outFile", "otname", "outfilename", "otfile", "inname", " outFile", "outname", "todir", "outdir", "otFILE", "tofilename", "inFile", "outFILE", "indir", "tofile", "Outdir", "infilename", "toFile", "OutFile", " outFILE", "otFile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "variable", "total", "document", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "attribute", "cache", "number", "temp", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "shape", "append"], "read": ["before", "each", "text", "send", "shift", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", " succeed", "ok", "submit", "ratulations", " succ", "condition", "scope", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "summary", "primary", "commit", "positive", "surv", "crit", "same", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", "unity", "please", " successes", "first", "support", "city", "exist", " successful", "ceed", "fail", "response", "successfully", "status", "result", " okay", "accept"]}}
{"id1": "10759917", "id2": "15971794", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"delete": ["drop", "update", "link", "dump", "get", "destroy", "Delete", "reset", "write", "put", "select", "de", "set", "create", "replace", "touch", "move", "save", "query", "remove", "lete", "insert", "execute", "clear", "download", "command", "load", "del"], "name": ["m", "NAME", "item", "null", "w", "link", "Name", "old", "c", "path", "o", "key", "url", "base", "prefix", "e", "nm", "part", "parent", "value", "common", "version", "id", "message", "error", "lon", "resource", "connection", "l", "term", "str", "source", "n", "code", "me", "local", "create", "string", "search", "title", "alias", "word", "ma", "names", "ame", "comment", "description", "data", "size", "file", "format", "family", "type", "label", "filename", "chain", "time"], "CannotDeleteSystemLinkException": ["CannotDeleteSystemTypeException", "CannotDeleteSystemDataStatus", "CannotDeleteSysLinksException", "CannotDeleteSystemLinkStatus", "CannotDeleteSystemDataEx", "CannotDeleteSystemLinksWarning", "CannotDeleteSystemLinksEx", "CannotDeleteSystemPageStatus", "CannotDeleteSysLinksEx", "CannotDeleteSystemPageError", "CannotDeleteSystemDataError", "CannotDeleteSystemLinksStatus", "CannotDeleteSysLinkError", "CannotDeleteSystemLinkWarning", "CannotDeleteSysLinkStatus", "CannotDeleteSysLinksStatus", "CannotDeleteSystemPageException", "CannotDeleteSysLinksError", "CannotDeleteSystemTypeError", "CannotDeleteSystemTypeWarning", "CannotDeleteSystemLinkError", "CannotDeleteSysLinkException", "CannotDeleteSystemLinkEx", "CannotDeleteSysLinkEx", "CannotDeleteSystemDataException", "CannotDeleteSystemPageEx", "CannotDeleteSystemLinksError", "CannotDeleteSystemLinksException", "CannotDeleteSystemTypeEx"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeIsFindEx", "ClassLinkTypeIsFind ", "ClassLinkTypeIsFoundException", "ClassLinkTypeNotFound ", "ClassLinkTypeIsFoundOver", "ClassLinkTypeNotUsedException", "ClassLinkTypeNotFindException", "ClassLinkTypeNotUsed ", "ClassLinkTypeNotFoundEx", "ClassLinkTypeIsFound ", "ClassLinkTypeIsFoundEx", "ClassLinkTypeNotFindEx", "ClassLinkTypeNotFindOver", "ClassLinkTypeNotFoundOver", "ClassLinkTypeNotUsedOver", "ClassLinkTypeNotUsedEx", "ClassLinkTypeIsFindOver", "ClassLinkTypeIsFindException", "ClassLinkTypeNotFind "], "conn": ["cn", "oc", "t", "err", "ec", "gate", "c", "pkg", "resp", "coll", "ws", "socket", "yes", "port", "bo", "cur", "Conn", "org", "die", "ctx", "en", "conf", "sec", "canon", "co", "nc", "rt", "gc", "pas", "client", "yn", "enc", "act", "cb", "pool", "loc", "open", "pt", "dn", "ang", "pen", "mc", "on", "cc", "ct", "pg", "cp", "ce", "ns", "connection", "obj", "iw", "rel", "cmd", "ens", "comm", "db", "connect", "addr", "ca", "exec", "close", "https", "ch", "mt", "req", "win", "con", "jp", "nt", "conv", "priv", "sys", "cert", "col"], "stmt": ["startMT", "strr", "stattm", "statMT", "constmb", "strpr", "STtm", "stmp", "snMT", " sttm", "Stmm", "statm", " stmb", "STmt", "startmm", "strmt", " str", "startmt", " stpr", "Str", " stm", "consttm", "STMT", "STmm", "strMT", "strm", "stm", "sttx", "statmt", " stMT", "Sttm", "str", "StMT", "Stmp", "Stpt", "Stm", "sttm", "Stpr", "constm", "snmt", "startmp", "snm", "stMT", " stmm", "strmp", "stmb", "STtx", "stpr", " stpt", "stmm", " sttx", "Stmt", "Stmb", "STmb", "STm", "snpt", "stpt", "strmm", "constmt", "Sttx"], "prepTable": ["PrepTier", "prepTier", " prepTier", "Preptable", "PrepTable", "ppTab", "prepTree", "summaryTier", "ppTable", "summarytable", "pptable", " prepTree", "summaryTable", " preptable", "preptable", " prepTab", "PrepTree", "prepTab", "ppTree", "PrepTab"], "objectLinkTable": ["objLinksTable", "objLinktable", " objectLinktable", "objectTypetable", "objectTypeTab", " objectLinkTab", "objectLinkList", "objectLinktable", "objectTypeType", "objectTypeTable", "objLinksList", "objectlinkType", "objectLinkType", "objLinkstable", "objectlinkTab", "objectlinktable", " objectLinkType", "objectLinksController", "objectLinksTable", "objectLinkstable", "objectLinkController", "objLinkList", "objectlinkTable", "objLinkController", "objectLinkTab", "objectLinksList", "objLinkTable", "objLinksController"], "sql": ["join", "scl", "fn", "expression", "url", "expr", "ips", "sq", "sp", "ns", "quote", "s", "spec", "sl", "nl", "spr", "sf", "q", "fields", "str", "sd", "select", "js", "sv", "rel", "csv", "string", "template", "SQL", "query", "json", "inv", "html", "description", "xml", "form", "dl", "format", "qs", "result", "ql"]}}
{"id1": "3024970", "id2": "13516684", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamtoOutputFile", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamToInputstream", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamToInputFile", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamTooutputFile", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamtoInputStream", "testCopy_inputStreamtoInputSteam", "testCopy_inputStreamtoInputstream"], "in": ["gin", "sql", "im", "read", "nin", " din", "c", "mc", "h", "mi", "up", "cin", "it", "on", "ini", "inf", "inn", "ind", "this", "p", "ain", "ins", "log", "rin", "l", "io", "r", "doc", "ai", "ic", "q", "al", "source", "scan", "n", "IN", "from", "iter", "mm", "init", "copy", "en", "inner", "isin", "bin", "con", "input", "sin", "din", "inv", "i", "inside", "el", "xml", "is", "ac", "In"], "baout": ["kaout", "kaend", "baot", "balog", " baot", "caOut", "baio", "cain", "baouts", "caouts", "bain", "abaout", "baend", "BAout", "abain", "BAot", "Balog", "BaOut", "boout", " baend", "boio", "caio", " baouts", " bain", "boOut", "oaout", "Baouts", "caout", "baOut", "BAin", "Baout", "kaOut", "BAOut", "oain", "abaot", "abaOut", "oaio", "caend", "boin", " balog", "oaOut", " baOut", "calog", "kain"], "out": ["null", "t", "b", "gt", "ot", "o", "up", "aos", "it", "gr", "check", "list", "client", "obj", "to", "log", "outs", "io", "n", "g", "res", "cmd", "output", "set", "ex", "Out", "copy", "all", "con", "conv", "sum", "ou", "oss", "at", "sys", "OU", " Out", "OUT", "co", "serv", "net"], "count": ["counter", "z", "read", "length", "resp", "total", "c", "amount", "Count", "found", "ct", "id", "skip", "number", "N", "code", "ount", "ctr", "start", "current", "nt", "num", "index", "sum", "size", "nb"]}}
{"id1": "6470716", "id2": "3809087", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"st": ["tt", "rt", "ft", "t", "ld", "sty", "stri", "ste", "stream", "se", "nd", "sh", "store", "ost", "sp", "ast", "St", "rest", "stable", "sw", "std", "service", "sm", "th", "str", "sth", "www", "set", "ist", "start", "step", "sn", "ust", "sts", "stra", "sta", "inst", "est", "ST", "d"], "url": ["ret", "pl", "domain", "bel", "ur", "null", "http", "hl", "link", "il", "ch", "github", "ref", "ls", "host", "base", "gl", "build", "address", "client", "rest", "l", "uri", "f", "sl", "fl", "nl", "r", "cl", "str", "rect", "mount", "rel", "impl", "www", "location", "ssl", "string", "char", "li", "Url", "mail", "web", "ul", "el", "addr", "html", "abs", "file", "loc", "dl", "ll", "cert", "URL", "browser", "shell"], "fis": ["Fais", "fier", "tos", "Fos", " f\u00eds", "efi", "xfier", "f\u00eds", "efis", "flis", "tais", "tis", "fliss", "feier", "fiss", "ufisl", "feois", "fais", " fisl", "efiss", "Fi", "Fier", "feis", "tiss", "ufi", "uf\u00eds", " fiss", "fisl", "xfi", "flisl", "xfis", "fli", "fei", "ef\u00eds", "ufiss", "Fiss", "fois", "Fois", "xfois", "ufis", "Fis", "fi", " fais", " fi"], "zis": ["zIs", "fits", "ozisin", "ozits", " zris", "zhis", "zenis", " zisa", "zipisin", "zisin", "zipIs", "ozisa", "czIs", " zos", "zenisi", "czis", "zipits", "zisi", "zhes", "zisa", "fiss", "ozis", " zIs", "zipis", "zenris", "fisi", "ozes", " zisi", "zos", "zhIs", "czisa", "zeniss", "zris", "czits", "zipes", "zhisin", "zits", "ziss", "ozIs", "zes", " zits", " ziss", "fris", "zipos"], "entry": ["record", "info", "row", "item", "null", "zip", "office", "link", "Entry", "existent", "jo", "se", "line", "be", "e", "or", "valid", "way", "sp", "ce", "list", "cell", "name", "system", "zo", "obj", "log", "element", "enter", "member", "out", "card", "source", "de", "jar", "entity", "inter", "ie", "def", "pattern", "word", "char", "nt", "tmp", "index", "fr", "ry", "comment", "form", "match", "chain", "field", "key", "ent", "event", "result", "attribute"], "count": ["counter", "t", "err", "read", "length", "total", "c", "cont", "end", "ch", "amount", "Count", "batch", "base", "add", "acc", "found", "check", "ct", "cc", "ind", "name", "cell", "buffer", "last", "call", "depth", "number", "n", "code", "ount", "iter", "child", "ctr", "start", "page", "current", "char", "core", "nt", "num", "index", "sum", "force", "comment", "size", "match", "len", "max", "nb"], "data": ["ata", "sample", "length", "table", "done", "mu", "zero", "DATA", "batch", "raw", "block", "value", "reason", "mem", "part", "name", "message", "buffer", "image", "number", "out", "cache", "source", "n", "buf", "output", "good", "step", "dat", " DATA", "string", "all", "def", "bin", "area", "next", "json", "bytes", "size", "format", "text", "chain", "result", "d"], "fos": ["wOS", "Fops", "Fos", "fOS", "foops", "his", "Fol", "fioss", "wos", "hOS", "fooss", "woss", "fool", "Foss", "fios", "fiol", " foss", " fOS", "hoss", "wis", "hos", "fiops", "foss", "fops", "fol", "foos"], "dest": ["src", "send", "det", "Dest", "done", "gate", "cont", "gest", "nd", "desc", "trans", "mem", "parent", "way", "pas", "decl", "coord", "dc", "writer", "rest", "master", "std", "out", "dist", "temp", "source", "member", "test", "output", "cat", "exp", "dat", "origin", "bin", "result", "them", "usr", "nt", "nom", "target", "sum", "comp", "pipe", "ptr", "transfer", "des", "foreign", "loc", "comb", "est", "crit"]}}
{"id1": "19868933", "id2": "11933797", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingNHIE", "copyFromFileToFileUsingRIO", "copyFromFileToFileUsingNFile", "copyFromFileToFileusingRFile", "copyFromFileToFileusingRIF", "copyFromFileToFileUsingNHIF", "copyFromFileToFileusingNIE", "copyFromFileToFileUsingRIF", "copyFromFileToFileusingRIO", "copyFromFileToFileusingNIF", "copyFromFileToFileUsingMIO", "copyFromFileToFileUsingRIE", "copyFromFileToFileUsingNHFile", "copyFromFileToFileusingNIO", "copyFromFileToFileusingNFile", "copyFromFileToFileusingRIE", "copyFromFileToFileUsingRFile", "copyFromFileToFileUsingNHIO", "copyFromFileToFileUsingMIF", "copyFromFileToFileUsingNIF", "copyFromFileToFileUsingMFile", "copyFromFileToFileUsingMIE", "copyFromFileToFileUsingNIE"], "inputFile": ["outputPage", "loadfile", "importFile", " inputPage", "inputPath", " inputPath", " inputLe", "openPath", " inputfile", "openFile", "loadLe", "importByte", " inputByte", "openLe", "openfile", " inputStream", "loadFile", "importPage", "inputPage", "loadPath", "outputByte", "outputStream", "inputfile", "inputByte", "inputStream", "importStream", "inputLe"], "outputFile": [" outputFiles", " outputPlace", "resultFile", " outputfile", "outputFiles", "toFiles", "toStream", "resultFiles", "putFile", "putDir", "outputDir", "putfile", "outputfile", "resultPlace", " outputDir", "inputDirectory", "resultStream", "outputStream", "putDirectory", "inputfile", "inputDir", "toFile", "outputPlace", "outputDirectory", "toPlace", " outputDirectory", " outputStream"], "inputChannel": ["openConnection", "inputChuck", " inputchannel", "rawChan", " inputCategory", "openChan", "inputChan", "rawFile", "loadChannel", " inputConnection", "InputChannel", " inputScope", " inputListener", "tableChannel", "httpChan", "loadChuck", "outputConnection", "httpFile", "inputConnection", "inputManager", "inputchannel", "inputBuffer", " inputManager", "internalListener", "tableScope", "rawConnection", "outputChan", " inputBuffer", "tableBlock", "internalChannel", "InputConnection", "inputListener", "importManager", " inputStream", " inputChan", "loadCategory", " inputBlock", "loadManager", "InputBuffer", "httpChannel", "tableListener", "importChuck", "outputBuffer", "outputStream", "inputBlock", "inputCategory", "openChannel", "httpConnection", "outputchannel", "importCategory", "InputStream", "inputScope", "internalBlock", " inputChuck", "importChannel", "rawChannel", "inputStream", "openchannel", "internalScope"], "outputChannel": ["outputButton", "displaychannel", "languageChannel", "publicCow", "putChan", "consolechannel", "removeChannel", "consoleFile", "removechannel", "consoleCow", "putButton", "consoleStream", "consoleChannel", "hiddenCamera", "putChannel", "displayChannel", "OutputStream", "OutputChannel", "languageClient", " outputButton", "languageCategory", "publicchannel", " outputchannel", "displayCategory", " outputCategory", "displayClient", " outputChan", "outputChan", "outputClient", "hiddenChannel", "outputCamera", "hiddenChan", "removeCow", "publicChannel", "OutputFile", "hiddenButton", "outputCategory", "outputStream", "languagechannel", " outputCamera", " outputClient", "outputCow", "outputchannel", "putCamera", "OutputChan", "consoleChan", " outputStream"]}}
{"id1": "6171406", "id2": "11933797", "code1": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"createTar": ["CreateHar", " createtar", "createHar", "setupHar", "createDir", "setupTar", "setupDir", " createDir", "createtar", " createHar", "Createtar", "setuptar", "CreateTar", "CreateDir"], "directoryToPack": ["DirectoryToPush", "directory2Package", " directory2Package", "directoryFromPack", " directory2pack", "directoryFromApply", "directorytoPush", " directoryToPackage", "directionTOPak", "directionToLoad", "directoryTopack", "directoryToPackage", "directoryToApply", "directoryFromPlan", " directoryToPak", " directoryOfpack", "directoryToPak", "directoryTOPush", "directionTOPackage", " directoryTopack", "documentToPackage", "directorytoPack", "directorytoLoad", "directoryTOApply", " directorytopack", "directoryOfPack", " directorytoPack", "directorytopack", "DirectorytoPak", "DirectoryToPack", "directoryToLoad", " directoryOfPak", "DirectorytoPush", " directorytoPackage", "directorytoPak", " directory2Pack", "directoryOfPak", "directoryFromPak", "directionTOPlan", "directoryOfpack", "directoryFromLoad", "DirectoryToPak", "directorytoPackage", "directoryAsPack", "directory2Pak", "directorytoApply", "directoryTOPak", "directoryAsPackage", "DirectorytoPack", "directory2pack", "directoryTOLoad", "directoryTOPack", "documentToPack", "directionToApply", "directoryFrompack", "directionToPackage", "directionTOApply", "DirectoryToPackage", "directionTOLoad", "directoryToPush", "directionToPak", "directoryOfPackage", "directoryFromPackage", "DirectorytoPackage", "directory2Pack", " directoryOfPack", "directoryTOPlan", "directionToPack", "directionTOPack", "directory2Plan", " directorytoPak", "directionToPlan", "directoryToPlan", "directoryTOPackage"], "targetTarFile": ["argetEarFile", "targetJarFormat", "targetEarFiles", "targetArchFilename", "targetARFilename", "targetTarEntry", "targetJarFile", "targetArchPath", "TargetTarFile", "targetArchFiles", "targetEarFormat", "argetEarFilename", "targetTarField", " targetEarFilename", "TargetTarField", "targetAREntry", " targetEarFiles", "targetEarfile", "targetTarFormat", "targetJarResource", "targetARFiles", "targetJarPath", "targetARFile", "targetJarFilename", "targetEarFile", "targetCarfile", " targetTarFiles", "targetArchFile", "TargetARField", "targetTarFiles", " targetEarLine", "targetTarString", "targetCarFile", "targetEarField", "argetTarFile", "targetJarFiles", " targetTarFilename", "targetCarFilename", "argetTarFilename", "targetTarPath", "targetEarFilename", "targetARPath", "argetTarResource", " targetTarfile", "targetARField", "targetEarLine", "TargetTarfile", "targetEarString", "TargetARFile", "targettarFile", "targetCarResource", "targetARfile", "TargetTarEntry", "targetWarEntry", "targetARLine", "targetARFormat", " targetEarFile", "targetWarField", "targettarString", "targetTarResource", "targetTarFilename", "targetWarFile", " targetTarFormat", "targetTarfile", " targetEarFormat", "targetCarLine", "targetJarfile", "argetEarString", "argetEarfile", "TargetARfile", "argetTarfile", "targetWarfile", " targetTarLine", "targetEarEntry", " targetTarPath", "argetTarString", " targetEarfile", "targetTarLine", "targettarFilename", "targettarfile", "TargetAREntry"], "buffer": ["memory", "binary", "buff", "length", "table", "variable", "object", "batch", "stream", "block", "Buffer", "message", "map", "limit", "print", "flag", "pointer", "cache", "buf", "string", "char", "comment", "header", "entry", "type", "attribute"], "targetOutput": ["TargetPUT", "sourceInput", "gtOutput", "argetTarget", "gtInput", " targetInput", " targetoutput", "TargetTarget", "sourceoutput", " targetPUT", "TargetOutput", "targetoutput", "sourceOutput", "argetOutput", "sourceTarget", "gtPUT", "targetPUT", "argetInput", "targetInput", "Targetoutput", "targetTarget", "TargetInput", "argetoutput", "gtoutput"], "targetOutputTar": ["argetOutputHar", "targetConnectionJar", "argetOutputtar", "targetInputJar", "argetCreatedTar", "targetCreatedJar", "targetCreatedtar", "targetInputHar", " targetOutputJar", "targetCreatedTar", "targetOutputHar", "argetCreatedtar", "targetTargettar", "targetCreatedHar", "argetOutputTar", "targetConnectiontar", " targetTargettar", "targetTargetJar", "targetInputtar", "targetInputTar", "argetCreatedJar", "targetOutputtar", "targetConnectionTar", " targetTargetJar", " targetOutputtar", "targetOutputJar", "argetOutputJar", "targetTargetTar", " targetTargetTar", "argetCreatedHar"], "fileList": ["Filelist", " filelist", "fileSet", "byteLIST", "filelist", "byteSet", "fieldlist", " fileStream", " fileLIST", "FileLIST", "byteList", "FileStream", "bytelist", "fileLIST", "fieldList", "FileList", "fileStream", "fieldSet", " fileSet", "FileSet", "fieldStream"], "iter": ["oper", "fer", "train", "other", "exec", "coll", "ner", "ver", "it", "valid", "ser", "ind", "iterator", "list", "writer", "er", "Iter", "reader", "gener", "loader", "ait", "cer", "ip", "former", "init", "inter", "itter", "inner", "iv", "tr", "outer", "ger", "walker", "i", "li", "ter", "iner", "actor", "loop", "vis", "chain", "loc", "liter", "ipper", "ator", "ir"], "file": ["info", "fer", "http", "archive", "version", "e", "issue", "port", "library", "log", "f", "number", "ory", "node", "user", "word", "fil", "hash", "model", "chain", "channel", "filename", "legal", "attribute", "full", "icle", "ile", "FILE", "table", "old", "il", "path", "line", "error", "unit", "to", "print", "feature", "source", "location", "entity", "template", "fold", "class", "header", "job", "key", "dir", "record", "link", "document", "check", "store", "use", "directory", "element", "fl", "folder", "date", "application", "string", "current", "db", "format", "remote", "true", "item", "module", "File", "null", "run", "rule", "object", "h", "url", "base", "stream", "value", "files", "valid", "fe", "name", "message", "p", "image", "resource", "group", "running", "ple", "single", "output", "local", "language", "page", "tree", "title", "core", "le", "comment", "data", "entry", "field", "type", "time", "handle", "event"], "filePathInTar": ["filepathINHar", "filePathInTr", "filePathINTar", "filePathINHar", "filepathintar", "filePathINEar", "filepathinTar", "fileLocationINTar", "filePathInsideTar", "filePathInHar", "fileLocationInEar", "filePathInsideWar", "filePathIntar", "filePathedIntar", "filePathOutTar", "filePathedInWar", "filepathIntar", "filepathinWar", "filePathInsideHar", "filePathInWar", "filepathInWar", "fileLocationINtar", "filePathInEar", "fileLocationINEar", "filePathedInHar", "fileLocationInTar", "fileLocationINTr", "filepathInTar", "filePathintar", "filepathInHar", "filePathinTr", "filePathinEar", "filepathINTar", "filePathOuttar", "filePathinWar", "filePathINTr", "filePathFromtar", "filePathFromTar", "filepathINWar", "filePathinTar", "filePathINtar", "filePathOutWar", "fileLocationIntar", "fileLocationInTr", "filePathFromTr", "filePathedInTar", "filePathINWar", "filePathFromEar"], "tarAdd": ["starNew", "TarCreate", "TarEntry", "tarNew", " tarMake", "cotInstall", "starAdd", "canNew", "trEntry", "taradd", "starCreate", "cotNew", "rarInstall", "staradd", "tarMake", "TarAdd", "rarAdd", "rarCreate", "tarCreate", " tarCreate", " taradd", "carNew", "trCreate", "carCreate", " tarNew", "trMake", "canAdd", "rarNew", "cotCreate", " tarEntry", "canadd", "trAdd", "carAdd", "TarMake", "tarEntry", "carInstall", "cotAdd", "canCreate", "tarInstall"], "in": ["join", "t", "nin", "un", "a", "get", "it", "on", "add", "ed", "id", "name", "this", "ins", "to", "by", "with", "ing", "sub", "out", "source", "n", "IN", "local", "an", "from", "start", "en", "within", "inner", "input", "current", "ign", "sin", "inside", "at", "into", "gen", "is", "In", "under"]}}
{"id1": "16232202", "id2": "9371421", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"doPost": ["doAdd", " doAdd", "handlepost", " doPOST", "handlePost", "DoAdd", "handleAdd", "DoPOST", " dopost", "DoPost", "handlePOST", "dopost", "doPOST", "Dopost"], "request": ["QUEST", "http", "get", "register", "require", "version", "quest", "worker", "address", "context", "claim", "user", "input", "subject", "attribute", "runtime", "raw", "client", "the", "post", "report", "print", "begin", "select", "order", "complete", "template", "query", "session", "law", "web", "remove", "xml", "requ", "view", "Request", "open", "command", "result", "record", "re", "have", "setup", "document", "condition", "media", "list", "connection", "directory", "call", "application", "controller", "pe", "work", "current", "position", "server", "first", "initial", "remote", "collection", "process", "forward", "url", "reference", "environment", "message", "reset", "req", "ire", "local", "create", "frame", "handle", "browser"], "response": ["answer", "re", "detail", "send", "http", "exit", "resp", "document", "security", "object", "onse", "e", "version", "esi", "settings", "environment", "message", "connection", "image", "sequence", "summary", "social", "report", "print", "ve", "service", "out", "respond", "application", "res", "console", "site", "video", "output", "profile", "location", "page", "reply", "position", "continue", "network", "Response", "render", "server", "next", "session", "description", "header", "view", "entry", "status", "event", "shell"], "cu": ["cn", "cro", "u", "ci", "tc", "ur", "cy", "umi", "cul", "UD", "CU", "c", "mu", "gu", "uci", "us", "ut", "util", "du", "pu", "chu", "lc", "lu", "su", "au", "ui", "ucc", "cp", "Cu", "bo", "angu", "hu", "uu", "uc", "ocr", "um", "yu", "uo", "tu", "nu", "ru", "aco", "ju", "unc", "ub", "U", "ctx", "ua", "cci", "gru", "ck", "cpu", "ou", "cum", "aus", "cm", "eu", "co", "hua", "cgi", "ue", "zu", "cus"], "ud": ["uda", "gd", "u", "ci", "ur", "ad", "UD", "htt", "pd", "gu", "ld", "us", "mud", "ut", "util", "du", "dk", " du", "uh", "su", "di", "ost", "udi", "ui", "cus", "aud", "edu", "urd", "ow", "od", "ku", "uu", "bd", "uc", "udo", "um", "eus", "gb", "ord", "tu", "ub", "unc", "uid", "zu", "unt", "rod", "td", "ck", "und", "udd", "oud", "uds", "aus", "hd", "eu", "dl", "vd", "dd", "d"], "returnTo": ["addTo", "ReturnTo", "renderTO", "returnTarget", "returnTO", "urnto", "urnTO", "addTarget", "addTO", "return2", "ReturnTO", "renderto", "urnTarget", "endto", "Returnto", "endTo", "urn2", "endTO", "renderTo", "urnTo", "Return2", "addto", "endTarget", "returnto", "render2"], "password": ["paste", "secret", "email", "phrase", "ssh", "Password", "crypt", "security", "default", "definition", "username", "prefix", "message", "sword", "login", "reset", "trust", "remember", "padding", "user", "profile", "auth", "pty", "pattern", "push", "token", "word", "database", "pool", "PASS", "description", "hello", "wd", "command", "shadow", "attribute"], "md": ["mod", "m", "ms", "det", "pd", "df", "mac", "amd", "ld", " MD", "mk", "dh", "mc", "nd", "MD", "cd", "mn", "mt", "od", "bd", "mb", "sm", "magic", "sd", "mg", "cmd", "dm", "mm", "td", "Cmd", "pdf", "der", "hd", " Md", "msg", "grad", "and", "dd", "d"], "hash": ["hex", "shift", "mac", "where", "rand", "h", "oh", "has", "raw", "ash", "flash", "check", "sh", "dig", "rh", "height", "str", "test", "ashes", "init", "result", "char", "tr", "sha", "Hash", "hed", "sum", "hd", "html", "her", "bytes", "data", "len", "key", "handle", "shadow", "ho"], "pass": ["secret", "pos", "zip", "ack", "read", "Pass", "pp", "pkg", "default", "prop", "add", "pg", "pas", "ps", " def", "conn", "mask", "test", "cat", "pack", "step", "act", "alias", "def", "push", "conf", "priv", "ph", "session", "tag", "ass", "pool", "PASS", "task", "fail", "ask", "wd", "handle", "auth"], "vis": ["info", "mod", "ha", "nav", "VIS", "gu", "cap", "val", "study", "key", "iz", "circ", "ver", "mit", "cond", "v", "vid", "rav", "var", "hidden", "str", "see", "vert", "visible", "stat", "tri", "att", "state", "feat", "cfg", "def", "virt", "comm", "miss", "priv", "display", "inv", "access", "pres", "wa", "vol", "is", "type", "view", "san", "serv", "Vis", "label", "act", "status"]}}
{"id1": "23402240", "id2": "237493", "code1": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"actualizarNdivisiones": [" actualizarNdivisione", " actualizarMdivisionas", " actualizarMisionas", " actualizarMisioners", " actualizarNisionas", " actualizarMdivisione", " actualizarNdivisionas", " actualizarNumentas", " actualizarMdivisioners", " actualizarNumenters", " actualizarNisiones", " actualizarNdivisioners", " actualizarNdome", " actualizarNdomas", " actualizarNumentes", " actualizarMisiones", " actualizarMdivisiones", " actualizarNisioners", " actualizarNumente", " actualizarNisione", " actualizarNdomers", " actualizarNdomes", " actualizarMisione"], "idTorneo": ["idMorneo", "idTaleos", "idTrone", "idTaneO", "idTornos", "idTalepo", "idMornos", "idLTorneO", "idTornee", "idTorneos", "idMornepo", "idMorne", "idTronpo", "idTorneon", "idToralO", "idTeroO", "idTornpo", "idTrono", "idTorne", "idMornee", "idMorno", "idTorali", "idLTorneon", "idTaleo", "idTaneon", "idToralon", "idLTorneo", "idLTanei", "idTornepo", "idTorno", "idLTaneo", "idTalee", "idTaneo", "idTronos", "idTorneO", "idMorneos", "idTeroon", "idTornei", "idLTaneon", "idLTaneO", "idTeroo", "idLTornei", "idMornpo", "idToralo", "idTeroi", "idTanei"], "nDivisiones": ["ndivionales", "nDivitione", "nDecionales", "nDivisione", "nDivitionales", "nDecisionals", "nDivisionals", "ndivions", "nDivitionals", "ndivione", "nDiviones", "nDivitiones", "nDivione", "nDivisionse", "nDividees", "ndivisione", "nDivionales", "nDivisionales", "nDivisionss", "nDecionals", "nDivides", "nDivisionsales", "nDecisiones", "nDeciones", "ndivisionales", "nDivisionses", "nDividee", "ndivisions", "nDivionals", "nDecione", "nDivions", "ndiviones", "nDecisionales", "nDivisions", "nDivideals", "ndivisiones", "nDecisione", "nDivideales"], "intResult": [" intRes", "IntResults", "interResult", "IntResult", "intValue", "IntReturn", "strResults", "interReturn", "strValue", "INTReturn", "INTresult", "IntRes", " intResults", "uintReturn", "floatresult", "intResults", "intresult", " intReturn", "interRes", " intValue", "floatResult", "uintResults", "floatResults", "INTResults", "uintResult", "INTResult", "intRes", "intReturn", "strReturn", " intresult", "floatReturn", "uintValue", "strResult", "interResults"], "sql": ["scl", "params", "fn", "expression", "table", "pp", "sel", "qs", "url", "ls", "pel", "sq", "sp", "s", "spec", "login", "log", "seed", "nl", "spr", "q", "sol", "select", "sv", "ln", "cmd", "csv", "sb", "sn", "string", "template", "SQL", "query", "json", "inv", "mail", "db", "xml", "description", "dl", "status", "ql"], "connection": ["nc", "computer", "creator", "po", "link", "table", "handler", "close", "c", "document", "ion", "engine", " Connection", "statement", "reference", "condition", "socket", "system", "Connection", "client", "port", "directory", "bo", "to", "writer", "context", "resource", "pointer", "conn", "number", "connected", "created", "application", "function", "no", "user", "location", "page", "con", "position", "current", "network", "server", "database", "relation", "session", "communication", "db", "pool", "connect", "description", "platform", "subject", "response", "channel", "open", "command", "collection"], "ps": ["processor", "pos", "pps", "eps", "po", "aps", "pd", "pp", "fp", "Ps", "statement", "PS", "tp", "ips", "pg", "sp", "cp", "cs", "p", "pn", "ts", "s", "ping", "mt", "pb", "proc", "gs", "prep", "pers", "res", "pe", "rs", "pt", "ds", "ports", "jp", "pse", "pr", "ptr", "posts", "stats", "mp", "fps", "gres"]}}
{"id1": "4686922", "id2": "13657103", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResources2Files", "extractResourceTofile", "extractResourceAsStream", "extractResourceFromFile", "extractResourceFromFiles", "extractResourceToFiles", "extractResource2Files", "extractResource2Stream", "extractResourceAsFiles", "extractResourceFromfile", "extractResources2File", "extractResourceToStream", "extractResources2Stream", "extractResourcesToFile", "extractResource2File", "extractResourcesToFiles", "extractResourcesToStream", "extractResourceAsFile", "extractResourceFromStream", "extractResources2file", "extractResource2file", "extractResourceAsfile", "extractResourcesTofile"], "resourcePath": ["templateIn", "attributePath", " resourcepath", "templateName", "templatePath", " resourceIn", "uriUrl", "resourceName", "resourceLocation", "Resourcepath", "attributeLocation", "ResourceIn", "ResourcePath", "uriPath", "attributeUrl", "ResourceName", "uriName", "resourcepath", "templatepath", "resourceUrl", "attributeName", "uriLocation", "resourceIn", "ResourceLocation", "ResourceUrl", " resourceName"], "dest": ["src", "null", "orig", "w", "Dest", "opt", "cont", "end", "desc", "trans", "mem", "parent", "home", "sp", "decl", "coord", "this", "rest", "to", "temp", "dist", "source", "output", "good", "cat", "gov", "etc", "origin", "dat", "img", "tmp", "target", "nom", "lit", "des", "loc", "self", "comb", "prop", "result", "dir"], "in": ["gin", "m", "re", " din", "mc", "mi", "up", "cin", "it", "on", "raw", "or", "none", "ini", "inf", "inn", "ind", "id", "resource", "ins", "l", "rin", "f", "r", "inc", "al", "source", "ln", "no", "IN", "from", "iter", "local", "init", "isin", "bin", "inner", "all", "con", "input", "conf", "sin", "din", "i", "inside", "file", "is", "ne", "In"], "out": ["os", "cn", "null", "t", "note", "w", "exit", "b", "ot", "ch", "o", "aos", "na", "it", "on", "client", "v", "writer", "can", "obj", "to", "outs", "print", "f", "io", "stable", "cache", "write", "n", "res", "no", "output", "Out", "en", "inner", "con", "again", "nt", "conv", "tmp", "outer", "ou", "oss", "i", "at", "sys", "pool", " Out", "OUT", "co", "ne", "cos", "col", "net"]}}
{"id1": "10218878", "id2": "10690321", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "label": 0, "substitutes": {"DecodeMapFile": ["DecvertMapFile", "DecodeToLog", "DecodeTofile", "DecvertMapLog", "DecodeFromFiles", "DecvertMAPfile", "DecvertMAPFile", "DecodeFromFile", "DecodeToFiles", "DecvertMapFiles", "DecodeMapFiles", "DecodeFromfile", "DecodeToFile", "DecodeMapfile", "DecodeMAPFile", "DecodeMAPfile", "DecodeMAPLog", "DecvertMapfile", "DecodeMAPFiles", "DecodeMapLog", "DecvertMAPFiles", "DecodeFromLog", "DecvertMAPLog"], "mapFile": [" mapPath", "imagefile", "imageFilename", "imageStream", " mapFILE", "mapfile", "MapStream", "listFILE", "mapStream", " mapStream", "cacheFILE", "imageFile", "MapFilename", " mapfile", "mapPath", "listFile", "cacheFile", "cachePath", "Mapfile", "MapFile", " mapFilename", "mapFILE", "mapFilename", "listPath"], "outputFile": ["inputName", "writeName", "outputPath", " outputPath", "outFile", "writeStream", "outFilename", "mapStream", " outputFilename", "writeDir", "outputName", "outputDir", "OutputPath", "inputFile", "outPath", "OutputFile", " outputDir", "mapDir", "OutputFilename", "OutputDir", "writeFile", "outputStream", "mapName", "inputDir", "outputFilename", "outDir", "inputStream"], "magicKey": ["anticField", "MagicKey", "prefixKey", "magicCounter", " magicId", " magicName", "magicField", " magicChar", " magicCode", "prefixCounter", "prefixValue", " magicKEY", "serialKey", "magicId", "anticKey", "prefixCode", "MagicKEY", " magicValue", "antickey", " magicField", "uniqueKey", "magicChar", "encryptedkey", "magicName", "magicValue", "encryptedKey", "uniqueValue", "magicKEY", "uniqueCounter", "serialName", "encryptedChar", " magicCounter", "uniqueCode", "magickey", "MagicName", "anticChar", "encryptedField", " magickey", "MagicId", "serialId", "magicCode", "serialKEY"], "buffer": ["paste", "memory", "row", "detail", "phrase", "binary", "buff", "length", "table", "sample", "total", "variable", "document", "batch", "base", "stream", "pad", "block", "mem", "Buffer", "vector", "flash", "check", "history", "filter", "message", "black", "sequence", "bo", "print", "attribute", "cache", "queue", "window", "buf", "code", "iter", "stroke", "page", "template", "screen", "char", "bridge", "index", "database", "sum", "program", "frame", "header", "initial", "button", "display", "bone", "command", "stack", "shape", "append"], "nread": ["Nreadable", "maxRead", "ncreadable", "nREAD", "Nread", "NRead", "maxget", " ntry", "rawread", " nreadable", "renwrite", " nRead", "nRead", "renread", "rawtry", "nget", "maxread", "ncadd", "rnread", "rnREAD", "nwrite", "nreader", "rnRead", " nREAD", "ncwrite", "Nadd", "ntry", "rentry", " nwrite", "renreader", "rawreader", "rnwrite", "nreadable", "rawwrite", " nreader", "Nget", "ncRead", "ncget", "maxadd", "ncread", "nadd", "Nwrite", "NREAD"], "map": ["make", "ace", "memory", "m", "mod", "pl", "module", "parse", "per", "aps", "read", "table", "where", "open", "batch", "up", "block", "mem", "ml", "apping", "address", "image", "collect", "mate", "master", "mt", "op", "ape", "cache", "mask", "MAP", "window", "down", "mount", "set", "ip", "pack", "pose", "maps", "apper", "con", "app", "place", "meta", "bridge", "com", "man", "manager", "config", "cm", "form", "file", "view", "lock", "co", "clear", "mp", "ap", "load", "shape"], "output": ["exit", "other", "update", "object", "o", "open", "Output", "batch", "stream", "secure", "block", "four", "socket", "oe", "plain", "icon", "client", "port", "can", "log", "print", "hidden", "write", "put", "out", "cache", "blue", "queue", "console", "entity", "input", "current", "network", "outer", "target", "next", "ou", "web", "latest", "auto", "ilo", "file", "online", "response", "format", "display", "result", "net"], "i": ["ji", "m", "ms", "ci", "u", "t", "spin", "phi", "b", "ii", "j", "gi", "qi", "gu", "I", "span", "us", "mi", "ti", "batch", "pi", "it", "di", "ini", "ui", "ind", "id", "y", "v", "multi", "ic", "uri", "ai", "ish", "q", "x", "n", "g", "iu", "ni", "bi", "ip", "cli", "si", "ie", "ri", "index", "sim", "li", "ix", "xi", "ami", "is", "fi", "ei"]}}
{"id1": "14783950", "id2": "21656668", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithoutzip", "composeWithZip", "composeWithoutExt", "compressWithFiles", "composeWithExt", "composeWithoutzip", "compressWithoutFiles", "compressWithoutExt", "composeWithoutFiles", "compressWithExt", "composeWithoutZip", "compressWithoutZip", "compresswithzip", "compressByExt", "composeWithzip", "compressWithzip", "compressByzip", "compresswithExt", "compressByFiles", "composeWithFiles", "compresswithFiles", "compresswithZip", "compressByZip"], "fileList": ["wordIterator", " fileCode", " FileLIST", "ileList", "ilelist", " filelist", "fileSet", " fileIterator", " fileNames", "filelist", "wordSet", "fileLock", " fileLock", " fileLIST", " FileSet", " fileL", "fileIterator", "pageCode", "fileL", "ileLIST", "pagelist", "tileIterator", "pageList", "fileLIST", "wordLIST", "tileSet", "pageLIST", "tileList", "fileNames", "pageL", "resourceNames", "fileCode", " FileCode", " fileSet", "itemLock", "resourceLock", "itemList", "itemNames", "wordList", "ileL", "tileLIST", "pageSet", "resourceList", " FileList"], "zipFileName": ["zFilenamename", "zipFileFilename", "zipFilenameNames", "zipileName", " zipfileName", " zipfilePath", "zFilenameName", " zipfileNames", "zipDirFilename", "zFileName", "zipfileNames", "zFileFilename", "zipileFilename", "zipDirNames", " zipFileNames", "zipFilenameName", "zipFilenamename", "zipfilePath", "zipfileFilename", "zipDirName", "zipilename", " zipFilePath", "zipFilename", " zipFileFilename", "zFilename", "zFilenamePath", "zipDirPath", "zipfilename", " zipfileFilename", "zipilePath", "zFilePath", "zFilenameFilename", "zipFilePath", "zipFileNames", "zipFilenamePath", "zipFilenameFilename", "zipfileName"], "fos": ["wOS", "lOS", "Fos", "lfoos", "fOS", "flis", "Foos", "flos", "wos", "loss", "woss", "Foss", "flOS", "lfos", "los", "loos", " fOS", "lfOS", "floos", " foos", "foss", "lfis", "woos", "foos", "FOS"], "zos": ["zan", "zen", "os", "sis", "less", "zin", "zh", "z", "zip", "hz", "zag", "zero", "Sax", "eros", "ws", "iners", "bes", "css", "cz", "ss", "ossus", "ps", "es", "zi", "zik", "ze", "zo", "zon", "enos", "ses", "nz", "js", "zers", "los", "iaz", "rys", "ez", "zb", "sbm", "hess", "za", "jas", "zzle", "zes", "oss", "han", "ippers", "rez", "zar", "ess", "enz", "zer", "webkit", "zu"], "iter": ["oper", "re", "train", "fer", "ee", "where", "coll", "ner", "Iterator", "ver", "izer", "it", "its", "maker", "ser", "valid", "iterator", "list", "er", "Iter", "reader", "here", "iver", "gener", "loader", "ait", "order", "user", "cer", "ip", "former", "exp", "kit", "inter", "inner", "iv", "tr", "outer", "ger", "orient", "walker", "i", "ptr", "li", "ter", "iner", "loop", "vis", "el", "is", "loc", "liter", "ipper", "ator", "ir"], "fileName": ["fNames", " fileNumber", "ileString", "localName", "ilename", " filename", "localNAME", "ileList", "fileCurrent", "ileCurrent", "FileString", " fileNames", "fileSet", "fileSource", "fileBody", "fieldname", "localList", "fSource", "fileNAME", "ileNumber", " filePath", "ileSet", "fNumber", "tableName", " fileCurrent", "ileBody", "tableSet", "FileCurrent", " fileString", "ilePath", "fileStore", "fileNumber", "tablePath", "getSource", "localname", "fieldName", "shortStore", "fieldList", "FilePath", "FileNames", "fileNames", "fieldNAME", " fileStore", "getStore", "fString", "ileSource", "fBody", "FileName", " fileSet", "shortname", " fileSource", "getName", "fname", "getname", "filePath", "shortSource", "Filename", "fName", "ileNAME", "ileName", "filename", " fileBody", "fileString"], "ind": ["pl", "mod", "dial", "inder", "pos", "med", "j", "ld", "nd", "wind", "count", "mind", "cond", "inn", "cd", "md", "Ind", "seed", "req", "cod", "inc", "hend", "cand", "stick", "n", "bind", "sign", "find", "att", "td", "typ", "roll", "dj", "kind", "num", "index", "div", "IND", "i", "ded", "ptr", "draw", "red", "loc", "butt", "ent", "pred", "d"], "shortName": ["fullname", "shortString", "smallFilename", "recentName", "ShortKey", "smallCode", " shortString", " shortKey", "quickKey", " shortname", "ShortName", "ShortCode", "smallName", "fullString", " shortType", "shortType", "quickName", "fullName", "ShortFilename", "shortFilename", "shortCode", "fullType", "ShortType", "quickname", "quickString", "recentname", "shortKey", "smallname", "shortname", "recentFilename", "ShortString", "recentCode", "Shortname"], "fis": ["ufois", "hris", "ufris", "cfis", "sfis", "sfIs", "pi", "wi", "fIs", "cfris", "Fris", "his", "hi", "FIs", "wIs", " fris", "cfois", "pis", "ufi", "cfi", "wois", "ufIs", "sfi", "wis", "sfois", "fois", "hois", "ufis", "Fis", "fi", "pris", "fris", "pois", " fIs"], "buf": ["bar", "wb", "orig", "buff", "b", "cap", "mu", "pkg", "ref", "batch", "block", "mem", "Buffer", "vec", "fb", "buffer", "uf", "tab", "var", "temp", "cur", "Buff", "seq", "aka", "cmd", "bl", "cat", "bag", "bin", "rb", "img", "tr", "fam", "br", "conv", "bed", "db", "cb", "cv", "bytes", "box", "msg", "fg", "bus", "bc", "arr"], "bytesRead": ["bytesNeed", "usersRead", "flowsFind", "flowsRead", "blocksRead", "postsFind", "bytesReady", " bytesLength", "usersLoad", "usersFind", "bytesWritten", "BytesLength", "flowsLoad", "linesRead", " bytesLoad", "flowsReady", "secondsWritten", "bytesFind", "blocksWritten", "BytesRead", "bytesLoad", "secondsLoad", "secondsWrite", "usersReady", "blocksWrite", " bytesWrite", "BytesNeed", "linesLength", "postsRead", "linesWritten", "blocksLoad", "secondsRead", "bytesLength", " bytesNeed", "postsLoad", " bytesWritten", "linesNeed", "BytesWritten", "bytesWrite", "postsReady"]}}
{"id1": "12128591", "id2": "22752444", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"hash": [" Hash", "hex", " address", "update", "dump", " fingerprint", " text", "h", " key", "id", "print", " body", " salt", " hashing", " h", " check", "code", " sum", " mac", " code", "Hash", " id", " message", " signature", " equals", " version"], "data": ["info", "what", "secret", "ata", "table", "mu", "DATA", "any", "a", "batch", "raw", "block", "value", "message", "buffer", "image", "sequence", "this", "password", "content", "out", "padding", "action", "window", "rel", "output", "dat", "string", "input", "json", "html", "bytes", "hello", "text", "command", "result", "accept"], "digest": ["digse", " digave", "mailgest", "deist", "digave", "deest", "Digse", "Digested", "redest", "initest", "redester", " digist", "digested", "mdest", "mailest", "displayested", "digester", "mdgest", "mailester", "digests", "equave", "deested", "equit", "mdests", "Digests", "initEST", "initested", "displayse", "mdit", "redgest", "initester", "mdested", "DigEST", "digly", " digit", "redly", "mdave", "Digist", " digested", "diggest", " digse", "mdse", "displayest", "displayests", "equest", "dese", " digEST", "digist", "mdester", "mailly", "Digest", "Digester", "mdly", "digEST", "equse", " digester", "digit"]}}
{"id1": "20623709", "id2": "14878593", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"split": ["join", "process", "upload", "parse", "read", "disk", "align", "Split", "batch", "part", "count", "scale", "use", "unit", "map", "sync", "write", "scan", "copy", "share", "seek", "slice", "transfer", "lock", "format", "open", "append"], "targetDirectory": ["targetDir", "localFile", "targetMemory", "baseMemory", "Targetdirectory", " targetLocation", "testLocation", " targetDirect", "baseDirect", " targetdirectory", "baseDir", "targetFolder", "testDirectory", " targetFolder", " targetDir", " targetMemory", "TargetDir", "baseDirectory", "baseFolder", "localDir", "targetdirectory", "basedirectory", "TargetDirectory", "TargetFolder", "TargetDirect", "TargetMemory", "targetDirect", "localDirectory", "baseFile", "targetLocation", "targetFile", "testDir", " targetFile", "localdirectory", "testDirect", "TargetLocation"], "prefix": ["PRE", "pkg", "zero", "path", "base", "username", "pi", "version", "fix", "name", "this", "p", "directory", "password", "uri", "FIX", "padding", "pre", " suffix", "title", "pattern", "fixed", "template", "alias", "Pref", "root", "index", "fixes", "tag", "ix", "pres", "localhost", "division", "size", "type", "format", "key", "filename", "status", "command"], "maxUnitBases": ["maxUnitLicas", "maxUnitbases", "maxUnityAliases", "maxUnitLounds", "maxUnitAliias", "maxUnitReplases", "maxUnitChades", "maxUnityLounds", "maxUnitReplicas", "maxUnitChias", "maxUnityAliades", "maxUnitReplounds", "maxUnitChicas", "maxUnityAliounds", "maxUnitChases", "maxUnitbias", "maxUnitbades", "maxUnitAliades", "maxUnityLases", "maxUnityLicas", "maxUnitReplages", "maxUnityBounds", "maxUnitbounds", "maxUnityBades", "maxUnitBages", "maxUnitLases", "maxUnitBounds", "maxUnitBades", "maxUnityBicas", "maxUnityLages", "maxUnitLages", "maxUnityBias", "maxUnityAliias", "maxUnitBicas", "maxUnitChages", "maxUnitBias", "maxUnityBages", "maxUnitAliounds", "maxUnityBases", "maxUnitChounds", "maxUnitAliases"], "maxUnitEntries": ["maxUnitErries", "maxUnitEntriers", "maxUnitentires", "maxUnitIntegires", "maxUnityEntries", "maxUnitIntegries", "maxUnityEntrs", "maxUnitentrs", "maxUnitErrys", "maxUnityEntires", "maxunitEntrys", "maxUnityentries", "maxUnityentrs", "maxUnitentries", "maxUnitEntrys", "maxUnitEntryires", "maxUnitEntryriers", "maxUnitEntrs", "maxUnitErrs", "maxUnitIntegriers", "maxUnitEntryrys", "maxunitEntries", "maxUnityentrys", "maxUnitIntegrys", "maxunitEntrs", "maxunitEntires", "maxUnitentrys", "maxUnitEntires", "maxUnitErires", "maxUnityEntrys", "maxUnitEntryries", "maxUnityentires"], "fis": ["ific", "Fii", "viss", "fic", " fii", "ifii", " fic", "fiss", "vi", "Fi", "Fic", " fiss", "fii", "Fiss", "ifis", "Fci", "vis", "ifci", "Fis", "fi", "vic", " fi"], "fci": ["fico", "cfis", " fai", "mco", "cfai", "Fini", "mcu", "fai", "fic", "tci", "Fco", "Fai", " fii", "cfco", " fico", "mci", " fic", "cfic", "tii", " fcu", "fini", "tcu", "Fico", "Fic", " fini", "fii", "cfci", "Fci", "cfico", "fcu", "mii", "tco", "Fis", "cfini"], "fos": ["wios", "Fos", "fOS", "ybos", "flos", " fios", "wos", "waos", "floss", "flaos", "Foss", "wbos", "flOS", "fbos", "yos", "fios", "faos", " foss", " fOS", " fbos", "Faos", "foss", "yios", "yaos", " faos", "FOS"], "fco": [" foco", "tcos", "cso", " fcon", "Foco", "pci", "fdo", "ccon", "cdo", "pso", " fdo", "foco", "Fco", "pcos", "cco", " fcos", "Fdo", "toco", "fso", "fcos", "Fci", " fso", "Fcos", "Fcon", "tco", "fcon", "tdo", "Fso", "pco"], "buffer": ["record", "memory", "row", "note", "phrase", "binary", "read", "buff", "length", "table", "sample", "document", "batch", "holder", "block", "Buffer", "address", "filter", "message", "black", "sequence", "library", "limit", "print", "reset", "flush", "event", "queue", "temp", "cache", "source", "pause", "padding", "window", "buf", "function", "order", "iter", "timeout", "complete", "template", "position", "char", "bridge", "database", "index", "stack", "comment", "data", "match", "channel", "entry", "button", "callback", "command", "result", "append"], "currentBasesCount": ["currentBasesLength", "currentbasesLength", "currentBaseCode", "currentBasedCode", "currentBaseLength", "currentBadesLength", "currentBasedLength", "currentbaseCode", "currentBasesCode", "currentbasesCode", "currentbaseLength", "currentbasesCount", "currentbaseCount", "currentBaseCount", "currentBasedCount", "currentBadesCode", "currentBadesCount"], "currentEntriesCount": ["currentEntiesCount", "currentEntrsFlag", "currentEntriesFlag", "currentEntiesCode", "currentEntrsCode", "currentEntrysFlag", "currentEntrsCount", "currentEntriesCode", "currentEntrysCount", "currentEntrysCode", "currentEntiesFlag"], "targetCount": ["argetAmount", "TargetNum", " targetAmount", " targetNum", " targetInfo", "TargetAmount", "targetAmount", "TargetCount", "targetInfo", "argetInfo", "targetNum", "argetCount", "TargetInfo", "argetNum"], "fastaChannel": ["fastoQueue", "fastaQueue", " fastoChannel", " fastoStream", "fastaiChannel", " fastoQueue", "fastoProvider", "fastaiStream", " fastaQueue", "fastityChan", "fastoButton", "fastityQueue", " fastaProvider", "fastpaProvider", "fastpaChannel", " fastaChan", "fastoStream", " fastaConnection", "fastaConnection", "fastaiChan", " fastaButton", "fastoChannel", " fastoChan", " fastaStream", "fastpaConnection", "fastoChan", "fastaProvider", "fastaChan", "fastityChannel", "fastoConnection", "fastpaButton", "fastaiQueue", "fastaStream", "fastityStream", "fastaButton"], "totalSeqCount": ["totalSegCode", "totalSeqsCount", "totalSeQCount", "totalSeqsCounter", "totalSeqsCode", "totalSeQSize", "totalSeQCode", "totalSegCounter", "totalSeQCounter", "totalSeqCode", "totalSeqCounter", "totalSegSize", "totalSegCount", "totalSeqsSize", "totalSeqSize"], "totalResiduesCount": ["totalResiduesFlag", "totalResiduationsCount", "totalResIdueFlag", "totalResIdueCount", "totalResidueCount", "totalResIdueCode", "totalResidusCode", "totalResidusCount", "totalResiduationsFlag", "totalResiduationsCode", "totalResIduesFlag", "totalResidueCode", "totalResidusFlag", "totalResiduesCode", "totalResIduesCount", "totalResidueFlag", "totalResIduesCode"], "prevTime": [" previousThread", "parT", "parThread", "parTime", "prevThread", " prevThread", "prevT", " previousTime", " prevT", " previousT"], "fastaFileSize": ["fastaTableSIZE", "fastAFileLength", "fastafileSIZE", "fastafileOwner", "fastoFileOwner", "fastoTableSize", "fastaFileSIZE", "fastaReaderHeight", "fastaChainOwner", "fastaTableSize", "fastoFileSIZE", "fastaReaderLength", "fastaFilesLength", "fastaTableHeight", "fastaFileLength", "fastaFilesName", "fastATableLength", "fastAFileName", "fastaReaderName", "fastAFileSize", "fastAFileHeight", "fastaChainSIZE", "fastaFileOwner", "fastaTableOwner", "fastaFilesSize", "fastoFileLength", "fastaReaderSize", "fastaFileName", "fastATableName", "fastafileLength", "fastaChainLength", "fastATableHeight", "fastoFileSize", "fastaTableLength", "fastoTableLength", "fastafileSize", "fastoTableOwner", "fastaFileHeight", "fastaFilesHeight", "fastoTableSIZE", "fastaTableName", "fastATableSize", "fastaChainSize"], "fastaFileReadOffset": ["fastaChainCurrentOffset", "fastaFileCurrentoffset", "fastaFileInputOffset", "fastaFileViewPos", "fastaFileViewAmount", "fastaFileWriteOrder", "fastaFilereadPos", "fastaFilesReadOffset", "fastaFileReadAmount", "fastaFileInputoffset", "fastaFilesReadLength", "fastaFileReadPosition", "fastaFileLoadOrder", "fastaPageLoadAmount", "fastaFileReadLocation", "fastaFileWriteAmount", "fastaFileReaderOffset", "fastaFilesReadAmount", "fastaFileInputLocation", "fastaFilesLoadOffset", "fastaFileLoadOffset", "fastaFileCurrentLocation", "fastaFileInputAmount", "fastaFileLoadPos", "fastaChainCurrentPosition", "fastaFileViewOrder", "fastaFileWriteLength", "fastaFileReadPos", "fastaFilesReadOrder", "fastaChainReadOffset", "fastaPageReadAmount", "fastaFileReaderLocation", "fastaFileViewOffset", "fastaChainReadoffset", "fastaFileInputPosition", "fastaChainReadPosition", "fastaChainCurrentLocation", "fastaFilesLoadLength", "fastaFileReadLength", "fastaFilesLoadOrder", "fastaFilesLoadAmount", "fastaPageLoadPos", "fastaPageLoadOrder", "fastaChainCurrentoffset", "fastaFileCurrentOffset", "fastaFilereadOrder", "fastaPageLoadOffset", "fastaFilereadAmount", "fastaFileReadOrder", "fastaPageReadOffset", "fastaFileWriteOffset", "fastaFileInputOrder", "fastaPageReadPos", "fastaFileReaderPosition", "fastaFileInputLength", "fastaFilereadOffset", "fastaFileCurrentPosition", "fastaFileLoadAmount", "fastaPageReadOrder", "fastaFileReadoffset", "fastaFileLoadLength", "fastaFileReaderoffset", "fastaChainReadLocation"], "partitionStartOffset": ["partitionDataPosition", "partitonStartPosition", "partitonStartingPosition", "partitonStartingPoint", "partitionStartingPoint", "partitionStartingOff", "partitionStartPosition", "partitonStartingOffset", "partitionDataPoint", "partitonStartOff", "partitionDataOff", "partitionStartingPosition", "partitionStartingOffset", "partitonStartPoint", "partitionStartPoint", "partitonStartingOff", "partitionStartOff", "partitionEndPoint", "partitionDataOffset", "partitionEndOff", "partitonStartOffset", "partitionEndPosition"], "bufferSize": ["sequenceCode", "bufferName", "tableLength", " bufferSIZE", "BufferSize", "tableSize", "buffName", "BufferName", "bufLength", "tableName", " bufferLength", "bufferCode", "bufSIZE", "bufferLength", "sequenceSIZE", "BufferSIZE", "buffSIZE", "bufSize", "buffSize", "tableSIZE", "BufferLength", "buffLength", "bufCode", " bufferCode", "sequenceSize", "bufferSIZE", "sequenceLength"], "fastaBuffer": ["wildanBuff", "fastoBuffer", "fastaQueue", "fastanRequest", "fastcaBuffer", "fastaDB", "fastmaCache", "fastasBuff", "wildaRequest", "fastsaQueue", " fastaMemory", "fastasQueue", "FastmaStore", "fastmaStore", "fastoStore", "fasteBuffer", " fastaBuilder", "wildaBuffer", "fastoQueue", "fastasBuilder", "FastaStore", "fastmaBuff", "fasteMemory", "fastalBuffer", "fastaRequest", "fastcaRequest", "fastsaBuffer", "fastaCache", "wildaCache", "fasteBuff", "fastsaChannel", "fastuMemory", "fastoCounter", "fastanCache", "FastmaBuff", "fastuBuffer", " fastoQueue", "wildanBuffer", "fastaBuilder", "fastasStore", "fastmaQueue", "fastmaBuffer", "fastmaBuilder", "fastasCounter", " fastoBuffer", "fastasBuffer", "fastasCache", " fastaCounter", "wildaBuff", "FastmaRequest", " fastaCache", "wildanCache", "fastuDB", "FastaBuff", "fastalQueue", "fastcaCache", "fastaStore", "fastoRequest", "fastoBuff", "fastasRequest", "fastsaBuff", " fastaQueue", "fastcaBuff", " fastaBuff", "fastanBuff", "FastmaBuffer", "fasteDB", "fastmaChannel", "fastaCounter", "fastuBuff", "fastmaRequest", " fastoCounter", "fastalBuff", "FastaBuffer", "FastaRequest", "fastalCounter", "fastaMemory", " fastoBuff", "fastanBuffer", " fastaDB", "fastaBuff", "wildanRequest"], "fastaReadState": ["fastaCurrentType", "fastaCurrentSTATE", "fastoReaderType", "fastaReaderStatus", "fastaCurrentState", "fastoReadState", "fastaReaderType", "fastoReaderSTATE", "fastaReadType", "fastaReadStatus", "fastaReadSTATE", "fastaReaderSTATE", "fastaLoadStatus", "fastoReaderStatus", "fastoReadType", "fastaLoadType", "fastoReadSTATE", "fastoReadStatus", "fastaReaderState", "fastaLoadSTATE", "fastaLoadState", "fastaCurrentStatus", "fastoReaderState"], "nBytes": ["nWords", " nItems", " nWords", "nrBytes", "nsBytes", " nBlocks", "nItems", "noBlocks", "nParts", " nParts", "nbytes", "NItems", "nNs", "nrItems", "noBytes", " nKeys", "nrbytes", "numBytes", " nbytes", "NKeys", "Nbytes", "numNs", "nobytes", "nsParts", "nrKeys", "NBytes", "nsbytes", "nKeys", "numbytes", "noNs", "nBlocks", " nNs", "NWords", "numBlocks", "NParts", "nsWords"]}}
{"id1": "8087001", "id2": "17974661", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"generateStackHashKey": ["generateTrackHashPage", "generateStackNodeKeys", "generateTrackhashKey", "generateTrackHashKey", "generateStackNodeIndex", "generateStackhashIndex", "generateStackHashKeys", "generateStackhashPage", "generateStackNodePage", "generateStackStateIndex", "generateTrackhashPage", "generateStackHashPage", "generateStackhashKey", "generateStackHashIndex", "generateStackStatePage", "generateTrackHashIndex", "generateStackStateKeys", "generateTrackHashKeys", "generateTrackhashKeys", "generateTrackhashIndex", "generateStackhashKeys", "generateStackNodeKey", "generateStackStateKey"], "e": ["m", "u", "t", "err", "email", " exc", "ee", "ec", " pe", "ge", "o", "h", "a", "se", "ed", "es", "oe", "error", "p", "er", "ae", "element", "f", "r", " me", "x", "E", "n", "me", "pe", " err", "eb", "ex", "eeee", "exp", "en", " te", "ie", "ep", " error", "ef", "exc", "te", "eer", "eg", "i", "el", "xe", " ce", "eu", "ne", "ue", "event", "d"], "digest": ["digse", "decse", "compests", "Digse", "Digested", "descgest", "digested", "Diger", "mdEST", "mdest", " diger", "digester", "decest", "digests", "Digests", "compested", "compEST", "mdested", "DigEST", "compest", "diger", "descer", "Diggest", "descse", " digested", "diggest", " digse", "mdse", "decester", " digEST", "decested", "mdester", " diggest", "descest", "Digest", "Digester", "digEST", " digester", " digests"], "hash": ["hex", "bh", "sample", "mac", "total", "h", "has", "score", "ash", "block", "ashed", "check", "sh", "valid", "build", "filter", "message", "dig", "map", "report", "log", "cache", "test", "search", "all", "style", "sha", "Hash", "sum", "tag", "html", "her", "chain", "key", "rh", "shadow"], "rtn": ["latn", "ntN", "rxn", "latne", "rton", "RTcn", "rtmn", "mtn", "RTn", "otne", "rtns", "rtne", "vrnm", "vrb", "ntb", "ntnm", "ytnor", "rotyn", "RTb", "RTnm", "otmn", "aptnu", "rtyn", "ttnu", "artns", "rotn", "rotns", "latnm", "rxmn", "latmn", "apton", "artnor", "ytns", "ertr", "aptr", "ttr", "ttn", "otnm", "rotnor", "artn", "RTN", "mtnm", "rotcn", "aptn", "rotnm", "rotnu", "otn", "ertnu", "ertn", "rxnm", "rtnu", "rtr", "artyn", "mtnu", "rtb", "mtcn", "rtcn", "ntn", "tton", "RTnu", "rtnm", "vrN", "rxne", "rtN", "ytyn", "vrn", "erton", "ytn", "rtnor"]}}
{"id1": "14567939", "id2": "4398382", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "label": 1, "substitutes": {"baseHash": ["basicKey", " basehash", " baseSign", "basehash", "basicSign", "baseSign", "basicHash", "baseKey", "Basehash", "BaseKey", "basichash", " baseKey", "BaseHash", "BaseSign"], "name": ["info", "domain", "person", "NAME", "Name", "run", "table", "default", "username", "prefix", "parent", "common", "address", "id", "login", "account", "admin", "term", "n", "user", "order", "local", "create", "named", "title", "search", "alias", "word", "current", "john", "names", "hash", "ame", "initial", "ident", "key", "family", "author"], "password": ["pass", "secret", "phrase", "picture", "Password", "crypt", "restricted", "username", "prefix", "value", "message", "sword", "login", "reset", "remember", "padding", "user", "auth", "token", "word", "database", "session", "hash", "description", "hello", "entry", "key", "wd", "command", "shadow", "attribute"], "digest": ["digse", "decgest", " Digend", " digend", " digum", " Digester", "Digse", "Digested", "digend", "displayester", "displayEST", "mdEST", "digested", "Diger", "descgest", "dEST", "mdest", "displayested", " diger", "digester", "mdgest", "decest", " Diger", " Digest", "Digend", "digum", "mdested", "DigEST", "Digum", "dested", "diger", "dest", "descse", "Diggest", "displayum", "descester", " digested", "diggest", "decester", "mdse", "displayest", "decested", "mdester", "descest", "Digest", "Digester", "digEST", "dgest", " digester", "descested"]}}
{"id1": "18891988", "id2": "3958807", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"getFile": ["selectString", "getfile", "GetFile", "createFilename", "Getfile", "GetString", "getString", "selectFilename", "selectfile", "createString", "GetFilename", "selectFile", "createfile", "createFile", "getFilename"], "serviceName": [" serviceNames", "ServiceNames", "serviceType", "serverType", "libraryName", "serverName", " serviceType", "ServiceCode", "serviceFamily", " serviceCode", " serviceFamily", "libraryFamily", "serviceNames", "libraryNames", "ServiceType", "ServiceName", "serverCode", "ServiceFamily", "serviceCode", "libraryType"], "wsdlLocation": ["wslLoc", "awsdLocation", "wsolURL", "wsolLoc", "wsDLlocation", "awsdlocation", "wdlPath", "wslLocation", "wssdlocation", "wsdLoc", "wssdPath", "awsdlLoc", "awsollocation", "awsdllocation", "wsdlocation", "wdlLoc", "wsollocation", "awsdLoc", "awsolURL", "awsdlURL", "wsdlFolder", "wslPath", "wlLocation", "wsDLFolder", "wdlFolder", "wsDLLocation", "awsolLoc", "wsolLocation", "wlFolder", "awsdlLocation", "wssdLoc", "wsDLLoc", "wssdLocation", "wsdlURL", "wsdllocation", "awsolLocation", "wsdlPath", "wdlLocation", "wslFolder", "wsDLURL", "wlLoc", "wlPath", "wssdFolder", "wsDLPath", "wsdURL", "wsdLocation", "awsdURL", "wssdURL", "wsdlLoc"], "endpoint": ["beginpoint", "beginword", "startword", "bindpoint", "endpoints", "idline", "startpoint", "endPoint", "endport", "idpoints", "beginpoints", " endpoints", "EndPoint", "endline", " endline", "Endpoint", "startPoint", "Endpoints", " endPoint", "idPoint", "bindPoint", "Endword", " endport", "endword", "idpoint", "Endport", "bindpoints", "beginPoint", "startline", "startpoints", "bindport"], "fileLocation": ["filelocation", "Filelocation", "filePosition", " filelocation", "fileLoc", "FileLocation", " fileLoc", "FileLoc", "documentLoc", " filePosition", "documentPosition", "documentlocation", "FilePosition", "documentLocation"], "tempDir": [" tempDirectory", " tempdir", "tmpdir", "tmpPath", "tempPath", "TempFolder", " tempPath", "tempDirectory", "tmpUrl", "tempdir", "tmpFolder", "Tempdir", "tempFolder", "TempDirectory", " tempFolder", "TempDir", "tmpDirectory", "TempPath", " tempUrl", "TempUrl", "tempUrl", "tmpDir"], "url": ["ret", "pl", "m", "re", "bel", "ur", "http", "link", "https", "un", "il", "github", "ls", "up", "base", "gl", "socket", "cp", "build", "l", "uri", "f", "sl", "r", "nl", "service", "conn", "str", "window", "rel", "mount", "location", "cr", "ssl", "char", "li", "Url", "mail", "web", "ul", "sur", "ll", "loc", "job", "dl", "open", "cert", "URL", "browser", "ctrl"], "WSDLFile": ["WSDLSFile", "WHDDLFILE", "WSDLSfile", "WIDLType", "WIDDLString", "WSDLLFilename", "WHDLfile", "WNDLfile", "WHDDLfile", "WSDLType", "WSDELFILE", "WHDDLFile", "WSDELFilename", "WIDLfile", "WSDLLString", "WSDLLFile", "WSDMLFILE", "WSDMLfile", "WSDQLfile", "WSDDLType", "WSDDLString", "WIDLFile", "WSDLLFILE", "WSDELFile", "WSDDLfile", "WSDDLFile", "WNDDLFilename", "WSDLLfile", "WSDLSString", "WSDLString", "WSDELfile", "WHDLFile", "WNDLFilename", "WSDLFILE", "WNDDLFILE", "WSDLFilename", "WSDQLFile", "WSDDLFILE", "WSDLSType", "WSDLLType", "WNDLFile", "WHDLFILE", "WNDLFILE", "WNDDLfile", "WSDLfile", "WIDDLFile", "WSDQLFILE", "WSDDLFilename", "WNDDLFile", "WIDDLfile", "WIDLString", "WIDDLType", "WSDMLFile"], "tmpWSDLFile": ["tmpWSDLLFilename", "tmpWIDDLfile", "tmpWSDLDFilename", "tmpWSDLfile", "tmpWSDLDfile", "tmpWSDLDFile", "tmpWSDLFiles", "tmpWIDLFilename", "tmpWIDDLFILE", "tmpWNDLFile", "tmpWIDLFile", "tmpWIDDLFilename", "tmpWSDLFILE", "tmpWSDDLfile", "tmpWNDDLfile", "tmpWSDDLFILE", "tmpWSDLLFILE", "tmpWIDLFILE", "tmpWNDLfile", "tmpWIDDLFile", "tmpWSDlFilename", "tmpWSDLLfile", "tmpWSDlFile", "tmpWSDDLFiles", "tmpWSDLLFiles", "tmpWNDDLFilename", "tmpWSDLLFile", "tmpWSDlFiles", "tmpWSDDLFile", "tmpWNDDLFiles", "tmpWNDLFiles", "tmpWIDLfile", "tmpWSDLFilename", "tmpWSDlfile", "tmpWNDLFilename", "tmpWNDDLFile", "tmpWSDDLFilename", "tmpWSDLDFILE"], "inputFile": [" inputFILE", "InputDo", " inputFiles", "tmpPlace", "inputPath", " inputPath", "tmpSourceFile", "inputFILE", "indexFILE", " inputfile", "clientFile", " inputDo", "inputSourceFile", "Inputfile", "inputFiles", "clientFILE", " inputSourceFile", "inDo", "clientPath", "tmpStream", "intfile", "interfaceSourceFile", "interfacePlace", "indexfile", "inFile", "errorFILE", "InputFile", "InputFiles", "infile", "outputFile", "inPath", "inputDo", "indexStream", "tmpfile", "interfaceFile", " inputPlace", "interfacefile", "clientFiles", "outputfile", "intFiles", "outputFILE", "outputStream", "indexFile", "inputfile", "intFile", "errorStream", "InputStream", "intFILE", "InputPath", "inputPlace", "tmpFILE", "InputFILE", "errorFile", "inputStream", "errorfile"], "tmpFile": ["inputFilename", "mpfile", "tempFILE", "tmpPath", " tmpFiles", " tmpfile", "tempPath", "empFilename", "empFILE", "tempFilename", "inputFILE", " tmpPath", "empFile", "mpFile", "tmpFiles", "tempFiles", "tempfile", "tempFile", "mpFiles", "tmpFilename", "tmpfile", "mpPath", "empfile", "inputfile", "tmpFILE"], "in": ["t", "c", "cont", "ch", "o", "mi", "stream", "cin", "it", "ini", "inf", "inn", "ind", "id", "client", "ain", "ins", "ic", "rin", "io", "r", "ai", "conn", "inc", "source", "n", "ln", "IN", "from", "init", "en", "bin", "inner", "isin", "input", "ri", "sin", "din", "inv", "file", "is", "ar", "In"], "out": ["os", "null", "t", "w", "c", "ch", "o", "aos", "on", "client", "connection", "buffer", "this", "writer", "can", "obj", "to", "outs", "log", "group", "io", "by", "conn", "write", "cache", "ao", "n", "output", "ex", "Out", "en", "all", "conf", "outer", "tmp", "conv", "ou", "inv", "oss", "at", "pool", "OU", "cm", "sys", "auto", "file", "OUT", "co", "lock", "ne", "we", "net"], "con": ["nc", "cn", "re", "tc", "fn", "cal", "c", "un", "ch", "mc", "ws", "acon", "cone", "cin", "func", "soc", "Con", "cp", "connection", "ain", "can", "login", "conn", "cur", "Conn", "ln", "cf", "fc", "win", "conf", "sec", "exc", "conv", "com", "CON", "num", "cm", "connect", "co", "ran", "const", "cons", "cos"], "fileLength": ["fileLen", "ileDuration", "channelSize", " fileLen", "fileFontSize", "ileLength", "objectSize", " fileSize", "channelLength", "ileLen", " fileDuration", "fileDuration", "FILELen", "fileSize", "objectFontSize", "FILEDuration", "channelFontSize", "channelDuration", " fileFontSize", "FILELength", "objectLength", "ileSize", "objectDuration", "FILESize"], "channelIn": ["chanIn", "channelSet", " channeledIn", "channeledIn", "ChannelIN", "ChannelOut", "consoleIn", "ChanneledIn", "chanSet", " channelIN", "clientIN", "chanOut", " channelin", "clientSet", "consoleOut", "clientin", "Channelin", "consoleIN", "consoleedIn", "channelIN", "clientOut", "ChannelIn", "channelin", "ChannelSet", "clientIn", "chanIN"], "channelOut": ["courseIn", "consoleout", "chanConn", "chanIn", "courseOUT", "ChannelOut", "chanout", "Channelout", " channelout", "chanOut", "channelOUT", "consoleOut", " channelConn", "channelConn", "ChannelOUT", "courseOut", "consoleOUT", "ChannelConn", "courseout", "channelout", "ChannelIn", "consoleIn", " channelOUT"], "tmpDocument": ["tpMedia", "tmDoc", "tempDocument", " tmpMedia", "tpDocument", "mkdocument", "tmdocument", "cpDocument", "mpDoc", "npMedia", "tpDocuments", " tmpdocument", "npDocument", "tmpDocuments", " tmpDoc", "tmpdocument", "mpDocument", "tempdocument", "tmpMedia", "cpDoc", "mkDoc", "tpFile", "mkDocument", "npFile", "tempDoc", "cpdocument", "tmDocument", "npDocuments", "tmpDoc", " tmpDocuments", "mpdocument"], "nl1": ["rnOne", "ln3", "NL2", "nl9", "sol1", "ln01", "nrOne", "pelOne", "nelOne", "rn6", "ln0", "nel3", "NL1", "rn1", "rn3", "nl6", "nr1", "sol2", "ln1", "pel1", "nr01", "ln2", "pel01", "nlOne", "NL0", "nl2", "lnOne", "nl0", "sol9", "NL9", "nel6", "sol0", "nl01", "nel1", "ln6", "nl3", "ln9"], "i": ["info", "ji", "m", "ms", "ci", "u", "j", "gi", "ii", "mu", "qi", "I", "us", "span", "mi", "key", "a", "ti", "o", "pi", "it", "di", "ini", "ui", "hi", "id", "y", "v", "multi", "ic", "k", "io", "ai", "\u0438", "x", "n", "ori", "me", "bi", "ip", "cli", "init", "si", "ie", "ij", "ri", "index", "sim", "li", "ix", "xi", "ami", "is", "ims"], "node1": ["Node2", "nodeOne", "componentOne", "node2", "node0", "ode1", "component1", "n1", "nOne", "node001", "layerOne", "Node001", "node91", "layer1", "component2", " node001", "ode0", " nodeOne", "n0", " node91", "layer91", "layer0", "NodeOne", "ode001", "ode2", "n91", " node2", " node0", "Node1", "Node0", "component0"], "tmpOut": ["mpout", "cmpIn", "npIn", "tempIn", "TempOUT", "empout", " tmpObj", "mpIn", "cmpOut", "tmpIn", "npOut", "mpOut", "npObj", "tempOUT", "tmpObj", "TempOut", "tempout", "TempObj", " tmpOUT", "tmpIs", "mpObj", "tempObj", "tempIs", " tmpIn", "npout", " tmpout", "empOut", "empIs", "TempIn", "tmpOUT", "tmpout", " tmpIs", "tempOut", "cmpout"], "retVal": ["retTrue", "returnval", " retval", "RetTrue", " retTrue", " retValue", "Retval", "RetVal", "retval", "RetValue", "returnValue", "returnTrue", "returnVal", "retValue"]}}
{"id1": "11962480", "id2": "8150996", "code1": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 0, "substitutes": {"read": ["download", "Read", "parse", "update", "empty", "delete", "store", "READ", "library", "readable", "write", "define", "construct", "loads", "create", "find", "init", "copy", " Read", "seek", "index", "config", "reading", "file", "open", "reads", "load"], "skeletonFilename": ["satelliteBas", "saltSourceFile", "SkelFilename", "saneFile", " skelURL", "skelResource", "sootTitle", "skelTitle", "saltFilename", "sadeFile", "SkeletonFormat", "siteString", " skelFilename", "skeletonString", "saneResource", "SkelBas", "SkelFile", "sootFile", "soleFile", "skeletonTitle", "saltFile", "SkelFormat", "SkeletonString", "SkelTitle", "SkelString", "saltURL", "skeletonBas", "sadeFilename", "saneFilename", "SkelResource", " skelFile", " skelSourceFile", "Skeletonfilename", "siteBas", "skelURL", "skeletonResource", "skeletonFile", "SkeletonFilename", "SkeletonResource", "siteFilename", "soleFilename", "skeletonFormat", "skelfilename", "skelString", " skeletonURL", "sadeResource", " skeletonFile", "sadefilename", "skelFormat", "sootFilename", "siteFile", "sootFormat", "soleFormat", "soleTitle", "skelBas", "skeletonfilename", "skeletonURL", "SkeletonBas", "Skelfilename", "skelSourceFile", "skelFilename", "SkeletonFile", "satelliteFilename", " skeletonSourceFile", "sanefilename", "skelFile", "satelliteFile", "satelliteString", "skeletonSourceFile", "SkeletonTitle"], "loader": ["older", "module", "later", "lr", "hl", "handler", "upper", "system", "context", "label", "resource", "er", "kernel", "library", "owner", "l", "wrapper", "finder", "folder", "cl", "license", "loads", "loading", "language", "container", "inner", "lib", "class", "Loader", "pool", "program", "loop", "parser", "acl", "loaded", "load", "builder"], "url": ["browser", "lr", "ur", "http", "link", "b", "path", "github", "ref", "util", "host", "base", "key", "ls", "build", "address", "name", "client", "resource", "uri", "l", "f", "sl", "nl", "rl", "org", "rel", "impl", "mount", "user", "location", "result", "server", "Url", "mail", "web", "manager", "html", "file", "loc", "lb", "dl", "entry", "open", "job", "channel", "URL", "load", "builder"], "line": ["LINE", "row", " chunk", "column", "link", " lineage", "sample", "lo", "rule", "eline", "inline", " row", "side", "e", "block", "ice", " block", " blank", "value", "part", "level", "cell", "message", "buffer", "Line", "sequence", "normal", " headline", "l", "log", "print", "nl", "lines", " sequence", " linen", " equation", " entry", " LINE", "ln", "cmd", " inline", " code", "lin", "L", "string", "page", " error", "word", " comment", "continue", "area", "body", "next", "point", "le", "zone", " message", "frame", "online", "comment", "file", "lane", "channel", "job", "entry", " frame", "ine", "label", "text", "chain", "liner", "field"], "section": ["sector", "row", "storage", "null", "length", "table", "variable", "journal", "option", "ner", "termination", "statement", "key", "room", "character", "prefix", "se", "sections", "block", "region", "part", "side", "ment", "list", "system", "connection", "buffer", "sequence", "writer", "Section", "summary", "article", "library", "group", "unit", "setting", "tab", "member", "number", "function", "user", "set", "language", "sect", "string", "page", "state", "position", "network", "second", "area", "session", "tag", "comment", "description", "division", "script", "header", "channel", "job", "entry", "format", "field", "event"], "reader": ["rot", "row", "older", "length", "handler", "anger", "rar", "upper", "ner", "driver", "stream", "mr", " Reader", "roller", "ser", "iterator", "oder", "buffer", "context", "writer", "runner", "er", "r", "rl", "cur", "ro", "iter", "Reader", "rx", "inner", "input", "reverse", "file", "reading", "layer", "parser", "entry", "rr", "builder"]}}
{"id1": "13852596", "id2": "13362846", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"execute": ["process", " proceed", "exec", " replay", " executed", "run", " benchmark", " launch", " assemble", "evaluate", " deploy", " executable", " release", " evaluate", " eval", "construct", " execution", "init", " exec", "launch", " chain", " test", " scan", " inherit", " sweep", " perform", " resolve"], "resources": ["faces", "modules", "packages", "actions", "banks", "services", "rooms", "accessible", "rows", "roots", "lets", "results", "files", "relations", "artifacts", "issues", "they", "ifiers", "users", "resource", "these", "stores", "flows", "workers", "items", "uploads", "blocks", "res", "ids", " Resources", "groups", "rs", "Resources", "objects", "scripts", "pointers", "types", "ports", "writers", "locks", "ris", "archives", "reports", "names", "projects", "apps", "bytes", "builders", "models", "classes", "images", "ions"], "i": ["info", "ji", "ci", "t", "im", "in", "ia", "phi", "gi", "ii", "j", "mu", "I", "mi", "ti", "h", "oi", "ios", "pi", "e", "di", "ini", "ui", "hi", "list", "v", "multi", "abi", "l", "io", "ai", "\u0438", "q", "ali", "iri", "ori", "g", "iu", "bi", "ex", "ip", "cli", "si", "ij", "ri", "ki", "li", "xi", "ami", "ims", "bis", "ir"], "classFile": ["userFiles", "connectionFile", "fastfile", "ClassLine", "sourceFile", "ClassClass", " classFILE", "objectClass", "ClassFILE", "fastFiles", " classClass", " classTree", "classifiedFile", "cellClass", "attributeFILE", "attributeFiles", "clFile", "classfile", "clFiles", "recordFilename", "classTree", "instanceFile", "clTree", "userFile", "Classfile", "classifiedfile", " classfile", "cellFile", "parentfile", "userfile", "classChain", "sourceFILE", "typeFILE", "classDirectory", "ClassChain", " classFiles", " classSourceFile", "attributeResource", "classFiles", "classFILE", "targetSourceFile", "parentSourceFile", "recordfile", "parentFile", "classLine", "typeLine", "ClassFilename", " classResource", "sourceFiles", "ClassFile", "attributeEntry", " classFilename", " classChain", "targetFILE", "userFILE", "connectionFILE", "sourceClass", "clfile", "ClassTree", "targetFiles", "classifiedSourceFile", "ClassFiles", "classFilename", "recordFiles", "ClassSourceFile", "classEntry", "attributeChain", "typeFile", "connectionSourceFile", "instanceFilename", "classSourceFile", "attributeFile", "instanceFiles", "connectionfile", "classifiedFiles", "classFolder", " classLine", "typeFiles", "ClassEntry", " classFolder", "ClassDirectory", "objectFolder", "instanceDirectory", "fastFile", "recordFile", " classEntry", "classClass", "classifiedFILE", "fastFILE", " classDirectory", "objectFile", "classResource", "cellFolder", "ClassResource", "targetFile", "parentFILE"], "inputStream": ["ipStream", "familyFile", "innerSteam", "familySource", "inSteam", "thisSteam", "ipStyle", "ipSteam", "jsonStream", "inStreamer", "inputSt", "outputPort", "outputSteam", "errorSteam", "jsonSteam", "familyStyle", " inputstream", "inputPort", " inputFile", "thisFile", "InputTime", "jsonStreamer", "outputstream", "inputSteam", "audioSteam", "audioStreamer", "thisSource", "thisStream", "InputMode", "ipFile", "inPort", " inputPort", "inputStreamer", "errorstream", "innerSet", "instream", "inputSet", " inputSteam", "audioStream", "innerStream", "inputSource", "outputFile", "inputFile", "outStreamer", "inputTime", "familyStream", "inputStyle", "outStream", "outputTime", "inputMode", "outSteam", "inputstream", " inputSt", "inSet", "InputSteam", " inputTime", " inputSource", "outputStyle", "errorStream", "jsonSet", "innerStreamer", "InputStream", " inputMode", "Inputstream", "inStream", "outSt", "errorMode", "audioSt", " inputStreamer", "familySteam"], "reader": ["editor", "dd", "row", "older", "per", "read", "handler", "variable", "document", "rar", "ner", "rule", "key", "definition", "driver", "prototype", "stream", "worker", "rer", "peer", "oder", "iterator", "client", "image", "runner", "er", "owner", "wrapper", "master", "r", "readable", "write", "service", "rl", "test", "user", "draft", "Reader", "dr", "inner", "operator", "instance", "ger", "query", "review", "manager", "actor", "red", "Writer", "penter", "reading", "layer", "parser", "ler", "entry", "loader", "field", "author", "mr", "finder", "builder"], "oldSize": ["oldersize", "oldFontSize", "oldLength", "olderLength", " oldLength", "OLDFontSize", " oldsize", "oldsize", "OLDsize", "OLDSize", "OLDLength", "olderSize", " oldFontSize", "olderFontSize"], "writer": ["editor", "adder", "row", "rw", "wb", "storage", "w", "written", "read", "handler", "variable", "document", "ner", "key", "definition", "driver", "weight", "worker", "wrote", "message", "buffer", "er", "riter", "runner", "wrapper", "writing", "owner", "r", "write", "service", "method", "buf", "node", "test", "draft", "Reader", "inner", "writers", "word", "player", "walker", "review", "draw", "actor", "ter", "manager", "Writer", "penter", "parser", "entry", "ler", "loader", "format", "author", "finder", "vector", "builder"], "b": ["m", "u", "wb", "t", "w", "binary", "bs", "c", "erb", "ab", "bit", "h", "a", "batch", "base", "bf", "bb", "ib", "fb", "v", "p", "B", "bound", "l", "f", "emb", "r", "bits", "mb", "gb", "n", "g", "sb", "bin", "rb", "br", "bp", "db", "ob", "bis", "nb", "d"], "outputStream": ["outputForm", "writePoint", " outputForm", "outputSteam", "outputPoint", "writeStream", "resultString", "resultForm", "OutputStream", "resultSteam", "outputstream", "inputSteam", "OutputString", "resultstream", " outputString", "OutputForm", "inputView", "writeSteam", "Outputstream", "writeView", " outputPoint", "resultStream", "inputstream", "OutputSteam", "outputString", "inputPoint", "outputView", " outputView", " outputSteam", "inputForm"], "injectedClasses": ["injectedUsES", "injectedUsBytes", "injectedCountes", "injectedUsets", "injectUsES", "injectUsBytes", "injectUsets", "injectedCountES", "injectedClassES", "injectedUses", "injectedClassets", "injectUses", "injectedCountBytes", "injectedClassBytes", "injectedCountets", "injectedSuccessBytes", "injectClassES", "injectedSuccesses", "injectClasses", "injectClassets", "injectedSuccessets", "injectedSuccessES", "injectClassBytes"], "newSize": ["newMax", "oldFontSize", "newFontSize", "newName", " newName", " newFontSize", "NewSize", "NewMax", "NewFontSize", " newMax", "NewName", "oldMax", "oldName"]}}
{"id1": "11475527", "id2": "620855", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"addDataFromURL": ["addTextFromurl", "addDataFormurl", "addDataToURL", "addDataFormURL", "addDataTourl", "addDatafromURL", "addTextFormURL", "addDatafromUrl", "addDataFormUrl", "addDataFromUrl", "addDatafromLocation", "addDataToLocation", "addTextFromURL", "addDataFromLocation", "addDataFormLocation", "addTextFromUrl", "addTextFormUrl", "addDataFromurl", "addTextFromLocation", "addTextFormLocation", "addTextFormurl", "addDataToUrl", "addDatafromurl"], "theurl": ["TheUrl", "Theuri", "heloader", "heuri", "teURL", " theloader", " theuri", "thloader", "Theurl", " theURL", "theloader", "teuri", "heURL", "heUrl", "teurl", "thefile", "thfile", "heurl", "theUrl", " theUrl", " thefile", "thUrl", "hefile", "teUrl", "theURL", "TheURL", "theuri", "thurl"], "line": ["record", "LINE", "row", "email", "link", "sample", "rule", "ner", "eline", "inline", "block", "ice", "valid", "day", "cell", "name", "message", "Line", "sequence", "l", "print", "source", "lined", "code", "node", "ln", "stroke", " inline", "lin", "page", "string", "char", "point", "le", "zone", "frame", "online", "header", "status", "lane", "comment", "entry", "ine", "text", "chain", "liner"], "in": ["gin", "t", "include", "read", "lo", "old", "oin", "mc", "o", "mi", "cin", "it", "or", "inf", "inn", "id", "ain", "ins", "l", "rin", "f", "ic", "reader", "r", "pin", "inc", "conn", "out", "ai", "al", "source", "proc", "n", "st", "IN", "from", "win", "init", "en", "isin", "bin", "inner", "con", "input", "again", "din", "phys", "ma", "i", "is", "ac", "serv", "open", "In"], "data": ["join", "info", "feed", "ad", "text", "ata", "read", "DATA", "a", "stream", "raw", "iterator", "client", "this", "buffer", "writer", "io", "reader", "content", "dec", "cache", "out", "window", "user", "dat", "def", "input", "body", "next", "pipe", "query", "size", "file", "bus", "da", "result", "d"], "e": ["m", "re", "t", "err", "ee", "b", "ec", "c", "ge", "o", "h", "a", "se", "be", "or", "ed", "es", "oe", "ce", "error", "y", "p", "ze", "er", "ae", "v", "element", "f", "ve", "ele", "r", "x", "E", "n", "g", "me", "pe", "de", "eeee", "ex", "ie", "le", "te", "i", "eu", "ne", "entry", "ine", "ue", "event", "d"]}}
{"id1": "3309233", "id2": "12724876", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    private void loadURL(URL url, String username, String password, JLabel statusDialogMBLabel) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (username != null && !username.equals(\"\")) {\n            if (password == null) {\n                password = \"\";\n            }\n            String encoding = new sun.misc.BASE64Encoder().encode(new String(username + \":\" + password).getBytes());\n            connection.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        this.tmpVRMLFile = File.createTempFile(\"xnavi-\", null, null);\n        System.out.println(\"Created tmp file: \" + this.tmpVRMLFile.getAbsolutePath());\n        FileWriter fw = new FileWriter(this.tmpVRMLFile);\n        long bytesInFile = this.tmpVRMLFile.length();\n        double sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n        String response = \"\";\n        while ((inputLine = in.readLine()) != null) {\n            response = inputLine + \"\\n\";\n            fw.write(response);\n            fw.flush();\n            if (statusDialogMBLabel != null) {\n                bytesInFile = this.tmpVRMLFile.length();\n                sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n                sizeInMB *= 100.0;\n                sizeInMB = (double) ((int) sizeInMB);\n                sizeInMB /= 100.0;\n                statusDialogMBLabel.setText(sizeInMB + \" MB\");\n                statusDialogMBLabel.repaint();\n            }\n        }\n        fw.close();\n        System.out.println(\"Wrote file \" + this.tmpVRMLFile.getAbsolutePath());\n    }\n", "label": 0, "substitutes": {"doInBackground": ["doInMemory", " doInHttp", " doInAsync", " doAsHttp", "doInAsync", " doAsAsync", "doAsBackground", " doIntBackground", "doAsHttp", " doIfBackground", "doAsAsync", " doIfMemory", "doInHttp", " doIntMemory", " doIntAsync", "doAsMemory", " doAsBackground", " doIfHttp", " doIfAsync", " doIntHttp", " doAsMemory", " doInMemory"], "params": ["styles", "ms", "details", "sql", "words", "pps", "actions", "aws", "services", "vs", "resources", "ls", "points", "results", "settings", "values", "p", "amps", "pins", "items", "lines", "members", "js", "ids", "keys", "types", "properties", "units", "photos", "ims", "steps", "json", "terms", "months", "ams", "parts", "posts", "names", "xs", "times", "reports", "fixes", "data", "models", "stats", "options", "images", "tags", "ps", "shape"], "param": ["perm", "project", "m", "Param", "ad", "pai", "parse", "sem", "rank", "cal", "option", "property", "pm", "pri", "dem", "prom", "power", "mem", "minute", "space", "cp", "sp", "p", "arg", "resource", "min", "Parameter", "aram", "amp", "sam", "conn", "member", "proc", "sm", "admin", "dm", "set", "mm", "ctx", "iam", "conf", "input", "jp", "par", "meter", "num", "ram", "ams", "rem", "cm", "config", "pool", "vm", "form", "initial", "am"], "client": ["cn", "api", "tc", "http", "close", "c", "ch", "secure", "cp", "system", "cell", "connection", "context", "resource", "grid", "wrapper", "call", "io", "service", "conn", "cl", "cache", "console", "cmd", "local", "ip", "google", "cli", "con", "app", "server", "city", "cm", "co", "response", "channel", "remote", "phone", "Client", "net"], "post": ["pass", "process", "mod", "row", "feed", "install", "send", "http", "zip", "upload", "link", "read", "parse", "pp", "ld", "end", "POST", "submit", "get", "after", "add", "ost", "build", "p", "rest", "req", "patch", "op", "write", "put", "request", "pre", "set", "create", "Post", "follow", "save", "def", "and", "head", " Post", "body", "pod", "next", "col", "form", "tx", " POST", "wp", "dd"], "resp": ["rep", "re", "rex", "cmp", "pos", "err", "http", "bs", "https", "repl", "esp", "soc", "desc", "bb", "sp", "obj", "rest", "req", "conn", "out", "cl", "proc", "respond", "rec", "res", "rel", "respons", "cmd", "exp", "comm", "jp", "Response", "body", "responsive", "conv", "comp", "inv", "rem", "wait", "html", "cb", "Resp", "ess", "response", "dl", "serv", "status", "col"], "entity": ["info", "eme", "details", "person", "cy", "detail", "note", "email", "active", "ee", "existent", "orm", "document", "my", "security", "object", "se", "line", "e", "ce", "activity", "resource", "obj", "unit", "owner", "group", "content", "member", "enc", "me", "pe", "output", "encrypted", "body", "le", "json", "Entity", "el", "xml", "data", "response", "entry", "ent", "ity", "event"], "result": ["ret", "join", "answer", "true", "successful", "detail", "table", "total", "currency", "success", "results", "valid", "message", "sequence", "summary", "group", "report", "feature", "request", "res", "date", "test", "output", "product", "csv", "profile", "complete", "continue", "current", "root", "relation", "Result", "comment", "status", "description", "match", "response"]}}
{"id1": "8815137", "id2": "8069594", "code1": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyToDir": ["transfer2File", "transferToPath", "transfer2Path", "copyToDirectory", "copyToPath", "copy2Directory", "transferToFile", "copyToFile", "transfer2Directory", "copyFromDirectory", "copytoFile", "copyFromPath", "copyFromDir", "copytoDirectory", "copy2Dir", "copy2Path", "copytoPath", "transferToDirectory", "copyFromFile", "copytoDir", "copy2File", "transfer2Dir", "transferToDir"], "dir": ["dd", "full", "mod", "src", "re", "module", "null", "pos", "det", "disk", "d", "old", "pkg", "cont", "mk", "path", "base", "desc", "parent", "name", "id", "directory", "md", "spec", "Dir", "req", "doc", "DIR", "out", "folder", "cur", "dist", "dis", "window", "rec", "res", "rel", "de", "draft", "dm", "local", "init", "dr", "def", "ds", "lib", "tr", "root", "tmp", "div", "ext", "manager", "db", "data", "fd", "loc", "vol", "fin", "wd", "ir", "del"], "file": ["info", "http", "disk", "get", "issue", "port", "limit", "log", "f", "io", "init", "el", "model", "filename", "full", "project", "domain", "ile", "FILE", "table", "fp", "il", "path", "line", "unit", "to", "report", "print", "flag", "play", "out", "source", "entity", "class", "task", "form", "job", "open", "label", "status", "result", "link", "fn", "used", "use", "this", "change", "controller", "all", "current", "db", "force", "msg", "lock", "format", "module", "File", "null", "rule", "h", "url", "base", "value", "parent", "name", "message", "p", "image", "resource", "cache", "local", "create", "output", "page", "title", "tree", "state", "core", "le", "comment", "field", "entry", "type", "foo", "handle"], "fileOutputStream": ["fileWriteStream", "fileOutputView", "fileOutputSocket", " fileWriteStream", "filePutForm", "FileOutputView", "fileSystemStream", "fileLogSteam", "fileLogForm", "fileControlSteam", "fileWriteForm", "FileOutputForm", "fileInputForm", "fileControlView", "fileInputView", "fileInputSocket", "fileOutputSteam", "FileInputSteam", " fileWriteSteam", " fileWriteForm", "fileWriteSteam", "fileControlStream", "FileOutputStream", "filePutstream", "FileInputStream", "fileControlSocket", " fileOutputForm", "fileInputstream", "FileOutputSteam", "fileWritestream", "fileInputSteam", "FileOutputSocket", "FileInputForm", "fileSystemView", " fileOutputSteam", " fileWritestream", " fileOutputstream", "fileSystemSocket", "filePutSteam", "FileInputView", "fileSystemSteam", "FileInputSocket", "filePutStream", "fileOutputForm", "fileLogStream", "fileOutputstream"], "fileInputStream": ["fileInSteam", "FILEInputStream", "FileInputRead", "FILEOutputStream", "FILEOutputThread", " fileInputSteam", "fileInputRead", "fileInController", "fileInterstream", "fileInsertStream", "fileinputController", "fileInterThread", "fileInStream", "fileinputSteam", "fileInputController", " fileOutputController", "fileOutputStreamer", "fileInterStreamer", "fileInterStream", " fileInputController", "fileinputSource", "fileOutputSteam", "FILEInputstream", "FILEOutputstream", "fileInputStreamer", "FileInputList", "FileInputSteam", "fileOutputList", "fileInsertList", "fileInputList", "FILEInputStreamer", "fileOutputController", "fileInsertSteam", "FileOutputStream", "fileInputThread", "fileInSource", "FileInputStream", "fileinputStream", "fileInputstream", "fileOutputThread", "FileOutputSteam", "FileOutputRead", "fileInputSteam", "fileOutputSource", " fileOutputSteam", " fileInputSource", "fileinputRead", "FILEInputThread", "fileOutputRead", " fileOutputSource", "fileInsertRead", "fileInputSource", "fileinputList", "fileOutputstream", "FILEOutputStreamer", "FileOutputList"], "read": ["each", "send", "shift", "Read", "in", "length", "have", "run", "parse", "close", "end", "ok", "offset", "get", "stream", "add", "raw", "check", "count", "ind", "need", "READ", "ready", "last", "trust", "print", "skip", "report", "reader", "with", "readable", "req", "seen", "write", "r", "height", "x", "n", "tell", "find", "start", "pack", "set", "push", "input", "seek", " write", "num", "index", "wait", "i", "size", "reading", "ask", "len", "open", "reads", "load", "shape", "hold"], "buffer": ["bar", "memory", "row", "phrase", "binary", "buff", "sample", "table", "variable", "document", "capacity", "batch", "stream", "block", "reason", "Buffer", "available", "history", "filter", "message", "sequence", "print", "event", "cache", "window", "buf", "iter", "page", "template", "result", "word", "char", "body", "frame", "header", "initial", "button", "text", "chain", "command", "stack", "attribute", "append"]}}
{"id1": "12586404", "id2": "732800", "code1": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"run": ["pass", "process", "exec", "parse", "sample", "submit", "runs", "check", "use", "runner", "call", "play", "action", "running", "apply", "invoke", "Run", "select", "test", "create", "profile", "work", "render", "program", "execute", "load"], "prova": ["rega", " proba", "reba", "revo", "Proga", " provo", "roba", "reva", " proga", "Prova", "rovo", "provo", "proba", "Provo", "proga", "Proba", "rova", "roga"], "agent": ["ace", "ad", "active", "pet", "driver", "host", "agents", "worker", "name", "client", "issue", "agency", "ain", "password", "Agent", "service", "admin", "action", "test", "cer", "ua", "ie", "operator", "server", "player", "man", "sim", "tag", "manager", "actor", "bot", "access", "script", "gent", "ant", "ity", "command", "net"], "key": ["pass", "info", "secret", "link", "my", "mk", "host", "ver", "power", "version", "value", "id", "name", "client", "y", "resource", "password", "k", "service", "cert", "user", "export", "keys", "state", "token", "conf", "KEY", "server", "root", "sum", " Key", "access", "py", "policy", "type", "Key", "chain", "net"], "src": ["sit", "RC", "sc", "text", "sing", "null", "rob", "bs", "SOURCE", "https", "rc", "href", "syn", "cont", "path", "secure", "stream", "desc", "its", "ser", "sq", "resource", "rest", "s", "ins", "uri", "seed", "buster", "sync", "sub", "rl", "std", "cur", "source", "str", "proc", "res", "rel", "st", "txt", "rs", "from", "sb", "sn", "typ", "dest", "supp", "iv", "rb", "sec", "input", "img", "sr", "config", "sys", "addr", "script", "inst", "loc", "filename", "dir"], "file": ["full", "File", "null", "ile", "binary", "FILE", "link", "disk", "table", "document", "il", "fp", "path", "rule", "base", "be", "e", "block", "files", "check", "fe", "name", "image", "resource", "port", "library", "log", "f", "io", "play", "out", "source", "sol", "from", "local", "create", " File", "class", "input", "work", "word", "body", "le", "db", "pool", "data", "channel", "type", "lock", "open", "ca", "filename", "handle"], "in": ["gin", "info", "vin", "im", "nin", " din", "mc", "mi", "cin", "it", "raw", "ini", "inf", "inn", "ind", "ill", "ain", "rest", "ins", "mn", "can", "rin", "reader", "pin", "inc", "r", "out", "ln", "from", "IN", "iter", "init", "lin", "bin", "inner", "isin", "en", "all", "con", "input", "din", "inv", "i", "ma", "cm", "el", "as", "form", "data", "cgi", "serv", "and", "mr", "In"], "is": ["os", "ms", "sis", "sit", "isl", "ils", "im", "bs", "isa", "us", "mi", "lis", "ios", "has", "it", "isi", "its", "isc", "tis", "es", "iss", "ists", "ts", "ins", "s", "ic", "isf", "does", "ois", "dis", "fs", "ire", "rys", "mis", "ist", "iris", "nis", "ip", "init", "isin", "si", "ics", "ri", "ris", "ys", "iso", "ends", "sim", "oss", "i", "abs", "sys", "as", "IS", "Is", "ires", "vis", "ais", "ims", "bis", "ir", "est"], "url": ["sql", "bel", "ur", "null", "http", "link", "b", "path", "ref", "ls", "gl", "ml", "dll", "id", "resource", "l", "uri", "log", "sl", "io", "nl", "fl", "r", "rl", "str", "rel", "mount", "user", "sb", "ssl", "char", "kl", "Url", "mail", "web", "ul", "ll", "dl", "cert", "URL", "net"], "fr": ["rt", "fer", "re", "lr", "Fr", "fn", "fw", "fp", "bf", "mr", "fm", "gr", "raf", "f", "r", "fl", "rl", "hr", "str", "cf", "FR", "fc", "cr", "dr", "tr", "sr", "br", "fy", "pr", "rr", "ry", "kr", "tf", "fd", "fi", "ll", "fin", "vr", "ir"], "results": ["details", "actions", "aps", "params", "features", "forms", "resources", "rows", "docs", "runs", "its", "errors", "values", "outs", "pins", "items", "blocks", "ces", "prints", "lines", "comments", "ults", "res", "rules", "output", "Results", "vals", "objects", "types", "RESULTS", "products", "them", "reports", "terms", "changes", "names", "tests", "chains", "models", "options", "images", "cases", "result", "maps"]}}
{"id1": "17190057", "id2": "6866575", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 1, "substitutes": {"encode": ["Encode", " enode", "deode", "Enode", "enode", "declose", "Enclose", " enclose", "enCode", "decode", " enCode", "EnCode", "enclose", "deCode"], "input": [" inputs", "in", "active", "sample", "audio", "qi", "url", "it", "raw", "value", "check", "name", "client", "address", "buffer", "image", " Input", "sequence", "context", "password", "print", "op", "out", "q", "Input", "source", "str", "request", "cmd", "output", "act", "string", "pattern", "config", "qa", "xml", "form", "data", "file", "initial", "hello", "format", "text", "command"], "NoSuchAlgorithmException": ["NoSuchALgorithmError", "NoSuchALgorithmClass", "NoSuchALgorithmEx", "NoSuchALgorithEx", "NoSuchAlryptionException", "NoSuchALgorithClass", "NoSuchAlgorithError", "NoSuchALgorithException", "NoSuchALgorithError", "NoSuchAlryptionClass", "NoSuchAlgorithEx", "NoSuchAlryptionError", "NoSuchAlgorithmClass", "NoSuchAlgorithmError", "NoSuchAlgorithException", "NoSuchAlgorithClass", "NoSuchAlryptionEx", "NoSuchAlgorithmEx", "NoSuchALgorithmException"], "md": ["mod", "m", "ms", "ad", "det", "pd", "df", "ld", "mk", "mc", "pm", "add", "nd", "desc", "MD", "ng", "di", "ind", "rm", "dig", "cd", "mn", "mt", "od", "bd", "sam", "mb", "sm", "mg", "sd", "js", "strong", "de", "cmd", "dm", "mm", "metadata", "dr", "def", "pdf", "der", "nt", "sha", "hd", "cm", "red", "mand", "msg", "mp", "dd", "d"]}}
{"id1": "21033686", "id2": "22320592", "code1": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"read": ["download", "feed", "send", "upload", "shift", "Read", "take", "run", "poll", "close", "end", "url", "get", "stream", "add", "GET", "count", "READ", "buffer", "skip", "print", "reader", "readable", "content", "write", "request", "select", "iter", "create", "find", "pull", "copy", "all", " Read", "input", "seek", "index", "next", "query", "wait", "transfer", "connect", "reading", "data", "view", "gets", "size", "open", "reads", "load"], "conn": ["nc", "handle", "cn", "dial", "sql", "cmp", "exec", "j", "resp", "gate", "c", "cont", "syn", "close", "ch", "url", "ct", "pg", "pas", "cp", "ns", "socket", "client", "connection", "obj", "cur", "Conn", "enc", "ait", "res", "cmd", "act", "ctx", "init", "ssl", "comm", "con", "jp", "conf", "nt", "conv", "com", "access", "cm", "cb", "connect", "canon", "addr", "ann", "msg", "aj", "co", "open", "ca", "cert", "fin", "ctrl", "net"], "length": ["phi", "total", "ENGTH", "amount", "default", "count", "available", "history", "message", "sequence", "rest", "l", "number", "height", "L", "result", "ength", "position", "present", "Length", "size", "data", "len", "duration", "family", "load"], "tempDir": ["empdir", "nulldir", "tmpEar", "empFolder", "empStart", "poraryDirectory", "tmpdir", "tmpPath", "tempPath", "tmpServ", "poraryStart", " tempPath", "tempDirectory", "empFile", "poraryServ", "nullPath", "empPath", "templateEar", "templateDirectory", "empDir", "tempdir", "tmpFile", "poraryFolder", "templateDir", "tmpFolder", "tempFolder", "tempEar", " tempFolder", "poraryDir", "tmpDirectory", "nullDir", "poraryEar", "tempStart", "tmpStart", "templateFolder", "tempServ", "empServ", "tmpDir"], "tempFile": ["TempFile", "empFolder", " tempField", "tempField", " tempfile", "tmpPath", "tempPath", "tmpPlace", "Tempfile", "currentFile", " tempPath", "empField", "poraryPlace", "empFile", "empDir", "tempfile", "poraryfile", "currentB", "tmpFile", "poraryFolder", "empPlace", "tempB", "tmpFolder", "tmpfile", "tempFolder", "empB", "currentPlace", "empfile", "tempPlace", "TempDir", "poraryFile", "currentfile", "TempPath", "tmpB", "TempField"], "in": ["gin", "re", "t", "nin", "o", "mi", "up", "cin", "it", "add", "or", "on", "ini", "inf", "raw", "inn", "ind", "internal", "client", "image", "ain", "ins", "l", "rin", "log", "io", "ai", "inc", "al", "source", "str", "n", "st", "IN", "from", "iter", "ex", "init", "local", "en", "bin", "inner", "isin", "all", "con", "input", "conf", "ssl", "din", "irm", "body", "i", "inside", "el", "form", "is", "In", "net"], "out": ["cn", "os", "m", "null", "t", "w", "nin", "b", "end", "ot", "o", "a", "up", "aos", "na", "it", "on", "or", "oe", "ns", "client", "p", "writer", "obj", "can", "to", "outs", "l", "boot", "io", "s", "ins", "op", "write", "dis", "n", "output", "ex", "an", "Out", "inner", "all", "con", "again", "conv", "com", "outer", "sum", "ou", "oss", "at", "sys", "OU", "external", "OUT", "co", "ne", "net"], "monitor": ["info", "memory", "process", "m", "processor", "umi", "detail", "watch", "im", "spin", "gray", "progress", "handler", "batch", "stream", "rain", "timer", "bm", "history", "system", "message", "buffer", "menu", "summary", "log", "mon", "report", "monkey", "ai", "member", "sm", "console", "alert", "dm", "profile", "timeout", "stat", "mx", "state", "Monitor", "network", "meter", "chron", "sim", "display", "manager", "cm", "program", "trace", "config", "pool", "match", "lock", "tem", "loader", "status", "thread"], "buflen": [" bufleng", "bucollength", "buflens", "bullen", "bufleng", " bupleng", "bullength", "buglen", "buflun", "buclength", "bulllen", "buplength", "buglun", "buclens", "buplun", " buflength", " bufllen", " buflun", "buclen", " buflens", "bulleng", " buplength", "buglength", " buplens", "bupllen", "bucolllen", "buflength", "buplens", " buplun", "buclun", "bucolleng", "buplen", "bufllen", "buglens", "bucollen", " bupllen", " buplen", "bupleng"], "bytesRead": ["bytesNeed", "bytesFound", "bytesSend", "linesWrite", "itemsWrite", "BytesWrite", " bytesread", "tesFound", "blocksRead", "BytesFound", "tesRead", "bytesread", "BytesReader", "BytesSend", "tesWritten", "bytesWritten", "blocksNeed", "tesNeed", "linesRead", "bytesReader", " bytesFound", " bytesReader", "Bytesread", "itemsSend", "itemsReader", "BytesRead", "blocksWritten", "tesWrite", "blocksWrite", " bytesWrite", "itemsRead", "linesWritten", "tesread", " bytesSend", "linesNeed", "bytesWrite"], "buf": ["bar", "row", "wb", "orig", "buff", "b", "cap", "pkg", "mu", "batch", "lim", "block", "mem", "Buffer", "vec", "fb", "buffer", "uf", "log", "tab", "cur", "Buff", "seq", "window", "cmd", "bl", "cat", "txt", "act", "ctx", "ctr", "bag", "bin", "cam", "rb", "img", "tr", "br", "conv", "bed", "db", "ob", "cb", "cv", "bytes", "box", "msg", "prop", "bu", "arr"], "start": ["t", "stop", "sample", "end", "offset", "base", "sp", "name", "p", "rest", "st", "Start", "step", "init", "art", "state", "tmp", "first", "ptr", "delay", "size", "len", "time", "open", "duration", "ST"], "nRead": ["dnUpdate", "nCopy", "numReader", "nWritten", "ncWrite", "onWrite", "pnReader", "numWrite", " nDisplay", "nnReader", "NRead", "nnWrite", "nnUpdate", "pnCopy", " nWritten", " nReader", " nView", "dnRead", "cnDisplay", "pnRead", "onReader", "nReader", "numView", "nsDisplay", "ncReader", "nsWrite", " nRequest", "onCopy", "nsRead", "cnRead", "nUpdate", " nCopy", "cnWritten", "nView", "onRead", "nDisplay", "dnWrite", "numRead", "nnRequest", "nRequest", " nUpdate", "nsWritten", "ncView", "nnRead", "ncRead", "cnWrite", "NWrite", "NRequest", "dnReader", "pnWrite", " nWrite", "nWrite"]}}
{"id1": "14168494", "id2": "2113444", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpByte", " CopyFile", " copyStream", " cpStream", " cpfile", " copyfile", " CopyStream", " copyByte", "Copyfile", "CopyByte", " Copyfile", " CopyByte", "CopyStream", " cpFile", "CopyFile"], "dest": ["w", "orig", "Dest", "gt", "cont", "trans", "del", "way", "v", "rest", "master", "to", "doc", "temp", "out", "dist", "source", "np", "st", "www", "good", "etc", "origin", "img", "them", "usr", "nt", "tmp", "target", "nom", "des", "loc", "nw", "pub", "result", "dir", "d"], "src": ["sc", "upload", "sel", "rc", "cont", "ls", "desc", "ser", "sq", "ins", "req", "sl", "sub", "cur", "source", "rel", "st", "from", "rs", "start", "sb", "rx", "init", "iv", "sec", "input", "img", "usr", "sr", "sys", "Source", "inst", "file", "loc"], "srcChannel": ["sourceCh", "srcchannel", "srcPanel", "sqChannel", "srcCan", "sqCan", " srcCh", "rcCommand", "bgCan", " srcMessage", " srcChain", "instChan", "sysChannel", "srcCommand", "sqPanel", "destMessage", "sqChain", "sourceChan", "destChan", " srcchannel", "sysChan", "instPanel", "destChannel", "sourceChannel", "rcMessage", "bgPanel", "sysCommand", "srcCh", " srcChan", "syschannel", "bgChain", "instChain", "rcChannel", "srcChan", "rcchannel", " srcCommand", "rcChan", "instChannel", "instCan", "destChain", "srcChain", "instCh", "bgChannel", "rcChain", "srcMessage"], "dstChannel": ["dndChan", "ddestCh", " dotHandler", "ddestHandler", "ddestChannel", "dstCh", "dotChan", "pdestCommand", "dstHandler", "destClient", "dbrHandler", " dotChan", "dndCommand", " dstChan", " dstButton", "dndChannel", "dotHandler", "pstCommand", " dotCh", "dbrChan", " dstHandler", "pdestChannel", "dstChan", "destChannel", "dbrCh", "dstClient", "pdestButton", "dbrChannel", "dndButton", "dotChannel", "dstCommand", "ddestClient", "ddestChan", "destCommand", "pdestClient", "ddestCommand", "dndCh", "dotCh", " dotButton", "ddestButton", "destButton", "dstButton", "dotButton", "pstChannel", " dstCh", "pstClient", "dndClient", "pstButton", " dotChannel"]}}
{"id1": "11032546", "id2": "23452437", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"testCopyUnknownSize": [" testcopyKnownSize", " testCopyKnownLength", " testCopyunknownsize", " testCopyUnknownShape", " testcopyUnknownLength", " testcopyUnknownSize", " testCopyunknownSize", " testcopyUnknownsize", " testCopyKnownSize", " testcopyKnownShape", " testcopyKnownsize", " testCopyUnknownLength", " testCopyUnknownsize", " testCopyDifferentsize", " testCopyunknownShape", " testcopyUnknownShape", " testcopyKnownLength", " testCopyDifferentLength", " testCopyKnownsize", " testCopyKnownShape", " testCopyDifferentSize", " testCopyDifferentShape", " testCopyunknownLength"], "in": ["gin", "null", "up", "cin", "it", "on", "inf", "inn", "ind", "ain", "ins", "log", "rin", "l", "r", "al", "source", "IN", "mm", "from", "copy", "en", "inner", "isin", "bin", "con", "input", "sin", "din", "inv", "inside", "i", "data", "file", "is", "In"], "out": ["os", "null", "t", "err", "b", "gt", "end", "o", "a", "up", "aos", "it", "on", "gr", "or", "check", "list", "client", "obj", "to", "log", "outs", "by", "io", "one", "n", "res", "cmd", "user", "output", " OUT", "ex", "Out", "all", "con", "sum", "ou", "inv", "at", "OU", "auto", " Out", "OUT", "co", "data", "result", "net"], "cpySize": ["cplysize", "Cplysize", "cdySize", "cpeCount", " cpysize", "cpesize", "CpySize", "CplySize", "CpyLength", "CplyLength", "Cpysize", "cpeLength", "cdyLength", "cdyCount", "cpeSize", "cfiCount", "cplyCount", "cfiSize", " cpyLength", "cplyLength", " cplyLength", " cpyCount", " cplySize", " cplyCount", "cdysize", "CpyCount", " cplysize", "cfiLength", "cplySize", "cpysize", "CplyCount", "cpyLength", "cpyCount", "cfisize"], "outArray": ["OUTObject", " outString", "listString", " outObject", "neObject", " outImpl", "inArray", " outarray", "OUTarray", " outArea", "inImpl", "OUTStream", "nearray", "inArea", "neStream", "OUTArray", " outStream", "inString", "outObject", "listImpl", "outStream", "listArray", "listArea", "outImpl", "neArray", "outarray", "outString", "outArea"]}}
{"id1": "7169984", "id2": "18544890", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"connRemote": [" communicateLocal", " communicateRemote", " connBase", " connAsync", " connLocal", " validateRemote", " authLocal", " validateLocal", " authBase", " authRemote", " authAsync", " communicateAsync", " validateAsync", " validateBase", " communicateBase"], "jsonObject": ["jsonElement", " jsonobject", "xmlElement", "jsObject", "xmlObj", "xmlAst", " jsonArray", "JSONAst", "jsobject", "JSONObject", "JSONobject", "JSONObj", " jsonAst", "jsonObj", "jsonArray", "JSONArray", "jsonobject", "jsArray", "jsObj", "JSONElement", "jsonAst", " jsonObj", " jsonElement", "xmlObject"], "OPCode": ["Opcode", " OpName", "OPName", "OpType", " OPcode", " OPType", " OpCode", "OPType", " OPCause", "opcode", "OPCause", " OpCause", " OPData", "opData", " OPName", "OpName", "OPcode", "opCode", "opType", "OPData", " OpType", "OpCause", "OpCode", "OpData"], "retSrc": ["retNrc", "returnSetcr", "retSetRC", "retNRC", " retInsRC", "returnScr", "RetStrRC", "retSrs", " retInsource", "RetSrc", "RetSRC", "RetStrrs", "returnSetsrc", "RetSrs", "retAsrs", "retRsource", "retNsrc", " retInssrc", "returnSetRC", "returnSRC", "retAssrc", "retInsrc", "RetStrsrc", "retSetsrc", "retSsrc", "retRsRC", "retInscr", "returnSsrc", "retScr", "retSetrc", "retStrrs", "RetSsrc", " retSource", "retSetcr", "retRsrc", "retInsrs", "retRssrc", "retSource", "retAsRC", "returnSetrc", "RetStrrc", "retInsRC", "retInssrc", "retStrsrc", "retAsrc", "retInsource", "retNcr", "retStrrc", "retStrRC", " retSRC", " retSsrc", "returnSrc", " retInsrc", "retStrource", "retSRC"], "httpClient": ["HttpConnect", " httpSystem", "ttpSystem", " httpNet", "HttpSystem", "upperClient", "ttpStore", " httpStore", " httpGe", "httpStore", "httpSystem", "upperNet", "upperCo", " httpConnect", "ttpClient", "healthCo", "ttpConnect", " httpCo", "httpNet", "healthGe", "HttpClient", "httpConnect", "HttpStore", "healthClient", "healthNet", "upperGe", "httpGe", "httpCo"], "httpPost": [" httppost", "ttppost", "httpsPOST", "hoverPre", "hoverPOST", "httppost", "HTTPPOST", " httpPOST", "httpPut", "ttpPOST", "httpsPress", " httpPut", " httpPre", "ttpPre", "healthPost", "ttpPost", "HTTPPut", " httpPress", "HTTPpost", "healthPOST", "httpPOST", "hPost", "ttpPut", "httpPre", "HTTPPost", "hPOST", "hoverpost", "hpost", "healthPress", "hoverPost", "httpPress", "httpsPost"], "httpParams": [" httpPargs", "httpPrps", "ttpParars", "httpPrgs", "ttpPrars", " httpParms", "ttpPrams", "httpPps", "httpparars", "httpPrars", "httpPrms", "httpPars", "httpPgs", "httpParms", " httpPams", "httpPms", "ttpParms", "httpparms", " httpParants", "httpSharms", "httpSharams", "httpParars", "ttpParams", "httpParants", " httpPms", "httpPants", "ttpPrps", "httpparps", "httpParps", "httpPargs", "httpSharants", "ttpPrms", " httpPants", "httpPrams", "httpPams", "ttpParps", "httpparams", "httpPrants", " httpPgs", "httpShargs"], "nameValuePair": ["nameKeyParair", "nameValuespair", "nameValueParatch", "nameValueParpair", "nameValuepeter", "nameKeyPpair", "nameValuePersair", "nameValuePareter", "nameValuePeter", "nameValuepair", "nameValuesPairs", "nameNameParair", "nameValuePartatch", "nameValuePariece", "nameValuePerspair", "nameKeyPairs", "nameValuesPiece", "nameKeyParairs", "nameValueParairs", "nameValueParair", "nameValuepiece", "nameKeyParpair", "nameValuePerseter", "nameValuePairs", "nameNamePair", "nameNameParatch", "nameValuePointpair", "nameValuespairs", "nameKeyPeter", "nameNameParpair", "nameValuePointair", "nameValuePpair", "nameValuesPair", "nameKeyPareter", "nameValuePointairs", "nameValuePatch", "nameValuesppair", "nameValuePiece", "nameValuePointiece", "nameKeyPair", "nameValuePersairs", "nameValuepairs", "nameValueppair", "nameValuePartair", "nameValuePartpair", "nameValuespiece", "nameValuesPpair", "nameNamePatch", "nameValueChair", "nameValueChpair", "nameValuepatch", "nameValueChairs", "nameNamePpair"], "response": ["answer", "resp", "document", "object", "onse", "e", "block", " responding", "message", "connection", "image", "sequence", "social", "report", "service", "cache", "request", "respond", "still", "res", "application", "output", "given", "entity", "tree", "reply", "network", "Response", "body", "next", "json", "relation", "trace", "frame", "description", "xml", "data", "view", "entry", "command", "result"]}}
{"id1": "5138455", "id2": "8788371", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"save": ["paste", " append", "upload", " Save", "gc", "dump", " swap", " paste", "Copy", "store", " restore", " move", "Save", "to", " seal", "write", " upload", " clone", "copy", " merge", " recover", " persist", " dump", " store", "clone", " insert", " set", "load"], "bytes": ["was", "words", "binary", "bs", "b", "aws", "Bytes", "ents", "odes", "tes", "its", "bps", "trans", "raw", "es", "ies", "seconds", "values", "amps", "blocks", "bits", "pieces", "lines", "bles", "ces", "gs", "ses", "gb", "loads", "rs", "some", "unks", "steps", "terms", "parts", "gets", "classes", "reads"], "outputFile": [" outputFiles", "referenceFiles", "inputFilename", "tempPath", "outputFiles", "outputPath", "inputPath", " outputPath", "outFile", "tempDir", "outFilename", "referenceFile", "referenceDir", "tempfile", "referenceFILE", "tempFile", " outputFilename", "outputDir", "inputFile", "OutputPath", "outPath", "outputfile", " outputDir", "OutputFile", "outputFILE", "OutputDir", "Outputfile", "inputfile", "inputDir", "OutputFiles", "outputFilename", "outDir", "OutputFILE", " outputFILE"], "in": ["gin", "m", "im", "include", "read", " din", "mc", "mi", "up", "cin", "it", "raw", "on", "ini", "inf", "inn", "ind", "id", "ze", "ins", "l", "rin", "f", "io", "r", "by", "print", "inc", "al", "reader", "source", "pre", "st", "from", "mm", "IN", "act", "iter", "en", "inner", "isin", "bin", "ie", "con", "input", "ri", "sin", "din", "i", "inside", "xml", "is", "In"], "out": ["full", "os", "cn", "null", "t", "fn", "b", "end", "ot", "o", "aos", "it", "on", "client", "v", "writer", "can", "obj", "to", "outs", "l", "log", "stable", "io", "op", "print", "write", "cache", "n", "res", "output", " OUT", "Out", "page", "screen", "nt", "outer", "ou", "i", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"]}}
{"id1": "4830847", "id2": "3767903", "code1": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"deleteJvmStatistics": ["deleteJmxStat", "deletejvmStats", "deleteJmData", "deleteJmStat", "deleteJmxStatistics", "deleteJvmData", "deleteJvmStat", "deletejvmStatistics", "deleteJVMStats", "deletejvmStat", "deleteJVMStat", "deletejmxStats", "deleteJmxStats", "deleteJmStatistics", "deletejmxStatistics", "deleteJvmStats", "deleteJmStats", "deleteJVMStatistics", "deletejvmData", "deletejmxData", "deletejmxStat", "deleteJVMData", "deleteJmxData"], "contextName": ["subjectName", "eventFrom", " contextTitle", "ContextDefault", "componentCommon", "classTitle", "subjectNAME", " contextCode", "contextCommon", "conceptInstance", "contextNames", "contextInstance", "componentCode", "ContextFrom", "subjectname", "eventDefault", "ctxCode", "ctxNAME", "conceptTitle", "contextTitle", "contextname", "ctxCommon", "classInstance", "ContextNames", " contextFrom", "ctxName", " contextname", " contextDefault", "contextCode", " contextNames", "classFrom", "className", "contextDefault", "conceptFrom", "conceptName", " contextInstance", "subjectCommon", "contextNAME", "contextFrom", "eventNames", "componentNAME", "componentname", "ctxname", "ContextName", "eventName", "componentName"], "dateFrom": ["resourceFrom", "datBefore", "dateAn", "numberStart", "dateStarting", "dayAn", "datefrom", "gradeBefore", " dateAn", "noteStart", "dateInitial", "datFrom", "dayStarting", "dateFor", "gradeFrom", "dayFor", "noteWithout", "dayStart", "gradefrom", "notefrom", " dateStart", " dateFor", "gradeWithout", "noteFrom", "dayFrom", "dayWithout", "numberFrom", "dateStart", "numberInitial", "gradeStart", "datAn", "dayInitial", "dayfrom", "dateWithout", "resourceStart", "resourceInitial", "resourceBefore", " dateStarting", "numberBefore", " dateBefore", "gradeStarting", "dateBefore", "datFor", "dayBefore"], "dateTo": ["ageLater", "ageToo", "DateFrom", "ageTo", "userTo", "ageTO", "DateUntil", "tradeTO", "userTO", "dayto", "tradeTo", "timeTo", "timeTarget", "DateTarget", " dateToo", "dayTO", "Dateto", "dateLater", "DateToo", "dateto", "dayTo", " dateTO", "DateTO", "dataTo", "tradeToo", "dataTO", "dataFrom", "dateTO", " dateUntil", " dateTarget", "tradeTarget", " dateLater", "dateUntil", "timeto", "dateToo", "DateTo", "dateTarget", "userLater", "timeTO", "dataUntil", "dayTarget", "userToo"], "connection": ["creator", "link", "table", "handler", "close", "c", "document", "ion", "engine", "statement", "driver", "reference", "condition", "socket", "system", "Connection", "client", "this", "resource", "directory", "context", "writer", "password", "reader", "pointer", "conn", "operation", "application", "function", "con", "instance", "server", "network", "current", "database", "session", "relation", "query", "manager", "communication", "db", "pool", "connect", "config", "auto", "response", "handle", "command", "collection"], "queryString": [" queryStatement", "qList", "gateSQL", "queryInt", "QuerySite", "qString", "questionSite", " querySQL", "QuerySet", "commandStr", "commandString", " queryStr", "commandstring", "readSocket", "scanChain", "questionModel", "errorQuery", "quQueue", "querySocket", "formQueue", "executeInt", "QueryDescription", "questionString", "responseQueue", "commandStatus", "gateSystem", "queryDescription", "questSocket", "QueryString", "queryStr", "responseString", "gatestring", "querySystem", "quQuery", "quString", "commandSet", "commandSystem", "queryStatement", "sqlName", "executeString", "QueryInt", "commandStatement", "queryName", "sqlStr", "queryQuery", "questString", "qChain", "QueryStr", "sqlString", "loadSQL", "queryQueue", " queryName", "questSystem", "formList", "commandSocket", "queryModel", "readSQL", "QueryStatement", "gateString", "sqlStatus", "questionQueue", "formChain", "quSite", "readString", " querySet", " queryQueue", "responseQuery", "querystring", "executeStr", "querySQL", " queryDescription", "scanString", "queryBegin", "scanQueue", "executeSite", " querySite", "quModel", " queryStatus", "errorString", "loadQueue", "sqlStatement", " querySocket", " queryInt", "errorBegin", "errorQueue", "formString", "qQueue", "queryList", "responseBegin", "commandName", " queryModel", "querySet", "quBegin", "queryChain", "loadString", "sqlDescription", "queryStatus", "queststring", "scanList", "querySite", "quSQL", "gateSocket"], "preparedStatement": ["preparedQuery", "prefetchedQuery", "PREparedQuery", "prefetchedstatement", " preparedProgram", "preparableStatement", "PrearedQuery", "prefreshSQL", "prefixedStatus", "prefreshQuery", "prefreshCommand", "prearedCDC", "programparedStatus", "preparedToken", "preferredCDC", "preferredStatement", "prefixedSQL", "preparableSQL", "prearedProgram", "PREferredCDC", "preressedstatement", "prearedStatement", "prefixedStatement", "previousProgram", "preressedQuery", "programparedSQL", "programparedMessage", "PreparedQuery", "preparableStatus", "PreparedStatement", "preferredProgram", "prerecordedMessage", "preciseStatement", "preparedStatus", "prearedQuery", "preededComment", "preparedCDC", "prepparedCommand", "programrecordedSQL", "prefixedQuery", "prerecordedSQL", "PREparedStatement", "PREferredstatement", "preciseQuery", "prefixedComment", "programrecordedStatement", "preparedProgram", "preressedCDC", "prearedComment", "programrecordedMessage", "prefreshStatement", "PREferredQuery", "prepparedGrant", "preparedSQL", "prearedSQL", "prerecordedStatus", "preededStatement", "PREparedCDC", "programrecordedStatus", "prefetchedGrant", "preressedStatement", "premediatedQuery", "preciseCommand", " preparedQuery", "prerecordedStatement", "PrearedToken", "prearedGrant", " previousProgram", "PrearedStatement", "PrearedComment", "premediatedGrant", "previousQuery", "prearedCommand", "preparedMessage", "prepparedQuery", "preededQuery", "preferredstatement", "PREparedstatement", "preparedstatement", "preciseSQL", "preferredQuery", "PreparedToken", "PREferredStatement", "prepparedSQL", " previousStatement", "prefetchedStatement", "prepparedStatement", "premediatedstatement", "preparedCommand", "programparedStatement", "preededToken", "prefixedToken", "prearedToken", "premediatedStatement", "prepparedstatement", "preparedComment", "prearedstatement", "previousStatement", " previousQuery", "preparedGrant", "prefixedMessage", "preparableMessage", "PreparedComment"], "indexCounter": ["conditionWriter", "indexController", "Indexcounter", "caseER", "methodCounter", "IndexNumber", " indexcounter", "mixWriter", "conditionBER", "queryCounter", "indexChain", "equHelper", "queryManager", "seeTER", "issueController", "viewTER", "indcounter", "indexTER", "dimensioncounter", "columnCounter", "indexVector", "indexIterator", "attributeCounter", "issueCounter", " indexWriter", "seeChain", "caseCounter", " indexController", "seeHelper", " indexBER", "positionWriter", " indexConsumer", "positionCounter", "methodListener", "mixTER", "indexCount", "xListener", "attributeHelper", "issueHelper", "equChain", "issueCount", "seeListener", "dimensionTER", "equTER", "indexManager", "indexListener", "positionTER", "methodVector", "dimensionIterator", "columnIterator", "seeVector", " indexIterator", "viewCounter", "mixCounter", "levelCounter", "IndexCount", "accessManager", "equCounter", "methodConsumer", "indexMaker", "indER", "indManager", "caseMaker", "issuecounter", "accessER", "columncounter", "indexWriter", "attributeCount", "seeConsumer", "indexHelper", "indexcounter", "xConsumer", " indexTER", "issueTER", "indCount", "indCounter", "viewManager", "seeCounter", "dimensionCounter", "indexBER", "conditionTER", "queryTER", "xCounter", "IndexController", "caseManager", "conditionCounter", " indexAdapter", "indNumber", " indexNumber", "mixBER", "positionConsumer", "issueChain", "columnTER", "indMaker", "indexConsumer", "levelHelper", "xVector", " indexManager", "levelCount", "accessCounter", " indexCount", "indexAdapter", "indexNumber", " indexHelper", "IndexCounter", "accessMaker", "levelAdapter", "attributeAdapter", "conditionConsumer", "indexER"]}}
{"id1": "21125261", "id2": "838844", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"test": ["train", "t", "read", "testing", "sample", "fit", "run", "evaluate", "unit", " evaluate", "feature", "example", "T", " sample", " tests", "debug", "server", "launch", "show", "Test", "tests", " testing", "execute", "hello", "load", "volt"], "is": ["os", "sis", "sit", "ms", "in", "bs", "us", "ws", "ls", "lis", "ios", "stream", "has", "isi", "its", "tis", "isc", "es", "ps", "s", "does", "ai", "out", "fs", "mis", "rs", "input", "ri", "ris", "iso", "xs", "i", "sys", "as", "IS", "xml", "Is", "ais", "serv", "isa", "are"], "byteArrayOutputStream": ["byteStringoutputStream", "byteArrayInputForm", "byteStringOutputStream", "byteArrayInputView", "byteArrayOutputView", "byteArray4String", "byteArrayByteSteam", "byteStringOutputString", "byteStringOutputForm", "byteArrayApplicationStream", "byteStringInputSteam", "byteArrayApplicationSteam", "byteStringInputStream", "byteArrayInputSteam", "byteStreamOutputStyle", "byteStringoutputForm", "byteArrayInputStream", "byteStringoutputString", "byteArrayOutputSteam", "byteStringOutputView", "byteArrayApplicationStyle", "byteArrayOutputForm", "byteArrayoutputStream", "byteStreamInputStyle", "byteArrayoutputString", "byteArrayoutputForm", "byteStringInputString", "byteStreamOutputSteam", "byteArray4Stream", "byteStreamInputSteam", "byteStringOutputSteam", "byteStringInputView", "byteStreamOutputStream", "byteArray4Steam", "byteArrayApplicationForm", "byteArrayInputStyle", "byteArrayOutputStyle", "byteStreamInputForm", "byteArrayByteForm", "byteStreamInputStream", "byteStringoutputSteam", "byteArrayByteString", "byteStreamOutputForm", "byteArrayByteView", "byteArrayByteStyle", "byteArrayOutputString", "byteArrayoutputSteam", "byteArrayInputString", "byteArrayByteStream", "byteArray4View"], "def": ["dict", "det", "df", "d", "Def", "dal", "default", "definition", "dem", "desc", "DEF", "decl", "cd", "md", "dec", "pro", "sd", "DE", "define", "de", "sche", "dev", "ds", "conf", "ef", "Definition", "json", "ded", "db", "hd", "des", "defined", "dl", "da", "crit", "del"], "se": ["ene", "ase", "ade", "parse", "sem", "spe", "ee", "sel", "ode", "ge", "engine", "ste", "be", "e", "su", "ide", "ser", "es", "she", "sp", "ce", "ine", "ane", "ze", "ae", "sl", "ve", "sed", "ese", "ses", "sd", "Se", "me", "pe", "de", "see", "set", "sche", "ense", "sea", "ie", "sec", "sa", "le", "pse", "te", "ke", "he", "SE", "so", "ne", "we", "est"], "linkId": ["connectionIdent", "linkid", "lineid", "chainIdent", " linkid", "chainId", "linkName", "linkedId", "linkedID", " linkID", "lineId", "Linkid", "linkIdent", "LinkName", "lineID", " linkName", "lineName", "linkedIdent", "chainID", "connectionId", "connectionID", "LinkID", "linkID", "LinkId"], "segmentId": ["begmentById", "sementid", "segementid", "segroupById", "begmentId", "sementRef", "begmentName", "segmentById", "idegementName", "segementId", "segementName", "idegmentId", "begmentID", "segmentRef", "semissionId", "idegementRef", "segementID", "segroupId", "segmentid", "segmentName", "idegmentid", "begroupId", "semissionid", "segementById", "idegmentRef", "begroupById", "sementID", "semissionRef", "segementRef", "begroupName", "segmentID", "sementById", "sementId", "sementName", "idegementId", "semissionName", "segroupID", "idegmentName", "segroupName", "idegementid", "begroupID"], "linkSegments": ["linkParments", "linkConnectroups", "linkPargments", "linkGgments", " linkSegroups", "linkThreadments", "linkThreadlements", "linkSeables", "linkThreadroups", "linkConnectlements", "linkFragment", "linkConnectets", "linkSegroups", "linkFragments", " linkGgments", "linkBuildables", "linkThreadgments", " linkSegables", " linkBuildments", "linkSements", "linkSeggments", "linkBuildments", "linkConnectments", "linkConnectables", "linkFraggments", "linkGment", "linkBuildroups", "linkSeglements", " linkThreadroups", " linkSeggments", "linkFragroups", "linkBuildment", " linkSegment", "linkBuildets", " linkBuildables", " linkBuildgments", "linkGroups", "linkSeets", "linkParroups", "linkConnectgments", "linkBuildgments", " linkSeglements", "linkSegables", "linkParlements", " linkThreadlements", " linkGments", "linkGments", "linkSegment", " linkGroups", "linkSegets", " linkGment", " linkSegets", " linkThreadments", " linkBuildets", " linkThreadgments"], "segments": ["sectors", " seges", " Seges", " sevals", "vements", "usegins", " sements", "bevals", "parsements", "megins", "segins", "mements", "vegments", "segs", " selements", "parselements", " Segments", " Sements", "seges", "usements", "beges", "parsectors", " segs", "parsegments", "usegments", " Sevals", "megs", "sements", "bements", " segins", "velements", "usegs", "selements", " sectors", "begments", "megments", "sevals", "vectors"], "frameProperties": ["framePropps", " frameByptions", " frameByilities", " frameProptions", "framePrrics", "frameParrics", " framePrperties", "frameComptions", "frameParperties", "frameComrics", " framePrps", "frameParptions", "frameProfptions", " frameProps", "frameComperties", "frameProrics", "frameProfps", " frameByperties", "framePrps", "frameByilities", " frameProrics", "frameProfperties", "frameProptions", "frameProilities", "framePrptions", "framePropptions", "frameProps", "frameParps", "framePropperties", "frameByps", "frameProfilities", "framePropilities", "frameComps", " framePrrics", " framePrptions", " frameProilities", "frameByptions", "frameByperties", " frameByps", "framePrperties"], "time": ["tim", "tt", "before", "each", "counter", "t", "length", "ime", "total", "runtime", "think", "speed", "timer", "version", "value", "etime", "check", "count", "now", "system", "rate", "message", "context", "sequence", "ts", "estamp", "frequency", "trust", "depth", "transform", "x", "window", "date", "set", "start", "step", "Time", "timeout", "distance", "clock", "money", "slow", "second", "point", "times", "trace", "delay", "task", "size", "tx", "year", "event", "duration", "TIME"], "vehicle": ["vehICLE", "verocity", "yardicle", "Vehocity", "yardogram", "verticle", "venticle", "heroICLE", "vertocity", "vehicles", "heroicle", "vehic", "verticles", "verogram", "survendor", "yardendor", "venticles", "Vehicle", " vehICLE", "heroocity", "vertic", " vehicles", "Vehicles", "survocity", "Vehic", "VehICLE", "vehendor", "heroicles", "vehocity", " vehocity", "yardocity", "survicle", "vericle", "ventocity", "vehogram", "verendor", "survogram", "ventic"]}}
{"id1": "18005010", "id2": "5441579", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 0, "substitutes": {"setProfile": ["SETProperty", "storeProf", "SETProf", "storeDefault", "setProf", "SETDefault", "setDefault", "storeProperty", "SETProfile", "storeProfile", " setProperty", " setProf", " setDefault", "setProperty"], "loginName": ["displayKey", "loginNames", "fileName", " loginname", "loginname", "displayname", " loginNames", " loginKey", "displayName", "displayNames", "loginKey", "fileNames", "fileKey", "filename"], "profile": ["memory", "project", "details", "usage", "prof", "photo", "note", "update", "Profile", "picture", "sample", "FILE", "table", "document", "option", "property", "username", "base", "line", "mem", "history", "settings", "client", "role", "p", "buffer", "context", "summary", "port", "report", "plot", "password", "log", "account", "feature", "user", "output", "title", "pty", "style", "template", "position", "properties", "json", "pse", "relation", "hash", "config", "pool", "face", "frame", "header", "data", "panel", "policy", "phone", "result"], "outStream": [" outWriter", "servSteam", " outstream", "OutStream", "outputSteam", "outFile", "aosPoint", " outView", "OutWriter", "outView", "OutView", "offstream", "outputstream", " outFile", "servStream", "outPoint", "Outstream", "exWriter", "offWriter", "aosSteam", "offStream", "aosStream", "outputFile", "aosWriter", "OutSteam", "exSteam", "offSteam", "servView", "outSteam", "outputStream", "outWriter", "outputView", "exStream", "exPoint", "OutFile", " outSteam", "servstream", " outPoint", "outstream"], "url": ["pl", "re", "bel", "ur", "http", "email", "parse", "link", "https", "path", "ls", "get", "base", "host", "build", "address", "client", "resource", "uri", "l", "f", "r", "nl", "service", "q", "str", "org", "rel", "impl", "mount", "location", "ssl", "string", "char", "li", "Url", "mail", "abs", "web", "html", "xml", "loc", "dl", "ll", "open", "cert", "URL", "browser"], "file": ["info", "File", "null", "ile", "email", "binary", "FILE", "link", "table", "document", "fp", "path", "base", "name", "image", "resource", "port", "library", "print", "f", "report", "out", "local", "output", "page", "tree", " File", "template", "lf", "body", "le", "web", "db", "pool", "entry", "format", "download", "filename", "result"], "connection": ["nc", "computer", "dial", "sql", "link", "close", "c", "ion", "statement", "character", "cone", "condition", "established", "socket", "system", "Connection", "client", "resource", "directory", "bo", "to", "pointer", "conn", "number", "connected", "created", "still", "application", "console", "no", "con", "position", "network", "database", "session", "relation", "web", "communication", "city", "connect", "online", "closure", "response", "channel", "generation", "open", "command", "net"], "writer": ["editor", "processor", "creator", "storage", "counter", "rw", "written", "w", "fn", "handler", "WR", "variable", "document", "wright", "journal", "ner", "ws", "driver", "worker", "maker", "wrote", "iterator", "client", "buffer", "usher", "er", "riter", "runner", "wrapper", "writing", "flush", "owner", "reader", "commit", "write", "window", "node", "function", "widget", "inner", "caster", "operator", "writers", "word", "network", "writ", "outer", "walker", "draw", "Writer", "wa", "println", "wt", "external", "comment", "entry", "format", "loader", "liner", "event", "builder"], "myEnum": ["myAcom", "myEncumb", "myenum", "myEnumb", "myenumb", "myEnom", "myEncum", "someENUM", "myenom", "myENUM", "myEncUM", "myEncom", "myAnums", "myENum", "myENumb", "someEnum", " myEnums", "myEnUM", " myAnum", " myEnet", "myAnumb", "myENom", " myEnom", " myAnom", " myAnums", "someENumb", "myAcum", "someEnumb", "myENet", "someENums", "myAcet", " myENumb", "myAnom", " myAnet", "myAnum", "myAnet", " myENum", "myENums", "someEnums", "someENum", "myEnet", "myAnUM", "someEnUM", " myENom", "myAcums", " myEnumb", "myEncums", "myEnums"], "key": ["info", "ace", "m", "row", "item", "note", "column", "ek", "mac", "variable", "val", "a", "host", "base", "prefix", "pair", "it", "ice", "value", "part", "parent", "cond", "cell", "name", "id", "v", "bo", "primary", "owner", "element", "k", "var", "member", "one", "str", "n", "node", "pe", "no", "test", "ex", "child", "step", "title", "keys", "string", "token", "word", "KEY", "char", "air", "index", "i", "hash", "Key", "type", "field", "entry", "label", "text", "chain", "col", "attribute"]}}
{"id1": "5759961", "id2": "18974466", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"saveUser": [" enrichAccount", " manipulateGroup", "saveuser", " saveuser", "saveGroup", " manipulateUser", " enrichuser", " enrichUser", " enrichGroup", "saveAccount", " saveAccount", " saveGroup", " manipulateAccount", " manipulateuser"], "user": ["record", "info", "project", "row", "usage", "u", "person", "item", "email", "per", "update", "table", "responsible", "rule", "object", "us", "url", "get", "username", "base", "ver", "add", "e", "or", "version", "User", "used", "store", "use", "name", "client", "message", "this", "v", "post", "login", "owner", "password", "report", "print", "by", "content", "account", "write", "me", "test", "uid", "ro", "USER", "profile", "create", "replace", "load", "word", "server", "usr", "char", "actor", "force", "data", "file", "response", "job", "entry", "author", "cert", "human", "auth", "result"], "digest": ["digse", "readested", "compests", "Digse", "Digested", "readse", "digested", "compress", "mdest", "digester", "hashester", "readest", "digests", " digress", "hashress", "compested", "mdested", "DigEST", "hashested", "hashest", "hashEST", "compest", " digested", " digse", "mdse", "hashests", " digEST", "readester", "digress", "mdester", "Digest", "Digester", "digEST", " digester", " digests"], "hash": ["full", "handle", "hex", "mac", "h", "has", "uh", "add", "ash", "version", "block", "check", "sh", "count", "id", "dig", "password", "cache", "number", "mask", "height", "ashes", "test", "init", "search", "char", "sha", "Hash", "hed", "index", "sum", "num", "tag", "html", "her", "size", "type", "max", "key", "rh", "result"], "bigInt": ["BigInteger", " bigLong", "littleint", "bigInteger", "littleInt", " bigint", "littleINT", "pgInt", "pgint", "bigINT", "hugeInteger", "BigLong", "BigInt", "bigint", "hugeInt", "longint", "hugeLong", "bigLong", " bigInteger", "Bigint", "pgINT", "longINT", "longInt", "hugeint"], "hashtext": ["ashtext", " hashstr", "Hashfunction", "ashText", "hashinfo", " hashinfo", "shatext", "hashpath", "ashstr", "hexText", "Hashstr", "Hashinfo", "hashtxt", " hashvalue", "hexvalue", " hashtxt", "shavalue", "ashtxt", "hashfunction", "hexread", "sumstr", "hashstr", "hexpath", " hashfunction", "hashread", " hashread", "ashread", "hashvalue", "hextext", "hashText", " hashText", "sumtext", "shaText", "sumpath", "shatxt", "HashText", "sumfunction", "sumText", "ashinfo", "hextxt", "Hashpath", "Hashtext"]}}
{"id1": "1180878", "id2": "14598566", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchStringdata", "fectUrldata", "fetchUrlStream", "fetchStringStream", "fetchURLFrame", "fectUrlStream", "fetchURLStream", "fetchGETdata", "fectURLFrame", "fectURLStream", "fectUrlData", "fectURLdata", "fetchGETFrame", "fectUrlFrame", "fetchStringFrame", "fetchURLdata", "fectURLData", "fetchUrldata", "fetchGETData", "fetchUrlFrame", "fetchGETStream", "fetchUrlData", "fetchStringData"], "url": ["full", "pl", "domain", "sql", "ur", "null", "http", "link", "b", "https", "path", "ref", "ls", "host", "base", "default", "lim", "gl", "address", "name", "resource", "uri", "l", "log", "sl", "print", "nl", "cl", "rel", "mount", "location", "ssl", "string", "pattern", "Url", "mail", "web", "html", "ul", "el", "xml", "file", "loc", "dl", "ll", "URL"], "proxyHost": ["proxyUrl", "slaveLabel", " proxyCheck", "roxyOver", "serverHost", " proxyOver", "slaveAddress", " proxyhost", "serverName", "proxyOver", "roxyhost", "Proxyhost", "proxyLabel", "roxyHost", "proxyhost", "ProxyHost", "roxyLabel", "ProxyPort", "roxyCheck", "roxyUrl", "roxyAddress", "ProxyLabel", "proxyName", "ProxyName", " proxyAddress", " proxyName", "slaveCheck", "slaveUrl", "ProxyUrl", "proxyAddress", "serverhost", "slavehost", "proxyCheck", "serverPort", "slaveHost", "slaveOver"], "proxyPort": ["serverport", "aliasAddress", "Proxyport", "aliasHost", "serverHost", "aliasport", "ProxyHost", "ProxyPort", " proxyport", "serverPORT", "proxyport", " proxyAddress", " proxyPORT", "proxyPORT", "serverAddress", "ProxyPORT", "proxyAddress", "aliasPort", "serverPort"], "con": ["nc", "non", "cn", "go", "dial", "po", "close", "cal", "c", "un", "cont", "gate", "pen", "xc", "mc", "syn", "open", "ver", "cone", "func", "trans", "pan", "cc", "ocon", "Con", "cp", "cond", "cover", "client", "connection", "cs", "bo", "ain", "can", "call", "conn", "cur", "Conn", "sub", "proc", "rec", "ln", "cf", "cmd", "cat", "fc", "ex", "pc", "act", "en", "comm", "conf", "don", "conv", "com", "CON", "fac", "connect", "canon", "col", "co", "cgi", "ran", "lock", "mo", "cons", "cos", "bc", "fin", "ctrl", "const"], "is": ["was", "os", "ms", "sis", "isl", "im", "eps", "in", "bs", "us", "ios", "lis", "has", "its", "isi", "isc", "es", "ps", "iss", "ists", "cs", "ts", "ains", "isp", "ins", "s", "isf", "bits", "ois", "dis", "fs", "mis", "ist", "iris", "iter", "ip", "rs", "init", "isin", "si", "ri", "ris", "ys", "iso", "xs", "oss", "i", "abs", "sys", "as", "Is", "IS", "gets", "ais", "ims", "bis", "isa", "are"], "u": ["ur", "mu", "un", "c", "us", "ut", "o", "pu", "up", "su", "lu", "au", "ui", "uv", "uf", "hu", "uri", "uu", "yu", "fu", "g", "tu", "nu", "iu", "U", "ru", "uid", "user", "uj", " nu", "cu", "ou", "i", "ul", "eu", "uni", "ue", "ud", "bu"], "proxy": ["shadow", "project", "echo", "go", "domain", "cas", "null", " proxies", "zip", "po", "PRO", "http", "link", "https", "host", "base", "cone", "pi", "Proxy", "version", "XY", "socket", "cp", "phone", "slave", "address", "client", "connection", "port", "bo", "ping", "map", "password", "library", "pin", "pointer", "cache", "pro", "x", "pre", "pe", "aco", "profile", "ip", "timeout", "ssl", "alias", "xy", "token", "jp", "server", "gp", "pipe", "pse", "prime", "embed", "web", "friend", "via", "roxy", "pool", "py", "translation", "policy", " prox", "browser"], "baos": [" bao", "naos", "BAo", "BAos", " baows", " baOS", "baows", "poos", "nao", "vaos", "aoos", " baose", "BAOs", "vaoS", " baoss", "baoss", " baOs", "bao", "aoOS", "vaOS", "poOs", "vais", "poo", " bais", "baose", " baoS", "aois", "BAoss", "BAose", "baOs", "poose", "naoss", "naows", "BAows", "aooS", "bais", "baoS", "baOS"]}}
{"id1": "2518655", "id2": "15580610", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"fnOut": [" fnOr", "pdfNet", "synOut", "fnOs", "bfOut", "dnOut", "fnIn", "bfIn", " fnOs", "fnNet", "synIn", "synOr", "pdfOut", "dnOutput", "dnIn", "fnOr", "dnOr", " fnNet", "synOutput", "fnOutput", "bfOs", "pdfIn", " fnIn", " fnOutput", "bfNet", "pdfOs"], "writer": ["editor", "creator", "send", "written", "w", "fn", "table", "handler", "variable", "close", "zero", "wright", "journal", "driver", "aster", "worker", "maker", "width", "client", "buffer", "runner", "riter", "master", "wrapper", "print", "writing", "rator", "reader", "flush", "commit", "report", "write", "service", "window", "console", "widget", "caster", "inner", "operator", "and", "writers", "writ", "outer", "walker", "her", "Writer", "println", "auto", "file", "external", "comment", "parser", "format", "loader", "white", "builder"], "i": ["m", "ci", "u", "im", "phi", "j", "gi", "ii", "gu", "c", "qi", "my", "I", "us", "mi", "key", "ti", "batch", "ogi", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "client", "y", "v", "multi", "ic", "uri", "ai", "\u0438", "q", "x", "g", "me", "iu", "bi", "ip", "init", "si", "ie", "ij", "ki", "ri", "sim", "li", "ix", "ma", "xi", "is", "ims", "ei", "chain"], "fInput": ["cfNew", " finput", "linput", "sfIn", "fileIn", "sfInput", "fNew", "fileinput", "sfOutput", "cfInput", " fIn", "lOutput", " fOutput", "fileOutput", "lNew", "cfOutput", "sfinput", "fOutput", "finput", "lInput", " fNew", "cfinput", "fIn", "fileInput"], "in": ["gin", "info", "re", "t", "vin", " din", "thin", "cin", "it", "or", "ini", "inf", "check", "inn", "ind", "client", "ins", "rin", "r", "kin", "pin", "inc", "out", "al", "n", "ln", "IN", "en", "isin", "bin", "inner", "all", "again", "input", "conf", "con", "sin", "din", "conv", "ma", "inside", "is", "serv", "In"]}}
{"id1": "20190303", "id2": "8486429", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_noTog", "test01_ok_failed_500_No_Log", "test01_ok_failed_500_no___lim", "test01_ok_failed_500_no___og", "test01_ok_failed_500_no_log", "test01_ok_failed_500_noTLog", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_no_lim", "test01_ok_failed_500_no___Log", "test01_ok_failed_500_noTlog", "test01_ok_failed_500_No_og", "test01_ok_failed_500_no_og", "test01_ok_failed_500_No_log", "test01_ok_failed_500_No_lim", "test01_ok_failed_500_noTlim", "test01_ok_failed_500_no___log"], "client": ["tc", "api", "http", "handler", "close", "c", "https", "url", "secure", "prefix", "system", "cell", "connection", "context", "resource", "control", "wrapper", "call", "cache", "service", "cl", "conn", "window", "console", "cmd", "local", "cli", "google", "ssl", "template", "con", "server", "session", "manager", "cm", "city", "config", "force", "connect", "pool", "co", "channel", "remote", "contact", "loader", "Client", "cert", "collection"], "post": ["mod", "row", "feed", "send", "upload", "http", "read", "parse", "POST", "submit", "url", "get", "add", "valid", "ost", "ps", "p", "op", "write", "put", "request", "pre", "test", "set", "create", "Post", "copy", "save", "and", " Post", "body", "pod", "json", "posts", "form", "wp", "dd"], "response": ["info", "answer", "re", "feed", "pos", "http", "sample", "resp", "document", "onse", "get", "soc", "version", "block", "value", "message", "connection", "service", "respond", "example", "res", "application", "respons", "user", "output", "given", "tree", "reply", "server", "network", "Response", "body", "next", "json", "xml", "description", "data", "view", "entry", "remote", "status", "result"]}}
{"id1": "11477906", "id2": "4389475", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"loadDefaultSettings": ["loadDefaultsettings", "loadDefaultValues", "loaddefaultSetting", "readdefaultSettings", "readDefaultSettings", "readdefaultsettings", "readDefaultSetting", "loadFAULTSetting", "readdefaultValues", "loadDefaultSetting", "loaddefaultSettings", "readDefaultValues", "loadFAULTSettings", "loadFAULTsettings", "readdefaultSetting", "loaddefaultValues", "loaddefaultsettings", "readDefaultsettings", "loadFAULTValues"], "configFileName": ["configFilename", "configFileLocation", "configStreamname", "confFilenamename", "configFilenameNames", "configfileNames", "configPagename", "configPageNames", "conffileNames", "configPagePath", "conffilePath", "confFilenameLocation", "conffileName", "confFileName", "configFILEname", "configFilePath", "configFILEPath", "confFilenamePath", "configFILEName", "configStreamLocation", "configPageName", "confFilenameName", "configFilenamePath", "configFilenamename", "configfilePath", "configfilename", "configStreamName", "configFilenameLocation", "confFilename", "configFileNames", "confFilePath", "conffilename", "configFilenameName", "configStreamPath", "confFileLocation", "configfileName", "confFileNames", "configFILELocation"], "in": ["gin", "info", "m", "re", "ad", "t", "im", "run", " din", "mc", "o", "mi", "ls", "up", "cin", "it", "on", "e", "or", "ini", "inf", "check", "inn", "ind", "id", "ze", "ain", "ins", "l", "rin", "doc", "ai", "al", "source", "n", "user", "ro", "IN", "from", "init", "en", "bin", "inner", "isin", "con", "input", "din", "ma", "i", "is", "ar", "In"], "out": ["cn", "m", "t", "w", "up", "aos", "port", "can", "log", "io", "user", "init", "en", "oss", "des", "OU", "OUT", "co", "net", "po", "gc", "ge", "o", "it", "raw", "ind", "client", "to", "ing", "off", "de", "ou", "read", "update", "gt", "ion", "ot", "or", "check", "store", "v", "obj", "not", "n", "res", "all", "server", "file", "ne", "ent", "os", "null", "writer", "ins", "outs", "over", "cache", "une", "output", "ex", "Out", "copy", "con", "nt", "conv", "at", "sys", "auto", "handle", "are"]}}
{"id1": "22977189", "id2": "8788371", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["gin", "read", "get", "up", "cin", "on", "raw", "it", "ini", "inf", "inn", "ind", "ill", "ze", "ins", "ic", "rin", "io", "reader", "r", "inc", "ln", "user", "ro", "iter", "from", "IN", "init", "inner", "bin", "con", "input", "conf", "ri", "din", "i", "inside", "is", "ar", "In", "are"], "out": ["ret", "full", "log", "os", "null", "w", "note", "b", "j", "gt", "end", "ot", "bit", "o", "aos", "it", "on", "or", "mem", "list", "client", "v", "port", "writer", "can", "obj", "to", "outs", "l", "print", "by", "io", "news", "flush", "conn", "write", "not", "cache", "report", "n", "res", "console", "cmd", "output", "set", "timeout", "Out", "en", "inner", "all", "con", "screen", "nt", "outer", "tmp", "conv", "i", "rem", "db", "at", "sys", "pool", "auto", "OUT", "co", "chain", "result", "net"], "line": ["LINE", "row", "column", "link", "rule", "eline", "key", "inline", "base", "character", "block", "ice", "valid", "day", "error", "cell", "name", "message", "Line", "sequence", "l", "print", "lined", "n", "date", "code", "ln", "user", "iter", "stroke", "entity", "lin", "page", "string", "style", "word", "char", "next", "point", "le", "frame", "comment", "header", "file", "match", "lane", "online", "entry", "ine", "text", "chain"]}}
{"id1": "18489832", "id2": "10451698", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" tryLoadZippedImage", " tryLoadXippedfile", " tryLoadXZipfile", " tryLoadZppedFile", " tryLoadZZipFile", " tryLoadZZipImage", " tryLoadZressedFile", " tryLoadXZipFile", " tryLoadZZipfile", " tryLoadZppedImage", " tryLoadXZipImage", " tryLoadZressedImage", " tryLoadXippedDir", " tryLoadZippedDir", " tryLoadZppedfile", " tryLoadZippedfile", " tryLoadZppedDir", " tryLoadXippedFile", " tryLoadZressedfile", " tryLoadZressedDir", " tryLoadXippedImage", " tryLoadZZipDir", " tryLoadXZipDir", " tryLoadZippedFile"], "url": ["ret", "row", "ur", "err", "http", "parse", "link", "b", "https", "un", "ref", "open", "get", "base", "key", "raw", "build", "address", "name", "l", "uri", "log", "sl", "r", "nl", "call", "request", "str", "mount", "location", "ssl", "char", "Url", "web", "ul", "xml", "external", "file", "ll", "dl", "loader", "URL", "browser"], "destDir": ["targetDir", "sourceFolder", "distDir", "sourceFile", "originFolder", " destFile", " destDirectory", "sourceDir", "targetFolder", "srcFolder", "originDirectory", "sourceDirectory", "distDIR", "originDir", "destDirectory", " destDIR", "destFile", " destFolder", "srcDirectory", "targetDirectory", "srcDIR", "srcFile", "distFolder", "destFolder", "distDirectory", "srcDir", "targetDIR", "destDIR", "originDIR"], "urlConnection": ["urlConnect", " urlConnect", "URLConnector", "URLConnection", "httpDialog", " urlDialog", "urlClient", "httpLink", "UrlLink", "URLCompany", "streamCompany", "urlCompany", "UrlConnect", "streamClient", " urlClient", " urlLink", "URLClient", "urlLink", "UrlConnection", "httpConnect", " urlCompany", "UrlDialog", "httpConnection", "urlConnector", "urlDialog", "streamConnector", "streamConnection", " urlConnector"], "tmpFile": ["empChain", " tmpTile", "cmpPage", "destPage", "mpfile", "tmpPage", " tmpfile", "destfile", "empFilename", "tempChain", " tmpView", "tempFilename", "tempDir", "thisfile", "empFile", "thisFile", "mpFile", "tmpBe", "destBe", "empDir", "cmpFilename", "tempfile", "tempFile", "thisFilename", "tempTile", " tmpPage", "thisChain", "tmpView", "tempBe", " tmpDir", "cmpfile", "empView", "destFile", "tmpFilename", "tmpfile", "tempPage", "empTile", "tmpTile", " tmpBe", "empfile", "tmpChain", " tmpFilename", "tempView", "cmpFile", "tmpDir"], "in": ["gin", "pass", "info", "re", "im", "old", "oin", "mi", "up", "cin", "it", "on", "or", "none", "ini", "inf", "inn", "ind", "ze", "ain", "ains", "ins", "l", "rin", "by", "inc", "ai", "al", "source", "one", "n", "ln", "st", "IN", "from", "iter", "win", "init", "en", "isin", "bin", "inner", "ie", "all", "con", "input", "sin", "din", "index", "ma", "i", "inside", "query", "el", "as", "is", "co", "In"], "out": ["cn", "os", "null", "t", "po", "note", "exit", "ch", "o", "up", "aos", "na", "it", "on", "or", "oe", "client", "v", "writer", "obj", "can", "to", "outs", "print", "flush", "io", "write", "one", "n", "cos", "no", "output", "ex", "Out", "all", "con", "nt", "conv", "tmp", "outer", "ou", "oss", "at", "sys", "OU", "external", "OUT", "co", "ne", "ent", "col", "net"], "localURL": ["LocalURI", " localUL", "LocalURL", "localhostURL", "localUR", " localUR", "LocalLL", "publicURI", "LocalUrl", "publicUrl", "localhostUL", "publicURL", " localURI", "localhostLL", " localUrl", "localID", "LocalID", " localID", "publicUR", "localURI", "localhostID", "localUL", " localLL", "localLL", "LocalUL", "localUrl", "LocalUR"]}}
{"id1": "7396682", "id2": "22801734", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"copy": ["pixel", "upload", "zip", "read", "link", "gc", "fit", "archive", "Copy", "repeat", "opy", "delete", "cp", "php", "cross", "map", "sync", "write", "Cop", "cat", "create", "replace", "crop", "move", "share", "core", "clip", "slice", "proxy", "split", "transfer", "clone", "py", "cop", "download", "load"], "srcFS": ["sourceFS", "srcOS", "rcFs", "sourceOS", "srcVS", "srcFs", "srcSF", "sysOS", " srcVS", "sysFs", "sysFS", "srcfs", "sourceCS", "rcFS", " srcFs", "srcCS", "sourceFs", "rcMS", "srFs", "rcfs", " srcfs", "sysVS", "sourcefs", "srcMS", " srcOS", " srcCS", " srcSF", "sourceVS", "sourceSF", "rcVS", "srfs", "srFS", " srcMS", "rcOS", "srMS", "rcCS", "rcSF"], "src": ["sit", "RC", "sc", "http", "SOURCE", "selected", "https", "rc", "cont", "syn", "pkg", "path", "url", "secure", "pri", "desc", "check", "ser", "sq", "nil", "resource", "obj", "spec", "uri", "req", "boot", "sync", "sub", "cur", "proc", "source", "str", "th", "node", "rel", "st", "from", "txt", "start", "sb", "rx", "sn", "ctr", "rs", "dest", "supp", "iv", "init", "sec", "input", "img", "usr", "sin", "sr", "tmp", "target", "comp", "via", "sys", "addr", "Source", "sci", "inst", "subject", "loc", "lb", "filename", "dir", "obs"], "dst": ["dslt", " dDest", "ldest", "lst", "deest", "Dest", "dddest", "dsdest", "dsst", "Dlt", "dDest", "dedest", "lgt", "dhdest", "ddnd", "ddlt", "dST", "dgt", "ddest", "Ddest", "degt", "deslt", "dnd", "dsST", "dhDest", "dsnd", "DST", " ddest", "desdest", "dsest", "desnd", " dest", "dsgt", "DDest", "dest", "lest", " dST", "dlt", "Dst", "desst", " dlt", "ddst", "dhst", "dhlt"], "deleteSource": [" deleteSources", "closeSource", "destroySource", "leteDest", "updateSOURCE", " deleteResult", "removeSource", "removeParent", "DeleteSourceFile", "closeSourceFile", "DeleteSOURCE", "updateSite", "leteResult", "delParent", "DeleteSource", "leteSource", "deleteSOURCE", "destroySources", "leteSOURCE", "deleteSite", "removeSOURCE", "removeDest", "delSource", "leteParent", "delSOURCE", "leteSources", " deleteTarget", "deleteTarget", "updateSource", "destroyResult", "deleteSources", "deleteDest", "DeleteSite", "deleteParent", "closeSite", "deleteSourceFile", "delDest", "destroyTarget", "updateSourceFile", "leteTarget", "closeSOURCE", "deleteResult"], "conf": ["info", "m", "cn", "params", "cms", "ch", "ref", "css", "acc", "check", "cc", "ban", "map", "report", "req", "f", "log", "cache", "conn", "q", "scan", "fs", "param", "ln", "cf", "mm", "plan", "ctx", "comm", "cfg", "def", "lib", "con", "irm", "conv", "com", "hash", "config", "cm", "cb", "pool", "comment", "co", "job", "ca", "Conf", "prop"], "contents": ["Contodes", "contants", " Contents", "CONTresses", " contterms", "constends", " contresses", "CONTENT", "CONTants", " Contresses", "Content", "CONTodes", "constENTS", " content", "contENTS", "CONTends", " ContENTS", " contants", "constaves", " contENTS", "CONTaves", "content", "contaves", "contterms", "CONTent", "ContENT", "CONTENTS", "Contents", " Content", " contENT", "Contterms", "CONTterms", " contends", "Contants", "contresses", "CONTents", "contodes", "contENT", " contodes", "constents", " contaves", "contends"], "i": ["ji", "m", "ms", "iq", "ci", "u", "im", "phi", "j", "ii", "gi", "qi", "my", "I", "us", "span", "o", "key", "mi", "ti", "oi", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "client", "y", "multi", "ic", "ai", "\u0438", "q", "x", "n", "ori", "me", "bi", "iter", "ip", "cli", "init", "inner", "si", "ie", "ij", "ki", "index", "sim", "li", "ix", "docker", "json", "ami", "xi", "is", "ims", "ei", "chain"], "in": ["sql", "re", "read", "sample", " din", "mc", "cin", "add", "raw", "ini", "inf", "check", "inn", "ind", "ze", "ins", "by", "r", "reader", "inc", "doc", "out", "source", "from", "IN", "en", "bin", "inner", "isin", "con", "input", "char", "din", "body", "xml", "is", "and", "In"]}}
{"id1": "19235551", "id2": "19520541", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "label": 0, "substitutes": {"handleFCLAException": ["handleICMAException", "handleICMAImage", "handleFCMAError", "handleICLARequest", "handleFCAError", "handleFCLAError", "handleFCLARequest", "handleICMAError", "handleFCLAImage", "handleICMARequest", "handleICLAException", "handleICLAImage", "handleICLAError", "handleFCMAImage", "handleFCCLAImage", "handleFCMAException", "handleFCCLARequest", "handleFCAException", "handleFCMARequest", "handleFCAImage", "handleFCARequest", "handleFCCLAException", "handleFCCLAError"], "params": ["pretty", "styles", "details", "packages", "comments", "ids", "param", "ctx", "keys", "types", "conf", "plugins", "properties", "photos", "reports", "fixes", "tools", "posts", "parents", "tags", "sql", "pos", "features", "services", "helps", "points", "settings", "values", "pins", "layout", "padding", "includes", "papers", "headers", "units", "ops", "pres", "config", "shape", "pps", "actions", "docs", "spec", "items", "members", "gs", "vals", "ports", "las", "marks", "terms", "changes", "ams", "parts", "names", "tests", "models", "options", "cases", "ps", "modules", "codes", "versions", "vs", "results", "files", "errors", "lines", "rules", "rs", "rison", "steps", "requires", "stats", "ims"], "uri": ["umi", "http", "archive", "handler", "href", " URI", "version", "wiki", "menu", "direction", "library", "io", "route", "ori", "init", "database", "proxy", "subject", "filename", "domain", "processor", "path", "pi", "unit", "report", "queue", "request", "source", "iri", "term", "near", "uid", "query", "html", "form", "loc", "uni", "dir", "phi", "length", "surface", "component", "range", "ini", "grab", "directory", "folder", "cue", "bid", "function", "controller", "ip", "cli", "distance", "server", "doi", "i", "force", "then", "file", "msg", "duration", "URI", "du", "username", "prefix", "ui", "id", "message", "resource", "har", "local", "origin", "copy", "ri", "slice", "description", "volume", "browser"], "url": ["ret", "m", "ur", "null", "http", "link", "b", "https", "ls", "address", "client", "image", "resource", "l", "library", "sl", "r", "nl", "rl", "str", "window", "rel", "location", "ssl", "string", "result", "char", "Url", "web", "mail", "file", "dl", "ll", "channel", "open", "URL", "browser"], "connection": ["process", "sql", "close", "c", "document", "object", " Connection", "statement", "reference", "condition", "Connection", "client", "context", "resource", "image", "pointer", "conn", "connected", "still", "output", "page", "con", "position", "server", "network", "database", "session", "relation", "communication", "connect", "description", "data", "response", "channel", "generation", "open", "command", "result", "collection"]}}
{"id1": "4481712", "id2": "530882", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"deleteObject": ["destroyItem", "getobject", "deleteobject", " deleteItem", "getObject", "deleteItem", "deleteObj", " deleteObj", "destroyobject", "destroyObject", " deleteobject", "getObj", "getItem", "destroyObj"], "id": ["info", "row", "t", "link", "pid", "mid", "path", "object", "h", "url", "Id", "ref", "it", "value", "oid", "delete", "name", "message", "p", "md", "kid", "k", "sid", "vid", "f", "n", "ids", "uid", "ID", "rid", "tag", "i", "hash", "db", "description", "data", "type", "ident", "key", "event", "d"], "conn": [" cc", "cn", "err", "resp", "gate", "pkg", "c", "coll", " dc", "ws", "socket", " mem", "port", "bo", "wp", "here", "cur", "Conn", "org", "ctx", "en", "conf", "oss", " ce", "canon", "co", "nw", "auth", "net", "nc", "pos", " cont", "urg", "pas", "client", "dc", " ch", "enc", "act", " c", " rc", " cs", "cb", " col", "loc", "ll", " con", "open", "pub", " compat", "pt", "ld", "mc", "cc", "ct", "pg", "cp", "ns", "ce", "connection", "obj", "n", "rel", "cf", "cmd", "cat", "ens", "comm", "cfg", " db", "nick", "db", " comm", "connect", "gen", " connection", "ann", "addr", " win", "ca", "tp", " cmd", "ctrl", " core", " conv", "close", "ch", "host", " net", " cx", "mn", " pc", "lang", " mc", "local", "win", " cp", "ssl", "con", "jp", "core", " ex", "nt", "conv", "com", " ac", "priv", "sys", "cons", "cert", "col"], "stmt": ["STmp", "stst", "ststat", " ststat", "utmp", "Ststat", "stmp", " stmb", "strmb", "utm", "statm", "Stmm", "strmn", "STmt", "strmt", "STst", " stm", "astmt", "astpt", "STMT", "STmm", "strMT", "statmb", "formmt", "strm", "formstat", "stm", "statmt", "Stst", "statpt", " stMT", "utst", "utmt", "ostpt", "StMT", "astm", "Stmp", "Stpt", "Stm", " stmn", "ostmm", "ostmt", "astmm", "stmb", "stMT", " stmm", "formm", "ostm", "formMT", "Stmn", "stmm", " stpt", "Stmb", "Stmt", "STm", "stmn", "stpt"], "dbConn": ["dbConnect", "dsConnect", "DbColl", "DBColl", "dbColl", "DBRec", "dbCon", " dbObj", "DBObj", "dbCt", "DBConn", "dbObj", "dsCon", "DbCon", "DbConn", " dbConnect", " dbColl", "DbObj", "DbCt", "DbRec", " dbCon", " dbRec", "dsCt", "dsConn", "dbRec", "DbConnect", " dbCt"], "selfConnection": ["reConnection", "SelfInfo", "alsoConnection", "ownConnect", " selfLink", "ownLink", "alsoLink", " selfConnect", "ownThread", "SelfFree", "selfCategory", "selfOnly", "ownConnection", "selfLink", "selfFree", " selfCategory", " selfThread", " selfconnection", "SelfOnly", "reconnection", "ownOnly", "selfConnect", "SelfConnect", "SelfConnection", " selfOnly", "alsoCategory", "SelfCategory", "ownFree", "selfconnection", "reConnect", "alsoConnect", "reLink", "selfInfo", "Selfconnection", " selfFree", "SelfLink", "selfThread", " selfInfo", "SelfThread"]}}
{"id1": "9371421", "id2": "9347451", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"eventHash": ["textRender", "textName", "EventRender", " eventhash", "textHash", " eventRender", " eventName", "eventRender", "texthash", "EventHash", "EventName", "eventhash", "eventName", "Eventhash"], "eventstr": ["msgstring", "ventname", "msgStr", "msgstr", "Eventname", " eventstring", "msgname", " eventenc", "EventStr", "ventenc", " eventStr", "Eventstr", "eventStr", "ventstr", "eventstring", "eventname", "Eventstring", "ventStr", "Eventenc", " eventname", "eventenc"], "md": ["mod", "m", "ms", "ad", "det", "df", "pd", "ld", "mk", "dh", "mc", "pm", "nd", "MD", "mem", "di", "del", "ind", "rm", "dig", "cd", "mn", "mt", "od", "bd", "mb", "mg", "sd", "down", "cmd", "dm", "mm", "met", "metadata", "dat", "td", "dr", "der", "nt", "ma", "hd", "red", "grad", "mand", "mo", "mp", "dd", "d"], "theDigest": ["theDest", "thedigesting", "theDesting", " theDigesting", " theDesting", "THEDigest", "theDFesting", "theDested", "theMDests", "theDFest", "theDFested", "theDigested", "theDigesting", "theDecests", "theDFEST", " theDested", "theDests", "THEDigests", " theDest", "theDigests", "theDigEST", "theDEST", "THEMDest", "theDecested", "theDecEST", " theDEST", "thedigEST", "thedigest", "THEMDests", " theDigested", " theDigEST", "THEDigEST", "theMDEST", "THEDigested", "THEMDEST", "theDecest", "THEMDested", "theMDest", "theMDested", "thedigested"]}}
{"id1": "15737836", "id2": "5441579", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["drop", "update", "link", "dump", "get", "disable", "add", "destroy", "Delete", "quit", "write", "clean", "select", "de", "set", "create", "touch", "move", "save", "database", "remove", "lete", "insert", "execute", "clear", "download", "load", "del"], "site": ["info", "sit", "domain", "item", "http", "link", "sample", "rule", "path", "ste", "base", "se", "e", "store", "settings", "environment", "name", "Site", "ze", "unit", "group", "service", "source", "scan", "node", "test", "course", "set", "station", "theme", "page", "template", "server", "network", "ite", "index", "session", "pse", "isite", "sites", "at", "config", "sys", "localhost", "data", "file", "remote", "chain", "software"], "dbo": ["drapo", "ddpo", "Dbu", "debugbo", "dpo", "Dpo", "dambo", "delmu", " dbu", " dado", "dbu", "ddBo", "dmu", "ppo", "delbu", "ddbo", "gBO", "dBo", "odpo", "debugambo", "Dado", "ddBO", "debugpo", "gbu", "drabon", "sdbo", "DBo", "Dbo", " dbon", "lBo", "debugBo", "DBO", "sdbu", "Dmu", "draBo", "ddbu", "dBO", "pbu", "odbo", "pbo", "sdBO", " dpo", "gbo", "drabo", "lpo", "lambo", "odBo", "pmu", "lbo", "ddado", " dBO", "delbo", "dado", "delpo", "Dbon", " dBo", "dbon", " dambo", "odbu"], "connection": ["computer", "usage", "creator", "po", "office", "link", "table", "handler", "c", "document", "ion", "engine", "collection", " Connection", "statement", "character", "reference", "cone", "management", "condition", "information", "established", "government", "socket", "settings", "binding", "system", "Connection", "client", "context", "resource", "bo", "directory", "writer", "library", "pointer", "conn", "operation", "connected", "created", "application", "console", "function", "controller", "output", "location", "associated", "container", "con", "current", "position", "network", "server", "database", "session", "relation", "manager", "communication", "config", "db", "connect", "pool", "auto", "city", "subject", "closure", "response", "generation", "open", "chain", "command", "intention", "net"], "preparedStatement": ["preparedQuery", "preparedCall", "PreparedDevice", " preparedCopy", "prejectedstatement", " prefixedCopy", "preachedstatement", "pparedStatement", "prepletedStatement", " prefixedStatement", "preparableStatement", "previsedQuery", "preachedGrant", "prefixedstatement", "pretparedListener", "premedStatus", " preachedStatement", "prejectedQuery", "preinitializedStyle", "premittedStyle", "prepletedDevice", "preferredStatement", "prejectedStatement", "preculatedstatement", "preferredCall", "prearedListener", " preparedStat", "preculatedStatement", "prepletedstatement", "prearedStatement", "prepferredstatement", "preachedCall", "postppedstatement", "postppedCall", "prefixedStatement", "prepletedStat", "premedStatement", "previsedStatement", "prepletedCall", "PreparedQuery", "preparableStatus", " prefixedstatement", "preachedStyle", "preparedDevice", "Preppedstatement", "prelatedStatement", "PreparedStatement", "preendedstatement", "preppedQuery", "perachedStatement", "preparedStat", "pretparedStatement", "prefixedCopy", "preparedStatus", "prearedQuery", " preparedstatement", "pretparableListener", "pparedStat", "prejectedCopy", "preendedStatement", "pparedQuery", "preppedStatus", "prefixedQuery", " prefixedQuery", "preformedStat", " preachedStat", "prearedCall", " preparedCall", " preachedCall", "PreppedStatement", "pretparableStatement", "previsedStat", "prelatedDevice", "preachedAdapter", "perparedStyle", "perachedAdapter", "postparedCall", "prepferredQuery", "preppedStat", "prearedCopy", "prepletedComment", "prearedComment", "prepletedGrant", "preparableListener", "preparedCopy", "preparedSQL", "prearedSQL", "paredStatement", "perparedStatement", "prepferredStatement", "prearedStatus", "prepferredSQL", "preparedListener", "perparedAdapter", "postppedStatement", " preparedQuery", "preppedstatement", "preformedStatement", "preparedStyle", "PrearedStatement", "PrearedComment", " preachedGrant", "pretparableStatus", "preachedComment", "prepparedQuery", "preferredstatement", "preparedstatement", "preformedGrant", "preinitializedAdapter", "preferredQuery", "premittedAdapter", "prepparedSQL", "pretparedStatus", "preferredSQL", "previsedStatus", "prelatedComment", "premittedStatement", "paredQuery", "prepparedStatement", "PreppedQuery", "preinitializedStatement", " preparedGrant", "premedListener", "preparedAdapter", "pparedStatus", "Prearedstatement", "perachedComment", "prearedDevice", "preculatedSQL", "prepparedCall", "perachedStyle", "paredStatus", "prepparedstatement", "premittedComment", "preppedStatement", "preparedComment", "preinitializedComment", "prearedstatement", "preparedGrant", "preculatedQuery", "prearedStat", "paredStat", "Preparedstatement", "perparedComment", "prelatedstatement", "prefixedCall", "preachedStatement", "PreparedComment", "preendedQuery", "PrearedDevice", "preformedCall", "postparedstatement", "preppedCall", "preachedStat", "postparedStatement"], "resultSet": ["resultSum", "resultPath", " resultList", "resultHandle", "ResultSession", "rowSession", "resultsList", "dataStream", " resultStream", "dataTime", "ResultSet", "characterStream", "ResultHandle", "responseUn", "characterSet", " resultSum", " resultPath", "responseStream", "responseSet", "ResultTime", "resultUn", " resultHandle", "rowSet", "ResultSum", "resultSession", "characterSum", "resultSource", "resultsPath", "resultTime", "resultsUn", "ResultStream", "resultStream", " resultSession", " resultTime", "dataSet", "resultList", "ResultUn", "rowSource", "resultsStream", "ResultList", "ResultSource", "resultsSet", " resultSource", "ResultPath", "rowHandle"], "chkSql": ["chKSyl", "chKDk", "chkSq", "chkInsql", "chKInsql", "chKDyl", "chKSQL", "chkDyl", "chkDk", "chKDQL", "chkRSyl", "chkDql", "chkSk", "chkRSQL", "chkDQL", "chKInsq", "chkInsQL", "chkStrQL", "chKInsQL", "chkRSql", "chKSql", "chkDq", "chkRSk", "chKDql", "chkStrq", "chkStrql", "chkSQL", "chKSq", "chkSyl", "chkInsq", "chKSk"], "selfDefinePath": ["selfDeliningPath", "selfDefinedKey", "selfDefineSet", "selfDefideDir", "selfdefinePath", "selfDefineKey", "selfDefINESet", "selfDefINEpath", "selfDelinepath", "selfDefiningpath", "selfDeliningKey", "selfDelineKey", "selfdefinePattern", "selfDefinedSet", "selfDefiningKey", "selfDefinedpath", "selfDefiningDir", "selfDefidePattern", "selfDefinepath", "selfdefinespath", "selfDefINEKey", "selfDelinePath", "selfDeliningSet", "selfDefiningSet", "selfDefinedPath", "selfdefinepath", "selfdefineDir", "selfDefiningPattern", "selfDefinesPath", "selfDefinesDir", "selfdefinesPath", "selfDeliningpath", "selfDefinesPattern", "selfDefidePath", "selfDelineSet", "selfDefinePattern", "selfDefidepath", "selfdefinesPattern", "selfDefiningPath", "selfdefinesDir", "selfDefINEPath", "selfDefineDir", "selfDefinespath"], "sqlStr": [" sqlString", " sqlSt", "sqlWr", "sqString", "qlstr", "sqlstr", " sqlName", " sqlstr", "sqWr", "sqlSt", " sqlWr", "SQLstr", "sqlName", "SQLSt", "sqstr", "sqSt", "sqStr", "qlStr", "qlName", "qlString", "sqlString", "SQLWr", "SQLStr", "sqName"]}}
{"id1": "4223002", "id2": "9824814", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getPasswordMD5": ["getTokenMD4", "getPasswordHS5", "getTokenMD5", "getTokenSM6", "getPasswordMD512", "getPasswordmd6", "getPasswordSM5", "getPasswordSM512", "getPasswordSM4", "getTokenMD512", "getTokenSM4", "getPasswordmd5", "getTokenSM5", "getPasswordHS512", "getTokenSM512", "getPasswordmd512", "getPasswordMD4", "getPasswordMD6", "getPasswordHS4", "getPasswordmd4", "getPasswordSM6", "getTokenMD6", "getPasswordHS6"], "algorithm": ["aluristic", "thechemist", " algo", "omalgo", "malgorith", "alric", "Algorith", "alignment", "already", "algebra", "halric", "alphgorithm", "themother", " Algorithm", "halready", " aluristic", "thegorithm", "approignment", "eargorith", "omalgorithm", " algorith", "malgorithm", "alphgebra", "approgorith", "approgorithm", "omalgorith", " already", "alphric", " Alchemist", "eargorithm", "alphgorith", " Algorith", "Algorithm", "alchemist", "Algo", "omaluristic", "halgorithm", "malchemist", "eargebra", "halgebra", "algorith", "earric", "malmother", "halgorith", "Aluristic", " Almother", "approready", "halignment", "almother", "thegorith", "algo", " alignment"], "messageDigest": ["messageMixEST", "messageAndist", "messageDesignEST", "messageDrise", "MessageDigest", "MessageDigse", "messageAndester", "Messagedigest", "MessageDigist", " messageDigested", "messagedigist", "Messagedigester", "messageDigitalEST", "messageDigester", " messagedigest", "messageDigse", "messageMixest", "messageDigested", "MessageDigester", "messageMixests", "messageDigist", "messageDesignested", " messageDigester", "messageDigests", "messagedigested", "messagedigest", "messageDriist", "messagedigester", "Messagedigse", "messageDigEST", "MessageDigests", " messagedigested", "messageAndse", "MessageDigEST", "messageDse", "MessagedigEST", "messageDriest", "messageDesignest", "messageDriester", "messagedigse", "messageDigitalester", " messagedigEST", "messageDesignester", " messagedigester", " messageDigEST", "messageDests", "messagedigests", "messageDigitalested", "messageDigitalest", "Messagedigist", "messageAndest", "messageMixse", "messagedigEST", "messageDest", "Messagedigests", "messageDEST"], "hexString": ["stringString", "exstring", "httpsArray", "hexstring", "stringArray", "httpsScreen", "octArray", "hexArray", "hexStatement", " hexStatement", "textString", "httpsstring", "stringstring", "httpsBuffer", " hexstring", "octScreen", "octstring", "exString", "textArray", "httpsStatement", "hexScreen", "stringBuffer", "exScreen", "exBuffer", "octString", "textStatement", " hexArray", "textBuffer", "httpsString", "hexBuffer", " hexBuffer", "exArray"], "i": ["ji", "m", "ms", "ci", "u", "im", "in", "phi", "j", "gi", "ii", "gu", "qi", "c", "my", "I", "us", "span", "mi", "ti", "a", "o", "pi", "it", "di", "ui", "ind", "ski", "hi", "zi", "client", "y", "multi", "ic", "uri", "io", "ai", "\u0438", "q", "x", "n", "bi", "set", "ex", "ip", "cli", "init", "si", "ie", "ri", "point", "sim", "li", "ix", "xi", "loop", "is", "yi", "key", "ei", "chain"]}}
{"id1": "20920051", "id2": "411595", "code1": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyTo": [" copyPhoto", "copyOver", "copyFiles", "opyDir", "transferTo", "copyDir", "opyOver", "copyPhoto", "opyPhoto", " copyFile", "moveDir", "opyTo", "movePhoto", " copyOver", "transferFrom", " copyDir", "CopyFrom", "transferFile", " copyFrom", "transferFiles", " copyFiles", "CopyFiles", "copyFile", "CopyFile", "CopyTo", "copyFrom", "moveTo", "moveOver"], "source": ["src", "details", "SOURCE", "empty", "get", "se", "none", "part", "sf", "from", "init", "ie", "input", "oss", "subject", "shell", "sql", "note", "sample", "old", "raw", "unit", "service", "scan", "select", "site", "visible", "search", "style", "template", "sin", "query", "config", "Source", "status", "component", "secure", "scope", "sort", "flat", "store", "use", "spec", "sl", "iter", "file", "ace", "null", "base", "parent", "sp", "name", "id", "image", "resource", "s", "seed", "ource", "local", "start", "copy", "origin", "missing", "original", "target", "pse", "size", "entry"], "dest": ["tom", "src", "null", "w", "orig", "d", "Dest", "opt", "end", "path", "ref", "it", "desc", "trans", "parent", "name", "dc", "this", "port", "rest", "master", "to", "deg", "doc", "out", "dist", "folder", "pro", "test", "st", "good", "txt", "dat", "origin", "dev", "result", "nt", "tmp", "target", "nom", "des", "loc", "self", "est", "dir", "del"], "temp": ["make", "porary", "mod", "pl", " temporary", "null", "t", "orig", "w", "zip", "alt", "empty", "fake", "mk", "path", "tar", " tmp", "EMP", "parent", "cp", "buffer", "p", "mt", "tab", "out", "emp", " Temp", "stem", "em", "test", "txt", "mm", "unt", "local", "dat", "template", "Tem", "tmp", "rem", "tm", "tem", "mp", "Temp", "por", "rm", "pt"], "sel": ["pl", "nav", "sc", "zh", " sl", "ael", "selected", "kel", "syn", "ls", "El", "se", "sen", "sels", "ml", "ser", "cel", "ial", "cell", "selection", "sl", " lic", "nl", "ele", "fl", "rl", "cl", "sol", "lv", "select", "Se", "sv", "nel", "Sel", "lf", "kl", "le", "rol", "elect", "el", "mil", "fol", "so", "sil", "del"], "tempDest": ["mmLoc", "mmTemp", "poraryDe", " temporaryTemp", "tempDec", " temporarydest", "tempDir", "poraryDest", "poraryTemp", "poraryDec", "tempNeg", "temdest", "tempTemp", " tempTemp", " tempDir", "ptNeg", " tempdest", "poraryLoc", "temDe", " temporaryDest", "destLoc", "destTemp", " tempDe", "destDec", "destDest", "porarydest", "mmDec", "tempLoc", " tempNeg", "poraryDir", "temDir", "ptTemp", "mmDest", "ptdest", " temporaryNeg", "tempDe", "temDest", "tempdest", "ptDest"], "sourceCh": ["seedChan", " sourceCor", " sourcech", " sourceCH", "startComp", "srcComp", "srcch", "srcCol", "ourceCh", "startCH", "statusCol", "sourceCr", "srcColl", "startCol", "ourceComp", "samplech", "sampleComp", "srcCH", "ourceCH", "sourceCor", "sourceComp", "sourceColl", "srcCh", "ourceChan", "statusCh", "sourceCH", " sourceCol", "srcCor", "seedCh", " sourceCr", " sourceComp", "ourceColl", "statusCH", "srcChan", "sampleCor", "statusCr", "sourceCol", "sampleCh", "sourcech", "startCh", "seedCol", "ourceCr", "ourceCol", "sourceChan", "seedColl"], "destCh": ["destCl", "destC", "tempCl", "usrChan", " destChar", "targetCh", "estCl", "tempCol", " destC", "targetChan", "usrChar", "destChan", " destDest", "restChan", "targetC", "tempChan", " destCl", "tempC", "destDest", "destCol", "restC", " destCol", "targetChar", "tempCh", "usrCh", "estC", "estDest", "destChar", "restCol", " destChan", "usrC", "restCh", "estCh"]}}
{"id1": "20995534", "id2": "8942491", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    public static URLConnection openProxiedConnection(URL url) throws IOException {\n        if (proxyHost != null) {\n            System.getProperties().put(\"proxySet\", \"true\");\n            System.getProperties().put(\"proxyHost\", proxyHost);\n            System.getProperties().put(\"proxyPort\", proxyPort);\n        }\n        URLConnection cnx = url.openConnection();\n        if (proxyUsername != null) {\n            cnx.setRequestProperty(\"Proxy-Authorization\", proxyEncodedPassword);\n        }\n        return cnx;\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromclassloader", "loadPropertiesFromClassPath", "loadPropertiesfromclassloader", "loadPropertiesFromFileloader", "loadPropertiesfromclassPath", "loadPropertiesFromClassname", "loadPropertiesFromclassname", "loadPropertiesfromClassname", "loadPropertiesFromFilePath", "loadPropertiesfromclassname", "loadPropertiesFromFilepath", "loadPropertiesfromClassPath", "loadPropertiesfromClasspath", "loadPropertiesFromFilename", "loadPropertiesFromClassloader", "loadPropertiesfromclasspath", "loadPropertiesFromclasspath", "loadPropertiesFromclassPath", "loadPropertiesfromClassloader"], "path": ["full", "hex", "item", "module", "w", "zip", "ath", "empty", "base", "prefix", "PATH", "name", "p", "filename", "resource", "context", "directory", "log", "transform", "str", "mount", "test", "txt", "location", "string", "pattern", "template", "root", "Path", "config", "program", "xml", "file", "data", "policy", "type", "entry", "format", "key", "text", "chain", "prop", "dir", "pt"], "locations": [" locATIONS", "Locations", "lococations", "locifications", "localATION", "equators", "locATIONS", "LOCifications", "localifications", "Locators", "LOCATIONS", "LocATION", "locators", " locifications", "Lococations", " locATION", "equATIONS", "equifications", " lococations", "localations", " locates", "plATIONS", " locators", "plations", "localates", "Locifications", "plates", "Locates", "LOCations", "locates", "locATION", "LOCocations", "LOCators", "LOCates", "equations", "plocations"], "props": [" properties", "roperties", "propperties", "proports", "probs", "propgs", "preports", "Prors", "Properties", "rops", "prodates", "rogs", "peps", "Probs", " prors", "preps", "prors", "privperties", "preperties", "Props", "peperties", "Proports", "robs", "privps", "properties", "pebs", "pegs", "Progs", "Prodates", "privdates", "progs", "propports", "propps", "privrs", "pregs", " prodates"], "url": ["row", "bel", "ur", "http", "link", "ref", "ls", "gl", "address", "name", "resource", "l", "log", "f", "sl", "r", "nl", "uri", "element", "rl", "mb", "term", "str", "org", "rel", "mount", "user", "location", "string", "page", "pattern", "server", "char", "Url", "web", "mail", "config", "ob", "el", "html", "xml", "file", "loc", "ll", "dl", "key", "URL", "browser"], "in": ["gin", "info", "cn", "sql", "vin", "read", "sample", "mc", "mi", "stream", "cin", "on", "inn", "ind", "media", "mn", "ins", "io", "reader", "inc", "out", "source", "ln", "from", "IN", "init", "en", "isin", "bin", "inner", "con", "input", "din", "body", "sum", "ma", "i", "mat", "cm", "as", "data", "file", "is", "and", "mr", "In"]}}
{"id1": "807346", "id2": "5138455", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"runScript": ["callCode", " runscript", " runCode", " runProgram", "executeProgram", "runCode", "executeCode", "runProgram", "executescript", "callscript", "callProgram", "callScript", "executeScript", "runscript"], "scriptName": [" scriptname", "templateName", "ScriptKey", "templatePath", "scriptBody", "fileName", "scriptname", "scriptPath", "templateBody", " scriptFile", "fileKey", "ScriptPath", "criptName", "criptFile", "ScriptName", " scriptPath", "scriptFile", "Scriptname", "criptPath", "filePath", " scriptBody", "scriptKey", " scriptKey", "filename", "templateFile", "criptBody"], "data": ["info", "what", "row", "t", "ata", "empty", "table", "DATA", "default", "a", "raw", "results", "value", "reason", "rew", "error", "list", "name", "this", "message", "image", "buffer", "p", "sequence", "to", "report", "log", "content", "cache", "out", "padding", "comments", "source", "str", "action", "window", "n", "video", "rel", "alert", "res", "debug", "output", "step", "dat", "extra", "missing", "string", "all", "title", "partial", "some", "input", "div", "next", "json", "html", "description", "comment", "response", "format", "type", "text", "chain", "command", "result"], "url": ["pl", "bel", "ur", "http", "hl", "link", "b", "https", "get", "base", "gl", "build", "address", "resource", "l", "uri", "f", "sl", "r", "nl", "log", "out", "str", "rel", "mount", "user", "ssl", "char", "Url", "mail", "abs", "ul", "web", "loc", "lb", "ll", "dl", "open", "job", "URL", "browser"], "in": ["gin", "info", " din", "val", "mc", "stream", "cin", "it", "on", "pi", "check", "inf", "inn", "ind", "ins", "l", "rin", "io", "r", "inc", "out", "al", "source", "IN", "mm", "act", "en", "isin", "bin", "inner", "all", "input", "din", "body", "ma", "i", "mat", "is", "serv", "In"], "buffIn": [" BuffIn", "BuffOut", "bufIn", "bufferOut", "BuffCon", "BuffIn", "buffOut", "bufferCon", "bufferIns", " buffOut", "bufferIn", " BuffOut", "BuffedIn", " BuffIns", "BuffIns", "buffedIn", "bufedIn", "buffIns", " buffedIn", "buffCon", "bufOut", " BuffCon"], "temp": ["porary", "tim", "mod", "perm", "tc", "t", "read", "length", "j", "variable", "fake", "cap", "perature", "character", "acc", "there", "cel", "cell", "buffer", "sequence", "deg", "cur", "emp", "term", "wr", "stem", "test", "txt", "output", "Temperature", "dat", "relative", "template", "input", "current", "tmp", "index", "i", "ptr", "tem", "mint", "Temp", "cert", "result", "thread", "pt"]}}
{"id1": "19307120", "id2": "23677147", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"sendPost": ["sendText", "postpost", "postPOST", " sendText", "sendpost", "sendPOST", "doPost", " sendPOST", "doText", "postText", "postPost", "dopost", "doPOST", " sendpost"], "url": ["ret", "pl", "ur", "u", "http", "link", "pp", "https", "path", "ref", "ls", "host", "base", "build", "address", "uri", "l", "call", "sl", "log", "nl", "q", "term", "str", "mount", "location", "ssl", "string", "Url", "web", "mail", "ul", "addr", "file", "ll", "dl", "loc", "URL"], "param": ["pass", "project", "m", "Param", "row", "params", "cal", "option", "property", "prop", "dem", "prefix", "prom", "block", "mem", "sp", "name", "p", "post", "amp", "aram", "password", "padding", "proc", "term", "argument", "mm", "start", "string", "conf", "input", "par", "meter", "ram", "tag", "rem", "config", "model", "comment", "key", "commit", "command"], "result": ["ret", "memory", "answer", "true", "diff", "default", "success", "results", "value", "reason", "valid", "found", "message", "buffer", "p", "report", "wrapper", "r", "feature", "temp", "confirmed", "cur", "term", "request", "res", "code", "date", "test", "product", "output", "complete", "string", "continue", "current", "sum", "query", "manager", "Result", "comment", "description", "data", "match", "response", "chain", "status", "command"], "httpurl": ["hUrl", "hconn", " httpURL", "webconn", "httpsURL", "workURL", "httpsUrl", "hurl", " httpUrl", "httpsurl", "webURL", "hURL", " httpconn", "httpsconn", "httpUrl", "workconn", "workUrl", "httpURL", "webUrl", "weburl", "workurl", "httpconn"], "httpConn": ["copCod", "procconn", "httpCon", "HttpConnect", "procCon", " httpCod", "copconn", "copCon", "hconn", " httpCon", "httpsConn", "procConnection", "httpsConnect", " httpConnection", "httpCod", "hoverconn", "hoverConnection", "hConnect", "procObj", "ttpConn", "procCod", " httpConnect", "hConnection", "ttpconn", "HttpConn", "procConn", " httpconn", "httpObj", "ttpCon", "httpsconn", "httpConnect", "copConn", "hConn", "hoverConn", "ttpConnection", "httpConnection", "httpsConnection", "httpconn", "hoverConnect", " httpObj", "httpsCon", "Httpconn", "ttpObj", "HttpCon"], "out": ["pretty", "os", "w", "ch", "o", "up", "aos", "it", "check", "v", "p", "writer", "obj", "to", "outs", "flush", "print", "by", "io", "write", "put", "n", "cmd", "output", "ex", "set", "timeout", "Out", "init", "inner", "all", "screen", "nt", "conv", "outer", "ou", "oss", "sys", "OU", "auto", "OUT", "co", "cos", "net"], "in": ["gin", "re", "per", "read", " din", "oin", "mi", "se", "cin", "it", "on", "inf", "inn", "ind", "mn", "ins", "er", "ic", "rin", "by", "reader", "inc", "al", "IN", "from", "iter", "init", "en", "isin", "inner", "bin", "input", "ri", "din", "ma", "i", "el", "is", "In"], "line": ["record", "LINE", "row", "email", "phrase", "link", "rule", "eline", "inline", "piece", "se", "e", "block", "ice", "cell", "message", "Line", "sequence", "port", "l", "print", "log", "lined", "code", "ln", "pe", "stroke", "iter", "ip", "lin", "page", "string", "continue", "body", "point", "le", "frame", "comment", "header", "file", "online", "lane", "entry", "field", "ine", "text", "chain", "liner"]}}
{"id1": "14317425", "id2": "11952735", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToDisk", "encodeStringToFiles", "encodeStringAsFile", "encodeStringToFile", "encodeStringAsStream", "encodeFiletoDisk", "encodeStringToStream", "encodeFiletoFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileAsStream", "encodeFileAsFiles", "encodeFiletoFiles", "encodeStringAsFiles", "encodeFileFromFile", "encodeFileAsFile", "encodeFileFromDisk", "encodeFiletoStream", "encodeStringAsDisk", "encodeFileToStream", "encodeFileAsDisk", "encodeFileFromFiles", "encodeFileToFiles"], "infile": ["Inbase", "inpath", "outFile", "outfilename", "InFile", "outpath", " infilename", "Infile", " inbase", "inFile", "inputFile", "inbase", " inFile", "inputpath", "infilename", " inpath", "inputfile", "inputfilename", "Inpath", "outbase"], "outfile": ["outfp", " outname", "infp", "outFile", "newname", "outfilename", "newfilename", "inname", " outFile", "fromFile", "outname", "todir", "outdir", "inFile", " outfilename", "newFile", "fromdir", "tofp", "indir", "fromfp", "tofile", "infilename", "fromfile", "toFile", "newfile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "image", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "ro", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "up", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "total", "variable", "document", "length", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "cache", "number", "temp", "queue", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "attribute", "append"], "read": ["before", "each", "text", "send", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", "ok", "submit", "ratulations", " succ", "condition", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "ith", " Success", "summary", "primary", "commit", "positive", "surv", "same", "good", "safe", "complete", "continue", "second", "sufficient", "democracy", "town", " okay", "warning", "unity", "please", " successes", "first", "support", "city", " successful", "ceed", "fail", "response", "successfully", "status", "result", "crit", "accept"]}}
{"id1": "20310134", "id2": "21656668", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " copyStream", " cpStream", " duplicatefile", " cpfile", " copyDirectory", " copyfile", " CopyStream", " CopyDirectory", " duplicateStream", " duplicateFile", " Copyfile", " duplicateDirectory", " cpDirectory", " cpFile"], "in": ["gin", "b", "old", "up", "cin", "on", "it", "ini", "inf", "inn", "ind", "id", "ain", "ins", "ic", "rin", "l", "io", "r", "inc", "source", "IN", "from", "mm", "init", "en", "isin", "input", "din", "i", "el", "as", "is", "In"], "out": ["os", "null", "t", "err", "w", "po", "b", "gt", "c", "ot", "o", "it", "v", "help", "p", "s", "to", "log", "outs", "l", "io", "op", "n", "g", "output", "ex", "Out", "nt", "ou", "at", "msg", "OUT", "serv", "ne", "net"], "inChannel": ["inchannel", "inPanel", "inListener", "intButton", "inButton", " inPanel", "inputCommand", "inCommand", "cinChannel", "intChan", "inConnection", "sinListener", " inCase", "inApplication", "sinCase", " inchannel", "sinChannel", "oinConnection", " inListener", "sinRoom", "intChannel", "cinCase", " inChan", "outApplication", "sinButton", "cinListener", " inConnection", "inputPanel", "outConnection", "oinchannel", "intCommand", "sinClient", "cinButton", " inButton", "dinButton", "oinApplication", " inCommand", " inApplication", "inCase", "dinChan", "outchannel", "inClient", " inRoom", "cinClient", "inRoom", "inputChannel", "insidePanel", "insideCommand", "cinRoom", "oinChannel", "dinChannel", "dinCommand", "inChan", "insideChannel", " inClient"], "outChannel": ["outerChan", "outCh", "inchannel", "fullCategory", "outputUser", "cosChannel", "noteMember", "OUTChan", " outUser", "outerUser", "outerChannel", " outCan", "inMember", "outerConnection", " outConnection", "outputConnection", "OUTCategory", "outputCh", "fullCan", " outCh", "fullChannel", "inCategory", "cosChan", "OUTCan", "outputChan", "outConnection", "fullChan", "outUser", "inCh", "outCategory", "noteChan", "noteCategory", "outchannel", "cosMember", "OUTChannel", "noteChannel", "cosCategory", "outCan", "outputChannel", "outputchannel", " outChan", " outchannel", "outChan", " outCategory", "inChan", "outMember"]}}
{"id1": "21821404", "id2": "7761195", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"getWebPage": ["getDebugUrl", "downloadWebPages", "getwebPages", "getLivePage", "downloadwebUrl", "downloadWebUrl", "getwebPage", "getDebugPage", "downloadWebpage", "downloadwebpage", "getLivePages", "getDebugpage", "getwebpage", "getWebUrl", "getWebPages", "downloadwebPage", "getDebugPages", "downloadWebPage", "getwebUrl", "getWebpage", "downloadwebPages", "getLivepage", "getLiveUrl"], "urlObj": ["logInfo", "uriobj", " urlOb", "UrlObject", " urlObject", " urlobj", "httpOb", "urlInd", "uriObj", "UrlOnce", "urlOb", "logOb", " urlInfo", "httpObject", "Urlobj", "urlOnce", "uriOnce", "UrlInd", "httpObj", "UrlCtrl", "uriCtrl", "urlobj", " urlInd", "httpInfo", "urlObject", "urlCtrl", "UrlObj", "uriInd", "uriObject", " urlOnce", " urlCtrl", "urlInfo", "logObj", "logObject"], "content": ["read", "empty", "cont", "document", "Content", "equ", "object", "raw", "value", "reason", "ce", "address", "articles", "message", "buffer", "sequence", "context", "article", "wrapper", "layout", "temp", "write", "comments", "source", "clean", "str", "code", "output", "txt", "complete", "page", "load", "string", "template", "title", "section", "continue", "core", "current", "body", "ext", "cm", "html", "comment", "ontent", "data", "header", "view", "response", "format", "display", "text", "command", "result"], "is": ["sis", "err", "c", "se", "isi", "e", "iss", "isf", "by", "rys", "ris", "as", "isa", "net", "was", "ms", "sit", "isl", "where", "lis", "its", "isc", "his", "ists", "out", "ois", "nis", "iso", "web", "Is", "job", "and", "ir", "re", "other", "in", "ot", "or", "sels", "es", "when", "not", "res", "mis", "iris", "isin", "string", "more", "i", "ais", "ians", "os", "were", "a", "ios", "has", "be", "ism", "tis", "id", "name", "s", "being", "does", "ese", "fs", "ire", "ist", "rs", "internet", "ri", "\u00eds", "sys", "IS", "plays", "bis", "chain", "are"], "reader": ["editor", "row", "per", "read", "ocker", "in", "handler", "rar", "anger", "ner", "dra", "iper", "stream", "roller", "ser", "iterator", "buffer", "writer", "er", "runner", "io", "r", "ipper", "ro", "iter", "Reader", "ader", "inner", "dr", "ri", "reading", "file", "parser", "loader", "liner", "rr"], "line": ["record", "LINE", "row", "detail", "column", "email", "link", "sample", "lo", "eline", "range", "inline", "piece", "e", "block", "part", "cell", "message", "Line", "sequence", "l", "print", "nl", "lined", "ln", "stroke", "lin", "string", "page", "word", "section", "char", "zone", "le", "point", "el", "frame", "comment", "online", "file", "lane", "entry", "ine", "label", "text", "liner"]}}
{"id1": "8087001", "id2": "17296916", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "label": 0, "substitutes": {"generateStackHashKey": ["generateTrackHashPage", "generateStackNodeKeys", "generateTrackhashKey", "generateTrackHashKey", "generateStackNodeIndex", "generateStackhashIndex", "generateStackHashKeys", "generateStackhashPage", "generateStackNodePage", "generateStackStateIndex", "generateTrackhashPage", "generateStackHashPage", "generateStackhashKey", "generateStackHashIndex", "generateStackStatePage", "generateTrackHashIndex", "generateStackStateKeys", "generateTrackHashKeys", "generateTrackhashKeys", "generateTrackhashIndex", "generateStackhashKeys", "generateStackNodeKey", "generateStackStateKey"], "e": ["m", "u", "t", "err", "email", " exc", "ee", "ec", " pe", "ge", "o", "h", "a", "se", "ed", "es", "oe", "error", "p", "er", "ae", "element", "f", "r", " me", "x", "E", "n", "me", "pe", " err", "eb", "ex", "eeee", "exp", "en", " te", "ie", "ep", " error", "ef", "exc", "te", "eer", "eg", "i", "el", "xe", " ce", "eu", "ne", "ue", "event", "d"], "digest": ["digse", "decse", "compests", "Digse", "Digested", "descgest", "digested", "Diger", "mdEST", "mdest", " diger", "digester", "decest", "digests", "Digests", "compested", "compEST", "mdested", "DigEST", "compest", "diger", "descer", "Diggest", "descse", " digested", "diggest", " digse", "mdse", "decester", " digEST", "decested", "mdester", " diggest", "descest", "Digest", "Digester", "digEST", " digester", " digests"], "hash": ["hex", "bh", "sample", "mac", "total", "h", "has", "score", "ash", "block", "ashed", "check", "sh", "valid", "build", "filter", "message", "dig", "map", "report", "log", "cache", "test", "search", "all", "style", "sha", "Hash", "sum", "tag", "html", "her", "chain", "key", "rh", "shadow"], "rtn": ["latn", "ntN", "rxn", "latne", "rton", "RTcn", "rtmn", "mtn", "RTn", "otne", "rtns", "rtne", "vrnm", "vrb", "ntb", "ntnm", "ytnor", "rotyn", "RTb", "RTnm", "otmn", "aptnu", "rtyn", "ttnu", "artns", "rotn", "rotns", "latnm", "rxmn", "latmn", "apton", "artnor", "ytns", "ertr", "aptr", "ttr", "ttn", "otnm", "rotnor", "artn", "RTN", "mtnm", "rotcn", "aptn", "rotnm", "rotnu", "otn", "ertnu", "ertn", "rxnm", "rtnu", "rtr", "artyn", "mtnu", "rtb", "mtcn", "rtcn", "ntn", "tton", "RTnu", "rtnm", "vrN", "rxne", "rtN", "ytyn", "vrn", "erton", "ytn", "rtnor"]}}
{"id1": "16556717", "id2": "14865947", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getSHADigest": ["getSHADDigester", "getSHAdigest", "getSHADigests", "getSHAdigests", "getSHAdegest", "getSHADdigest", "getSHADDigest", "getSHADdigester", "getSHADDigse", "getSHADdigests", "getSHADDigests", "getSHAdigester", "getSHAdegester", "getSHAdegests", "getSHADigse", "getSHADigester", "getSHADegests", "getSHAdigse", "getSHADegester", "getSHADegest", "getSHAdegse", "getSHADdigse", "getSHADegse"], "password": ["pass", "secret", "words", "w", "phrase", "email", "Password", "username", "prefix", "value", "address", "name", "id", "message", "sword", "login", "reset", "padding", "user", "string", "pattern", "token", "word", "input", "database", "session", "hash", "description", "data", "response", "command", "key", "wd", "text", "auth", " Password"], "digest": [" digment", "digse", "decgest", "mentester", "Digested", "Digse", "mentgest", " digist", "digested", "dEST", "digment", "digester", "decest", "dighash", "dist", "DigEST", "hashested", "hashest", "hashEST", "Digist", "dested", "igse", " dighash", "mentest", "dest", "Diggest", "hashment", " digested", "Dighash", "diggest", " digse", "decester", " digEST", "igEST", "digist", "igest", "ighash", "Digest", "decEST", "Digester", "digEST", "Digment", "mentEST"], "sha": ["ha", "go", "shared", "api", "ah", "po", "phi", "mac", "ssh", "a", "alpha", "tar", "has", "na", "pi", "func", "ca", "sh", "sq", "hi", "md", "git", "sam", "ka", "ao", "ta", "shi", "no", "ya", "sche", "pa", "ssl", "si", "HA", "sa", "lambda", "iso", "SHA", "sum", "ma", "ho", "access", "hash", "qa", "addr", "wa", "auto", "asha", "ppa", "wal", "acl", "da", "shell"], "pwhash": [" pwhashed", "pswashed", " pwhat", "pwhat", "psway", "pWHashed", "pWHash", "pthashed", "pshashed", " pswat", "pshash", " psway", "pwhashed", "pswhash", "pwhhash", " pswash", " pwhhash", "pswash", "pWHay", "pthhash", " pwhay", "pWHhash", "pthash", "pWHat", "pshay", " pswashed", "pthat", "pswat", "pwhay", "pshhash", " pswhash"]}}
{"id1": "4982745", "id2": "17947246", "code1": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "code2": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "label": 0, "substitutes": {"doJSONRequest": [" doJSONResponse", "doHTTPConnection", " doHTTPRequest", " doJSONQuery", "doHTTPRequest", " doHTTPQuery", "doHTTPQuery", " doHTTPResponse", "doCustomResponse", "doJSONConnection", "doJSONQuery", "dojsonResponse", "doCustomQuery", "dojsonConnection", "doJSONResponse", "dojsonQuery", "dojsonRequest", "doHTTPResponse", " doJSONConnection", "doCustomConnection", "doCustomRequest", " doHTTPConnection"], "jsonRequest": ["JSONRequest", "jsonObject", "rawPost", "sonObject", "rawRequest", " jsonObject", "rawObject", "jsonPost", "JSONObject", "rawResponse", " jsonPost", "sonRequest", "sonPost", "JSONPost", "sonResponse", "JSONResponse"], "request": ["record", "project", "re", "QUEST", "person", "http", "update", "setup", "close", "document", "object", "url", "get", "reference", "pair", "add", "condition", "quest", "use", "address", "name", "client", "question", "message", "this", "resource", "post", "context", "report", "req", "call", "begin", "reset", "claim", "q", "transform", "application", "order", "create", "start", "copy", "search", "input", "instance", "position", "query", "first", "remove", "xml", "requ", "initial", "insert", "Request", "hello", "self", "remote", "job", "command", "complete"], "params": ["styles", "eters", "details", "cas", "pps", "eps", "actions", "cap", "pkg", "services", "prop", "points", "parent", "settings", "cp", "pas", "amps", "multi", "spec", "pins", "lines", "proc", "gs", "members", "pers", "param", "Parameters", "rules", "caps", "rs", "mm", "ctx", "groups", "headers", "types", "ports", " parameters", "properties", "par", "tmp", "phys", "ims", "json", "terms", "changes", "ams", "parts", "ars", "pool", "as", "pres", "posts", "names", "sys", "chains", "stats", "options", "tags", "ps", "shape"], "entity": ["eme", "details", "person", "null", "note", "email", "orm", "document", "security", "object", "component", "e", "valid", "ct", "available", "oe", "ce", "environment", "activity", "quote", "connection", "buffer", "error", "resource", "obj", "ae", "account", "enc", "code", "application", "em", "pe", "user", "om", "ip", "create", "metadata", "encrypted", "iam", "iso", "le", "json", "query", "Entity", "ITY", "el", "comment", "xml", "model", "entry", "type", "ell", "ent", "ity", "event", "shell"], "t": ["tt", "m", "tim", "iat", "tw", "tc", "z", "w", "det", "j", "total", "c", "tick", "ot", "ut", "ti", "it", "e", "ct", "now", "ts", "p", "y", "s", "mt", "l", "f", "vt", "temp", "x", "ta", "n", "g", "T", "st", "txt", "pt", "qt", "nt", "i", "at", "wt", "elt", "tm", "dt", "tf", "time", "tp", "duration", "et", "d"], "response": ["memory", "answer", "re", "resp", "document", "object", "onse", "success", "e", "version", "environment", "client", "message", "connection", "sequence", "reset", "report", "service", "out", "respond", "one", "res", "application", "output", "given", "tree", "reply", "network", "Response", "body", "next", "json", "frame", "description", "data", "remote", "status", "result"], "responseString": [" responseArray", "replySystem", "ResponseObject", "responseSystem", "replyStr", "replystring", "messageString", "messageObject", "responseText", "resultString", "replyString", "ResponseArray", "ResponseString", "resultstring", "ResponseStr", "responseStr", "outputText", "answerObject", "outputArray", " responseSystem", "resultStr", " responseText", "ResponseSystem", "resultObject", " responseObject", "outputStr", "messagestring", "answerStr", " responsestring", "outputString", "messageStr", "Responsestring", "responsestring", "responseArray", "answerString", " responseStr", "answerstring", "ResponseText", "responseObject"], "jsonResponse": ["JSONRequest", "jsonData", "JSONResp", "xmlRequest", "jsonObject", "JSONData", "sonStatus", "sonObject", " jsonResp", " jsonData", "csvAnswer", "sonAnswer", " jsonObject", "csvResponse", "sonData", "jsonStatus", " jsonStatus", "sonError", "sonResp", "JSONObject", " jsonresponse", "jsonAnswer", "jsonresponse", "JSONresponse", "csvStatus", "JSONAnswer", "xmlResp", "xmlResponse", "JSONResponse", "sonresponse", "csvResp", "xmlError", "jsonResp", "sonRequest", " jsonAnswer", "xmlAnswer", "sonResponse", "xmlObject"], "jsonError": ["jsonAuth", "javascriptAuth", "javascriptError", "jError", " jsonQuery", "sonQuery", "javascriptQuery", "JSONAuth", "sonError", "JSONEr", "jQuery", " jsonEvent", "jsonEvent", "jsonQuery", "JSONEvent", "jAuth", "JSONError", "sonResponse", "javascriptEr", "sonEvent", "JSONQuery", "jEr", "jsonEr", "JSONResponse"]}}
{"id1": "3958807", "id2": "18114701", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"loadBinaryStream": ["loadBignedStream", "loadBixedInput", "loadBbinaryStream", "loadEmbbinaryStream", "loadEmbinaryFile", "loadBixedStreamer", "loadEmbbinaryInput", "loadEmbinaryStreamer", "loadBignedStreamer", "loadBbinaryFile", "loadEmbinaryStream", "loadBignedFile", "loadBinaryStreamer", "loadBignedInput", "loadEmbbinaryStreamer", "loadBinaryInput", "loadBixedFile", "loadBbinaryInput", "loadBinaryFile", "loadBixedStream", "loadEmbinaryInput", "loadBbinaryStreamer", "loadEmbbinaryFile"], "streamName": ["recordNAME", "StreamNAME", "streamType", "StreamName", "recordHandle", "stringType", "recordName", " streamType", "fileNAME", "streamHandle", "fileName", "streamPath", " streamHandle", "resourceName", "resourceNAME", "streamname", "recordname", "stringName", "streamNAME", " streamPath", "longPath", "Streamname", "longNAME", "StreamHandle", " streamNAME", "stringNAME", "resourceType", " streamname", "longName", "filePath"], "streamToLoad": ["stream2Read", "streamToUse", " stream2Use", "streamWillLoad", "stringWillload", "stringToload", " streamToRead", "stringToLoad", " stream2load", "streamToRead", "stringToAdd", "stream2Load", "streamTOAdd", "streamTOload", "streamTOLoad", "streamWillload", " stream2Read", "streamTORead", "stream2Use", " streamToload", "streamTOUse", "streamtoLoad", " stream2Load", "streamToload", " streamWillload", "stream2load", " streamToUse", "stringWillAdd", "streamtoload", "streamToAdd", "stringWillLoad", "streamWillAdd", " streamWillLoad", "streamtoAdd"], "sz": ["Siz", "insch", "sld", " siz", "rsld", "sch", " sze", "rsiz", "sze", "insiz", "Sze", "insze", "insz", "Sld", "rsz", "siz", "Sch", "Sz", " sld", "rsze", " sch"], "req": ["dq", "http", "Requ", "attr", "pkg", "wx", "urg", "require", "gr", "quest", "sq", "pas", "client", "cur", "request", "q", "proc", "org", "res", "seq", "quick", "cmd", "ctx", "rx", "comm", "jp", "usr", "qt", "query", "inv", "comp", "fr", "requ", "Request", "wcs", "qq", "qs"], "resp": ["ret", "rep", "os", "re", "cmp", "pos", "http", "Res", "rend", "https", "wx", "esp", "soc", "gr", "pas", "sp", "client", "p", "obj", "report", "request", "r", "content", "conn", "proc", "wr", "cl", "respond", "sol", "dis", "rec", "res", "rel", " Resp", "respons", "cmd", "fs", "output", "exp", "comm", "jp", "Response", "nt", "body", "conv", "compl", "inv", "fr", "html", "RES", "sys", "Resp", "msg", "vol", "response", "serv", "status", "result"], "out": ["cn", "os", "null", "t", "in", "utt", "w", "bs", "gt", "us", "ot", "o", "ws", "aos", "client", "ts", "obj", "ins", "to", "outs", "log", "io", "sw", "gs", "n", "res", " outs", "output", "ex", "Out", "yout", "nt", "conv", "ou", "oss", "sys", "OUT", "co", "vol", "cos", "net"], "bos": ["fits", "os", "bh", "bones", "bs", "buff", "bat", "oops", "banks", "eros", "ws", "bes", "aos", "ios", "base", "tes", "boards", "uts", "ts", "bo", "mos", "bits", "oids", "bles", "js", "los", "bi", "BS", "ods", "ols", "bin", "oos", "ubis", "bas", "ys", "jas", "oss", "bot", "des", "sys", "bytes", "nos", "bis", "dos", "obs"]}}
{"id1": "350482", "id2": "19378010", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doFeaturecheck", "doVersionTest", " doVersionscheck", "doImageTest", "doVersionInfo", "doFeatureInfo", " doApplicationTest", " doApplicationInfo", "doVersioncheck", "doBuildTest", "doFeatureTest", "doVersionscheck", "doImageQuery", " doVersionsTest", "doApplicationCheck", " doVersionInfo", " doApplicationCheck", "doVersionsUpdate", "doApplicationQuery", " doVersioncheck", "doBuildCheck", " doVersionQuery", " doVersionTest", "doBuildcheck", "doFeatureUpdate", " doVersionsCheck", "doVersionsCheck", " doApplicationQuery", "doApplicationTest", "doBuildUpdate", " doVersionUpdate", "doFeatureQuery", "doImageCheck", "doFeatureCheck", "doImageInfo", " doVersionsUpdate", "doVersionsTest", "doApplicationInfo", "doVersionUpdate", "doVersionQuery"], "view": ["iew", "project", "row", "http", "update", "document", "engine", "component", "h", "version", "block", "check", "ml", "cell", "client", "this", "buffer", "image", "v", "views", "context", "port", "report", "print", "layout", "call", "q", "window", "controller", "see", "widget", "View", "page", "tree", "VIEW", "virtual", "input", "server", "show", "index", "query", "review", "manager", "html", "tv", "pool", "cv", "form", "model", "file", "subject", "box", "vm", "self", "lock", "display", "eye", "browser"], "url": ["pl", "domain", "bel", "ur", "oul", "http", "hl", "link", "b", "ref", "host", "get", "gl", "build", "address", "client", "v", "uri", "l", "f", "sl", "r", "nl", "log", "rl", "str", "rel", "mount", "ssl", "char", "Url", "mail", "ul", "html", "file", "loc", "lb", "ll", "dl", "job", "URL", "browser"], "in": ["gin", "info", " IN", " din", "In", "stream", "cin", "on", "inf", "inn", "ain", "mn", "ins", "can", "rin", "f", "l", "reader", "inc", "out", "source", "n", "ln", "IN", "from", "init", "isin", "inner", "input", "sin", "din", "body", "asin", "i", "mat", "is", "vin"], "bin": ["gin", "re", "bg", "spin", "binary", "buff", "b", "thin", " din", " bins", "ebin", "bn", "cin", "stock", "inn", "brain", "buffer", "ins", "rin", "mon", "by", "reader", "sam", "obin", "out", "cache", "ln", "cos", "bi", "bl", "local", "win", "init", "bur", "rb", "inner", "lib", "con", "all", "jin", "sin", "din", "body", "abin", " Bin", "bed", "session", "conv", "db", "cb", "file", "ran", "len", "nb"], "line": ["record", "LINE", "row", "detail", "column", "err", "parse", "link", "sample", "lo", "rule", "stay", "eline", "range", "tile", "inline", "base", "stream", "block", "ice", "part", " block", "ine", "cell", "message", "Line", "sequence", "port", "l", "log", "print", "lines", "code", "ln", "cmd", "iter", "cat", "lin", "string", "page", "style", "section", "word", "char", "next", "le", "point", "zone", "trace", "frame", "comment", "status", "file", "lane", "channel", "job", "entry", "field", "key", "chain", "liner"], "develBuild": ["deployBuilt", "devBuilder", "desVELBuild", "deffBuild", "deffbuild", "DeVELBuild", "devBuild", "deVELLog", "develBuilt", "desVELbuild", "desvelBuild", "duffBuilt", "DevelBuild", "DeVELbuild", "devLog", "deffBuilder", "depoBuild", "duVELBuilder", "duVELBoot", "Develbuild", "develbuild", "develBoot", "deVELbuild", "deploybuild", "duffBuild", "duvelBuilder", "deployBuild", "duVELBuild", "devbuild", "DevelLog", "duvelbuild", "develLoad", "desVELRelease", "duffBuilder", "develLog", "deeltaBuild", "duffbuild", "desvelRelease", "DeVELBuilt", "deeltaRelease", "desvelLoad", "deployRelease", "duvelBuilt", "deVELBuild", "duVELbuild", "deVELLoad", "depobuild", "depoBuilt", "desVELLoad", "deeltabuild", "deeltaLoad", "deVELBuilt", "deployLoad", "DevelBuilt", "deffBuilt", "deployBoot", "duvelBoot", "depoLog", "deVELBoot", "DeVELLog", "develBuilder", "devBuilt", "develRelease", "devBoot", "duvelBuild", "desvelbuild", "deVELBuilder", "deployBuilder", "deVELRelease"], "stableBuild": ["devBuilder", "secureBuild", "devBuild", " unstableCraft", " stablebuild", " stableBuilder", "activeBuild", "secureCraft", " unstableLong", "stableBoot", " stableLong", " unstablebuild", " unstableBuild", " stableBind", " unstableBind", "stableBind", "devbuild", "securebuild", "activeMake", "stablebuild", " stableBoot", "confirmedLong", "confirmedbuild", " unstableBoot", "devMake", "stableBuilder", "stableLong", "activeBuilder", "confirmedBoot", "confirmedBuild", "stableCraft", "activebuild", " stableCraft", " stableMake", "secureBuilder", " unstableBuilder", "devBind", "stableMake"]}}
{"id1": "18989018", "id2": "23677147", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"doSetInput": [" doGetData", "doSetinput", "doHandleData", "dosetOutput", "doHandleinput", " doSetinput", " doGetOutput", "dosetinput", "doGetInput", "doHandleInput", " doSetData", "dosetData", " doGetInput", "doHandleOutput", "doGetinput", "doSetData", " doSetOutput", "doGetOutput", "dosetInput", "doGetData", " doGetinput", "doSetOutput"], "input": ["info", "what", "get", "up", "add", "version", "context", "control", "doc", "op", "argument", "plugin", "from", "init", "att", "supp", "conf", "qa", "attribute", "note", "active", "ia", "table", "submit", "it", "raw", "error", "client", " Input", "password", "print", "um", "request", "select", "act", "query", "config", "xml", "form", "key", "command", "ion", "history", "this", "arg", "primary", "unknown", "cmd", "ip", "pattern", "def", "present", "initial", "text", "upload", "cont", "ch", "p", "image", "focus", "content", "al", "Input", "output", "local", "instance", "via", "support", "ix", "edit", "wa", "entry", "field", "accept"], "monitor": ["hist", "process", "m", "processor", "watch", "im", "progress", " Monitor", "handler", "mi", "rain", "timer", "history", "system", "message", "wm", "runner", "summary", "report", "mon", "log", "sam", "window", "console", "dm", "timeout", "stat", "mx", "state", "inner", "Monitor", "meter", "man", "manager", "cm", "program", "pool", "display", "mr"], "root": ["project", "ms", "m", "storage", "null", "pkg", "Root", "h", "util", "host", "base", "roots", "prefix", "scope", "room", "top", "home", "parent", "store", "system", "context", "p", "resource", "directory", "owner", "r", "folder", "window", "oot", "res", "node", "mount", "ro", "local", "container", "tree", "oots", "server", "target", "manager", "sys", "localhost", "box", " Root", "RO", "mr"], "format": ["process", "mod", "module", "api", "feed", "parse", "Format", "tif", "supported", "util", "base", "fm", "version", "MAT", "ct", "filter", "unit", "spec", "map", "f", "layout", "fill", "feature", "service", "transform", "term", "cf", "set", "fc", "act", "feat", "former", "metadata", "title", "pattern", "template", "class", "actor", "config", "at", "form", "xml", "policy", "tool", "type", "filename", "struct", "attribute"], "source": ["src", "details", "SOURCE", "se", "reason", "address", "context", "port", "license", "from", "index", "proxy", "relation", "trace", "display", "filename", "shell", "join", "note", "sample", "table", "raw", "report", "service", "out", "scan", "console", "site", "find", "style", "template", "body", "session", "Source", "view", "scope", "ser", "store", "iterator", "this", "buffer", "spec", "string", "i", "is", "remote", "ne", "secret", "null", "object", "base", "parent", "sp", "sequence", "resource", "image", "wrapper", "cache", "ource", "local", "output", "language", "copy", "state", "inner", "origin", "dest", "target", "size", "data", "handle"], "in": ["gin", "src", "thin", "get", "add", "can", "io", "doc", "inc", "from", "init", "en", "index", "inside", "el", "as", "sql", "it", "raw", "ind", "internal", "out", "scan", "ln", "body", "xml", "serv", "include", "on", "ini", "store", "iterator", "this", "buffer", "ain", "rin", "pin", "iter", "IN", "isin", "all", "din", "i", "is", "text", "In", "null", "nin", "mi", "cin", "inn", "id", "p", "image", "resource", "ins", "l", "ic", "reset", "reader", "local", "create", "win", "copy", "bin", "inner", "container", "con", "sum", "ma", "size", "data"], "path": ["api", "pkg", "address", "system", "context", "port", "log", "member", "route", "th", "user", "from", "index", "trace", "full", "join", "pos", "po", "ath", "where", "pi", "home", "ith", "physical", "print", "temp", "transform", "pro", "near", "location", "template", "Path", "loc", "key", "dir", "pt", "link", "length", "ref", "history", "cp", "pointer", "folder", "mount", "rel", "string", "pattern", "alias", "PATH", "item", "host", "base", "prefix", "parent", "name", "p", "resource", " PATH", "set", "local", "tree", "dest", "point", "pr", "entry", "time", "policy", "chain", "prop"], "s": ["src", "m", "storage", "t", "http", "b", "https", "c", "simple", "us", "h", "ls", "ss", "has", "a", "space", "socket", "sq", "store", "ts", "p", "v", "l", "f", "sl", "r", "sw", "sam", "sf", "sm", "gs", "sol", "js", "fs", "sv", "S", "g", "single", "st", "set", "rs", "sb", "stat", "sts", "ssl", "conf", "sa", "i", "abs", "sys", "is", "serv", "stats", "ps"], "file": ["info", "item", "File", "t", "ile", "binary", "FILE", "link", "table", "il", "fp", "object", "supported", "key", "tile", "base", "be", "e", "value", "files", "media", "use", "name", "id", "message", "p", "image", "resource", "obj", "port", "l", "library", "f", "io", "content", "sf", "fo", "fs", "node", "from", "local", "location", " File", "class", "original", "le", "i", "form", "data", "type", "filename"], "uri": ["domain", "u", "ur", "note", "http", "phrase", "URI", "phi", "link", "pid", "qi", " URI", "ref", "du", "range", "reference", "prefix", "pi", "ui", "address", "id", "image", "resource", "unit", "directory", "uu", "route", "request", "term", "iri", "nu", "uid", "local", "location", "origin", "copy", "template", "ri", "char", "doi", "query", "i", "html", "form", "description", "msg", "subject", "uni", "remote", "volume", "filename", "chain", "result", "dir"], "url": ["ur", "api", "u", "http", "link", "href", "ref", "ls", "host", "get", "gl", "address", "name", "resource", "l", "f", "sl", "r", "nl", "rl", "term", "str", "rel", "mount", "location", "ssl", "string", "char", "Url", "mail", "ul", "dl", "ll", "channel", "open", "URL", "browser"], "cd": ["dn", "DC", "pd", "ec", "ld", "xd", "kb", "rd", "desc", "cc", "ct", "idd", "cp", "dc", "cs", "md", "od", "bd", "sd", "gb", "did", "de", "cmd", "dm", "cf", "ctr", "cr", "td", "ds", "db", "cm", "hd", "dt", "CD", "cod", "vd", "dd", "d"], "valid": ["full", "info", "bad", "solid", "active", "VAL", "empty", "val", "supported", "found", "available", "required", "check", "used", "v", "normal", "multi", "md", "recent", "by", "al", " invalid", " Valid", "test", "basic", "allowed", "good", "local", "visible", "dev", "all", "related", "def", "current", "present", "more", "ma", "form", "defined", "formed", "Valid", "open", "legal", "multiple"], "stream": ["dd", "Stream", "row", "sc", "im", "upload", "read", "sample", " upstream", "empty", "ous", "speed", "raw", "ream", " streaming", "store", "steam", "buffer", "image", "resource", "context", " streamed", "reader", "content", "sam", "sw", "out", "transform", "clean", "console", "Steam", "REAM", "instance", "pool", "form", "data", "is", "channel", "ess", "view", "response", " Stream"], "document": ["record", " documents", "m", "Open", "Supported", "_", "Exception", "FILE", "cont", "object", "information", "Internal", "value", "Store", "media", "message", "context", "image", "resource", "New", "doc", "content", "number", "Required", "output", "NULL", "language", "string", "Document", "instance", "index", "json", "Context", "IA", "Source", "ocument", "data", "text", "collection"]}}
{"id1": "17296916", "id2": "13563706", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 1, "substitutes": {"logging": [" logStorage", " logger", "loging", "Logger", "LogStorage", "logger", "logStorage", "Loging", " loging", "debuging", "debugging", "debugStorage", "Logging", "debugger"], "wrap": ["handle", "ad", "w", "zip", "parse", "link", "read", "gate", "wx", "ws", "grow", "get", "W", "pad", "add", " wrapped", "aw", "wind", "python", "store", "sp", "build", "use", "message", "ow", "wrapper", "reset", "sw", "transform", "x", "window", "me", "ew", " wrapper", "safe", "find", "pack", "create", "start", "inter", "work", "word", "wire", "root", "wra", "rap", "web", "force", "box", "wa", "form", "chain", "nw", "format", "xf", "we", "shape"], "buffer": ["bar", "memory", "row", "note", "phrase", "binary", "buff", "table", "surface", "document", "batch", "base", "reference", "line", "block", "Buffer", "bb", "flash", "store", "quote", "message", "sequence", "writer", "bo", "pb", "directory", "report", "print", "library", "wrapper", "reset", "flag", "queue", "cache", "window", "buf", "console", "builder", "output", "profile", "iter", "reply", "template", "word", "position", "screen", "bridge", "body", "database", "ob", "trace", "face", "frame", "header", "size", "view", "layer", "button", "display", "command", "complete", "attribute", "append"], "encoding": ["enumging", "Encoding", "enaling", "enging", "clanguage", "enoding", "cododing", "enlanguage", "cododed", "encging", "enoded", "ecoding", "enclanguage", "enryption", "Encryption", "coding", "ecoded", "encoded", "caling", "enumoder", "cging", "cryption", "encaling", "encoder", "ecryption", "encryption", "coder", "enumlanguage", "enoder", "ecoder", "cododer", "Encoder", "codryption", "Encaling", "enumoding"], "getEncoding": ["getEncling", "getEnging", "getExpging", "getEnling", "getEncination", "getOrigoding", "getencling", "getOrigination", " getEnging", "getOrigling", "getEnination", " getEncging", "getEnression", "getExpryption", " getEnoding", " getEncryption", "getencryption", "getencoding", "getencination", " getEncression", "getOrigryption", " getEnling", " getEnryption", "getEncression", "getExpression", " getEnression", "getEnoding", " getEncling", "getExpoding", "getencging", "getEncryption", "getencression", " getEnination", "getEncging", " getEncination", "getEnryption"], "headers": ["styles", "modules", "frames", "params", "authors", "codes", "ctors", "relations", "values", "users", "ers", "pins", "heads", "checks", "blocks", "fields", "comments", "members", "ilers", "ids", "caps", "weights", "rs", "groups", "objects", "boxes", "keys", "holders", "ports", "writers", "drivers", "properties", "head", "terms", "reports", "pres", "names", "header", "builders", "chains", "ppers", "limits", "images", "tags", "ters"], "is": ["was", "os", "sis", "ms", "isl", "in", "bs", "us", "ios", "lis", "has", "osi", "isi", "its", "or", "isc", "tis", "ui", "iss", "ists", "ins", "ic", "isf", "does", "ois", "dis", "fs", "mis", "ist", "iris", "nis", "ip", "isin", "si", "ri", "\u00eds", "ris", "ys", "iso", "isd", "i", "sys", "as", "Is", "IS", "ais", "ims", "bis", "isa", "obs"], "bos": ["fits", "os", "ms", "bh", "bones", "ones", "bs", "oops", "banks", "eros", "bes", "aos", "ios", "soc", "tes", "isi", "boards", "lets", "tis", "ui", "uts", "ts", "cs", "bo", "ows", "bits", "oids", "ses", "js", "fs", "los", "bi", "ods", "ols", "bin", "oos", "ubis", "bas", "tops", "jas", "ys", "windows", "pod", "oss", "uds", "bot", "sys", "des", "nos", "bytes", "ots", "stats", "bis", "cos", "dos", "ps", "obs"], "e": ["m", "re", "t", "err", "ee", "c", "ge", "o", "h", "a", "se", "ed", "es", "oe", "error", "p", "v", "er", "ae", "f", "r", "ev", "x", "E", "n", "g", "me", "de", "ex", "eeee", "en", "ie", "exc", "ate", "le", "i", "ne", "d"]}}
{"id1": "16353490", "id2": "14464131", "code1": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"executePost": [" performpost", " performPOST", "executePOST", " executeGet", " executePOST", "execGet", " executepost", "executepost", "execPOST", " performGet", "execpost", " performPost", "executeGet", "execPost"], "targetURL": ["targetUrl", "templateUrl", "TargetURL", "baseUrl", "TargetUrl", "sourceLocation", "sourceUrl", "baseLocation", "baseID", " targetID", "baseUR", "targetURI", "templateURL", " targetUrl", "targetID", "targetUR", "sourceURL", "templateID", "targetLocation", "templateURI", "TargetUR", "sourceUR", " targetURI", "baseURI", "baseURL", "TargetLocation"], "urlParameters": [" urlNames", "URLParameter", " urlTypes", "rowRequirements", "urlTypes", "rowParameter", "rowNames", "URLTypes", "URLParameters", "UrlParameters", "UrlParameter", "uriParameter", " urlDetails", "uriParameters", "urlParameter", "uriArgs", "UrlArgs", "rowParameters", "UrlTypes", "UrlNames", "urlArgs", " urlParameter", " urlRequirements", "UrlDetails", "urlRequirements", " urlArgs", "URLDetails", "urlDetails", "urlNames", "UrlRequirements"], "url": ["pl", "ur", "u", "t", "http", "hl", "link", "https", "document", "il", "path", "github", "ref", "ls", "host", "get", "gl", "base", "ml", "build", "address", "name", "resource", "uri", "l", "log", "sl", "r", "nl", "rl", "loader", "org", "str", "mount", "www", "location", "ssl", "Url", "web", "mail", "ul", "file", "ll", "dl", "open", "URL"], "connection": ["c", "government", "socket", "system", "context", "bo", "library", "io", "operation", "number", "license", "still", "node", "user", "see", "database", "relation", "closure", "subject", "channel", "generation", "attribute", "nc", "note", "Connection", "client", "conn", "console", "you", "location", "session", "query", "city", "open", "command", "creator", "office", "link", "document", "ion", "option", "component", "termination", "statement", "creation", "condition", "or", "when", "directory", "pointer", "application", "controller", "function", "current", "position", "communication", "connect", "initial", "remote", "collection", "close", "engine", "object", "character", "reference", "cone", "information", "general", "device", "message", "resource", "writer", "cache", "write", "connected", "method", "no", "set", "create", "associated", "language", "container", "con", "network", "description", "entry", "volume"], "wr": ["bh", "rw", "wb", "shr", "tw", "w", "WR", "dx", "mk", "rew", "wid", "wrote", "rus", "wm", "writer", "RW", "mt", "r", "spr", "ocr", "sw", "iw", "hr", "mg", "ln", "ru", "writ", "wn", "Wr", "wy", "wer", "fr", "inv", "pr", "ptr", "wt", "kr", "wa", "nw", "wk", "vr", "we", "mr", "vet", "adr"], "is": ["os", "sit", "ms", "sis", "isl", "im", "in", "isa", "ii", "ios", "lis", "se", "isi", "its", "isc", "iss", "ins", "s", "does", "ai", "ih", "still", "iris", "nis", "rs", "si", "ri", "\u00eds", "ris", "iso", "xs", "i", "sys", "IS", "Is", "ais", "bis", "ir", "are"], "rd": ["rt", "lr", "rw", "dq", "rob", "ld", "rar", "rand", "mr", "erd", "nd", "RD", "rer", "rus", "rm", "ra", "r", "reader", "rl", "rg", "hr", "rect", "ru", "rs", "rx", "cr", "nder", "dr", "rb", "rpm", "ri", "rid", "sr", "ird", "din", "rr", "fr", "ptr", "ry", "red", "rn", "rh", "dd"], "line": ["record", "LINE", "row", "column", "phrase", "link", "sample", "ode", "ge", "rule", "eline", "range", "inline", "se", "e", "block", "ice", "error", "name", "cell", "message", "list", "Line", "sequence", "buffer", "l", "print", "log", "code", "ln", "stroke", "lin", "page", "string", "word", "point", "mail", "frame", "comment", "header", "file", "lane", "entry", "ine", "label", "text", "liner", "command"], "response": ["answer", "detail", "resp", "object", "onse", "success", "version", "value", "block", "message", "buffer", "sequence", "image", "summary", "report", "print", "reset", "content", "service", "request", "example", "application", "res", "respons", "output", "csv", "tree", "reply", "position", "render", "network", "Response", "server", "continue", "next", "json", "relation", "html", "frame", "description", "model", "view", "entry", "format", "display", "command", "result", "vector", "collection"]}}
{"id1": "2465747", "id2": "2668634", "code1": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"postRequest": ["postQuery", "PostRequest", "PostCommand", "postCommand", "processCommand", "Postrequest", "PostQuery", " postrequest", " postQuery", "processrequest", "postrequest", "processQuery", "processRequest", " postCommand"], "urlString": ["sslRaw", "urlName", "lSource", "lSeries", "uriString", "UrlStr", "urlRaw", "uriSource", " urlSeries", "UrlName", "urlSeries", "lName", "lRaw", "UrlSource", "urlStr", "urlSource", " urlRaw", "uriName", "sslSeries", " urlStr", "sslStr", "UrlString", "lString", "sslString", "lStr", "uriStr"], "data": ["info", "record", "dict", "details", "ata", "update", "params", "table", "done", "DATA", "resources", "default", "batch", "results", "none", "value", "store", "settings", "filter", "name", "message", "p", "resource", "post", "to", "map", "content", "cache", "action", "user", "extra", "dat", "metadata", "missing", "state", "def", "properties", "meta", "json", "session", "times", "hash", "description", "form", "response", "format", "images", "text", "d"], "returnData": ["resultData", "returnDATA", "fullDATA", " returnDATA", "saveText", "getString", "ReturnText", "fullData", "reportData", "resultText", "reportDat", "reportLine", "ReturnDATA", "saveDATA", "getText", " returnQuery", "returnText", " returnString", "resultString", "returnLine", "ReturnQuery", "getDATA", "saveData", "returnDat", "ReturnLine", "saveQuery", " returnLine", "ReturnData", "returnQuery", "fullLine", "returnString", "ReturnString", "commentLine", "reportDATA", "getData", "fullDat", "commentDat", " returnText", "commentData", "resultLine", "commentDATA"], "url": ["re", "bel", "ur", "u", "http", "link", "b", "https", "ls", "get", "base", "gl", "build", "address", "client", "uri", "l", "f", "sl", "r", "nl", "call", "log", "conn", "str", "org", "loader", "mount", "google", "location", "ssl", "Url", "mail", "ul", "ll", "dl", "job", "open", "URL"], "connection": ["nc", "creator", "link", "https", "c", "document", "ion", "statement", "creation", "character", "cone", "condition", "general", "established", "socket", "use", "Connection", "client", "message", "resource", "directory", "to", "l", "uri", "wrapper", "io", "pointer", "conn", "service", "connected", "operation", "number", "n", "application", "function", "no", "using", "container", "con", "position", "network", "database", "session", "relation", "manager", "communication", "city", "connect", "online", "description", "subject", "response", "channel", "entry", "open", "cert", "command"], "out": ["pretty", "os", "null", "t", "w", "b", "ion", "ch", "o", "up", "aos", "list", "client", "buffer", "v", "writer", "obj", "p", "to", "outs", "print", "l", "io", "r", "flush", "can", "log", "write", "conn", "n", "g", "console", "user", "output", "ex", "Out", "inner", "all", "con", "screen", "outer", "conv", "ou", "i", "at", "cm", "OU", "auto", "OUT", "co", "net"], "keySet": [" keyset", "KeyMap", " keyList", "numList", "KEYMap", "keySpec", " keySpec", "keysMap", "verset", "KEYName", "keysSet", "verSet", "keyMap", "rowSet", "keyName", "KEYSpec", "numSet", "verList", "keysList", "rowList", "verMap", "KeyList", "numName", "KEYList", "numset", " keyName", " keyMap", "rowSpec", "KEYSet", "keyset", "Keyset", "keyList", "KeyName", "keysName", "KeySet"], "values": ["UES", "modules", "lists", "actions", "params", "bs", "codes", "versions", "services", "vs", "forms", "events", "ves", "rows", "bes", "roots", "points", "results", "its", "files", "value", "issues", "settings", "users", "views", "flows", "items", "pins", "blocks", "fields", "members", "pes", "fs", "sets", "rules", "verts", "als", "groups", "objects", "vals", "keys", "types", "ports", "properties", "windows", "terms", "times", "changes", "names", "Values", "tests", "strings", "gets", "options", "tags", "maps", "obs"], "count": ["err", "cloud", "empty", "consider", "c", "coll", "repeat", "add", "cd", "frequency", "number", "country", "code", "ount", "conf", "cycle", "num", "index", "make", "table", "amount", "currency", "found", "ind", "cell", "client", "last", "flag", "find", "child", "continue", "loop", "and", "length", "total", "Count", "batch", "unique", "check", "ct", "list", "call", "account", "n", "mount", "test", "cmd", "all", "current", "next", "first", "force", "ask", "const", "month", "OUNT", "counter", "\u00e7", "cont", "base", "valid", "now", "id", "name", "sequence", "group", "create", "ctr", "title", "state", "con", "nt", "sum", "size", "contact", "handle", "hold"], "in": ["gin", "re", "read", " din", "mi", "cin", "pi", "on", "it", "or", "raw", "check", "inf", "ini", "inn", "ind", "buffer", "mn", "ins", "ic", "l", "rin", "io", "reader", "r", "inc", "al", "source", "from", "IN", "en", "isin", "bin", "inner", "conf", "input", "din", "body", "ma", "i", "inside", "form", "is", "and", "In"], "inputLine": ["evalData", " inputRow", "textSet", " inputData", "contextline", " inputLINE", "inputData", "outputRow", "textFile", "evalLine", "outputline", "viewLine", " inputFile", "textLine", "textData", "InputData", " inputline", "evalFile", "inputSet", "contextLINE", "contextRow", "inputFile", "contextLine", "outputLine", "outputLINE", "evalSet", " inputSet", "viewline", "inputLINE", "viewData", "InputRow", "inputline", "viewRow", "Inputline", "InputLine", "inputRow"]}}
{"id1": "2396191", "id2": "18164929", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFromHTTPfast", "getLinksFormURLfast", "getLinksFormURLFast", "getLinksFormHTTPfast", "getLinksFromURISafe", "getLinksFromURIfast", "getLinksFormHTTPFast", "getLinksFromUrlfast", "getLinksFormHTTPSafe", "getLinksFromURIFast", "getLinksFromURLfast", "getLinksFromHTTPSafe", "getLinksFromUrlSafe", "getLinksFromUrlFast", "getLinksFromURLSafe", "getLinksFormURLSafe", "getLinksFromHTTPFast"], "p_url": ["private_dir", "p_mail", "adminoymail", "p6html", "private_browser", "x3dir", "pongURL", "p6url", "p64org", "pswurl", "vp_lr", "adminoydir", "p_email", "p_html", "porebrowser", "pswlink", "p_json", "porehtml", "vp_link", "p_page", "p_uid", "p___url", "pingYurl", "pingYpage", "primaryongemail", "private_html", "adminoyuid", "poymail", "ping_page", "postonorg", "p3uri", "postonurl", "pingYlr", "pongemail", "primary_url", "poreurl", "p_browser", "poydir", "ping_line", "primary_URL", "vp_url", "admin_dir", "pswlr", "p_line", "primary_org", "p_org", "pongurl", "primaryongurl", "p3url", "x_lr", "primary_email", "admin_uid", "ping_lr", "private_url", "poyuid", "admin_url", "p___page", "pswjson", "p6browser", "pYpage", "pingYline", "primaryongorg", "admin_mail", "p3lr", "postonemail", "ping_url", "p64email", "poredir", "p_lr", "p___lr", "p64URL", "poyurl", "adminoyurl", "pongorg", "p_URL", "x_uri", "primaryongURL", "x3lr", "pYurl", "p___line", "p_dir", "p_link", "p_uri", "p6dir", "vp_json", "pYlr", "x3uri", "p64url", "postonURL", "p3dir", "x3url", "pYline"], "x_url": [" x_ls", " x_web", "x_ls", "x_log", "x_cn", "xJurl", " x_log", "x_web", "x_net", " x_cn", "xJlog", "xJweb", " x_net", "xJnet"], "x_conn": ["x3client", "x_con", "x_nt", "p_connection", "x3connection", "p_con", "x3conn", "x_connection", " x_client", " x_nt", "p_conn", "x3nt", "x_client", "p_ws", "x_ws", " x_connection"], "x_is_reader": ["x_isresparser", "x_isresrx", "x_is_Reader", "x_is_read", "x_is2read", "x_is2writer", "x_ais_writer", "x_is2Reader", "x_ais_reader", "x_isresreader", "x_is2reader", "x_ais_parser", "x_is_parser", "x_ais_rx", "x_isreswriter", "x_is_rx", "x_is_writer"], "x_reader": ["ex_rr", "x8rot", "rx_writer", "x_stream", "x_rr", "ex_writer", "x8reader", "rx_reader", "ex_reader", "rx_buffer", "x_writer", "x8writer", "x_rot", "x8buffer", "x_buffer", "rx_rot", "ex_stream"], "x_line": ["xmypage", "xLEstream", "x_print", "x_____print", "ex_route", "xLEline", "xLEiter", "xmyiter", "x_____match", "ex_page", "x_stream", "ex_link", "xmyline", " x_print", "x_____page", "ex_iter", "x_____line", "xmystream", "x_iter", "xLEpage", "x_route", "ex_stream", "ex_line"], "e": ["m", "re", "u", "t", "err", "eps", "ent", "ee", "ec", "c", "eur", "ge", "end", "o", "h", "a", "se", "be", "ed", "es", "oe", "fe", "ce", "EEE", "y", "ere", "ze", "er", "ae", "l", "element", "f", "ele", "ea", "r", "ev", "x", "one", "E", "n", "g", "me", "pe", "de", "eb", "eeee", "exp", "en", "ie", "ef", "le", "te", "eg", "ye", "el", "xe", "eu", "ne", "ue", "he", "ei", "we", "event", "et", "d"], "x_match": ["xi_move", "x_process", " x_mat", "x_tag", "x10member", " x_find", "ex_member", "x2mat", "x_fire", "rx_mat", "x67match", "x67mat", "xi_match", "x_entry", "x___tag", " x2member", "x_find", "rx_member", "x___move", "x__find", "x67member", "xi_message", "x_message", "x___mat", "x67process", " x_process", "ex_result", "x_member", " x2mat", "x__mat", "rx_tag", "x_mat", "x_look", "ex_match", "x__match", "x___message", "xi_fire", "ex_entry", "x10result", "ex_look", " x2match", "x___fire", "x2match", "x___match", "rx_match", "x__result", "x2process", " x_member", "x_move", " x2process", "x10entry", "x2member", "x___member", "x10match"], "x_dir": ["x_file", "x_path", "x_div", "x5div", "ex_dir", "x5dir", "ex_path", "ex_div", "ex_file", "x5file", "x5path"], "x_root": ["x__root", "x_path", "inx_path", "x7root", "x__path", "inx7parent", "x7path", "x_parent", "x7target", "x_target", "inx7root", "x7parent", "inx7target", "inx_parent", "inx_root", "x__target", "inx_target", "x__parent", "inx7path"], "x_links": ["x_lines", "x__pages", "x_relations", "x__links", " x_relations", "x_pages", "x__lines", "x__relations", " x_pages", " x_lines"], "x_texts": ["x_paths", "x_logsets", "x_lengths", "x_textsets", "x__textes", "x_pathsets", "x_pathls", "x_textls", "x_textes", "x__textls", "x_lengthsets", "x__textsets", "x_logs", "x__texts", "x_lengthes", "x_loges", "x__logs", "x__logls", "x_logls", "x_lengthls", "x__logsets", "x__loges", "x_pathes"], "x_buf": ["x_buff", "ex2bag", "x2uf", "x64Buff", " x_uf", "x7pool", " x2buff", "x2Buff", "x64temp", "ex2temp", "ex_temp", "x_bag", " x_temp", "ex_bag", " x_buff", "ex2Buff", "x2temp", "x7buff", "ex_Buff", "x64bag", " x2buf", "x7temp", "x_Buff", " x_buffer", " x_pool", "x64buf", " x2temp", "x___temp", "x2pool", "x_uf", "x___bag", "x2bag", "ex_buf", "x___buf", "x_buffer", "x_pool", "x2buff", "x_temp", "x2buffer", " x2pool", "x___Buff", "x7buf", "ex2buf", "x2buf"], "x_matches": ["x__maschers", "x_Mataches", "x2patters", "x_machers", "x_mataches", "x_patchers", "x_patches", "x_formatcher", "x_matchers", "x_matcher", "x_Matchers", "x_patcher", "x2matches", "x__matists", "x_actices", "x_Matcher", "x__masches", "x2patcher", "x_morets", "x_catches", "x_attets", "x_matchches", "x2matcher", "x_morcher", "x_actcher", "x__masists", "x_catets", "x_attists", "x_masets", "x_patets", "x_formatices", "x2patets", "x_catchers", "x_formatches", "x_morches", "x_memchers", "x_matices", "x__matches", "x_matets", "x_matqs", "x_memches", "x_masches", "x_Matqs", "x_maschers", "x_catters", "x_matters", "x__masets", "x2matets", "x2matters", "x_patters", "x_Matches", "x_matchchers", "x_morters", "x_attches", "x_matchcher", "x_memqs", "x_actches", "x_matists", "x_attchers", "x_catists", "x_memaches", "x_formatchers", "x_masists", "x__matchers", "x_maches", "x_maaches", "x_actchers", "x__matets", "x_matchters", "x_maqs", "x2patches", "x_matchets", "x_Matices"], "x_page": [" x_port", "x_pp", "xtpage", "xhomepp", "xturl", "xhomeport", "xtmessage", "x_port", "xhomeline", "x_message", "xhomepage", "x_net", " x_pp", "p_net", "xtline", "p_page", "p_line", " x_message"], "x_link": ["x_path", "x42path", "x_location", "xe_ink", "xe_link", "x42location", "xe_links", " x_location", " x_path", "xe_url", "x42page", "x_ink", "x42link"], "i": ["info", "ji", "m", "iq", "ci", "u", "im", "in", "phi", "j", "gi", "ii", "qi", "fire", "I", "us", "mi", "key", "oi", "batch", "ti", "pi", "it", "di", "ini", "ui", "hi", "id", "this", "y", "v", "multi", "ic", "io", "ai", "x", "n", "ori", "me", "bi", "iter", "ip", "cli", "init", "origin", "si", "ki", "PI", "sim", "li", "ix", "xi", "ami", "is", "fi", "ims", "chain"]}}
{"id1": "2521141", "id2": "23672408", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "drop", "upload", "zip", "link", "archive", "close", "Copy", "get", "delete", "opy", "cp", "io", "sync", "write", "source", "select", "set", "create", "replace", "crop", "export", "move", "save", "share", "clip", "slice", "ate", "transfer", "edit", "cut", "clone", "remove", "file", "insert", "cop", "download", "load"], "from_name": ["from_names", " from_part", " from_no", "from_no", "from_key", "fromkname", "fromkName", " from_filename", " from_info", "from_case", " from_resource", "fromamefilename", "fromameName", "fromamekey", "from_Name", "from_part", "fromamename", " from_key", "from_info", "from_filename", "from_resource", " from_case", "fromkcase", " from_Name", "fromkpart", " from_names"], "to_name": ["to7file", "to_word", "tolyname", "eto_Name", " to_nm", "toNamenew", "to_new", "eto_word", "to_get", "to_Name", "to7get", "to_number", "tolynumber", "eto_name", "toNamefile", "from_new", "tolyfile", "tolynm", "to7new", "toNamename", "toNameget", "to_nm", "from_get", " to_number", "to7name"], "from_file": [" from_node", "to_dir", "fromlyresource", "fromsfile", "fromlyfile", "or_File", " from_time", "from_run", "or_run", "from_File", "from_time", "fromsname", "fromsdir", " from_type", " from_resource", "or_file", "from_type", " from_File", "or_name", "from_node", "fromlyFile", "from_resource", "from_dir", " from_do", "fromlynode", " from_port", "from_do", "from_port"], "to_file": ["to_run", "to_base", "to_dir", "TO_file", "toJFile", "that_tree", "toJdrop", " to_block", "to_files", "that_file", " to_dir", " to_run", "to_element", "toJfile", " to_base", "TO_port", " to_drop", "to_port", " to_local", "to_type", "to_block", "to_link", "toJblock", "from_type", "to_create", "to_tree", "that_link", "that_File", "TO_name", "to_drop", "to_local", "TO_FILE", "TO_element", "from_dir", " to_File", "TO_files", "to_FILE", "to_File", " to_create"], "parent": ["cmp", "null", "pixel", "per", "params", "pid", "where", "my", "rule", "path", "default", "prop", "tar", "prefix", "top", "up", "base", "desc", "block", "Parent", "home", "part", "peer", "sp", "name", "id", "client", "p", "port", "directory", "unit", "master", "owner", "spec", "folder", "temp", "paren", "source", "test", "user", "child", "ip", "timeout", "relative", "pa", "percent", "page", "tree", "mother", "def", "position", "server", "instance", "par", "holder", "root", "man", "point", "ma", "pool", "global", "comment", "form", "file", "remote", "family", "parents", "chain", "event", "shape"], "dir": ["dd", "mod", "dict", "module", "det", "cont", "coll", "path", "di", "del", "part", "ind", "cond", "sp", "cd", "md", "directory", "Dir", "folder", "DIR", "dist", "cur", "str", "rec", "rel", "cmd", "iter", "local", "good", "init", "dr", "def", "tr", "dep", "div", "dim", "db", "addr", "red", "file", "vol", "fd", "loc", "self", "wd", "ir", "d"], "from": ["before", "re", "pos", "orig", "in", "link", "old", "empty", "back", "base", "se", "stream", "func", "on", "or", "check", "store", "error", "client", "false", "normal", "bound", "From", "reset", "by", "io", "with", "out", "source", "term", "window", "no", "st", "left", "local", "start", "user", "init", "set", "en", "inner", "style", "ie", "con", "and", "com", "fun", "query", "fr", "form", "file", "vol", "so", "entry", "ent", "ra"], "to": ["pretty", "tt", "go", "that", "null", "t", "po", "b", "table", "total", "o", "top", "base", "pi", "on", "e", "or", "eto", "client", "ts", "must", "tto", "can", "by", "stable", "op", "ato", "toc", "out", "ta", "no", "To", "output", "will", "token", "two", "nt", "too", "target", "ma", "te", "please", "sys", "into", "auto", "co", "so", "tty", "ne", "TO"], "buffer": ["bar", "memory", "paste", "row", "phrase", "binary", "sample", "buff", "table", "variable", "document", "batch", "base", "character", "block", "Buffer", "available", "message", "sequence", "password", "event", "queue", "cache", "temp", "window", "buf", "function", "stroke", "iter", "page", "template", "word", "char", "database", "frame", "entry", "button", "command", "stack", "attribute", "append"], "bytes_read": ["words_read", "wordsyncwrite", " bytes_write", " bytes2write", "bytes_write", "words_report", "bytes__range", "bytes2Read", "bytes_run", "wordsyncread", "bytes__read", "Bytes_write", " bytes2Read", " bytes2read", "bytes_len", "bytesyncwrite", "wordsyncreport", "bytes_Read", "bytes_report", "bytes2read", "bytes2range", "wordsynclen", "bytes__write", "bytesyncreport", "words_write", "bytes2write", " bytes_range", "Bytes_run", "bytes__Read", " bytes2range", "words_len", " bytes_Read", "Bytes_read", "bytes_range", "bytesyncread", "bytesynclen"]}}
{"id1": "16550855", "id2": "7396682", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "label": 0, "substitutes": {"readPage": ["writepage", "printpage", "printArticle", "printPages", " readpage", " readPages", "readPages", "writePage", "writeArticle", "writePages", "printPage", "readpage", "readArticle", " readArticle"], "ignoreComments": ["oreLeaks", "hideTags", "oreComment", "oreTags", " ignoreBlocks", "hideComment", "hideQuotes", "ignoreComment", "hideComments", "hideNotes", " ignoreNotes", "oreNotes", "oreBlocks", " ignoreQuotes", "ignoreTags", " ignoreLeaks", " ignoreTags", "oreQuotes", " ignoreComment", "ignoreBlocks", "ignoreLeaks", "oreComments", "hideBlocks", "ignoreNotes", "ignoreQuotes", "hideLeaks"], "in": ["info", "m", "read", "b", "thin", " din", "cal", "old", "mc", "h", "url", "get", "up", "cin", "add", "it", "on", "check", "inf", "inn", "ind", "client", "ill", "mn", "ins", "ic", "rin", "io", "reader", "r", "doc", "inc", "out", "al", "from", "IN", "mm", "init", "copy", "en", "isin", "bin", "inner", "all", "con", "input", "conf", "again", "din", "sum", "ma", "i", "cm", "is", "and", "In"], "inputLine": ["InputNet", "rawline", "resultLINE", "rawChain", "InputEntry", " inputRow", "inName", "helloLin", "outputBlock", "latRow", "inputRecord", "indexLINE", "inputName", " inputLINE", " Inputline", "inputLin", "rawLine", "outputRow", "InputBlock", "outputline", " inputName", "indexLine", "inputLo", "inputChain", "helloRow", " inputEntry", "resultName", "helloCell", "helloLo", " inputline", "rawRow", "inputCell", "indexLin", "helloLine", "inLine", "helloNet", "multiLINE", "inLINE", "multiLo", "outputLine", "inputNet", " inputBlock", "multiLin", "InputCell", " inputCell", "inputLINE", "helloBlock", "indexLo", " inputRecord", " InputLine", "latLine", "inputBlock", "inRecord", "helloLINE", "InputRow", "inputline", " inputNet", "latline", "inputEntry", " InputEntry", "resultRecord", "Inputline", " inputChain", "resultLine", "multiLine", "InputLine", " InputBlock", "latChain", "inputRow"], "html": ["pretty", "details", "api", "err", "http", "dump", "attr", "available", "esi", "enabled", "summary", "f", "str", "att", "json", "hash", "hd", "full", "raw", "layout", "hard", "related", "template", "body", "embed", "web", "xml", "header", "form", "view", "rendered", "result", "built", "total", "flash", "plain", "multi", "height", "alert", "rss", "current", "mail", "db", "msg", "ht", "format", "tml", "tt", "detail", "https", "h", "url", "htm", "css", "has", "value", "hover", "message", "p", "md", "HTML", "wrapper", "content", "cache", "js", "output", "theme", "sg", "title", "page", "img", "pdf", "data", "emphasis", "human", "browser"]}}
{"id1": "11865906", "id2": "17974661", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"testIdentification": ["testIDENTifier", "TestIdentify", "Testidentify", "testIDENTify", "testIdifier", "testIdify", "testIdication", "testIDENTification", "TestIdentification", "testIdentify", "testidentify", "testIdentifier", "Testidentication", "testidentifier", "testIdentication", "Testidentification", "TestIdentication", "testidentication", "testidentification", "TestIdentifier", "testIDENTication", "testIdification", "Testidentifier"], "username": ["dn", "project", "lead", "person", "NAME", "pai", "knife", "rue", "sudo", "email", "about", "taker", "component", "your", "stab", "url", "key", "information", "prefix", "character", "displayText", "ubuntu", "name", "approximately", "connection", "otype", "assuming", "sword", "login", "owner", "uri", "account", "admin", "source", "unknown", "term", "wordpress", "uid", "uno", "USER", "seat", "minimum", "twitter", "metadata", "profile", "title", "string", "pty", "\u4eba", "token", "operator", "language", "position", "instance", "john", "ername", "latest", "impact", "localhost", "initial", "subject", "author", "hello", "phone", "albeit", "filename", "attribute", "human", "blood"], "password": ["pass", "secret", "words", "email", "phrase", "picture", "Password", "crypt", "definition", "power", "value", "python", "device", "address", "message", "sword", "login", "reset", "account", "remember", "number", "padding", "confirmed", "height", "application", "profile", "auth", "language", "string", "pattern", "token", "word", "REDACTED", " Password", "database", "hash", "PASS", "description", "comment", "hello", "entry", "command", "shadow", "attribute"], "md5": [" Md3", "sha4", "MD3", "md3", "dig2", "MD5", "sha3", "digol", " md512", " md4", "sha7", " Md512", " md7", "md512", "md2", "sha5", "dig3", " md3", "sha512", "mdol", " mdol", "MD2", "md7", " Md7", "MD4", "md4", " md2", "dig5", " Md5", "MDol"], "logServiceMock": ["logServiceMTck", "logServiceDocked", "logServiceMex", "logServicePOCK", "logServiceVex", "logServiceMMox", "logServicePox", "logStorePOCK", "logServiceMXocker", "logServMck", "logServicemocked", "logServiceMulock", "logServiceManocked", "logServiceVocks", "logServiceJMocker", "logServiceVocker", "logServicemex", "logServiceVock", "logServiceMuock", "logServiceJMocked", "logStoreMocker", "logServiceMuck", "logServicemlock", "logServMlock", "logStorePocker", "logServiceMMock", "logStoreMOCK", "logServicemck", "logServiceMOCK", "logServiceJMock", "logServMocked", "logServMTock", "logServiceVocked", "logServiceManocker", "logServicemOCK", "logServMock", "logServiceMox", "logServicemocker", "logServiceMXocked", "logServiceManocks", "logServMTck", "logServMTocked", "logServicePock", "logServiceMTock", "logServiceMuocked", "logServiceMlock", "logServicemox", "logServiceMck", "logServiceDocker", "logStoreMox", "logServiceMocked", "logServiceDex", "logServMTlock", "logStoreMock", "logStorePox", "logServiceMocker", "logServiceMTocked", "logServiceMMOCK", "logServiceMMocker", "logServiceDock", "logServiceMXock", "logServicemock", "logServiceMocks", "logServiceMTlock", "logServicePocker", "logStorePock", "logServiceManock", "logServicemocks"], "dbServiceMock": ["dbServiceHMox", "dbServiceMck", "dbServiceMaj", "dbServicesMocked", "dbServiceMonocker", "dbServiceMoness", "dbServiceVock", "dbServiceVox", "dbServiceSock", "dbServiceMonox", "dbServicesmocked", "dbServiceMocks", "dbServiceMXck", "dbServiceMocked", "dbStoreMocked", "dbServiceHMocked", "dbServicemock", "dbFactoryMock", "dbServiceSike", "dbServicesMaj", "dbServiceTocked", "dbServicesmaj", "dbServiceTock", "dbStoremox", "dbStoreMox", "dbServiceMonock", "dbServiceTrap", "dbServiceMick", "dbServiceTox", "dbServiceMXock", "dbServicesmock", "dbFactoryMXock", "dbServiceMox", "dbServiceMXocked", "dbServiceVocked", "dbServicemess", "dbServiceVrap", "dbFactoryMck", "dbServicemaj", "dbServiceHMock", "dbStoremrap", "dbStoreMrap", "dbServicemocks", "dbServiceJMocked", "dbServiceSocked", "dbServiceMrap", "dbFactoryMocked", "dbServiceMXocks", "dbStoreMock", "dbServiceSick", "dbServiceSaj", "dbFactoryMXck", "dbServicemike", "dbServicemrap", "dbServiceJMaj", "dbServicesmike", "dbServicesMike", "dbServicemocker", "dbStoremock", "dbServiceSocker", "dbServiceJMock", "dbServiceMonocked", "dbServicemox", "dbServiceMike", "dbServicemck", "dbServicesMock", "dbServiceMocker", "dbServiceVocks", "dbFactoryMXocked", "dbServiceMess", "dbStoremocked", "dbFactoryMXocks", "dbServicemick", "dbFactoryMocks", "dbServiceVck", "dbServicemocked", "dbServiceJMike", "dbServiceHMess", "dbServiceMonick"], "user": ["record", "person", "usage", "creator", "null", "prof", "other", "per", "read", "u", "responsible", "rule", "object", "component", "User", "used", "use", "system", "name", "client", "message", "role", "menu", "list", "to", "report", "owner", "by", "student", "account", "write", "temp", "plugin", "uid", "output", "profile", "USER", "entity", "reply", "word", "core", "char", "usr", "instance", "body", "json", "actor", "comment", "form", "response", "usa", "entry", "contact", "key", "author", "human", "auth", "result"]}}
{"id1": "3584508", "id2": "18504192", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "label": 1, "substitutes": {"copyResource": [" copiedFile", "downloadAddress", " copiedAddress", " copiedUrl", "downloadFile", " copyAddress", " copyFile", " copiedResource", "downloadResource", "copyUrl", "copyFile", " copyUrl", "downloadUrl", "copyAddress"], "url": ["ret", "re", "ur", "null", "http", "hl", "link", "https", "path", "github", "ref", "util", "ls", "base", "gl", "host", "ml", "address", "resource", "l", "uri", "f", "sl", "fl", "nl", "r", "mb", "service", "rl", "cl", "source", "str", "rel", "mount", "ssl", "string", "gif", "char", "Url", "mail", "web", "ul", "el", "html", "file", "loc", "dl", "ll", "cert", "URL", "browser"], "input": ["info", "PUT", "before", "feed", "null", "upload", "http", "in", "exec", "read", "active", "audio", "parse", "empty", "cont", "get", "base", "stream", "up", "add", "raw", "it", "context", "image", "ain", "can", "focus", "reader", "op", "iter", "enter", "request", "Input", "source", "unknown", "select", "user", "local", "start", "ip", "pull", "act", "missing", "state", "inner", "eval", "ssl", "init", "index", "sum", "access", "inside", "config", "qa", "form", "initial", "file", "open", "acl", "text", "accept"], "output": ["null", "exit", "other", "update", "unsigned", "table", "object", "component", "o", "Output", "secure", "success", "four", "icon", "client", "connection", "image", "bool", "group", "beta", "print", "hidden", "write", "out", "put", "console", "you", "entity", "current", "continue", "network", "position", "outer", "next", "ou", "web", "online", "ilo", "auto", "file", "response", "secondary", "format", "ne", "display", "remote", "text", "net"], "b": ["m", "wb", "u", "t", "z", "binary", "bs", "buff", "j", "c", "ab", "bit", "base", "bf", "be", "block", "bb", "ib", "ba", "B", "v", "fb", "obj", "y", "p", "l", "f", "k", "by", "r", "mb", "bits", "gb", "g", "bi", "eb", "sb", "rb", "ble", "char", "br", "bp", "body", "i", "db", "ob", "cb", "nb", "bc", "d"]}}
{"id1": "11475527", "id2": "10540676", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addTextFromurl", "addDataFormurl", "addDataToURL", "addDataFormURL", "addDataTourl", "addDatafromURL", "addTextFormURL", "addDatafromUrl", "addDataFormUrl", "addDataFromUrl", "addDatafromLocation", "addDataToLocation", "addTextFromURL", "addDataFromLocation", "addDataFormLocation", "addTextFromUrl", "addTextFormUrl", "addDataFromurl", "addTextFromLocation", "addTextFormLocation", "addTextFormurl", "addDataToUrl", "addDatafromurl"], "theurl": ["TheUrl", "Theuri", "heloader", "heuri", "teURL", " theloader", " theuri", "thloader", "Theurl", " theURL", "theloader", "teuri", "heURL", "heUrl", "teurl", "thefile", "thfile", "heurl", "theUrl", " theUrl", " thefile", "thUrl", "hefile", "teUrl", "theURL", "TheURL", "theuri", "thurl"], "line": ["record", "LINE", "row", "email", "link", "sample", "rule", "ner", "eline", "inline", "block", "ice", "valid", "day", "cell", "name", "message", "Line", "sequence", "l", "print", "source", "lined", "code", "node", "ln", "stroke", " inline", "lin", "page", "string", "char", "point", "le", "zone", "frame", "online", "header", "status", "lane", "comment", "entry", "ine", "text", "chain", "liner"], "in": ["gin", "t", "include", "read", "lo", "old", "oin", "mc", "o", "mi", "cin", "it", "or", "inf", "inn", "id", "ain", "ins", "l", "rin", "f", "ic", "reader", "r", "pin", "inc", "conn", "out", "ai", "al", "source", "proc", "n", "st", "IN", "from", "win", "init", "en", "isin", "bin", "inner", "con", "input", "again", "din", "phys", "ma", "i", "is", "ac", "serv", "open", "In"], "data": ["join", "info", "feed", "ad", "text", "ata", "read", "DATA", "a", "stream", "raw", "iterator", "client", "this", "buffer", "writer", "io", "reader", "content", "dec", "cache", "out", "window", "user", "dat", "def", "input", "body", "next", "pipe", "query", "size", "file", "bus", "da", "result", "d"], "e": ["m", "re", "t", "err", "ee", "b", "ec", "c", "ge", "o", "h", "a", "se", "be", "or", "ed", "es", "oe", "ce", "error", "y", "p", "ze", "er", "ae", "v", "element", "f", "ve", "ele", "r", "x", "E", "n", "g", "me", "pe", "de", "eeee", "ex", "ie", "le", "te", "i", "eu", "ne", "entry", "ine", "ue", "event", "d"]}}
{"id1": "2521141", "id2": "13891080", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "drop", "upload", "zip", "link", "archive", "close", "Copy", "get", "delete", "opy", "cp", "io", "sync", "write", "source", "select", "set", "create", "replace", "crop", "export", "move", "save", "share", "clip", "slice", "ate", "transfer", "edit", "cut", "clone", "remove", "file", "insert", "cop", "download", "load"], "from_name": ["from_names", " from_part", " from_no", "from_no", "from_key", "fromkname", "fromkName", " from_filename", " from_info", "from_case", " from_resource", "fromamefilename", "fromameName", "fromamekey", "from_Name", "from_part", "fromamename", " from_key", "from_info", "from_filename", "from_resource", " from_case", "fromkcase", " from_Name", "fromkpart", " from_names"], "to_name": ["to7file", "to_word", "tolyname", "eto_Name", " to_nm", "toNamenew", "to_new", "eto_word", "to_get", "to_Name", "to7get", "to_number", "tolynumber", "eto_name", "toNamefile", "from_new", "tolyfile", "tolynm", "to7new", "toNamename", "toNameget", "to_nm", "from_get", " to_number", "to7name"], "from_file": [" from_node", "to_dir", "fromlyresource", "fromsfile", "fromlyfile", "or_File", " from_time", "from_run", "or_run", "from_File", "from_time", "fromsname", "fromsdir", " from_type", " from_resource", "or_file", "from_type", " from_File", "or_name", "from_node", "fromlyFile", "from_resource", "from_dir", " from_do", "fromlynode", " from_port", "from_do", "from_port"], "to_file": ["to_run", "to_base", "to_dir", "TO_file", "toJFile", "that_tree", "toJdrop", " to_block", "to_files", "that_file", " to_dir", " to_run", "to_element", "toJfile", " to_base", "TO_port", " to_drop", "to_port", " to_local", "to_type", "to_block", "to_link", "toJblock", "from_type", "to_create", "to_tree", "that_link", "that_File", "TO_name", "to_drop", "to_local", "TO_FILE", "TO_element", "from_dir", " to_File", "TO_files", "to_FILE", "to_File", " to_create"], "parent": ["cmp", "null", "pixel", "per", "params", "pid", "where", "my", "rule", "path", "default", "prop", "tar", "prefix", "top", "up", "base", "desc", "block", "Parent", "home", "part", "peer", "sp", "name", "id", "client", "p", "port", "directory", "unit", "master", "owner", "spec", "folder", "temp", "paren", "source", "test", "user", "child", "ip", "timeout", "relative", "pa", "percent", "page", "tree", "mother", "def", "position", "server", "instance", "par", "holder", "root", "man", "point", "ma", "pool", "global", "comment", "form", "file", "remote", "family", "parents", "chain", "event", "shape"], "dir": ["dd", "mod", "dict", "module", "det", "cont", "coll", "path", "di", "del", "part", "ind", "cond", "sp", "cd", "md", "directory", "Dir", "folder", "DIR", "dist", "cur", "str", "rec", "rel", "cmd", "iter", "local", "good", "init", "dr", "def", "tr", "dep", "div", "dim", "db", "addr", "red", "file", "vol", "fd", "loc", "self", "wd", "ir", "d"], "from": ["before", "re", "pos", "orig", "in", "link", "old", "empty", "back", "base", "se", "stream", "func", "on", "or", "check", "store", "error", "client", "false", "normal", "bound", "From", "reset", "by", "io", "with", "out", "source", "term", "window", "no", "st", "left", "local", "start", "user", "init", "set", "en", "inner", "style", "ie", "con", "and", "com", "fun", "query", "fr", "form", "file", "vol", "so", "entry", "ent", "ra"], "to": ["pretty", "tt", "go", "that", "null", "t", "po", "b", "table", "total", "o", "top", "base", "pi", "on", "e", "or", "eto", "client", "ts", "must", "tto", "can", "by", "stable", "op", "ato", "toc", "out", "ta", "no", "To", "output", "will", "token", "two", "nt", "too", "target", "ma", "te", "please", "sys", "into", "auto", "co", "so", "tty", "ne", "TO"], "buffer": ["bar", "memory", "paste", "row", "phrase", "binary", "sample", "buff", "table", "variable", "document", "batch", "base", "character", "block", "Buffer", "available", "message", "sequence", "password", "event", "queue", "cache", "temp", "window", "buf", "function", "stroke", "iter", "page", "template", "word", "char", "database", "frame", "entry", "button", "command", "stack", "attribute", "append"], "bytes_read": ["words_read", "wordsyncwrite", " bytes_write", " bytes2write", "bytes_write", "words_report", "bytes__range", "bytes2Read", "bytes_run", "wordsyncread", "bytes__read", "Bytes_write", " bytes2Read", " bytes2read", "bytes_len", "bytesyncwrite", "wordsyncreport", "bytes_Read", "bytes_report", "bytes2read", "bytes2range", "wordsynclen", "bytes__write", "bytesyncreport", "words_write", "bytes2write", " bytes_range", "Bytes_run", "bytes__Read", " bytes2range", "words_len", " bytes_Read", "Bytes_read", "bytes_range", "bytesyncread", "bytesynclen"]}}
{"id1": "3187685", "id2": "16719805", "code1": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"copyJar": [" copyingPath", " copyingJar", " copyPath", " copyFile", "copyPath", " copyingFile", "copyFile", "CopyPath", "CopyJar", "CopyFile"], "src": ["rt", "sc", "rob", "rc", "cont", "syn", "urg", "stock", "usc", "ser", "sq", "s", "ins", "req", "cur", "source", "str", "js", "st", "from", "rs", "start", "sb", "rx", "ctr", "init", "sn", "dest", "iv", "sec", "input", "img", "usr", "sr", "sys", "Source", "inst", "ipl"], "dst": ["Dct", "Dnd", "dddest", " dkt", "Dlt", "dedest", "dend", "ddnd", "Dkt", "dct", "ddest", "deslt", "Ddest", "dnd", "ddst", "dest", "ddct", " dnd", "deskt", "dkt", "dect", "dlt", "Dst", "desst", " dlt", "desnd"], "srcChannel": [" srcContext", "srcchannel", "stchannel", "srcContext", "stChan", "stChannel", "singCategory", " srcManager", "srChan", "sourceConnection", "rcClass", "singContext", " srcChain", "srCategory", "serCategory", "srcClass", "sourcechannel", "singConnection", "srManager", "singChannel", "sbChannel", "rcConnection", " srcConnection", " srcCategory", "serManager", " srcchannel", "srcManager", "rcCategory", "sourceChannel", "sbchannel", " srcChan", "sourceChain", "serChan", "srChannel", " srcClass", "srcConnection", "serChannel", "rcChannel", "srcChan", "rcchannel", "stClass", "rcChan", "srcChain", "sbChain", "rcContext", "srcCategory", "sbChan", "rcChain", "sourceChan"], "dstChannel": ["dnetManager", "dndManager", "dndConnection", "dstConnection", "dndChan", "ddrRow", "dstManager", "dmtChannel", "dstchannel", "dnetChannel", "dotConnection", "ddrchannel", "ddestChannel", " dotConnection", "dotChan", "dstWriter", "dndRow", "dstschannel", " dotChan", "ddestRow", " dstChan", "dstsConnection", " dstButton", "dndchannel", " dotchannel", "dndChannel", "dndWriter", "dstRow", " dmtConnection", "dmtchannel", " dnetChannel", " dnetButton", "dnetButton", "ddestchannel", " dmtChan", "dstChan", "dnetConnection", "dnetChan", "dmtConnection", "ddrWriter", " dstchannel", "dnetchannel", " dnetManager", " dstManager", "dndButton", " dndChannel", "dotChannel", "dstsChannel", " dstWriter", "dotchannel", " dstRow", " dmtchannel", " dmtChannel", " dndchannel", "dstButton", "dotButton", "ddestWriter", " dstConnection", " dnetChan", " dndRow", "dmtChan", "dstsChan", "dotManager", "ddrChannel", " dotChannel", " dndWriter"]}}
{"id1": "4686922", "id2": "16851955", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResources2Files", "extractResourceTofile", "extractResourceAsStream", "extractResourceFromFile", "extractResourceFromFiles", "extractResourceToFiles", "extractResource2Files", "extractResource2Stream", "extractResourceAsFiles", "extractResourceFromfile", "extractResources2File", "extractResourceToStream", "extractResources2Stream", "extractResourcesToFile", "extractResource2File", "extractResourcesToFiles", "extractResourcesToStream", "extractResourceAsFile", "extractResourceFromStream", "extractResources2file", "extractResource2file", "extractResourceAsfile", "extractResourcesTofile"], "resourcePath": ["templateIn", "attributePath", " resourcepath", "templateName", "templatePath", " resourceIn", "uriUrl", "resourceName", "resourceLocation", "Resourcepath", "attributeLocation", "ResourceIn", "ResourcePath", "uriPath", "attributeUrl", "ResourceName", "uriName", "resourcepath", "templatepath", "resourceUrl", "attributeName", "uriLocation", "resourceIn", "ResourceLocation", "ResourceUrl", " resourceName"], "dest": ["src", "null", "orig", "w", "Dest", "opt", "cont", "end", "desc", "trans", "mem", "parent", "home", "sp", "decl", "coord", "this", "rest", "to", "temp", "dist", "source", "output", "good", "cat", "gov", "etc", "origin", "dat", "img", "tmp", "target", "nom", "lit", "des", "loc", "self", "comb", "prop", "result", "dir"], "in": ["gin", "m", "re", " din", "mc", "mi", "up", "cin", "it", "on", "raw", "or", "none", "ini", "inf", "inn", "ind", "id", "resource", "ins", "l", "rin", "f", "r", "inc", "al", "source", "ln", "no", "IN", "from", "iter", "local", "init", "isin", "bin", "inner", "all", "con", "input", "conf", "sin", "din", "i", "inside", "file", "is", "ne", "In"], "out": ["os", "cn", "null", "t", "note", "w", "exit", "b", "ot", "ch", "o", "aos", "na", "it", "on", "client", "v", "writer", "can", "obj", "to", "outs", "print", "f", "io", "stable", "cache", "write", "n", "res", "no", "output", "Out", "en", "inner", "con", "again", "nt", "conv", "tmp", "outer", "ou", "oss", "i", "at", "sys", "pool", " Out", "OUT", "co", "ne", "cos", "col", "net"]}}
{"id1": "12097948", "id2": "3745402", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 0, "substitutes": {"systemID": [" systemId", "systemName", "sysIDs", " systemVD", " systemName", "privateId", "privateVD", "sysId", "privateName", "SystemName", " systemIDs", "sysID", "SystemId", "sysVD", "privateID", "systemId", "systemIDs", "systemVD", "SystemID", "SystemIDs", "sysName"], "id": ["gd", "null", "in", "link", "pid", "mid", "end", "path", "aid", "Id", "ref", "hide", "base", "it", "ide", "part", "oid", "delete", "internal", "name", "message", "p", "md", "kid", "post", "uri", "sid", "layout", "f", "mask", "q", "source", "one", "bid", "str", "bind", "iden", "ids", "res", "no", "uid", "test", "ID", "create", "ip", "init", "def", "rid", "wire", "show", "json", "i", "edit", "hash", "query", "hd", "db", "description", "form", "data", "ident", "key", "shape", "d"], "loader": ["older", "module", "lr", "hl", "handler", "where", "pkg", "qualified", "lc", "cdn", "system", "label", "context", "er", "kernel", "library", "l", "owner", "framework", "reader", "nl", "finder", "rl", "cl", "lp", "user", "loads", "location", "loading", "language", "container", "class", "manager", "Loader", "pool", "layer", "parser", "acl", "loaded", "load", "builder"], "url": ["ret", "browser", "bel", "lr", "ur", "http", "link", "il", "path", "ref", "ls", "util", "or", "ml", "address", "name", "resource", "uri", "l", "f", "sl", "r", "nl", "mb", "rl", "str", "org", "rel", "impl", "mount", "user", "location", "ssl", "Url", "mail", "abs", "web", "el", "norm", "ul", "html", "xml", "file", "loc", "lb", "ll", "tool", "job", "dl", "URL", "load", "builder"], "inStream": ["intBlock", "onSteam", "inSteam", "INstream", "onStream", "inView", "intSteam", "INStream", "innSteam", "InFile", "INView", "intSocket", "INSteam", " inSteam", "inBlock", "InStream", "InSteam", "inputSteam", "onstream", "inputStream", "instream", "inFile", "innSocket", "innBlock", " inView", "inputFile", " inSocket", "intStream", " inFile", "onView", " instream", "inSocket", "inputstream", "Instream", "innStream", " inBlock"], "constraints": ["constsats", "constrats", "conStraint", "costaints", "constraint", "constsaints", "constaint", "costats", "conStraints", "constats", "constains", "costraints", "costaint", "costains", "constaints", "conStrains", "costrains", "constsains", "costrats", "costraint", "constsaint", "constrains", "conStrats"]}}
{"id1": "884867", "id2": "14231545", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"zipname": ["zname", "polyname", "archivename", "gzsize", "gznamed", " zipbase", "zipnamed", "zipsize", "archiveName", "ziproot", "tarname", "archiveout", " zipsize", "zename", "zeout", "tarsize", "downloadnamed", "tarroot", "downloadname", "downloadfilename", "zebase", "archivebase", "zName", "polyName", "downloadName", " zipName", "polyfilename", "zipName", " ziproot", "zipfilename", "znamed", "zfilename", "tarnamed", "zipbase", "polynamed", " zipnamed", "gzname", "gzroot", "zeName"], "zipout": ["zname", " zipoutput", "zin", "zout", "zipobj", "Zipout", "gzout", " zipall", "sendout", "zn", "gzobj", " zipobj", " zipclient", "sendin", "zOut", "zipn", "zgen", " zipgen", "zipgen", " zipin", "Zipclient", "gzOut", "sendn", "gzall", "zipin", "zipall", "gzion", "zipclient", "zipion", "sendoutput", "zall", "zion", "Zipn", "sendclient", "sendname", "Zipname", "gzin", "zipOut", "zipoutput", "Zipin", "gzgen", "Zipoutput", " zipion", "zobj", " zipOut"], "out": ["pretty", "cn", "t", "w", "up", "aos", "can", "log", "io", "by", "str", "one", " manager", "init", "en", "conf", " sys", "oss", "OUT", "co", "ac", "net", "o", "desc", "inf", "client", "to", "print", "conn", "ln", " outs", " OUT", "gov", "ou", " Out", "cos", "go", "gt", "opt", " fmt", "on", "list", "obj", "n", "res", "cmd", "all", "cfg", "screen", " bout", "gen", " output", "msg", "dt", "ent", "os", "null", "ch", "name", "p", "writer", " abort", "ins", "group", "outs", " say", "g", "output", "ex", "set", "Out", "inner", "con", "nt", "inv", "at", "sys", "auto"], "buffer": ["paste", "memory", "bar", "row", "phrase", "binary", "buff", "table", "variable", "total", "document", "batch", "pad", "line", "block", "mem", "Buffer", "available", "history", "filter", "message", "sequence", "library", "cache", "queue", "temp", "window", "buf", "output", "iter", "page", "tree", "template", "database", "frame", "comment", "button", "command", "stack", "attribute", "append"], "in": ["gin", "info", "im", "per", "read", "nin", "oin", "mc", "get", "up", "cin", "on", "it", "pi", "or", "check", "inf", "ini", "inn", "ind", "ins", "ic", "rin", "by", "reader", "inc", "ai", "like", "bi", "from", "IN", "mm", "ex", "init", "iter", "en", "isin", "inner", "bin", "con", "input", "din", "ma", "query", "i", "form", "is", "ac", "and", "In"], "length": ["join", "full", "bow", "shift", "read", "phi", "total", "capacity", "ENGTH", "amount", "component", "character", "integer", "version", "value", "space", "count", "vector", "available", "history", "tail", "message", "sequence", "maximum", "frequency", "library", "print", "depth", "number", "needed", "padding", "height", "code", "impl", "no", "distance", "language", "volume", "string", "load", "class", "ength", "position", "present", "Length", "database", "point", "display", "angle", "size", "match", "reading", "loc", "hello", "len", "family", "type", "duration", "shape", "collection"]}}
{"id1": "11341711", "id2": "11032546", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"makeBackup": ["createbackpoint", "createBackups", "makeDup", "createBackupid", "createBackup", "makeStpoint", "makeDups", "makeStupid", "makeDupid", "createbackup", "makeDpoint", "createbackups", "makebackup", "createbackupid", "makebackupid", "makebackpoint", "makeBackupid", "createBackpoint", "makeBackpoint", "makeStup", "makebackups", "makeStups", "makeBackups"], "dir": ["src", "zip", "in", "disk", "Directory", "pkg", "path", "url", " d", "base", "or", "del", "store", "ind", "y", "directory", "md", "direct", "rad", "Dir", "doc", "folder", "DIR", "dist", "out", "ir", "dis", "window", "dm", "iter", "local", "dat", "dr", "dep", "tmp", "draw", "db", "mail", "addr", "file", "fd", "data", "loc", "vol", "dl", "wd", "handle", "dd", "d"], "sourcedir": [" sourcedire", "senderel", "isourceel", "sourcedirs", "sourceirs", "isourceir", "isourcedir", "sourceel", "soredire", "isourcedel", "sourcesel", "isourcer", " sourcedirs", " sourcesir", "soredirs", "soreddir", " sourcesirs", "sourcedel", "sourcesdir", "sourcesr", " sourcesdir", "sourcesir", "isourcedr", "sourceir", "sourcedr", "soredir", "senderir", "sourceddir", "sourcer", " sourceddir", "sourceire", "senderdir", "isourceddir", "sourcedire", "senderr", "sourcesire", " sourcesire", "sourcesirs"], "destinationdir": ["estinationfolder", "stinationdb", "destionDir", "destinedir", "destinationDir", "destensionDir", "estinatordir", "destinationsir", "estinatordb", "stinationsdir", "stinationir", "stinationsir", "destinationsdb", "estinatorDir", "destinatordir", "destinatorir", "destionfolder", "stinationdir", "destensiondir", "destiondir", "destineddir", "destinatorDir", "estinationdb", "stinationsdb", "destinationsdiv", "estinationdir", "estinationDir", "destensiondb", "destinatordiv", "estinatorfolder", "destinationdb", "destinatorfolder", "destineddb", "destinationdiv", "destinatordb", "destinationir", "destensionfolder", "stinationdiv", "stinationsdiv", "destineddiv", "destinationsdir", "destinationfolder", "destiondb"], "destinationDirEnding": ["destinationDirEvener", "destinationDirectoryENDing", "destinationDirectoryENDding", "destinationDirectoryEndding", "destinationFileEvening", "destinationDirFeedING", "destinationDirFeeding", "destinationDirEnditing", "destinationDirEveniting", "destinationDirectoryEnder", "destinationDirENDer", "destinationFileEndING", "destinationDirFeeder", "destinationDirectoryEnding", "destinationFileEveniting", "destinationDirENDing", "destinationDirEndING", "destinationDirEvenING", "destinationDirectoryEndging", "destinationDirEndging", "destinationDirEvending", "destinationDirENDging", "destinationFileEvenING", "destinationDirENDING", "destinationDirServer", "destinationFileEvener", "destinationDirFeediting", "destinationDirServing", "destinationDirENDding", "destinationFileEnditing", "destinationDirEvenging", "destinationDirectoryENDer", "destinationDirServding", "destinationDirEnder", "destinationDirEndding", "destinationDirectoryENDging", "destinationFileEnder", "destinationFileEnding", "destinationDirENDiting", "destinationDirEvening", "destinationDirServging"], "files": ["faces", "modules", "details", "words", "actions", "params", "bs", "features", "forms", "Files", "resources", "ls", "docs", "facts", "events", "pages", "sections", "lets", "its", "states", "issues", "list", "errors", "users", "values", "items", "uploads", "mails", "parents", "prints", "lines", "members", "fields", "assets", "fs", "ids", "headers", "links", "objects", "plates", "keys", "types", "ports", "iles", "reports", "fixes", "names", "parts", "projects", "tools", "tests", "bytes", "file", "strings", "ames", "classes", "images", "filename", "qs", "obs"], "checkdir": ["ckroom", " checkdirectory", "Checkfolder", "Checkroom", "checkedir", "checkedDir", "keyroom", "ckDir", "ckdb", "ckthis", " checkDir", "checkblock", " checkurl", "getfolder", "ckfolder", "Checkdb", "checkroom", "checkdb", "workDir", "ckdir", "Checkblock", "ckurl", "checkthis", "workdir", "Checkir", "keyfolder", "keydb", "checkdirectory", "checkir", " checkthis", "ckdirectory", "CheckDir", "checkedfolder", " checkdb", "checkeddb", "getblock", "keydir", "checkDir", "Checkdir", "checkfolder", "checkurl", "getdir", " checkfolder", " checkblock", "workurl", "checkeddirectory", "getdb", "checkeddir", " checkir", "Checkdirectory", "workthis"], "date": ["ATE", "month", " Date", "note", "diff", "cal", "close", "key", "get", "today", "add", "none", "day", "Date", "when", "use", "now", " day", "resource", "doc", "de", "user", "set", "start", "dat", "iso", "ate", "zone", "te", "tag", "dt", "data", "file", "msg", "late", "year", "time", "event", "d"], "msec": ["cmsc", "cmcl", "cmsec", "mSec", "gmsec", "gmSec", "mcl", "Mct", "mtSec", "cmisec", " mSec", " misec", "MSec", "mstr", " mstr", " mcl", " mct", "mtisec", " msc", "mtcl", "Msec", "gmsc", "mtct", "msc", "mtstr", "gmstr", "mtsc", "mct", "misec", "mtsec"], "checkFile": [" checkFILE", "CheckFiles", "readfile", "Checkfile", "updateFiles", " checkfile", "readFile", " checkSourceFile", "checkFiles", "updateFile", "readSourceFile", "CheckFILE", "checkFILE", "updateFILE", "checkSourceFile", "readFILE", "readFiles", "CheckFile", "checkfile", "updateSourceFile", " checkFiles"], "i": ["info", "ji", "m", "iq", "ci", "im", "in", "phi", "j", "ii", "gi", "gu", "qi", "my", "I", "mi", "ti", "batch", "base", "pi", "it", "di", "ini", "ui", "ind", "zi", "id", "name", "hi", "y", "sequence", "multi", "ic", "io", "ai", "x", "me", "iu", "bi", "ex", "ip", "cli", "init", "exp", "si", "ie", "ij", "ki", "ri", "index", "sim", "li", "ix", "xi", "is", "key", "ei", "major"], "f": ["m", "ft", "u", "t", "df", "b", "j", "fw", "fp", "F", "o", "bf", "e", "fe", "fb", "p", "v", "uf", "l", "fl", "fo", "fs", "cf", "fc", "lf", "fac", "fr", "file", "tf", "fi", "fd", "fg", "fa", "d"], "g": ["go", "m", "gd", "bg", "t", "w", "gc", "gi", "b", "j", "gu", "ge", "og", "vg", "gl", "e", "graph", "pg", "ga", "v", "p", "s", "group", "l", "G", "out", "gs", "mg", "gb", "gy", "ig", "cfg", "gg", "gp", "gm", "eg", "config", "tg", "msg", "file", "fg", "d"], "destinationFile": ["destinatedDirectory", "DestinationEmail", "transinationFilename", "destinateFilename", "transinationFile", "DestinationFile", "destinationFiles", "destationFile", "destinatorFiles", "destinationsEmail", "destinationsFile", "transinatedDirectory", "destarationFiles", "destarationDirectory", "destinationEmail", "destinatorFilename", "transinatedFilename", "destinationFilename", "destinatedFiles", "destinateEmail", "destinatorDirectory", "DestationFiles", "transinatedFile", "DestationFile", "destinatedFilename", "transinationDirectory", "destinationsFiles", "destationEmail", "transinationFiles", "destinationsFilename", "DestinationFiles", "destinateFile", "destarationFilename", "DestationFilename", "DestationEmail", "destinatorFile", "DestinationFilename", "destinateFiles", "destationFilename", "transinatedFiles", "destationFiles", "destinationDirectory", "destarationFile", "destinatedFile"], "sourceFile": ["srcFilename", "sourceFILE", "SourceFilename", "staticFILE", "SourceFile", "staticFiles", "srcLine", "staticFile", "staticfile", "ourceFile", " sourceFILE", "SourceLine", "sourceLine", "sourcefile", "srcFile", "SourceFILE", "ourceFilename", "SourceFiles", "srcfile", "Sourcefile", "sourceFiles", " sourcefile", "ourceLine", "sourceFilename", " sourceFiles", "ourcefile"], "infile": [" infield", "INfield", "INline", "inputblock", "INFile", "outFile", "insfile", "inline", "InFile", "pinline", "INfile", "infield", "Infile", "insFile", "pinfile", " inblock", "inFile", "instream", "Inblock", "inputFile", "pinfield", " inline", "insstream", " inFile", "outline", "insblock", " instream", "Instream", "inputfile", "outblock", "inputline", "inblock", "pinFile"], "outfile": [" outpage", "outview", " outstream", "outerview", "Outfile", "outFile", "inline", "outerstream", "outputline", "inlink", "outputstream", " outFile", "inview", "Outstream", "outlink", " outview", "outerfile", "instream", "inbuffer", " outline", "inFile", "Outlink", "outputfile", " outlink", "outpage", "outbuffer", "outline", "outputpage", "outerbuffer", "OutFile", " outbuffer", "inpage", "outstream"], "c": ["nc", "m", "u", "sc", "t", "err", "z", "\u00e7", "gc", "ec", "close", "rc", "ch", "C", "o", "mc", "a", "lc", "e", "count", "ct", "cc", "cp", "ce", "dc", "v", "cs", "cd", "y", "p", "k", "r", "uc", "cache", "out", "cl", "x", "n", "code", "unc", "cf", "pc", "cr", "arc", "cu", "conf", "char", "cm", "cb", "chain", "ca", "cos", "bc", "col", "ac", "d"]}}
{"id1": "11341711", "id2": "3375718", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"makeBackup": ["createbackpoint", "createBackups", "makeDup", "createBackupid", "createBackup", "makeStpoint", "makeDups", "makeStupid", "makeDupid", "createbackup", "makeDpoint", "createbackups", "makebackup", "createbackupid", "makebackupid", "makebackpoint", "makeBackupid", "createBackpoint", "makeBackpoint", "makeStup", "makebackups", "makeStups", "makeBackups"], "dir": ["src", "zip", "in", "disk", "Directory", "pkg", "path", "url", " d", "base", "or", "del", "store", "ind", "y", "directory", "md", "direct", "rad", "Dir", "doc", "folder", "DIR", "dist", "out", "ir", "dis", "window", "dm", "iter", "local", "dat", "dr", "dep", "tmp", "draw", "db", "mail", "addr", "file", "fd", "data", "loc", "vol", "dl", "wd", "handle", "dd", "d"], "sourcedir": [" sourcedire", "senderel", "isourceel", "sourcedirs", "sourceirs", "isourceir", "isourcedir", "sourceel", "soredire", "isourcedel", "sourcesel", "isourcer", " sourcedirs", " sourcesir", "soredirs", "soreddir", " sourcesirs", "sourcedel", "sourcesdir", "sourcesr", " sourcesdir", "sourcesir", "isourcedr", "sourceir", "sourcedr", "soredir", "senderir", "sourceddir", "sourcer", " sourceddir", "sourceire", "senderdir", "isourceddir", "sourcedire", "senderr", "sourcesire", " sourcesire", "sourcesirs"], "destinationdir": ["estinationfolder", "stinationdb", "destionDir", "destinedir", "destinationDir", "destensionDir", "estinatordir", "destinationsir", "estinatordb", "stinationsdir", "stinationir", "stinationsir", "destinationsdb", "estinatorDir", "destinatordir", "destinatorir", "destionfolder", "stinationdir", "destensiondir", "destiondir", "destineddir", "destinatorDir", "estinationdb", "stinationsdb", "destinationsdiv", "estinationdir", "estinationDir", "destensiondb", "destinatordiv", "estinatorfolder", "destinationdb", "destinatorfolder", "destineddb", "destinationdiv", "destinatordb", "destinationir", "destensionfolder", "stinationdiv", "stinationsdiv", "destineddiv", "destinationsdir", "destinationfolder", "destiondb"], "destinationDirEnding": ["destinationDirEvener", "destinationDirectoryENDing", "destinationDirectoryENDding", "destinationDirectoryEndding", "destinationFileEvening", "destinationDirFeedING", "destinationDirFeeding", "destinationDirEnditing", "destinationDirEveniting", "destinationDirectoryEnder", "destinationDirENDer", "destinationFileEndING", "destinationDirFeeder", "destinationDirectoryEnding", "destinationFileEveniting", "destinationDirENDing", "destinationDirEndING", "destinationDirEvenING", "destinationDirectoryEndging", "destinationDirEndging", "destinationDirEvending", "destinationDirENDging", "destinationFileEvenING", "destinationDirENDING", "destinationDirServer", "destinationFileEvener", "destinationDirFeediting", "destinationDirServing", "destinationDirENDding", "destinationFileEnditing", "destinationDirEvenging", "destinationDirectoryENDer", "destinationDirServding", "destinationDirEnder", "destinationDirEndding", "destinationDirectoryENDging", "destinationFileEnder", "destinationFileEnding", "destinationDirENDiting", "destinationDirEvening", "destinationDirServging"], "files": ["faces", "modules", "details", "words", "actions", "params", "bs", "features", "forms", "Files", "resources", "ls", "docs", "facts", "events", "pages", "sections", "lets", "its", "states", "issues", "list", "errors", "users", "values", "items", "uploads", "mails", "parents", "prints", "lines", "members", "fields", "assets", "fs", "ids", "headers", "links", "objects", "plates", "keys", "types", "ports", "iles", "reports", "fixes", "names", "parts", "projects", "tools", "tests", "bytes", "file", "strings", "ames", "classes", "images", "filename", "qs", "obs"], "checkdir": ["ckroom", " checkdirectory", "Checkfolder", "Checkroom", "checkedir", "checkedDir", "keyroom", "ckDir", "ckdb", "ckthis", " checkDir", "checkblock", " checkurl", "getfolder", "ckfolder", "Checkdb", "checkroom", "checkdb", "workDir", "ckdir", "Checkblock", "ckurl", "checkthis", "workdir", "Checkir", "keyfolder", "keydb", "checkdirectory", "checkir", " checkthis", "ckdirectory", "CheckDir", "checkedfolder", " checkdb", "checkeddb", "getblock", "keydir", "checkDir", "Checkdir", "checkfolder", "checkurl", "getdir", " checkfolder", " checkblock", "workurl", "checkeddirectory", "getdb", "checkeddir", " checkir", "Checkdirectory", "workthis"], "date": ["ATE", "month", " Date", "note", "diff", "cal", "close", "key", "get", "today", "add", "none", "day", "Date", "when", "use", "now", " day", "resource", "doc", "de", "user", "set", "start", "dat", "iso", "ate", "zone", "te", "tag", "dt", "data", "file", "msg", "late", "year", "time", "event", "d"], "msec": ["cmsc", "cmcl", "cmsec", "mSec", "gmsec", "gmSec", "mcl", "Mct", "mtSec", "cmisec", " mSec", " misec", "MSec", "mstr", " mstr", " mcl", " mct", "mtisec", " msc", "mtcl", "Msec", "gmsc", "mtct", "msc", "mtstr", "gmstr", "mtsc", "mct", "misec", "mtsec"], "checkFile": [" checkFILE", "CheckFiles", "readfile", "Checkfile", "updateFiles", " checkfile", "readFile", " checkSourceFile", "checkFiles", "updateFile", "readSourceFile", "CheckFILE", "checkFILE", "updateFILE", "checkSourceFile", "readFILE", "readFiles", "CheckFile", "checkfile", "updateSourceFile", " checkFiles"], "i": ["info", "ji", "m", "iq", "ci", "im", "in", "phi", "j", "ii", "gi", "gu", "qi", "my", "I", "mi", "ti", "batch", "base", "pi", "it", "di", "ini", "ui", "ind", "zi", "id", "name", "hi", "y", "sequence", "multi", "ic", "io", "ai", "x", "me", "iu", "bi", "ex", "ip", "cli", "init", "exp", "si", "ie", "ij", "ki", "ri", "index", "sim", "li", "ix", "xi", "is", "key", "ei", "major"], "f": ["m", "ft", "u", "t", "df", "b", "j", "fw", "fp", "F", "o", "bf", "e", "fe", "fb", "p", "v", "uf", "l", "fl", "fo", "fs", "cf", "fc", "lf", "fac", "fr", "file", "tf", "fi", "fd", "fg", "fa", "d"], "g": ["go", "m", "gd", "bg", "t", "w", "gc", "gi", "b", "j", "gu", "ge", "og", "vg", "gl", "e", "graph", "pg", "ga", "v", "p", "s", "group", "l", "G", "out", "gs", "mg", "gb", "gy", "ig", "cfg", "gg", "gp", "gm", "eg", "config", "tg", "msg", "file", "fg", "d"], "destinationFile": ["destinatedDirectory", "DestinationEmail", "transinationFilename", "destinateFilename", "transinationFile", "DestinationFile", "destinationFiles", "destationFile", "destinatorFiles", "destinationsEmail", "destinationsFile", "transinatedDirectory", "destarationFiles", "destarationDirectory", "destinationEmail", "destinatorFilename", "transinatedFilename", "destinationFilename", "destinatedFiles", "destinateEmail", "destinatorDirectory", "DestationFiles", "transinatedFile", "DestationFile", "destinatedFilename", "transinationDirectory", "destinationsFiles", "destationEmail", "transinationFiles", "destinationsFilename", "DestinationFiles", "destinateFile", "destarationFilename", "DestationFilename", "DestationEmail", "destinatorFile", "DestinationFilename", "destinateFiles", "destationFilename", "transinatedFiles", "destationFiles", "destinationDirectory", "destarationFile", "destinatedFile"], "sourceFile": ["srcFilename", "sourceFILE", "SourceFilename", "staticFILE", "SourceFile", "staticFiles", "srcLine", "staticFile", "staticfile", "ourceFile", " sourceFILE", "SourceLine", "sourceLine", "sourcefile", "srcFile", "SourceFILE", "ourceFilename", "SourceFiles", "srcfile", "Sourcefile", "sourceFiles", " sourcefile", "ourceLine", "sourceFilename", " sourceFiles", "ourcefile"], "infile": [" infield", "INfield", "INline", "inputblock", "INFile", "outFile", "insfile", "inline", "InFile", "pinline", "INfile", "infield", "Infile", "insFile", "pinfile", " inblock", "inFile", "instream", "Inblock", "inputFile", "pinfield", " inline", "insstream", " inFile", "outline", "insblock", " instream", "Instream", "inputfile", "outblock", "inputline", "inblock", "pinFile"], "outfile": [" outpage", "outview", " outstream", "outerview", "Outfile", "outFile", "inline", "outerstream", "outputline", "inlink", "outputstream", " outFile", "inview", "Outstream", "outlink", " outview", "outerfile", "instream", "inbuffer", " outline", "inFile", "Outlink", "outputfile", " outlink", "outpage", "outbuffer", "outline", "outputpage", "outerbuffer", "OutFile", " outbuffer", "inpage", "outstream"], "c": ["nc", "m", "u", "sc", "t", "err", "z", "\u00e7", "gc", "ec", "close", "rc", "ch", "C", "o", "mc", "a", "lc", "e", "count", "ct", "cc", "cp", "ce", "dc", "v", "cs", "cd", "y", "p", "k", "r", "uc", "cache", "out", "cl", "x", "n", "code", "unc", "cf", "pc", "cr", "arc", "cu", "conf", "char", "cm", "cb", "chain", "ca", "cos", "bc", "col", "ac", "d"]}}
{"id1": "7044685", "id2": "22114133", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["Encrypt", " encrypted", "encryption", "crypted", "encrypted", "crypt", "cryption", " encryption", "Encryption", "Encrypted"], "plaintext": ["plainText", "mainText", "messagetext", "ainprint", "maintext", " plainText", "mainstring", "plaindata", "messagedata", "ainText", "aintext", " plainprint", "plainstring", "ainstring", " plaindata", "messageprint", "messageText", "aindata", "plainprint", " plainstring"], "d": ["mod", "m", "gd", "ad", "t", "w", "z", "pd", "df", "done", "ld", "c", "dal", "dx", "end", "dh", "h", "nd", "D", "e", "di", "ind", " md", "dig", "cd", "md", "y", "p", "od", "l", "f", "bd", "dec", "sd", "ord", "g", "did", "de", "dm", "debug", "dat", "dr", "ds", "ded", "db", "hd", "red", "fd", "dl", "da", "dd"]}}
{"id1": "18731843", "id2": "5977352", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doBody": [" sendBody", " sendHead", " doContent", " writebody", "loadContent", " doHead", "loadBody", " writeHead", " sendbody", " writeBody", "loadHead", " writeContent", " sendContent", "loadbody", " dobody"], "req": ["err", "http", "exec", "Requ", "j", "pkg", "wx", "urg", "gr", "quest", "ps", "sq", "q", "request", "proc", "hr", "pro", "js", "res", "rec", "quick", "cmd", "ctx", "def", "conf", "jp", "qt", "query", "inv", "fr", "reg", "requ", "aj", "Request", "tx", "qq", "express", "crit"], "resp": ["ret", "rep", "re", "pos", "err", "http", "Res", "esp", "soc", "trans", "sp", "client", "out", "cl", "wr", "respond", "sol", " res", "rec", "res", "rel", "js", "respons", "output", "exp", "comm", "def", "Response", "next", "Rep", "RES", "wa", "Resp", "vol", "response", "serv", "result"], "bis": ["os", "ads", "bh", "bt", "bie", "lbs", "bs", "bat", "mi", "oi", "lis", "bes", "cin", "ios", "be", "isi", "bps", "iss", "atis", "zo", "fps", "pins", "pin", "bits", "ses", "bid", "los", "mis", "bi", "iris", "nis", "onis", "sb", "lin", "isin", "phis", "ubis", "ris", "inet", "bil", "iso", "rison", "oss", "aus", "is", "ais", "webkit", "avi", "idis", "obs"], "bos": ["fits", "os", "bh", "bs", "oops", "ubs", "eros", "banks", "oi", "asis", "bes", "aos", "ios", "tes", "its", "tis", "uts", "ts", "bo", "vas", "ows", "outs", "mes", "pins", "bits", "gs", "fs", "asket", "los", "bi", "ods", "acs", "BS", "ols", "bin", "oos", "zb", "ubis", "bas", "bil", "jas", "ys", "stones", "oss", "uds", "nos", "is", "dos", "obs"]}}
{"id1": "6403868", "id2": "732800", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUninstallItems", "extractUninstallFile", "extractUnpackFile", "extractUnpackFiles", "extractunInstallFile", "extractUnInstallFiles", "extractuninstallFiles", "extractuninstallFile", "extractUnpackItems", "extractunInstallItems", "extractUnInstallItems", "extractUnInstallFile", "extractuninstallItems", "extractunInstallFiles"], "_destPath": ["_destPoint", "_destDir", "_tempPoint", "_destTh", "_combFormat", "_privTh", "_restDir", "_restPath", "_DestKey", "_destKey", "_srcPath", "_DestDir", "_tempFormat", "_tempTh", "_DestPath", "_DestPoint", "_privPath", "_DestTh", "_sourcePath", "_restKey", "_privPoint", "_restPoint", "_privDir", "_tempDir", "_sourceFormat", "_sourceDir", "_destFormat", "_srcPoint", "_srcKey", "_combPath", "_srcDir", "_tempPath", "_combDir"], "upgrade": ["upchange", "upate", "equcp", " upchange", "upcheck", "ungrade", " upgrad", " upgrades", "exgrade", "equgrade", "downgrade", " upate", "unate", "equgrad", "equate", "exchange", "downchange", " upcheck", "upgrad", "downcheck", "excheck", "upcp", "ungrad", "exgrades", " upcp", "downgrades", "uncp", "upgrades"], "lastVer": ["LastVer", "nextVers", "lastRes", "oldVersion", " lastVersion", "nextServ", " lastRes", "latestVers", "LastVers", " lastver", "LastVersion", "latestServ", "latestVer", "nextRes", "lastVersion", "oldVers", "lastServ", " lastVers", "nextVer", "Lastver", "oldVer", "lastver", "lastVers", "latestRes", " lastServ", "oldver"], "oldlog": ["olderpath", " oldpath", "Oldpath", "olderr", "OldLog", "oldpath", "oldererr", "olderlog", " oldog", " olderr", "Oldog", "OLDpath", "Oldlog", "olderLog", "oldLog", " oldLog", "OLDlog", "OLDLog", "olderog", "oldog", "OLDerr", "OLDog"], "destPath": ["restDir", " destPoint", "DestStream", "descKey", "originTh", "locDisk", "altParent", " destFile", "destParent", "estPos", "estName", "gestTime", "altPath", "srcPath", " destTh", "privPos", "estRef", "destRef", "identPoint", "restFile", " destKey", "destNet", "altPoint", "srcFile", "gestNode", "DestFont", "privRoot", "DestDir", "srcPort", "declDir", "foreignDir", "DestName", "destPoint", "altNode", "gestName", "originPoint", "originPort", "destDir", " destRef", "destPos", "declFont", "identPort", "DestPath", "destTh", "destNode", "DestFull", "destTime", " destPos", "DestDirectory", "gestPath", "destDirectory", "destFile", "altName", "descNet", "sortFull", "destFull", " destRoot", "gestNet", "DestRef", "destLog", "sortPath", "estDir", "destRoot", "destHost", "gestDisk", " destHost", "altHost", "DestFile", "descPath", " destParent", " destDirectory", "DestPod", "potPod", "destDisk", "destFont", "descName", "descDisk", "restPoint", "altDir", "privPath", "DestLog", "DestPoint", "foreignPath", " destDir", "restPath", "potPath", "DestPos", "srcLog", "locTime", "estPath", "destStream", "locNet", "identTh", "sortFont", "DestRoot", "DestParent", "privDir", "locPath", "destPod", "declFull", "destName", "potStream", " destPort", "descPos", " destNode", "destPort", "foreignPod", "destKey", "declPath", "gestHost", "srcDirectory", "descTime", "sortDir", "foreignStream", "potDir", "originPath", "identPath", "estKey", "srcDir", " destLog", " destName", "DestPort"], "lastVerPath": [" lastVerDir", "lastVerDir", " lastVerpath", "lastVersVal", " lastVerName", "lastResForm", "lastVersionPath", "lastVersLog", "lastVERFile", "lastverCh", "lastVersPath", "lastVersName", "lastVERpath", "lastverpath", "highestVERVal", "lastVERDir", "lastVERVal", "lastVerLog", " lastVersPath", "lastVerForm", "lastverDir", " lastVerCh", " lastVersFile", "lastVersFile", " lastverForm", "lastVersionFile", "highestVERPath", "lastVERPath", "lastverVal", "lastverName", " lastverpath", "lastverLog", " lastVersCh", "lastverPath", " lastverDir", "lastVerCh", "lastVersionpath", "highestVERpath", "lastVerspath", "lastRespath", " lastVerFile", "highestVerPath", "lastVersionCh", "highestVerFile", " lastverPath", "highestVerVal", " lastVerLog", "lastVerVal", "highestVERFile", "lastverFile", "lastResPath", "lastVerFile", "lastVerpath", "lastVERForm", "lastResDir", "lastVersCh", " lastVerForm", " lastVersLog", "lastVerName", "lastverForm", "highestVerpath"], "bkdir": ["blkdi", "bukDIR", " bkfolder", "bkkpath", "blkjdi", " bkkDir", "bukdi", " bakdi", "bkjdi", "BckDir", "blkdir", "bkgdir", "bkjdir", "bckDIR", "blkjdir", "bkrel", " bakfolder", "bckfolder", "bkgfolder", "bakdir", "blkjfd", "blkjgroup", "bkdi", " bkkdir", "bkkDIR", "bkkrel", "BkDIR", "blkgroup", "bqfd", "bkjfd", "bckdir", "bkgDir", "Bkpath", " bakDir", "bakrel", "bukgroup", "bakDir", "Bkdir", "bukdir", "BckDIR", "bkkDir", "bckDir", "bkkdi", "bqdir", "bkgrel", "blkfd", " bkkrel", "bkDir", "bkfolder", "bakfolder", "bqgroup", "bukpath", "bkkfolder", "bqdi", " bkkfolder", "Bckdir", "bckdi", "bkgroup", "bkDIR", "bakdi", "bkjgroup", " bkDir", "Bckpath", " bkdi", "bkpath", " bkrel", "bckpath", "bkkdir", "BkDir", " bakdir", "bkfd", "bukfd", "bukDir"], "oldClassCopied": ["oldClassCopyie", "oldclassCopies", "oldClassCopaced", "oldClassCopiated", "oldClassColied", "oldClassCopie", "oldClassReplried", "oldClassCopyified", "oldclasscopied", "oldClassChried", "oldclassCopied", "oldClasscopified", "oldClassColified", "oldclassCopie", "oldClasscopied", "oldDirReplried", "oldClassChiated", "oldclasscopified", "oldDirReplied", "oldClasscopried", "oldDirReplies", "oldClassChied", "oldClassCopified", "oldClassCopyies", "oldDirCopies", "oldClassColaced", "oldDirCopried", "oldClassCopies", "oldclassCopified", "oldClassCopried", "oldClassReplied", "oldClassReplaced", "oldClassReplified", "oldclasscopie", "oldclassCopaced", "oldDirCopiated", "oldClasscopies", "oldClassCopyied", "oldDirCopied", "oldclasscopies", "oldDirRepliated", "oldClassChies", "oldClasscopiated", "oldClassColies", "oldClassRepliated", "oldClassReplies", "oldClasscopie"], "ls": ["tl", "ms", "less", "ils", "lbs", "bs", "vs", "els", "LS", "ws", "lis", "lc", "its", "sels", "es", "ns", "ists", "cs", "ts", "l", "acts", "rl", "lines", "gs", "lv", "ats", "les", "fs", "la", "ln", "los", "rs", "ols", "ds", "ks", "ics", "lf", "las", "lt", "irs", "xs", "abs", "ars", "dl", "qs", "ps", "lists"], "i": ["ji", "m", "iq", "ci", "u", "im", "phi", "j", "b", "gi", "gu", "qi", "ii", "fire", "I", "us", "mi", "oi", "a", "batch", "ti", "key", "pi", "it", "di", "ini", "ui", "ski", "zi", "id", "hi", "y", "multi", "ic", "l", "io", "x", "me", "bi", "ip", "cli", "init", "si", "ij", "ki", "ri", "index", "sim", "li", "ix", "xi", "ami", "eu", "is", "ims", "ei", "chain"]}}
{"id1": "18433984", "id2": "6188784", "code1": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"doUpload": ["postTransfer", "postImport", "doTransfer", " doupload", "postUpload", " doImport", "doupload", "defaultTransfer", "defaultImport", "doImport", " doTransfer", "postupload", "defaultUpload", "defaultupload"], "request": ["QUEST", "http", "get", "up", "version", "quest", "reason", "address", "context", "enter", "argument", "user", "input", "model", "subject", "attribute", "tim", "submit", "raw", "client", "ure", "report", "begin", "q", "order", "art", "query", "session", "access", "xml", "requ", "view", "Request", "open", "key", "command", "result", "record", "re", "each", "params", "document", "un", "component", "condition", "connection", "buffer", "question", "call", "application", "string", "current", "position", "server", "first", "file", "initial", "pass", "forward", "upload", "such", "object", "url", "du", "information", "reference", "now", "name", "message", "resource", "reset", "req", "content", "method", "create", "necessary", "instance", "point", "frame", "complete", "accept"], "response": ["re", "send", "resp", "document", "onse", "success", "sp", "ce", "connection", "message", "image", "report", " responses", "write", "respond", " Response", "application", "res", "respons", "output", "state", "reply", "Response", "session", "file", "view", "status", "event"], "reqSession": ["curState", "reqSocket", "questSocket", " reqS", " reqESSION", "questState", "reqSite", " reqState", "reqState", "qSession", "qESSION", "requS", "requSession", " reqSocket", "qsession", " reqsession", "questSession", "requsession", " reqSite", "curSession", "requState", "requESSION", "questESSION", "curS", "reqS", "curSite", "reqESSION", "requSite", "reqsession", "requSocket"], "uploadFiles": ["inputResources", "inputfiles", "uploadResources", "transferfiles", "transferFiles", "transferTypes", "uploadTypes", "inputFiles", " uploadResources", "inputTypes", "transferResources", " uploadTypes", " uploadfiles", "uploadfiles"], "tempDirName": ["tempRelToken", "tempDIRname", "tempLocPath", "tempVerFamily", "tempFolderPath", "TempFoldername", "tempFilename", "tempPathDefault", "tmpFileNAME", "tempDirDefault", "tempDIRName", "tempVerNAME", "tempLocDefault", "tempPathname", "tempFolderName", "tempPathNAME", "tempDbDefault", "tmpFileToken", "tempRelName", "tempLocName", "TempFolderFamily", "TempFolderName", "tmpDirname", "TempDirname", "tmpFileDefault", "tempDIRNAME", "tempDirname", "tmpFileName", "tmpDirDefault", "tempFolderDefault", " tempDirDefault", "tempPathName", "tmpDirToken", "tempFileToken", "tempFileFamily", "TempDirName", "tempRelname", "tempDirFamily", "tempRelNAME", "tmpFilename", "tempFileDefault", " tempFolderDefault", "tempFolderFamily", "tempVerName", "tmpDirNAME", "tempDirPath", "tempDIRToken", "TempDirFamily", "TempFolderNAME", "tmpDirName", "tempFolderNAME", " tempFolderName", " tempDirPath", "tempDbPath", "tempFileName", "tempDirToken", " tempFolderPath", "tempDirNAME", "tempFileNAME", "TempDirNAME", "tempFoldername", "tempDbName", "tempVername"], "tempUploadDir": ["TempUploadDir", "tempAttachLen", "tempuploadDir", "tempLoadSys", "tempDeploydir", "temActionDir", "empuploadDir", "tempUploadLen", "tempDeployD", "temUploadDb", "tempUploadDirectory", "tempAttachdir", "empuploaddir", "tempUpLoc", "tmpUploadLock", "tempUpDir", "tmpUploadFolder", "tempAttachRel", "tempAttachLock", "empUploadD", "tempDownloadDirectory", "tempActiondir", "tempUpgradeDir", "TempDownloadDir", "tempDeployJar", "tempAttachSys", "tempActdir", "tmpUpDir", "tempuploadFolder", "TempUploadDirectory", "empAttachLoc", "tempUpgradeLen", "tempAttachDirectory", "empAttachD", "tempDeployLen", "tmpDownloadDirectory", "tempUploadSys", "tmpUploaddir", "tmpDownloadJar", "tmpAttachSys", "tempUpdateDis", "tempActionLoc", "tempUploadFolder", "tempDownloadDir", "tempLoaddir", "tempSaveDir", "tempUpRel", "tempNewdir", "tempUploadFiles", "tempUpgradeD", "tempDeployDest", "TempDownloaddir", "empUploadDis", "tempAttachFiles", "empUploadLoc", "temUploadDir", "tmpDownloadFiles", "empUploadRel", "tempDownloadJar", "tempuploadLoc", "tempAttachD", "tempUpdateDir", "tempuploadDirectory", "tempDeployDirectory", "tempUploadD", "tempDownloaddir", "tempuploadJar", "tempUploadLock", "tempNewDir", "tmpDownloadFolder", "tempActionDb", "tempUploadLoc", "temUploaddir", "tempUploadJar", "tmpUploadFiles", "tmpUploadSys", "tempNewSys", "tmpDownloadDir", "tempSaveFiles", "tempUpdatedir", "tempAttachLoc", "tmpUpRel", "tempUploadDb", "tempuploaddir", "tempDownloadFolder", "tempSaveDirectory", "empUploadDir", "tmpAttachLock", "tmpUploadDir", "tempDownloadFiles", "empUploadDest", "tmpUploadRel", "tempDeployFolder", "tempuploadRel", "tempUpdateD", "empAttachDir", "tempActDir", "tempActionDir", "tmpUploadDirectory", "tempuploadD", "tempUploadRel", "tempuploadLen", "empAttachDest", "tempActionLen", "tmpUploadLoc", "TempDownloadDirectory", "tempLoadLock", "TempUploaddir", "tempAttachDest", "tempNewLock", "tempUpgradeDest", "tmpUploadJar", "tempDownloadDb", "tempAttachDir", "tempDeployDir", "tempUploaddir", "empAttachRel", "empuploadDis", "tempActDis", "tmpUpLoc", "tmpAttachdir", "empuploadD", "empAttachLen", "tempDeployDb", "tempUploadDis", "tempActionRel", "tempuploadDis", "temActiondir", "empUploaddir", "empUploadLen", "tempActD", "tempLoadDir", "tempUploadDest", "tmpAttachDir", "temActionDb"], "attachmentDir": ["aditutionRect", "attmentFolder", "adachmentTier", "attitutionDet", "aditutionTier", "attmentDIR", "attentionStr", "adachmentDir", "adachmentDet", "attestationDet", "aditutionDet", "attachachmentFolder", "attachedDirectory", "attachableDir", "attachmentD", "attentionDir", "attignmentRect", "attestationRect", "attignmentdir", "attachachmentDir", "attachableD", "attachmentTier", "adachmentRect", "attignmentDet", "attachableDIR", "attachignmentFolder", "attributionDir", "attributeachmentDirectory", "attignmentDIR", "attributeachedStr", "extachmentDIR", "extacherDir", "attachmentDIR", "attignmentTier", "attributeachedDir", "attachingDIR", "attributeachedDirectory", "attributeachmentStr", "attignmentFolder", "attachachmentdir", "extacherDIR", "attmentdir", "attacherDirectory", "attacherDir", "attachachmentDIR", "attitutionRect", "attachignmentDir", "aditutionDir", "attributeachmentDir", "attacherD", "attachingD", "attachedStr", "attachmentFolder", "extachmentDir", "attacherDIR", "attachmentStr", "attitutionTier", "attestationDir", "attachedDir", "attachignmentDIR", "attachmentDirectory", "attitutionDir", "attributionFolder", "attributiondir", "attachmentdir", "attacherStr", "attestationTier", "attignmentDir", "attributionDIR", "extacherD", "attentionDirectory", "attachmentRect", "attachingDir", "extachmentD", "attachignmentdir", "attachmentDet", "attmentDir"], "paramMap": ["aramap", "paramsMap", "aramMap", "aramSkip", "aramList", "pixelMap", " parammap", "permMap", "pixelApply", " paramSkip", "paramsSet", "ParamMaps", "paramMaps", "propertyLock", "permLock", " paramList", "paramList", "propertyCache", "paramApply", "paramsMaps", "aramSet", " paramMaps", "permCache", "fieldmap", "propertyApply", "ParamSet", "pixelCache", " paramSet", "fieldMap", "arammap", "fieldList", "fieldTable", "paramCache", "aramMaps", " paramap", "paramSet", "aramTable", "paramSkip", "propertyMap", "ParamSkip", "paramTable", "permApply", "ParamMap", "paramap", "paramLock", "parammap", "paramsap", "pixelLock", " paramTable"]}}
{"id1": "3430784", "id2": "1598693", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"decodeBody": ["decodeContent", " DecodeForm", "decodesContent", "decprocessBody", " DecodesForm", "decodesForm", "decodedContent", " DecodeBody", "decodesBody", "decodedBody", "decodedHeader", " DecodeHeader", "decodedForm", " DecodesHeader", "decprocessContent", "decodeHeader", " DecodesContent", "decodesHeader", "decprocessForm", "decprocessHeader", "decodeForm", " DecodesBody", " DecodeContent"], "in": ["gin", "info", "m", "b", "c", "get", "up", "add", "doc", "inc", "from", "init", "en", "input", "asin", "inside", "mat", "load", "ac", "sql", "oin", "pi", "it", "inf", "ind", "to", "r", "ai", "conn", "q", "source", "mm", "act", "body", "xml", "form", "serv", "vin", "on", "or", "check", "v", "ain", "rin", "n", "iter", "IN", "isin", "all", "din", "i", "file", "is", "In", "nin", "cont", "h", "cin", "inn", "ins", "l", "req", "k", "reader", "content", "al", "ex", "pc", "bin", "inner", "con", "ma", "data"], "contentTransferEncoding": ["contentRequestEncoder", "contentTransferChoding", "contentTypeEncoding", "contentTransferencacing", "contentRequestencoder", "contentTransferEnoder", "contentTransferFormoding", "contentRequestEncication", "contentTransferEvoding", "contentTransferEnapping", "contentInfoEncoder", "contentTransferSeode", "contentTransferEvication", "contentTransferEvoder", "contentTransferColloder", "contentTransferEncType", "contentTransferChoded", "contentTransferEncode", "contentTransferEncication", "contentTransferEvoded", "contentRequestEncation", "contentTransferEncation", "contentRequestEnation", "contentTransferencType", "contentTransferEncapping", "contentTransferFormType", "contentTransferencoding", "contentTypeEnoded", "contentTypeEncapping", "contentTransferColloding", "contentTransferChapping", "contentTypeEnapping", "contentRequestencication", "contentTransferencication", "contentTransferEnacing", "contentTransferAuthType", "contentTypeEncoded", "contentInfoencoding", "contentTransferFormoder", "contentInfoencling", "contentTypeEnode", "contentTransferAuthoder", "contentTransferEncacing", "contentTransferEncling", "contentRequestEnasting", "contentTransferEncoder", "contentTransferSeoded", "contentInfoEncoding", "contentInfoencacing", "contentTypeEncode", "contentTransferAuthoded", "contentTransferEnling", "contentRequestencoding", "contentTransferChode", "contentTransferEnode", "contentTransferEnasting", "contentTransferCollasting", "contentTransferFormling", "contentInfoEncacing", "contentRequestEnoding", "contentTransferencoder", "contentRequestEnType", "contentInfoEncling", "contentRequestEnoded", "contentTransferSeoding", "contentTransferencling", "contentRequestencoded", "contentTransferEnoded", "contentTransferSeapping", "contentRequestEncoded", "contentTransferEnType", "contentTransferEncoded", "contentTransferEnication", "contentRequestEncType", "contentRequestEncasting", "contentTransferAuthoding", "contentTransferEncasting", "contentTransferencoded", "contentTransferEnoding", "contentInfoencoder", "contentRequestEnoder", "contentRequestEncoding", "contentTransferCollation", "contentTransferEnation", "contentTypeEnoding"], "tempBody": ["tempReturn", " temporaryFoot", "TempFile", "tabBox", "tabBody", " tempHead", "temFile", "tmpHead", "tempbody", " temporaryReturn", "tabFoot", "tempFoot", "tempFile", "tmpBody", "temReturn", "tmpbody", " temporaryBody", " tempBox", "temBox", "TempBody", "temFoot", " tempFile", "Tempbody", "temBody", " tempbody", " temporaryBox", "tempBox", "temHead", "tabReturn", "TempHead", "tmpBox", "tembody", "tempHead"], "out": ["os", "cn", "m", "null", "t", "ent", "gc", "o", "up", "aos", "cin", "it", "client", "v", "writer", "obj", "to", "outs", "l", "log", "io", "one", "n", "res", "user", "output", "ex", "Out", "inner", "all", "con", "conv", "outer", "sum", "ou", "inv", "oss", "sys", "OU", "auto", "OUT", "co", "is", "cos", "net"]}}
{"id1": "4056444", "id2": "15351863", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"hashPassword": [" hashUser", "hashText", "hashUser", "updatepassword", "updateUser", " hashText", "HashText", " hashpassword", "updateText", "updatePassword", "HashPassword", "HashUser", "Hashpassword", "hashpassword"], "password": ["pass", "secret", "email", "phrase", "w", "expression", "Password", "default", "username", "prefix", "value", "required", "address", "name", "message", "p", "sword", "login", "reset", "report", "account", "padding", "user", "string", "random", "pattern", "token", "word", "input", "present", " Password", "database", "PASS", "description", "data", "hello", "key", "wd", "text", "command", "shadow", "attribute"], "md": ["mod", "m", "ms", "ad", "med", "det", "pd", "df", "ld", "mk", "dh", "mc", "pm", "add", "desc", "MD", "di", "sh", "del", "ind", "cd", "mn", "mt", "od", "bd", "mb", "sam", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "der", "sha", "hed", "hd", "cm", "db", "red", " Md", "mand", "grad", "mo", "dd", "d"], "hash": ["full", "mod", "hex", "row", "bh", "secret", "mac", "crypt", "h", "has", "score", "username", "ash", "block", "version", "check", "sh", "value", "build", "filter", "id", "address", "message", "dig", "name", "map", "print", "cache", "mask", " hashing", "code", "test", "user", "search", "all", "string", "state", "token", "char", "sha", "Hash", "hed", "index", "sum", "html", "file", "array", "format", "key", "handle", "auth", "shadow"]}}
{"id1": "15799935", "id2": "8754809", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveExtachedBody", "saveExtachedPart", "saveExtachmentbody", "saveAttentionBody", "saveExtachedbody", "saveAttachmentFile", "saveExtachedFile", "saveExtachmentPart", "saveAttachableFile", "saveAttachedFile", "saveAttentionFile", "saveAttachedbody", "saveExtachmentFile", "saveAttachablebody", "saveAttachmentPart", "saveAttachmentbody", "saveAttachableBody", "saveAttachedPart", "saveExtachmentBody", "saveAttachablePart", "saveAttachedBody", "saveAttentionbody", "saveAttentionPart"], "context": ["null", "document", "component", "host", "version", "parent", "cc", "history", "media", "ce", "system", "environment", "client", "connection", "message", "center", "background", "content", "cache", "service", "request", "comments", "application", "cf", "course", "ctx", "state", "search", "container", "template", "current", "present", "network", "instance", "java", "foundation", "Context", "support", "config", "frame", "view", "chain", "tx", "response", "translation", "contact", "subject", "command", "stack"], "part": ["join", "PART", "sample", "component", "host", "top", "piece", "pair", "add", "base", "block", "trans", "parent", "se", "version", "sp", "name", "message", "p", "connection", "bound", "post", "report", "patch", "temp", "start", "Part", "art", "reply", "partial", "word", "work", "instance", "body", "tmp", "pod", "zone", "session", "parts", "task", "file", "data", "tx", "job", "type", "and", "thread"], "localAttachment": ["localAttachachment", " localDetignment", "localAppachment", "localattachment", "localAttignment", "localAttention", " localAttment", " localAttachached", "localAttached", " localDetachment", " localAssachment", "localAssail", "localAssention", " localAttached", "localATTention", "localAttment", "localDetached", "localDetention", "localAttachention", "localATTachment", "localAcignment", " localAttachachment", "localAppention", "localATTignment", " localAttachignment", " localAttention", "localATTment", "localattached", "localAcail", "localAttachignment", "localAssachment", " localAssached", "localAppail", "localAssignment", " localAttignment", "localAssached", "localAssment", " localAttachention", " localAttail", "localDetail", " localDetail", "localattention", "localAcachment", " localAssention", "localAttachached", "localAppached", "localDetignment", "localAttail", "localAttachail", "localAcached", " localAssail", " localDetached", "localDetachment"], "accountId": ["objectId", "amountDb", "accNum", "accInt", "containerID", "objectID", "amountId", "accID", "AccountId", "accountInt", "accId", "accountS", "accountAnd", "accountNum", "bankId", "accS", "accDb", " accountS", "amountInt", " accountAnd", "amountID", " accountById", "containerNum", "bankAnd", "objectById", "accountById", "containerId", " accountNum", "AccountName", " accountName", "bankID", "accAnd", "containerInt", " accountInt", "AccountID", "accountID", "AccountById", "objectName", "bankS", " accountDb", "accountDb", "accountName", " accountID"], "attachmentId": ["attachedSerial", "attacheid", "AttachmentId", "Attociationid", "attionSerial", "contachedById", "contachedId", "AttachmentID", "assachmentId", "assachmentById", "attachmentid", "AttociationID", "attionid", "Attachmentid", "attociationid", "attociationId", "attignmentID", "AttociationById", "attachmentSerial", "contachedid", "attionId", "attacheID", "assignmentid", "assignmentById", "assachmentID", "attociationSerial", "attacheId", "attachedId", "contachmentSerial", "attmentid", "attacheById", "contachmentid", "attmentID", "attignmentId", "attmentById", "attociationID", "contachmentById", "attachmentID", "assignmentID", "AttachmentById", "AttociationId", "attignmentById", "attionById", "attachedID", "assachmentid", "attachmentById", "contachedSerial", "attociationById", "assignmentId", "attignmentid", "attachedid", "attmentId", "contachmentId", "attachedById"], "in": ["gin", "info", "m", "vin", "per", "read", "ch", "mc", "up", "cin", "it", "raw", "on", "inf", "inn", "ind", "id", "p", "ins", "l", "rin", "r", "iter", "inc", "ai", "al", "source", "IN", "from", "ex", "mm", "init", "act", "en", "isin", "bin", "inner", "all", "con", "input", "conf", "din", "body", "sum", "i", "inside", "as", "file", "is", "In"], "saveIn": [" saveIns", "sendIN", "savIns", "storeOut", "savIn", "savAs", "aveIn", "aveOut", "secureAs", "aveIN", "sendOut", "savIN", "getIn", "getIN", "savePath", "saveIN", "storeIn", "secureIN", "storePath", "secureIn", "sendPath", "saveOut", "storeIN", "saveIns", " savePath", "getOut", "getIns", " saveIN", "secureIns", "aveIns", "sendIn", " saveOut"], "saveAs": ["Saveas", "submitIn", "dumpAn", " saveBy", "saveTo", "aveIn", "aveAs", " saveAS", "SaveBy", "saveas", "aveAn", "submitAs", "dumpTo", "dumpAs", "submitAS", "submitas", " saveAn", "aveas", "SaveIn", "saveBy", "saveAn", " saveTo", "saveAS", "aveAS", "submitBy", "SaveAs", "aveTo", "SaveAS"], "out": ["os", "cn", "null", "t", "gc", "ent", "o", "up", "aos", "it", "name", "v", "obj", "can", "to", "outs", "log", "io", "one", "ao", "n", "res", "output", "ex", "Out", "copy", "inner", "all", "con", "outer", "conv", "sum", "ou", "oss", "i", "inv", "sys", "OU", "auto", "OUT", "co", "serv", "cos", "net"], "copySize": ["msgLength", "opySIZE", " copyFontSize", "opyPercent", "copyPercent", "opySize", "opyLength", "likeCount", "CopyFontSize", "pushFontSize", "pushLength", "pushCount", "copyFontSize", "msgSize", "CopyPercent", "CopySIZE", "likeFontSize", "pushSize", "likeSize", "msgSIZE", "CopyCount", "likeLength", "CopyLength", "CopySize", "copyLength", "copySIZE", "msgPercent", " copyCount", "copyCount", " copyLength"], "contentUriString": ["contentIiStr", "contentUniString", "contentUiStr", "contentUiString", "contentUnuriNumber", "contentUiStatic", "contentUicStatic", "contentUuriString", "contentUrisstring", "contentUnriNumber", "contentUrisStr", "contentUristring", "contentUriNumber", "contentIiString", "contentUuristring", "contentUnuristring", "contentUrisNumber", "contentUniNumber", "contentUuriNumber", "contentUuriStatic", "contentUistring", "contentIristring", "contentUicStr", "contentUnuriString", "contentIiStatic", "contentUnristring", "contentUriStatic", "contentIriStr", "contentIistring", "contentIriString", "contentUuriStr", "contentUicString", "contentUnriString", "contentUicstring", "contentUnuriStr", "contentUriStr", "contentIriStatic", "contentUnistring", "contentUnriStr", "contentUniStr", "contentUrisString"], "mSize": ["lSize", "mBytes", "lPos", "lBytes", "moPos", "moBytes", "mPos", "nPos", "nLength", "nSize", "lLength", "nBytes", "moSize", "mLength", "moLength"], "mContentUri": ["mContentIRI", "mContentUris", "mContentPris", "mResourceIRI", "mContent_RI", "mContentIri", "mContentPRI", "mResourceUris", "mContent_ris", "mContentIuid", "mResourceURI", "mResourceIri", "mContent_uid", "mContentIris", "mContentPuid", "mContentURI", "mResourceIuid", "mResourceIris", "mContent_ri", "mContentUuid", "mResourceUuid", "mContentPri", "mResourceUri"], "cv": ["nc", "av", "cn", "tc", "cas", "cmp", "gc", "CV", "cap", "c", "cont", "rc", "xc", "vv", "nv", "lc", "desc", "cc", "ct", "mult", "cp", "ov", "dc", "v", "uv", "pb", "GV", "vt", "um", "ev", "lv", "sv", "buf", "cf", "vp", "csv", "fc", "vc", "qv", "act", "cu", "conv", "cm", "cb", "vm", "box", "qu", "vol", "vr", "const", "cod", "ctrl"], "uri": ["handle", "u", "ur", " Uri", "URI", "phi", "picture", "link", "qi", " URI", "component", "url", "du", "range", "prefix", " ni", "ui", "address", "id", "resource", "unit", "directory", "report", "uu", "folder", "q", "term", "iri", "bid", "uid", "ip", "origin", "ri", "doi", "query", "i", "subject", "uni", "ue", "result", "dir"]}}
{"id1": "21555906", "id2": "1586662", "code1": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["Actionperressed", "Actionperceived", "ActionPerformed", "ActionPerressed", "Actionperuted", "actionperuted", "actionperressed", "actionPerressed", "actionPeruted", "actionperformed", "Actionperformed", "actionTransceived", "actionTransuted", "actionPerceived", "actionTransressed", "actionExecformed", "actionperceived", "ActionPeruted", "ActionPerceived", "actionTransformed", "actionExecressed", "actionExecceived", "actionExecuted"], "ae": ["aa", "ace", "re", "ene", "ase", "ade", "ee", "arde", " pe", "ge", "a", "se", "e", "AE", "es", "ane", "ce", "iae", "oe", "fe", " ace", "ze", "er", "ra", "ea", "ape", "ese", "je", "action", " ge", "me", "pe", "de", "eeee", "za", "sa", "te", "ke", "xe", "eu", " je", "ca", "ei", "ue", "event"], "toservlet": ["tosupert", "tosuperle", "tooserverlet", "tosourcet", "toservert", "tosservle", "tooservole", "tosservlet", "tosuperlets", "tooservlets", "toserverlet", "toservLET", "tooservLET", "tosservlets", "toserverlets", "tooservt", "tooservlet", "tosuperole", "tosuperLET", "tooservert", "tosuperlet", "toservole", "toserverole", "tosourcele", "tosourceole", "tooserverle", "tooserverole", "toservle", "toservt", "tosservLET", "tooserverLET", "tooservle", "toserverLET", "tosourcelet", "toserverle", "toservlets", "tooserverlets"], "servleturl": ["serviceletUrl", "servlUrl", "servbleurl", "serviceleturl", "servvetconnection", "servleteUrl", "serviceletsname", "selectleturl", "servleurl", "servletname", "servleUrl", "servleloc", "servvetname", "servlconnection", "servletloc", "selectletUrl", "selectletloc", "serviceletname", "servbleloc", "servleconn", "servbleconn", "servletsname", "servleteloc", "selectbleurl", "selectbleconn", "serviceletsurl", "servleteurl", "selectbleUrl", "servletsurl", "serviceletconnection", "servletsconnection", "serviceletsUrl", "servbleUrl", "servletUrl", "servveturl", "selectbleloc", "servvetUrl", "servleteconn", "serviceletsconnection", "servlurl", "servletsUrl", "servletconn", "selectletconn", "servlname"], "servletconnection": ["servvetconnection", "servletsconn", "servletecontext", "servlecharacter", "servvetConnection", " servetcharacter", "servlexcharacter", "servetConnection", "servantConnection", "servletscharacter", "servleconnection", "servLETconnect", "servleconnect", "servlexconn", "servletopen", "serviceantconnection", "ervleteconnection", "ervletconnection", " servletsConnection", "serviceletopen", "serviceantconn", " servletcontext", "servetconnect", "servetconn", "portleturl", " servetconnect", "portLETconnection", "servleConnection", "servantconn", "ervletconn", "serviceantConnection", "portLETurl", "serviceletConnection", " servletsconnection", " servetConnection", "servletConnection", "servletconnect", "ervletecharacter", "servvetopen", "servletcontext", "servLETConnection", " servletconnect", "portLETConnection", "servlecontext", "ervletcharacter", " servetconn", "serviceletconn", "servetconnection", "servleteconnect", " servletconn", "portletConnection", "servleteurl", " servletConnection", "servletsurl", "servantopen", "serviceletconnection", "servvetconn", "servletscontext", "servetcharacter", "portLETconnect", " servetconnection", "servletsclient", "servletconn", "servletsConnection", " servletscontext", "servleteconnection", "ervletConnection", "servletcharacter", "ervleteConnection", "serviceantopen", "servlexconnection", "ervleteconn", "portletconnection", "servleconn", "servlexconnect", "servletsopen", " servletsclient", "servLETurl", "servleclient", " servletclient", "servletsconnection", "servLETconnection", "portletconnect", "servleteclient", "servleteConnection", " servletcharacter", "servantconnection", "servletsconnect", "servletecharacter", "servleteconn", "servletclient"], "inputFromClient": ["inputWithClient", "inputFromRemote", "inputStreamClient", "inputInServer", "inputWithclient", " inputFromRemote", "inputToCurrent", "InputToClient", "inputfromCurrent", "inputfromClient", "inputfromCase", " inputfromClient", "inputToRemote", " inputfromclient", "inputWithRemote", "inputInClient", "InputFromclient", " inputToServer", "inputfromRemote", " inputToClient", "inputFromclient", "inputStreamRemote", " inputToCurrent", "inputfromServer", "InputFromClient", "inputfromclient", " inputfromRemote", "InputToRemote", "inputStreamCase", "inputStreamclient", " inputFromServer", " inputFromclient", "inputInCurrent", "inputInRemote", "inputFromServer", " inputFromCurrent", "inputToServer", " inputFromCase", "inputFromCurrent", "inputInclient", " inputfromServer", "InputToclient", " inputfromCase", "InputFromRemote", "inputFromCase", "inputToClient", "inputToclient"], "fos": ["foes", "tos", "Fos", " foes", "fOS", "bows", " fows", "fows", "sfos", "toes", "Foes", "tOS", "bOS", "sfOS", " foses", "boes", "sfoes", "Foses", " fOS", "bos", "tows", "foses", "sfoses", "FOS"], "buf": ["bar", "orig", "buff", "b", "cap", "pkg", "mu", "ref", "batch", "block", "mem", "Buffer", "cp", "vec", "fb", "buffer", "uf", "doc", "tab", "temp", "cur", "pause", "Buff", "seq", "cf", "cmd", "txt", "cat", "iter", "bag", "rb", "img", "br", "conv", "tmp", "bed", "db", "cb", "gen", "cv", "box", "bytes", "msg", "fg", "bc", "arr"], "bytesread": ["bitsadd", "bytesrun", "fieldsreadable", "byteswrite", "secondsreadable", "fieldswrite", "bytesreadable", "secondsread", "Bytesneeded", " bytesreadable", "bitsload", "secondsrun", "bytesadd", "bitsread", "bytesload", "fieldsread", "bpsload", "amplesneed", "secondswrite", "bytesneed", "Bytesread", "ampleswrite", " bytesadd", " byteswrite", "bitsprint", "amplesneeded", "amplesread", "bpsprint", "Byteswrite", " bytesload", "fieldsrun", "bytesprint", "Bytesneed", " bytesrun", "bytesneeded", "bpsadd", " bytesneed", " bytesprint", " bytesneeded", "bpsread"]}}
{"id1": "4481712", "id2": "11305840", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "label": 1, "substitutes": {"deleteObject": ["destroyItem", "getobject", "deleteobject", " deleteItem", "getObject", "deleteItem", "deleteObj", " deleteObj", "destroyobject", "destroyObject", " deleteobject", "getObj", "getItem", "destroyObj"], "id": ["info", "row", "t", "link", "pid", "mid", "path", "object", "h", "url", "Id", "ref", "it", "value", "oid", "delete", "name", "message", "p", "md", "kid", "k", "sid", "vid", "f", "n", "ids", "uid", "ID", "rid", "tag", "i", "hash", "db", "description", "data", "type", "ident", "key", "event", "d"], "conn": [" cc", "cn", "err", "resp", "gate", "pkg", "c", "coll", " dc", "ws", "socket", " mem", "port", "bo", "wp", "here", "cur", "Conn", "org", "ctx", "en", "conf", "oss", " ce", "canon", "co", "nw", "auth", "net", "nc", "pos", " cont", "urg", "pas", "client", "dc", " ch", "enc", "act", " c", " rc", " cs", "cb", " col", "loc", "ll", " con", "open", "pub", " compat", "pt", "ld", "mc", "cc", "ct", "pg", "cp", "ns", "ce", "connection", "obj", "n", "rel", "cf", "cmd", "cat", "ens", "comm", "cfg", " db", "nick", "db", " comm", "connect", "gen", " connection", "ann", "addr", " win", "ca", "tp", " cmd", "ctrl", " core", " conv", "close", "ch", "host", " net", " cx", "mn", " pc", "lang", " mc", "local", "win", " cp", "ssl", "con", "jp", "core", " ex", "nt", "conv", "com", " ac", "priv", "sys", "cons", "cert", "col"], "stmt": ["STmp", "stst", "ststat", " ststat", "utmp", "Ststat", "stmp", " stmb", "strmb", "utm", "statm", "Stmm", "strmn", "STmt", "strmt", "STst", " stm", "astmt", "astpt", "STMT", "STmm", "strMT", "statmb", "formmt", "strm", "formstat", "stm", "statmt", "Stst", "statpt", " stMT", "utst", "utmt", "ostpt", "StMT", "astm", "Stmp", "Stpt", "Stm", " stmn", "ostmm", "ostmt", "astmm", "stmb", "stMT", " stmm", "formm", "ostm", "formMT", "Stmn", "stmm", " stpt", "Stmb", "Stmt", "STm", "stmn", "stpt"], "dbConn": ["dbConnect", "dsConnect", "DbColl", "DBColl", "dbColl", "DBRec", "dbCon", " dbObj", "DBObj", "dbCt", "DBConn", "dbObj", "dsCon", "DbCon", "DbConn", " dbConnect", " dbColl", "DbObj", "DbCt", "DbRec", " dbCon", " dbRec", "dsCt", "dsConn", "dbRec", "DbConnect", " dbCt"], "selfConnection": ["reConnection", "SelfInfo", "alsoConnection", "ownConnect", " selfLink", "ownLink", "alsoLink", " selfConnect", "ownThread", "SelfFree", "selfCategory", "selfOnly", "ownConnection", "selfLink", "selfFree", " selfCategory", " selfThread", " selfconnection", "SelfOnly", "reconnection", "ownOnly", "selfConnect", "SelfConnect", "SelfConnection", " selfOnly", "alsoCategory", "SelfCategory", "ownFree", "selfconnection", "reConnect", "alsoConnect", "reLink", "selfInfo", "Selfconnection", " selfFree", "SelfLink", "selfThread", " selfInfo", "SelfThread"]}}
{"id1": "13657103", "id2": "823074", "code1": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"forBundle": [" manageBunch", " processEmbasket", " processRebundle", " processEmbunch", " processRebunch", " manageRebranch", " processPasket", " processPundle", " processBunch", " manageRebunch", " manageRebundle", " processBranch", " processBasket", " processPunch", " processEmbranch", " processPranch", " processEmbundle", " manageRebasket", " manageBranch", " processRebranch", " manageBundle", " manageBasket", " processBundle", " processRebasket"], "manip": ["Manip", " ManIP", "manop", "emanip", "emanipper", " Manap", "managerip", " Manip", "Manup", "manipper", "emaniper", "manIP", "manips", " manap", "MANap", "MANIP", "emanIP", "emanap", "damipper", "emanup", " maniper", "managerop", "Manips", "MANip", "emanop", "manap", "Manop", "Manap", "maniper", "damiper", " Manips", "damip", "managerup", " manipper", "MANips", "managerIP", "ManIP", "damap", "manup"], "bout": ["bbio", "bbouts", "zin", " boff", "zOUT", "bOut", "zou", "zOut", "bbOut", "wpool", "bOUT", " bio", "boff", " bou", "bbop", "BOUT", "Bout", " bin", "bpool", "zouts", "wop", "wou", "wout", "Boff", "bouts", "bio", "bou", "bin", "Bin", "zoff", "zio", " bOUT", " bOut", "bbpool", "bbout", " bpool", " bop", "wOut", " bouts", "bop"], "zout": ["tzout", "zin", "zerouts", "zoend", "zOUT", "zou", "zippool", " zin", " zoss", "ezOUT", " zouts", "zend", " zos", "zOut", "zoneout", "wpool", "ozoss", "zoneouts", "zoent", "zoneOut", "azout", "azouts", "ezout", "zeOut", "ozou", "zipouts", "ezos", "zeout", " zaos", "zerout", "zouts", " zou", "zipin", " zent", "wout", "ozout", "ozos", "azOut", "zipnet", " zall", "zoss", "zent", "tzOUT", "zall", "win", "zoouts", "zos", "ozOUT", "zein", "zoout", "zenet", "zoneaos", "zpool", "zipaos", "ozall", "azin", " zend", "znet", "zipOut", "wouts", "zaos", " znet", " zOUT", " zOut", "tzoss", "zerend", "zipout", "wOut", " zpool", "zerent", "tzall", "ezou"], "bundle": ["brundle", "pbkg", "pbulk", "bigration", "masket", "boigration", "brasket", "sbound", "rbkg", " bund", "mond", "rbundle", "mbund", "abulk", "rbulk", "bond", " bulk", "bund", "sbasket", "mund", " bond", "abigration", "bound", "bkg", "lasket", "pbundle", "sbund", " basket", "boulk", "abundle", "rbasket", "boasket", "basket", "mbasket", " bkg", "abasket", "sbundle", "boundle", "brulk", "mbond", "brigration", "lundle", " bound", "pbasket", "lound", "bulk", "mundle", "mbundle", "lund"], "files": ["faces", "styles", "bees", "actions", "features", "forms", "pages", "Files", "balls", "ls", "resources", "rows", "facts", "roots", "lets", "results", "runs", "issues", "books", "ails", "seconds", "users", "values", "ures", "stores", "items", "lines", "fields", "assets", "fs", "les", "ids", "rules", "groups", "headers", "organisms", "links", "objects", "plates", "keys", "ds", "types", "ports", "photos", "leases", "iles", "reports", "fixes", "names", "sites", "times", "bytes", "file", "chains", "classes", "images", "ions", "obs"], "url": ["m", "re", "bel", "ur", "http", "link", "b", "path", "ls", "gl", "ml", "sp", "buffer", "resource", "l", "uri", "f", "sl", "r", "nl", "fl", "mb", "str", "rel", "mount", "user", "sb", "location", "char", "li", "Url", "mail", "web", "ob", "el", "norm", "html", "file", "dl", "ll", "entry", "loc", "key", "cert", "URL", "browser"], "name": ["info", "full", "m", "NAME", "length", "Name", "run", "path", "default", "prefix", "on", "version", "nm", "none", "part", "common", "internal", "id", "address", "normal", "f", "source", "str", "one", "n", "me", "code", "term", "no", "order", "node", "local", "named", "string", "title", "all", "alias", "word", "num", "names", "hash", "ame", "comment", "file", "data", "type", "size", "format", "family", "key", "label", "filename", "len", "event"], "mf": [" mfo", "manF", "manff", "Mfo", " Mf", "Mif", "Mf", "Mfy", "manfy", "mnf", "mfo", " Mff", "mnfo", "mnif", "manf", "Mff", "mF", "mif", " Mfy", " mif", " mF", "mff", " MF", "mnF", "mfy", "MF"], "tmpFile": ["tempName", "tmpCheck", "TempFile", "mpfile", " tmpFiles", " tmpfile", "tmpPlace", "Tempfile", "tempDir", "potFiles", "tmpName", "mpDir", "tarfile", "mpFile", "potPlace", "tmpFiles", "tarFile", "TempF", "tempFiles", "tempfile", "tempFile", "tarCheck", "tarName", " tmpPlace", "tmpfile", "TempCheck", "tempF", "TempName", "potfile", "tempPlace", "TempDir", "mpF", "potFile", "tempCheck", "tmpF", "tmpDir"], "ref": ["ret", " reg", "rep", "REF", "re", "nav", "rev", " referred", " pref", "link", "pid", "resp", "rc", "href", "pkg", " href", "range", "reference", " refer", "prefix", " references", "mem", "rm", "id", "Reference", "port", "req", "f", "r", "tab", "service", "pro", " req", "rel", "eb", " ret", "def", "conf", " val", "br", " id", "rem", " re", "af", "Ref", "prop"]}}
{"id1": "8087001", "id2": "2465747", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"generateStackHashKey": ["generateTrackHashPage", "generateStackNodeKeys", "generateTrackhashKey", "generateTrackHashKey", "generateStackNodeIndex", "generateStackhashIndex", "generateStackHashKeys", "generateStackhashPage", "generateStackNodePage", "generateStackStateIndex", "generateTrackhashPage", "generateStackHashPage", "generateStackhashKey", "generateStackHashIndex", "generateStackStatePage", "generateTrackHashIndex", "generateStackStateKeys", "generateTrackHashKeys", "generateTrackhashKeys", "generateTrackhashIndex", "generateStackhashKeys", "generateStackNodeKey", "generateStackStateKey"], "e": ["m", "u", "t", "err", "email", " exc", "ee", "ec", " pe", "ge", "o", "h", "a", "se", "ed", "es", "oe", "error", "p", "er", "ae", "element", "f", "r", " me", "x", "E", "n", "me", "pe", " err", "eb", "ex", "eeee", "exp", "en", " te", "ie", "ep", " error", "ef", "exc", "te", "eer", "eg", "i", "el", "xe", " ce", "eu", "ne", "ue", "event", "d"], "digest": ["digse", "decse", "compests", "Digse", "Digested", "descgest", "digested", "Diger", "mdEST", "mdest", " diger", "digester", "decest", "digests", "Digests", "compested", "compEST", "mdested", "DigEST", "compest", "diger", "descer", "Diggest", "descse", " digested", "diggest", " digse", "mdse", "decester", " digEST", "decested", "mdester", " diggest", "descest", "Digest", "Digester", "digEST", " digester", " digests"], "hash": ["hex", "bh", "sample", "mac", "total", "h", "has", "score", "ash", "block", "ashed", "check", "sh", "valid", "build", "filter", "message", "dig", "map", "report", "log", "cache", "test", "search", "all", "style", "sha", "Hash", "sum", "tag", "html", "her", "chain", "key", "rh", "shadow"], "rtn": ["latn", "ntN", "rxn", "latne", "rton", "RTcn", "rtmn", "mtn", "RTn", "otne", "rtns", "rtne", "vrnm", "vrb", "ntb", "ntnm", "ytnor", "rotyn", "RTb", "RTnm", "otmn", "aptnu", "rtyn", "ttnu", "artns", "rotn", "rotns", "latnm", "rxmn", "latmn", "apton", "artnor", "ytns", "ertr", "aptr", "ttr", "ttn", "otnm", "rotnor", "artn", "RTN", "mtnm", "rotcn", "aptn", "rotnm", "rotnu", "otn", "ertnu", "ertn", "rxnm", "rtnu", "rtr", "artyn", "mtnu", "rtb", "mtcn", "rtcn", "ntn", "tton", "RTnu", "rtnm", "vrN", "rxne", "rtN", "ytyn", "vrn", "erton", "ytn", "rtnor"]}}
{"id1": "3430784", "id2": "536614", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decodeContent", " DecodeForm", "decodesContent", "decprocessBody", " DecodesForm", "decodesForm", "decodedContent", " DecodeBody", "decodesBody", "decodedBody", "decodedHeader", " DecodeHeader", "decodedForm", " DecodesHeader", "decprocessContent", "decodeHeader", " DecodesContent", "decodesHeader", "decprocessForm", "decprocessHeader", "decodeForm", " DecodesBody", " DecodeContent"], "in": ["gin", "info", "m", "b", "c", "get", "up", "add", "doc", "inc", "from", "init", "en", "input", "asin", "inside", "mat", "load", "ac", "sql", "oin", "pi", "it", "inf", "ind", "to", "r", "ai", "conn", "q", "source", "mm", "act", "body", "xml", "form", "serv", "vin", "on", "or", "check", "v", "ain", "rin", "n", "iter", "IN", "isin", "all", "din", "i", "file", "is", "In", "nin", "cont", "h", "cin", "inn", "ins", "l", "req", "k", "reader", "content", "al", "ex", "pc", "bin", "inner", "con", "ma", "data"], "contentTransferEncoding": ["contentRequestEncoder", "contentTransferChoding", "contentTypeEncoding", "contentTransferencacing", "contentRequestencoder", "contentTransferEnoder", "contentTransferFormoding", "contentRequestEncication", "contentTransferEvoding", "contentTransferEnapping", "contentInfoEncoder", "contentTransferSeode", "contentTransferEvication", "contentTransferEvoder", "contentTransferColloder", "contentTransferEncType", "contentTransferChoded", "contentTransferEncode", "contentTransferEncication", "contentTransferEvoded", "contentRequestEncation", "contentTransferEncation", "contentRequestEnation", "contentTransferencType", "contentTransferEncapping", "contentTransferFormType", "contentTransferencoding", "contentTypeEnoded", "contentTypeEncapping", "contentTransferColloding", "contentTransferChapping", "contentTypeEnapping", "contentRequestencication", "contentTransferencication", "contentTransferEnacing", "contentTransferAuthType", "contentTypeEncoded", "contentInfoencoding", "contentTransferFormoder", "contentInfoencling", "contentTypeEnode", "contentTransferAuthoder", "contentTransferEncacing", "contentTransferEncling", "contentRequestEnasting", "contentTransferEncoder", "contentTransferSeoded", "contentInfoEncoding", "contentInfoencacing", "contentTypeEncode", "contentTransferAuthoded", "contentTransferEnling", "contentRequestencoding", "contentTransferChode", "contentTransferEnode", "contentTransferEnasting", "contentTransferCollasting", "contentTransferFormling", "contentInfoEncacing", "contentRequestEnoding", "contentTransferencoder", "contentRequestEnType", "contentInfoEncling", "contentRequestEnoded", "contentTransferSeoding", "contentTransferencling", "contentRequestencoded", "contentTransferEnoded", "contentTransferSeapping", "contentRequestEncoded", "contentTransferEnType", "contentTransferEncoded", "contentTransferEnication", "contentRequestEncType", "contentRequestEncasting", "contentTransferAuthoding", "contentTransferEncasting", "contentTransferencoded", "contentTransferEnoding", "contentInfoencoder", "contentRequestEnoder", "contentRequestEncoding", "contentTransferCollation", "contentTransferEnation", "contentTypeEnoding"], "tempBody": ["tempReturn", " temporaryFoot", "TempFile", "tabBox", "tabBody", " tempHead", "temFile", "tmpHead", "tempbody", " temporaryReturn", "tabFoot", "tempFoot", "tempFile", "tmpBody", "temReturn", "tmpbody", " temporaryBody", " tempBox", "temBox", "TempBody", "temFoot", " tempFile", "Tempbody", "temBody", " tempbody", " temporaryBox", "tempBox", "temHead", "tabReturn", "TempHead", "tmpBox", "tembody", "tempHead"], "out": ["os", "cn", "m", "null", "t", "ent", "gc", "o", "up", "aos", "cin", "it", "client", "v", "writer", "obj", "to", "outs", "l", "log", "io", "one", "n", "res", "user", "output", "ex", "Out", "inner", "all", "con", "conv", "outer", "sum", "ou", "inv", "oss", "sys", "OU", "auto", "OUT", "co", "is", "cos", "net"]}}
{"id1": "8665649", "id2": "11154758", "code1": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        FileOutputStream fos = null;\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String filename = \"i.exe\";\n            fos = new FileOutputStream(filename);\n            client.retrieveFile(\"/\" + filename, fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"_getImage": ["_downloadImage", " _downloadimage", "_buildImages", " _downloadImages", "_buildImage", "_buildFile", "_getImages", "_buildimage", "_getFile", "_downloadFile", " _getImages", " _getimage", "_downloadImages", "_downloadimage", " _downloadFile", "_getimage", " _getFile", " _downloadImage"], "urlStr": [" urlSt", "urlSt", " urlSTR", "Urlstr", "uriString", "UrlStr", "uristr", "urlString", "mountStr", "uriSTR", "mountString", "urlstr", "lSTR", "imageSTR", "imageSt", "mountSTR", "imageString", "mountstr", "UrlSTR", "UrlString", "lString", "lSt", "urlSTR", "lStr", " urlString", "imageStr", "uriStr"], "url": ["pl", "re", "bel", "ur", "api", "http", "parse", "link", "https", "ls", "host", "base", "gl", "build", "client", "uri", "l", "f", "sl", "r", "nl", "rl", "q", "str", "org", "sb", "google", "ssl", "char", "atl", "Url", "web", "abs", "ul", "el", "sur", "ll", "lb", "dl", "loc", "cert", "URL"], "conn": ["nc", "cn", "gate", "c", "cont", "syn", "ch", "coll", "ct", "pg", "pas", "cp", "client", "connection", "cs", "l", "cur", "Conn", "yn", "enc", "org", "res", "rel", "cmd", "nn", "ctx", "init", "ssl", "comm", "con", "jp", "conf", "nt", "conv", "db", "cb", "connect", "canon", "ann", "loc", "serv", "open", "cert", "ctrl", "net"], "in": ["gin", "m", "t", "im", "include", " din", "pid", "oin", "mc", "o", "stream", "cin", "it", "on", "or", "inn", "ind", "ill", "ins", "s", "l", "rin", "req", "io", "reader", "doc", "inc", "out", "ai", "proc", "source", "user", "IN", "txt", "act", "from", "init", "en", "bin", "isin", "inner", "all", "con", "input", "again", "din", "body", "sum", "ma", "i", "mat", "qa", "as", "xml", "file", "is", "serv", "and", "In"]}}
{"id1": "15737836", "id2": "14688886", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["drop", "update", "link", "dump", "get", "disable", "add", "destroy", "Delete", "quit", "write", "clean", "select", "de", "set", "create", "touch", "move", "save", "database", "remove", "lete", "insert", "execute", "clear", "download", "load", "del"], "site": ["info", "sit", "domain", "item", "http", "link", "sample", "rule", "path", "ste", "base", "se", "e", "store", "settings", "environment", "name", "Site", "ze", "unit", "group", "service", "source", "scan", "node", "test", "course", "set", "station", "theme", "page", "template", "server", "network", "ite", "index", "session", "pse", "isite", "sites", "at", "config", "sys", "localhost", "data", "file", "remote", "chain", "software"], "dbo": ["drapo", "ddpo", "Dbu", "debugbo", "dpo", "Dpo", "dambo", "delmu", " dbu", " dado", "dbu", "ddBo", "dmu", "ppo", "delbu", "ddbo", "gBO", "dBo", "odpo", "debugambo", "Dado", "ddBO", "debugpo", "gbu", "drabon", "sdbo", "DBo", "Dbo", " dbon", "lBo", "debugBo", "DBO", "sdbu", "Dmu", "draBo", "ddbu", "dBO", "pbu", "odbo", "pbo", "sdBO", " dpo", "gbo", "drabo", "lpo", "lambo", "odBo", "pmu", "lbo", "ddado", " dBO", "delbo", "dado", "delpo", "Dbon", " dBo", "dbon", " dambo", "odbu"], "connection": ["computer", "usage", "creator", "po", "office", "link", "table", "handler", "c", "document", "ion", "engine", "collection", " Connection", "statement", "character", "reference", "cone", "management", "condition", "information", "established", "government", "socket", "settings", "binding", "system", "Connection", "client", "context", "resource", "bo", "directory", "writer", "library", "pointer", "conn", "operation", "connected", "created", "application", "console", "function", "controller", "output", "location", "associated", "container", "con", "current", "position", "network", "server", "database", "session", "relation", "manager", "communication", "config", "db", "connect", "pool", "auto", "city", "subject", "closure", "response", "generation", "open", "chain", "command", "intention", "net"], "preparedStatement": ["preparedQuery", "preparedCall", "PreparedDevice", " preparedCopy", "prejectedstatement", " prefixedCopy", "preachedstatement", "pparedStatement", "prepletedStatement", " prefixedStatement", "preparableStatement", "previsedQuery", "preachedGrant", "prefixedstatement", "pretparedListener", "premedStatus", " preachedStatement", "prejectedQuery", "preinitializedStyle", "premittedStyle", "prepletedDevice", "preferredStatement", "prejectedStatement", "preculatedstatement", "preferredCall", "prearedListener", " preparedStat", "preculatedStatement", "prepletedstatement", "prearedStatement", "prepferredstatement", "preachedCall", "postppedstatement", "postppedCall", "prefixedStatement", "prepletedStat", "premedStatement", "previsedStatement", "prepletedCall", "PreparedQuery", "preparableStatus", " prefixedstatement", "preachedStyle", "preparedDevice", "Preppedstatement", "prelatedStatement", "PreparedStatement", "preendedstatement", "preppedQuery", "perachedStatement", "preparedStat", "pretparedStatement", "prefixedCopy", "preparedStatus", "prearedQuery", " preparedstatement", "pretparableListener", "pparedStat", "prejectedCopy", "preendedStatement", "pparedQuery", "preppedStatus", "prefixedQuery", " prefixedQuery", "preformedStat", " preachedStat", "prearedCall", " preparedCall", " preachedCall", "PreppedStatement", "pretparableStatement", "previsedStat", "prelatedDevice", "preachedAdapter", "perparedStyle", "perachedAdapter", "postparedCall", "prepferredQuery", "preppedStat", "prearedCopy", "prepletedComment", "prearedComment", "prepletedGrant", "preparableListener", "preparedCopy", "preparedSQL", "prearedSQL", "paredStatement", "perparedStatement", "prepferredStatement", "prearedStatus", "prepferredSQL", "preparedListener", "perparedAdapter", "postppedStatement", " preparedQuery", "preppedstatement", "preformedStatement", "preparedStyle", "PrearedStatement", "PrearedComment", " preachedGrant", "pretparableStatus", "preachedComment", "prepparedQuery", "preferredstatement", "preparedstatement", "preformedGrant", "preinitializedAdapter", "preferredQuery", "premittedAdapter", "prepparedSQL", "pretparedStatus", "preferredSQL", "previsedStatus", "prelatedComment", "premittedStatement", "paredQuery", "prepparedStatement", "PreppedQuery", "preinitializedStatement", " preparedGrant", "premedListener", "preparedAdapter", "pparedStatus", "Prearedstatement", "perachedComment", "prearedDevice", "preculatedSQL", "prepparedCall", "perachedStyle", "paredStatus", "prepparedstatement", "premittedComment", "preppedStatement", "preparedComment", "preinitializedComment", "prearedstatement", "preparedGrant", "preculatedQuery", "prearedStat", "paredStat", "Preparedstatement", "perparedComment", "prelatedstatement", "prefixedCall", "preachedStatement", "PreparedComment", "preendedQuery", "PrearedDevice", "preformedCall", "postparedstatement", "preppedCall", "preachedStat", "postparedStatement"], "resultSet": ["resultSum", "resultPath", " resultList", "resultHandle", "ResultSession", "rowSession", "resultsList", "dataStream", " resultStream", "dataTime", "ResultSet", "characterStream", "ResultHandle", "responseUn", "characterSet", " resultSum", " resultPath", "responseStream", "responseSet", "ResultTime", "resultUn", " resultHandle", "rowSet", "ResultSum", "resultSession", "characterSum", "resultSource", "resultsPath", "resultTime", "resultsUn", "ResultStream", "resultStream", " resultSession", " resultTime", "dataSet", "resultList", "ResultUn", "rowSource", "resultsStream", "ResultList", "ResultSource", "resultsSet", " resultSource", "ResultPath", "rowHandle"], "chkSql": ["chKSyl", "chKDk", "chkSq", "chkInsql", "chKInsql", "chKDyl", "chKSQL", "chkDyl", "chkDk", "chKDQL", "chkRSyl", "chkDql", "chkSk", "chkRSQL", "chkDQL", "chKInsq", "chkInsQL", "chkStrQL", "chKInsQL", "chkRSql", "chKSql", "chkDq", "chkRSk", "chKDql", "chkStrq", "chkStrql", "chkSQL", "chKSq", "chkSyl", "chkInsq", "chKSk"], "selfDefinePath": ["selfDeliningPath", "selfDefinedKey", "selfDefineSet", "selfDefideDir", "selfdefinePath", "selfDefineKey", "selfDefINESet", "selfDefINEpath", "selfDelinepath", "selfDefiningpath", "selfDeliningKey", "selfDelineKey", "selfdefinePattern", "selfDefinedSet", "selfDefiningKey", "selfDefinedpath", "selfDefiningDir", "selfDefidePattern", "selfDefinepath", "selfdefinespath", "selfDefINEKey", "selfDelinePath", "selfDeliningSet", "selfDefiningSet", "selfDefinedPath", "selfdefinepath", "selfdefineDir", "selfDefiningPattern", "selfDefinesPath", "selfDefinesDir", "selfdefinesPath", "selfDeliningpath", "selfDefinesPattern", "selfDefidePath", "selfDelineSet", "selfDefinePattern", "selfDefidepath", "selfdefinesPattern", "selfDefiningPath", "selfdefinesDir", "selfDefINEPath", "selfDefineDir", "selfDefinespath"], "sqlStr": [" sqlString", " sqlSt", "sqlWr", "sqString", "qlstr", "sqlstr", " sqlName", " sqlstr", "sqWr", "sqlSt", " sqlWr", "SQLstr", "sqlName", "SQLSt", "sqstr", "sqSt", "sqStr", "qlStr", "qlName", "qlString", "sqlString", "SQLWr", "SQLStr", "sqName"]}}
{"id1": "4982745", "id2": "6299111", "code1": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "code2": "    public static String retrieveQ(String urlToRetrieve) throws MalformedURLException, IOException {\n        URL url = new URL(urlToRetrieve);\n        URLConnection uc = url.openConnection();\n        InputStream is = uc.getInputStream();\n        BufferedReader in = new BufferedReader(new InputStreamReader(is));\n        StringBuilder output = new StringBuilder(16384);\n        String str;\n        boolean first = true;\n        while ((str = in.readLine()) != null) {\n            if (!first) output.append(\"\\n\");\n            first = false;\n            output.append(str);\n        }\n        in.close();\n        System.err.println(((HttpURLConnection) uc).getResponseMessage());\n        return output.toString();\n    }\n", "label": 0, "substitutes": {"doJSONRequest": [" doJSONResponse", "doHTTPConnection", " doHTTPRequest", " doJSONQuery", "doHTTPRequest", " doHTTPQuery", "doHTTPQuery", " doHTTPResponse", "doCustomResponse", "doJSONConnection", "doJSONQuery", "dojsonResponse", "doCustomQuery", "dojsonConnection", "doJSONResponse", "dojsonQuery", "dojsonRequest", "doHTTPResponse", " doJSONConnection", "doCustomConnection", "doCustomRequest", " doHTTPConnection"], "jsonRequest": ["JSONRequest", "jsonObject", "rawPost", "sonObject", "rawRequest", " jsonObject", "rawObject", "jsonPost", "JSONObject", "rawResponse", " jsonPost", "sonRequest", "sonPost", "JSONPost", "sonResponse", "JSONResponse"], "request": ["record", "project", "re", "QUEST", "person", "http", "update", "setup", "close", "document", "object", "url", "get", "reference", "pair", "add", "condition", "quest", "use", "address", "name", "client", "question", "message", "this", "resource", "post", "context", "report", "req", "call", "begin", "reset", "claim", "q", "transform", "application", "order", "create", "start", "copy", "search", "input", "instance", "position", "query", "first", "remove", "xml", "requ", "initial", "insert", "Request", "hello", "self", "remote", "job", "command", "complete"], "params": ["styles", "eters", "details", "cas", "pps", "eps", "actions", "cap", "pkg", "services", "prop", "points", "parent", "settings", "cp", "pas", "amps", "multi", "spec", "pins", "lines", "proc", "gs", "members", "pers", "param", "Parameters", "rules", "caps", "rs", "mm", "ctx", "groups", "headers", "types", "ports", " parameters", "properties", "par", "tmp", "phys", "ims", "json", "terms", "changes", "ams", "parts", "ars", "pool", "as", "pres", "posts", "names", "sys", "chains", "stats", "options", "tags", "ps", "shape"], "entity": ["eme", "details", "person", "null", "note", "email", "orm", "document", "security", "object", "component", "e", "valid", "ct", "available", "oe", "ce", "environment", "activity", "quote", "connection", "buffer", "error", "resource", "obj", "ae", "account", "enc", "code", "application", "em", "pe", "user", "om", "ip", "create", "metadata", "encrypted", "iam", "iso", "le", "json", "query", "Entity", "ITY", "el", "comment", "xml", "model", "entry", "type", "ell", "ent", "ity", "event", "shell"], "t": ["tt", "m", "tim", "iat", "tw", "tc", "z", "w", "det", "j", "total", "c", "tick", "ot", "ut", "ti", "it", "e", "ct", "now", "ts", "p", "y", "s", "mt", "l", "f", "vt", "temp", "x", "ta", "n", "g", "T", "st", "txt", "pt", "qt", "nt", "i", "at", "wt", "elt", "tm", "dt", "tf", "time", "tp", "duration", "et", "d"], "response": ["memory", "answer", "re", "resp", "document", "object", "onse", "success", "e", "version", "environment", "client", "message", "connection", "sequence", "reset", "report", "service", "out", "respond", "one", "res", "application", "output", "given", "tree", "reply", "network", "Response", "body", "next", "json", "frame", "description", "data", "remote", "status", "result"], "responseString": [" responseArray", "replySystem", "ResponseObject", "responseSystem", "replyStr", "replystring", "messageString", "messageObject", "responseText", "resultString", "replyString", "ResponseArray", "ResponseString", "resultstring", "ResponseStr", "responseStr", "outputText", "answerObject", "outputArray", " responseSystem", "resultStr", " responseText", "ResponseSystem", "resultObject", " responseObject", "outputStr", "messagestring", "answerStr", " responsestring", "outputString", "messageStr", "Responsestring", "responsestring", "responseArray", "answerString", " responseStr", "answerstring", "ResponseText", "responseObject"], "jsonResponse": ["JSONRequest", "jsonData", "JSONResp", "xmlRequest", "jsonObject", "JSONData", "sonStatus", "sonObject", " jsonResp", " jsonData", "csvAnswer", "sonAnswer", " jsonObject", "csvResponse", "sonData", "jsonStatus", " jsonStatus", "sonError", "sonResp", "JSONObject", " jsonresponse", "jsonAnswer", "jsonresponse", "JSONresponse", "csvStatus", "JSONAnswer", "xmlResp", "xmlResponse", "JSONResponse", "sonresponse", "csvResp", "xmlError", "jsonResp", "sonRequest", " jsonAnswer", "xmlAnswer", "sonResponse", "xmlObject"], "jsonError": ["jsonAuth", "javascriptAuth", "javascriptError", "jError", " jsonQuery", "sonQuery", "javascriptQuery", "JSONAuth", "sonError", "JSONEr", "jQuery", " jsonEvent", "jsonEvent", "jsonQuery", "JSONEvent", "jAuth", "JSONError", "sonResponse", "javascriptEr", "sonEvent", "JSONQuery", "jEr", "jsonEr", "JSONResponse"]}}
{"id1": "22046596", "id2": "16623181", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["paste", " rename", "upload", " copying", " share", "Copy", " paste", " swap", " seek", " restore", "cp", " cop", " move", " replace", " dup", " parallel", "write", " replicate", " cp", " mirror", " extend", " overwrite", " duplicate", " Transfer", "transfer", " insert", " populate"], "s": ["src", "os", "ms", "less", "z", "b", "ws", "ls", "ss", "its", "es", "sq", "ies", "ns", "ts", "v", "p", "cs", "ins", "l", "f", "sl", "sf", "ses", "gs", "ats", "js", "g", "source", "S", "n", "fs", "st", "str", "sv", "rs", "sb", "sts", "string", "ds", "input", "ys", "xs", "south", "gets", "is", "qs", "ps"], "t": ["ret", "tt", "rt", "tc", "w", "kt", "j", "gt", "ot", "h", "o", "it", "ct", "ts", "p", "v", "mt", "l", "k", "f", "n", "g", "T", "test", "st", "txt", "unt", "title", "template", "tr", "nt", "te", "i", "at", "wt", "ht", "ent", "pt"], "in": ["gin", "info", "im", " din", "oin", "mi", "up", "cin", "it", "inf", "inn", "ind", "ins", "ic", "rin", "io", "inc", "ai", "source", "user", "from", "iter", "IN", "init", "en", "bin", "isin", "inner", "ie", "con", "input", "sin", "din", "inside", "i", "is", "ar", "and", "ir", "In"], "out": ["cn", "w", "j", "b", "gt", "c", "ot", "ch", "o", "up", "aos", "it", "or", "check", "client", "this", "v", "can", "to", "l", "outs", "k", "io", "by", "conn", "n", "g", "res", "output", "ex", "Out", "en", "con", "nt", "outer", "ou", "i", "sys", "msg", "OUT", "co", "channel", "ac", "result", "net"]}}
{"id1": "17193692", "id2": "19322910", "code1": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"execUpdate": ["ExecAction", " ExecAction", "executeUpdate", " ExecUpdate", " executeSet", " ExecSelect", " ExecSet", "executeSelect", " executeSelect", " executeUpdate", "ExecSelect", "ExecSet", " executeAction", "ExecUpdate", "executeSet", "executeAction"], "sqlStmts": ["sqlStarmms", "sqlStlms", "sqlSymts", "sqlSttmls", "sqlStrnt", "sqlStmls", "sqlStrmts", "sqlStlps", "sqlStrruts", "sqlStmtters", "sqlSttmnt", "sqlStmters", "sqlStrrks", "sqlStmsts", "sqlStmks", "sqlStamuts", "sqlStmuts", "sqlStmths", "sqlStrrts", "sqlStmms", "sqlStrmls", "sqlStrts", "sqlStrrms", "sqlStrrmnt", "sqlSymps", "sqlSttmts", "sqlStrmnt", "sqlStrmps", "sqlStruts", "sqlStarmters", "sqlStrters", "sqlStrms", "sqlStamters", "sqlStrns", "sqlStmtks", "sqlSylts", "sqlStmments", "sqlStrrps", "sqlStlters", "sqlStrments", "sqlStarmments", "sqlStrrnt", "sqlStmnt", "sqlStrrls", "sqlStrrmts", "sqlStrmks", "sqlStmtsts", "sqlSylsts", "sqlStmrts", "sqlStmps", "sqlStrths", "sqlStrmters", "sqlStmrters", "sqlStmns", "sqlSylps", "sqlStmrns", "sqlStrmns", "sqlStsls", "sqlStmtns", "sqlStrps", "sqlStrmsts", "sqlStrrters", "sqlStrrths", "sqlStrrmps", "sqlStamths", "sqlSymms", "sqlSttmps", "sqlStrmths", "sqlStlts", "sqlStrrns", "sqlStrls", "sqlStmtts", "sqlStamts", "sqlStrrments", "sqlStsnt", "sqlStlsts", "sqlSylms", "sqlStrks", "sqlStsts", "sqlStmrks", "sqlStrmments", "sqlStarmts", "sqlStrmuts", "sqlSymsts", "sqlSttmters", "sqlStmtms", "sqlStrrmters", "sqlStsps", "sqlStlments", "sqlStrmms", "sqlStmtps"], "i": ["info", "ji", "m", "u", "ci", "im", "z", "in", "phi", "j", "ii", "gi", "qi", "c", "my", "I", "us", "mi", "key", "a", "o", "ti", "pi", "it", "di", "ini", "ui", "ind", "hi", "id", "zi", "v", "y", "multi", "ic", "uri", "ai", "\u0438", "x", "n", "g", "me", "ori", "iu", "bi", "ip", "cli", "si", "ie", "ij", "ri", "index", "slice", "point", "sim", "li", "ix", "ma", "asi", "xi", "is", "yi", "ims", "ei"], "stmt": ["stg", " stmsg", "Stmsg", "stmp", "smp", "Stt", "smt", " stm", " stmp", "ostg", "stm", " stMT", "sm", "stymsg", "Stg", "stt", "st", "StMT", "Stmp", " stt", " stg", "Stm", "stym", "ostmt", "stmsg", "stMT", "styMT", "ostm", "stymt", "Stmt", "ostMT"]}}
{"id1": "1798720", "id2": "5998352", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 1, "substitutes": {"save": ["install", "send", "upload", "zip", "update", " Save", "dump", "archive", "pkg", "register", "version", "aw", "release", "delete", "store", "Save", " seal", "folder", "pack", "init", "export", "data", "download", "filename", "saving", "accept"], "packageName": [" packagename", "pkgNames", "pkgKey", "packageKey", "pkgType", "PackageId", "packagename", "PackageNames", " packageKey", "pkgId", "pkgName", "packageId", "moduleId", "PackageName", "moduleNames", " packageCode", "packageNames", " packageType", " packageNames", " packageId", "PackageType", "moduleCode", "modulename", "pkgCode", "packageType", "moduleKey", "packageCode", "pkgname", "moduleName"], "fileContents": [" fileBytes", " fileItems", "packageContents", " fileValues", "fileItems", "packageContent", "byteNames", "byteContent", "fileContent", "FileBytes", "fileValues", "FileContent", "packageNames", "FileItems", "fileIngredients", "FileNames", "pageItems", "byteContents", "pageNames", "FileContents", "pageBytes", " fileIngredients", "pageContents", "byteValues", "fileBytes", "packageIngredients", "FileIngredients", " fileContent", "FileValues"], "fileNames": ["issueVaults", "fieldNumbers", "dirNames", "fileTypes", "messageNames", "fileLeaks", "moduleVaults", "fieldTypes", "resourceTypes", "fileName", "FileTypes", " fileLeaks", "fileNumbers", "issueNames", "dirTypes", " fileValues", "FileLeaks", "messageKeys", " fileName", "messageValues", "moduleNames", "fieldNames", " fileTypes", "moduleContents", "fieldContents", "fileValues", "issueName", "FileNames", "resourceNumbers", " fileVaults", " fileNumbers", "resourceValues", "fileKeys", "messageName", "FileContents", "resourceContents", "resourceNames", "FileName", "dirLeaks", "fileVaults", "dirKeys", " fileKeys", "issueContents", "moduleName", "FileKeys", "FileValues"], "dirBase": [" directoryBuilder", "dirBasic", "DIRBas", "irSet", "DirBase", "dirBas", "dirSet", "pathBasic", "folderBas", "folderBasic", "DIRBase", "DirBuilder", "directorySet", " directoryBottom", "dirBuilder", "DirBottom", " directoryBase", "pathbase", "directorybase", "DIRBottom", "dirbase", "pathBas", "irbase", "folderBase", "directoryBase", "pathBase", "directoryBas", "directoryBasic", "pkgSet", "pkgBase", "irBas", "pkgBas", "pkgbase", " directoryBas", "irBase", "folderbase", "dirBottom", "DIRBuilder", "DirBas"], "packageDir": [" packageFolder", " packageDist", "podDist", "pkgDir", "pkgRel", "podDef", " packagePath", "podD", "installDir", "packageDist", "pkgPath", "moduleFolder", " packageD", "podDir", "installDef", " packageRel", "moduleDir", "pkgFolder", "moduleDef", "packagePath", "installD", "packageRel", "moduleRel", "packageD", " packageDef", "packageFolder", "modulePath", "installDist", "pkgDef", "packageDef"], "created": ["creator", "successful", "creat", "mounted", "arted", "forced", "activated", "existent", "TED", "joined", "creation", "started", "founded", "called", "ced", "ready", "registered", "generated", "provided", "developed", "raised", "confirmed", " started", "recorded", "given", "create", "allowed", "released", "associated", "printed", "present", "installed", "reported", "Created", "checked", " generated", "filled", "defined", "made", "loaded", "locked", "added", "produced"], "currentPath": ["currentlyCh", "currentPoint", "recentName", "currentCh", " currentName", "CurrentCh", "currentlyPath", "currentFile", "CurrentName", "CurrentPoint", "currentlyName", " currentPoint", "currentParent", " currentFile", "recentPath", "recentParent", "CurrentParent", "currentName", " currentParent", "recentPoint", "CurrentPath", " currentCh", "currentlyFile", "CurrentFile"], "i": ["info", "m", "I", "oi", "y", "f", "me", "init", "ie", "them", "index", "cgi", "u", "gi", "j", "o", "pi", "it", "di", "ind", "zi", "ai", "q", "bi", "li", "key", "status", "iii", "major", "go", "im", "in", "phi", "ii", "mu", "qi", "my", "ti", "batch", "ini", "ski", "hi", "this", "v", "multi", "iy", "uri", "iu", "ip", "cli", "ij", "ki", "xi", "ei", "ji", "os", "iq", "ci", "mi", "ui", "id", "p", "ic", "g", "ex", "exp", "si", "jj", "ri", "slice", "sim", "ix", "ami", "yi", "chain", "ity"], "file": ["info", "row", "File", "ile", "FILE", "link", "dir", "table", "handler", "disk", "rule", "path", "h", "base", "parent", "name", "buffer", "port", "resource", "p", "l", "log", "f", "io", "sf", "fo", "play", "source", "set", "child", "local", "page", "template", "body", "le", "db", "pool", "comment", "header", "format", "type", "handle", "et"], "fos": ["Fo", "foes", "Fos", " foes", "ffo", "fOS", "sfos", "woses", "flos", "oow", "Foes", "wos", "floes", "flo", "ffoes", "woss", "floses", "floss", "fo", " fo", "sfOS", "fow", "Foss", " foses", "fbow", "oaos", "flaos", "sfaos", "fbos", "faos", " foss", " fOS", "ffos", "oos", "ffaos", "Faos", "foss", "foses", "woes", " fow", "fbo", "sfoss", " faos", "fbaos", "oo", "FOS"], "fileSrc": ["fileErc", "jobSri", " fileInsource", "fileSrl", "fileSRC", "fileSource", "fileInsource", "fileInssrc", "fileDci", "jobSrl", " fileSsrc", "fileSci", "jobNri", "fileInsrc", "fileEri", "fileSsrc", "fileEci", "fileNci", "fileDri", "jobNrc", "jobSci", "fileInRC", " fileInsrc", "fileNrl", " fileInssrc", "fileNrc", " fileInsRC", "fileDsrc", "fileNri", "fileDrc", "jobSrc", "fileInsRC", "jobNrl", " fileSource", "fileDrl", "fileInrc", "fileDource", "fileDRC", "jobNci", "fileSri", " fileSRC", "fileErl", "fileInource"], "fileDst": ["fileSpl", "fileSlt", "fileDcr", "FileDld", "fileNcr", "FileDnd", "fileScr", "fileDld", "fileDnd", "filednd", "FileDpl", "FileScr", "fileSot", "fileDpl", "FileDot", "fileDot", "FileSot", "fileNot", "fileDlt", "filedld", "FileDcr", "fileWpl", "fileSnd", "fileNnd", "FileDlt", "filedcr", "FileSpl", "FileSld", "fileNst", "fileWot", "filedst", "FileSst", "fileNpl", "fileWlt", "fileWst", "fileNlt", "fileSld", "FileSlt", "FileDst", "fileSst", "fileNld", "FileSnd"], "reader": ["rot", "row", "read", "ocker", "handler", "rc", "rar", "upper", "ner", "driver", "stream", "roller", "rer", "book", "iterator", "oder", "buffer", "context", "er", "resource", "runner", "readable", "r", "rl", "controller", "ader", "iter", "Reader", "ro", "rx", "dr", "inner", "Larry", "ri", "query", "review", "actor", "reading", "parser", "ler", "entry", "loader", "author", "rr"], "writer": ["editor", "adder", "creator", "storage", "later", "w", "read", "table", "handler", "variable", "document", "wright", "driver", "stream", "worker", "maker", "store", "iterator", "client", "buffer", "runner", "riter", "flush", "print", "wrapper", "writing", "report", "write", "service", "window", "console", "function", "test", "user", "order", "iter", "Reader", "caster", "operator", "writers", "word", "server", "wire", "player", "outer", "query", "walker", "draw", "manager", "ter", "Writer", "println", "parser", "format", "loader", "entry", "liner", "browser", "builder"], "line": ["record", "LINE", "row", "detail", "column", "link", "sample", "rule", "eline", "range", "inline", "block", "ole", "valid", "cell", "message", "Line", "sequence", "port", "l", "print", "nl", "kin", "number", "source", "lined", "date", "code", "node", "ln", "pe", "user", "stroke", "entity", "lin", "page", "string", "style", "word", "continue", "edge", "point", "le", "frame", "comment", "header", "entry", "ine", "label", "text", "chain", "liner"]}}
{"id1": "4686922", "id2": "16388708", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResources2Files", "extractResourceTofile", "extractResourceAsStream", "extractResourceFromFile", "extractResourceFromFiles", "extractResourceToFiles", "extractResource2Files", "extractResource2Stream", "extractResourceAsFiles", "extractResourceFromfile", "extractResources2File", "extractResourceToStream", "extractResources2Stream", "extractResourcesToFile", "extractResource2File", "extractResourcesToFiles", "extractResourcesToStream", "extractResourceAsFile", "extractResourceFromStream", "extractResources2file", "extractResource2file", "extractResourceAsfile", "extractResourcesTofile"], "resourcePath": ["templateIn", "attributePath", " resourcepath", "templateName", "templatePath", " resourceIn", "uriUrl", "resourceName", "resourceLocation", "Resourcepath", "attributeLocation", "ResourceIn", "ResourcePath", "uriPath", "attributeUrl", "ResourceName", "uriName", "resourcepath", "templatepath", "resourceUrl", "attributeName", "uriLocation", "resourceIn", "ResourceLocation", "ResourceUrl", " resourceName"], "dest": ["src", "null", "orig", "w", "Dest", "opt", "cont", "end", "desc", "trans", "mem", "parent", "home", "sp", "decl", "coord", "this", "rest", "to", "temp", "dist", "source", "output", "good", "cat", "gov", "etc", "origin", "dat", "img", "tmp", "target", "nom", "lit", "des", "loc", "self", "comb", "prop", "result", "dir"], "in": ["gin", "m", "re", " din", "mc", "mi", "up", "cin", "it", "on", "raw", "or", "none", "ini", "inf", "inn", "ind", "id", "resource", "ins", "l", "rin", "f", "r", "inc", "al", "source", "ln", "no", "IN", "from", "iter", "local", "init", "isin", "bin", "inner", "all", "con", "input", "conf", "sin", "din", "i", "inside", "file", "is", "ne", "In"], "out": ["os", "cn", "null", "t", "note", "w", "exit", "b", "ot", "ch", "o", "aos", "na", "it", "on", "client", "v", "writer", "can", "obj", "to", "outs", "print", "f", "io", "stable", "cache", "write", "n", "res", "no", "output", "Out", "en", "inner", "con", "again", "nt", "conv", "tmp", "outer", "ou", "oss", "i", "at", "sys", "pool", " Out", "OUT", "co", "ne", "cos", "col", "net"]}}
{"id1": "17583193", "id2": "8747840", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"populateRecord": ["populaterecord", "populateRec", "populatesData", "populatesrecord", " populatesRec", "populatesRecord", "populatedRec", "populatesRec", " populaterecord", "populatedData", "popupdaterecord", "popupdateRec", " populateData", "populatedRecord", " populatesrecord", " populateRec", "populateData", " populatesRecord", "populatedrecord", "popupdateData", " populatesData", "popupdateRecord"], "attrIDs": ["attrEMS", "adjUES", "adjIDs", "rmIDs", "aaaIDs", "attrLS", "permIDs", "immID", "rmIDS", "arrIDS", "attributeFiles", "addrKids", "attID", "immIDs", "attFiles", "sortKids", "errUES", "aaaLS", "attIDs", "cmpIDS", "sortids", "rmById", "cmpIDs", "attById", "permID", "filterids", "attIDS", "attrById", "attFS", "attributeKids", "attributeIDS", "immEMS", "filterIDs", "urgIDs", "permIDS", "attributeID", "attrUES", "attributeById", "addrUES", "attributeFS", "urgENTS", "errIDS", "permFS", "addrIDs", "arrKids", "filterKids", "immIDS", "arrIDs", "urgIDS", "attEMS", "attrIDS", "urgLS", "filterIDS", "aaaENTS", "attrENTS", "attrID", "sortFiles", "sortID", "arrids", "attributeids", "errIDs", "rmID", "attributeENTS", "addrids", "attrFS", "adjIDS", "attrFiles", "attrids", "addrIDS", "attributeEMS", "attrKids", "attributeIDs", "attributeLS", "aaaIDS", "sortIDS"], "i": ["info", "m", "err", "c", "iti", "us", "I", "e", "y", "f", "io", "x", "ori", "me", "init", "ie", "ik", "index", "eu", "d", "u", "ia", "gi", "o", "pi", "it", "di", "ind", "zi", "er", "print", "ai", "\u0438", "q", "bi", "li", "status", "ir", "im", "z", "in", "phi", "ii", "qi", "my", "ti", "ini", "hi", "list", "v", "multi", "uri", "n", "iu", "iter", "ip", "cli", "ij", "ki", "xi", "is", "ei", "ji", "iq", "ci", "mi", "h", "base", "wi", "parent", "ui", "name", "p", "ic", "l", "g", "ni", "si", "ri", "sim", "ix", "ami", "ims", "chain", "ity", "any"], "sortIDs": ["sortLS", "sortUES", "SortLS", "successDOS", "attrEMS", "saveIDS", "SortIDS", "ortDocuments", "SortIDs", " sortIDS", "servID", "ortIDS", "attrLS", "parseIDS", "saveMS", "ortDetails", "shareDOS", "servMembers", "sortKids", "syncIDS", "saveResults", " sortKids", "servIDs", "sortDetails", " sortIDES", "sortids", "SortMembers", "altKids", "sortDOS", "altEMS", " sortTags", "filterDocuments", " sortBs", "sortEMS", "ortBs", "sortMS", "parseIDs", "successIDs", "altIDS", "sortMembers", "updateEMS", "successTags", "altIDs", "servResults", "saveLS", "servensions", "servTags", "attrMS", "orderIDs", "servFiles", "saveIDs", "filterIDs", "saveIDES", "SortEMS", "sortVs", "ortIDs", "ordIDs", "updateIDS", " sortID", "orderDOS", "sortBs", "sortensions", " sortDetails", " sortVs", " sortFiles", "successKids", "altBytes", "saveKids", " sortBS", "sortBytes", "servids", " sortResults", "ortResults", "ortID", "ordids", "sortResults", "successEMS", "sortIDES", " sortensions", "relationMembers", "relationIDS", "orderUES", " sortMS", " sortMembers", "sortTags", "updateIDs", "saveIE", "filterKids", " sortBytes", "shareKids", "successUES", "syncIDs", "syncBytes", "shareIDs", "servDetails", "attrIDS", "orderKids", "filterIDS", "sortDocuments", "syncEMS", " sortids", "shareUES", "ordIDS", "SortIE", "servEMS", "attrID", "sortFiles", "parseIDES", " sortEMS", "successIDES", "sortID", "filterBs", "updateMembers", "sortBS", " sortDocuments", "successIDS", "attrFiles", "attrids", "servIDS", "servKids", "sortIE", "ordEMS", "ortVs", "relationensions", "altIDES", "filterIDES", "attrKids", "attrIE", "servVs", "servBS", "ortids", "sortIDS", "parseKids", "relationIDs", "ortBS"], "j": ["ji", "m", "err", "z", "other", "d", "b", "c", "jo", "it", "e", "ind", "adj", "kj", "y", "v", "obj", "jit", "er", "l", "bo", "k", "by", "r", "beta", "J", "out", "q", "x", "jet", "ja", "js", "oj", "g", "rel", "n", "je", "uj", "jj", "ij", "jp", "dj", "jl", "tr", "br", "next", "json", "pr", "ix", "fr", "el", "jac", "aj", "job", "jc", "bj", "jump", "pt"], "temp": ["porary", "tt", "tim", "perm", "mod", "tc", "t", "orig", "read", "length", "alt", "variable", "fake", " tmp", "EMP", "mem", "buffer", "emp", " Temp", "term", "pre", "test", "txt", "set", "unt", "template", "current", "tmp", "prime", "cum", "rem", "ptr", "wait", "tm", "tty", "tem", "mp", "Temp", "thread"]}}
{"id1": "20091126", "id2": "14317425", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "Transfer", "upload", "Copy", "open", "get", "delete", "store", "cp", "system", "y", "map", "to", "call", "io", "sync", "write", "Cop", "cat", "create", "move", "save", "transfer", "clone", "file", " Copy", "download", "load"], "in": ["gin", "info", "b", " din", "old", "up", "cin", "ini", "inf", "inn", "ind", "id", "ain", "ins", "l", "rin", "io", "r", "inc", "source", "n", " input", "IN", "from", "mm", "init", "en", "inner", "isin", "ck", "input", "din", "i", "el", "file", "In"], "out": ["os", "null", "t", "err", "w", "_", "b", "gt", "c", "end", "ot", "ch", "o", "it", "e", "or", " it", "v", "y", "p", "s", "to", "l", "log", "outs", "io", "write", "x", "one", "n", "res", "output", "ex", "Out", "nt", "tmp", " os", "ou", "at", "as", " output", "bytes", "file", "OUT", "co", "msg", "channel", "self", "result", "net"], "inChannel": ["inchannel", "inPanel", "incChuck", "outBlock", "ginPanel", "innChan", "INChannel", " inSection", "inListener", "binCommand", "binSection", "inCommand", "InChannel", "cinChannel", "INListener", "incChain", "outCommand", "insideSection", "cinchannel", "cinBlock", "innConnection", "inRow", "inBlock", " inchannel", "ginChain", "cinCommand", " inListener", "insideChannel", "ginChuck", "inSection", " inChan", "incChannel", " inConnection", "INChan", "binChain", "binRow", "conChannel", "INConnection", "inChain", "incPanel", "binPanel", " inCommand", "innchannel", "outchannel", "inChuck", "conListener", "conChan", "conConnection", "binChuck", "insideCommand", "InChan", "inChan", "Inchannel", "innChannel", " inRow", "inConnection", " inBlock", "InConnection", "insideRow", "ginChannel", "binChannel"], "outChannel": ["outCh", "cmdChan", "inchannel", "OUTSlot", "outputManager", "outGate", "outSlot", "outMany", "cosChannel", "OutCh", "OUTChan", "OutChan", "modulePassword", " outPassword", "Outchannel", "cosUser", "cmdGate", "cmdChannel", "moduleChan", " outCh", "cosChan", "skyGate", "moduleManager", "outputChan", "outUser", "cmdMany", "OUTUser", " outManager", "outManager", "skyMany", "inCh", "cosSlot", "moduleChannel", " outMany", "outchannel", "OUTChannel", "skyChan", "outputChannel", "inSlot", "inUser", " outChan", "skyChannel", "outChan", " outchannel", "outPassword", "outputPassword", "inChan", "OutChannel", " outGate"]}}
{"id1": "4686922", "id2": "6558022", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResources2Files", "extractResourceTofile", "extractResourceAsStream", "extractResourceFromFile", "extractResourceFromFiles", "extractResourceToFiles", "extractResource2Files", "extractResource2Stream", "extractResourceAsFiles", "extractResourceFromfile", "extractResources2File", "extractResourceToStream", "extractResources2Stream", "extractResourcesToFile", "extractResource2File", "extractResourcesToFiles", "extractResourcesToStream", "extractResourceAsFile", "extractResourceFromStream", "extractResources2file", "extractResource2file", "extractResourceAsfile", "extractResourcesTofile"], "resourcePath": ["templateIn", "attributePath", " resourcepath", "templateName", "templatePath", " resourceIn", "uriUrl", "resourceName", "resourceLocation", "Resourcepath", "attributeLocation", "ResourceIn", "ResourcePath", "uriPath", "attributeUrl", "ResourceName", "uriName", "resourcepath", "templatepath", "resourceUrl", "attributeName", "uriLocation", "resourceIn", "ResourceLocation", "ResourceUrl", " resourceName"], "dest": ["src", "null", "orig", "w", "Dest", "opt", "cont", "end", "desc", "trans", "mem", "parent", "home", "sp", "decl", "coord", "this", "rest", "to", "temp", "dist", "source", "output", "good", "cat", "gov", "etc", "origin", "dat", "img", "tmp", "target", "nom", "lit", "des", "loc", "self", "comb", "prop", "result", "dir"], "in": ["gin", "m", "re", " din", "mc", "mi", "up", "cin", "it", "on", "raw", "or", "none", "ini", "inf", "inn", "ind", "id", "resource", "ins", "l", "rin", "f", "r", "inc", "al", "source", "ln", "no", "IN", "from", "iter", "local", "init", "isin", "bin", "inner", "all", "con", "input", "conf", "sin", "din", "i", "inside", "file", "is", "ne", "In"], "out": ["os", "cn", "null", "t", "note", "w", "exit", "b", "ot", "ch", "o", "aos", "na", "it", "on", "client", "v", "writer", "can", "obj", "to", "outs", "print", "f", "io", "stable", "cache", "write", "n", "res", "no", "output", "Out", "en", "inner", "con", "again", "nt", "conv", "tmp", "outer", "ou", "oss", "i", "at", "sys", "pool", " Out", "OUT", "co", "ne", "cos", "col", "net"]}}
{"id1": "20920051", "id2": "1598693", "code1": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"copyTo": [" copyPhoto", "copyOver", "copyFiles", "opyDir", "transferTo", "copyDir", "opyOver", "copyPhoto", "opyPhoto", " copyFile", "moveDir", "opyTo", "movePhoto", " copyOver", "transferFrom", " copyDir", "CopyFrom", "transferFile", " copyFrom", "transferFiles", " copyFiles", "CopyFiles", "copyFile", "CopyFile", "CopyTo", "copyFrom", "moveTo", "moveOver"], "source": ["src", "details", "SOURCE", "empty", "get", "se", "none", "part", "sf", "from", "init", "ie", "input", "oss", "subject", "shell", "sql", "note", "sample", "old", "raw", "unit", "service", "scan", "select", "site", "visible", "search", "style", "template", "sin", "query", "config", "Source", "status", "component", "secure", "scope", "sort", "flat", "store", "use", "spec", "sl", "iter", "file", "ace", "null", "base", "parent", "sp", "name", "id", "image", "resource", "s", "seed", "ource", "local", "start", "copy", "origin", "missing", "original", "target", "pse", "size", "entry"], "dest": ["tom", "src", "null", "w", "orig", "d", "Dest", "opt", "end", "path", "ref", "it", "desc", "trans", "parent", "name", "dc", "this", "port", "rest", "master", "to", "deg", "doc", "out", "dist", "folder", "pro", "test", "st", "good", "txt", "dat", "origin", "dev", "result", "nt", "tmp", "target", "nom", "des", "loc", "self", "est", "dir", "del"], "temp": ["make", "porary", "mod", "pl", " temporary", "null", "t", "orig", "w", "zip", "alt", "empty", "fake", "mk", "path", "tar", " tmp", "EMP", "parent", "cp", "buffer", "p", "mt", "tab", "out", "emp", " Temp", "stem", "em", "test", "txt", "mm", "unt", "local", "dat", "template", "Tem", "tmp", "rem", "tm", "tem", "mp", "Temp", "por", "rm", "pt"], "sel": ["pl", "nav", "sc", "zh", " sl", "ael", "selected", "kel", "syn", "ls", "El", "se", "sen", "sels", "ml", "ser", "cel", "ial", "cell", "selection", "sl", " lic", "nl", "ele", "fl", "rl", "cl", "sol", "lv", "select", "Se", "sv", "nel", "Sel", "lf", "kl", "le", "rol", "elect", "el", "mil", "fol", "so", "sil", "del"], "tempDest": ["mmLoc", "mmTemp", "poraryDe", " temporaryTemp", "tempDec", " temporarydest", "tempDir", "poraryDest", "poraryTemp", "poraryDec", "tempNeg", "temdest", "tempTemp", " tempTemp", " tempDir", "ptNeg", " tempdest", "poraryLoc", "temDe", " temporaryDest", "destLoc", "destTemp", " tempDe", "destDec", "destDest", "porarydest", "mmDec", "tempLoc", " tempNeg", "poraryDir", "temDir", "ptTemp", "mmDest", "ptdest", " temporaryNeg", "tempDe", "temDest", "tempdest", "ptDest"], "sourceCh": ["seedChan", " sourceCor", " sourcech", " sourceCH", "startComp", "srcComp", "srcch", "srcCol", "ourceCh", "startCH", "statusCol", "sourceCr", "srcColl", "startCol", "ourceComp", "samplech", "sampleComp", "srcCH", "ourceCH", "sourceCor", "sourceComp", "sourceColl", "srcCh", "ourceChan", "statusCh", "sourceCH", " sourceCol", "srcCor", "seedCh", " sourceCr", " sourceComp", "ourceColl", "statusCH", "srcChan", "sampleCor", "statusCr", "sourceCol", "sampleCh", "sourcech", "startCh", "seedCol", "ourceCr", "ourceCol", "sourceChan", "seedColl"], "destCh": ["destCl", "destC", "tempCl", "usrChan", " destChar", "targetCh", "estCl", "tempCol", " destC", "targetChan", "usrChar", "destChan", " destDest", "restChan", "targetC", "tempChan", " destCl", "tempC", "destDest", "destCol", "restC", " destCol", "targetChar", "tempCh", "usrCh", "estC", "estDest", "destChar", "restCol", " destChan", "usrC", "restCh", "estCh"]}}
{"id1": "18891988", "id2": "3806532", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["selectString", "getfile", "GetFile", "createFilename", "Getfile", "GetString", "getString", "selectFilename", "selectfile", "createString", "GetFilename", "selectFile", "createfile", "createFile", "getFilename"], "serviceName": [" serviceNames", "ServiceNames", "serviceType", "serverType", "libraryName", "serverName", " serviceType", "ServiceCode", "serviceFamily", " serviceCode", " serviceFamily", "libraryFamily", "serviceNames", "libraryNames", "ServiceType", "ServiceName", "serverCode", "ServiceFamily", "serviceCode", "libraryType"], "wsdlLocation": ["wslLoc", "awsdLocation", "wsolURL", "wsolLoc", "wsDLlocation", "awsdlocation", "wdlPath", "wslLocation", "wssdlocation", "wsdLoc", "wssdPath", "awsdlLoc", "awsollocation", "awsdllocation", "wsdlocation", "wdlLoc", "wsollocation", "awsdLoc", "awsolURL", "awsdlURL", "wsdlFolder", "wslPath", "wlLocation", "wsDLFolder", "wdlFolder", "wsDLLocation", "awsolLoc", "wsolLocation", "wlFolder", "awsdlLocation", "wssdLoc", "wsDLLoc", "wssdLocation", "wsdlURL", "wsdllocation", "awsolLocation", "wsdlPath", "wdlLocation", "wslFolder", "wsDLURL", "wlLoc", "wlPath", "wssdFolder", "wsDLPath", "wsdURL", "wsdLocation", "awsdURL", "wssdURL", "wsdlLoc"], "endpoint": ["beginpoint", "beginword", "startword", "bindpoint", "endpoints", "idline", "startpoint", "endPoint", "endport", "idpoints", "beginpoints", " endpoints", "EndPoint", "endline", " endline", "Endpoint", "startPoint", "Endpoints", " endPoint", "idPoint", "bindPoint", "Endword", " endport", "endword", "idpoint", "Endport", "bindpoints", "beginPoint", "startline", "startpoints", "bindport"], "fileLocation": ["filelocation", "Filelocation", "filePosition", " filelocation", "fileLoc", "FileLocation", " fileLoc", "FileLoc", "documentLoc", " filePosition", "documentPosition", "documentlocation", "FilePosition", "documentLocation"], "tempDir": [" tempDirectory", " tempdir", "tmpdir", "tmpPath", "tempPath", "TempFolder", " tempPath", "tempDirectory", "tmpUrl", "tempdir", "tmpFolder", "Tempdir", "tempFolder", "TempDirectory", " tempFolder", "TempDir", "tmpDirectory", "TempPath", " tempUrl", "TempUrl", "tempUrl", "tmpDir"], "url": ["ret", "pl", "m", "re", "bel", "ur", "http", "link", "https", "un", "il", "github", "ls", "up", "base", "gl", "socket", "cp", "build", "l", "uri", "f", "sl", "r", "nl", "service", "conn", "str", "window", "rel", "mount", "location", "cr", "ssl", "char", "li", "Url", "mail", "web", "ul", "sur", "ll", "loc", "job", "dl", "open", "cert", "URL", "browser", "ctrl"], "WSDLFile": ["WSDLSFile", "WHDDLFILE", "WSDLSfile", "WIDLType", "WIDDLString", "WSDLLFilename", "WHDLfile", "WNDLfile", "WHDDLfile", "WSDLType", "WSDELFILE", "WHDDLFile", "WSDELFilename", "WIDLfile", "WSDLLString", "WSDLLFile", "WSDMLFILE", "WSDMLfile", "WSDQLfile", "WSDDLType", "WSDDLString", "WIDLFile", "WSDLLFILE", "WSDELFile", "WSDDLfile", "WSDDLFile", "WNDDLFilename", "WSDLLfile", "WSDLSString", "WSDLString", "WSDELfile", "WHDLFile", "WNDLFilename", "WSDLFILE", "WNDDLFILE", "WSDLFilename", "WSDQLFile", "WSDDLFILE", "WSDLSType", "WSDLLType", "WNDLFile", "WHDLFILE", "WNDLFILE", "WNDDLfile", "WSDLfile", "WIDDLFile", "WSDQLFILE", "WSDDLFilename", "WNDDLFile", "WIDDLfile", "WIDLString", "WIDDLType", "WSDMLFile"], "tmpWSDLFile": ["tmpWSDLLFilename", "tmpWIDDLfile", "tmpWSDLDFilename", "tmpWSDLfile", "tmpWSDLDfile", "tmpWSDLDFile", "tmpWSDLFiles", "tmpWIDLFilename", "tmpWIDDLFILE", "tmpWNDLFile", "tmpWIDLFile", "tmpWIDDLFilename", "tmpWSDLFILE", "tmpWSDDLfile", "tmpWNDDLfile", "tmpWSDDLFILE", "tmpWSDLLFILE", "tmpWIDLFILE", "tmpWNDLfile", "tmpWIDDLFile", "tmpWSDlFilename", "tmpWSDLLfile", "tmpWSDlFile", "tmpWSDDLFiles", "tmpWSDLLFiles", "tmpWNDDLFilename", "tmpWSDLLFile", "tmpWSDlFiles", "tmpWSDDLFile", "tmpWNDDLFiles", "tmpWNDLFiles", "tmpWIDLfile", "tmpWSDLFilename", "tmpWSDlfile", "tmpWNDLFilename", "tmpWNDDLFile", "tmpWSDDLFilename", "tmpWSDLDFILE"], "inputFile": [" inputFILE", "InputDo", " inputFiles", "tmpPlace", "inputPath", " inputPath", "tmpSourceFile", "inputFILE", "indexFILE", " inputfile", "clientFile", " inputDo", "inputSourceFile", "Inputfile", "inputFiles", "clientFILE", " inputSourceFile", "inDo", "clientPath", "tmpStream", "intfile", "interfaceSourceFile", "interfacePlace", "indexfile", "inFile", "errorFILE", "InputFile", "InputFiles", "infile", "outputFile", "inPath", "inputDo", "indexStream", "tmpfile", "interfaceFile", " inputPlace", "interfacefile", "clientFiles", "outputfile", "intFiles", "outputFILE", "outputStream", "indexFile", "inputfile", "intFile", "errorStream", "InputStream", "intFILE", "InputPath", "inputPlace", "tmpFILE", "InputFILE", "errorFile", "inputStream", "errorfile"], "tmpFile": ["inputFilename", "mpfile", "tempFILE", "tmpPath", " tmpFiles", " tmpfile", "tempPath", "empFilename", "empFILE", "tempFilename", "inputFILE", " tmpPath", "empFile", "mpFile", "tmpFiles", "tempFiles", "tempfile", "tempFile", "mpFiles", "tmpFilename", "tmpfile", "mpPath", "empfile", "inputfile", "tmpFILE"], "in": ["t", "c", "cont", "ch", "o", "mi", "stream", "cin", "it", "ini", "inf", "inn", "ind", "id", "client", "ain", "ins", "ic", "rin", "io", "r", "ai", "conn", "inc", "source", "n", "ln", "IN", "from", "init", "en", "bin", "inner", "isin", "input", "ri", "sin", "din", "inv", "file", "is", "ar", "In"], "out": ["os", "null", "t", "w", "c", "ch", "o", "aos", "on", "client", "connection", "buffer", "this", "writer", "can", "obj", "to", "outs", "log", "group", "io", "by", "conn", "write", "cache", "ao", "n", "output", "ex", "Out", "en", "all", "conf", "outer", "tmp", "conv", "ou", "inv", "oss", "at", "pool", "OU", "cm", "sys", "auto", "file", "OUT", "co", "lock", "ne", "we", "net"], "con": ["nc", "cn", "re", "tc", "fn", "cal", "c", "un", "ch", "mc", "ws", "acon", "cone", "cin", "func", "soc", "Con", "cp", "connection", "ain", "can", "login", "conn", "cur", "Conn", "ln", "cf", "fc", "win", "conf", "sec", "exc", "conv", "com", "CON", "num", "cm", "connect", "co", "ran", "const", "cons", "cos"], "fileLength": ["fileLen", "ileDuration", "channelSize", " fileLen", "fileFontSize", "ileLength", "objectSize", " fileSize", "channelLength", "ileLen", " fileDuration", "fileDuration", "FILELen", "fileSize", "objectFontSize", "FILEDuration", "channelFontSize", "channelDuration", " fileFontSize", "FILELength", "objectLength", "ileSize", "objectDuration", "FILESize"], "channelIn": ["chanIn", "channelSet", " channeledIn", "channeledIn", "ChannelIN", "ChannelOut", "consoleIn", "ChanneledIn", "chanSet", " channelIN", "clientIN", "chanOut", " channelin", "clientSet", "consoleOut", "clientin", "Channelin", "consoleIN", "consoleedIn", "channelIN", "clientOut", "ChannelIn", "channelin", "ChannelSet", "clientIn", "chanIN"], "channelOut": ["courseIn", "consoleout", "chanConn", "chanIn", "courseOUT", "ChannelOut", "chanout", "Channelout", " channelout", "chanOut", "channelOUT", "consoleOut", " channelConn", "channelConn", "ChannelOUT", "courseOut", "consoleOUT", "ChannelConn", "courseout", "channelout", "ChannelIn", "consoleIn", " channelOUT"], "tmpDocument": ["tpMedia", "tmDoc", "tempDocument", " tmpMedia", "tpDocument", "mkdocument", "tmdocument", "cpDocument", "mpDoc", "npMedia", "tpDocuments", " tmpdocument", "npDocument", "tmpDocuments", " tmpDoc", "tmpdocument", "mpDocument", "tempdocument", "tmpMedia", "cpDoc", "mkDoc", "tpFile", "mkDocument", "npFile", "tempDoc", "cpdocument", "tmDocument", "npDocuments", "tmpDoc", " tmpDocuments", "mpdocument"], "nl1": ["rnOne", "ln3", "NL2", "nl9", "sol1", "ln01", "nrOne", "pelOne", "nelOne", "rn6", "ln0", "nel3", "NL1", "rn1", "rn3", "nl6", "nr1", "sol2", "ln1", "pel1", "nr01", "ln2", "pel01", "nlOne", "NL0", "nl2", "lnOne", "nl0", "sol9", "NL9", "nel6", "sol0", "nl01", "nel1", "ln6", "nl3", "ln9"], "i": ["info", "ji", "m", "ms", "ci", "u", "j", "gi", "ii", "mu", "qi", "I", "us", "span", "mi", "key", "a", "ti", "o", "pi", "it", "di", "ini", "ui", "hi", "id", "y", "v", "multi", "ic", "k", "io", "ai", "\u0438", "x", "n", "ori", "me", "bi", "ip", "cli", "init", "si", "ie", "ij", "ri", "index", "sim", "li", "ix", "xi", "ami", "is", "ims"], "node1": ["Node2", "nodeOne", "componentOne", "node2", "node0", "ode1", "component1", "n1", "nOne", "node001", "layerOne", "Node001", "node91", "layer1", "component2", " node001", "ode0", " nodeOne", "n0", " node91", "layer91", "layer0", "NodeOne", "ode001", "ode2", "n91", " node2", " node0", "Node1", "Node0", "component0"], "tmpOut": ["mpout", "cmpIn", "npIn", "tempIn", "TempOUT", "empout", " tmpObj", "mpIn", "cmpOut", "tmpIn", "npOut", "mpOut", "npObj", "tempOUT", "tmpObj", "TempOut", "tempout", "TempObj", " tmpOUT", "tmpIs", "mpObj", "tempObj", "tempIs", " tmpIn", "npout", " tmpout", "empOut", "empIs", "TempIn", "tmpOUT", "tmpout", " tmpIs", "tempOut", "cmpout"], "retVal": ["retTrue", "returnval", " retval", "RetTrue", " retTrue", " retValue", "Retval", "RetVal", "retval", "RetValue", "returnValue", "returnTrue", "returnVal", "retValue"]}}
{"id1": "21979462", "id2": "14231545", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadurltoJSON", " downloadURLoBytes", " downloadURLoJSON", " downloadURL2String", " downloadURLtoBytes", " downloadurloBytes", " downloadURLToJSON", " downloadurloText", " downloadurloString", " downloadURL2Text", " downloadURLToBytes", " downloadURLToText", " downloadurloJSON", " downloadURLtoText", " downloadURLoText", " downloadurltoText", " downloadurltoString", " downloadURLtoJSON", " downloadurltoBytes", " downloadURL2Bytes", " downloadURL2JSON", " downloadURLToString", " downloadURLoString"], "url": ["ret", "domain", "bel", "ur", "http", "link", "run", "un", "ref", "ls", "base", "gl", "address", "id", "name", "resource", "uri", "l", "log", "sl", "uu", "rect", "mount", "location", "ssl", "all", "char", "Url", "web", "mail", "ul", "file", "ll", "job", "dl", "URL", "browser"], "in": ["gin", "info", "re", "read", "thin", "oin", "mc", "up", "cin", "it", "on", "or", "check", "inf", "inn", "ind", "ill", "mn", "ins", "er", "ic", "io", "reader", "by", "inc", "ai", "out", "al", "IN", "from", "copy", "inner", "isin", "bin", "all", "con", "input", "conf", "again", "din", "sum", "ma", "i", "is", "and", "In"], "sb": ["bt", "bg", "bh", "wb", "rob", "gc", "bs", "b", "bn", "erb", "ab", "bf", "kb", "bb", "sq", "sp", "ib", "pb", "bd", "sam", "sf", "mb", "gb", "sd", "lp", "ub", "eb", "pa", "sg", "ssl", "SB", "zb", "rb", "sa", "bp", "gob", "nb", "db", "cb", "sk", "xb", "lb", "bis", "bsp", "bj"], "str": ["m", "re", "t", "err", "exec", "j", "b", "cont", "syn", "ch", "ls", "expr", "Str", "gr", "block", "part", "del", "sp", "list", "p", "obj", "s", "l", "print", "req", "sl", "r", "cur", "source", "n", "st", "bl", "txt", "set", "iter", "cat", "dat", "sts", "string", "comm", "pt", "dr", "def", "char", "tr", "br", "div", "next", "comp", "i", "fr", "comment", "msg", "vol", "text", "chain", "bc", "STR", "arr"]}}
{"id1": "11840277", "id2": "5620792", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"clearTables": ["clearLables", "cleanLates", "clearSates", "clearTells", "resetTashes", "clearSTable", "cleanTates", "clearContates", "cleartables", "clearSables", "clearDates", "cleanTables", "clearTableashes", "clearDables", "clearTableTable", "clearTates", "clearSashes", "clearTashes", "clearContables", "cleanLiles", "resetTableTable", "clearDiles", "clearTableables", "resetTates", "cleartashes", "clearContells", "clearTiles", "cleartates", "cleanTells", "clearLates", "clearLiles", "clearTableates", "resetTableables", "cleanLells", "cleanLables", "clearTTable", "resetTableates", "cleartTable", "clearContiles", "resetTables", "cleanTiles", "clearDells", "resetTTable", "clearLells", "resetTableashes"], "conn": ["cn", "oc", "resp", "gate", "c", "coll", "ws", "yes", "bo", "cur", "Conn", "org", "user", "die", "ctx", "en", "forge", "conf", "oss", "canon", "co", "wd", "nc", "rt", "note", "gc", "gn", "pas", "Connection", "client", "yn", "enc", "out", "act", "ds", "cb", "pool", "ont", "open", "pt", "dn", "ang", "link", "mc", "on", "cc", "ct", "pg", "cp", "ns", "ce", "connection", "obj", "iw", "n", "rel", "cf", "cmd", "comm", "cfg", "db", "connect", "gen", "addr", "ca", "tp", "exec", "close", "ch", "h", "mt", "req", "lang", "con", "nt", "com", "conv", "priv", "sys", "cons", "cert", "col"], "stmt": ["ustmg", "esttry", "estmg", "STlt", "stdpt", "startmt", "STMT", " stMT", "klMT", "strpt", "astm", "restlamm", "Stmp", "contMT", "contlt", "usemm", "restgr", "stMT", "styMT", "stymm", " stpt", "Stmt", " superstpt", "ostMT", "statgt", "Stmg", "usemt", "statMT", " stmsg", "Stmsg", "klgr", "Stgt", " stgr", " superstlamm", "stmg", "stlt", "putmt", "strm", "statmt", "estmsg", " stmg", "estMT", " stmr", "ostmm", "useMT", " stmm", "STm", "putMT", "ustmsg", "restmr", "Stmm", "STmt", "strmt", "astmr", " stm", "stlamm", "astmt", "restMT", "stm", "estmt", "startgr", "kllamm", "sttry", "Stm", " stgt", "stgr", " superstmt", "STpt", "stmm", "stdlamm", "STmp", "astMT", "contmt", "stmp", "statm", "ostmr", "restmm", "stymr", "Stlt", "startmr", "STmm", "klmt", "ustm", " stmp", "usetry", " stlamm", "Stgr", "StMT", "Stmr", "restmt", "putmsg", "putmg", "ustmt", "ostmt", "stmsg", "stmr", "stdmt", "stymt", "estmm", "stgt", "startmg", " sttry", "stpt", "strmm"]}}
{"id1": "6371589", "id2": "23620712", "code1": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"insertUser": [" insertAccount", "insertAccount", "insertPerson", " insertUsers", " insertPerson", "InsertAccount", "InsertPerson", "addAccount", "InsertUser", "insertUsers", "InsertUsers", "addUsers", "addPerson", "addUser"], "newUsers": ["newsusers", "newsVersions", " newPosts", "latestPosts", "newIDs", "_", "latestUsers", " NewPosts", "Secure", "givenusers", "givenPosts", "givenVersions", "New", "NEWStudents", "newPosts", " NewUsers", "NEWPosts", "newusers", "newVersions", "NEWUsers", "givenUsers", "newsPosts", "NEWIDs", "newStudents", "newsUsers", " NewIDs", " newVersions", "latestStudents", "latestIDs", " NewStudents", " newusers"], "pass": ["pl", "pos", "pillar", "ack", "allow", "parse", "params", "Pass", "pp", "prop", "na", "add", "pg", "pas", "use", "cross", "p", "post", "password", "skip", "conn", "res", "cat", "auth", "dr", "save", "push", "def", "conf", "miss", "par", "priv", "session", "oss", "access", "hash", "ass", "pool", "PASS", "col", "fail", "wd", "ps", "crit"], "realmPass": ["realmCat", "realmDrag", "realamPass", "realamAss", "calmPass", "Realgmpass", "realnCat", "realmsAct", "balmDrag", "balmiCat", "balmiDrag", "calmspass", "realmnCat", "realmFail", "realmsAss", "realemFail", "realimCat", "realmAss", "realnDrag", "realemAdd", "realmiPass", "realnpass", "RealgmAdd", "RealmCat", "realgmAdd", "RealgmPass", "realimAdd", "realmsAdd", "RealamAss", "realamAdd", "balmiPass", "realmAct", "RealamAdd", "RealgmFail", "RealamPass", "RealmAss", "RealmAdd", "realmiDrag", "RealmPass", "realmiCat", "realgmFail", "realrPass", "realmpass", "calmAct", "RealamCat", "realmipass", "balmipass", "realrAdd", "realrpass", "realgmPass", "realmnpass", "Realmpass", "realmnDrag", "realmAdd", "realamCat", "balmPass", "realgmpass", "realmspass", "realimPass", "realgmAct", "balmCat", "calmAdd", "calmpass", "realmnPass", "realampass", "calmsAdd", "realmsCat", "realnPass", "realamFail", "realrAct", "RealmFail", "calmsPass", "balmpass", "realimAss", "realemPass", "realempass", "realmsPass", "calmsAct"], "userDirs": ["userPathns", " userDns", "userDs", "userPaths", " userDir", "userPathirs", "userDir", "userDirns", "userDirir", "userDns", "userDirirs", " userDirns", " userDirir", "userPathir", " userDs", " userDirirs"], "iter": ["info", "hex", "train", "oper", "fer", "ci", "err", "exec", "il", "ner", "coll", "range", "iz", "ver", "it", "maker", "ser", "valid", "rer", "ind", "peer", "ill", "er", "Iter", "spec", "skip", "reader", "gener", "here", "inc", "ait", "altern", "ipper", "test", "ip", "kit", "inter", "inner", "itter", "iv", "tr", "outer", "next", "orient", "li", "i", "ptr", "ter", "iner", "el", "loop", "vis", "loc", "loader", "ator", "ir", "del"], "user": ["info", "usage", "us", "version", "part", "system", "users", "menu", "bo", "by", "confirmed", "plugin", "me", "pre", "from", "profile", "dev", "word", "char", "match", "usa", "self", "display", "author", "project", "row", "u", "per", "ver", "User", "error", "client", "post", "password", "uu", "term", "USER", "entity", "usr", "body", "query", "ter", "form", "job", "open", "status", "result", "record", "person", "creator", "other", "component", "or", "used", "check", "store", "use", "role", "account", "date", "test", "vote", "file", "item", "module", "rule", "object", "parent", "device", "message", "resource", "owner", "student", "core", "player", "comment", "entry", "contact", "volume", "time", "event", "browser"], "realm": ["chemi", "schem", "realmin", "Realm", "calmo", "palmin", "palmi", "calmi", "trm", "realc", "palm", "trl", "chem", "schemin", "schemi", " realmo", "schems", "realmo", "trc", "rall", "realmi", "Realgm", "realM", "reall", "rec", "trms", "rel", "calm", "Realmi", "Realmo", "ralm", "Realmn", "ralms", "chemn", "rems", " realgm", "palms", "ralc", "realmn", "rem", "RealM", " realmin", "cheM", "calM", "calgm", "realgm", "calmn", " realmi"], "username": ["NAME", "email", "href", "approximately", "summary", "master", "frequency", "mass", "kin", "number", "aka", "profile", "database", "gender", "json", "monitor", "subject", "filename", "attribute", "currency", "login", "password", "source", "term", "wordpress", "uid", "usr", "ame", "phone", "status", "dn", "person", "successful", "component", "batch", "displayText", "history", "mobile", "directory", "uri", "pron", "account", "unknown", "seat", "twitter", "metadata", "java", "impact", "initial", "family", "software", "month", "rue", "sudo", "utm", "journal", "url", "character", "prefix", "information", "utf", "today", "name", "sword", "owner", "method", "output", "minimum", "language", "title", "token", "instance", "network", "target", "river", "ername", "via", "latest", "localhost", "description", "platform", "uno", "human"], "ph": ["pl", "pha", "prof", "ah", "phi", "mph", "wh", "pp", "pd", "pkg", "alph", "mk", "ch", "hm", "h", " perf", "dh", "oh", "phil", "pi", "sh", "pas", " pl", "php", "eth", "p", "uth", "gh", "Ph", "fo", "iph", " ep", "th", "ih", "uph", "pal", "arch", "eh", "oth", "aph", "prot", "phy", "eph", "hp", "pr", "kh", "PH", "her", "ht", "tch", "rh", "pt"], "realms": ["realarms", "Realm", "alms", "tenents", "rens", "Realmins", "Realmes", "realns", "realmins", "alm", "tenmes", "Realarms", "Realms", "rearms", "trms", "trarms", "alents", "remes", "trns", "realmes", "remins", "alarms", "rems", "Realns", "tenms", "Realents", "tenarms", "rem", "almes", "realents", "trmins"], "realmName": ["realarmFull", "alrSpec", " realcName", "realrNames", "realmSpec", "realmoName", "almSpec", "realmoId", "realmcFull", "realmiNames", " realmNames", " realmFull", "realcNames", "realarmNames", "alrName", "almName", "realmcNames", " realcType", "realcName", " realcNames", "realcFull", "realrId", "realrName", "realmoSpec", "realmType", "realmId", " realcFull", "realmcType", "realmNames", "almId", "almNames", "realmiSpec", "realmcName", "realrSpec", "realmFull", "alrId", "realmiName", " realmType", "realmiId", "alrNames", "realcType", "realarmName", "realmoNames", "realarmType"], "psImpl": ["dsInstance", "pseImpl", "persImpl", "dsStr", "psStr", "psInstance", "psimpl", "pseimpl", "persStr", "persimpl", "pseInstance", "dsImpl", "persInstance", "dsimpl", "pseStr"], "iterator": ["Iterator", "information", "stream", "integer", "history", "values", "sequence", "runner", "wrapper", "order", "set", "inner", "operator", "instance", "current", "next", "walker", "ter", "trace", "size", "loader", "ator", "result", "vector", "collection"]}}
{"id1": "17475530", "id2": "822452", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkFromimage", "testAddLinkForImages", "testAddLinkFromPicture", "testAddLinksToImage", "testAddLinkstoPicture", "testAddLinkFromImages", "testAddLinkstoImages", "testAddLinkstoImage", "testAddLinktoImage", "testAddLinktoimage", "testAddLinkForimage", "testAddLinkstoimage", "testAddLinksToImages", "testAddLinkToimage", "testAddLinktoImages", "testAddLinkToPicture", "testAddLinkToImages", "testAddLinksToimage", "testAddLinksToPicture", "testAddLinkForPicture", "testAddLinkForImage", "testAddLinktoPicture", "testAddLinkFromImage"], "in": ["gin", "info", "m", "re", "vin", "include", "nin", " din", "mc", "o", "get", "up", "cin", "it", "on", "add", "pi", "or", "ini", "ed", "check", "inn", "ind", "sein", "v", "er", "ins", "password", "rin", "k", "by", "doc", "r", "inc", "out", "al", "source", "one", "from", "IN", "set", "ex", "init", "en", "inner", "bin", "isin", "all", "input", "din", "show", "sum", "ma", "i", "inside", "at", "file", "is", "and", "In"]}}
{"id1": "21488518", "id2": "3801655", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"createNew": ["createFresh", "CreateFresh", "dataNext", "CreateNew", "getFresh", "CreateResource", "createResource", "dataNew", "dataResource", "getNext", "CreateNext", "dataFresh", "getResource", "createNext", "getNew"], "name": ["NAME", "null", "Name", "old", "end", "path", "key", "base", "prefix", "version", "value", "part", "nm", "none", "common", "use", "address", "id", "now", "client", "normal", "resource", "ename", "password", "only", "source", "one", "action", "n", "code", "no", "local", "create", "named", "missing", "title", "string", "template", "alias", "word", "current", "lat", "body", "index", "names", "ame", "description", "file", "size", "data", "format", "time", "type", "filename", "handle", "event"], "in": ["gin", "t", "err", "vin", "b", "c", "mc", "get", "cin", "it", "inn", "ind", "p", "ins", "s", "rin", "reader", "r", "al", "source", "from", "IN", "mm", "en", "inner", "bin", "isin", "con", "input", "din", "body", "asin", "ma", "i", "mat", "xml", "file", "data", "is", "In"], "length": ["read", "total", "amount", "path", "stream", "value", "count", "message", "buffer", "sequence", "password", "content", "padding", "enc", "height", "input", "position", "Length", "body", "description", "bytes", "size", "data", "len", "max", "text", "duration", "shape"], "contentType": ["Contenttype", "ContentLength", "contentLength", "mediaTypes", "contentTypes", "contenttype", "mediaLength", "mediatype", "ContentTypes", "mediaType", " contentLength", " contenttype", "ContentType", " contentTypes"], "dest": ["src", " dst", "wb", "orig", "disk", "Dest", "table", "resp", "cont", "path", "trans", "mem", "home", "parent", "oe", "there", "coord", "this", "rest", "obj", "temp", "folder", "source", " Dest", "iter", "cat", "dat", "origin", "copy", "tmp", "target", "nom", "lit", " destination", "loc", "self", "comb", "prop", "result", "dir", "d"], "out": ["go", "os", "null", "t", "w", "ent", "po", "end", "ion", "o", "up", "aos", "it", "client", "port", "obj", "s", "to", "outs", "log", "can", "io", "op", "off", "conn", "write", "n", "res", "output", "set", "ex", "Out", "copy", "en", "con", "conv", "outer", "ou", "oss", "sys", "OU", "external", "file", "OUT", "co", "serv", "cos", "col", "net"], "request": ["re", "QUEST", "forward", "params", "url", "reference", "require", "pair", "quest", "message", "report", "req", "library", "begin", "claim", "reset", "enter", "select", "ire", "user", "child", "create", "relative", "search", "move", "push", "input", "current", "query", "remove", "requ", "ask", "Request", "response", "open", "result"]}}
{"id1": "22338097", "id2": "20426057", "code1": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"createMD5": [" generateMD5", " generateSHA4", " generateSHA1", " generateMD1", " generateSHA5", " generateSHA2", " createmd2", " createMD1", " createmd5", " generateMD4", " createSHA1", " createSHA4", " createMD4", " createmd4", " createSHA2", " createSHA5", " generateMD2", " createmd1", " createMD2"], "pwd": ["pass", " pct", " pword", "pcwd", "passwd", "pess", "pw", " pess", "passw", " pw", "pcess", "Pess", "Pwd", "password", "Pct", "pword", "pcw", "psw", " pass", "pct", "psword", "Pw", "pcct", "psass", "pswd", "passass"], "md": ["mod", "m", "ms", "ad", "det", "df", "ld", " MD", "mk", "dh", "mc", "pm", "MD", "ng", "ct", "ind", "rm", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "me", "down", "de", "cmd", "dm", "mm", "def", "pdf", "der", "nt", "material", "gm", "hd", "red", " Md", "mand", "grad", "mp", "wd", "and", "dd", "d"], "pd": ["dd", "ud", "ads", "PD", "dq", "ad", "pps", "px", "po", "ped", "df", "pp", "ld", "wd", "density", "xd", "pm", "dk", "pi", "ppo", "pn", "p", "cd", "pb", "bd", "pes", "pat", "sd", "np", "dp", "pt", "td", "ds", "rpm", "pta", "pdf", "ecd", "isd", "hd", "online", "dds", "dt", "dl", "ppa", "tp", "vd", "ps", "d"], "app": ["pl", "process", "av", "bg", "api", "ack", "buff", "pp", "orm", "wx", "alph", "ab", "append", "add", "acc", "bb", "App", "sp", "now", "arm", "cell", "APP", "p", "amp", "map", "op", "conn", "js", "ap", "application", "buf", "ip", "exp", "pack", "pal", "att", "dev", "push", "con", "conf", "sa", "db", "abs", "ob", "reg", "form", "msg", "ask", "display", "and", "apt", "ps", "ac", "arr"], "i": ["ji", "m", "iq", "ci", "u", "im", "err", "in", "phi", "j", "ii", "gi", "gu", "qi", "c", "my", "I", "span", "mi", "ti", "oi", "batch", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "name", "sym", "y", "multi", "ic", "print", "uri", "io", "ai", "\u0438", "q", "x", "n", "iu", "bi", "iter", "ip", "cli", "init", "si", "ie", "ij", "ki", "conv", "index", "sim", "li", "ix", "json", "xi", "yi", "ims", "ei", "chain"], "s2": [" sess", " silly", "sq02", "sq1", "S102", "svess", "s0", "ns02", "s5", "silly", "sq2", "s02", "ss1", "S2", "stwo", "ns2", "svilly", "sess", "ms1", "ns0", "s102", " s1", "S1", "ss2", "ms2", "sq102", "sv1", "sv2", "ssilly", " s02", " s5", "ssess", "mstwo", " stwo", " s0", " s102", "ms5", "s1", "S02", "nstwo"]}}
{"id1": "2668853", "id2": "10214218", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileTOFile", "decodeFilesToFiles", "decodeFileToPage", "decodeFilesToFile", "decodeFileToString", "decodeFileAsFile", "decodeFilesToString", "decodeFiles2String", "decodeFile2String", "decodeFileAsFiles", "decodeFiles2File", "decodeFileAsPage", "decodeFileTOFiles", "decodeFilesToPage", "decodeFile2File", "decodeFiles2Files", "decodeFileTOPage", "decodeFile2Files", "decodeFileToFiles", "decodeFileTOString", "decodeFile2Page", "decodeFiles2Page", "decodeFileAsString"], "infile": [" inwhere", "Inbase", "inputwhere", "inpath", "outFile", "innfilename", "InFile", "innfile", "outpath", " infilename", " inbase", "innwhere", "Infile", "inFile", "innbase", "inputFile", "inputbase", "inbase", "inputpath", "infilename", "inputfile", "inwhere", "inputfilename", "Inpath", "outbase"], "outfile": ["listfilename", "outfp", "inpath", " outpath", "Outfilename", "infp", "Outfile", "outFile", "listfp", "outfilename", "outpath", " outFile", "Outpath", "tofilename", "inFile", " outfilename", "listFile", "tofp", "listfile", "tofile", "infilename", "toFile", "OutFile"], "in": ["gin", "info", "re", "im", "per", "nin", " din", "oin", "o", "get", "cin", "it", "on", "ini", "inf", "inn", "ind", "image", "ain", "ins", "rin", "by", "io", "pin", "inc", "conn", "amin", "al", "source", "ai", "n", "user", "ro", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "In"], "out": ["cn", "os", "t", "w", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "flush", "print", "io", "write", "n", "g", "res", "ln", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "ent", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "total", "variable", "document", "zero", "length", "batch", "base", "pad", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "password", "cache", "number", "temp", "queue", "padding", "window", "buf", "tree", "template", "frame", "comment", "header", "initial", "view", "display", "bone", "command", "stack", "attribute", "append"], "read": ["before", "each", "send", "shift", "Read", "length", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "check", "count", "need", "ready", "READ", "reads", "skip", "print", "reader", "readable", "write", "q", "select", "pe", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "data", "size", "reading", "len", "open", "text", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "close", "danger", " successfully", " succeed", "security", "ok", "cont", "submit", "setup", "top", "ratulations", " succ", "release", "valid", " failure", "error", "cess", "snap", "growth", " Success", "summary", "master", "primary", "commit", "surv", " succeeded", "same", " convergence", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", " okay", "warning", "unity", "please", " successes", "first", "green", "city", "exist", "support", " successful", "ceed", "response", "successfully", "status", "result", "crit", "accept"]}}
{"id1": "18731843", "id2": "6421904", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doBody": [" sendBody", " sendHead", " doContent", " writebody", "loadContent", " doHead", "loadBody", " writeHead", " sendbody", " writeBody", "loadHead", " writeContent", " sendContent", "loadbody", " dobody"], "req": ["err", "http", "exec", "Requ", "j", "pkg", "wx", "urg", "gr", "quest", "ps", "sq", "q", "request", "proc", "hr", "pro", "js", "res", "rec", "quick", "cmd", "ctx", "def", "conf", "jp", "qt", "query", "inv", "fr", "reg", "requ", "aj", "Request", "tx", "qq", "express", "crit"], "resp": ["ret", "rep", "re", "pos", "err", "http", "Res", "esp", "soc", "trans", "sp", "client", "out", "cl", "wr", "respond", "sol", " res", "rec", "res", "rel", "js", "respons", "output", "exp", "comm", "def", "Response", "next", "Rep", "RES", "wa", "Resp", "vol", "response", "serv", "result"], "bis": ["os", "ads", "bh", "bt", "bie", "lbs", "bs", "bat", "mi", "oi", "lis", "bes", "cin", "ios", "be", "isi", "bps", "iss", "atis", "zo", "fps", "pins", "pin", "bits", "ses", "bid", "los", "mis", "bi", "iris", "nis", "onis", "sb", "lin", "isin", "phis", "ubis", "ris", "inet", "bil", "iso", "rison", "oss", "aus", "is", "ais", "webkit", "avi", "idis", "obs"], "bos": ["fits", "os", "bh", "bs", "oops", "ubs", "eros", "banks", "oi", "asis", "bes", "aos", "ios", "tes", "its", "tis", "uts", "ts", "bo", "vas", "ows", "outs", "mes", "pins", "bits", "gs", "fs", "asket", "los", "bi", "ods", "acs", "BS", "ols", "bin", "oos", "zb", "ubis", "bas", "bil", "jas", "ys", "stones", "oss", "uds", "nos", "is", "dos", "obs"]}}
{"id1": "22046596", "id2": "2199604", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["paste", " rename", "upload", " copying", " share", "Copy", " paste", " swap", " seek", " restore", "cp", " cop", " move", " replace", " dup", " parallel", "write", " replicate", " cp", " mirror", " extend", " overwrite", " duplicate", " Transfer", "transfer", " insert", " populate"], "s": ["src", "os", "ms", "less", "z", "b", "ws", "ls", "ss", "its", "es", "sq", "ies", "ns", "ts", "v", "p", "cs", "ins", "l", "f", "sl", "sf", "ses", "gs", "ats", "js", "g", "source", "S", "n", "fs", "st", "str", "sv", "rs", "sb", "sts", "string", "ds", "input", "ys", "xs", "south", "gets", "is", "qs", "ps"], "t": ["ret", "tt", "rt", "tc", "w", "kt", "j", "gt", "ot", "h", "o", "it", "ct", "ts", "p", "v", "mt", "l", "k", "f", "n", "g", "T", "test", "st", "txt", "unt", "title", "template", "tr", "nt", "te", "i", "at", "wt", "ht", "ent", "pt"], "in": ["gin", "info", "im", " din", "oin", "mi", "up", "cin", "it", "inf", "inn", "ind", "ins", "ic", "rin", "io", "inc", "ai", "source", "user", "from", "iter", "IN", "init", "en", "bin", "isin", "inner", "ie", "con", "input", "sin", "din", "inside", "i", "is", "ar", "and", "ir", "In"], "out": ["cn", "w", "j", "b", "gt", "c", "ot", "ch", "o", "up", "aos", "it", "or", "check", "client", "this", "v", "can", "to", "l", "outs", "k", "io", "by", "conn", "n", "g", "res", "output", "ex", "Out", "en", "con", "nt", "outer", "ou", "i", "sys", "msg", "OUT", "co", "channel", "ac", "result", "net"]}}
{"id1": "15241397", "id2": "13657103", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", " doPut", "doGET", "Doget", "DoGet", "handleget", " doget", "doget", " doGET", "DoGET", "handlePut", "DoPut", "doPut", "handleGET"], "request": ["re", "each", "QUEST", "forward", "http", "in", "setup", "document", "get", "reference", "quest", "address", "client", "question", "message", "the", "context", "connection", "reset", "report", "req", "transform", "application", "user", "create", "start", "input", "position", "server", "current", "query", "first", "frame", "initial", "Request", "hello", "command", "complete", "attribute"], "response": ["answer", "send", "http", "exit", "resp", "document", "fire", "object", "onse", "success", "version", "block", "ce", "connection", "message", "image", "context", "resource", "sequence", "report", "print", "reset", "ve", "content", "write", "service", "respond", "application", "res", "console", "site", "output", "page", "reply", "position", "server", "network", "Response", "body", "next", "json", "session", "frame", "description", "xml", "view", "form", "status", "result"], "rewrittenQueryString": ["rewrittenQueryStr", "rewwrittenqueryQuery", "rewrittenURLStr", "rewrittenqueryString", "rewwrittenQueryStr", "rewrittenQuStr", "rewrittenQueryQuery", "rewrittenQuString", "rewrittenqueryQuery", "rewliedqueryStr", "rewartedQueryStr", "rewrittenCurrentQuery", "rewliedqueryString", "rewartedQueryString", "rewwrittenQuerystring", "rewwrittenqueryStr", "rewrittenQustring", "rewartedQuerystring", "rewrittenqueryStr", "rewliedQueryStream", "rewrittenQueryStream", "rewrittenRequeststring", "rewrittenQuerystring", "rewrittenHeaderStream", "rewrittenquerystring", "rewrittenRequestString", "rewwrittenquerystring", "rewrittenRequestQuery", "rewrittenURLstring", "rewrittenHeaderStr", "rewartedHeaderString", "rewrittenCurrentstring", "rewartedHeaderStream", "rewartedHeaderStr", "rewwrittenQueryString", "rewrittenURLString", "rewwrittenQueryQuery", "rewartedHeaderstring", "rewrittenQuestionStream", "rewrittenCurrentString", "rewrittenHeaderstring", "rewliedQueryString", "rewrittenQuestionStr", "rewwrittenqueryString", "rewrittenQuStream", "rewrittenRequestStr", "rewrittenQuestionString", "rewliedQueryStr", "rewliedqueryStream", "rewrittenHeaderString", "rewartedQueryStream", "rewrittenCurrentStr", "rewrittenURLStream", "rewrittenqueryStream"], "rewrittenUrl": ["rewriteUrl", "RewwrittenString", "rewittenurl", "rewrittenurl", "rewwrittenLink", "RewrittenUr", "RewwrittenUr", "rewriterUr", "RewwrittenURL", "rewwrittenURL", "rewriddenURL", "rewrotePosition", "rewroteUrl", "rewroteURL", "rewriteURL", "Rewrittenurl", "rewrownUr", "rewrittenString", "rewrittenLink", "RewrittenLink", "rewadjustedPort", "RewrittenPosition", "rewrittenPosition", "rewroteUr", "rewartedPosition", "Rewwrittenurl", "RewwrittenLink", "rewittenUrl", "rewadjustedUrl", "RewrittenUrl", "rewwrittenString", "rewedURL", "rewrownURL", "RewrittenString", "rewartedUr", "rewriddenUrl", "rewrownUrl", "RewwrittenPort", "rewriddenPosition", "rewartedUrl", "RewrittenURL", "rewrapedURL", "RewrittenPort", "rewwrittenPosition", "rewroteLink", "rewartedURL", "rewriteUr", "rewrittenPort", "rewrownPosition", "rewriterString", "rewartedurl", "rewadjustedUr", "rewedUrl", "rewriterUrl", "rewittenURL", "rewriterURL", "rewwrittenPort", "rewrapedUr", "RewwrittenPosition", "RewwrittenUrl", "rewwrittenUr", "rewedString", "rewittenLink", "rewrittenURL", "rewriddenUr", "rewwrittenUrl", "rewedUr", "rewriteurl", "rewroteurl", "rewadjustedURL", "rewrittenUr", "rewwrittenurl", "rewrapedPort", "rewrapedUrl"], "httpURLConnection": ["httpRLConnect", " httpUrlconnection", "httpHTTPApplication", "HttpUrlConnect", "ttpUrlApplication", "httpFileConn", "ttpURLControl", "httpSRconnection", "httpRLconnection", "httpUrlConnection", " httpURLConnect", "ttpURLConnection", "httpUrlConnect", "httpUrlConfiguration", "httpRLApplication", "httpMLConnection", "HttpHTTPConnect", "httpUrlControl", "httpURLConn", "httpHTTPConn", "HttpUrlconnection", "HttpURLApplication", "ttpURLApplication", "ttpUrlControl", "httpURLConnect", "HttpURLConfiguration", "ttpUrlConnect", "httpHTTPConnection", "HttpURLConnection", "ttpURLconnection", "ttpUrlConn", "httpHTTPconnection", "httpUrlConn", "httpMLConnect", " httpUrlApplication", "httpRLConnection", "HttpHTTPConnection", " httpURLconnection", "httpURLControl", "HttpURLConnect", "httpSRApplication", "HttpURLconnection", "HttpUrlConnection", "httpURLConfiguration", "ttpURLConn", "httpHTTPControl", "ttpUrlconnection", "httpFileConnect", "httpSRConfiguration", " httpURLApplication", "httpURLconnection", "httpSRControl", "HttpHTTPApplication", "httpURLApplication", " httpUrlConnection", "httpSRConnect", "httpHTTPConnect", "httpMLApplication", "ttpUrlConnection", "HttpHTTPConfiguration", "ttpURLConnect", "HttpHTTPconnection", " httpUrlConnect", "httpFileApplication", "httpHTTPConfiguration", "httpUrlApplication", "httpSRConnection", "httpMLconnection", "httpFileConnection", "httpUrlconnection"], "header": ["info", "detail", "column", "shift", "heading", "handler", "variable", "rule", "component", "option", "h", "holder", "line", "prefix", "version", "block", "part", "check", "device", "peer", "filter", "address", "client", "buffer", "port", "er", "wrapper", "feature", "hidden", "padding", "term", "argument", "user", "Header", "headers", "init", "metadata", "dr", "page", "title", "state", "token", "operator", "section", "core", "head", "meta", "zone", "query", "relation", "tag", "hash", "ter", "comment", "layer", "field", "format", "policy", "handle", "status", "event", "attribute"], "value": ["record", "email", "sample", "expression", "val", "property", "default", "VALUE", "pair", "version", "python", "address", "name", "message", "values", "v", "sequence", "unit", "password", "element", "content", "example", "sv", "test", "see", "create", "language", "string", "save", "instance", "server", "current", "Value", "zone", "json", "hash", "des", "description", "comment", "data", "ue", "hello", "entry", "field", "key", "label", "text", "attribute", "job", "format", "vector"], "inputStream": ["outputLoop", " inputView", "InputLoop", "InputThread", "errorSteam", "errorWindow", " inputstream", "outputSteam", "inputThread", " inputWindow", " inputLoop", "inputLoop", "outputstream", "InputView", "inputSteam", "outputWindow", "errorstream", "inputView", " inputSteam", " inputThread", "inputstream", "outputView", "errorStream", "InputStream", "inputWindow", "outputThread"], "outputStream": ["responseForm", "outputForm", " outputForm", " outputstream", "OutputLength", "outputLength", "outputSteam", "displayStream", "OutputStream", "responseStream", "displaySteam", "outputstream", "inputSteam", "OutputForm", "responseSteam", "inputView", "responseLength", "displaystream", " outputView", "inputstream", "OutputSteam", "outputView", " outputLength", " outputSteam", "displayView"]}}
{"id1": "17202158", "id2": "8079516", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["findZoneID", "readLineIDs", "readObjectIDS", "findLocalIDS", "readZoneIDS", "findLocalIDs", "findZoneNames", "readLocalIDS", "findZoneIDs", "findLocalNames", "readLineIDS", "readObjectID", "readLocalIDs", "readLocalNames", "readObjectIDs", "readLocalID", "readLineID", "findZoneIDS", "readZoneID", "findLocalID", "readZoneNames", "readObjectNames", "readLineNames"], "zoneFileName": [" zonefilePath", "zoneFilesName", "ZonefileName", "zonefileChain", "zoneFilesPath", "zoneFileType", "zoneFileSpec", "zoneFileNames", "zoneFILEName", " zoneFileChain", "zonefileNames", " zonefileName", "zoneFilenameName", "ZoneFileSource", "ZonefileType", "zoneFILEPath", "zoneFilenameSpec", "zoneFilesChain", "ZonefileFilename", "zoneFILENames", "ZoneFileSpec", "zoneFILEFilename", "zoneFileFilename", "zoneFilenameSource", "zoneFolderName", "zonefileSpec", "ZonefileSource", "ZonefileSpec", "zoneFolderFilename", "zoneFileSource", "zonefileName", "zoneFilenamePath", "zoneFolderPath", " zoneFileNames", "zoneFilesNames", "zoneFilePath", "zonefileSource", "zoneDirSource", "zoneFileChain", "ZoneFileType", "zoneFILEChain", "zoneDirPath", "ZoneFileName", "zonefilePath", "ZoneFilePath", "zonefileFilename", "zonefileType", "ZoneFileFilename", "zoneFolderType", "zoneDirSpec", "zoneDirName", "zoneFILEType", " zonefileNames", "ZonefilePath", " zoneFilePath", " zonefileChain"], "zoneids": ["zanaires", "znames", " zonelines", "zoneoids", "zuploads", "zaIDs", "zoneuploads", "tznaires", "ziplines", "zids", "zcodes", "zipids", "zaids", "tzoids", "zipIDs", " zoneIDs", " zoneuploads", " zoneoids", "zonecodes", "elementlines", "elementcodes", "elementids", "zonenames", "zaoids", " zonenames", "zlines", "zonelines", "zoneIDs", "tzIDs", "zonenaires", "elementuploads", " zonenaires", " zonecodes", "zipnames", "tzids", "zIDs"], "url": ["ret", "browser", "lr", "ur", "bel", "http", "ref", "ls", "open", "base", "build", "name", "this", "resource", "uri", "l", "f", "sl", "r", "nl", "log", "rl", "cl", "q", "str", "rel", "mount", "user", "ssl", "char", "Url", "web", "ul", "file", "loc", "ll", "lb", "dl", "loader", "URL", "result"], "lnr": ["nlr", "nlcr", "lenr", "linp", "cncr", "lenn", "lnR", "lndr", "linrar", "lendr", "olndr", "olnR", "cnr", "nlrar", "nlR", "nldr", "olnr", "lnp", "lnn", "cnrar", "lincr", "linr", "nlp", "lncr", "olnn", "lenR", "cnp", "lnrar", "nln"], "line": ["LINE", "row", "phrase", "link", "sample", "ge", "eline", "range", "inline", "stream", "block", "e", "part", "day", "cell", "message", "Line", "sequence", "normal", "l", "log", "print", "nl", "number", "code", "ln", "stroke", "lin", "page", "string", "style", "word", "continue", "char", "section", "next", "le", "point", "display", "frame", "comment", "header", "online", "file", "lane", "entry", "ine", "text", "chain", "liner", "net"]}}
{"id1": "16079868", "id2": "6299111", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String retrieveQ(String urlToRetrieve) throws MalformedURLException, IOException {\n        URL url = new URL(urlToRetrieve);\n        URLConnection uc = url.openConnection();\n        InputStream is = uc.getInputStream();\n        BufferedReader in = new BufferedReader(new InputStreamReader(is));\n        StringBuilder output = new StringBuilder(16384);\n        String str;\n        boolean first = true;\n        while ((str = in.readLine()) != null) {\n            if (!first) output.append(\"\\n\");\n            first = false;\n            output.append(str);\n        }\n        in.close();\n        System.err.println(((HttpURLConnection) uc).getResponseMessage());\n        return output.toString();\n    }\n", "label": 1, "substitutes": {"readIntoList": ["readintoList", "readIntToMenu", "readintintolist", "readIntTolist", "readintintoMenu", "readIntintoMenu", "readIntIntlist", "readintolist", "readintintoList", "readIntIntList", "readIntIntMenu", "readIntolist", "readIntintolist", "readIntToList", "readintintoMap", "readIntintoList", "readintoMap", "readIntintoMap", "readIntoMenu", "readIntToMap", "readIntIntMap", "readIntoMap", "readintoMenu"], "url": ["ret", "domain", "bel", "ur", "http", "link", "b", "ref", "address", "name", "id", "image", "resource", "uri", "l", "log", "f", "r", "nl", "str", "window", "mol", "rect", "mount", "hub", "from", "location", "ssl", "string", "input", "char", "Url", "web", "mail", "el", "xml", "file", "loc", "ll", "dl", "open", "cert", "URL", "browser"], "list": ["info", "record", "dict", "m", "module", "detail", "t", "table", "batch", "top", "get", "add", "block", "part", "parent", "level", "name", "p", "port", "summary", "map", "l", "print", "group", "v", "out", "cache", "only", "n", "test", "st", "set", "state", "all", "tree", "network", "show", "relation", "pool", "view", "LIST", "listed", "is", "format", "type", "label", "status", "rm", "lists", "collection"], "in": ["gin", "re", "read", " din", "val", "get", "up", "cin", "add", "on", "line", "check", "inf", "inn", "ill", "mn", "ins", "er", "ic", "rin", "by", "reader", "r", "pin", "inc", "doc", "out", "source", "IN", "from", "en", "isin", "bin", "inner", "all", "con", "input", "conf", "din", "sum", "i", "file", "is", "and", "In"], "inputLine": ["inputL", "contextline", "htmlLINE", "textLin", "httpL", "formline", "nextText", "selectText", "inputLINE", "nameline", "httpLINE", "InputLINE", "nameBlock", "formBlock", "inputline", "nameLINE", "latLINE", " inputRow", " inputLINE", "nameLine", "inputLin", "textL", "commandLine", "nextLine", "htmlBlock", "contextLine", "outputLine", " inputBlock", "nextLINE", "latLine", "inputBlock", "attLINE", "Inputline", "selectLINE", "textLINE", "nextRow", "helloLin", "InputBlock", "outputline", "textLine", "selectRow", "commandline", "helloLine", "actLine", "dataLine", "formLINE", "activeLINE", "htmlline", "inputRow", "attLine", " inputText", "actLINE", "httpLine", "actline", "httpLin", " inputline", "activeLine", "commandLINE", "contextLINE", "outputLINE", "selectLine", "formLine", "helloLINE", "dataLINE", "helloL", "inputText", "InputLine", "htmlLine"], "commandNameBegin": ["commandnamebegin", "commandFamilyBeg", "commandTypebegin", "commandNameStart", "commandNAMEMon", "commandNamesBeginning", "commandNamesbegin", " commandNamebegin", "commandFamilyMon", "commandTypeStart", "commandSizeBeg", " commandNameBeginning", "commandNameBeginning", "commandNameMon", "commandNamebegin", "commandSizeMorning", "commandNameEGIN", "commandNameInitial", "CommandNameStart", "commandnameBeginning", " commandNameEGIN", "commandnameBegin", " commandOrderStart", "commandFamilyInitial", "commandNAMEBegin", "commandLineBegin", " commandSizeMorning", " commandSizeBegin", "CommandNamebegin", "commandLineStart", "commandTypeBeginning", "CommandNameBegin", "commandFamilyBegin", " commandNameMon", "commandFamilyEGIN", "commandNAMEInitial", "CommandNamesBeginning", "commandOrderbegin", "commandFamilyBeginning", "commandOrderBeginning", "commandnameEGIN", "CommandNamesStart", "CommandNamesbegin", "commandnameBeg", "commandNamesStart", "commandSizeEGIN", "commandLinebegin", " commandOrderBeginning", "commandFamilyMorning", "commandNameMorning", " commandNameMorning", " commandNameInitial", "commandOrderStart", " commandSizeBeg", "commandOrderBegin", "CommandNamesBegin", " commandSizeEGIN", "commandLineBeginning", " commandOrderBegin", "commandSizeBegin", "commandnameStart", "commandNameBeg", " commandOrderbegin", " commandNameBeg", "commandNamesBegin", "commandnameMorning", "CommandNameBeginning", "commandNAMEBeginning", "commandTypeBegin", " commandNameStart"], "commandNameEnd": [" commandNamesEnd", " commandNameend", "commandStringEND", "formNameEND", "formNameStart", "commandNamesEND", " commandLineend", "commandNameStart", "commandSizeStart", "commandNamesStart", "commandStringEnd", "cmdNameEnd", "cmdTimeEnd", " commandNameEND", "commandLineEND", "commandNamesend", "commandLineend", "cmdNameend", " commandNamesEND", "commandNamesBegin", "commandTypeend", " commandLineEnd", "cmdNameEND", "cmdTimeend", "formNameEnd", "commandStringBegin", "cmdTimeEND", "commandnameend", "commandnameEnd", " commandNamesBegin", "formNameend", " commandLineEND", "commandTypeStart", "formSizeStart", "commandTypeEnd", "formSizeEND", "commandSizeEnd", "commandTimeEND", "commandNamesEnd", "commandLineEnd", "commandTypeEND", "commandSizeEND", "commandnameEND", "commandNameEND", "commandNameend", "commandTimeEnd", "formSizeEnd", "commandTimeend", "commandSizeend", "commandTypeBegin", " commandNamesStart", "formSizeend", " commandNameStart", "commandStringStart"], "item": ["info", "bar", "m", "row", "module", "im", "other", "link", "handler", "this", "rule", "object", "option", "Item", "base", "mix", "it", "add", "or", "mem", "check", "store", "question", "p", "image", "unit", "obj", "article", "owner", "element", "menu", "group", "items", "event", "member", "hit", "em", "iter", "mm", "local", "exp", "widget", "page", "title", "inner", "template", "tree", "app", "instance", "related", "index", "sim", "li", "i", "monitor", "el", "task", "match", "type", "entry", "button", "key", "label", "command"], "e": ["m", "re", "u", "t", "err", "w", "ent", "ee", "b", "ec", "c", "end", "eur", "ge", "h", "o", "a", "se", "be", "ed", "es", "fe", "oe", "ce", "error", "v", "p", "ze", "er", "ae", "l", "f", "ve", "r", "ea", "ev", "x", "q", "E", "n", "g", "one", "de", "pe", "eb", "ex", "eeee", "en", "ie", "ef", "le", "te", "i", "eg", "el", "eu", "ne", "ue", "event", "et", "d"]}}
{"id1": "19944975", "id2": "5148212", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["writeConfig", "outputSettings", " writeSettings", "outputConfiguration", "WriteConfiguration", "outputConfig", " writeConfig", "WriteContent", " writeContent", "WriteSettings", "writeContent", "writeSettings", "outputContent", "WriteConfig"], "out": ["pretty", "null", "t", "err", "w", "b", "table", "c", "ch", "o", "free", "h", "up", "aos", "check", "list", "client", "this", "p", "help", "writer", "v", "group", "log", "report", "outs", "io", "over", "to", "print", "conn", "n", "g", "res", "cmd", "output", " OUT", "set", "Out", "all", "con", "nt", "outer", "ou", "at", "pool", "cm", "OU", "file", "OUT", "msg", "cast", "ent", "result"], "url": ["ret", "domain", "bel", "http", "link", "path", "ref", "base", "gl", "address", "name", "client", "resource", "uri", "l", "f", "sl", "r", "nl", "rl", "service", "str", "rect", "rel", "mount", "user", "location", "ssl", "pattern", "char", "Url", "mail", "abs", "file", "loc", "dl", "ll", "key", "cert", "URL", "net"], "in": ["gin", "m", "null", "read", "sample", " din", "mc", "up", "cin", "it", "on", "none", "inn", "ind", "ins", "l", "rin", "f", "io", "r", "reader", "al", "source", "str", "user", "st", "IN", "from", "en", "isin", "bin", "inner", "con", "input", "sin", "din", "body", "sum", "ma", "i", "inside", "el", "file", "is", "serv", "and", "In"]}}
{"id1": "19549489", "id2": "5744493", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "upload", "read", "Copy", "add", "delete", "cp", "map", "sync", "write", "Cop", "cat", "create", "replace", "csv", " cp", "export", "move", "save", " mirror", "slice", " duplicate", "transfer", "clone", " Copy", "download", "rm", "load"], "sourceFile": [" sourcePage", "SourceFilename", "SourcePage", "SourceFile", "ourceFile", "SourceLine", "sourcePage", "inputFile", "sourceLine", "sourcefile", "inputPage", "inputLine", "ourceFilename", "ourcePage", " sourceLine", "Sourcefile", " sourceFilename", "inputfile", " sourcefile", "ourceLine", "sourceFilename", "ourcefile"], "destinationFile": ["estinatedFilename", "estinationPlace", "destinoFilename", "declinatorPath", "estinatedPlace", "estinatedfile", "destinateFilename", "destinatePlace", "destinationPath", "declinationFile", "destinationsFile", "destinatorFilename", "destinationFilename", "destrativePlace", "destinatedFilename", "destrativeFile", "estinationFile", "destinatedPlace", "destinationsfile", "declinatorFilename", "declinatorFile", "destrativeFilename", "destinatePath", "destinationPlace", "destinationsFilename", "destinatorPath", "destrativePath", "destinationsPlace", "destinateFile", "declinationFilename", "declinatorPlace", "estinationFilename", "destinatorFile", "destinatorPlace", "declinationPath", "estinationfile", "destinationfile", "destinofile", "destinatedfile", "destinoFile", "estinatedFile", "declinationPlace", "destinatedFile", "destinoPlace"], "sourceFileChannel": ["sourceStreamConnection", "sourceLineChannel", "sourceEntryChan", "srcBlockEntry", "sourceBaseChuck", "srcBlockChannel", "sourceStreamChuck", "sourceLinechannel", "srcBlockchannel", "sourceBlockEntry", "sourceFileEntry", "srcFileChannel", "srcFilechannel", "ourceFileChan", "sourceStreamChannel", "sourceBytechannel", "sourceByteConnection", "sourceEntryConnection", "sourceLineChan", "ourceEntrychannel", "ourceEntryChan", " sourceFileHandler", "sourceFileConnection", "ourceFileConnection", "sourceByteChannel", "sourceLineEntry", "srcBlockConnection", "sourceLineConnection", "sourceBaseChannel", "srcFileConnection", "sourceBlockchannel", "srcFileEntry", "sourceByteEntry", "sourceStreamHandler", "sourceFilechannel", "sourceBlockConnection", "ourceEntryConnection", "ourceEntryChannel", "sourceFileHandler", "sourceEntrychannel", "sourceBaseApplication", "sourceFileApplication", "sourceFileChuck", "sourceEntryChannel", "sourceStreamApplication", " sourceFileApplication", "ourceFilechannel", "sourceBlockChannel", "sourceStreamchannel", "sourceFileChan", "ourceFileChannel", " sourceFileChuck", "sourceBaseHandler", "sourceStreamChan"], "destinationFileChannel": ["destinationFilechannel", "destinationResourceManager", "destinationfilechannel", "destinationChannelChannel", "destinatorFileConnection", "destinationPageChan", "destinatorFileChan", "destinationPageContext", "destmentResourceChan", "destinationResourceChannel", "destinationFileEntry", "destinationDirectorychannel", "destinationFileConnection", "destinationResourceChan", "destinationFilesCh", "destinationPageChannel", "destinatorFileChannel", "destmentFilechannel", "destinationFilesChan", "destmentFileChan", "destinatorFileCh", "destinationFileManager", "destinationFileCh", "destinationfileChan", "destinatorFilesConnection", "destinationFilesChannel", "destinationfileChannel", "destmentPageChannel", "destinationFilesConnection", "destinatorFilesCh", "destinationfileManager", "destmentPageEntry", "destinationFileContext", "destinatorFilesChan", "destmentFileManager", "destinationChannelChan", "destinationResourcechannel", "destmentPageChan", "destinationFileChan", "destinationChannelEntry", "destinationfileCh", "destinationChannelCh", "destinationDirectoryChannel", "destmentResourceManager", "destinationDirectoryManager", "destinationPageEntry", "destinationChannelConnection", "destinationChannelContext", "destinationfileConnection", "destmentResourcechannel", "destmentResourceChannel", "destmentPageContext", "destinatorFilesChannel", "destmentFileContext", "destmentFileChannel", "destinationDirectoryChan", "destinationfileContext", "destmentFileEntry", "destinationfileEntry"]}}
{"id1": "804637", "id2": "21125261", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "20091126", "id2": "17158020", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"copy": ["paste", "Transfer", "upload", "Copy", "open", "get", "delete", "store", "cp", "system", "y", "map", "to", "call", "io", "sync", "write", "Cop", "cat", "create", "move", "save", "transfer", "clone", "file", " Copy", "download", "load"], "in": ["gin", "info", "b", " din", "old", "up", "cin", "ini", "inf", "inn", "ind", "id", "ain", "ins", "l", "rin", "io", "r", "inc", "source", "n", " input", "IN", "from", "mm", "init", "en", "inner", "isin", "ck", "input", "din", "i", "el", "file", "In"], "out": ["os", "null", "t", "err", "w", "_", "b", "gt", "c", "end", "ot", "ch", "o", "it", "e", "or", " it", "v", "y", "p", "s", "to", "l", "log", "outs", "io", "write", "x", "one", "n", "res", "output", "ex", "Out", "nt", "tmp", " os", "ou", "at", "as", " output", "bytes", "file", "OUT", "co", "msg", "channel", "self", "result", "net"], "inChannel": ["inchannel", "inPanel", "incChuck", "outBlock", "ginPanel", "innChan", "INChannel", " inSection", "inListener", "binCommand", "binSection", "inCommand", "InChannel", "cinChannel", "INListener", "incChain", "outCommand", "insideSection", "cinchannel", "cinBlock", "innConnection", "inRow", "inBlock", " inchannel", "ginChain", "cinCommand", " inListener", "insideChannel", "ginChuck", "inSection", " inChan", "incChannel", " inConnection", "INChan", "binChain", "binRow", "conChannel", "INConnection", "inChain", "incPanel", "binPanel", " inCommand", "innchannel", "outchannel", "inChuck", "conListener", "conChan", "conConnection", "binChuck", "insideCommand", "InChan", "inChan", "Inchannel", "innChannel", " inRow", "inConnection", " inBlock", "InConnection", "insideRow", "ginChannel", "binChannel"], "outChannel": ["outCh", "cmdChan", "inchannel", "OUTSlot", "outputManager", "outGate", "outSlot", "outMany", "cosChannel", "OutCh", "OUTChan", "OutChan", "modulePassword", " outPassword", "Outchannel", "cosUser", "cmdGate", "cmdChannel", "moduleChan", " outCh", "cosChan", "skyGate", "moduleManager", "outputChan", "outUser", "cmdMany", "OUTUser", " outManager", "outManager", "skyMany", "inCh", "cosSlot", "moduleChannel", " outMany", "outchannel", "OUTChannel", "skyChan", "outputChannel", "inSlot", "inUser", " outChan", "skyChannel", "outChan", " outchannel", "outPassword", "outputPassword", "inChan", "OutChannel", " outGate"]}}
{"id1": "5951610", "id2": "22442270", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"testNetworkHTTP": ["testApplicationURL", "testNetURL", "testApplicationHTML", "TestNetworkURL", "testNetHTML", "TestNetworkHTML", "TestNetURL", "TestNetHTTP", "TestNetHTML", "testNetworkHTML", "TestNetworkHTTP", "testNetworkURL", "testApplicationHTTP", "testNetHTTP"], "url": ["ret", "pl", "m", "lr", "u", "ur", "t", "http", "hl", "email", "link", "b", "https", "il", "path", "back", "ref", "ls", "util", "base", "gl", "get", "github", "host", "ml", "address", "resource", "obj", "l", "log", "print", "sl", "r", "nl", "fl", "rl", "conn", "cl", "term", "str", "org", "rel", "blog", "mount", "www", "impl", "bl", "uri", "console", "location", "pull", "ssl", "all", "ocl", "lt", "Url", "mail", "web", "html", "el", "ul", "norm", "dl", "loc", "ll", "lb", "channel", "acl", "cert", "URL"], "urlConnection": ["httpHandler", "methodConnection", "utilService", "lsConnect", "sslConn", "lrConn", "urlDiscussion", "implConnection", "httpSet", "managerConnect", " urlHandler", "managerConnector", "consoleConnection", "railListener", " urlMachine", "resourceConnection", "mlConn", "implConnector", "sslConnection", "managerInfo", "browserConnection", "mlConnection", "emailConnect", "utilConn", "lsConn", "sslPosition", "urlConnect", "urlListener", "railConnection", "httpService", "urlHandler", "consoleConn", "httpConnector", "managerConnection", "httpListener", "urlService", " urlInfo", " urlCon", "railHandler", "urlMachine", " urlDiscussion", "urlConn", "fileConnection", " urlResponse", "resourceConnector", "fileConnect", "fileConn", "mlCon", "urlSet", " urlConnector", "emailConnection", "implConnect", " urlService", "urlInfo", "dbConnect", "urlResponse", "methodConnector", " urlConnect", "dbPosition", "utilConnection", "resourceResponse", "browserConn", "sslConnector", "dbConn", "emailConnector", " urlConn", " urlPosition", "railConnect", "nameConnector", "resourceConn", "fileDiscussion", "urlPosition", "httpConnection", "sslConnect", "utilConnect", "sslDiscussion", "utilListener", "nameConnection", "methodConn", "lrConnection", "lsConnection", "mlMachine", "nameConnect", "utilSet", "lrConnector", "httpConn", "implConn", "methodConnect", "urlCon", "nameConn", "lsConnector", "lrResponse", "httpConnect", "httpInfo", " urlListener", " urlSet", "consoleMachine", "dbConnection", "urlConnector", "browserConnect", "emailConn", "consoleCon", "utilConnector", "browserConnector"], "rd": ["rt", "lr", "rw", "gd", "rob", "rend", "ped", "ld", "rc", "rax", "rand", "dra", "repl", "xd", "drm", "mr", "erd", "nd", "ered", "RD", "rer", "ind", "rus", "rm", "dig", "ra", "r", "bd", "rl", "std", "rg", "wr", "hr", "ord", "rs", "rod", "rx", "nder", "dr", "ined", "rb", "art", "ck", "ri", "rid", "adr", "usr", "din", "ird", "rr", "fr", "rown", "ptr", "rez", "red", "ded", "grad", "fd", "rn", "rh", "dd", "dir", "d"], "line": ["record", "LINE", "row", "column", "email", "link", "length", "lo", "where", "stay", "eline", "range", "inline", "side", "block", "ice", "part", "check", "none", "error", "cell", "message", "buffer", "Line", "port", "l", "log", "nl", "number", "lines", "cl", "LIN", "node", " LINE", "ln", "iter", "set", "lin", "string", "page", "continue", "next", "zone", "point", "le", "pipe", "edge", "frame", "comment", "status", "file", "online", "loop", "channel", "lock", "entry", "time", "ine", "len", "liner", "load"]}}
{"id1": "10131427", "id2": "21438069", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 0, "substitutes": {"copyFile": [" CopyFile", " copyStream", " cpStream", " copyImage", " cpImage", " cpfile", " copyfile", " CopyStream", "CopyImage", "Copyfile", " CopyImage", " Copyfile", "CopyStream", " cpFile", "CopyFile"], "in": ["gin", "vin", "b", "old", "o", "up", "cin", "it", "on", "inf", "inn", "ind", "ins", "s", "ic", "rin", "l", "r", "inc", "source", "n", "st", "from", "IN", "mm", "en", "isin", "input", "edIn", "din", "i", "el", "is", "ar", "In"], "out": ["os", "t", "err", "w", "po", "b", "gt", "ot", "ch", "o", "it", "check", "v", "help", "s", "to", "outs", "l", "log", "io", "str", "n", "output", "ex", "Out", "nt", "ou", "oss", "i", "file", "OUT", "serv", "ne", "net"], "sourceChannel": ["matchChannel", "ourceChannel", " sourceButton", "srcchannel", "resourcechannel", "resourceStream", "seedApplication", "inputChan", "SourceConnection", "SourceChannel", "SourceStream", "resourceChannel", "sourceChuck", "Sourcechannel", "sourceConnection", "seedButton", "sourcechannel", "inputConnection", "inputChain", "ourceChain", "sourceApplication", " sourceChan", "srcButton", "matchButton", "matchApplication", "srcStream", "singleChannel", "srcChannel", "ourceChan", "sourceChain", "matchChuck", " sourcechannel", "ourceButton", "seedChuck", " sourceStream", "ourceConnection", "singleApplication", "ourceStream", " sourceChain", "ourcechannel", "resourceConnection", "singleChuck", "inputChannel", "sourceStream", " sourceConnection", "singleButton", "sourceButton", "sourceChan", "seedChannel"], "destinationChannel": ["destroyClient", "DestinationChan", "DestinationConnection", "destinatedChan", "DestationContext", "desticationChannel", "destinatoryChannel", "destroyChan", "DestensionChan", "DestationChan", "destinationConnection", "DestationChannel", "destationConnection", "destinatoryChan", "destensionChan", "destationClient", "destroyConnection", "desticationCow", "DestationConnection", "desticationChan", "DestinationCow", "destensionChannel", "destinatedChannel", "destationBlock", "DestationCow", "destinationClient", "destinationContext", "destationCow", "DestensionChannel", "destensionConnection", "destationChan", "DestinationChannel", "desticationBlock", "DestinationContext", "destinationBlock", "destinationChan", "DestensionClient", "destinationsChannel", "DestinationBlock", "destinatedConnection", "destinationsContext", "destinationsChan", "destinationsConnection", "destensionClient", "destinationCow", "DestensionConnection", "destationContext", "destroyChannel", "destinatoryBlock", "DestationBlock", "DestinationClient", "destinatedContext", "destationChannel", "destinatoryCow"]}}
{"id1": "9954926", "id2": "3767903", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"simulate": ["modulates", "simure", "simulates", "smulates", "modure", "modulate", " simure", " simulates", "smure", "modulation", "smulate", "simulation", "smulation", " simulation"], "out": ["pretty", "cn", "t", "err", "w", "b", "c", "up", "aos", "e", "can", "flush", "log", "f", "io", "init", "conf", "OU", "OUT", "co", "net", "gc", "o", "it", "raw", "error", "client", "last", "to", "report", "print", "conn", "put", "gov", "ou", "pool", "go", "in", "batch", "on", "store", "list", "buffer", "v", "obj", "hit", "n", "res", "cmd", "all", "cfg", "screen", "outer", "gen", "ent", "os", "null", "nr", "base", "gr", "name", "p", "help", "writer", "ins", "group", "outs", "content", "cache", "write", "output", "ex", "exp", "set", "Out", "copy", "inner", "tree", "state", "con", "nt", "conv", "ger", "sum", "inv", "manager", "at", "sys", "handle"], "file": ["File", "t", "ile", "FILE", "b", "table", "document", "fp", "path", "base", "e", "name", "message", "buffer", "port", "resource", "connection", "l", "library", "f", "log", "io", "report", "play", "source", "console", "output", "set", "template", "input", "le", "db", "pool", "model", "data", "lock", "channel", "format", "type", "filename", "handle", "result"], "obtainUserReputationRequest": ["obtainUserReputionTask", "obtainUserRepresentationError", "obtainUserRepresentutationRequest", "obtainUserReputationsRequest", "obtainUserRepationResponse", "obtainUserRepationQuery", "obtainUserRepositoryTask", "obtainUserRepresentutationResponse", "obtainUserRepresentationTarget", "obtainUserReputationrequest", "obtainUserReputationTask", "obtainUserReputionQuery", "obtainUserReporationResponse", "obtainUserReputationsTarget", "obtainUserRepositoryResponse", "obtainUserReputationError", "obtainUserReputationTarget", "obtainUserReputationsQuery", "obtainUserReputationsTask", "obtainUserRelutationsRequest", "obtainUserRelutationsResponse", "obtainUserRepresentationRequest", "obtainUserRepositoryQuery", "obtainUserRepresentationrequest", "obtainUserRelutationQuery", "obtainUserRelutationsQuery", "obtainUserReplutationRequest", "obtainUserRepationRequest", "obtainUserRelutationRequest", "obtainUserRepresentutationError", "obtainUserReporationQuery", "obtainUserReporationRequest", "obtainUserRepetitionTarget", "obtainUserReputationsResponse", "obtainUserReplutationResponse", "obtainUserReputationQuery", "obtainUserRepresentutationQuery", "obtainUserRepetitionResponse", "obtainUserRepationrequest", "obtainUserRepationTarget", "obtainUserRepresentutationTarget", "obtainUserReputationsError", "obtainUserRelutationTask", "obtainUserRepetitionRequest", "obtainUserRelutationsTask", "obtainUserReporationError", "obtainUserRepationError", "obtainUserRepresentationResponse", "obtainUserRepresentationQuery", "obtainUserRepositoryRequest", "obtainUserReputationsrequest", "obtainUserRepresentutationrequest", "obtainUserReputionResponse", "obtainUserRelutationResponse", "obtainUserReputionrequest", "obtainUserReputionRequest", "obtainUserReputionTarget", "obtainUserReplutationTarget"], "obtainUserReputationResponse": ["obtainUserRepositoryAnswer", "obtainUserReportutationResp", "obtainUserReputationsService", "obtainUserReportutationResponse", "obtainUserRepulationAnswer", "obtainUserReputationsAnswer", "obtainUserRepositoryResponse", "obtainUserReputationAnswer", "obtainUserReputationsResp", "obtainUserReputationResp", "obtainUserReportositoryService", "obtainUserReputationService", "obtainUserRepositoryResp", "obtainUserRepulationResp", "obtainUserReportutationService", "obtainUserRepositoryService", "obtainUserRepulationResponse", "obtainUserReputationsResponse", "obtainUserReportutationAnswer", "obtainUserReportositoryResp", "obtainUserReportositoryResponse", "obtainUserRepulationService", "obtainUserReportositoryAnswer"], "rateUserRequest": ["rateUsersQuery", "RateClientRequest", "rateUserQuery", "RateUserRequest", "rateProxyQUEST", "rateuserResponse", "rateUsersChange", "rateLineResponse", "RateUsersResponse", "rateDateGrant", "RateUserGrant", "createUserCommand", "createUserrequest", "rateRowRecord", "createuserRequ", "RateClientGrant", "RateUsersQUEST", "rateUsersAccess", "rateuserQUEST", "raceUserRecord", "rateUserAccess", "rateLineCommand", "rateUserQUEST", "raceRowRequest", "RateUserResponse", "rateSampleRequest", "RateUsersQuery", "scaleOwnerRequest", "rateSampleCommand", "RateLineQuery", "RateUsersrequest", " rateUserQuery", "rateJobRequest", "rateRowResponse", "rateOwnerRecord", "rateuserAccess", "createuserRequest", "rateuserQuery", "RateLineRequest", "rateLineRequ", "rateOwnerAccess", "rateOwnerRequest", " rateUserJob", "rateOwnerResponse", "rateDateRequest", "rateLinerequest", "createUserRequ", "createuserCommand", "rateuserRequest", "rateUserrequest", "rateUsersrequest", "rateDateResponse", "rateProxyQuery", "rateUserRecord", "RateLineResponse", "scaleUserResponse", "raceRowRecord", "rateTimeRequest", "rateJobResponse", "rateUsersResponse", "rateUserJob", "rateUsersQUEST", "rateTimeResponse", "RateUserChange", "rateUserGrant", "rateUserChange", "rateRowrequest", "scaleOwnerAccess", "rateClientRequest", "rateSampleRequ", "RateUsersRequest", "rateProxyResponse", "raceRowrequest", "rateUserCommand", "rateLineGrant", "rateClientrequest", "createUserRequest", "createuserrequest", "raceUserrequest", "rateJobChange", "RateLinerequest", "rateRowRequest", "rateuserRequ", "RateUserrequest", "RateUserQUEST", "rateTimerequest", "rateLineRequest", "rateClientResponse", "scaleUserRequest", "rateuserCommand", "rateUsersRequest", "RateClientResponse", "rateClientJob", "scaleOwnerResponse", " rateUserrequest", "rateuserrequest", "rateRowJob", "scaleUserAccess", "RateUsersChange", "rateOwnerrequest", "RateUserQuery", "rateClientGrant", "rateUserRequ", "rateSamplerequest", "raceUserRequest", "rateProxyRequest", "rateLineQuery"], "rateUserResponse": ["rateControllerResponse", " rateClientReturn", "RateUserRequest", "rateMethodResponse", "rateuserResponse", "rateControllerRequest", "rateMemberRequest", "RateUsersResponse", "rateMemberresponse", "rateMethodData", "RateUserReply", "rateFileResponse", "RateUserData", "rateUserStatus", "ratesClientResp", "rateWordReturn", "RateUserResponse", "rateControllerMessage", "rateMethodVersion", "rateUserMessage", "rateUsersReply", " rateUserresponse", "rateWordRequest", "ratesClientMessage", "rateWordresponse", "rateUserVersion", " rateClientRequest", "rateUserData", "ratesUserMessage", " rateUserReturn", " rateClientResponse", "rateFileRequest", "rateManagerResponse", "rateDateRequest", "rateUserAnswer", "rateTimeAnswer", "RateUserVersion", "rateUsersresponse", "rateClientResp", "ratesUserResponse", "rateuserRequest", "rateDateResponse", "RateUsersReply", "rateTimeRequest", "rateDateData", "rateClientresponse", "rateUsersStatus", "rateUsersResponse", "rateUsersAnswer", "rateTimeResponse", "ratesClientRequest", " rateUserStatus", "rateClientRequest", "rateUserresponse", " rateUserAnswer", "RateUsersRequest", "rateFileresponse", "rateManagerResp", "rateTimeStatus", "rateUserReply", "rateFileReturn", " rateClientresponse", "rateuserReply", "rateMemberResponse", "RateUsersresponse", "rateManagerMessage", "rateMemberReply", "ratesUserResp", "rateClientResponse", "rateUserResp", "rateManagerRequest", "ratesUserRequest", "rateUsersRequest", "rateClientReturn", "rateClientMessage", "rateDateVersion", "rateMethodRequest", "rateControllerResp", "rateuserresponse", "rateUserReturn", "RateUserresponse", "rateWordResponse", "ratesClientResponse"], "fis": ["lIS", "sfIS", "sfiss", "fIS", "flisa", "sfis", "flis", "sfIs", "lis", "fIs", "FIs", "fiss", " fisa", "liss", "bi", "bisa", "fli", "Fiss", "FIS", "lIs", "fisa", "Fis", "fi", " fi", "bis"], "br": ["bt", "lr", "shr", "bh", "nr", "bn", "ch", "bf", "Br", "be", "gr", "bm", "bd", "wr", "hr", "gb", "str", "buf", "bl", "bi", "ctr", "cr", "dr", "bro", "tr", "BR", "bp", "sr", "div", "bridge", "ger", "pr", "fr", "kr", "ber", "vr", "mr", "browser", "adr"], "call": ["info", "dial", "send", "update", "cal", "c", "Call", "url", "cin", "line", "add", "block", "called", "check", "use", "list", "cell", "name", "message", "report", "log", "play", "request", "str", "action", "n", "code", "function", "test", "all", "word", "continue", "char", "bridge", "query", "inv", "draw", "trace", "frame", "comment", "execute", "contact", "callback", "label", "ell", "status", "command", "result"]}}
{"id1": "7087108", "id2": "14038176", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"doGet": ["invokeSet", " handleGET", "invokeget", " handleget", " handleGet", "doGET", " handleSet", "doSet", " doget", "doget", " doGET", " doSet", "invokeGet", "invokeGET"], "request": ["info", "project", "re", "QUEST", "forward", "each", "http", "setup", "document", "url", "get", "reference", "raw", "version", "quest", "worker", "store", "address", "client", "question", "message", "the", "change", "post", "context", "reset", "report", "call", "req", "begin", "enter", "transform", "select", "application", "construct", "controller", "order", "local", "create", "relative", "search", "input", "position", "core", "instance", "server", "index", "query", "first", "remove", "frame", "xml", "model", "initial", "requ", "Request", "hello", "subject", "open", "handle", "command", "complete", "attribute", " Request"], "response": ["os", "re", "http", "resp", "onse", "default", "success", "ce", "message", "context", "image", "connection", "report", "print", "write", "out", "respond", "one", "application", "res", "respons", "output", "page", "reply", "render", "server", "Response", "body", "next", "frame", "description", "xml", "view", "status", "result"], "path": ["full", "project", "hex", "text", "ath", "dir", "where", "pkg", "url", "base", "prefix", "value", "check", "system", "name", "p", "uri", "print", "log", "patch", "temp", "route", "transform", "th", "select", "mount", "test", "output", "location", "relative", "title", "string", "pattern", "template", "dest", "query", "Path", "config", "key", "filename", "chain", "prop", "PATH"], "file": ["full", "bar", "File", "null", "upload", "ile", "binary", "FILE", "disk", "link", "run", "table", "document", "rule", "object", "base", "be", "e", "valid", "check", "fe", "name", "port", "resource", "bo", "image", "to", "library", "bool", "f", "spec", "report", "source", "console", "user", "output", "local", "page", "tree", "load", "real", "word", "le", "relation", "mail", "db", "form", "model", "view", "chain", "channel", "job", "lock", "key", "ca", "filename", "handle", "result"], "in": ["gin", "pic", "read", "sample", "thin", " din", "mc", "up", "cin", "it", "on", "or", "ini", "inn", "ind", "mn", "ins", "s", "l", "rin", "ic", "reader", "kin", "inc", "out", "al", "source", "one", "IN", "mm", "copy", "en", "bin", "isin", "inner", "ck", "con", "input", "again", "sin", "din", "asin", "sum", "i", "cm", "as", "is", "and", "In"]}}
{"id1": "8468859", "id2": "8801436", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["join", "process", "dial", "exit", "link", "setup", "close", "pen", "register", "check", "ready", "client", "connection", "error", "login", "ping", "log", "sync", "conn", "Connect", "connected", "request", "bind", "select", "construct", "set", "create", "start", " disconnect", "init", "timeout", "establish", "con", "network", "config", "attach", "match", "open"], "status": ["join", "details", "usage", "sc", "update", "gc", "params", "url", "score", "prefix", "version", "sort", "check", "settings", "scale", "list", "use", "sequence", "summary", "ping", "login", "spec", "print", "content", "sync", "service", "flags", "comments", "source", "str", "code", "console", "sign", "output", "stat", "title", "search", "ssl", "style", "severe", "json", "access", "impact", "description", "comment", "xml", "policy", "format", "stats", "display", "uses", "result"], "reply": ["ret", "record", "answer", "link", "consider", "close", "repl", "back", "prefix", "success", "part", "error", "address", "message", "ply", " Reply", "flag", "feature", "write", "number", "code", "user", "state", "continue", "vote", "notice", "Reply", "next", "query", "frame", "comment", "match", "py", "response", "job", "time", "nb", "command", "result"], "isConnected": ["issConnecteded", "issConnected", "isConnecteds", "IsConnectioned", "isAdapteds", " isConnects", "isConnectioned", "isConns", "isStarted", "isLoading", "issConnectioning", "isNECTedIn", "isStarting", "isLinkED", "isProcessed", "IsNECTed", "isConnects", "isAdapts", "isNECTing", " isLoads", "isPresentedIn", " isConnecteds", " isLoadeds", "isProcessedIn", "isConnED", "isCorrecteds", "isPresented", "issConnectionedIn", "IsConnections", "isCorrecting", "isConnectured", "isConnectED", "IsConnectED", "isConnecteded", "isLinks", "IsConnectured", "isConned", "isAdapted", "isConnecting", "isPresenting", "isStartedIn", "isStartable", "IsNECTable", " isConnecting", "isCorrected", "IsConnected", "issConnectioned", "issConnectioneded", "isConnectable", "isConnectioning", "isConnections", "issConnecting", "isPresenteded", "IsConnectionED", "issConnectedIn", "IsConnects", "isProcessing", "isConnectionured", "isStarteded", "IsNECTing", "isLoads", "isConnured", "IsConnectedIn", "isProcessable", "IsConnectable", "isNECTable", "IsConnecting", "IsNECTedIn", "isLoadeds", "isConnectioneded", "isAdapting", "isLinkured", " isLoading", "isLoaded", "isLinked", "isCorrects", " isLoaded", "isConnectionED", "isConnectedIn", "isNECTed", "IsConnectionured", "isConnectionedIn"]}}
{"id1": "21488868", "id2": "9347451", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToDisk", "encodeStringToFiles", "encodeStringAsFile", "encodeStringToFile", "encodeStringAsStream", "encodeFiletoDisk", "encodeStringToStream", "encodeFiletoFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileAsStream", "encodeFileAsFiles", "encodeFiletoFiles", "encodeStringAsFiles", "encodeFileFromFile", "encodeFileAsFile", "encodeFileFromDisk", "encodeFiletoStream", "encodeStringAsDisk", "encodeFileToStream", "encodeFileAsDisk", "encodeFileFromFiles", "encodeFileToFiles"], "infile": ["Inbase", "inpath", "outFile", "outfilename", "InFile", "outpath", " infilename", "Infile", " inbase", "inFile", "inputFile", "inbase", " inFile", "inputpath", "infilename", " inpath", "inputfile", "inputfilename", "Inpath", "outbase"], "outfile": ["outfp", " outname", "infp", "outFile", "newname", "outfilename", "newfilename", "inname", " outFile", "fromFile", "outname", "todir", "outdir", "inFile", " outfilename", "newFile", "fromdir", "tofp", "indir", "fromfp", "tofile", "infilename", "fromfile", "toFile", "newfile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "image", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "ro", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "up", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "total", "variable", "document", "length", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "cache", "number", "temp", "queue", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "attribute", "append"], "read": ["before", "each", "text", "send", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", "ok", "submit", "ratulations", " succ", "condition", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "ith", " Success", "summary", "primary", "commit", "positive", "surv", "same", "good", "safe", "complete", "continue", "second", "sufficient", "democracy", "town", " okay", "warning", "unity", "please", " successes", "first", "support", "city", " successful", "ceed", "fail", "response", "successfully", "status", "result", "crit", "accept"]}}
{"id1": "692738", "id2": "7499186", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["pl", "domain", "sql", "bel", "ur", "http", "link", "b", "ld", "un", "path", "ref", "ls", "get", "base", "gl", "util", "default", "address", "name", "resource", "uri", "l", "log", "sl", "r", "nl", "rl", "cl", "q", "term", "str", "mount", "impl", "location", "string", "ssl", "page", "pattern", "char", "Url", "web", "config", "el", "html", "xml", "external", "file", "loc", "job", "dl", "ll", "key", "URL", "browser"], "in": ["gin", "m", "null", "include", "read", "nin", "update", " din", "c", "oin", "mc", "o", "mi", "In", "cin", "line", "on", "check", "inn", "name", "min", "ins", "login", "l", "rin", "f", "s", "reader", "ai", "out", "al", "source", "n", "ln", "IN", "from", "init", "en", "isin", "bin", "inner", "con", "input", "again", "din", "body", "ma", "i", "online", "is", "serv", "vin"]}}
{"id1": "4973095", "id2": "19652200", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "label": 0, "substitutes": {"url": ["pl", "bad", "lr", "ur", "null", "u", "hl", "http", "email", "link", "ld", "https", "util", "ls", "base", "gl", "lim", "open", "ado", "au", "cp", "build", "address", "connection", "ol", "l", "log", "uri", "sl", "r", "nl", "print", "rl", "conn", "cl", "io", "str", "org", "out", "impl", "mount", "hub", "www", " URL", "location", "ssl", "string", "con", "Url", "web", "mail", "html", "el", "iol", "ob", "xml", "file", "ll", "loc", "lb", "dl", "job", "parser", "URL", "browser"], "f": ["full", "t", "w", "fn", "b", "j", "df", "tif", "c", "fp", "F", "h", "o", "stream", "bf", "fort", "fb", "ff", "p", "v", "y", "s", "log", "l", "fl", "sf", "out", "fo", "n", "fs", "cf", "fc", "lf", "fac", "i", "fr", "form", "file", "fd", "fi", "tf", "fa", "d"], "by": ["re", "bad", "each", "buff", "b", "where", "how", "it", "y", "report", "BY", "with", "io", "of", "out", "By", "g", "you", "from", "using", "bin", "ly", "via", "then", "sys", "as", "reg", "serv", "por", "ody", "browser", "fully"], "uc": ["nc", "ud", "auc", "tc", "u", "sc", "cas", "cmp", "stud", "oc", "gc", "nic", "ec", "c", "rc", "uci", "mc", "lc", "usc", "soc", "uh", "chu", "cc", "uch", "ucc", "asc", "userc", "uu", "ocr", "cur", "cl", "ux", "ub", "unc", "uca", "anc", "fc", "pc", "cu", "con", "ul", "UC", "eu", "loc", "roc", "bc", "ac", "cus"]}}
{"id1": "17773263", "id2": "6756635", "code1": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"visar": ["visatar", " visa", "Visar", "Visitado", "Visa", "Visitar", "Visado", " visatar", "Visita", "visa", "Visitatar", "Visatar"], "ClassNotFoundException": ["ClassNotPresentError", "ClassNotfoundException", "ClassDefPresentError", "ClassDefFoundException", "ClassDefFoundError", "ClassNotfoundError", "ClassNotSupportedException", "ClassDefPresentException", "ClassNotFoundError", "ClassNotPresentException", "ClassNotSupportedError"], "Exception": ["File", "Operation", "Event", "Throw", "Message", "Configuration", "Connection", " exception", "Error", "Application", "None", "Example", "E", "Index", "Array", "Document", "Class", "Warning", "Context", "Result", "Status", "Instance", "Record", "Handler", "Exit", "ception"], "conn": ["nc", "cn", "sql", "exec", "ec", "gate", "c", "close", "ch", "coll", "pen", "open", "gn", "cc", "ct", "pg", "socket", "cp", "ns", "Con", "Connection", "connection", "p", "client", "sp", "can", "obj", "wp", "yn", "Conn", "enc", "cur", "wr", "org", "js", "n", "res", "rel", "cmd", "txt", "rs", "ctx", "en", "comm", "con", "jp", "conf", "nt", "conv", "irm", "oss", "db", "config", "pool", "connect", "ann", "co", "ran", " con", "ont", "cons", "cert", "fin"], "ps": ["pl", "ms", "pos", "pps", "eps", "aps", "pd", "bs", "pp", "fp", "ples", "vs", "Ps", "PS", "ls", "css", "ups", "points", "its", "ips", "pg", "pas", "sp", "cp", "ies", "uts", " pp", "p", "ts", "cs", "amps", "s", "itions", "ress", "ins", "pins", "ping", "proc", "ats", "gs", "js", "fs", "pers", "res", "pe", "als", "rs", "pc", "pa", "sts", "gres", "ports", "jp", "ys", "ops", "ims", "ends", "pse", "pr", "pres", "posts", "plays", "stats", "mp", "fps", "wp", "qs", "pt"], "fechaSystem": ["fetchoBase", "fachaServer", "fechoaServer", "fechasSystem", "fechaSTEM", "fechaeServer", "fechaServer", "fechasBase", "fetchaSystem", "fachoaSystem", "fetchaBase", "fetchoServer", "fechoSys", "fachaSys", "fechoaProcess", "fechoaSys", "fetchoSystem", "fechasSys", "fetchoSys", "fespoaProcess", "fechsaProcess", "fespoaSystem", "fechoaSystem", "fespaProcess", "fechoBase", "fechoSTEM", "fechaeSystem", "fechaBase", "fechaProcess", "fechoaSTEM", "fachoaSys", "fespaSTEM", "fachoaServer", "fechABase", "fechoServer", "fetchaSys", "fachaSystem", "fetchaServer", "fechaeSys", "fechasServer", "fespaSystem", "fechASystem", "fechaSys", "fechoSystem", "fechASys", "fechsaSTEM", "fechsaSystem", "fespoaSTEM", "fechoProcess"], "aaaammdd": ["aaaaammd", "aaaambss", "aaaammds", " baammd", "aaaaammde", " baambds", "aaaambdd", "aaalammmm", "aaapmd", " baammdd", "aaaammss", "aaaammm", "aaapmds", "aaaaamde", "aaaaamd", "aaaamde", " baambss", "aaaammmm", "aaaamds", "aaaammde", "aaalammde", "aaalammd", "aaapmdd", "aaaamd", "aaaaumde", "aaaaummm", "aaaaumd", "aaaambd", "aaaammd", "aaaamdd", "aaaaamdd", " baammds", "aaaaammm", " baambd", "aaaamss", "aaapmss", "aaaaammdd", "aaaaumdd", "aaalammdd", " baammss", " baambdd", "aaaambds", "aaaaammmm"], "hhmmss": ["hhmys", "ohmmss", "hhtmss", "hhmmrss", "hhtmcss", "hhmmcss", "hhmms", "hhmmess", "hhmbess", "ohtmcss", "hhmmmms", "hhmmms", "ohtmess", "hhMMss", "HHMMrss", "hhmbms", "hhtmms", "hhmyss", "HHMMss", "hhmmmss", "hhmyrss", "hhtmess", "ohmmms", "hhMMps", "ohmmess", "hhmmmps", "hhmmmcss", "hhmmmrss", "HHmmps", "hhMMrss", "ohtmms", "hhmmps", "hhmyps", "ohmmcss", "hhmbcss", "hhmbss", "hhmmmess", "HHMMps", "hhMMs", "HHmmss", "HHmmrss", "HHmms", "HHMMs", "ohtmss"], "sss": [" ssls", "\u00dfd", "yssy", "rssis", "essls", "ssh", "ysss", "\u00dfs", "rssd", "ssis", "esss", "essys", "csss", "ssy", "\u00dfh", "\u00dfis", "cssis", "rssh", "ssys", " ssy", "cssh", "ssd", "yssys", "yssls", "cssd", "ssls", "rsss", "essy", " ssys"], "ss": ["dd", "styles", "ms", "sql", "less", "os", "tz", "tt", "pps", "bs", "aws", "ssh", "https", "ws", "ls", "css", "SS", "se", "tis", "esi", "sq", "ns", "iss", "es", "cs", "ts", "ews", "s", "ping", "sf", "ses", "sol", "sd", "js", "sv", "course", "\u00df", "sy", "rs", "good", "sb", "rss", "ssl", "string", "ds", "hess", "ys", "oss", "pres", "ass", "sys", "html", "bytes", "ess", "stats"], "sentenciaSql": ["sentenciaInsql", "sentenceSsql", "sentenciaSourceq", "sentenciaSq", "sentenciaInssql", "sentenciaDeed", "sentenciaSeed", "sentenciaDel", "sentenciaSQL", "sentenzaSq", "sentenciaStringq", "sentenceSql", "sentenzaInseed", "sentenciaStringQL", "sentenciaInsQL", "sentenzaSeed", "sentenciaSel", "sentenceSq", "sentenciaStringsql", "sentenciaDql", "sentenciaInsel", "sentenciaSsql", "sentenciaSourceel", "sentenciaInseed", "sentenzaSel", "sentenciaStringql", "sentenzaInsel", "sentenceSQL", "sentenciaSourceeed", "sentenciaSourceql", "sentenciaDq", "sentenzaInsq", "sentenzaSql", "sentenciaInsq", "sentenzaInsql"], "contador": ["controlarter", " contarter", "intadr", " container", " contorno", " contamo", "contactator", "\u00e7orno", "ontdoor", "montamo", "intpointer", "constator", "controlarer", "intador", " contoffer", " contdoor", "controlator", "CONTamina", "constdoor", "colabo", " Contpointer", "ontador", "contactarter", "contactador", "portainer", " contrane", "contano", "ontamo", "\u00e7offer", "colator", "colainer", " Contator", "constoffer", "contorno", "frontamo", "ontrane", "CONTator", " contpointer", "contamina", "contactarer", "portabo", "\u00e7ano", "contator", " Contamina", "CONTador", "portator", "frontator", " contadr", "constrane", "constpointer", "contrane", " contano", " contator", "montadr", "frontador", "CONTpointer", "ontarer", "ontator", "constorno", "montador", "frontarter", "constadr", "ontarter", "portador", "contdoor", "colador", " contamina", "constainer", "contadr", "contarer", "constador", "contoffer", "contarter", "constano", "montator", "contabo", "\u00e7ador", "intainer", "ontadr", " Contador", "container", " contabo", "controlador", "contpointer", "contamo"], "visado": ["visando", "Visado", " visitando", " visitados", "Visada", " visitada", " visitado", " visando", " visada", "Visando", " visados", "visada", "Visados", "visados"]}}
{"id1": "6403868", "id2": "1357662", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUninstallItems", "extractUninstallFile", "extractUnpackFile", "extractUnpackFiles", "extractunInstallFile", "extractUnInstallFiles", "extractuninstallFiles", "extractuninstallFile", "extractUnpackItems", "extractunInstallItems", "extractUnInstallItems", "extractUnInstallFile", "extractuninstallItems", "extractunInstallFiles"], "_destPath": ["_destPoint", "_destDir", "_tempPoint", "_destTh", "_combFormat", "_privTh", "_restDir", "_restPath", "_DestKey", "_destKey", "_srcPath", "_DestDir", "_tempFormat", "_tempTh", "_DestPath", "_DestPoint", "_privPath", "_DestTh", "_sourcePath", "_restKey", "_privPoint", "_restPoint", "_privDir", "_tempDir", "_sourceFormat", "_sourceDir", "_destFormat", "_srcPoint", "_srcKey", "_combPath", "_srcDir", "_tempPath", "_combDir"], "upgrade": ["upchange", "upate", "equcp", " upchange", "upcheck", "ungrade", " upgrad", " upgrades", "exgrade", "equgrade", "downgrade", " upate", "unate", "equgrad", "equate", "exchange", "downchange", " upcheck", "upgrad", "downcheck", "excheck", "upcp", "ungrad", "exgrades", " upcp", "downgrades", "uncp", "upgrades"], "lastVer": ["LastVer", "nextVers", "lastRes", "oldVersion", " lastVersion", "nextServ", " lastRes", "latestVers", "LastVers", " lastver", "LastVersion", "latestServ", "latestVer", "nextRes", "lastVersion", "oldVers", "lastServ", " lastVers", "nextVer", "Lastver", "oldVer", "lastver", "lastVers", "latestRes", " lastServ", "oldver"], "oldlog": ["olderpath", " oldpath", "Oldpath", "olderr", "OldLog", "oldpath", "oldererr", "olderlog", " oldog", " olderr", "Oldog", "OLDpath", "Oldlog", "olderLog", "oldLog", " oldLog", "OLDlog", "OLDLog", "olderog", "oldog", "OLDerr", "OLDog"], "destPath": ["restDir", " destPoint", "DestStream", "descKey", "originTh", "locDisk", "altParent", " destFile", "destParent", "estPos", "estName", "gestTime", "altPath", "srcPath", " destTh", "privPos", "estRef", "destRef", "identPoint", "restFile", " destKey", "destNet", "altPoint", "srcFile", "gestNode", "DestFont", "privRoot", "DestDir", "srcPort", "declDir", "foreignDir", "DestName", "destPoint", "altNode", "gestName", "originPoint", "originPort", "destDir", " destRef", "destPos", "declFont", "identPort", "DestPath", "destTh", "destNode", "DestFull", "destTime", " destPos", "DestDirectory", "gestPath", "destDirectory", "destFile", "altName", "descNet", "sortFull", "destFull", " destRoot", "gestNet", "DestRef", "destLog", "sortPath", "estDir", "destRoot", "destHost", "gestDisk", " destHost", "altHost", "DestFile", "descPath", " destParent", " destDirectory", "DestPod", "potPod", "destDisk", "destFont", "descName", "descDisk", "restPoint", "altDir", "privPath", "DestLog", "DestPoint", "foreignPath", " destDir", "restPath", "potPath", "DestPos", "srcLog", "locTime", "estPath", "destStream", "locNet", "identTh", "sortFont", "DestRoot", "DestParent", "privDir", "locPath", "destPod", "declFull", "destName", "potStream", " destPort", "descPos", " destNode", "destPort", "foreignPod", "destKey", "declPath", "gestHost", "srcDirectory", "descTime", "sortDir", "foreignStream", "potDir", "originPath", "identPath", "estKey", "srcDir", " destLog", " destName", "DestPort"], "lastVerPath": [" lastVerDir", "lastVerDir", " lastVerpath", "lastVersVal", " lastVerName", "lastResForm", "lastVersionPath", "lastVersLog", "lastVERFile", "lastverCh", "lastVersPath", "lastVersName", "lastVERpath", "lastverpath", "highestVERVal", "lastVERDir", "lastVERVal", "lastVerLog", " lastVersPath", "lastVerForm", "lastverDir", " lastVerCh", " lastVersFile", "lastVersFile", " lastverForm", "lastVersionFile", "highestVERPath", "lastVERPath", "lastverVal", "lastverName", " lastverpath", "lastverLog", " lastVersCh", "lastverPath", " lastverDir", "lastVerCh", "lastVersionpath", "highestVERpath", "lastVerspath", "lastRespath", " lastVerFile", "highestVerPath", "lastVersionCh", "highestVerFile", " lastverPath", "highestVerVal", " lastVerLog", "lastVerVal", "highestVERFile", "lastverFile", "lastResPath", "lastVerFile", "lastVerpath", "lastVERForm", "lastResDir", "lastVersCh", " lastVerForm", " lastVersLog", "lastVerName", "lastverForm", "highestVerpath"], "bkdir": ["blkdi", "bukDIR", " bkfolder", "bkkpath", "blkjdi", " bkkDir", "bukdi", " bakdi", "bkjdi", "BckDir", "blkdir", "bkgdir", "bkjdir", "bckDIR", "blkjdir", "bkrel", " bakfolder", "bckfolder", "bkgfolder", "bakdir", "blkjfd", "blkjgroup", "bkdi", " bkkdir", "bkkDIR", "bkkrel", "BkDIR", "blkgroup", "bqfd", "bkjfd", "bckdir", "bkgDir", "Bkpath", " bakDir", "bakrel", "bukgroup", "bakDir", "Bkdir", "bukdir", "BckDIR", "bkkDir", "bckDir", "bkkdi", "bqdir", "bkgrel", "blkfd", " bkkrel", "bkDir", "bkfolder", "bakfolder", "bqgroup", "bukpath", "bkkfolder", "bqdi", " bkkfolder", "Bckdir", "bckdi", "bkgroup", "bkDIR", "bakdi", "bkjgroup", " bkDir", "Bckpath", " bkdi", "bkpath", " bkrel", "bckpath", "bkkdir", "BkDir", " bakdir", "bkfd", "bukfd", "bukDir"], "oldClassCopied": ["oldClassCopyie", "oldclassCopies", "oldClassCopaced", "oldClassCopiated", "oldClassColied", "oldClassCopie", "oldClassReplried", "oldClassCopyified", "oldclasscopied", "oldClassChried", "oldclassCopied", "oldClasscopified", "oldClassColified", "oldclassCopie", "oldClasscopied", "oldDirReplried", "oldClassChiated", "oldclasscopified", "oldDirReplied", "oldClasscopried", "oldDirReplies", "oldClassChied", "oldClassCopified", "oldClassCopyies", "oldDirCopies", "oldClassColaced", "oldDirCopried", "oldClassCopies", "oldclassCopified", "oldClassCopried", "oldClassReplied", "oldClassReplaced", "oldClassReplified", "oldclasscopie", "oldclassCopaced", "oldDirCopiated", "oldClasscopies", "oldClassCopyied", "oldDirCopied", "oldclasscopies", "oldDirRepliated", "oldClassChies", "oldClasscopiated", "oldClassColies", "oldClassRepliated", "oldClassReplies", "oldClasscopie"], "ls": ["tl", "ms", "less", "ils", "lbs", "bs", "vs", "els", "LS", "ws", "lis", "lc", "its", "sels", "es", "ns", "ists", "cs", "ts", "l", "acts", "rl", "lines", "gs", "lv", "ats", "les", "fs", "la", "ln", "los", "rs", "ols", "ds", "ks", "ics", "lf", "las", "lt", "irs", "xs", "abs", "ars", "dl", "qs", "ps", "lists"], "i": ["ji", "m", "iq", "ci", "u", "im", "phi", "j", "b", "gi", "gu", "qi", "ii", "fire", "I", "us", "mi", "oi", "a", "batch", "ti", "key", "pi", "it", "di", "ini", "ui", "ski", "zi", "id", "hi", "y", "multi", "ic", "l", "io", "x", "me", "bi", "ip", "cli", "init", "si", "ij", "ki", "ri", "index", "sim", "li", "ix", "xi", "ami", "eu", "is", "ims", "ei", "chain"]}}
{"id1": "8216539", "id2": "15445861", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileTextAsString", "getFileContentasString", "getFileTextAsText", "getFileContentAsStr", "getFileContentasText", "getFileTextAsStr", "getFileContentasStr", "getFileContentAsText"], "filePath": ["baseName", "filePATH", " fileInfo", "FileString", "fileName", "fileDef", "baseString", "basePath", " fileName", "entryPATH", "FILEpath", "ileInfo", " fileDef", "FILEName", " fileString", "ilePath", "basepath", "FILEPath", "FilePATH", "FileInfo", "FilePath", "fileInfo", "filepath", "entrypath", "FileDef", " filepath", "FileName", "entryPath", "ileDef", "entryName", "FILEPATH", "Filepath", "ileName", "fileString"], "encoding": ["ENCordering", "Encoding", "enoding", "unicode", "characteraching", "unicoding", "ENCaching", "enode", "Encuing", "encging", "ENCging", "encuing", "Encging", "characteroding", "ENCoding", "Encode", "characterging", "encordering", "unicuing", "enuing", "Encordering", "characterordering", "Encaching", "unicaching", "encaching", "enaching", "encode"], "testURL": ["checkURL", " testRE", "testedUrl", "TestURL", "TestUrl", "testedRE", "checkUrl", "testingURL", "testRE", "testUrl", "TestUR", " testUrl", "testedUR", "testingSR", "checkUR", "testingUrl", " testSR", "testingUR", "testingRE", "testSR", " testUR", "checkSR", "testUR", "testedURL", "TestSR"], "input": ["empty", "get", "up", "add", "address", "context", "can", "op", "cur", "from", "pull", "init", "eval", "json", "qa", "channel", "hello", "feed", "active", "sample", "unsigned", "submit", "it", "raw", "client", "q", "source", "act", "config", "xml", "form", "view", "open", "acl", "command", "PUT", "in", "read", "audio", "batch", "list", "iterator", "quick", "iter", "ip", "current", "lat", "tmp", "file", "upload", "exec", "cont", "url", "has", "stream", "image", "focus", "reader", "quit", "hidden", "Input", "output", "start", "missing", "inner", "exist", "comment", "data", "accept"], "sw": ["was", "hw", "tw", "sc", "w", "sem", "wh", "Sw", " Sw", "fw", "ws", "su", "aw", "rew", "sh", "sp", "ow", "ews", "ows", "sl", "sf", "enc", "iw", "sm", "wr", "kw", "sv", "ew", "sb", "sn", "igm", "sa", "SW", "wn", "wra", "wo", "wl", "sk", "wa", "sur", "nw", "we"]}}
{"id1": "13362846", "id2": "481364", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"setContenu": ["setContennux", "setcontensenux", "setcontensenu", "setcontensenU", "setcontenu", "setContenux", "setContensenux", "setContennu", "setContenue", "setCont\u00ednu", "setContennU", "setContensenu", "setContenU", "setcontenue", "setContennue", "setcontenU", "setCont\u00ednue", "setCont\u00ednU", "setCont\u00ednux", "setContensenU", "setcontenux", "setContensenue", "setcontensenue"], "contenuFichier": ["contenuMicheaire", "contenuFithiere", "contenuFochiere", "contenuFamilyachiere", "contenuVichiere", "contenuFichiest", "contenuFigner", "contenuFichaire", "contenuFileichie", "contenuFihiest", "contenuFiverier", "contenuFicheer", "contenuFolfier", "contenuFihiere", "contenuFechyr", "contenuFignaire", "contenuFrenchire", "contenuFsechier", "contenuFechiest", "contenuFochiers", "contenuFsichire", "contenuFrenchier", "contenuFicheaire", "contenuFichire", "contenuFichorie", "contenuFsichieri", "contenuFachiere", "contenuFechier", "contenuFigniere", "contenuVchie", "contenuFsrenchaire", "contenuFamilyichorie", "contenuVechiere", "contenuFuffier", "contenuFicheiere", "contenuFichyr", "contenuFachiers", "contenuFochIER", "contenuFsichier", "contenuFileochiere", "contenuMichier", "contenuFichtiere", "contenuFCher", "contenuFichiere", "contenuFicheire", "contenuFachie", "contenuFochie", "contenuFochier", "contenuFChaire", "contenuVchIER", "contenuVechiest", "contenuFChiere", "contenuVechyr", "contenuFamilyichiere", "contenuVichyr", "contenuFsecher", "contenuFolfer", "contenuFsichaire", "contenuFrenchieri", "contenuFechiere", "contenuFsrenchire", "contenuFechieri", "contenuFileichiere", "contenuFchiere", "contenuFamilyichier", "contenuFileichiers", "contenuVchier", "contenuFuffer", "contenuFuffieri", "contenuVichie", "contenuVchiere", "contenuFsrenchieri", "contenuFithorie", "contenuFecher", "contenuFrenchaire", "contenuFichiers", "contenuFichtie", "contenuFicheiers", "contenuFihier", "contenuFithie", "contenuFamilyachier", "contenuFichtier", "contenuVechier", "contenuVichiest", "contenuFileichier", "contenuFileochier", "contenuMicheier", "contenuFithier", "contenuFicheie", "contenuMichaire", "contenuFechire", "contenuVichier", "contenuFsicher", "contenuFicheieri", "contenuFsechire", "contenuFiverieri", "contenuFamilyichie", "contenuFolfire", "contenuFchIER", "contenuFileochie", "contenuFiveraire", "contenuFichIER", "contenuMicher", "contenuMicheer", "contenuFichieri", "contenuMicheiere", "contenuFiverire", "contenuFichtIER", "contenuFchier", "contenuFachorie", "contenuFchie", "contenuFicheier", "contenuVichIER", "contenuFsechieri", "contenuFithyr", "contenuFichie", "contenuFileochiers", "contenuFamilyachorie", "contenuFicheorie", "contenuFolfieri", "contenuFachier", "contenuMichiere", "contenuFChier", "contenuFamilyachie", "contenuFignier", "contenuFithiest", "contenuFuffire", "contenuFicher", "contenuFihyr", "contenuFsrenchier"], "fichierElectronique": ["fichierSelectronicity", "fichierElectradorie", "fichierSelectronique", "fichierelectreniques", "fichierElectoniques", "fichierTransferronius", "fichierSelectroneicity", "fichierSelectronoch", "fichierElectronicy", "fichierElectradorius", "fichierElectrenier", "fichierCentronicy", "fichierElectronsiques", "fichierElectroneie", "fichierElectroniq", "fichierTransferradoric", "fichierElectchronicy", "fichierElectronipolar", "fichierElectonique", "fichierElectrenius", "fichierElectriciques", "fichierElectchronicity", "fichierelectrenic", "fichierElectromie", "fichierElectrenique", "fichierElectricie", "fichierElectronoch", "fichierElectroneic", "fichierElectroneipolar", "fichierElectroneaire", "fichierElectromicity", "fichierelectrenier", "fichierElectradorique", "fichierCentRONaire", "fichierElectrenaire", "fichierTransferronic", "fichierElectronicity", "fichierElectchroniques", "fichierElectricique", "fichierElectromique", "fichierElectchronique", "fichierCentronique", "fichierCentronius", "fichierSelectroneique", "fichierElectriciq", "fichierElectronsier", "fichierElectronaire", "fichierSelectroniques", "fichierElectrenic", "fichierTransferradorie", "fichierElectromaire", "fichierElectromipolar", "fichierElectronsoch", "fichierElectronius", "fichierElectronier", "fichierCentronaire", "fichierAdministroneique", "fichierTransferradorique", "fichierCentRONicy", "fichierElectchronius", "fichierelectronier", "fichierElectRONaire", "fichierElectronsicity", "fichierAdministroneiq", "fichierCentRONique", "fichierElectRONique", "fichierelectrenique", "fichierElectchronoch", "fichierElectroneicity", "fichierTransferronique", "fichierElectrontique", "fichierElectroneoch", "fichierElectronsiq", "fichierElectronsique", "fichierelectronique", "fichierElectroneiq", "fichierElectroneius", "fichierElectreniques", "fichierElectronsie", "fichierAdministroneiques", "fichierElectromius", "fichierElectroniques", "fichierAdministroneie", "fichierTransferronie", "fichierTransferradorius", "fichierElectrontipolar", "fichierCentRONius", "fichierElectroneiques", "fichierElectonic", "fichierElectchronaire", "fichierElectronic", "fichierElectradoric", "fichierElectronticity", "fichierelectronic", "fichierElectrontaire", "fichierAdministroniq", "fichierElectromic", "fichierElectRONicy", "fichierElectroneique", "fichierAdministronie", "fichierElectrenicy", "fichierElectronie", "fichierElectonier", "fichierElectronsic", "fichierAdministroniques", "fichierelectroniques", "fichierAdministronique", "fichierSelectroneoch", "fichierSelectroneiques", "fichierElectRONius"], "utilisateurCourant": ["utilisateurGovernants", "utilisateurParticipant", "utilisateurCourante", "utilisateurParticipiant", "utilisateursCourante", "utilisateurRepresentante", "utilisateurGovernante", "utilisateursGovernants", "utilisateursGovernante", "utilisateursCourants", "utilisateurCourants", "utilisateurParticipante", "utilisateurRepresentants", "utilisateurRepresentiant", "utilisateurCouriant", "utilisateurGovernant", "utilisateurGoverniant", "utilisateurParticipants", "utilisateursGoverniant", "utilisateursCouriant", "utilisateurRepresentant", "utilisateursCourant", "utilisateursGovernant"], "support": ["evidence", "storage", "install", "null", "allow", "cap", "document", "supported", "prototype", "SUP", "success", " Support", "history", "media", "accept", "cover", "system", "use", "help", "context", "port", "library", "control", "trust", "feature", "service", "proof", "pport", "see", "profile", "replace", "language", "supp", "know", "share", "please", "access", "force", "format", "Support", "collection"], "ficheDocument": ["facheJournal", "fayeDocument", "fayeDoc", "flicheMatrix", "FicheDatabase", "frenchTransaction", "facheDoc", "facheTransaction", "ficidocument", "fitimeDocument", " frenchDatabase", "foyerTree", "facheTree", "FicheDocument", "fitimeDescription", "fliciDocument", "hicheDocument", "bacheDatabase", "frenchDescription", "ficiDatabase", "bicheDoc", "hachedocument", "bacheDoc", "frenchDatabase", "hacheJournal", "bicheDatabase", "hichedocument", "ficiDocument", " frenchDescription", "facheDatabase", "ficiJournal", "flicheTransaction", "frenchDocument", "frenchDoc", "fliciMatrix", "fitimeMatrix", "bicheDocument", "fruitTransaction", "hacheDocument", "fcheDocument", "facheDocument", "FicheDoc", "fcheDoc", "fiqueDocument", "ficheJournal", "FicheDocuments", "hicheJournal", "ficheMatrix", "fruitdocument", "fayeDatabase", "fruitJournal", "hacheTransaction", "flicheDatabase", "ficheDatabase", "fcheTree", " ficheDescription", "fitimeTransaction", "foyerDatabase", "ficheDocuments", "fcheDatabase", "bacheDocument", "ficiMatrix", "ficheTree", "hicheTransaction", "foyerDocument", "FayeDocuments", "bicheTree", "fruitDocument", " frenchDocument", "fifaDocuments", "fliciTransaction", "foyerDoc", "fichedocument", "fifaDoc", "fachedocument", "fliciDatabase", "bacheTree", "fifaDocument", "fayeDocuments", " ficheDatabase", "ficheTransaction", "ficheDescription", "ficiTransaction", "flicheDocument", "FayeDoc", "fifaDatabase", "fiqueDatabase", "fitimeDatabase", "fiqueDescription", "frenchDocuments", "FayeDocument", "frenchMatrix", "ficheDoc", "FayeDatabase"], "nomFichier": ["nomFichoier", "nomPFoililler", "nomUFichIER", "nomFcher", "nomFachancer", "nomFoilER", "nomFcherer", "nomFichoanger", "nomFichiere", "nomFihIER", "nomNichie", "nomFchiner", "nomNichiere", "nomUFichery", "nomPFichjer", "nomFericanger", "nomPichier", "nomNolfier", "nomPFichER", "nomFachiere", "nomUFichier", "nomPachier", "nomFicerer", "nomFicheie", "nomNolfiere", "nomFicheier", "nomFicherer", "nomFiliciller", "nomFiverIER", "nomFichancer", "nomFchier", "nomFicheiner", "nomUFichire", "nomFichER", "nomFolfier", "nomPFoilER", "nomFihery", "nomFolfie", "nomFichIER", "nomFachier", "nomFichire", "nomNolfie", "nomFicher", "nomNichire", "nomFilicER", "nomFachiner", "nomFichery", "nomFicjer", "nomFicER", "nomFchiere", "nomFicire", "nomFihire", "nomFachery", "nomFicheire", "nomPachomer", "nomFiverier", "nomFiverire", "nomFericancer", "nomFilicjer", "nomFichanger", "nomPFoilier", "nomFachire", "nomFiverery", "nomFilicier", "nomFachIER", "nomFicier", "nomUFachery", "nomNichier", "nomFichoIER", "nomFichjer", "nomFicheiere", "nomFoililler", "nomUFachire", "nomFoiljer", "nomPichomer", "nomFchomer", "nomFacher", "nomFachie", "nomFolfiere", "nomPichire", "nomFericier", "nomPachire", "nomFachomer", "nomPFoiljer", "nomFichiner", "nomUFachIER", "nomFachanger", "nomFichoancer", "nomPacherer", "nomFicomer", "nomPFichier", "nomNolfire", "nomFichie", "nomFiciller", "nomFihier", "nomFacherer", "nomFicheer", "nomFericIER", "nomUFachier", "nomPFichiller", "nomFichomer", "nomFolfire", "nomFoilier", "nomFichiller", "nomPicherer", "nomFchire"], "extension": ["Extension", "Extensions", "expitude", "extitude", "strension", "extractor", "expractor", "contention", "protension", "protention", "strensions", "Extending", "expension", "xtension", "xtending", "protitude", "extention", "contractor", "protractor", "xtensions", "extensions", "expention", "strending", "contension", "extending", "contitude"], "fichierElectroniqueExistant": ["fichierElectroniquePersistent", "fichierElectronoguePersistant", "fichierElectronogramExclusive", "fichierElectroniqueExistance", "fichierElectronogramExistent", "fichierElectroniqueInert", "fichierElectroniqueInclusive", "fichierElectronogramLocalistance", "fichierElectroniqueExister", "fichierElectroniqueAssistance", "fichierElectroniquePlusistant", "fichierElectronicityInistant", "fichierElectronoguePersiker", "fichierElectroniqueExplert", "fichierElectroniqueAssistant", "fichierElectroniqueLocalclusive", "fichierElectronogueExistant", "fichierElectroniqueExplistant", "fichierElectroniqueInvant", "fichierElectroniqueExplvant", "fichierElectronoguePersister", "fichierElectronicityInert", "fichierElectroniquePersistant", "fichierElectronicityInvant", "fichierElectroniqueInistent", "fichierElectroniqueAssclusive", "fichierElectroniquePresentiker", "fichierElectroniqueLocalistance", "fichierElectroniqueExclusive", "fichierElectroniquePresentister", "fichierElectroniqueExiker", "fichierElectronogramLocalclusive", "fichierElectronicityExert", "fichierElectroniqueEXistant", "fichierElectroniqueEXert", "fichierElectronicityInistance", "fichierElectronicityExvant", "fichierElectronicityExistant", "fichierElectronicityExistance", "fichierElectroniquePresentistant", "fichierElectroniquePlusister", "fichierElectronogramExistant", "fichierElectroniqueAssistent", "fichierElectroniquePersiker", "fichierElectroniqueInistance", "fichierElectronogramLocalistent", "fichierElectroniquePersister", "fichierElectronoguePersistent", "fichierElectroniqueEXvant", "fichierElectroniqueEXistance", "fichierElectronogramLocalistant", "fichierElectronogueExiker", "fichierElectroniquePresentistent", "fichierElectroniqueExvant", "fichierElectroniqueExert", "fichierElectroniquePlusistent", "fichierElectroniquePlusiker", "fichierElectroniqueInistant", "fichierElectronogramExistance", "fichierElectroniqueLocalistent", "fichierElectronogueExister", "fichierElectroniqueLocalistant", "fichierElectroniqueExplistance", "fichierElectroniqueExistent", "fichierElectronogueExistent"], "idIgid": ["idIgida", "idIgdoid", "idIgzida", "idIkglimit", "idIkgid", "idIgzid", "idIvgkey", "idIgoid", "idIgdata", "idIIgido", "idIIgida", "idIgids", "idIegdata", "idIvgdata", "idIgis", "idIigmid", "idIigmaddress", "idIigmis", "idAglimit", "idImglimit", "idIgcoid", "idIgzido", "idIIgzido", "idImgids", "idIegkey", "idIgido", "idImgaddress", "idIgaddress", "idIgkey", "idIIgoid", "idAgaddress", "idIkgis", "idImgkey", "idImgis", "idAgis", "idIglimit", "idIgzoid", "idIgcido", "idIIgzida", "idIgcid", "idAmgid", "idAmgaddress", "idIgdido", "idIvgid", "idIegid", "idIIgid", "idAmgis", "idImgdata", "idAmglimit", "idIIgzoid", "idIgdida", "idIgcida", "idIIgzid", "idIkgaddress", "idIigmlimit", "idIgdid", "idIvgids", "idAgid", "idIegids", "idImgid"], "inputStream": ["imageStream", "InputLoop", "InputThread", "outputSteam", " inputstream", "helloSteam", "inputThread", " inputLoop", "helloStreamer", "InputTime", "inputLoop", "outputstream", "inputSteam", "inputStreamer", "helloStream", " inputSteam", "inputTime", " inputChannel", " inputThread", "inputstream", "InputSteam", " inputTime", "imageLoop", "inputChannel", "outputChannel", "outputStreamer", "imageSteam", "InputStream", "helloChannel", "Inputstream", "imageTime", " inputStreamer", "outputThread"], "outputStream": ["sequenceStyle", "outputForm", "sequenceSteam", "outputSteam", " outputStyle", "writeStream", "webStreamer", "OutputStream", "writeForm", "inputSteam", "sequenceStreamer", "OutputStreamer", "webStream", "OutputStyle", "OutputForm", "inputView", "webView", "sequenceStream", "writeSteam", "writeView", "OutputView", " outputStreamer", "OutputSteam", " outputView", "webSteam", "outputView", "outputStyle", "outputStreamer", " outputSteam", "inputForm"], "typeMime": ["typemIME", "typeRime", "typemim", "typeSmIME", "typeSmim", "Typemme", "TypeMme", "typeRme", "TypeMime", "typeSmime", "TypeMIME", "TypemIME", "typeMme", "TypeMim", "typeMIME", "typemime", "typeSmme", "typeRIME", "typemme", "typeRim", "typeMim", "Typemim", "Typemime"], "tailleFichier": [" tailleFuzzier", " tailleFicheies", " tailleficheie", " tailleFuzzie", " taillefichiers", " tailleFicheiers", " tailleFixiers", " taillefichies", " tailleFicheier", " tailleficheier", " tailleficheiers", " tailleFichies", " tailleficheies", " taillefichier", " tailleFixier", " tailleFichie", " tailleFuzzies", " tailleFicheie", " tailleFixies", " tailleFuzziers", " tailleFichiers", " tailleFixie", " taillefichie"]}}
{"id1": "1508930", "id2": "5632808", "code1": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"httpRequestByPOST": ["httpRequestbypost", "httpGetbyGET", "httpRequestViaPOST", "httpGetbypost", "httpRequestbyPOST", "httpRequestWithPost", "httpRequestByPost", "httpRequestWithpost", "httpGetByGET", "httpGetByPOST", "httpRequestWithGET", "httpGetbyPost", "httpRequestByGET", "httpGetbyPOST", "httpRequestbyPost", "httpRequestWithPOST", "httpRequestViapost", "httpRequestBypost", "httpRequestViaGET", "httpGetBypost", "httpRequestViaPost", "httpRequestbyGET", "httpGetByPost"], "url": ["ret", "pl", "join", "domain", "ur", "api", "http", "href", "path", "ref", "ls", "host", "base", "address", "id", "name", "uri", "l", "k", "call", "request", "str", "method", "location", "ssl", "string", "pattern", "Url", "web", "loc", "ll", "remote", "format", "key", "dl", "URL"], "timeout": ["Timeout", "length", "mode", "period", "amount", "sleep", "batch", "version", "seconds", "port", "password", "number", "padding", "method", "ssl", "body", "wait", "delay", "pool", "size", "type", "format", "time", "duration", "max", "blocking"], "params": ["styles", "details", "packages", "pps", "pos", "actions", "forms", "pi", "settings", "media", "list", "Par", "p", "values", "spec", "AMS", "pins", "padding", "param", "Parameters", "mm", "objects", "keys", " parameters", "properties", "photos", "terms", "query", "changes", "ams", "parts", "posts", "names", "data", "mas", "images", "tags", "ps"], "response": ["answer", "null", "resp", "document", "object", "onse", "success", "block", "value", "version", "address", "message", "yes", "sequence", "connection", "report", "reset", "content", "service", "request", "respond", "example", "application", "respons", "output", "relative", "complete", "string", "all", "reply", "template", "network", "Response", "body", "next", "relation", "json", "frame", "description", "xml", "data", "view", "remote", "format", "text", "status", "command", "result"], "httpClient": [" httpclient", "htmlCo", "ttpclient", "HttpConnect", "httpCase", " httpProxy", "htmlClient", "sslDo", "httpProxy", "ttpProxy", " httpDo", "HttpProxy", " httpConnect", "sslClient", "ttpClient", " httpCase", "sslCo", "ttpConnect", " httpCo", "HttpClient", "httpDo", "Httpclient", "httpConnect", "htmlCase", "httpclient", "htmlDo", "sslCase", "httpCo"], "httpPost": [" httppost", "HTTPPos", "statusPut", "httpPos", "HttpPut", "httppost", "HTTPPOST", "statusPos", "thisPOST", " httpPOST", "httpPut", "ttpPOST", " httpPut", "thispost", "ttpPost", "HTTPPut", "HTTPpost", "HttpPOST", "httpPOST", "thisPut", "HttpPos", "ttpPut", "HTTPPost", "HttpRequest", "HttpPost", "statusPost", "httpRequest", "statusRequest", "thisPost", "HTTPRequest"], "serverResponse": [" serverDescription", "ServerAnswer", " serverPage", "httpBody", " serverAnswer", "serverEx", "statusEx", "httpCall", "descriptionDescription", "httpLine", "serverDescription", "erverLine", "statusEntity", "verResponse", " serverEntity", "serverStream", "ServerEx", "ServerDescription", " serverStream", "verBody", "descriptionAnswer", "ServerResponse", "serverEntity", "ServerEntity", "serverLine", "descriptionStream", "statusPage", "verLine", "serverBody", "verCall", "ServerPage", "httpResponse", "erverBody", "ServerStream", "serverPage", "serverCall", " serverEx", "erverResponse", "statusResponse", "serverAnswer", "erverCall", "descriptionResponse"], "statusLine": ["StatusCode", "responseLine", "statLink", "responseCode", " statusResponse", "serviceLine", "statusCode", "servicePage", "checkline", "serverCode", "Statusline", "statLine", "specLink", "statusline", " statusCode", "responseline", "responsePage", "serviceResponse", "serverLine", "checkPage", " statusLink", "statusLink", "statusPage", "specline", "StatusPage", " statusline", "serverPage", "statPage", "checkCode", "statCode", "specLine", "specCode", "StatusLine", "checkLine", " statusPage", "statusResponse", "serviceCode", "statline"], "inputStream": ["imagestream", "inSteam", "imageStream", "InputReader", "outputPath", "outputReader", "contentStream", "InputThread", "inputPath", " inputPath", " inputstream", "inputThread", "outputSource", "inputSteam", "instream", " inputSteam", "inputSource", " inputThread", "inputstream", "InputSteam", "outputStream", "contentSteam", "imageReader", " inputSource", "inReader", "imageSteam", "InputStream", "contentThread", "InputPath", "InputSource", "inStream", "contentSource"], "inputReader": ["errorLibrary", "serviceLibrary", "imageStreamer", "imageStream", "uploadStreamer", "InputReader", "uploadreader", " inputLibrary", "inputEditor", "uploadStream", "uploadReader", "serviceReader", "serviceStream", "inputStreamer", "errorEditor", "serviceEditor", "inputreader", "imageReader", "errorReader", "errorStream", "imagereader", "inputLibrary", "InputStream", "InputStreamer", "Inputreader", " inputEditor"], "bufferedReader": ["buffereredReader", "bederedWriter", "bufferedWriter", "bufferedStream", "buffererredStream", "buffedParser", "buffereredRunner", "buffedWriter", "bedenedWriter", "bedenedLoader", "buffinedStream", "buffererredRunner", "bederedParser", "bufferredStream", "bufferredWriter", "bufferredLoader", "bufferedRunner", "buffererReader", "buffenedReader", "buffenedLoader", "buffereredWriter", "buffinedWriter", "buffenedParser", "buffinedReader", "buffererStream", "bufferredReader", "buffererredReader", "bufferedParser", "buffedReader", "buffenedWriter", "bufferredRunner", "bufferedLoader", "bederedReader", "bufferredParser", "bedenedParser", "bederedLoader", "buffererRunner", "buffererredWriter", "bedenedReader", "buffedLoader", "buffereredStream", "buffererWriter", "buffinedRunner"], "buffer": ["bar", "memory", "null", "note", "phrase", "binary", "buff", "table", "total", "document", "batch", "block", "Buffer", "filter", "black", "sequence", "message", "change", "bound", "library", "background", "print", "mb", "cache", "temp", "queue", "window", "buf", "console", "builder", "profile", "template", "bridge", "database", "trace", "comment", "escape", "absolute", "layer", "button", "display", "bone", "stack", "append"], "line": ["LINE", "row", "column", "email", "phrase", "link", "rule", "eline", "inline", "e", "block", "error", "cell", "name", "message", "Line", "sequence", "l", "print", "log", "nl", "n", "code", "ln", "user", "stroke", "lin", "page", "string", "word", "le", "point", "query", "frame", "comment", "header", "file", "model", "lane", "online", "entry", "ine", "text", "chain", "liner"], "lastErrorCode": [" lastErClass", "lastErrorCount", "lastStateCode", "firstStatusClass", "firstStatusMessage", " lastErrorClass", "firstStatusCode", "lastStatusCount", "firstErrorMessage", "lastStateCount", " lastErMessage", "lastErCode", "lastStatusClass", "lastErClass", "lastStateMessage", "firstStatusCount", "lastErMessage", "firstErrorCode", "lastErrorClass", "lastEventClass", " lastErCode", " lastErrorCount", "lastEventCount", " lastErCount", "lastStateClass", "lastStatusMessage", "lastErCount", "firstErrorClass", "lastEventMessage", "firstErrorCount", "lastStatusCode", "lastEventCode"], "lastErrorMessage": [" lastErrorString", " lastEventDescription", "lastIssueMsg", " lastStatusDescription", "lastWarningMessage", "lasterrorMessage", "lastEventString", " lastErrorLine", " lastErrorDetails", "lastEventLine", " lastEventMessage", "lastIssueDescription", "lastStatusLine", "lastWarningMsg", "lastErrorDescription", "lastErrorMsg", "lastErrorDetails", " lastStatusDetails", "lastErrorString", "lastStatusMsg", "lastIssueMessage", " lastStatusMessage", "lastIssueDetails", " lastEventString", " lastStatusMsg", "lastWarningDescription", "lasterrorDescription", "lastStatusMessage", "lastWarningDetails", "lastStatusDescription", "lastEventMessage", "lastStatusString", " lastEventLine", " lastErrorDescription", "lastEventDescription", " lastErrorMsg", "lasterrorString", "lasterrorLine", "lastErrorLine", "lastStatusDetails"]}}
{"id1": "18793482", "id2": "22993368", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyapplicationData", "modifyServerMessage", "modifyapplicationmessage", "modifyApplicationData", "modureAppMessage", "modifyAppMessage", "modifyServerMsg", "modureAppMsg", "modifyAppData", "modureAppmessage", "modureApplicationMsg", "modureAppData", "modifyapplicationMsg", "modureApplicationmessage", "modureApplicationData", "modifyServermessage", "modifyAppmessage", "modureApplicationMessage", "modifyapplicationMessage", "modifyAppMsg", "modifyApplicationmessage", "modifyApplicationMsg", "modifyServerData"], "locale": [" localey", "localey", " locales", "localALE", "regALE", "locales", " locALE", " locational", "localale", "Localey", "localales", "locational", "localational", "regale", "Locales", "regational", "locALE", "regales", "LocALE", "Locational", "localaley", "Locale"], "messageName": [" messageNAME", "MessageNAME", "messageKey", "messageNames", "messageNAME", "messageType", " messageNames", "MessageType", "msgType", "msgKey", " messageType", "MessageKey", "mediaName", "msgName", "MessageValue", "mediaKey", "msgValue", "mediaNames", "mediaNAME", "MessageNames", "MessageName", " messageKey"], "messageValue": ["messageVALUE", "messageVal", "messageType", "MessageType", "essageVal", " messageType", "MessageVALUE", "msgvalue", "essageValue", "essageType", "languageName", "languagevalue", "messagevalue", "MessageVal", "MessageValue", "msgName", "Messagevalue", " messageVal", "msgValue", "msgVALUE", "languageVALUE", "languageValue", "MessageName", "essageName"], "properties": ["project", "details", "params", "pid", "property", "prop", "results", "files", "settings", "message", "report", " props", "pro", "utils", "profile", "metadata", "types", "pdf", "json", "parts", "config", "perties", " Properties", "data", "policy", "options", "ps"], "i18nPath": ["i18nyPath", "i18rDriver", "i18nIf", "i18nUrl", "i18anP", "i8nDir", "i18neDriver", "i18nDriver", "i18nyDriver", "i18lUrl", "i18anDir", "i18nPoints", "i18bDir", "i8lUrl", "i18bUrl", "i18natDriver", "i18nDir", "i18rDir", "i18lStr", "i18natPath", "i18anPath", "i18nP", "i18bPath", "i18nePoints", "i18lDir", "i8nUrl", "i18neStr", "i18lPath", "i18anIf", "i18natP", "i18nStr", "i8lDir", "i18nyDir", "i18rPath", "i18neUrl", "i18natPoints", "i8nPath", "i18anDriver", "i18anPoints", "i18neDir", "i18nyIf", "i18neP", "i8nStr", "i18rIf", "i8lStr", "i8lPath", "i18bStr", "i18nePath"], "englishFile": ["englishDirectory", "electricFile", " englishDirectory", "ianaFile", "languageFile", "englishDir", "ianaDirectory", "enFilename", "wikifile", "enfile", "EnglishFilename", "ianaPath", "electricPort", " englishfile", "ianaPort", "englishTable", "englishPort", "electricDirectory", "ianaDir", "electricDir", "englishFilename", "wikiFile", " englishTable", "Englishfile", " englishPort", " englishDir", "englishPath", "EnglishFile", "ianaTable", "enFile", "ianafile", " englishPath", "languageFilename", "englishFiles", "languagefile", "englishfile", "EnglishFiles", "wikiPath", "languageFiles", "wikiTable", "enFiles"], "propertiesFilePath": ["settingsFilenamePath", "propertiesFilepath", "pertiesFilepath", "settingsFileLocation", "pertiesFileType", "pertiesfileName", "settingsFileName", "propertiesFilenameLocation", "propertiesfileName", "propertiesfileLocation", "propertiesFileType", "propertiesfileType", "pertiesfilePath", "pertiesfilepath", "settingsFilepath", "propertiesFileLocation", "propertiesFilenamepath", "propertiesFilesType", "propertiesfilePath", "propertiesFilesName", "propertiesFilenamePath", "settingsFilenameLocation", "propertiesfilepath", "pertiesFileName", "propertiesFilespath", "settingsFilenameName", "propertiesFileName", "settingsFilePath", "propertiesFilesLocation", "propertiesFilenameName", "propertiesFilenameType", "pertiesfileType", "settingsFilenamepath", "pertiesFilePath", "propertiesFilesPath"], "file": ["record", "info", "domain", "os", "comment", "module", "File", "null", "ile", "FILE", "table", "run", "document", "fp", "rule", "path", "object", "base", "be", "files", "parent", "use", "name", "message", "connection", "buffer", "resource", "image", "port", "library", "print", "f", "io", "report", "content", "write", "source", "application", "console", "output", "create", "local", "complete", "language", "page", "string", "style", "class", "current", "pool", "model", "xml", "data", "fi", "channel", "type", "entry", "format", "key", "filename", "handle", "result", "attribute"], "in": ["gin", "read", " din", "oin", "get", "cin", "it", "ini", "inf", "inn", "ind", "ain", "ins", "ic", "rin", "io", "reader", "inc", "ai", "al", "IN", "from", "iter", "init", "en", "isin", "bin", "inner", "input", "ri", "sin", "din", "asin", "i", "inside", "ar", "ir", "In"], "out": ["os", "w", "end", "o", "aos", "it", "check", "can", "to", "outs", "log", "print", "io", "sw", "write", "put", "cache", "n", "cos", "output", "ex", "set", "csv", "Out", "inner", "con", "conf", "screen", "again", "nt", "outer", "conv", "ou", "at", "external", "OUT", "co", "we", "net"], "c": ["nc", "u", "t", "\u00e7", "gc", "ec", "cap", "rc", "cont", "ch", "C", "mc", "character", "lc", "count", "ct", "cc", "cp", "ce", "cs", "v", "dc", "cd", "l", "k", "call", "r", "cache", "cl", "x", "n", "code", "unc", "cos", "cf", "fc", "pc", "etc", "cr", "arc", "cu", "con", "conf", "char", "i", "cm", "cb", "co", "chain", "ca", "cod", "bc", "col", "ac", "d"], "is": ["os", "sis", "sit", "isl", "ios", "lis", "it", "isi", "its", "tis", "isc", "es", "iss", "ins", "ic", "isf", "iris", "nis", "isin", "ri", "\u00eds", "ris", "iso", "i", "sys", "as", "IS", "Is", "ais", "bis", "isa"], "breader": ["brewer", "breadr", " breadber", "bbr", "brower", "bbar", "brewger", " breadar", "bbder", "breadber", "browe", "breade", "bler", "blear", "browger", "brewber", " breadr", "browber", "breadder", "breadar", " breadger", "bleer", " breade", " breadder", "bleder", "bber", "breadger", "brewe"], "line": ["record", "handle", "LINE", "row", "detail", "note", "column", "phrase", "parse", "link", "sample", "email", "lo", "stay", "rule", "eline", "range", "inline", "se", "side", "block", "ice", "part", "cell", "message", "Line", "sequence", "port", "normal", "l", "log", "nl", "queue", "lines", "node", "code", "ln", "no", "cmd", "left", "iter", "stroke", "ip", "entity", "lin", "page", "string", "section", "continue", "char", "word", "body", "edge", "point", "query", "le", "slice", "mail", "next", "trace", "frame", "comment", "header", "online", "lane", "entry", "ine", "label", "text", "chain", "liner", "shell"], "strBuilder": ["strParser", "objBuilder", "stringbuilder", "StrBuffer", "stringParser", "arrBu", " strParser", "strBuilt", "Strbuilder", "stringBuild", " strBuffer", "objBuffer", "strBuffer", "arrBuilder", "stringBuilt", "arrParser", "strBu", "StrParser", "arrbuilder", "frBuilt", "StrBuilt", " strbuilder", "stringBuffer", " strBu", "objBuild", "StrBuild", "frParser", "objbuilder", "frBuilder", "arrBuild", "stringBuilder", "StrBuilder", "strbuilder", "strBuild", "arrBuffer", " strBuild", "StrBu", "frBuild"], "pieces": ["fits", "words", "knife", "eps", "rings", "ctors", "services", "xes", "ties", "piece", "sections", "its", "finals", "letters", "cars", "cuts", "powers", "pins", "places", "feet", "bits", "checks", "lines", "blocks", "items", "Parts", "ces", "caps", "groups", "links", "plates", "sts", "pointers", "keys", "types", "units", "ops", "steps", "fixes", "terms", "times", "tools", "parts", "bytes", "strings", "tips", "players", "ps", "maps"], "found": [" caught", " detected", " founded", "failed", "successful", "err", "mounted", "finished", "read", "forced", "built", "done", "old", "empty", "supported", "started", "success", "valid", "ed", "count", "used", "available", "bool", "focused", "needed", "confirmed", "created", "changed", "opened", "tested", "good", "find", "given", "released", "expected", "search", "printed", "fixed", "installed", "index", "compl", "first", " Found", "filled", "identified", "defined", "loaded", "Found", "sent", "sold", "finder"]}}
{"id1": "18570190", "id2": "9398454", "code1": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"getProcess": ["selectprocess", " getprocess", "getprocess", "recordRecord", "getProduct", "recordprocess", " getProduct", "getRecord", "recordProcess", "selectProduct", "selectRecord", "selectProcess", "recordProduct", " getRecord"], "processId": ["processIdent", "workerID", "procEnd", "procId", "processingIdent", " processById", "processingId", "cessID", "procNumber", "cessId", "workerId", "processById", "processEnd", "processingById", "workerById", " processID", " processNumber", " processIdent", "workerIdent", "processNumber", "cessNumber", " processEnd", "processingID", "processID", "cessEnd", "procID"], "req": ["sql", "dq", "send", "http", "Requ", "pkg", "mk", "ref", "url", "get", "require", "gr", "desc", "quest", "sq", "cp", "need", "client", "this", "obj", "conn", "request", "q", "proc", "res", "cmd", "ctx", "rx", "comm", "def", "Cmd", "query", "inv", "eg", "fr", "task", "requ", "msg", "Request", "tx", "job", "qq", "crit"], "resp": ["rep", "sql", "re", "rex", "cmp", "pos", "err", "http", "Res", "https", "esp", "soc", "expr", "desc", "bb", "sp", "obj", "report", "conn", "out", "proc", "ev", "Exc", "respond", "sol", "org", "res", "rel", "eb", "txt", "exp", "comm", "Response", "conv", "body", "compl", "json", "comp", "inv", "pres", "rem", "html", "rez", "fr", "wy", "bytes", "Resp", "msg", "vol", "ess", "response", "dl", "serv", "status", "col", "result"], "xmlable": ["elementorable", "xmlble", "phpitable", "elementable", "phpable", " xmlorable", "elementability", "mlable", " xmlitable", "apacheability", "phpble", "mlorable", "apachestable", "mlability", " xmlstable", "mlble", "elementstable", "xmlstable", "mlstable", " xmlble", "mlitable", " xmlability", "apacheable", "xmlorable", "xmlitable", "apacheble", "phporable", "xmlability"], "p": ["pl", "rep", "m", "process", "pai", "t", "parse", "pp", "pid", "pkg", "tap", "pm", "a", "up", "cp", "sp", "php", "post", "pb", "ping", "op", "proc", "pro", "np", "g", "lp", "pers", "vp", "pc", "pa", "P", "jp", "app", "par", "ph", "pr", "mp", "tp", "ap", "ps"]}}
{"id1": "755203", "id2": "22801734", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "13362846", "id2": "9236363", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setContennux", "setcontensenux", "setcontensenu", "setcontensenU", "setcontenu", "setContenux", "setContensenux", "setContennu", "setContenue", "setCont\u00ednu", "setContennU", "setContensenu", "setContenU", "setcontenue", "setContennue", "setcontenU", "setCont\u00ednue", "setCont\u00ednU", "setCont\u00ednux", "setContensenU", "setcontenux", "setContensenue", "setcontensenue"], "contenuFichier": ["contenuMicheaire", "contenuFithiere", "contenuFochiere", "contenuFamilyachiere", "contenuVichiere", "contenuFichiest", "contenuFigner", "contenuFichaire", "contenuFileichie", "contenuFihiest", "contenuFiverier", "contenuFicheer", "contenuFolfier", "contenuFihiere", "contenuFechyr", "contenuFignaire", "contenuFrenchire", "contenuFsechier", "contenuFechiest", "contenuFochiers", "contenuFsichire", "contenuFrenchier", "contenuFicheaire", "contenuFichire", "contenuFichorie", "contenuFsichieri", "contenuFachiere", "contenuFechier", "contenuFigniere", "contenuVchie", "contenuFsrenchaire", "contenuFamilyichorie", "contenuVechiere", "contenuFuffier", "contenuFicheiere", "contenuFichyr", "contenuFachiers", "contenuFochIER", "contenuFsichier", "contenuFileochiere", "contenuMichier", "contenuFichtiere", "contenuFCher", "contenuFichiere", "contenuFicheire", "contenuFachie", "contenuFochie", "contenuFochier", "contenuFChaire", "contenuVchIER", "contenuVechiest", "contenuFChiere", "contenuVechyr", "contenuFamilyichiere", "contenuVichyr", "contenuFsecher", "contenuFolfer", "contenuFsichaire", "contenuFrenchieri", "contenuFechiere", "contenuFsrenchire", "contenuFechieri", "contenuFileichiere", "contenuFchiere", "contenuFamilyichier", "contenuFileichiers", "contenuVchier", "contenuFuffer", "contenuFuffieri", "contenuVichie", "contenuVchiere", "contenuFsrenchieri", "contenuFithorie", "contenuFecher", "contenuFrenchaire", "contenuFichiers", "contenuFichtie", "contenuFicheiers", "contenuFihier", "contenuFithie", "contenuFamilyachier", "contenuFichtier", "contenuVechier", "contenuVichiest", "contenuFileichier", "contenuFileochier", "contenuMicheier", "contenuFithier", "contenuFicheie", "contenuMichaire", "contenuFechire", "contenuVichier", "contenuFsicher", "contenuFicheieri", "contenuFsechire", "contenuFiverieri", "contenuFamilyichie", "contenuFolfire", "contenuFchIER", "contenuFileochie", "contenuFiveraire", "contenuFichIER", "contenuMicher", "contenuMicheer", "contenuFichieri", "contenuMicheiere", "contenuFiverire", "contenuFichtIER", "contenuFchier", "contenuFachorie", "contenuFchie", "contenuFicheier", "contenuVichIER", "contenuFsechieri", "contenuFithyr", "contenuFichie", "contenuFileochiers", "contenuFamilyachorie", "contenuFicheorie", "contenuFolfieri", "contenuFachier", "contenuMichiere", "contenuFChier", "contenuFamilyachie", "contenuFignier", "contenuFithiest", "contenuFuffire", "contenuFicher", "contenuFihyr", "contenuFsrenchier"], "fichierElectronique": ["fichierSelectronicity", "fichierElectradorie", "fichierSelectronique", "fichierelectreniques", "fichierElectoniques", "fichierTransferronius", "fichierSelectroneicity", "fichierSelectronoch", "fichierElectronicy", "fichierElectradorius", "fichierElectrenier", "fichierCentronicy", "fichierElectronsiques", "fichierElectroneie", "fichierElectroniq", "fichierTransferradoric", "fichierElectchronicy", "fichierElectronipolar", "fichierElectonique", "fichierElectrenius", "fichierElectriciques", "fichierElectchronicity", "fichierelectrenic", "fichierElectromie", "fichierElectrenique", "fichierElectricie", "fichierElectronoch", "fichierElectroneic", "fichierElectroneipolar", "fichierElectroneaire", "fichierElectromicity", "fichierelectrenier", "fichierElectradorique", "fichierCentRONaire", "fichierElectrenaire", "fichierTransferronic", "fichierElectronicity", "fichierElectchroniques", "fichierElectricique", "fichierElectromique", "fichierElectchronique", "fichierCentronique", "fichierCentronius", "fichierSelectroneique", "fichierElectriciq", "fichierElectronsier", "fichierElectronaire", "fichierSelectroniques", "fichierElectrenic", "fichierTransferradorie", "fichierElectromaire", "fichierElectromipolar", "fichierElectronsoch", "fichierElectronius", "fichierElectronier", "fichierCentronaire", "fichierAdministroneique", "fichierTransferradorique", "fichierCentRONicy", "fichierElectchronius", "fichierelectronier", "fichierElectRONaire", "fichierElectronsicity", "fichierAdministroneiq", "fichierCentRONique", "fichierElectRONique", "fichierelectrenique", "fichierElectchronoch", "fichierElectroneicity", "fichierTransferronique", "fichierElectrontique", "fichierElectroneoch", "fichierElectronsiq", "fichierElectronsique", "fichierelectronique", "fichierElectroneiq", "fichierElectroneius", "fichierElectreniques", "fichierElectronsie", "fichierAdministroneiques", "fichierElectromius", "fichierElectroniques", "fichierAdministroneie", "fichierTransferronie", "fichierTransferradorius", "fichierElectrontipolar", "fichierCentRONius", "fichierElectroneiques", "fichierElectonic", "fichierElectchronaire", "fichierElectronic", "fichierElectradoric", "fichierElectronticity", "fichierelectronic", "fichierElectrontaire", "fichierAdministroniq", "fichierElectromic", "fichierElectRONicy", "fichierElectroneique", "fichierAdministronie", "fichierElectrenicy", "fichierElectronie", "fichierElectonier", "fichierElectronsic", "fichierAdministroniques", "fichierelectroniques", "fichierAdministronique", "fichierSelectroneoch", "fichierSelectroneiques", "fichierElectRONius"], "utilisateurCourant": ["utilisateurGovernants", "utilisateurParticipant", "utilisateurCourante", "utilisateurParticipiant", "utilisateursCourante", "utilisateurRepresentante", "utilisateurGovernante", "utilisateursGovernants", "utilisateursGovernante", "utilisateursCourants", "utilisateurCourants", "utilisateurParticipante", "utilisateurRepresentants", "utilisateurRepresentiant", "utilisateurCouriant", "utilisateurGovernant", "utilisateurGoverniant", "utilisateurParticipants", "utilisateursGoverniant", "utilisateursCouriant", "utilisateurRepresentant", "utilisateursCourant", "utilisateursGovernant"], "support": ["evidence", "storage", "install", "null", "allow", "cap", "document", "supported", "prototype", "SUP", "success", " Support", "history", "media", "accept", "cover", "system", "use", "help", "context", "port", "library", "control", "trust", "feature", "service", "proof", "pport", "see", "profile", "replace", "language", "supp", "know", "share", "please", "access", "force", "format", "Support", "collection"], "ficheDocument": ["facheJournal", "fayeDocument", "fayeDoc", "flicheMatrix", "FicheDatabase", "frenchTransaction", "facheDoc", "facheTransaction", "ficidocument", "fitimeDocument", " frenchDatabase", "foyerTree", "facheTree", "FicheDocument", "fitimeDescription", "fliciDocument", "hicheDocument", "bacheDatabase", "frenchDescription", "ficiDatabase", "bicheDoc", "hachedocument", "bacheDoc", "frenchDatabase", "hacheJournal", "bicheDatabase", "hichedocument", "ficiDocument", " frenchDescription", "facheDatabase", "ficiJournal", "flicheTransaction", "frenchDocument", "frenchDoc", "fliciMatrix", "fitimeMatrix", "bicheDocument", "fruitTransaction", "hacheDocument", "fcheDocument", "facheDocument", "FicheDoc", "fcheDoc", "fiqueDocument", "ficheJournal", "FicheDocuments", "hicheJournal", "ficheMatrix", "fruitdocument", "fayeDatabase", "fruitJournal", "hacheTransaction", "flicheDatabase", "ficheDatabase", "fcheTree", " ficheDescription", "fitimeTransaction", "foyerDatabase", "ficheDocuments", "fcheDatabase", "bacheDocument", "ficiMatrix", "ficheTree", "hicheTransaction", "foyerDocument", "FayeDocuments", "bicheTree", "fruitDocument", " frenchDocument", "fifaDocuments", "fliciTransaction", "foyerDoc", "fichedocument", "fifaDoc", "fachedocument", "fliciDatabase", "bacheTree", "fifaDocument", "fayeDocuments", " ficheDatabase", "ficheTransaction", "ficheDescription", "ficiTransaction", "flicheDocument", "FayeDoc", "fifaDatabase", "fiqueDatabase", "fitimeDatabase", "fiqueDescription", "frenchDocuments", "FayeDocument", "frenchMatrix", "ficheDoc", "FayeDatabase"], "nomFichier": ["nomFichoier", "nomPFoililler", "nomUFichIER", "nomFcher", "nomFachancer", "nomFoilER", "nomFcherer", "nomFichoanger", "nomFichiere", "nomFihIER", "nomNichie", "nomFchiner", "nomNichiere", "nomUFichery", "nomPFichjer", "nomFericanger", "nomPichier", "nomNolfier", "nomPFichER", "nomFachiere", "nomUFichier", "nomPachier", "nomFicerer", "nomFicheie", "nomNolfiere", "nomFicheier", "nomFicherer", "nomFiliciller", "nomFiverIER", "nomFichancer", "nomFchier", "nomFicheiner", "nomUFichire", "nomFichER", "nomFolfier", "nomPFoilER", "nomFihery", "nomFolfie", "nomFichIER", "nomFachier", "nomFichire", "nomNolfie", "nomFicher", "nomNichire", "nomFilicER", "nomFachiner", "nomFichery", "nomFicjer", "nomFicER", "nomFchiere", "nomFicire", "nomFihire", "nomFachery", "nomFicheire", "nomPachomer", "nomFiverier", "nomFiverire", "nomFericancer", "nomFilicjer", "nomFichanger", "nomPFoilier", "nomFachire", "nomFiverery", "nomFilicier", "nomFachIER", "nomFicier", "nomUFachery", "nomNichier", "nomFichoIER", "nomFichjer", "nomFicheiere", "nomFoililler", "nomUFachire", "nomFoiljer", "nomPichomer", "nomFchomer", "nomFacher", "nomFachie", "nomFolfiere", "nomPichire", "nomFericier", "nomPachire", "nomFachomer", "nomPFoiljer", "nomFichiner", "nomUFachIER", "nomFachanger", "nomFichoancer", "nomPacherer", "nomFicomer", "nomPFichier", "nomNolfire", "nomFichie", "nomFiciller", "nomFihier", "nomFacherer", "nomFicheer", "nomFericIER", "nomUFachier", "nomPFichiller", "nomFichomer", "nomFolfire", "nomFoilier", "nomFichiller", "nomPicherer", "nomFchire"], "extension": ["Extension", "Extensions", "expitude", "extitude", "strension", "extractor", "expractor", "contention", "protension", "protention", "strensions", "Extending", "expension", "xtension", "xtending", "protitude", "extention", "contractor", "protractor", "xtensions", "extensions", "expention", "strending", "contension", "extending", "contitude"], "fichierElectroniqueExistant": ["fichierElectroniquePersistent", "fichierElectronoguePersistant", "fichierElectronogramExclusive", "fichierElectroniqueExistance", "fichierElectronogramExistent", "fichierElectroniqueInert", "fichierElectroniqueInclusive", "fichierElectronogramLocalistance", "fichierElectroniqueExister", "fichierElectroniqueAssistance", "fichierElectroniquePlusistant", "fichierElectronicityInistant", "fichierElectronoguePersiker", "fichierElectroniqueExplert", "fichierElectroniqueAssistant", "fichierElectroniqueLocalclusive", "fichierElectronogueExistant", "fichierElectroniqueExplistant", "fichierElectroniqueInvant", "fichierElectroniqueExplvant", "fichierElectronoguePersister", "fichierElectronicityInert", "fichierElectroniquePersistant", "fichierElectronicityInvant", "fichierElectroniqueInistent", "fichierElectroniqueAssclusive", "fichierElectroniquePresentiker", "fichierElectroniqueLocalistance", "fichierElectroniqueExclusive", "fichierElectroniquePresentister", "fichierElectroniqueExiker", "fichierElectronogramLocalclusive", "fichierElectronicityExert", "fichierElectroniqueEXistant", "fichierElectroniqueEXert", "fichierElectronicityInistance", "fichierElectronicityExvant", "fichierElectronicityExistant", "fichierElectronicityExistance", "fichierElectroniquePresentistant", "fichierElectroniquePlusister", "fichierElectronogramExistant", "fichierElectroniqueAssistent", "fichierElectroniquePersiker", "fichierElectroniqueInistance", "fichierElectronogramLocalistent", "fichierElectroniquePersister", "fichierElectronoguePersistent", "fichierElectroniqueEXvant", "fichierElectroniqueEXistance", "fichierElectronogramLocalistant", "fichierElectronogueExiker", "fichierElectroniquePresentistent", "fichierElectroniqueExvant", "fichierElectroniqueExert", "fichierElectroniquePlusistent", "fichierElectroniquePlusiker", "fichierElectroniqueInistant", "fichierElectronogramExistance", "fichierElectroniqueLocalistent", "fichierElectronogueExister", "fichierElectroniqueLocalistant", "fichierElectroniqueExplistance", "fichierElectroniqueExistent", "fichierElectronogueExistent"], "idIgid": ["idIgida", "idIgdoid", "idIgzida", "idIkglimit", "idIkgid", "idIgzid", "idIvgkey", "idIgoid", "idIgdata", "idIIgido", "idIIgida", "idIgids", "idIegdata", "idIvgdata", "idIgis", "idIigmid", "idIigmaddress", "idIigmis", "idAglimit", "idImglimit", "idIgcoid", "idIgzido", "idIIgzido", "idImgids", "idIegkey", "idIgido", "idImgaddress", "idIgaddress", "idIgkey", "idIIgoid", "idAgaddress", "idIkgis", "idImgkey", "idImgis", "idAgis", "idIglimit", "idIgzoid", "idIgcido", "idIIgzida", "idIgcid", "idAmgid", "idAmgaddress", "idIgdido", "idIvgid", "idIegid", "idIIgid", "idAmgis", "idImgdata", "idAmglimit", "idIIgzoid", "idIgdida", "idIgcida", "idIIgzid", "idIkgaddress", "idIigmlimit", "idIgdid", "idIvgids", "idAgid", "idIegids", "idImgid"], "inputStream": ["imageStream", "InputLoop", "InputThread", "outputSteam", " inputstream", "helloSteam", "inputThread", " inputLoop", "helloStreamer", "InputTime", "inputLoop", "outputstream", "inputSteam", "inputStreamer", "helloStream", " inputSteam", "inputTime", " inputChannel", " inputThread", "inputstream", "InputSteam", " inputTime", "imageLoop", "inputChannel", "outputChannel", "outputStreamer", "imageSteam", "InputStream", "helloChannel", "Inputstream", "imageTime", " inputStreamer", "outputThread"], "outputStream": ["sequenceStyle", "outputForm", "sequenceSteam", "outputSteam", " outputStyle", "writeStream", "webStreamer", "OutputStream", "writeForm", "inputSteam", "sequenceStreamer", "OutputStreamer", "webStream", "OutputStyle", "OutputForm", "inputView", "webView", "sequenceStream", "writeSteam", "writeView", "OutputView", " outputStreamer", "OutputSteam", " outputView", "webSteam", "outputView", "outputStyle", "outputStreamer", " outputSteam", "inputForm"], "typeMime": ["typemIME", "typeRime", "typemim", "typeSmIME", "typeSmim", "Typemme", "TypeMme", "typeRme", "TypeMime", "typeSmime", "TypeMIME", "TypemIME", "typeMme", "TypeMim", "typeMIME", "typemime", "typeSmme", "typeRIME", "typemme", "typeRim", "typeMim", "Typemim", "Typemime"], "tailleFichier": [" tailleFuzzier", " tailleFicheies", " tailleficheie", " tailleFuzzie", " taillefichiers", " tailleFicheiers", " tailleFixiers", " taillefichies", " tailleFicheier", " tailleficheier", " tailleficheiers", " tailleFichies", " tailleficheies", " taillefichier", " tailleFixier", " tailleFichie", " tailleFuzzies", " tailleFicheie", " tailleFixies", " tailleFuzziers", " tailleFichiers", " tailleFixie", " taillefichie"]}}
{"id1": "23199071", "id2": "2807585", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getReadBody", "getContentSource", "getReadStream", "getOutputBody", "getReadFile", "getInputFile", "getInputBody", "getContentBody", "getReadSource", "getContentFile", "getContentStream", "newOutputStream", "newInputBody", "newOutputSource", "getOutputFile", "newInputSource", "newOutputFile", "newOutputBody", "newInputFile", "getOutputStream", "getOutputSource", "getInputSource", "newInputStream"], "url": ["ret", "pl", "full", "row", "lr", "ur", "null", "u", "api", "http", "email", "hl", "link", "err", "pp", "https", "val", "path", "ref", "ls", "host", "base", "raw", "internal", "build", "address", "id", "this", "resource", "uri", "l", "f", "sl", "r", "nl", "log", "print", "q", "str", "res", "rel", "mount", "impl", "location", "ssl", "string", "page", "server", "Url", "web", "mail", "html", "ul", "ll", "dl", "remote", "loc", "URL", "browser"], "file": ["info", "full", "File", "t", "ile", "FILE", "link", "table", "fp", "rule", "object", "path", "ref", "util", "base", "tile", "check", "fe", "name", "message", "buffer", "image", "resource", "obj", "library", "print", "f", "uri", "folder", "source", "user", "local", "entity", "language", "page", "lib", "template", "checked", "le", "relation", "mail", "db", "fi", "job", "field", "filename", "event", "dir"]}}
{"id1": "665420", "id2": "10547671", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doFeaturecheck", "doVersionTest", " doVersionscheck", "doImageTest", "doVersionInfo", "doFeatureInfo", " doApplicationTest", " doApplicationInfo", "doVersioncheck", "doBuildTest", "doFeatureTest", "doVersionscheck", "doImageQuery", " doVersionsTest", "doApplicationCheck", " doVersionInfo", " doApplicationCheck", "doVersionsUpdate", "doApplicationQuery", " doVersioncheck", "doBuildCheck", " doVersionQuery", " doVersionTest", "doBuildcheck", "doFeatureUpdate", " doVersionsCheck", "doVersionsCheck", " doApplicationQuery", "doApplicationTest", "doBuildUpdate", " doVersionUpdate", "doFeatureQuery", "doImageCheck", "doFeatureCheck", "doImageInfo", " doVersionsUpdate", "doVersionsTest", "doApplicationInfo", "doVersionUpdate", "doVersionQuery"], "view": ["iew", "project", "row", "http", "update", "document", "engine", "component", "h", "version", "block", "check", "ml", "cell", "client", "this", "buffer", "image", "v", "views", "context", "port", "report", "print", "layout", "call", "q", "window", "controller", "see", "widget", "View", "page", "tree", "VIEW", "virtual", "input", "server", "show", "index", "query", "review", "manager", "html", "tv", "pool", "cv", "form", "model", "file", "subject", "box", "vm", "self", "lock", "display", "eye", "browser"], "url": ["pl", "domain", "bel", "ur", "oul", "http", "hl", "link", "b", "ref", "host", "get", "gl", "build", "address", "client", "v", "uri", "l", "f", "sl", "r", "nl", "log", "rl", "str", "rel", "mount", "ssl", "char", "Url", "mail", "ul", "html", "file", "loc", "lb", "ll", "dl", "job", "URL", "browser"], "in": ["gin", "info", " IN", " din", "In", "stream", "cin", "on", "inf", "inn", "ain", "mn", "ins", "can", "rin", "f", "l", "reader", "inc", "out", "source", "n", "ln", "IN", "from", "init", "isin", "inner", "input", "sin", "din", "body", "asin", "i", "mat", "is", "vin"], "bin": ["gin", "re", "bg", "spin", "binary", "buff", "b", "thin", " din", " bins", "ebin", "bn", "cin", "stock", "inn", "brain", "buffer", "ins", "rin", "mon", "by", "reader", "sam", "obin", "out", "cache", "ln", "cos", "bi", "bl", "local", "win", "init", "bur", "rb", "inner", "lib", "con", "all", "jin", "sin", "din", "body", "abin", " Bin", "bed", "session", "conv", "db", "cb", "file", "ran", "len", "nb"], "line": ["record", "LINE", "row", "detail", "column", "err", "parse", "link", "sample", "lo", "rule", "stay", "eline", "range", "tile", "inline", "base", "stream", "block", "ice", "part", " block", "ine", "cell", "message", "Line", "sequence", "port", "l", "log", "print", "lines", "code", "ln", "cmd", "iter", "cat", "lin", "string", "page", "style", "section", "word", "char", "next", "le", "point", "zone", "trace", "frame", "comment", "status", "file", "lane", "channel", "job", "entry", "field", "key", "chain", "liner"], "develBuild": ["deployBuilt", "devBuilder", "desVELBuild", "deffBuild", "deffbuild", "DeVELBuild", "devBuild", "deVELLog", "develBuilt", "desVELbuild", "desvelBuild", "duffBuilt", "DevelBuild", "DeVELbuild", "devLog", "deffBuilder", "depoBuild", "duVELBuilder", "duVELBoot", "Develbuild", "develbuild", "develBoot", "deVELbuild", "deploybuild", "duffBuild", "duvelBuilder", "deployBuild", "duVELBuild", "devbuild", "DevelLog", "duvelbuild", "develLoad", "desVELRelease", "duffBuilder", "develLog", "deeltaBuild", "duffbuild", "desvelRelease", "DeVELBuilt", "deeltaRelease", "desvelLoad", "deployRelease", "duvelBuilt", "deVELBuild", "duVELbuild", "deVELLoad", "depobuild", "depoBuilt", "desVELLoad", "deeltabuild", "deeltaLoad", "deVELBuilt", "deployLoad", "DevelBuilt", "deffBuilt", "deployBoot", "duvelBoot", "depoLog", "deVELBoot", "DeVELLog", "develBuilder", "devBuilt", "develRelease", "devBoot", "duvelBuild", "desvelbuild", "deVELBuilder", "deployBuilder", "deVELRelease"], "stableBuild": ["devBuilder", "secureBuild", "devBuild", " unstableCraft", " stablebuild", " stableBuilder", "activeBuild", "secureCraft", " unstableLong", "stableBoot", " stableLong", " unstablebuild", " unstableBuild", " stableBind", " unstableBind", "stableBind", "devbuild", "securebuild", "activeMake", "stablebuild", " stableBoot", "confirmedLong", "confirmedbuild", " unstableBoot", "devMake", "stableBuilder", "stableLong", "activeBuilder", "confirmedBoot", "confirmedBuild", "stableCraft", "activebuild", " stableCraft", " stableMake", "secureBuilder", " unstableBuilder", "devBind", "stableMake"]}}
{"id1": "659316", "id2": "17202157", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    static Matrix readMatrix(String filename, int nrow, int ncol) {\n        Matrix cij = new Matrix(nrow, ncol);\n        try {\n            URL url = filename.getClass().getResource(filename);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            for (int i = 0; i < nrow; i++) for (int j = 0; j < ncol; j++) cij.set(i, j, Double.parseDouble(lnr.readLine()));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return cij;\n    }\n", "label": 0, "substitutes": {"argv": ["argvs", "argm", " argm", " argV", "argc", "argss", "Argv", "callv", "suppp", "suppvs", "callvs", "argsV", "Args", " argvs", " argc", "argsc", "ArgV", "argsm", "Argc", "suppV", " argp", "callV", "argsv", "argp", "Argm", "suppv", "callp", "argV"], "sources": ["slocks", "servets", "servources", " siders", " sults", " soots", "stors", "inources", "sodes", "tocks", "tiders", "seults", "siders", "stources", "socks", "sures", "soots", "slources", "stets", "seets", "servors", "tources", "inodes", "sets", "toots", "servures", "seodes", "stures", " sors", "sliders", "inets", "inults", " socks", "seources", " sets", "sults", " sodes", "sloots", " sures", "sors"], "targets": ["tokets", " tanges", "toolsanksets", "Topends", "toolsankgers", "tokgers", "tankgers", "toolsargens", "Topets", "targes", "topends", "tassets", " tangens", " targens", "tanksets", "Topches", "tangets", " targends", "Targets", "tangches", "toolsarggers", " tangets", "targens", " tangends", "Targches", "topes", "targends", "tokes", "tanges", "Targes", "tankets", "targetgers", "tangens", "tokens", "tokends", "tasses", "targsets", "topches", "tangends", "targgers", "tassends", "toolsankens", "topens", "toolsankets", "targetsets", "tassches", " targes", "toksets", "Targends", "tankens", "targetens", "targches", "toolsargsets", "toolsargets", "targetets", "Topes", "topets"], "srclen": ["srccen", "srccogn", "srselength", "rsclog", "srplade", "rsccue", " srclade", " srplade", "rsclogn", "srclogn", "srseln", "srselade", "srselog", "srclue", "srcln", "srCLn", " srplen", " srpln", " srplength", "srklogn", "rsccogn", "srpln", "rsccen", "srclength", "srplength", "srccog", "srCLen", "srplen", "srCLength", "srselue", "srselogn", "srklog", "rsclue", "rsclen", "srclog", " srclength", "srclade", "rsccog", "srselen", "srklue", "srklen", "srccue", " srcln", "srCLade"], "source": ["info", "src", "null", "link", "SOURCE", "get", "secure", "score", "scope", "parent", "ser", "store", "internal", "sp", "system", "scale", "this", "buffer", "sequence", "resource", "context", "s", "wrapper", "reader", "service", "cache", "scan", "select", "me", "console", "ource", "site", "standard", "iter", "create", "start", "local", "set", "copy", "from", "search", "inner", "style", "template", "input", "root", "query", "trace", "sys", "force", "Source", "escape", "file", "match", "status"], "tgt": ["Targ", "tept", "tht", "nht", "tegt", "warget", "npt", "itarget", "tetarget", "starget", "warg", "ittarget", "Tht", "tegn", "wgt", "Target", " ttarget", "tgn", "starg", "teht", "tpt", "wtarget", "Tgt", " targ", "tearget", "ngt", " tpt", " tgn", "itgt", "ttarget", "sttarget", "ngn", "itarg", "targ", "stgt", " tht", "tearg", "itht"], "target": ["null", "goal", "link", "table", "gt", "handler", "path", "top", "base", "parent", "socket", "internal", "peer", "buffer", "resource", "writer", "to", "Target", "wrapper", "owner", "stable", "pointer", "member", "out", "mask", "rel", "ARGET", "bolt", "output", "local", "child", "touch", "copy", "inter", "dest", "template", "trap", "tmp", "next", "proxy", "manager", "trace", "sys", "localhost", "arget", "match", "secondary", "channel"], "deletes": ["Deels", "Deles", "desets", "leves", "dules", "desges", "leets", "dges", "delletes", "seles", "deslets", "duleted", "dellets", "seletes", "leletes", "seels", "desves", "duges", "deges", "delets", "deles", "dulets", "duletes", "duels", "lelets", "dletes", "Deleted", "dleted", "deves", "deleted", "deels", "delves", "deets", "Deletes", "desleted", "desletes", "dlets", "seleted"], "del": ["tl", "pl", "Del", "re", "err", "sel", "syn", "els", " dele", "ls", "dem", "se", "pel", "delete", "let", "cel", "md", "l", "ele", "nl", "dec", "rl", "cl", "dis", "rel", "de", "bl", "dr", "def", "tr", "nt", "kl", "le", "compl", "inv", "rol", "rem", "el", "des", "dl", "ll", "len", "ne", "col", "elt", "vet"]}}
{"id1": "13439950", "id2": "11562173", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["readremoteFile", "downloadRemoteRemote", "readremoteFrom", "readLocalFile", "readLocalFrom", "downloadStaticFilename", "downloadRemoteFilename", "readLocalRemote", "downloadStaticFile", "downloadRemoteFile", "downloadStaticRemote", "readRemoteFrom", "readremoteFilename", "downloadRemoteFrom", "readRemoteRemote", "readStaticFrom", "readStaticFile", "readRemoteFilename", "readLocalFilename", "readremoteRemote", "readStaticRemote", "downloadStaticFrom", "readStaticFilename"], "response": ["answer", "secret", "send", "sample", "resp", "onse", "line", "version", "value", "block", "settings", "address", "message", "connection", "sequence", "image", "summary", "report", "print", "reset", "service", "cache", "request", "source", "str", "example", "res", "application", "respons", "output", "string", "reply", "continue", "server", "network", "Response", "body", "next", "relation", "json", "description", "data", "view", "format", "resolution", "status", "command", "result", "vector"], "url": ["ret", "pl", "lr", "ur", "bel", "http", "hl", "link", "b", "https", "ref", "base", "gl", "build", "name", "resource", "l", "uri", "sl", "fl", "nl", "r", "rl", "str", "rel", "mount", "cmd", "ssl", "char", "Url", "mail", "abs", "ul", "el", "web", "loc", "lb", "ll", "dl", "URL", "browser"], "is": ["os", "ms", "sis", "isl", "in", "bs", "ios", "lis", "it", "ates", "isi", "its", "isc", "sels", "es", "iss", "ists", " Is", "ins", "ic", "isf", "does", "ir", "fs", "iris", "nis", "ip", "rs", "ri", "\u00eds", "ris", "iso", "i", "sys", "as", "IS", "Is", "ais", "serv", "bis", "isa"], "br": ["bt", "bh", "lr", "shr", "rob", "nr", "bs", "b", "bn", "repl", "ver", "Br", "bf", "be", "gr", "bm", "sp", "r", "bd", "wr", "hr", "str", "buf", "rel", "res", "bi", "bl", "ro", "cr", "dr", "rb", "bro", "jp", "tr", "BR", "bp", "bridge", "pr", "fr", "ber", "vr", "bc", "mr", "browser", "adr"], "s": ["os", "ms", "m", "less", "sql", " inputs", "t", "z", "w", "bs", "j", "b", "sample", "h", "o", "ls", "ss", "ves", "se", "a", "tes", "e", " gets", "its", "value", "es", "sq", "ns", " ts", "ies", "ts", "p", "v", "y", "sym", "ins", "l", "series", "r", "gs", "str", "ats", "n", "js", "sv", "S", "res", "still", "g", "single", "txt", "rs", "csv", "sb", "sn", "sts", "string", "i", " samples", "gets", "strings", "stats", "qs", "ps", "sports"], "eof": ["eomp", "Eef", "eef", "Eomp", " eOf", "seof", " eow", "Eol", " eov", "sef", "eeot", "eOf", " eomp", "eov", "eeOf", "eeOF", "eeef", "eeos", "eOF", "eeol", "Eof", "Eos", "geif", "eeomp", " eOF", " eot", "eeov", "geow", " eif", "eeof", "geOF", "seot", " eol", "eot", "ef", "eos", "eow", " eos", "eif", " ef", "eol", "seef", "Eov", "eeow", "geof", "eeif", "EOf", " eef"]}}
{"id1": "9796161", "id2": "16804988", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMD2", "toMD5", "getmd5", "getmd4", "getSHA7", "getMD4", "getMD7", "toMD4", "getmd2", "getmd7", "toSHA7", "getSHA5", "toSHA2", "toMD7", "toMD2", "getSHA4", "getSHA2", "toSHA5", "toSHA4"], "s": ["src", "ms", "sql", "os", "t", "bs", "b", "aws", "c", "h", "ws", "ls", "ss", "its", " gets", "space", "es", "sq", "ns", "ies", "ts", "p", "v", "y", "ins", "l", "f", "ses", "str", "ats", "n", "js", "sv", "S", "gs", "source", "fs", "g", "rs", "sb", "sts", "string", "xs", "ends", "i", "abs", "bytes", "data", "strings", "is", "gets", "text", "ps"], "m": ["perm", "mod", "ms", "mut", "mac", "mu", "managed", "mk", "mc", "hm", "h", "pm", "mi", "fm", "e", "nm", "bm", "rm", "v", "y", "md", "mt", "l", "M", "mask", "sm", "g", "me", "em", "dm", "mm", "om", "am", "man", "gm", "rem", "manager", "cm", "vm", "tm", "made", "mo", "mr"]}}
{"id1": "2461169", "id2": "19747399", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileAsfile", "decodeFileToString", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFileFileFile", "decodeStringToString", "decodeStringToFiles", "decodeString2file", "decodeFileTofile", "decodeFile2String", "decodeStringToFile", "decodeString2String", "decodeString2File", "decodeFileFileFiles", "decodeFileAsFiles", "decodeFile2File", "decodeFile2Files", "decodeString2Files", "decodeFileFileString", "decodeFileToFiles", "decodeFile2file", "decodeFileAsString"], "infile": ["isinfolder", "isinfile", "inputname", "Inbase", "outFile", "outfolder", "InFile", "outfilename", "inname", "isinname", "fromFile", "outname", "Infile", "infolder", "frombase", "inFile", "inputFile", "inbase", "fromfilename", "infilename", "inputfile", "isinFile", "fromfile", "Infilename", "inputfolder", "outbase"], "outfile": [" outname", "inFILE", "Outfilename", "Outfile", "outFile", "otname", "outfilename", "otfile", "inname", " outFile", "outname", "todir", "outdir", "otFILE", "tofilename", "inFile", "outFILE", "indir", "tofile", "Outdir", "infilename", "toFile", "OutFile", " outFILE", "otFile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "variable", "total", "document", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "attribute", "cache", "number", "temp", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "shape", "append"], "read": ["before", "each", "text", "send", "shift", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", " succeed", "ok", "submit", "ratulations", " succ", "condition", "scope", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "summary", "primary", "commit", "positive", "surv", "crit", "same", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", "unity", "please", " successes", "first", "support", "city", "exist", " successful", "ceed", "fail", "response", "successfully", "status", "result", " okay", "accept"]}}
{"id1": "8490297", "id2": "14231545", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"copyFile": [" duplicatefile", " duplicateDir", " cpfile", " cpFile", " copyfile", " duplicateFiles", "copyfile", " cpFiles", " copyFiles", " cpDir", " duplicateFile", "copyFiles", "copyDir", " copyDir"], "src": ["sit", "sc", "http", "bs", "ctx", "rc", "cont", "syn", "pkg", "url", "ls", "func", "usc", "desc", "ser", "sq", "nil", "resource", "obj", "ins", "spec", "uri", "req", "sf", "rl", "cur", "source", "rel", "impl", "st", "txt", "rs", "ctr", "sb", "rx", "start", "from", "init", "stat", "dest", "iv", "ck", "sec", "input", "img", "usr", "sr", "conv", "target", "tmp", "comp", "via", "config", "sys", "addr", "Source", "sn", "inst", "msg", "subject", "ipl", "lb", "loc", "filename", "obs"], "dst": ["Dnd", "dust", "pust", "dund", "dung", "sddest", "dedest", " dng", "pst", "ddest", "Ddest", "dng", "deust", "dnd", "Dng", "sdust", "sdth", " ddest", "dudest", "pth", "sdst", "pdest", "dest", " dnd", "dth", "deth", "Dst"], "in": ["gin", "info", "im", "read", " din", "rc", "oin", "up", "cin", "on", "it", "inf", "inn", "ind", "ze", "ain", "min", "ins", "ic", "rin", "inc", "ai", "al", "source", "ln", "st", "from", "iter", "mm", "IN", "init", "en", "isin", "inner", "con", "input", "sin", "din", "i", "inside", "is", "ar", "ir", "In"], "out": ["cn", "os", "t", "gt", "c", "end", "ot", "ch", "o", "up", "aos", "it", "on", "oe", "client", "v", "p", "writer", "obj", "to", "outs", "io", "by", "write", "cache", "n", "g", "res", "output", "Out", "con", "nt", "outer", "sum", "ou", "at", "sys", "auto", "OUT", "co", "ne", "and", "net"], "buf": ["bar", "buff", "b", "cap", "pkg", "mu", "batch", "block", "nm", "Buffer", "vec", "fb", "buffer", "uf", "log", "tab", "queue", "cur", "Buff", "seq", "aka", "cmd", "bl", "cat", "good", "bag", "bin", "cam", "rb", "img", "char", "fam", "br", "conv", "fac", "db", "cb", "gen", "cv", "bytes", "box", "data", "msg", "tx", "bus", "bc", "prop", "arr"], "len": ["full", "cmp", "pos", "lic", "hl", "Len", "length", "ld", "cap", "val", "end", "coll", "span", "ls", "e", "wid", "count", "vec", "lon", "v", "l", "nl", "yn", "n", "seq", "ln", "no", "en", "all", "lib", "lf", "nt", "le", "fun", "compl", "el", "ren", "lan", "size", "ll", "dl", "fin", "elt", "del"]}}
{"id1": "22993368", "id2": "20602651", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileAsfile", "decodeFileToString", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFileFileFile", "decodeStringToString", "decodeStringToFiles", "decodeString2file", "decodeFileTofile", "decodeFile2String", "decodeStringToFile", "decodeString2String", "decodeString2File", "decodeFileFileFiles", "decodeFileAsFiles", "decodeFile2File", "decodeFile2Files", "decodeString2Files", "decodeFileFileString", "decodeFileToFiles", "decodeFile2file", "decodeFileAsString"], "infile": ["isinfolder", "isinfile", "inputname", "Inbase", "outFile", "outfolder", "InFile", "outfilename", "inname", "isinname", "fromFile", "outname", "Infile", "infolder", "frombase", "inFile", "inputFile", "inbase", "fromfilename", "infilename", "inputfile", "isinFile", "fromfile", "Infilename", "inputfolder", "outbase"], "outfile": [" outname", "inFILE", "Outfilename", "Outfile", "outFile", "otname", "outfilename", "otfile", "inname", " outFile", "outname", "todir", "outdir", "otFILE", "tofilename", "inFile", "outFILE", "indir", "tofile", "Outdir", "infilename", "toFile", "OutFile", " outFILE", "otFile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "variable", "total", "document", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "attribute", "cache", "number", "temp", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "shape", "append"], "read": ["before", "each", "text", "send", "shift", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", " succeed", "ok", "submit", "ratulations", " succ", "condition", "scope", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "summary", "primary", "commit", "positive", "surv", "crit", "same", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", "unity", "please", " successes", "first", "support", "city", "exist", " successful", "ceed", "fail", "response", "successfully", "status", "result", " okay", "accept"]}}
{"id1": "15896098", "id2": "15797402", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checkums", "getSHA256Checkchecksum", "getSHA256Checksums", "getSHA256Checksam", "getSHA256Checkchecksums", "getSHA256Checkume", "getSHA256Chechecksums", "getSHA256Checkchecksam", "getSHA256Checsums", "getSHA256Checkum", "getSHA256Chechecksum", "getSHA256Checkchecksume", "getSHA256Chechecksam", "getSHA256Checksume", "getSHA256Checsume", "getSHA256Checkcksume", "getSHA256Checkam", "getSHA256Checsam", "getSHA256Checkcksam", "getSHA256Checkcksum", "getSHA256Checsum", "getSHA256Checkcksums", "getSHA256Chechecksume"], "source": ["src", "secret", "text", "in", "sample", "SOURCE", "path", "url", "base", "raw", "value", "reason", "name", "message", "buffer", "image", "context", "this", "s", "sequence", "seed", "content", "out", "ource", "from", "output", "string", "template", "style", "input", "body", "target", "Source", "data", "file", "subject", "format", "filename", "status"], "checksum": [" checksume", "checkim", "checksumb", " checksim", "checkums", " checksumb", "csim", "cksumb", " checksums", "cssum", "checkume", "cksums", "checkssum", "cksim", "checkum", "csum", "checksume", "ckssum", "checkumb", "csume", "checksim", "cksume", "checksums", "cksum", " checkssum"], "md": ["mod", "m", "ms", "ad", "mp", "det", "pd", "df", "ld", " MD", "mk", "dh", "mc", "pm", "MD", "di", "ind", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "def", "Cmd", "pdf", "der", "nt", "hd", " Md", "red", "mand", "grad", "mo", "down", "wd", "dd", "d"], "byteData": ["ByteDATA", " byteDat", "sliceDat", "wordBytes", "bleParts", "bleRel", "bytedata", "channelParts", "routeDat", "phraseParts", " byteDATA", "channelData", "phraseData", "routeData", "phraseBytes", "routeCount", " byteArray", "reverseDATA", "ByteData", "bytesArray", "sliceList", "wordData", "bytesBytes", "phraseDATA", "byteList", "wordArray", " byteList", "byteParts", "byteBytes", "byteArray", "ByteBytes", "bytesDATA", " byteBytes", "ioDat", " bytedata", "wordDATA", "reverseDat", " byteCount", "ioData", "sliceData", "bledata", "ioDATA", "bleData", "byteRel", "byteDat", "bytesData", " byteParts", "routeDATA", "reverseCount", " byteRel", "ByteParts", "byteCount", "channeldata", "ioList", "reverseData", "byteDATA", "channelRel", "sliceDATA"], "sb": ["bt", "bh", "bg", "wb", "bs", "b", "obb", "erb", "bf", "SF", "kb", "bps", "bb", "sh", "sq", "sp", "ib", "pb", "sam", "sf", "sw", "mb", "sm", "gb", "sv", "lp", "ub", "eb", "sg", "ssl", "zb", "rb", "SB", "si", "sbm", "bash", "sa", "nb", "db", "ob", "cb", "xb", "lb", "bis", "bsp", "bj", "shell"], "i": ["info", "m", "err", "I", "oi", "y", "io", "me", "init", "ie", "json", "series", "ms", "u", "j", "gi", "o", "pi", "it", "di", "ind", "client", "er", "to", "print", "ai", "\u0438", "q", "bi", "li", "loop", "major", "im", "phi", "ii", "qi", "my", "ion", "ti", "life", "ini", "history", "ski", "hi", "list", "this", "multi", "iy", "uri", "iu", "ip", "cli", "ij", "ki", "xi", "remote", "ei", "ji", "iq", "ci", "ime", "gu", "mi", "ui", "id", "ic", "l", "g", "set", "si", "ri", "point", "sim", "ix", "ims", "chain", "ity", "any"], "hexString": ["hexResource", "shortString", "exstring", "fullstring", "hexstring", "htmlArray", "hashArray", "htmlString", "htmlBuffer", "shortstring", "fullStore", "hexArray", "hashString", " hexstring", "hashBuffer", " HexResource", "exString", "htmlstring", "shortBuffer", "fullString", "exBuffer", " hexResource", "shortResource", " HexBuffer", " Hexstring", " hexStore", " hexArray", "shortArray", " HexString", "exStore", "hashstring", "hexStore", "hexBuffer", "fullBuffer", " hexBuffer", "exArray"], "hex": ["full", "rex", "zh", "solid", "hl", "dump", "cont", "alph", "h", "prop", "mix", "raw", "none", "flash", "sh", "php", "sex", "pex", "temp", "x", "term", " sex", "ex", "cat", "tex", "exp", "oct", "def", "alias", " Hex", " ex", "com", "ph", "ext", "json", "comp", "lit", "html", "des", "form", "rendered", "tx", "hello", "he", "rh"]}}
{"id1": "3731077", "id2": "310182", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["downloadfile", " cpfile", "downloadDirectory", "downloadFile", "copyfile", " cpFiles", "CopyFiles", "Copyfile", "downloadFiles", " cpDirectory", "CopyDirectory", "copyFiles", "copyDirectory", " cpFile", "CopyFile"], "from": ["info", "what", "before", "orig", "link", "old", "un", "path", "bean", "url", "a", "range", "base", "se", "add", "or", "part", "name", "ol", "s", "From", "reset", "f", "by", "with", "of", "without", "rom", "source", "str", "org", "pro", "term", "st", "local", "start", "origin", "string", "input", "original", "star", "query", "fr", "html", "at", "as", "config", "db", "form", "data", "vol", "view", "file", "so", "por"], "to": ["full", "tom", "tt", "that", "pretty", "null", "t", "po", "phi", "table", "total", "o", "top", "base", "it", "on", "or", "none", "parent", "eto", "name", "must", "this", "bo", "f", "by", "temp", "toc", "th", "one", "ta", "org", "tu", "no", "To", "st", "output", "etc", "tree", "dest", "oto", "token", "template", "two", "nt", "too", "target", "te", "html", "into", "auto", "size", "file", "co", "TO", "pt"], "parentDir": [" parentdir", "netDir", "Parentdir", "parentdir", "parentDirectory", "ParentDir", "parentFolder", "netdir", "rootdir", "parentFile", " parentDirectory", "ParentDirectory", "rootDir", "rootFolder", "masterFolder", "masterDir", "rootFile", "masterDirectory", "netFile", "masterFile", "netFolder", "ParentFolder", " parentFile", "ParentFile", " parentFolder"], "in": ["gin", "re", "vin", " IN", "update", "mc", "mi", "o", "get", "up", "cin", "it", "on", "raw", "ini", "inf", "inn", "ind", "id", "ain", "min", "ins", "rin", "print", "doc", "inc", "al", "source", "one", "IN", "mm", "win", "init", "local", "en", "bin", "isin", "inner", "all", "con", "input", "ri", "conf", "sin", "din", "ma", "i", "inside", "config", "irc", "xml", "form", "is", "ir", "In", "net"], "out": ["go", "cn", "os", "null", "t", "err", "nin", "gc", "b", "gt", "c", "ion", "ot", "o", "css", "aos", "na", "it", "on", "or", "ns", "list", "client", "v", "can", "obj", "outs", "io", "op", "write", "one", "n", "g", "res", "ln", "no", "cmd", "ro", "output", "ex", "Out", "all", "con", "again", "nt", "outer", "conv", "ou", "oss", "i", "at", "sys", "auto", "file", "OUT", "co", "vol", "ne", "cos", "net"], "ic": ["ico", "eric", "wic", "icy", "ci", "tc", "nic", "tic", "pic", "c", "IC", "rc", "ot", "cin", "it", "isc", "cc", "icon", "ric", "ins", "inc", "ican", "mic", "iu", "icc", "sic", "fc", "ip", "pc", "vc", "arc", "ics", "cu", "ik", "i", "iac", "ix", "irc", "aic", "co", "bc", "ac", "cus"], "oc": ["ico", "nc", "mot", "ci", "ox", "tc", "nic", "pic", "gc", "ec", "c", "og", "ot", "cot", "o", "soc", "oci", "ocon", "osc", "oe", "cus", "ric", "ucc", "ocr", "toc", "ict", "oco", "mic", "unc", "aco", "anc", "voc", "pc", "vc", "arc", "oct", "cu", "yo", "alloc", "OC", "irc", "aic", "co", "oca", "roc", "cos", "ac", "oly"]}}
{"id1": "23585985", "id2": "18696387", "code1": "    public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException {\n        StreamSource streamSource = new StreamSource();\n        if (item.getType() == Type.JAVA_OBJECT) {\n            LOG.debug(\"Streaming Java object\");\n            Object obj = ((JavaObjectValue) item).getObject();\n            if (!(obj instanceof File)) {\n                throw new XPathException(\"Passed java object should be a File\");\n            }\n            File inputFile = (File) obj;\n            InputStream is = new FileInputStream(inputFile);\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(inputFile.toURI().toURL().toString());\n        } else if (item.getType() == Type.ANY_URI) {\n            LOG.debug(\"Streaming xs:anyURI\");\n            String url = item.getStringValue();\n            if (url.startsWith(\"/\")) {\n                url = \"xmldb:exist://\" + url;\n            }\n            InputStream is = new URL(url).openStream();\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(url);\n        } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) {\n            LOG.debug(\"Streaming element or document node\");\n            if (item instanceof NodeProxy) {\n                NodeProxy np = (NodeProxy) item;\n                String url = \"xmldb:exist://\" + np.getDocument().getBaseURI();\n                LOG.debug(\"Document detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n            Serializer serializer = context.getBroker().newSerializer();\n            NodeValue node = (NodeValue) item;\n            InputStream is = new NodeInputStream(serializer, node);\n            streamSource.setInputStream(is);\n        } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) {\n            LOG.debug(\"Streaming base64 binary\");\n            BinaryValue binary = (BinaryValue) item;\n            byte[] data = (byte[]) binary.toJavaObject(byte[].class);\n            InputStream is = new ByteArrayInputStream(data);\n            streamSource.setInputStream(is);\n            if (item instanceof Base64BinaryDocument) {\n                Base64BinaryDocument b64doc = (Base64BinaryDocument) item;\n                String url = \"xmldb:exist://\" + b64doc.getUrl();\n                LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n        } else {\n            LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType()));\n            throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType()));\n        }\n        return streamSource;\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"getStreamSource": ["getFormSources", " getStreamStream", " getFormIterator", "getRawIterator", "getStreamerSource", " getStreamIterator", "getStreamerSources", "getRawStream", "getStreamSources", "getFormStream", " getFormSources", "getStreamStream", " getFormSource", "getFormIterator", " getFormStream", " getStreamSources", "getStreamIterator", "getRawSource", "getRawSources", "getStreamerIterator", "getStreamerStream", "getFormSource"], "item": ["info", "m", "that", "oc", "empty", "attr", "pkg", "abc", "up", "add", "menu", "article", "tk", "claim", "op", "atom", "anything", "om", "att", "input", "word", "json", "el", "attribute", "row", "it", "raw", "stuff", "cell", "unit", "source", "term", "related", "xml", "job", "key", "status", "result", "record", "re", "other", "link", "val", "document", "ref", "Item", "mix", "on", "check", "store", "jack", "list", "this", "spec", "element", "items", "hit", "test", "iter", "good", "app", "area", "addr", "msg", "initial", "remote", "module", "detail", "rule", "object", "value", "mem", "device", "now", "name", "p", "image", "owner", "content", "local", "exp", "container", "tree", "instance", "original", "com", "sim", "edit", "entry", "type", "handle", "event"], "context": ["info", "c", "document", "runtime", "object", "component", "mc", "information", "condition", "check", "parent", "cc", "environment", "system", "connection", "sequence", "resource", "kernel", "wrapper", "content", "event", "cache", "application", "construct", "set", "ctx", "location", "metadata", "search", "state", "template", "operator", "input", "instance", "current", "network", "index", "Context", "config", "view", "chain", "tx", "subject", "options", "text", "command", "collection"], "streamSource": ["streamManager", "consoleManager", "streamType", "designSOURCE", "runtimeSOURCE", "socketSource", "StreamSource", "consoleProvider", "hostSource", " streamSite", "StreamProvider", "peerSourceFile", "constSite", "hostSourceFile", "streamScan", "streamScope", "feedSourceFile", "streamSources", "signScope", "constSourceFile", "feedSources", "streamSpec", "streamSOURCE", " streamType", "followStore", "followSpec", "socketSourceFile", "acceptSite", "StreamSources", "StreamSOURCE", "designSpec", "runtimeScope", " streamSpec", "followSOURCE", "socketStore", "designSource", " streamScope", " streamManager", "acceptSource", "consoleType", "streamStore", " streamStore", "signSource", "peerSource", "followSource", "runtimeSource", " streamSources", "feedSOURCE", "signSOURCE", "designStore", "acceptSourceFile", "streamSite", "StreamManager", " streamProvider", "hostType", "constScan", "consoleSourceFile", "feedStore", "peerSite", "streamSourceFile", "streamProvider", "consoleSource", "consoleSources", "consoleStore", "hostStore", "peerScan", " streamSOURCE", "socketSite", "constSource", " streamSourceFile", "acceptScan", "feedSource", "feedSite"], "obj": ["os", "bh", "cmp", "ox", "t", "sky", "oc", "j", "resp", "attr", "pkg", "mk", "object", "ot", "o", "ref", "aos", "stuff", "Obj", "ct", "y", "bo", "tk", "obo", "x", "org", "js", "oj", "cmd", "txt", "ex", "act", "jj", "xy", "def", "ck", "pot", "app", "nt", "tmp", "json", "abs", "ob", "cb", "msg", "ht", "co", "mo", "cod", "bj", "aux", "obs"], "inputFile": ["mediaFile", "sequenceFile", "importFile", " inputFiles", "mediaFILE", "inputPath", " inputPath", "inputFILE", " inputfile", " inputObject", "textFile", "InputObject", "Inputfile", "inputFiles", " InputFile", "mediaObject", "textFILE", "mediafile", "sequencefile", "inputSet", "InputFile", "InputFiles", "textObject", "importObject", "importPath", "sequenceObject", " InputSet", " inputSet", "inputfile", " InputObject", "textfile", "importFiles", "InputPath", "InputFILE", "inputObject", "sequenceSet", " Inputfile"], "is": ["info", "was", "os", "ms", "sis", "isl", "ils", "im", "bs", "cont", "ls", "has", "lis", "ios", "its", "isi", "isc", "tis", "es", "iss", "ists", "atis", "cs", "ains", "ins", "s", "isf", "dis", "js", "fs", "res", "mis", "iris", "nis", "set", "init", "isin", "ics", "ris", "ys", "iso", "xs", "sim", "i", "abs", "sys", "as", "Is", "IS", "ires", "ais", "stats", "ims", "bis", "isa", "obs"], "url": ["full", "handle", "domain", "sql", "lr", "ur", "http", "email", "hl", "link", "run", "attr", "href", "pkg", "https", "path", "ref", "ls", "host", "util", "gl", "prefix", "ml", "address", "id", "uri", "l", "log", "sl", "f", "nl", "r", "print", "rl", "q", "term", "str", "org", "rel", "impl", "mount", "console", "user", "ssl", "string", "pattern", "char", "Url", "mail", "web", "html", "el", "norm", "db", "xml", "external", "ul", "addr", "tm", "dl", "ll", "format", "len", "loc", "label", "cert", "URL", "browser", "dir"], "np": ["dn", "nc", "mp", "nr", "pd", "pkg", "fp", "dh", "nv", "nm", "pn", "mn", "nl", "n", "lp", "nu", "nn", "dp", "gov", "vp", "NP", "jp", "rpm", "bp", "num", "nb", "hp", "ph", "kr", "nw", "rn", "nit", "tp", "wp"], "serializer": ["initialization", "serialiser", "serialization", "virtualizer", "virtualization", "virtualifier", " serialer", "initialisation", "initialiser", "initialifier", " serialization", "virtualisation", "serialisation", " serialiser", "initializer", " serialisation", "serialifier", "serialer", " serialifier", "erialer", "erialiser", "erialization", "initialer", "erializer"], "node": ["src", "m", "row", "document", "object", "component", "Node", "value", "nm", "oid", "name", "image", "resource", "article", "od", "seed", "content", "doc", "source", "n", "nu", "nn", "entity", "tree", "token", "nt", "root", "num", "json", "mor", "xml", "msg", "view", "remote", "entry", "nb", "event"], "binary": ["null", "_", "Entry", "get", "Store", "New", "of", "n", "ex", "Raw", "instance", "Source", "xml", "Ex"]}}
{"id1": "21368981", "id2": "14619453", "code1": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"create": ["process", "api", "install", "send", "creat", "upload", "read", "activate", "submit", "creation", "get", "add", "release", "build", "post", "write", "created", "request", "Create", "save", "instance", "launch", "insert", "execute", "hello"], "application": ["usage", "api", "aton", "b", "expression", "document", "object", "amount", "component", "information", "base", "management", "value", "binding", "address", "system", "client", "message", "sequence", "resource", "provided", "Application", "content", "service", "request", "code", "language", "app", "position", "database", "json", "face", "description", "apache", "data", "entry", "type", "command", "attribute"], "response": ["answer", "api", "detail", "resp", "document", "object", "onse", "default", "information", "add", "version", "value", "block", "message", "sequence", "image", "summary", "report", "library", "service", "request", "respond", "action", "example", "me", "function", "respons", "site", "see", "output", "profile", "complete", "page", "tree", "reply", "position", "server", "network", "Response", "continue", "index", "next", "json", "relation", "hash", "frame", "description", "model", "view", "entry", "format", "status", "command", "result", "attribute", "collection"], "connection": ["usage", "office", "link", "expression", "close", "c", "ion", "engine", "component", "statement", "creation", "character", "information", "cone", "reference", "condition", "version", "government", "device", "when", "Connection", "client", "bo", "directory", "library", "wrapper", "event", "pointer", "conn", "operation", "connected", "number", "license", "n", "method", "function", "no", "builder", "user", "set", "location", "language", "volume", "container", "con", "position", "server", "network", "database", "relation", "session", "query", "web", "communication", "connect", "description", "subject", "generation", "entry", "channel", "open", "machine", "translation", "command", "attribute", "collection"], "obj": ["dict", "os", "err", "po", "utt", "j", "obb", "resp", "og", "object", "o", "ref", "Obj", "adj", "obs", "tk", "obo", "str", "org", "js", "np", "oj", "output", "txt", "ctx", "objects", "onet", "uj", "nt", "body", "tmp", "json", "inv", "ob", "msg", "data", "ent", "bj", "arr"]}}
{"id1": "18489832", "id2": "12172485", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" tryLoadZippedImage", " tryLoadXippedfile", " tryLoadXZipfile", " tryLoadZppedFile", " tryLoadZZipFile", " tryLoadZZipImage", " tryLoadZressedFile", " tryLoadXZipFile", " tryLoadZZipfile", " tryLoadZppedImage", " tryLoadXZipImage", " tryLoadZressedImage", " tryLoadXippedDir", " tryLoadZippedDir", " tryLoadZppedfile", " tryLoadZippedfile", " tryLoadZppedDir", " tryLoadXippedFile", " tryLoadZressedfile", " tryLoadZressedDir", " tryLoadXippedImage", " tryLoadZZipDir", " tryLoadXZipDir", " tryLoadZippedFile"], "url": ["ret", "row", "ur", "err", "http", "parse", "link", "b", "https", "un", "ref", "open", "get", "base", "key", "raw", "build", "address", "name", "l", "uri", "log", "sl", "r", "nl", "call", "request", "str", "mount", "location", "ssl", "char", "Url", "web", "ul", "xml", "external", "file", "ll", "dl", "loader", "URL", "browser"], "destDir": ["targetDir", "sourceFolder", "distDir", "sourceFile", "originFolder", " destFile", " destDirectory", "sourceDir", "targetFolder", "srcFolder", "originDirectory", "sourceDirectory", "distDIR", "originDir", "destDirectory", " destDIR", "destFile", " destFolder", "srcDirectory", "targetDirectory", "srcDIR", "srcFile", "distFolder", "destFolder", "distDirectory", "srcDir", "targetDIR", "destDIR", "originDIR"], "urlConnection": ["urlConnect", " urlConnect", "URLConnector", "URLConnection", "httpDialog", " urlDialog", "urlClient", "httpLink", "UrlLink", "URLCompany", "streamCompany", "urlCompany", "UrlConnect", "streamClient", " urlClient", " urlLink", "URLClient", "urlLink", "UrlConnection", "httpConnect", " urlCompany", "UrlDialog", "httpConnection", "urlConnector", "urlDialog", "streamConnector", "streamConnection", " urlConnector"], "tmpFile": ["empChain", " tmpTile", "cmpPage", "destPage", "mpfile", "tmpPage", " tmpfile", "destfile", "empFilename", "tempChain", " tmpView", "tempFilename", "tempDir", "thisfile", "empFile", "thisFile", "mpFile", "tmpBe", "destBe", "empDir", "cmpFilename", "tempfile", "tempFile", "thisFilename", "tempTile", " tmpPage", "thisChain", "tmpView", "tempBe", " tmpDir", "cmpfile", "empView", "destFile", "tmpFilename", "tmpfile", "tempPage", "empTile", "tmpTile", " tmpBe", "empfile", "tmpChain", " tmpFilename", "tempView", "cmpFile", "tmpDir"], "in": ["gin", "pass", "info", "re", "im", "old", "oin", "mi", "up", "cin", "it", "on", "or", "none", "ini", "inf", "inn", "ind", "ze", "ain", "ains", "ins", "l", "rin", "by", "inc", "ai", "al", "source", "one", "n", "ln", "st", "IN", "from", "iter", "win", "init", "en", "isin", "bin", "inner", "ie", "all", "con", "input", "sin", "din", "index", "ma", "i", "inside", "query", "el", "as", "is", "co", "In"], "out": ["cn", "os", "null", "t", "po", "note", "exit", "ch", "o", "up", "aos", "na", "it", "on", "or", "oe", "client", "v", "writer", "obj", "can", "to", "outs", "print", "flush", "io", "write", "one", "n", "cos", "no", "output", "ex", "Out", "all", "con", "nt", "conv", "tmp", "outer", "ou", "oss", "at", "sys", "OU", "external", "OUT", "co", "ne", "ent", "col", "net"], "localURL": ["LocalURI", " localUL", "LocalURL", "localhostURL", "localUR", " localUR", "LocalLL", "publicURI", "LocalUrl", "publicUrl", "localhostUL", "publicURL", " localURI", "localhostLL", " localUrl", "localID", "LocalID", " localID", "publicUR", "localURI", "localhostID", "localUL", " localLL", "localLL", "LocalUL", "localUrl", "LocalUR"]}}
{"id1": "20247400", "id2": "16388708", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"in": ["gin", "info", " din", "up", "cin", "it", "on", "check", "inf", "inn", "ind", "ze", "ins", "rin", "io", "inc", "ai", "source", "from", "IN", "init", "bin", "inner", "isin", "con", "input", "din", "i", "file", "is", "and", "In", "net"], "out": ["os", "null", "t", "err", "exit", "w", "b", "other", "gt", "ot", "o", "line", "it", "or", "check", "list", "name", "client", "writer", "obj", "ins", "to", "log", "print", "report", "io", "r", "outs", "write", "str", "n", "ln", "cmd", "output", "ex", "Out", "con", "screen", "outer", "ou", "oss", "at", "sys", "OU", "println", "auto", "msg", "OUT", "ne", "we", "dir", "net"], "buffer": ["bar", "memory", "processor", "phrase", "binary", "buff", "b", "table", "length", "total", "variable", "document", "sample", "component", "key", "batch", "se", "block", "Buffer", "available", "history", "address", "filter", "message", "sequence", "limit", "flush", "library", "cache", "temp", "queue", "source", "pause", "window", "buf", "function", "output", "iter", "template", "position", "bridge", "database", "index", "stack", "db", "trace", "comment", "header", "data", "view", "match", "channel", "command", "size", "clear", "display", "attribute", "event", "result", "shape", "append"]}}
{"id1": "10361370", "id2": "9479502", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"hash": ["update", "crypt", "h", "ash", "version", "check", "filter", "message", "password", "print", "code", "test", "ashes", "sign", "profile", "render", "Hash", "index", "sum", "tag", "html", "header", "match", "array", "key", "handle", "attribute"], "saltBefore": ["saveAfter", "SaltAfter", "sALTAfter", "SALTAfter", "saveBefore", "SaltBefore", "SALTBefore", "SaltPrevious", "sadeAfter", "sashBefore", "savePrevious", "sadePrevious", " saltStart", " sALTAfter", "saltStart", "sashAfter", "sALTPrevious", "sALTStart", "sALTBefore", "SALTPrevious", "saltPrevious", " sALTStart", " sALTBefore", "sadeStart", "sadeBefore", "sashStart"], "content": ["record", "null", "expression", "c", "cont", "document", "Content", "object", "path", "url", "raw", "value", "reason", "media", "message", "image", "sequence", "password", "source", "license", "example", "str", "code", "output", "txt", "entity", "title", "string", "input", "current", "present", "word", "body", "json", "config", "html", "comment", "xml", "data", "file", "initial", "subject", "translation", "description", "time", "format", "text", "any"], "saltAfter": ["valtAfter", "sadePost", "saveAfter", "SaltAfter", "SALTAfter", "sALTAfter", "saveBefore", "SaltBefore", "saltPost", "sintBody", "sintafter", "saveBody", "vintBody", "sALTafter", "SALTBefore", "vintAfter", "soltBefore", "SALTResult", "valtBody", "valtBefore", "sALTBody", "sadeAfter", "saltResult", "SALTPost", "sALTPost", "sadeResult", "soltResult", "valtafter", "SaltPost", "sALTResult", "sALTBefore", "sintBefore", "SaltResult", "saltBody", "saltafter", "vintafter", "soltAfter", "soltPost", "saveafter", "vintBefore", "sadeBefore", "sintAfter"], "repeatedHashingCount": ["repeatedHASHCount", "repeatedHashingLength", "repeatedHashingCode", "repeatedHachingLength", "repeatedHachingCode", "repeatedHASHcount", "repeatedHashcount", "repeatedHashCode", "repeatedHASHCounter", "repeatedRashingCode", "repeatedRashesCount", "repeatedHashCount", "repeatedHashLength", "repeatedRashLength", "repeatedRashescount", "repeatedRashingCount", "repeatedHachingCC", "repeatedRashesLength", "repeatedRashesCounter", "repeatedRashingCC", "repeatedHashingCC", "repeatedHashesCode", "repeatedHashingcount", "repeatedRashCount", "repeatedHashesCount", "repeatedRashingcount", "repeatedHashescount", "repeatedRashingCounter", "repeatedRashingLength", "repeatedHASHLength", "repeatedHashingCounter", "repeatedHashCounter", "repeatedHashesCounter", "repeatedHachingCount", "repeatedHashCC", "repeatedHashesLength", "repeatedRashCode", "repeatedHashesCC", "repeatedRashCC"], "digest": ["digse", "debugEST", " digum", "digency", "Digested", "fingerest", " dighest", "dert", "dfested", "digester", "argEST", "dighash", "Digests", "digesting", "compEST", " digert", "DigEST", "hashest", "digert", "dested", "Digist", "Dighash", "argester", "hashhash", " digency", " digEST", "mdester", "debugitude", " Digested", "fingerhest", "dse", "fifitude", "fifest", "commest", "debugest", " digist", " digesting", " digitude", "algest", "printhest", "digests", "extest", " Digest", "printest", "Digum", "algester", "Digute", "digitude", "extested", "diagnests", "algEST", " digester", "algested", "designest", "fingeresting", "digute", "printEST", "diagnist", "digum", "hashEST", "dfesting", " digested", "dighest", "comphash", "commity", "mdse", "descity", "commested", "digist", "descest", "Digest", "Digester", "hashute", "digEST", "extse", "mdested", " digity", "fifEST", "designester", " Digester", "Digse", "digity", "commse", "diagnest", "dester", "digested", "argest", "designesting", "mdest", "fingerEST", "extester", "designested", "dfester", "compest", "debugency", "diagnum", "dest", "descse", "fifency", " digse", "argested", "dfest", " Digert", "printesting", " digests", "compute", "descested"], "digestLength": ["digistData", "digselength", "digseOffset", "digesterOffset", "digestedType", "digestedLength", "descesterLength", "digesterlength", "digestData", "digesterType", "digseLen", " digesterLength", "descesterLen", "descestLen", "digesterData", "descesterOffset", " digestLen", "digseLength", "digestLen", " digestData", "digestlength", " digesterType", "descesterlength", "digistType", "descestOffset", " digesterData", "digestedLen", "descestlength", "descestLength", "digestedOffset", "digesterLength", "digistLen", " digesterLen", "digestedlength", "digistLength", "digestOffset", "digestedData", "digesterLen", " digestType", "digestType"], "i": ["iq", "m", "ms", "sql", "ci", "u", "im", "err", "in", "z", "phi", "j", "ii", "gi", "gu", "qi", "my", "I", "mi", "ti", "batch", "pi", "it", "di", "ini", "ui", "ind", "ski", "client", "v", "y", "multi", "mill", "ic", "print", "uu", "uri", "ai", "q", "x", "n", "me", "iu", "bi", "ex", "iter", "ip", "cli", "init", "si", "index", "sim", "li", "ix", "xi", "is", "ei"]}}
{"id1": "8932510", "id2": "823074", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["actionPre", "DoPut", "actionPut", "doPre", " doPOST", "actionPost", "DoPre", "actionPOST", "DoPOST", "DoPost", " doPut", "doPOST", "doPut", " doPre"], "request": ["info", "QUEST", "http", "get", "register", "pair", "block", "quest", "address", "context", "enter", "user", "input", "subject", "cgi", "self", "project", "error", "client", "post", "report", "select", "order", "search", "art", "query", "session", "web", "remove", "form", "requ", "xml", "Request", "command", "record", "memory", "re", "have", "setup", "document", "condition", "store", "this", "change", "question", "connection", "call", "application", "current", "server", "position", "java", "first", "initial", "remote", "forward", "object", "url", "reference", "message", "resource", "reset", "req", "create", "start", "copy", "container", "instance", "frame", "time", "complete"], "response": ["send", "resp", "document", "object", "default", "onse", "information", "success", "version", "release", " responding", "ce", "connection", "context", "image", "report", "reset", "write", "respond", "one", " Response", "application", "res", "respons", "site", "output", "tree", "reply", "render", "Response", "session", "frame", "description", "model", "view", "event", "result"], "is": ["info", "was", "ms", "sis", "isl", "in", "isa", "has", "lis", "ios", "isi", "its", "ips", "isc", "es", "tis", "iss", "ists", "image", "isp", "ins", "bits", "ois", "mis", "iris", "ip", "init", "isin", "si", "ris", "ys", "iso", "xs", "i", "as", "Is", "IS", "ais", "ims", "bis", "icks", "ir", "obs"], "page": ["browser", "go", "row", "pos", "po", "link", "table", "pp", "document", "object", "pages", "url", "o", "stream", "line", "wiki", "part", "sp", "error", "address", "message", "p", "port", "image", "menu", "post", "resource", "article", "content", "cache", "out", "Page", "node", "pe", "pc", "title", "token", "server", "index", "next", "point", "session", "proxy", "age", "html", "pool", "frame", "form", "file", "view", "data", "entry", "result"], "os": ["Os", "ms", "pos", "po", "offset", "o", "ios", "or", "oid", "es", "ui", " o", "s", "io", "op", "sw", "res", "oos", "si", "ops", "iso", "oss", "pool", "so", "mo", "OS", "ps"], "rootUrl": ["parentUrl", "rootURL", "homeUrl", " rootURL", "baseUr", " rootDir", "baseUrl", "parenturl", "parentUr", "baseDir", "parentURL", "webUr", "rootUr", "homeurl", "webDir", " rootUr", "homeURL", "webURL", "rootDir", "homeUr", " rooturl", "rooturl", "baseURL"], "isMultipart": ["isMultiispart", "isMulticart", "isMultipland", "isMultisparted", "isMultipage", "isMultIParted", "isMultiparted", "isMultispage", "isMultIPand", "isMultiisparted", "isMultIPart", "isMultiiparted", "isMultiplage", "isManipage", "isMultiisparts", "isMultiipart", "isMultiiparts", "isManIParts", "isMulticarts", "isManIPart", "isMultIPage", "isMulticage", "isManipand", "isManipart", "isMultisparts", "isMultiparts", "isManIPand", "isManIPage", "isManiparts", "isMultIParts", "isMultiplart", "isMultiispage", "isMultispart", "isMultiipage", "isMultispand", "isMultipand", "isMulticarted", "isMultiplarts"], "rd": ["dd", "rt", "ud", "gd", "rw", "ard", "rob", "rend", "ld", "rc", "rand", "dra", "xd", "dk", "erd", "nd", "RD", "rer", "ind", "rus", "dig", "ra", "r", "rl", "rg", "hr", "hod", "yd", "ord", "ro", "rs", "rod", "nder", "dr", "td", "rb", "rid", "ird", "ptr", "fr", "hd", "rown", "red", "fd", "rn", "rh", "vd", "rr", "adr"], "upload": ["row", "install", "ack", "allow", "update", "pload", "archive", " Upload", "ut", "util", "up", "add", "aw", "own", "Upload", "delete", "grab", "ow", "image", "post", "uploads", "select", "create", "art", "move", "save", "input", "tmp", "fax", "transfer", "imgur", "form", "attach", "file", "insert", "execute", "download", "ud", "load"], "webUrl": ["httpUr", "weurl", "netURL", "rootURL", "webPath", "neturl", "webPort", "weVer", "netPath", "rootVer", "wwwURL", "wwwPath", "webUr", "rootPort", "WebUr", "wwwUrl", "weURL", "rootUr", "netUrl", "httpVer", "WebURL", "weUrl", "webURL", "netUr", "wePort", "httpUrl", "webVer", "Weburl", "rootPath", "weburl", "weUr", "WebUrl", "wwwUr", "httpPort"], "iter": ["IT", "oper", "train", "fer", "tif", "where", "coll", "ner", "iz", "ver", "it", "valid", "ser", "ind", "iterator", "er", "Iter", "reader", "iver", "loader", "ait", "order", "cer", "ip", "former", "init", "kit", "inter", "inner", "iv", "tr", "outer", "next", "orient", "walker", "i", "li", "ter", "inv", "iner", "loop", "loc", "ipper", "ator", "ir", "dir"], "item": ["info", "record", "m", "row", "module", "im", "other", "in", "link", "rule", "object", "option", "Item", "up", "base", "it", "block", "or", "value", "mem", "store", "iterator", "error", "image", "unit", "obj", "element", "tab", "member", "atom", "hit", "source", "order", "local", "ip", "step", "stat", "mm", "container", "word", "instance", "area", "json", "li", "el", "file", "entry", "key", "status", "event", "attribute"], "name": ["NAME", "module", "Name", "old", "cap", "path", "o", "key", "a", "base", "prefix", "on", "block", "part", "parent", "common", "id", "normal", "resource", "sequence", "source", "one", "term", "n", "magic", "no", "order", "local", "named", "string", "title", "alias", "class", "word", "num", "ma", "names", "ame", "data", "file", "size", "channel", "len", "family", "type", "label", "event"], "baos": [" bao", "BAo", "kaoes", "BAos", "BAoes", "boo", " baops", "gaOS", "aoos", "baops", "gais", "gaos", "daos", "waoss", " baoss", "baoss", "daoes", "aooss", "boops", "waos", "BAops", "bao", "booes", "kaoss", "BAoS", "aoOS", "BAis", "waOS", "BAOS", "gaoss", "kaOS", "boos", " baoes", "baoes", "daOS", "kaos", "BAoss", "bois", "daoss", "aooS", "boOS", "bais", "baoS", "booS", "wais", "gaoS", "booss", "baOS"], "wpIs": ["phpIs", "cpIs", "phpI", "ipIs", "wpIm", "wtI", "wordpressI", "wpUrl", "hwIS", "phpAre", "wordpressUrl", "wpInst", "wordpressis", "cpIS", "hwIs", "wtShares", "xpI", "fwUrl", "WPIs", "fwIs", "wpAre", "wtIs", "xpShares", "WPUrl", "phpShares", "wpIS", "phpIS", "wordpressIS", "hwInst", "wpis", "WPIm", "xpAre", "WPI", "wordpressIs", "WPInst", "fwIm", "WPIS", "phpis", "fwI", "wpShares", "xpIs", "wtAre", "ipInst", "wpI", "hwI", "ipI", "cpis", "ipIS", "wordpressIm"], "u": ["ur", "w", "gu", "mu", "us", "o", "url", "it", "su", "lu", "au", "ui", "p", "uv", "uf", "hu", "l", "uu", "f", "r", "io", "uri", "ux", "fu", "tu", "iu", "ru", "nu", "U", "uid", "user", "uj", "cu", " nu", "ou", "i", "ul", "eu", "uni", "ue", "bu"]}}
{"id1": "4602568", "id2": "21348951", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"storeImage": ["StoreImage", "saveImages", "StoreImages", "storePicture", "saveFile", "savePicture", "StorePicture", " storeImages", "storeFile", "storeImages", " storePicture", "saveImage", "StoreFile", " storeFile"], "inStream": ["inSteam", "cinFile", "fileSteam", "cinSteam", "outForm", "inView", "cinStream", "outFile", " inSteam", "inForm", "inputSteam", "inFile", "inputView", " inView", "inputFile", "fileForm", "cinView", " inFile", "fileFile", " inForm", "fileStream", "outSteam", "inputStream"], "fileName": [" filename", "resourcePath", "fileTime", " fileInfo", " filePath", "FileType", "resourceName", "FILEName", "FileTime", "imageInfo", "imageName", "FILEPath", "fileInfo", "FileInfo", "FilePath", "fileType", "FILEInfo", " fileType", "FILEname", "resourceType", "resourceTime", "FileName", "imagePath", "imagename", "filePath", "imageType", "Filename", "imageTime", "filename"], "resize": ["Ressize", "Resizes", "ressize", "Resized", "rensize", " resizes", "renizes", "renize", "resizes", "resized", "renized", " ressize", "Resize", " resized"], "rightNow": ["westFuture", " RightNOW", "RightToday", "rightCurrent", "westCurrent", " RightThen", "westNow", "correctNOW", "westToday", " rightCurrent", "RightCurrent", "rightThen", " rightServer", " rightThen", "correctToday", " rightNOW", " rightFuture", "rToday", "rightNOW", "rNow", "rServer", "rightServer", "rNOW", " RightCurrent", "rightToday", "correctNow", "RightNow", "rightFuture", "RightFuture", "correctFuture", " RightNow", "westServer", "westThen", " rightToday", "westNOW"], "dayNamedFolderName": ["dayNamedThemeSize", "dayNamingFolderSize", "dayNamedThemePath", "dayNamingFolderPath", "dayNamedThemeName", "dayNamingFolderNames", "dayNamedArea1", "dayNamingFileNames", "dayNamingDirectoryName", "dayNamingFolderName", "dayNamedfolderPath", "dayNamedfolder1", "dayNamedFolderPath", "dayNamedAreaNames", "dayNamedfolderName", "dayNamedFolderNames", "dayNamingDirectory1", "dayNamedFileName", "dayNamedfoldername", "dayNamingFilename", "dayNamingFilePath", "dayNamingDirectoryname", "dayNamedAreaname", "dayNamingFileName", "dayNamedDirectoryNames", "dayNamedfolderNames", "dayNamedFolder1", "dayNamedFileNames", "dayNamedAreaName", "dayNamedFilename", "dayNamingFileSize", "dayNamingFolder1", "dayNamingDirectoryNames", "dayNamingFoldername", "dayNamedThemeNames", "dayNamedFoldername", "dayNamedThemename", "dayNamedDirectoryname", "dayNamedFileSize", "dayNamedFolderSize", "dayNamedDirectoryName", "dayNamedFilePath", "dayNamedDirectory1"], "uploadDirRoot": ["uploadDbCover", "UploadDirRoot", " uploadDirroot", "uploaddirRoot", "UploadDbRoot", "uploadDbBase", "saveDirParent", "uploadFolderroot", "uploaddirroot", "uploadNetRoot", "uploadDbRoot", "uploadUrlBase", "UploadDbroot", "UploadDirBase", "uploadUrlRoot", "uploadFolderBase", "saveDbParent", "uploaddirCover", " uploadRelroot", "uploadUrlroot", " uploadRelPath", "UploadDbBase", "saveDirroot", " uploadRelBase", "uploadDirCover", "uploadUrlPath", "uploadDbroot", "uploadFolderPath", " uploadRelRoot", "saveDbRoot", "uploadDirBase", "uploadDirroot", "uploadRelroot", "uploadNetCover", "uploadRelBase", "UploadDirCover", "uploadDirectoryRoot", "uploadDirectoryParent", " uploadDirBase", "uploadUrlParent", "uploadRelRoot", "uploaddirBase", "uploadNetroot", "uploadDirPath", "uploadFolderRoot", "uploadDbParent", "UploadDbCover", " uploadDirPath", "uploadRelPath", "uploadDirectoryroot", "saveDirRoot", "UploadDirroot", "uploadDirParent", "uploadNetBase", "saveDbroot"], "file": ["full", "project", "File", "null", "t", "ile", "FILE", "link", "table", "run", "il", "h", "key", "get", "base", "top", "up", "parent", "name", "port", "resource", "image", "to", "f", "op", "folder", "source", "node", "no", "local", "entity", "page", "tree", "class", "work", "force", "el", "pool", "task", "channel", "type", "time", "open", "handle", "dir"], "extension": ["xtended", "dimention", "EXTension", "expensions", "extended", "expended", "exendant", "xtention", "dimension", "xtension", "expension", "xtend", "dimensions", "extention", "exension", "extend", "EXTention", "extensions", "EXTended", "exensions", "expendant", "expention", "dimendant", "expend", "exention", "EXTend", "extendant"], "outFileName": ["outFileNames", "outImageName", "OUTLogname", "outFileInfo", " outLogNames", "OUTLogKey", "outLogVersion", " outLogVersion", "outFilenameType", "outDirPath", "outFieldSize", "outFilesname", "outImageKey", "outFieldName", "outfileVersion", "inFileSize", " outLogName", "outFilenamename", "inFileType", "OutfileKey", "inFilename", "OUTFileName", "inFileName", "OUTLogName", "OUTFileKey", "outFieldType", "Outfilename", "infileType", " outLinePath", "outfilePath", "infileName", "outfileNames", "OUTFieldPath", "outLineName", "outFieldPath", "outLinename", "outLogNames", " outFilename", "OutFilename", "outLinePath", " outLogname", "outImageNames", " outFileVersion", "OutFileKey", " outFilePath", "outFileType", "OutFilePath", "outFileKey", " outLineNames", "OUTFieldname", "outFilenameNames", "outLineKey", "infileSize", "outFilenameName", "outFilenameVersion", "outfileName", "OUTFilename", "outfilename", "outLogName", "outFieldname", "outDirname", "outFilenamePath", "outLogKey", "outFilenameSize", "outFileVersion", "outLogname", " outLineInfo", " outLineName", "outFilenameKey", "outFilenameInfo", "infilename", "outImagePath", "OUTFieldName", " outFileInfo", "outDirName", "OutfilePath", "outImagename", "OutFileName", "OUTFilePath", "outfileSize", "outFileSize", "outFilename", "outFilesPath", "outLineNames", "outfileType", "outfileKey", "OUTLogPath", "outFilesName", "outImageInfo", "outLogPath", " outFileNames", "outFilePath", "OutfileName", "outLineInfo"], "outPathAndName": ["outPathandSize", "outLocationandSize", "outPathOrNames", "outPortButKey", "outPortButPath", "outPortAndPath", "outLocationAndKey", "outLocationAndName", "outPathandPath", "outTimeButPath", "outTimeButLike", "outPathOrName", "outTimeAndPath", "outPathandName", "outPathandKey", "outTimeAndTime", "outPathButPath", "outTimeAndLike", "outPathButLike", "outLocationandName", "outPathOrPath", "outPathANDPath", "outPathANDTime", "outLocationandNames", "outPathAndPath", "outPathButTime", "outPathAndLike", "outPortAndName", "outPathOrTime", "outPathOrLike", "outTimeButTime", "outPathButName", "outPathAndNames", "outPathANDName", "outPathandNames", "outPortButName", "outPathAndSize", "outPathAndTime", "outPathButKey", "outPathANDLike", "outLocationAndNames", "outTimeButName", "outTimeAndName", "outLocationAndSize", "outPathAndKey", "outPathOrSize", "outPathOrKey", "outPortAndKey", "outLocationandKey"], "uploadedFile": ["uploadmedPlace", "uploadedGlobal", "uploadededGlobal", "uploaderFILE", "uploadedPlace", "uploadtedFILE", "uploadashedField", "uploadtedField", "uploadiedUnit", " UploadedFile", "uploadpedFile", "uploadredFormat", "uploadredPlace", "uploadashedFILE", "uploadiedF", "uploadredGlobal", "presenttedFILE", "uploadpedUnit", "uploadiedFile", "presenttedfile", "presenttedField", "uploadiedLine", " UploadmedFormat", "uploadashedFile", " UploadedFormat", "uploadashedfile", "presentedField", " UploadedGlobal", " uploadededFile", "presentedFILE", "uploadpedLine", "uploadifiedUnit", "uploadedLine", " uploadedifiedUnit", "uploadedFormat", "uploadpedF", "uploadifiedLine", "uploadededPlace", "uploadmedFile", " uploadededF", "uploadtedfile", "uploadedF", "presenttedFile", "uploadedField", "presentedFile", " uploadededLine", " UploadmedFile", "uploadredFile", "uploadifiedFile", " UploadmedPlace", "presentedfile", " uploadedifiedLine", " UploadedPlace", " UploadmedGlobal", "uploadtedFile", "uploadedUnit", "uploadededFile", "uploadmedFormat", "uploadedfile", "uploadedFILE", "uploaderfile", "uploaderFile", "uploadmedGlobal", "uploadededFormat", "uploaderField", " uploadedifiedF", "uploadifiedF", " uploadedifiedFile", " uploadededUnit"], "outStream": ["oView", "inSteam", "_", "inView", "oStream", "outFile", " outView", "outView", " outFile", "inFile", "outSteam", "oFile", "oSteam", " outSteam"]}}
{"id1": "17111859", "id2": "18631594", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 1, "substitutes": {"getHash": ["Gethash", "getKey", "GetSum", "getSum", " gethash", "createHash", " getKey", "GetHash", "createSum", "createhash", "GetKey", "gethash", " getSum", "createKey"], "string": ["sql", "null", "text", "sample", "dump", "object", "key", "prefix", "pair", "value", "space", "list", "name", "address", "message", "buffer", "v", "s", "password", "content", "ring", "cache", "source", "function", "test", "pattern", "input", "instance", "char", "word", "hash", "comment", "data", "strings", "array", "format", "ident", "type", "filename", "chain", "status", "attribute"], "hashTime": [" hashTimer", "clockLength", " hashTimes", " hashLock", "messageTimer", "hashLength", "hashTimeout", "HashTimer", "HashTime", "messageTimeout", "clockTimeout", "clockTimer", "hashTimes", "clockTime", " hashLength", "messageLock", "HashTimes", " hashTimeout", "messageLength", "messageTimes", "HashLock", "messageTime", "hashTimer", "hashLock"], "md5": [" MDock", " MD3", " Md3", "hash3", "MD1", " Md55", "MD3", "md3", " md45", "dig2", "MD5", "mdock", "md10", "MD512", "md45", "dig45", "md55", "hash5", " md512", "det2", " mdock", " MD2", "md2", "dig1", " Mdock", "md512", " MD10", " md55", " MD55", "MD10", " MD5", " md3", " md1", "det3", "hash512", "MD2", " md10", "hash2", "md1", "det5", " md2", "MD45", "dig5", " Md5"], "result": ["ret", "answer", "cup", "hex", "row", "params", "table", "done", "total", "diff", "currency", "pair", "success", "results", "su", "valid", "comb", "list", "buffer", "sequence", "mate", "report", "r", "cache", "cur", "card", "res", "correct", "test", "output", "product", "complete", "search", "RESULTS", "work", "current", "reverse", "comp", "Result", "comment", "match", "response", "array", "chain"], "hexString": ["alphCharacter", " hexChain", " hexResult", "hexCharacter", "hexResult", " HexStr", "exChain", "charBuffer", "alphChain", "hexArray", "exResult", "exStr", " hexStr", " HexResult", "hexChain", "exString", "alphArray", "exBuffer", "charResult", " hexCharacter", "charString", "alphString", "hexStr", " hexArray", " HexArray", "exCharacter", " HexString", "charArray", "hexBuffer", " hexBuffer", "exArray"], "i": ["ji", "m", "u", "ci", "z", "in", "phi", "j", "gi", "ii", "gu", "qi", "my", "I", "us", "mi", "o", "a", "ti", "pi", "it", "e", "di", "ini", "ui", "ind", "hi", "id", "v", "y", "multi", "sequence", "to", "ic", "uri", "k", "io", "l", "ai", "\u0438", "q", "x", "n", "me", "bi", "ip", "cli", "si", "ki", "index", "sim", "li", "ix", "xi", "is", "ei", "chain"], "str": ["ret", "hex", "t", "Str", "sp", "name", "buffer", "sequence", "p", "obj", "stable", "r", "STR", "sw", "out", "enc", "cache", "n", "res", "st", "output", "txt", "ctr", "cr", "dr", "char", "tr", "br", "fr", "hash", "data", "msg", "key", "text", "chain", "status", "arr"]}}
{"id1": "12242903", "id2": "16063533", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"hashKey": ["updateLink", "updatekey", "processkey", "processLink", "processValue", "hashValue", "updateValue", "hashLink", "hashkey", " hashValue", " hashkey", "processKey", " hashLink", "updateKey"], "key": ["ace", "hex", "item", "secret", "null", "phrase", "link", "path", "prefix", "username", "base", "piece", "value", "name", "id", "message", "y", "this", "client", "port", "obj", "password", "k", "seed", "attribute", "cache", "service", "cert", "source", "code", "encrypted", "string", "title", "state", "template", "token", "conf", "KEY", "char", "foo", "json", "description", "sk", "data", "lock", "type", "hello", "entry", "Key", "text", "chain", "et"], "hashed": ["hushed", " hushed", "rhamped", "ahored", "hhed", "khash", "khhed", "hashing", "khrypted", "hamped", "hoted", "shhed", "hoashed", "ahushed", "hrypted", " hrypted", "shoted", "enhhed", "thushed", "rhashed", "thashed", "khashed", "shashed", "khashing", "ahashed", "hored", " hamped", "enhash", " hashing", "ahash", " hhed", "enhashed", "rhhed", "enhrypted", "thash", " hored", "thored", " hoted", "hohed", "shamped", "hoashing", "rhoted", "hoash"], "md5": ["det55", " MD3", "MD3", " MD45", "sha0", "md3", " md45", "MD5", "sha3", "md45", "md55", " MD2", "md2", "sha2", "dig55", " md55", "sha5", "dig3", " MD5", "MD0", " md3", "det3", "MD2", " md0", "det5", "md0", "MD45", " md2", "dig5"], "hash": ["hex", "ah", "shift", "hz", "sample", "length", "ssh", "total", "h", "score", "has", "uh", "ash", "block", "ashed", "check", "square", "sh", "sq", "count", "build", "message", "kernel", "trust", "number", "height", "search", "sha", "Hash", "hed", "index", "sum", "checked", "carry", "tag", "html", "always", "array", "handle", "radius", "shadow"]}}
{"id1": "13414771", "id2": "9824814", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encriptPassword": [" descryptKey", " descriptKey", " desizeField", " descriptPassword", "EnribeField", " descryptPassword", "EncriptPassword", "EncriptKey", "EnribePassword", " desizeAuth", "EncriptAuth", "EnribeAuth", " descriptAuth", " desribeField", " descryptField", " desribeKey", " desizeKey", "EncriptField", " descryptAuth", " desribePassword", " descriptField", "EnribeKey", " desribeAuth", " desizePassword"], "passwd": ["paswd", "asswd", " password", "defphrase", "pw", "passw", "assw", "mailword", "passphrase", " passw", "password", "pasw", " passsword", "defwd", "pword", "passsword", "pwd", "mailw", "defw", "assword", "psword", "pasword", "defword", "mailphrase", "mailwd", "assphrase"], "md": ["mod", "m", "ms", "pd", "df", "ld", " MD", "managed", "mk", "dh", "mc", "hm", "pm", "add", "desc", "MD", "di", "ind", "rm", "cd", "mn", "mt", "od", "bd", "mb", "mask", "sm", "mg", "sd", "cmd", "dm", "mm", "dr", "td", "ds", "pdf", "der", "nt", "ma", "mail", "hd", "at", "red", "mo", "down", "and", "dd", "d"], "hash": ["hex", "bh", "ah", "sample", "mac", "ssh", "h", "oh", "score", "has", "uh", "ash", "ashed", "check", "sh", "sq", "filter", "message", "kernel", "mass", "password", "trust", "hidden", "cache", "mask", "proof", "sha", "Hash", "hed", "sum", "checked", "hd", "her", "key", "rh", "shadow"]}}
{"id1": "11484416", "id2": "5676111", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"moveFile": ["Movefile", "MoveFile", "copyImage", "moveDirectory", "copyfile", "moveImage", "copyFile", " moveDirectory", " movefile", " moveImage", "copyDirectory", "movefile", "MoveImage", "MoveDirectory"], "orig": ["ret", "was", "src", "im", " ORIG", "dom", "old", "rc", " original", "Origin", "prop", "base", "lim", "raw", "or", "internal", "coord", "Original", "temp", "cur", "created", "org", "ori", "ord", "good", "iter", "ip", "create", "init", "Orig", "origin", "copy", "ie", "exp", "def", "act", "imp", "img", "original", "clip", "dest", "existing", "ex", "tmp", "proxy", "inv", "ra"], "target": ["ret", "src", "null", "t", "goal", "mac", "gt", "table", "path", "tile", "top", "base", "png", "it", "parent", "build", "Target", "out", "source", "rel", "test", "output", "local", "replace", "touch", "origin", "copy", "dest", "template", "tmp", "next", "sys", "arget", "file", "match", "format"], "buffer": ["bar", "memory", "paste", "phrase", "read", "binary", "buff", "length", "table", "sample", "variable", "document", "engine", "batch", "base", "stream", "line", "block", "mem", "Buffer", "bb", "history", "available", "filter", "message", "sequence", "limit", "print", "password", "bank", "cache", "queue", "scroll", "window", "buf", "output", "iter", "page", "screen", "char", "bridge", "face", "bytes", "header", "data", "comment", "button", "display", "chain", "command", "stack", "attribute"], "bread": ["bird", "fan", "less", "shield", "piece", "score", "uckle", "beck", "wake", "rew", "log", "iber", "fred", "ig", "ble", "broken", "ful", "oug", " Bread", "eric", "bad", "knife", "spoken", "bn", "bb", "neum", "print", "crafted", "eb", "bi", "don", "bridge", "jing", "web", "fee", "bill", "blow", "fine", "read", "bishop", "give", "robe", "rain", "bold", "four", "middle", "rik", " barely", "good", "corruption", " ribs", "cake", "rown", "bc", "bel", "stay", "brew", "wei", "inn", "level", "READ", "scroll", "billion", "nob", "bled", "leen", "brow", "lf", "boat", "gear", "beat", "bush", " breadth"], "fis": ["biss", "Fos", "ufris", "ufos", "lis", "di", "frei", "Fris", "fia", "fiss", " fris", " fia", "liss", "dis", "los", " fiss", "bi", "freia", "bos", "ufiss", "Fiss", "li", "freis", "ufis", "Fis", "fi", " fi", "fris", "bis", "dia"], "fos": ["voes", "voos", "pos", "foes", "tos", "Fos", " foes", "pus", "poos", " fus", "toes", "Foos", "ooses", "tis", "ooes", "poes", "Foes", "eoos", " fot", "fus", "eoes", " foses", "oot", "Foses", "oos", "vus", "vos", "eos", " foos", "foses", "Fot", "toos", "Fis", "fot", "eis", "foos"]}}
{"id1": "14783950", "id2": "3187685", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithoutzip", "composeWithZip", "composeWithoutExt", "compressWithFiles", "composeWithExt", "composeWithoutzip", "compressWithoutFiles", "compressWithoutExt", "composeWithoutFiles", "compressWithExt", "composeWithoutZip", "compressWithoutZip", "compresswithzip", "compressByExt", "composeWithzip", "compressWithzip", "compressByzip", "compresswithExt", "compressByFiles", "composeWithFiles", "compresswithFiles", "compresswithZip", "compressByZip"], "fileList": ["wordIterator", " fileCode", " FileLIST", "ileList", "ilelist", " filelist", "fileSet", " fileIterator", " fileNames", "filelist", "wordSet", "fileLock", " fileLock", " fileLIST", " FileSet", " fileL", "fileIterator", "pageCode", "fileL", "ileLIST", "pagelist", "tileIterator", "pageList", "fileLIST", "wordLIST", "tileSet", "pageLIST", "tileList", "fileNames", "pageL", "resourceNames", "fileCode", " FileCode", " fileSet", "itemLock", "resourceLock", "itemList", "itemNames", "wordList", "ileL", "tileLIST", "pageSet", "resourceList", " FileList"], "zipFileName": ["zFilenamename", "zipFileFilename", "zipFilenameNames", "zipileName", " zipfileName", " zipfilePath", "zFilenameName", " zipfileNames", "zipDirFilename", "zFileName", "zipfileNames", "zFileFilename", "zipileFilename", "zipDirNames", " zipFileNames", "zipFilenameName", "zipFilenamename", "zipfilePath", "zipfileFilename", "zipDirName", "zipilename", " zipFilePath", "zipFilename", " zipFileFilename", "zFilename", "zFilenamePath", "zipDirPath", "zipfilename", " zipfileFilename", "zipilePath", "zFilePath", "zFilenameFilename", "zipFilePath", "zipFileNames", "zipFilenamePath", "zipFilenameFilename", "zipfileName"], "fos": ["wOS", "lOS", "Fos", "lfoos", "fOS", "flis", "Foos", "flos", "wos", "loss", "woss", "Foss", "flOS", "lfos", "los", "loos", " fOS", "lfOS", "floos", " foos", "foss", "lfis", "woos", "foos", "FOS"], "zos": ["zan", "zen", "os", "sis", "less", "zin", "zh", "z", "zip", "hz", "zag", "zero", "Sax", "eros", "ws", "iners", "bes", "css", "cz", "ss", "ossus", "ps", "es", "zi", "zik", "ze", "zo", "zon", "enos", "ses", "nz", "js", "zers", "los", "iaz", "rys", "ez", "zb", "sbm", "hess", "za", "jas", "zzle", "zes", "oss", "han", "ippers", "rez", "zar", "ess", "enz", "zer", "webkit", "zu"], "iter": ["oper", "re", "train", "fer", "ee", "where", "coll", "ner", "Iterator", "ver", "izer", "it", "its", "maker", "ser", "valid", "iterator", "list", "er", "Iter", "reader", "here", "iver", "gener", "loader", "ait", "order", "user", "cer", "ip", "former", "exp", "kit", "inter", "inner", "iv", "tr", "outer", "ger", "orient", "walker", "i", "ptr", "li", "ter", "iner", "loop", "vis", "el", "is", "loc", "liter", "ipper", "ator", "ir"], "fileName": ["fNames", " fileNumber", "ileString", "localName", "ilename", " filename", "localNAME", "ileList", "fileCurrent", "ileCurrent", "FileString", " fileNames", "fileSet", "fileSource", "fileBody", "fieldname", "localList", "fSource", "fileNAME", "ileNumber", " filePath", "ileSet", "fNumber", "tableName", " fileCurrent", "ileBody", "tableSet", "FileCurrent", " fileString", "ilePath", "fileStore", "fileNumber", "tablePath", "getSource", "localname", "fieldName", "shortStore", "fieldList", "FilePath", "FileNames", "fileNames", "fieldNAME", " fileStore", "getStore", "fString", "ileSource", "fBody", "FileName", " fileSet", "shortname", " fileSource", "getName", "fname", "getname", "filePath", "shortSource", "Filename", "fName", "ileNAME", "ileName", "filename", " fileBody", "fileString"], "ind": ["pl", "mod", "dial", "inder", "pos", "med", "j", "ld", "nd", "wind", "count", "mind", "cond", "inn", "cd", "md", "Ind", "seed", "req", "cod", "inc", "hend", "cand", "stick", "n", "bind", "sign", "find", "att", "td", "typ", "roll", "dj", "kind", "num", "index", "div", "IND", "i", "ded", "ptr", "draw", "red", "loc", "butt", "ent", "pred", "d"], "shortName": ["fullname", "shortString", "smallFilename", "recentName", "ShortKey", "smallCode", " shortString", " shortKey", "quickKey", " shortname", "ShortName", "ShortCode", "smallName", "fullString", " shortType", "shortType", "quickName", "fullName", "ShortFilename", "shortFilename", "shortCode", "fullType", "ShortType", "quickname", "quickString", "recentname", "shortKey", "smallname", "shortname", "recentFilename", "ShortString", "recentCode", "Shortname"], "fis": ["ufois", "hris", "ufris", "cfis", "sfis", "sfIs", "pi", "wi", "fIs", "cfris", "Fris", "his", "hi", "FIs", "wIs", " fris", "cfois", "pis", "ufi", "cfi", "wois", "ufIs", "sfi", "wis", "sfois", "fois", "hois", "ufis", "Fis", "fi", "pris", "fris", "pois", " fIs"], "buf": ["bar", "wb", "orig", "buff", "b", "cap", "mu", "pkg", "ref", "batch", "block", "mem", "Buffer", "vec", "fb", "buffer", "uf", "tab", "var", "temp", "cur", "Buff", "seq", "aka", "cmd", "bl", "cat", "bag", "bin", "rb", "img", "tr", "fam", "br", "conv", "bed", "db", "cb", "cv", "bytes", "box", "msg", "fg", "bus", "bc", "arr"], "bytesRead": ["bytesNeed", "usersRead", "flowsFind", "flowsRead", "blocksRead", "postsFind", "bytesReady", " bytesLength", "usersLoad", "usersFind", "bytesWritten", "BytesLength", "flowsLoad", "linesRead", " bytesLoad", "flowsReady", "secondsWritten", "bytesFind", "blocksWritten", "BytesRead", "bytesLoad", "secondsLoad", "secondsWrite", "usersReady", "blocksWrite", " bytesWrite", "BytesNeed", "linesLength", "postsRead", "linesWritten", "blocksLoad", "secondsRead", "bytesLength", " bytesNeed", "postsLoad", " bytesWritten", "linesNeed", "BytesWritten", "bytesWrite", "postsReady"]}}
{"id1": "21555906", "id2": "5836744", "code1": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["Actionperressed", "Actionperceived", "ActionPerformed", "ActionPerressed", "Actionperuted", "actionperuted", "actionperressed", "actionPerressed", "actionPeruted", "actionperformed", "Actionperformed", "actionTransceived", "actionTransuted", "actionPerceived", "actionTransressed", "actionExecformed", "actionperceived", "ActionPeruted", "ActionPerceived", "actionTransformed", "actionExecressed", "actionExecceived", "actionExecuted"], "ae": ["aa", "ace", "re", "ene", "ase", "ade", "ee", "arde", " pe", "ge", "a", "se", "e", "AE", "es", "ane", "ce", "iae", "oe", "fe", " ace", "ze", "er", "ra", "ea", "ape", "ese", "je", "action", " ge", "me", "pe", "de", "eeee", "za", "sa", "te", "ke", "xe", "eu", " je", "ca", "ei", "ue", "event"], "toservlet": ["tosupert", "tosuperle", "tooserverlet", "tosourcet", "toservert", "tosservle", "tooservole", "tosservlet", "tosuperlets", "tooservlets", "toserverlet", "toservLET", "tooservLET", "tosservlets", "toserverlets", "tooservt", "tooservlet", "tosuperole", "tosuperLET", "tooservert", "tosuperlet", "toservole", "toserverole", "tosourcele", "tosourceole", "tooserverle", "tooserverole", "toservle", "toservt", "tosservLET", "tooserverLET", "tooservle", "toserverLET", "tosourcelet", "toserverle", "toservlets", "tooserverlets"], "servleturl": ["serviceletUrl", "servlUrl", "servbleurl", "serviceleturl", "servvetconnection", "servleteUrl", "serviceletsname", "selectleturl", "servleurl", "servletname", "servleUrl", "servleloc", "servvetname", "servlconnection", "servletloc", "selectletUrl", "selectletloc", "serviceletname", "servbleloc", "servleconn", "servbleconn", "servletsname", "servleteloc", "selectbleurl", "selectbleconn", "serviceletsurl", "servleteurl", "selectbleUrl", "servletsurl", "serviceletconnection", "servletsconnection", "serviceletsUrl", "servbleUrl", "servletUrl", "servveturl", "selectbleloc", "servvetUrl", "servleteconn", "serviceletsconnection", "servlurl", "servletsUrl", "servletconn", "selectletconn", "servlname"], "servletconnection": ["servvetconnection", "servletsconn", "servletecontext", "servlecharacter", "servvetConnection", " servetcharacter", "servlexcharacter", "servetConnection", "servantConnection", "servletscharacter", "servleconnection", "servLETconnect", "servleconnect", "servlexconn", "servletopen", "serviceantconnection", "ervleteconnection", "ervletconnection", " servletsConnection", "serviceletopen", "serviceantconn", " servletcontext", "servetconnect", "servetconn", "portleturl", " servetconnect", "portLETconnection", "servleConnection", "servantconn", "ervletconn", "serviceantConnection", "portLETurl", "serviceletConnection", " servletsconnection", " servetConnection", "servletConnection", "servletconnect", "ervletecharacter", "servvetopen", "servletcontext", "servLETConnection", " servletconnect", "portLETConnection", "servlecontext", "ervletcharacter", " servetconn", "serviceletconn", "servetconnection", "servleteconnect", " servletconn", "portletConnection", "servleteurl", " servletConnection", "servletsurl", "servantopen", "serviceletconnection", "servvetconn", "servletscontext", "servetcharacter", "portLETconnect", " servetconnection", "servletsclient", "servletconn", "servletsConnection", " servletscontext", "servleteconnection", "ervletConnection", "servletcharacter", "ervleteConnection", "serviceantopen", "servlexconnection", "ervleteconn", "portletconnection", "servleconn", "servlexconnect", "servletsopen", " servletsclient", "servLETurl", "servleclient", " servletclient", "servletsconnection", "servLETconnection", "portletconnect", "servleteclient", "servleteConnection", " servletcharacter", "servantconnection", "servletsconnect", "servletecharacter", "servleteconn", "servletclient"], "inputFromClient": ["inputWithClient", "inputFromRemote", "inputStreamClient", "inputInServer", "inputWithclient", " inputFromRemote", "inputToCurrent", "InputToClient", "inputfromCurrent", "inputfromClient", "inputfromCase", " inputfromClient", "inputToRemote", " inputfromclient", "inputWithRemote", "inputInClient", "InputFromclient", " inputToServer", "inputfromRemote", " inputToClient", "inputFromclient", "inputStreamRemote", " inputToCurrent", "inputfromServer", "InputFromClient", "inputfromclient", " inputfromRemote", "InputToRemote", "inputStreamCase", "inputStreamclient", " inputFromServer", " inputFromclient", "inputInCurrent", "inputInRemote", "inputFromServer", " inputFromCurrent", "inputToServer", " inputFromCase", "inputFromCurrent", "inputInclient", " inputfromServer", "InputToclient", " inputfromCase", "InputFromRemote", "inputFromCase", "inputToClient", "inputToclient"], "fos": ["foes", "tos", "Fos", " foes", "fOS", "bows", " fows", "fows", "sfos", "toes", "Foes", "tOS", "bOS", "sfOS", " foses", "boes", "sfoes", "Foses", " fOS", "bos", "tows", "foses", "sfoses", "FOS"], "buf": ["bar", "orig", "buff", "b", "cap", "pkg", "mu", "ref", "batch", "block", "mem", "Buffer", "cp", "vec", "fb", "buffer", "uf", "doc", "tab", "temp", "cur", "pause", "Buff", "seq", "cf", "cmd", "txt", "cat", "iter", "bag", "rb", "img", "br", "conv", "tmp", "bed", "db", "cb", "gen", "cv", "box", "bytes", "msg", "fg", "bc", "arr"], "bytesread": ["bitsadd", "bytesrun", "fieldsreadable", "byteswrite", "secondsreadable", "fieldswrite", "bytesreadable", "secondsread", "Bytesneeded", " bytesreadable", "bitsload", "secondsrun", "bytesadd", "bitsread", "bytesload", "fieldsread", "bpsload", "amplesneed", "secondswrite", "bytesneed", "Bytesread", "ampleswrite", " bytesadd", " byteswrite", "bitsprint", "amplesneeded", "amplesread", "bpsprint", "Byteswrite", " bytesload", "fieldsrun", "bytesprint", "Bytesneed", " bytesrun", "bytesneeded", "bpsadd", " bytesneed", " bytesprint", " bytesneeded", "bpsread"]}}
{"id1": "6301863", "id2": "4056444", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 0, "substitutes": {"doRawRequest": ["doNativeQuery", "sendRawAction", "sendHttpQuery", "doNativeRequest", "sendHttpCall", "sendRawRequest", "doDirectCall", "doRawQuery", "doDirectQuery", "doHttpAction", "sendRawQuery", "sendHttpRequest", "doHttpQuery", "doHttpRequest", "doDirectRequest", "doNativeCall", "doDirectAction", "sendHttpAction", "doNativeAction", "sendRawCall", "doRawAction", "doHttpCall", "doRawCall"], "postData": ["requestData", "POSTMessage", "PostData", "PostString", " postString", "preBody", " postMessage", "requestBody", "postedData", "PostMessage", "postString", "POSTDATA", "postedMessage", "preDATA", "postedString", "postdata", " postdata", "POSTBody", "preMessage", "postDATA", "requestDATA", "requestMessage", "POSTData", "preData", "postMessage", "posteddata", "postBody", "Postdata"], "url": ["ret", "pl", "re", "bel", "ur", "hl", "http", "link", "ld", "https", "pkg", "ls", "gl", "build", "client", "l", "uri", "sl", "nl", "str", "org", "rel", "mount", "www", "cmd", "google", "ssl", "con", "Url", "web", "mail", "ul", "abs", "addr", "ll", "lb", "loc", "dl", "cert", "URL"], "conn": ["nc", "cn", "exec", "j", "resp", "close", "c", "cont", "syn", "ch", "gn", "ct", "pg", "pas", "cp", "ns", "client", "connection", "l", "cur", "Conn", "iw", "enc", "org", "res", "rel", "cmd", "act", "nec", "pt", "ssl", "comm", "con", "jp", "nt", "com", "conv", "inv", "cb", "connect", "canon", "addr", "col", "sys", "loc", "open", "cert", "fin", "net"], "wr": ["lr", "rw", "wb", "w", "WR", "dx", "wx", "fw", "mk", "tn", "wid", "rew", "wm", "writer", "RW", "r", "spr", "sw", "write", "iw", "hr", "dr", "writ", "kl", "wn", "Wr", "wy", "wer", "fr", "pr", "wt", "kr", "rou", "Writer", "nw", "wk", "vr", "wd", "wp", "mr", "vet"], "rd": ["dd", "rt", "rw", "rob", "rend", "ld", "rc", "rog", "rar", "rand", "mr", "erd", "nd", "RD", "rer", "ra", "r", "reader", "rl", "hr", "rect", "ru", "ro", "rs", "rod", "rx", "cr", "nder", "dr", "rb", "rpm", "ri", "rid", "sr", "pr", "ptr", "fr", "ry", "red", "rn", "rh", "rr", "adr"], "sb": ["bh", "bg", "bt", "RB", "rob", "lbs", "gc", "bs", "bn", "obb", "b", "erb", "bf", "kb", "bps", "bb", "sh", "sq", "sp", "ib", "pb", "bd", "mb", "sf", "sm", "gb", "sd", "bsp", "lp", "sv", "sth", "eb", "sg", "bag", "SB", "zb", "si", "rb", "sa", "bp", "gob", "abs", "ob", "cb", "xb", "lb", "bis", "nb", "bj", "obs"], "line": ["LINE", "row", "phrase", "link", "sample", "stay", "rule", "eline", "inline", "e", "block", "ice", "check", "valid", "list", "name", "cell", "message", "buffer", "Line", "sequence", "l", "log", "print", "nl", "number", "code", "ln", "pe", "stroke", "entity", "lin", "string", "page", "style", "word", "point", "le", "zone", "display", "frame", "comment", "header", "file", "entry", "ine", "label", "text", "chain", "liner"]}}
{"id1": "5125848", "id2": "17296916", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "label": 1, "substitutes": {"combineJs": ["combINEJs", "ComboseJs", "combineLink", "combINEJS", "Combinejs", "combinatejs", "CombineLink", "combinateJS", "ComboseJS", "combinejs", "combINELink", "comboseJS", "combINEjs", "ComboseLink", "combinateLink", "combineJS", "Combosejs", "comboseJs", "CombineJS", "CombineJs", "comboseLink", "combinateJs", "combosejs"], "base": ["domain", "re", "api", "ase", "bottom", "b", "based", "host", "prefix", "Base", "address", "id", "buffer", "bound", "uri", "reset", " based", "source", "bid", "site", "from", "local", "start", "relative", "origin", "page", "template", " Base", "server", "bas", "root", " basis", "db", "absolute", "file", "data", " bases"], "linkJs": ["linkedLinks", " linkScript", "linkjs", "inkTags", "LinkJS", "Linkjs", "linkedJS", "LinkJs", " linkJS", "inkScript", " linkTags", " linkjs", "inkJs", "LinkTags", "linkLinks", "linkedJs", "inkJS", "inkLinks", "linkedScript", "inkjs", " linkLinks", "linkScript", "linkTags", "linkJS"], "newFiles": ["linkFiles", "newLinks", "nextFiles", "linkDocuments", "newDocuments", "nextfiles", "nextLinks", "linkfiles", " newLinks", "linkLinks", " newDocuments", "nextDocuments", " newfiles", "newfiles"], "dir": ["dd", "mod", "module", "zip", "disk", "diff", "done", "pkg", "mk", "ref", " d", "tar", "desc", "di", " Dir", "id", "cd", "directory", "md", "DB", "Dir", "doc", "folder", "DIR", "created", "temp", "out", "fs", "rel", "dm", "good", "local", "dr", "def", "lib", " directory", "dep", "root", "tmp", "div", "area", "manager", "db", "sys", "addr", "auto", "file", "fd", "lock", "dl", "loc", "vol", "wd", "ir", "d"], "name": [" prefix", " dummy", " filename", " scanner", " self", " names", " report", " str", " tmp", " logger", " start", " karma", " foo", " browser", " info", " res", " err", " vm", " manager", " rebuild", " db", " log", " b", " bar", " msg", " os", " cleaner", " parser", " loader"], "minDir": ["sortRel", "thinTier", "minutePref", "skindir", "skinDir", "minuteDir", "mindir", "smallDb", " minPref", " minJar", "miniTrans", " minFile", "smallLoc", "smallNet", "miniDir", "minNet", "minTrans", "minFile", "minRel", "miniJar", " minNet", "MinNet", "sortDar", " minDar", "mainLoc", "thinJar", "MinDir", "thinDir", "MinFile", "smallDir", "minJar", "minuteRel", "minuteDar", "miniTier", "maindir", "minLoc", "sortDir", "minDb", "skinLoc", " minRel", "sortPref", "smallFile", "minPref", "minTier", "smalldir", " minTier", " minTrans", "minDar", "mainDb", "skinDb", "mainDir", "thinTrans"], "combineFile": ["coordinefile", "combinfile", "coordINEWriter", "combineMessage", "comboiceMessage", "combinerfile", "comboiceEmail", "combinateMessage", "combinateEmail", "comineFile", "coordINEfile", "combINEWriter", "combosefile", "cominefile", "coordINESet", "comineEmail", "comboseWriter", "combinefile", "cominateMessage", "combinFile", "combINEfile", "combineSet", "combinWriter", "cominateFile", "comboiceFile", "cominatefile", "combineEmail", "coordineWriter", "comineMessage", "comboicefile", "coordineSet", "combinSet", "combINESet", "combinateFile", "coordineFile", "combINEFile", "coordINEFile", "comboseFile", "cominateEmail", "comboseSet", "combinerEmail", "combinatefile", "combinerMessage", "combinerFile"], "concatFile": ["convertTable", "cocatFile", "comcFile", "concatfile", "convertfile", "concDir", "conatTable", "conatFiles", "conCatDir", "covertFiles", "convertDir", "cocatTable", "concapFiles", "concatDir", "cocatfile", "concatFilename", "covertTable", "concFile", "convertFilename", "comcFilename", "comcDir", "cocatFiles", "covertFile", "concapFile", "concapTable", "covertfile", "comcatDir", "concapfile", "comcatFile", "conatfile", "concatTable", "convertFiles", "convertFile", "conatFile", "conCatFilename", "concatFiles", "concFilename", "comcatFilename", "conCatFile"], "combineWriter": ["ComboseCounter", "combieFile", "combineCounter", "Combinewriter", "combinateCounter", "combinewriter", "combieReader", "declineReader", "comboseCounter", "CombineWriter", "combieWriter", "combenWrite", "CombineCounter", "combenWriter", "combinatewriter", "declineWriter", "combineReader", "comboseReader", "combinateWriter", "declineFile", "comboseWriter", "combenCounter", "declinateFile", "combineWrite", "combinateWrite", "declineWrite", "declinateWriter", "ComboseWriter", "combieWrite", "ComboseWrite", "combinateReader", "CombineWrite", "combosewriter", "comboseWrite", "combinateFile", "comboseFile", "Combosewriter", "combenwriter", "declinateReader", "declinateWrite"], "concatWriter": ["coatFile", "cocatFile", "coatWriter", "concatsFile", "cocatWrite", "conatWriter", "convertReader", "comvertFile", "cocatWriter", "concatsWrite", "comcatWriter", "convertWrite", "comcatWrite", "conatWrite", "convertWriter", "concatReader", "conatReader", "coatWrite", "comvertWriter", "concatsWriter", "comvertReader", "comvertWrite", "cocatReader", "comcatFile", "concatsReader", "convertFile", "concatWrite", "conatFile", "coatReader", "comcatReader"], "fails": ["failed", "mailed", "facailing", "facails", "failing", "facocks", "frailing", "lails", "Fails", " falls", "lailed", "Fils", " failed", "Failed", "mocks", "frils", "frails", " focks", "mails", "lailing", "ifailing", "ifails", "ifocks", "frailed", "mailing", "ifailed", "lils", "fils", " failing", "focks", "Failing", "lalls", "facailed", "malls", "falls"], "link": ["mark", "close", "c", "linked", "inline", "line", "add", "check", "Link", "address", "map", "l", "skip", "log", "source", "node", "code", "ln", "set", "child", "links", "follow", "push", "share", "embed", "relation", "li", "display", "task", "script", "match", "loc", "self", "remote", "ink", "open", "load"], "path": ["join", "full", "src", "hex", "ath", "href", "ref", "prefix", "id", "p", "image", "resource", "uri", "route", "source", "str", "location", "relative", "string", "pattern", "template", "alias", "style", "input", "kind", "root", "Path", "data", "match", "file", "loc", "format", "entry", "key", "text", "prop", "PATH"], "url": ["lr", "ur", "null", "http", "hl", "href", "il", "ref", "ls", "host", "gl", "get", "build", "address", "id", "this", "resource", "uri", "l", "sl", "r", "nl", "request", "source", "str", "rel", "mount", "location", "ssl", "string", "char", "li", "Url", "mail", "abs", "ul", "web", "addr", "html", "loc", "ll", "URL", "browser"], "inputStream": ["outputSteam", " inputstream", "InputStyle", "InputTime", "outputstream", "inputSteam", "InputSet", "instream", "inputSet", " inputSteam", "inputTime", " inputStyle", "inTime", "inputStyle", " inputSet", "inputstream", "InputSteam", "inSet", " inputTime", "outputStyle", "InputStream", "Inputstream", "inStream"], "jsFile": ["cssPath", "javascriptFile", "jsPath", "jFilename", "cssFile", " jsfile", "javascriptTable", "JsFilename", "jPath", "javascriptPath", "javascriptName", "Jsfile", "javascriptfile", "cssTable", " jsFilename", "JsFile", " jsName", "JsPath", "jsfile", "cssfile", "jsTable", "jFile", " jsTable", "jName", "cssFilename", "jsName", "javascriptFilename", " jsPath", "jsFilename"], "fileName": ["getHash", " filePath", " fileHash", "FileName", "FileHash", " filename", "getName", "FilePath", "getname", "filePath", "getPath", "Filename", "filename", "fileHash"], "outputStream": ["outputForm", " outputForm", " outputstream", "outputSteam", " outputSet", " outputStyle", "writeStream", "OutputSet", "OutputStream", "outputstream", "inputSteam", "OutputStyle", "OutputForm", "outputSet", "writeSteam", "inputStyle", "Outputstream", "writeSet", "inputstream", "OutputSteam", "outputStyle", " outputSteam", "writestream", "inputForm"], "first": ["fast", "true", "each", "send", "First", "default", "top", "success", "unique", "valid", "sort", "ind", "now", "natural", "must", "false", "fourth", "last", "prev", "primary", "master", "seconds", "only", "same", "quick", "st", "front", "start", "all", "real", "current", "continue", "second", "index", "next", "important", "then", "latest", "initial", "self", "open", "third", "stack"], "reader": ["row", "http", "read", "handler", "rc", "rar", "ner", "driver", "stream", "mr", "rer", "iterator", "this", "buffer", "context", "writer", "runner", "er", "resource", "wrapper", "rator", "r", "io", "ocr", "rl", "ro", "Reader", "inner", "input", "core", "file", "data", "layer", "parser", "loader", "rr", "builder"], "jsCompressor": ["cssRepressor", "cssCompressor", "cssReposer", "jscompiler", "jscompression", "cssComposer", "cssCompression", "jsReposer", "jsCompiler", "cssRepiler", "jsRepressor", "jsBuffression", "cssCompiler", "jsComposer", "jsBuffiler", "jsCompression", "jsBuffressor", "jscompressor", "jsRepiler", "cssRepression", "jsBuffoser", "jsRepression", "jscomposer"], "s": ["full", "ms", "details", "less", "os", "words", "eds", "t", "qs", "ls", "ss", "tes", "es", "ies", "ns", "ts", "y", "cs", "ers", "l", "lines", "ats", "gs", "fs", "pers", "ids", "S", "ens", "ds", "hs", "xs", "parts", "is", "ings", "tags", "ps"], "s1": ["ls81", "ys0", "ys1", "pers0", "ls0", "idFirst", "id1", "sFirst", "s0", "s3", "ys81", "pers1", "es1", "ls3", "esFirst", "s81", " s81", " s3", "es9", "s9", "ps0", "ps1", "ls1", "ys3", " s0", "id9", "id2", "es2"], "i": ["iat", "ci", "ifier", "im", "ia", "j", "ii", "iti", "ion", "I", "ch", "us", "mi", "oi", "o", "ati", "pi", "it", "di", "ui", "id", "p", "y", "v", "ic", "io", "ai", "um", "ori", "iu", "bi", "ip", "ig", "ie", "ri", "li", "is", "ity"], "s2": ["tes1", "Stwo", "ss22", "tes2", "gsSecond", "es02", "SSecond", "gs2", "s02", "S2", "ss02", "stwo", "es1", "ssTwo", "ztwo", "ms02", "z02", "sTwo", "esTwo", "ss2", "ms2", "gs02", "gstwo", "tes02", "sSecond", "zSecond", "z2", "msTwo", "s22", "tesTwo", "ms22", "es2", "S02"], "i1": ["oOne", "eOne", "a1", "p4", "iOne", "p1", "it01", "o0", "it4", "p2", "a01", "it2", "it0", "e4", "o1", "e2", "i2", "a2", "p01", "i0", "pOne", "o4", "p0", "e1", "aOne", "i4", "i01", "itOne", "it1"]}}
{"id1": "12097948", "id2": "21656668", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"systemID": [" systemId", "systemName", "sysIDs", " systemVD", " systemName", "privateId", "privateVD", "sysId", "privateName", "SystemName", " systemIDs", "sysID", "SystemId", "sysVD", "privateID", "systemId", "systemIDs", "systemVD", "SystemID", "SystemIDs", "sysName"], "id": ["gd", "null", "in", "link", "pid", "mid", "end", "path", "aid", "Id", "ref", "hide", "base", "it", "ide", "part", "oid", "delete", "internal", "name", "message", "p", "md", "kid", "post", "uri", "sid", "layout", "f", "mask", "q", "source", "one", "bid", "str", "bind", "iden", "ids", "res", "no", "uid", "test", "ID", "create", "ip", "init", "def", "rid", "wire", "show", "json", "i", "edit", "hash", "query", "hd", "db", "description", "form", "data", "ident", "key", "shape", "d"], "loader": ["older", "module", "lr", "hl", "handler", "where", "pkg", "qualified", "lc", "cdn", "system", "label", "context", "er", "kernel", "library", "l", "owner", "framework", "reader", "nl", "finder", "rl", "cl", "lp", "user", "loads", "location", "loading", "language", "container", "class", "manager", "Loader", "pool", "layer", "parser", "acl", "loaded", "load", "builder"], "url": ["ret", "browser", "bel", "lr", "ur", "http", "link", "il", "path", "ref", "ls", "util", "or", "ml", "address", "name", "resource", "uri", "l", "f", "sl", "r", "nl", "mb", "rl", "str", "org", "rel", "impl", "mount", "user", "location", "ssl", "Url", "mail", "abs", "web", "el", "norm", "ul", "html", "xml", "file", "loc", "lb", "ll", "tool", "job", "dl", "URL", "load", "builder"], "inStream": ["intBlock", "onSteam", "inSteam", "INstream", "onStream", "inView", "intSteam", "INStream", "innSteam", "InFile", "INView", "intSocket", "INSteam", " inSteam", "inBlock", "InStream", "InSteam", "inputSteam", "onstream", "inputStream", "instream", "inFile", "innSocket", "innBlock", " inView", "inputFile", " inSocket", "intStream", " inFile", "onView", " instream", "inSocket", "inputstream", "Instream", "innStream", " inBlock"], "constraints": ["constsats", "constrats", "conStraint", "costaints", "constraint", "constsaints", "constaint", "costats", "conStraints", "constats", "constains", "costraints", "costaint", "costains", "constaints", "conStrains", "costrains", "constsains", "costrats", "costraint", "constsaint", "constrains", "conStrats"]}}
{"id1": "9096319", "id2": "6371580", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNodeRegainedSite", "handleNodeRegifiedSite", "handleNoderegainedService", "handleNodeRegainsSite", "handleNoderegainsService", "handleNodeRegainsService", "handleNodeRegalledServices", "handleNoderegainsSite", "handleNodeRegifiedService", "handleNodeRegifiedServices", "handleNodeRegalledSite", "handleNoderegainedSite", "handleNoderegainedServices", "handleNodeRegalledService", "handleNoderegainsServices", "handleNodeRegainsServices", "handleNodeRegainedServices"], "eventID": ["nodeType", "serviceTime", " eventId", "EventUID", "serviceUID", "eventId", " eventType", "nodeTime", "nodeId", " eventName", "eventType", "nodeName", "EventType", "EventTime", "eventKey", "nodeUID", "serviceKey", "EventID", "EventName", "serviceId", "EventId", "eventUID", "eventName", " eventUID", " eventKey", "nodeKey"], "nodeID": ["nodeInfo", "NodeIDs", " nodeInfo", "localJS", "odeId", " nodeid", "odeID", " nodeId", "instanceInfo", "resourceId", "entityId", "instanceIDs", "nodeId", "serverName", " nodeIDE", "moduleId", "nodeIDs", "resourceName", " nodeName", "nodeIT", "nodeName", "resourceID", "volumeName", "nodeIDE", " nodeIDs", "nodeJS", "localId", "moduleID", " nodeIT", "Nodeid", "odeIDE", "instanceId", " nodeJS", "volumeIT", "NodeName", "NodeId", "NodeIT", "volumeId", "instanceID", "localID", "serverInfo", "serverID", "moduleIT", "moduleIDE", "nodeid", "volumeID", "serverId", "moduleid", "serverIDs", "NodeID", "entityID", "entityJS"], "ipAddr": ["ipAddsrs", "ipResr", " ipAddrar", "ipAcrb", "ipStorehr", " ipAddn", "ipAndrs", " ipAttrar", " ipAtter", "ipAttp", " ipAddressp", "ipAddsrb", "ipAtter", "ipSender", "ipAttr", "ipAddp", "ipAddhr", "ipAddressri", "ipResrs", "ipaddrt", "ipStorers", "ipaddr", "epAddr", "ipAddressaddr", "ipaddl", "ipAcn", "epAddressl", "ipAttrar", "ipIntaddr", " ipAddrb", "ipAddn", "ipStorert", "ipAddresser", "ipAdder", "ipAndl", "ipIntrs", "ipAddrs", "ipReshr", "ipAddressr", "ipResrt", "ipAddrar", "ipSendrar", "ipaddrs", " ipaddp", " ipaddrt", " ipAdder", " ipAddrs", "ipAddressrs", "ipAddsn", " ipAddp", "ipAndp", " ipAttp", "ipAndrt", " ipaddrs", " ipAddrt", "ipStorer", " ipaddr", "ipAddressp", " ipAttr", "epAddressr", "ipAcrs", "ipAddri", "ipIntr", "ipAndri", " ipAddhr", "epAddressri", "ipAcr", " ipAddaddr", " ipAddressaddr", "epAddressrs", "ipSendr", "ipAddressrar", "epAddl", "ipAddressl", "epAddri", " ipAddressrs", " ipAddl", "ipAndr", "ipaddp", "ipAddaddr", "ipAddl", "ipSendp", "ipAddrb", "ipIntp", "ipAddrt", "ipAddsr", " ipAddressr", "epAddrs"], "serviceID": ["sourceID", "serviceid", "componentId", "serviceNOTE", "serviceType", "servId", "securityID", "servNAME", "resourceId", "sourceName", " serviceKey", "servid", "serviceNAME", "componentNOTE", "ServiceNOTE", "servID", "ServiceKey", " serviceType", "resourceName", "resourceID", "ServiceId", "ServiceLAN", "servKey", " serviceName", "ServiceJO", "serviceKey", "sourceId", "serviceLAN", "securityName", "componentID", "ServiceID", "ServiceType", "Serviceid", " serviceLAN", "resourceType", "servLAN", "serviceId", "componentName", " serviceNAME", "servName", " serviceid", "sourceJO", "serviceJO", "ServiceName", "securityid", "ServiceNAME", " serviceNOTE", " serviceJO", "securityId", "serviceName", " serviceId"], "eventTime": ["ventType", "ventTIME", "ventTime", "eventtime", "Eventtime", " eventType", "agetime", "attributeTime", "eventType", "EventType", "ageType", "EventTime", "ageTime", "ventTimes", "attributeTIME", "attributeTimes", "eventTimes", "ageTIME", "attributeType", "eventTIME", " eventTimes", " eventTIME", "EventTIME", " eventtime"], "log": ["t", "err", "w", "email", "og", "util", "se", "pel", "enter", "low", "LOG", "user", "debug", "en", "conf", "json", "channel", "bug", "net", "full", "ome", "sql", "row", "note", "ge", " logger", "it", "scale", "error", "cell", "report", "out", "blog", "de", "prot", "config", "xml", "and", "link", "lo", "category", "or", "store", "use", "call", "Log", "cat", "iam", "tag", "mail", "db", "msg", "file", "lock", "ar", "crit", "pl", "zip", "cal", "cont", "url", "base", "be", "message", "l", "tab", "ex", "set", "gob", "ger", "ext", "le", "com", "at", "entry", "event"], "dbConn": ["dbConnect", "sbConn", "DBConnect", "dbCon", "bCon", " dbObj", "bdConnect", "fbObj", "gbConn", "DBConn", "dbObj", "tableconn", "bCons", " dbCons", "DbCon", "fbConnect", "dbCons", "gbConnection", "cbConnection", "userConnect", "gbConnect", "DbConn", " dbConnect", "userObj", "bdConn", "DbObj", "fbCon", "Dbconn", "tableCon", " dbCon", "sbConnect", "tableConn", "cbConnect", "DBCons", "bdCon", "userCon", "cbCon", "sbCon", "sbObj", "dbConnection", "dbconn", "cbConn", "fbConn", "tableObj", "bConnect", "gbCon", "DBCon", "bdObj", "userConn", " dbconn", "bConn", "DbConnect", "sbConnection"], "outageUpdater": ["outageUPdter", "outageUpdoder", "outageUtdoder", "outageUpnter", "outageUptaser", "outageUpdatedater", "outageUpdatetter", "outageUptarer", "outageUpdaters", "outageUpdatedaser", "outageUpdter", "outageUdoder", "outageUptatter", "outageUpdatemaser", "outageUpddATER", "outageUppater", "outageUpndter", "outageUpdbaser", "outageUplarer", "outageUpddater", "outageUpdatedager", "outageUPtaters", "outageUplter", "outageUpddaser", "outageUpdarer", "outageUpdatemater", "outageUpdatater", "outageUpDater", "outageUdater", "outageUpmetter", "outageUpdager", "outageUnndater", "outageUdatetter", "outageUplitter", "outageUtdrer", "outageUpddomer", "outageUpDaser", "outageUpnomer", "outageUptaters", "outageUtDoder", "outageUtDaser", "outageUnditter", "outageUpmitter", "outageUprarer", "outageUpdaterater", "outageUpnoder", "outageUpdatedarer", "outageUpDaters", "outageUPdATER", "outageUndater", "outageUpnaser", "outageUpmaser", "outageUpmoder", "outageUtDrer", "outageUprager", "outageUptter", "outageUpmter", "outageUpdatedATER", "outageUpditter", "outageUpdaterarer", "outageUPtater", "outageUpdateraters", "outageUpdataser", "outageUpdatter", "outageUpdatemomer", "outageUpmATER", "outageUpdrer", "outageUpnATER", "outageUpdetter", "outageUPtoder", "outageUPtter", "outageUPnaters", "outageUpnaters", "outageUptater", "outageUppaser", "outageUdaser", "outageUpdboder", "outageUtDater", "outageUptager", "outageUPtaser", "outageUpDager", "outageUnndter", "outageUPditter", "outageUPtitter", "outageUppoder", "outageUpDarer", "outageUtdater", "outageUpdatedomer", "outageUPnarer", "outageUplaters", "outageUploder", "outageUpndater", "outageUdataser", "outageUpDrer", "outageUPdaser", "outageUPnATER", "outageUpDATER", "outageUnndATER", "outageUptoder", "outageUpnater", "outageUpDatter", "outageUPdatter", "outageUpnitter", "outageUpdatemATER", "outageUpnarer", "outageUpdATER", "outageUpdbetter", "outageUpdatedaters", "outageUPdoder", "outageUtdaser", "outageUPnater", "outageUpDoder", "outageUPtatter", "outageUPdaters", "outageUpmater", "outageUnnditter", "outageUdatoder", "outageUpdomer", "outageUpdaterager", "outageUpnatter", "outageUpnditter", "outageUndATER", "outageUprater", "outageUdetter", "outageUptitter", "outageUPdarer", "outageUpndATER", "outageUdatater", "outageUpdatoder", "outageUPdater", "outageUndter", "outageUpmrer", "outageUplATER", "outageUpdaser", "outageUpraters", "outageUplater", "outageUpdbater", "outageUpprer", "outageUpmomer"]}}
{"id1": "19739421", "id2": "8069594", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownParameterClass", " UnknownOptionClass", " UnknownCommandException", " UnknownCommandHandler", "UnknownCommandError", "UnknownFormatException", " UnknownOptionHandler", "UnknownOptionClass", "UnknownOptionError", " UnknownCommandError", "UnknownOptionHandler", "UnknownParameterHandler", "UnknownParameterError", " UnknownOptionError", "UnknownParameterException", "UnknownCommandHandler", "UnknownFormatHandler", "UnknownCommandException", "UnknownCommandClass", "UnknownFormatClass", "UnknownFormatError", " UnknownCommandClass"], "cmdLineParser": ["cmdLBuilder", " cmdPageBuilder", "mdlineParser", "CmdlineBuilder", "CmdLineProvider", "cmdlineHandler", "cmdPageBuilder", "commandlineParser", "mdlineOptions", "cmdPageParser", "CmdLineReader", "commandlineReader", "cmdLineReader", "cmdlineLoader", "cmdFrameReader", "cmdFramePers", "commandLineBuilder", "cmdNetParser", "commandLineRunner", " cmdPageParser", "cmdlineStreamer", "cmdNetStreamer", "mdlineStreamer", "mdlineHandler", "cmdChainReader", "commandlineProvider", "cmdFrameParser", "commandlineRunner", "cmdlineParser", "CmdlineReader", "cmdListparser", "mdlineparser", " cmdPageReader", "cmdListBuilder", "mdLineReader", "commandlineBuilder", "cmdListParser", "mdlineReader", "cmdChainParser", "cmdBlockParser", "commandlinePers", "cmdLParser", "mdLineLoader", " cmdLineBuilder", "cmdChainarser", "mdLineBuilder", "cmdBlockHandler", "cmdlineReader", "cmdLinePers", "cmdlinearser", "cmdSetReader", "cmdLineProvider", "mdlineLoader", "cmdlineOptions", "cmdBlockReader", "cmdListReader", "cmdLineBuilder", "mdLineOptions", "cmdlineProvider", "cmdlineRunner", "cmdBlockOptions", "cmdlineparser", "cmdNetHandler", "commandLineReader", "cmdLineRunner", "mdLineHandler", "cmdLineLoader", "cmdChainLoader", "cmdPageReader", "cmdLineparser", "mdlineBuilder", "cmdFrameRunner", "commandLineProvider", "cmdLineHandler", "cmdlinePers", "mdlinearser", "cmdBlockProvider", "cmdSetparser", "CmdlineParser", "cmdBlockBuilder", "cmdLineStreamer", "CmdLineBuilder", "commandLinePers", "mdLineparser", "cmdLOptions", "mdLineParser", " cmdLineReader", "commandLineParser", "cmdLineOptions", "mdLinearser", "cmdLHandler", "cmdlineBuilder", "cmdLinearser", "cmdNetReader", "cmdPageProvider", "CmdlineProvider", "cmdSetParser", "mdLineStreamer", "cmdSetBuilder", "CmdLineParser"], "formatOption": ["filterOption", "formatEntry", "transformOption", "FormatOperation", "FormatOption", "filterEntry", " formatOptions", "formatOperation", "FormatOptions", " formatEntry", " formatOperation", "transformEntry", "transformOperation", "formatOptions", "transformOptions"], "outputEncodingOption": ["outputencappingOption", "outputencodingoption", "outputEncappingOption", "outputEncodingoption", "outputEncgingOption", "outputencachingOption", "outputEncamingOption", "outputEncamingOptions", "outputEncgingoption", "outputEncodingOptions", "outputencappingoption", "outputencachingOptions", "outputEncachingOption", "outputEncappingOptional", "outputEncamingOptional", "outputEncamingoption", "outputencachingOptional", "outputEncgingOptional", "outputencodingOptions", "outputEncachingOptions", "outputencodingOptional", "outputencodingOption", "outputEncachingOptional", "outputEncodingOptional", "outputencappingOptional", "outputEncappingoption", "outputEncappingOptions"], "inputEncodingOption": ["inputEncachingOptional", "inputEncappingAttribute", "inputEncappingOptional", "inputEncappingOption", "inputCodingOptional", "inputenclingAttribute", "inputenclingOption", "inputEncappingOptions", "inputEncordingoption", "inputEncodingOptional", "inputEnclingOptions", "inputEncachingOptions", "inputEnclingoption", "inputEncordingOption", "inputEncachingOption", "inputEncendingOptional", "inputCodingOptions", "inputencodingOption", "inputCachingOptions", "inputEnclingOption", "inputEncendingOptions", "inputenclingOptions", "inputEncodingAttribute", "inputenclingoption", "inputEncappingoption", "inputEncordingAttribute", "inputencodingoption", "inputencodingAttribute", "inputCachingOption", "inputEncordingOptions", "inputCachingOptional", "inputEncendingOption", "inputEncodingoption", "inputEnclingAttribute", "inputEncodingOptions", "inputCodingOption", "inputencodingOptions"], "format": ["pretty", "join", "what", "api", "module", "note", "parse", "Format", "tif", "table", "option", "get", "prefix", "pi", "it", "version", "sort", "scale", "filter", "use", "name", "fix", "error", "unit", "print", "f", "layout", "with", "transform", "term", "license", "source", "method", "output", "set", "language", "title", "string", "pattern", "template", "style", "export", "printf", "config", "at", "force", "form", "file", "type", "policy", "display", "filename", "status", "command", "accept"], "outputEncoding": ["responseEncryption", "outputDecling", "currentEncaching", "outputEngling", "outputEngacing", "currentEnaching", "outputEngaling", "publicEncaging", " outputEncacing", "outputCompryption", "outputencoding", " outputEncryption", "outputEncaling", "responseEncalling", " outputDecining", "outputencording", "publicEncoding", "outputEncording", "outputEncging", "currentEncling", "outputMessining", " outputEngoder", "outputEncaging", "outputencaging", "outputEngging", "outputEncling", "outputEnoding", "outputencling", "outputEnling", "outputDecalling", "outputEnoder", " outputDecoding", " outputEncining", "outputencaching", "outputEncaching", " outputEngaling", "publicEncording", " outputDecaming", "outputEncalling", "outputEnaling", " outputEncoder", "outputCompining", "outputEnaching", "outputEnging", "outputCompaming", "outputEncining", "currentEnoding", "outputEncoder", "outputEncryption", "responseEncoding", " outputEngoding", " outputEncaming", "outputDecoding", "outputMessoding", "outputDecining", "outputEncacing", "outputEngoder", "outputencging", "outputMessryption", "outputDecaming", "outputMessaming", "responseEncling", "currentEncging", "outputEnacing", "outputEngoding", "publicEncling", "currentEnling", " outputEncaling", " outputDecryption", "outputEnaging", "outputDecryption", "outputEngaching", "outputEnryption", "currentEncoding", "currentEnging", " outputEngacing", "outputEnalling", "outputCompoding", "outputEncaming", "outputEnording"], "inputEncoding": ["outputEnging", "sourceEncoding", "outputEncging", "inputPackale", "inputencoder", "inputEncling", "sourceEnoding", "inputEncoder", "contextEncoding", "sourceEncacing", "contextEncacing", "inputencacing", "inputEncale", "inputEngale", "outputEncoder", "inputEnging", "contextEnale", "inputEncacing", "contextEnoder", "sourceEnling", "inputEning", "inputCodacing", "outputEnoding", "inputencling", "inputEnoding", "contextEncoder", "inputChoding", "inputPackoder", "outputEnoder", "sourceEnacing", "contextEnoding", "inputPackging", "contextEncale", "outputEncale", "inputEncing", "inputencoding", "sourceEncling", "inputEnale", "contextEnacing", "sourceEning", "inputEnacing", "inputCododing", "inputEngging", "inputEnoder", "inputEngoding", "sourceEncing", "inputChacing", "inputPackoding", "inputCodling", "inputencing", "inputChale", "inputCoding", "inputEngoder", "outputEnale", "inputencale", "inputChoder", "inputEnling", "inputEncging"], "remainingArgs": ["remainingParts", "remainJs", "mainingJs", "remainingBlocks", "mainingGS", "mainingParts", "remistingLinks", "mainedGS", "remainingFrames", "remainingItems", "remainsGS", "remgoingargs", "remainedParts", "remgoingArgs", "remainingargs", "removalArgs", "remistingGS", "remainsArgs", "remainingGS", "resainingGS", "remgoingParts", "remainGS", "resainedItems", "remainingJs", "trainingArgs", "resainingLinks", "trainItems", "remainedArgs", "remendingItems", "trainGS", "removalGS", "remainedBlocks", "mainingArgs", "resainedargs", "remendingGS", "resainingBlocks", "remgoingJs", "remainedParameters", "remainedFrames", "remainFrames", "trainFrames", "trainingGS", "mainedArgs", "remainedItems", "removalBlocks", "resainedBlocks", "remistingBlocks", "resainedArgs", "remendingArgs", "trainArgs", "resainingargs", "trainingFrames", "remainsParameters", "resainingItems", "remainingParameters", "remgoingGS", "removalParameters", "resainingArgs", "remainedJs", "remainArgs", "remainingLinks", "remainLinks", "remainsBlocks", "remainItems", "remainedLinks", "remainBlocks", "resainingParameters", "resainedLinks", "remistingArgs", "remainParts", "remendingFrames", "mainedJs", "trainingItems", "remainedargs", "remainedGS", "resainedParameters", "mainedParts", "resainedGS", "remgoingItems", "remainargs"], "inputFile": [" inputLike", "acceptfile", " inputFILE", "InputPlace", "outputPath", "requestFILE", "inputPath", "hiddenFile", " inputPath", "acceptFile", "hiddenfile", "inputFILE", " inputfile", " inputLine", "Inputfile", "requestPath", "acceptPlace", "acceptLine", "InputFile", " inputPlace", "outputfile", "hiddenPath", "inputLine", "outputLike", "hiddenLike", "requestfile", "inputfile", "requestFile", "InputPath", "InputLine", "inputPlace", "InputFILE", "inputLike"], "outputFile": [" outputFiles", "outputDo", "inputFilename", "clientDir", " outputfile", "outputFiles", "coinDo", "writeFolder", "cachefile", "clientFile", "cacheFilename", "writeDo", "coinfile", "coinFile", " outputDo", "outputFolder", "outputDir", "cacheDir", "outputfile", "OutputFile", " outputDir", "clientFiles", "cacheFile", "OutputDo", "OutputFilename", "clientDo", "OutputDir", "writeFile", "Outputfile", "inputfile", "writefile", "inputDir", " outputFolder", "coinFolder", "OutputFiles", "outputFilename"], "out": ["pretty", "null", "err", "in", "up", "aos", "on", "gr", "inf", "ser", "list", "error", "writer", "obj", "ins", "outs", "print", "log", "io", "report", "temp", "conn", "n", "res", "ln", "user", "output", "ex", "init", "Out", "inter", "inner", "all", "cfg", "con", "screen", "outer", "ou", "inv", "session", "manager", "sys", "gen", "msg", "OUT", "dir", "net"]}}
{"id1": "189963", "id2": "14878593", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "338852", "id2": "1357662", "code1": "    public static void sort(float norm_abst[]) {\n        float temp;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (norm_abst[j] > norm_abst[j + 1]) {\n                    temp = norm_abst[j];\n                    norm_abst[j] = norm_abst[j + 1];\n                    norm_abst[j + 1] = temp;\n                }\n            }\n        }\n        printFixed(norm_abst[0]);\n        print(\" \");\n        printFixed(norm_abst[1]);\n        print(\" \");\n        printFixed(norm_abst[2]);\n        print(\" \");\n        printFixed(norm_abst[3]);\n        print(\" \");\n        printFixed(norm_abst[4]);\n        print(\" \");\n        printFixed(norm_abst[5]);\n        print(\" \");\n        printFixed(norm_abst[6]);\n        print(\" \");\n        printFixed(norm_abst[7]);\n        print(\"\\n\");\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"sort": ["process", "cmp", "update", "rank", "run", " sorted", "func", " compare", "list", "min", " Sort", "test", "round", "order", "replace", "init", "stat", "printf", "position", "reverse", "fun", "Sort", " shuffle", "println", "ort", "format", "display", "rint"], "norm_abst": ["norm_afbl", "norm_avstr", "norm_afist", "norm_afct", "norm_obstr", "norm___apdr", "norm______abstream", "norm_rabck", "norm_absnd", "norm_habstr", "norm___afstr", "norm_rabnd", "norm_apste", "norm_appsty", "norm_abrest", "norm___apst", "norm___abst", "norm_afnd", "norm_ebstall", "norm_avsts", "norm_absts", "norm_rabst", "norm_ubbr", "norm_apdr", "norm___absts", "norm_acstr", "norm_acst", "norm___obst", "norm_ubld", "norm___afnt", "norm_avbr", "norm_ubstall", "norm_appst", "norm_labst", "norm_afcr", "norm_abbst", "norm_avnt", "norm_abste", "norm_afst", "norm_ubstr", "norm___abnt", "norm_rabbl", "norm_rabct", "norm_absnt", "norm_afnt", "norm______abst", "norm___abbr", "norm_abscr", "norm_labck", "norm_obstream", "norm_appist", "norm_abssts", "norm_avste", "norm_abbl", "norm_avst", "norm_abbr", "norm_abcr", "norm_obld", "norm______abbst", "norm_apbr", "norm_abct", "norm_abnd", "norm_abld", "norm______abbstream", "norm_ebst", "norm_ubsty", "norm_edsts", "norm_edst", "norm_appstall", "norm_pubdr", "norm_ubist", "norm_absck", "norm___obsts", "norm_labist", "norm_absrest", "norm___abstr", "norm_acsts", "norm_habst", "norm_obbr", "norm_absld", "norm_ubct", "norm_abstall", "norm_absstr", "norm_afsty", "norm_obist", "norm_obct", "norm_avdr", "norm_ebsty", "norm_absst", "norm_ubrest", "norm_abstr", "norm_apsts", "norm_obsts", "norm_rabST", "norm_abbstream", "norm___afst", "norm_obst", "norm_absty", "norm_obsty", "norm_abdr", "norm_rabcr", "norm_abST", "norm_afST", "norm___apbr", "norm_pubsts", "norm___afbr", "norm_abnt", "norm___apsts", "norm_pubbr", "norm_absste", "norm___obstr", "norm_abbstr", "norm_pubst", "norm_apst", "norm_absstream", "norm_abstream", "norm___abdr", "norm_afstr", "norm_edct", "norm_ubste", "norm_absct", "norm_obST", "norm_absist", "norm_obbl", "norm_absbr", "norm_abck", "norm_abist", "norm_labct", "norm______abbstr", "norm_habrest", "norm_labste", "norm_afbr", "norm_ubst", "norm_ebist", "norm_apist", "norm______abstr"], "temp": [" temperature", "ret", "tim", "mod", "tc", "t", "orig", "po", "alt", "total", "fake", "cap", "variable", "perature", "base", " tmp", "cp", "v", "p", "buffer", "unit", "deg", "print", "f", "emp", "term", "pre", "test", "txt", "iter", "unt", "Temperature", "dat", "partial", "cu", "current", "tr", "tmp", "cum", "ptr", "prime", "tf", "mint", "late", "tem", "mp", "Temp", "pt"], "i": ["ji", " ii", "ret", "iq", "ci", "im", "ia", "gi", "ii", "qi", "jo", "us", "mi", "ti", "pi", "it", "wi", "di", "ini", "ui", "ind", "zi", "hi", "id", "v", "ic", "io", "ai", "x", "g", "me", "iu", "bi", "ip", "init", "si", "ie", "ij", "ri", "index", "li", "ix", "xi", "ami", "is", "ar", "ims", "ir"], "j": ["ji", "m", "note", "z", "other", "err", "bs", "b", "d", "jo", "og", "ion", "ge", "h", "o", "get", "it", "on", "e", "ng", "sp", "adj", "kj", "y", "jit", "obj", "kid", "s", "v", "er", "k", "last", "ijk", "off", "J", "q", "str", "ja", "js", "g", "oj", "je", "jet", "user", "exp", "uj", "jj", "xy", "ij", "jp", "dj", "jl", "tr", "br", "jas", "next", "json", "pr", "kh", "fr", "jac", "aj", "job", "jc", "bj", "prop", "jump", " dj"]}}
{"id1": "22479286", "id2": "2525897", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 1, "substitutes": {"md5": [" md4", " MD3", "MD4", "MD3", "md4", " MD4", "md3", " MD5", " md3", "MD5", " MD2", " md2", "MD2", "md2"], "plainText": ["positiontext", "fullPrint", "externalTEXT", "fullText", "initialText", "batText", "mainText", "externalString", "ainSync", "maintext", "initialString", "altString", "batTerm", "ainPrint", "ainDelete", " plainTerm", "mainTEXT", "positionText", " plainMessage", " plainTEXT", "plainForm", "plaintext", "flatTEXT", "mainString", "ainTrans", "batString", "fulltext", "longTEXT", "initialTrans", "positionTEXT", "richText", "richPrint", "plainSync", "fullString", " plainDelete", "longText", "ainText", "flatMessage", "ainTerm", "plainPrint", "aintext", " plainTrans", "plainMessage", "flatText", "initialtext", "altText", "externalDelete", "plainString", "longString", " plainString", "plainTEXT", "ainTEXT", " plaintext", "plainTrans", " plainSync", "positionString", "alttext", "richTEXT", "ainForm", "externalText", " plainForm", "plainTerm", "richString", "altTEXT", "plainDelete", "batSync", "longPrint", "flatForm", "ainString", "altPrint", "ainMessage"], "md": ["mod", "m", "ms", "ad", "mp", "det", "pd", "df", "mac", "ld", " MD", "mk", "dh", "mc", "h", "pm", "add", "desc", "MD", "di", "ng", "ind", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "de", "cmd", "dm", "mm", "dr", "pdf", "der", "nt", "man", "hd", " Md", "red", "mand", "grad", "down", "dd", "dir", "d"], "digest": ["digse", "defested", "presentest", "presentEST", "presentity", "Digested", "presentests", "digity", "digute", "mdEST", "digested", "Digidate", " digute", "mdest", "defEST", "digests", "Digity", "Digests", "defse", "digum", "digidate", "DigEST", "Digum", " digests", "presentute", "compest", "presentested", "candute", "defest", "Digute", "compum", " digested", " digse", "mdse", "candidate", " digEST", "Digest", "candum", "digEST", "mdested", " digity", "compute", "compidate", "candest"], "hexString": ["charText", "hexstring", "exText", " hexSingle", "rexBuffer", " HexText", "charBuffer", "hexText", "hexArray", " hexstring", "expBuffer", "exString", "expText", "exBuffer", "rexArray", "rexString", "hexSingle", "charString", "expstring", " HexBuffer", " Hexstring", " hexArray", " HexString", " hexText", "charArray", "rexSingle", "hexBuffer", "exSingle", "expString", " hexBuffer", "exArray"], "i": ["info", "ji", "m", "iq", "u", "ci", "im", "err", "in", "z", "phi", "b", "j", "gi", "gu", "c", "qi", "ii", "I", "my", "ti", "mi", "a", "batch", "pi", "it", "di", "ui", "ind", "ski", "hi", "id", "y", "v", "multi", "to", "ic", "uri", "io", "ai", "\u0438", "q", "x", "n", "g", "me", "iu", "bi", "set", "ex", "ip", "init", "si", "ie", "conv", "index", "sim", "li", "ix", "xi", "is", "yi", "key", "chain"]}}
{"id1": "6301863", "id2": "15465293", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"Usage:  URLDumper <URL> <file>\");\n            System.exit(1);\n        }\n        String location = args[0];\n        String file = args[1];\n        URL url = new URL(location);\n        FileOutputStream fos = new FileOutputStream(file);\n        byte[] bytes = new byte[4096];\n        InputStream is = url.openStream();\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            fos.write(bytes, 0, read);\n        }\n        is.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"doRawRequest": ["doNativeQuery", "sendRawAction", "sendHttpQuery", "doNativeRequest", "sendHttpCall", "sendRawRequest", "doDirectCall", "doRawQuery", "doDirectQuery", "doHttpAction", "sendRawQuery", "sendHttpRequest", "doHttpQuery", "doHttpRequest", "doDirectRequest", "doNativeCall", "doDirectAction", "sendHttpAction", "doNativeAction", "sendRawCall", "doRawAction", "doHttpCall", "doRawCall"], "postData": ["requestData", "POSTMessage", "PostData", "PostString", " postString", "preBody", " postMessage", "requestBody", "postedData", "PostMessage", "postString", "POSTDATA", "postedMessage", "preDATA", "postedString", "postdata", " postdata", "POSTBody", "preMessage", "postDATA", "requestDATA", "requestMessage", "POSTData", "preData", "postMessage", "posteddata", "postBody", "Postdata"], "url": ["ret", "pl", "re", "bel", "ur", "hl", "http", "link", "ld", "https", "pkg", "ls", "gl", "build", "client", "l", "uri", "sl", "nl", "str", "org", "rel", "mount", "www", "cmd", "google", "ssl", "con", "Url", "web", "mail", "ul", "abs", "addr", "ll", "lb", "loc", "dl", "cert", "URL"], "conn": ["nc", "cn", "exec", "j", "resp", "close", "c", "cont", "syn", "ch", "gn", "ct", "pg", "pas", "cp", "ns", "client", "connection", "l", "cur", "Conn", "iw", "enc", "org", "res", "rel", "cmd", "act", "nec", "pt", "ssl", "comm", "con", "jp", "nt", "com", "conv", "inv", "cb", "connect", "canon", "addr", "col", "sys", "loc", "open", "cert", "fin", "net"], "wr": ["lr", "rw", "wb", "w", "WR", "dx", "wx", "fw", "mk", "tn", "wid", "rew", "wm", "writer", "RW", "r", "spr", "sw", "write", "iw", "hr", "dr", "writ", "kl", "wn", "Wr", "wy", "wer", "fr", "pr", "wt", "kr", "rou", "Writer", "nw", "wk", "vr", "wd", "wp", "mr", "vet"], "rd": ["dd", "rt", "rw", "rob", "rend", "ld", "rc", "rog", "rar", "rand", "mr", "erd", "nd", "RD", "rer", "ra", "r", "reader", "rl", "hr", "rect", "ru", "ro", "rs", "rod", "rx", "cr", "nder", "dr", "rb", "rpm", "ri", "rid", "sr", "pr", "ptr", "fr", "ry", "red", "rn", "rh", "rr", "adr"], "sb": ["bh", "bg", "bt", "RB", "rob", "lbs", "gc", "bs", "bn", "obb", "b", "erb", "bf", "kb", "bps", "bb", "sh", "sq", "sp", "ib", "pb", "bd", "mb", "sf", "sm", "gb", "sd", "bsp", "lp", "sv", "sth", "eb", "sg", "bag", "SB", "zb", "si", "rb", "sa", "bp", "gob", "abs", "ob", "cb", "xb", "lb", "bis", "nb", "bj", "obs"], "line": ["LINE", "row", "phrase", "link", "sample", "stay", "rule", "eline", "inline", "e", "block", "ice", "check", "valid", "list", "name", "cell", "message", "buffer", "Line", "sequence", "l", "log", "print", "nl", "number", "code", "ln", "pe", "stroke", "entity", "lin", "string", "page", "style", "word", "point", "le", "zone", "display", "frame", "comment", "header", "file", "entry", "ine", "label", "text", "chain", "liner"]}}
{"id1": "20190303", "id2": "23611770", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_noTog", "test01_ok_failed_500_No_Log", "test01_ok_failed_500_no___lim", "test01_ok_failed_500_no___og", "test01_ok_failed_500_no_log", "test01_ok_failed_500_noTLog", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_no_lim", "test01_ok_failed_500_no___Log", "test01_ok_failed_500_noTlog", "test01_ok_failed_500_No_og", "test01_ok_failed_500_no_og", "test01_ok_failed_500_No_log", "test01_ok_failed_500_No_lim", "test01_ok_failed_500_noTlim", "test01_ok_failed_500_no___log"], "client": ["tc", "api", "http", "handler", "close", "c", "https", "url", "secure", "prefix", "system", "cell", "connection", "context", "resource", "control", "wrapper", "call", "cache", "service", "cl", "conn", "window", "console", "cmd", "local", "cli", "google", "ssl", "template", "con", "server", "session", "manager", "cm", "city", "config", "force", "connect", "pool", "co", "channel", "remote", "contact", "loader", "Client", "cert", "collection"], "post": ["mod", "row", "feed", "send", "upload", "http", "read", "parse", "POST", "submit", "url", "get", "add", "valid", "ost", "ps", "p", "op", "write", "put", "request", "pre", "test", "set", "create", "Post", "copy", "save", "and", " Post", "body", "pod", "json", "posts", "form", "wp", "dd"], "response": ["info", "answer", "re", "feed", "pos", "http", "sample", "resp", "document", "onse", "get", "soc", "version", "block", "value", "message", "connection", "service", "respond", "example", "res", "application", "respons", "user", "output", "given", "tree", "reply", "server", "network", "Response", "body", "next", "json", "xml", "description", "data", "view", "entry", "remote", "status", "result"]}}
{"id1": "9802073", "id2": "17083703", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testAutoCommit": ["testAutoCompit", "testAutoCommits", "testAutoCompute", "testAutoComits", "testAutoComit", "testAutoDebits", "testAutoComute", "testAutoCompits", "testAutoCommmit", "testAutoDebute", "testAutoDebit", "testAutoDebmit", "testAutoCompmit", "testAutoCommute"], "con": ["nc", "cn", "dial", "re", "go", "tc", "gc", "cal", "c", "rc", "pen", "xc", "coll", "mc", "ver", "ca", "cc", "ct", "Con", "cp", "client", "connection", "ain", "bo", "can", "obj", "call", "fl", "conn", "cur", "Conn", "clean", "out", "enc", "rec", "res", "ln", "cf", "cat", "fc", "local", "win", "ctx", "act", "en", "comm", "conf", "don", "conv", " conn", "CON", "com", "fac", "cm", "connect", "canon", "gen", "co", "ran", "const", "cons", "cos", "bc", "col", "ac", "ctrl"], "stmt": ["STmp", "statgr", "starm", "stmp", " stmb", " stct", "Stmm", "statm", "statmm", "STmt", "strgr", "strmb", " stgr", "strmt", " superstarm", "stct", " stm", " superstmb", "Starm", "STMT", "statct", "statmb", " stmp", "strm", " starm", "stm", "statmt", " stMT", "StMT", "Stmp", "Stpt", "Stm", "stgr", "stmb", "stMT", " stmm", "strmp", " superstmt", "STpt", " superstm", "stmm", "Stmb", " stpt", "Stmt", "STmb", "STm", "Stct", "stpt", "strmm"], "rs": ["ags", "rt", "ms", "irms", "ros", "bs", "arms", "ares", "rc", "ubs", "vs", "ws", "rows", "ls", "ss", "its", "results", "rd", "Rs", "cs", "ers", "ows", "ins", "ues", "ra", "gs", "ats", "cks", "js", "fs", "res", "vers", "rys", "acs", "sts", "ds", "ks", "usr", "ris", "ys", "sr", "rates", "hs", "ras", "xs", "RS", "times", "ars", "sys", "ems", "ires", "dds", "acks", "ges", "stats", "ims", "icks", "qs", "mr", "obs"]}}
{"id1": "9096319", "id2": "932225", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"handleNodeRegainedService": ["handleNodeRegainedSite", "handleNodeRegifiedSite", "handleNoderegainedService", "handleNodeRegainsSite", "handleNoderegainsService", "handleNodeRegainsService", "handleNodeRegalledServices", "handleNoderegainsSite", "handleNodeRegifiedService", "handleNodeRegifiedServices", "handleNodeRegalledSite", "handleNoderegainedSite", "handleNoderegainedServices", "handleNodeRegalledService", "handleNoderegainsServices", "handleNodeRegainsServices", "handleNodeRegainedServices"], "eventID": ["nodeType", "serviceTime", " eventId", "EventUID", "serviceUID", "eventId", " eventType", "nodeTime", "nodeId", " eventName", "eventType", "nodeName", "EventType", "EventTime", "eventKey", "nodeUID", "serviceKey", "EventID", "EventName", "serviceId", "EventId", "eventUID", "eventName", " eventUID", " eventKey", "nodeKey"], "nodeID": ["nodeInfo", "NodeIDs", " nodeInfo", "localJS", "odeId", " nodeid", "odeID", " nodeId", "instanceInfo", "resourceId", "entityId", "instanceIDs", "nodeId", "serverName", " nodeIDE", "moduleId", "nodeIDs", "resourceName", " nodeName", "nodeIT", "nodeName", "resourceID", "volumeName", "nodeIDE", " nodeIDs", "nodeJS", "localId", "moduleID", " nodeIT", "Nodeid", "odeIDE", "instanceId", " nodeJS", "volumeIT", "NodeName", "NodeId", "NodeIT", "volumeId", "instanceID", "localID", "serverInfo", "serverID", "moduleIT", "moduleIDE", "nodeid", "volumeID", "serverId", "moduleid", "serverIDs", "NodeID", "entityID", "entityJS"], "ipAddr": ["ipAddsrs", "ipResr", " ipAddrar", "ipAcrb", "ipStorehr", " ipAddn", "ipAndrs", " ipAttrar", " ipAtter", "ipAttp", " ipAddressp", "ipAddsrb", "ipAtter", "ipSender", "ipAttr", "ipAddp", "ipAddhr", "ipAddressri", "ipResrs", "ipaddrt", "ipStorers", "ipaddr", "epAddr", "ipAddressaddr", "ipaddl", "ipAcn", "epAddressl", "ipAttrar", "ipIntaddr", " ipAddrb", "ipAddn", "ipStorert", "ipAddresser", "ipAdder", "ipAndl", "ipIntrs", "ipAddrs", "ipReshr", "ipAddressr", "ipResrt", "ipAddrar", "ipSendrar", "ipaddrs", " ipaddp", " ipaddrt", " ipAdder", " ipAddrs", "ipAddressrs", "ipAddsn", " ipAddp", "ipAndp", " ipAttp", "ipAndrt", " ipaddrs", " ipAddrt", "ipStorer", " ipaddr", "ipAddressp", " ipAttr", "epAddressr", "ipAcrs", "ipAddri", "ipIntr", "ipAndri", " ipAddhr", "epAddressri", "ipAcr", " ipAddaddr", " ipAddressaddr", "epAddressrs", "ipSendr", "ipAddressrar", "epAddl", "ipAddressl", "epAddri", " ipAddressrs", " ipAddl", "ipAndr", "ipaddp", "ipAddaddr", "ipAddl", "ipSendp", "ipAddrb", "ipIntp", "ipAddrt", "ipAddsr", " ipAddressr", "epAddrs"], "serviceID": ["sourceID", "serviceid", "componentId", "serviceNOTE", "serviceType", "servId", "securityID", "servNAME", "resourceId", "sourceName", " serviceKey", "servid", "serviceNAME", "componentNOTE", "ServiceNOTE", "servID", "ServiceKey", " serviceType", "resourceName", "resourceID", "ServiceId", "ServiceLAN", "servKey", " serviceName", "ServiceJO", "serviceKey", "sourceId", "serviceLAN", "securityName", "componentID", "ServiceID", "ServiceType", "Serviceid", " serviceLAN", "resourceType", "servLAN", "serviceId", "componentName", " serviceNAME", "servName", " serviceid", "sourceJO", "serviceJO", "ServiceName", "securityid", "ServiceNAME", " serviceNOTE", " serviceJO", "securityId", "serviceName", " serviceId"], "eventTime": ["ventType", "ventTIME", "ventTime", "eventtime", "Eventtime", " eventType", "agetime", "attributeTime", "eventType", "EventType", "ageType", "EventTime", "ageTime", "ventTimes", "attributeTIME", "attributeTimes", "eventTimes", "ageTIME", "attributeType", "eventTIME", " eventTimes", " eventTIME", "EventTIME", " eventtime"], "log": ["t", "err", "w", "email", "og", "util", "se", "pel", "enter", "low", "LOG", "user", "debug", "en", "conf", "json", "channel", "bug", "net", "full", "ome", "sql", "row", "note", "ge", " logger", "it", "scale", "error", "cell", "report", "out", "blog", "de", "prot", "config", "xml", "and", "link", "lo", "category", "or", "store", "use", "call", "Log", "cat", "iam", "tag", "mail", "db", "msg", "file", "lock", "ar", "crit", "pl", "zip", "cal", "cont", "url", "base", "be", "message", "l", "tab", "ex", "set", "gob", "ger", "ext", "le", "com", "at", "entry", "event"], "dbConn": ["dbConnect", "sbConn", "DBConnect", "dbCon", "bCon", " dbObj", "bdConnect", "fbObj", "gbConn", "DBConn", "dbObj", "tableconn", "bCons", " dbCons", "DbCon", "fbConnect", "dbCons", "gbConnection", "cbConnection", "userConnect", "gbConnect", "DbConn", " dbConnect", "userObj", "bdConn", "DbObj", "fbCon", "Dbconn", "tableCon", " dbCon", "sbConnect", "tableConn", "cbConnect", "DBCons", "bdCon", "userCon", "cbCon", "sbCon", "sbObj", "dbConnection", "dbconn", "cbConn", "fbConn", "tableObj", "bConnect", "gbCon", "DBCon", "bdObj", "userConn", " dbconn", "bConn", "DbConnect", "sbConnection"], "outageUpdater": ["outageUPdter", "outageUpdoder", "outageUtdoder", "outageUpnter", "outageUptaser", "outageUpdatedater", "outageUpdatetter", "outageUptarer", "outageUpdaters", "outageUpdatedaser", "outageUpdter", "outageUdoder", "outageUptatter", "outageUpdatemaser", "outageUpddATER", "outageUppater", "outageUpndter", "outageUpdbaser", "outageUplarer", "outageUpddater", "outageUpdatedager", "outageUPtaters", "outageUplter", "outageUpddaser", "outageUpdarer", "outageUpdatemater", "outageUpdatater", "outageUpDater", "outageUdater", "outageUpmetter", "outageUpdager", "outageUnndater", "outageUdatetter", "outageUplitter", "outageUtdrer", "outageUpddomer", "outageUpDaser", "outageUpnomer", "outageUptaters", "outageUtDoder", "outageUtDaser", "outageUnditter", "outageUpmitter", "outageUprarer", "outageUpdaterater", "outageUpnoder", "outageUpdatedarer", "outageUpDaters", "outageUPdATER", "outageUndater", "outageUpnaser", "outageUpmaser", "outageUpmoder", "outageUtDrer", "outageUprager", "outageUptter", "outageUpmter", "outageUpdatedATER", "outageUpditter", "outageUpdaterarer", "outageUPtater", "outageUpdateraters", "outageUpdataser", "outageUpdatter", "outageUpdatemomer", "outageUpmATER", "outageUpdrer", "outageUpnATER", "outageUpdetter", "outageUPtoder", "outageUPtter", "outageUPnaters", "outageUpnaters", "outageUptater", "outageUppaser", "outageUdaser", "outageUpdboder", "outageUtDater", "outageUptager", "outageUPtaser", "outageUpDager", "outageUnndter", "outageUPditter", "outageUPtitter", "outageUppoder", "outageUpDarer", "outageUtdater", "outageUpdatedomer", "outageUPnarer", "outageUplaters", "outageUploder", "outageUpndater", "outageUdataser", "outageUpDrer", "outageUPdaser", "outageUPnATER", "outageUpDATER", "outageUnndATER", "outageUptoder", "outageUpnater", "outageUpDatter", "outageUPdatter", "outageUpnitter", "outageUpdatemATER", "outageUpnarer", "outageUpdATER", "outageUpdbetter", "outageUpdatedaters", "outageUPdoder", "outageUtdaser", "outageUPnater", "outageUpDoder", "outageUPtatter", "outageUPdaters", "outageUpmater", "outageUnnditter", "outageUdatoder", "outageUpdomer", "outageUpdaterager", "outageUpnatter", "outageUpnditter", "outageUndATER", "outageUprater", "outageUdetter", "outageUptitter", "outageUPdarer", "outageUpndATER", "outageUdatater", "outageUpdatoder", "outageUPdater", "outageUndter", "outageUpmrer", "outageUplATER", "outageUpdaser", "outageUpraters", "outageUplater", "outageUpdbater", "outageUpprer", "outageUpmomer"]}}
{"id1": "19849797", "id2": "8135072", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", " copyStream", "transferStream", "transferfile", " cpStream", "transferFiles", " cpfile", " copyfile", "copyfile", " cpFiles", " copyFiles", "copyFiles", "copyStream", " cpFile"], "sourceFile": [" sourcePath", " sourcePage", "srcPath", "ourcePath", "srcLine", "ourceFile", "srcField", "ourceField", "ourceTable", "sourcePage", "sourceLine", "sourcefile", "srcFile", "sourcePath", "srcPage", "ourcePage", " sourceLine", "srcfile", "sourceTable", " sourceField", " sourcefile", "ourceLine", "sourceField", "srcTable", " sourceTable", "ourcefile"], "destFile": ["datPlace", "declEntity", "optFolder", "destDir", "DestFile", "destFilename", "restPlace", "optPath", "optFile", "srcFolder", "DestPath", "srcPath", " destPath", "DestFilename", "DestFiles", " destDir", "destEntity", "restFile", "optFilename", "srcFile", " destFilename", " destPlace", "declFile", "destFolder", "destPath", "optEntity", "srcFiles", "datFilename", "destFiles", "datFiles", "restFiles", "datFile", "DestDir", "srcDir", "destPlace", "srcEntity", "declDir", " destFiles", "restFilename", "declFolder", "optDir"], "source": ["src", "before", "OURCE", "send", "note", "in", "parse", "update", "sample", "local", "SOURCE", "table", "component", "back", "score", "se", "stream", "scope", "none", "parent", "check", "store", "ce", "slave", "iterator", "use", "scale", "image", "resource", "sequence", "spec", "owner", "reader", "service", "console", "ource", "standard", "from", "iter", "start", "create", "init", "origin", "copy", "search", "inner", "style", "ie", "load", "input", "missing", "char", "body", "index", "target", "proxy", "query", "show", "force", "Source", "comment", "cause", "match", "subject", "channel", "attribute", "pose", "series", "result", "shell"], "destination": ["destined", "separment", "Destinator", "decinate", "noninate", "nonination", "decination", "descation", "descinate", "verination", " destation", "restinator", "descinator", "verinated", "termininate", " destinate", " destinator", "noninator", "restinated", "destation", "Destation", " destificate", "veration", "descination", " destment", "separinated", "separation", "Destination", "decined", "separination", "destificate", "Destment", "Destinate", "noninated", "Destinated", "restinate", "destinator", " destined", "destinate", "terminined", " destinated", "termininated", "destinated", "destment", "restination", "decinated", "terminination", "verificate", "Destificate"]}}
{"id1": "18238468", "id2": "364438", "code1": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"testLoadSource": [" testloadSourceFile", " testAddFile", "testloadSourceFile", " testLoadSourceFile", " testAddSources", " testLoadSources", "testloadSource", " testloadSource", " testloadSources", "testloadSources", "testLoadSources", " testLoadFile", " testAddSourceFile", " testloadFile", "testLoadFile", "testloadFile", " testAddSource", "testLoadSourceFile"], "metadata": ["info", "m", "details", "ad", "detail", "about", "params", "df", "sample", "document", "managed", "mk", "my", "sheet", "default", "definition", "desc", "valid", "common", "iterator", "activity", "message", "md", "directory", "article", "map", "mt", "primary", "password", "layout", "summary", "content", "report", "wrapper", "payment", "unknown", "license", "still", "basic", "cmd", "met", "dirty", "template", "properties", "pdf", "meta", "tmp", "material", "json", "adata", "manager", "config", "xml", "header", "data", "parser", "policy", "dd"], "inputStream": ["thisView", "formStream", "thisSteam", " inputView", "currentSteam", "dataStream", "loadStore", " inputstream", "currentStreamer", "inputPort", "dataSteam", "InputForm", "formForm", "inputPresent", "loadSteam", "InputView", "inputSteam", "thisStream", " inputPort", "inputStreamer", "inputView", " inputSteam", " inputForm", "loadstream", "loadStream", "inputStore", "currentStream", "InputSteam", "formSteam", "thisPresent", "inputstream", "dataPort", " inputStore", "dataStreamer", "InputStream", "inputForm", "Inputstream", "InputStore", "currentPort", "InputPresent", " inputPresent", " inputStreamer"], "writer": ["editor", "adder", "creator", "storage", "counter", "null", "w", "written", "unsigned", "handler", "WR", "wright", "stream", "worker", "maker", "rew", "wrote", "iterator", "buffer", "riter", "master", "wrapper", "writing", "to", "reader", "write", "out", "temp", "window", "console", "order", "output", "caster", "inner", "string", "operator", "writers", "network", "wire", "writ", "outer", "walker", "manager", "her", "Writer", "woman", "channel", "loader", "event", "builder"], "contents": ["Contodes", " CONTENT", "utfented", " CONTodes", "Contented", "Content", " CONTens", "CONTented", "utfent", " CONTents", "content", " contens", "ContENT", "CONTent", "Contents", " contENT", "contens", "contodes", "Contens", "utfents", "CONTents", "contented", "contENT", " contodes"]}}
{"id1": "19467540", "id2": "21979717", "code1": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "code2": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"updateProductIfAvailable": ["updateProductIsAvailable", "updateProductOrAvailable", "updateProductWhereAvailable", "updateProductWhereValid", "updateProductsOrValid", "updateProductIfValid", "updateProductOravailable", "updateProductsIfValid", "updateProductIsavailable", "updateProductsIfAvailable", "updateProductsOrAvailable", "updateProductsOravailable", "updateProductOrValid", "updateProductsIfavailable", "updateProductIfavailable", "updateProductWhereavailable", "updateProductIsValid"], "carro": ["barro", "contro", "carros", " caraco", " carlo", " carri", " carrob", " carrom", "Carlo", "CarRO", "carri", "barri", "Caraco", "contlo", "controb", "carlo", "barrob", "Carros", "Carrob", "contros", "barRO", "Carrom", "Carro", "baraco", "barrom", "barlo", " carRO", " carros", "Carri", "barros", "caraco", "carRO", "carrom", "carrob"], "request": ["join", "project", "http", "exit", "setup", "document", "collection", "object", "get", "reference", "quest", "parent", "media", "use", "list", "environment", "address", "message", "question", "context", "resource", "client", "framework", "report", "req", "uri", "reset", "enter", "application", "user", "respect", "search", "template", "push", "input", "current", "server", "foundation", "query", "session", "access", "web", "pool", "xml", "model", "platform", "data", "Request", "response", "apache", "view", "contact", "attribute", "accept"], "listado": ["listato", "Listado", "parentament", " listato", " listados", "parentado", "Listament", " listament", "Listato", "listament", "listados", "parentato", "parentados", "Listados"], "conexion": ["conexpao", "conexpison", "ranexions", "coneuxion", "conectionison", "coneexor", "conexions", "canxION", " conexions", "coneuxison", " conexao", "conexaison", "cinxaioned", "conexpione", "conexpdial", "coneixon", "cinxaions", "conenexions", "canixION", "canixon", "conenexION", "coexinion", "conegexison", " conexison", "canxao", "conenexao", "conexison", "conenexioned", "raneixone", "conexor", "coneixION", "coneaxison", "coexpression", "conexdial", "conenexison", "coneuxions", "conexpinion", "conenexone", "conexao", "conexon", "conexadial", "coneaxdial", "conexpion", "cinxion", "conexione", "coneexION", "conectionioned", "conexaioned", "conexinion", " conenexion", "cinxions", "conxions", " conexaions", "cinxaison", "cinxioned", "conexiion", "coexpison", "conegexinion", "coneixao", "coneixions", "coneuxinion", "conexpions", "coneuxression", " conexdial", "coneuxao", "coexpion", "coneexone", "cinxison", "conexiION", "conexpression", "coexison", " conexaion", "conexiao", "coexression", "conexior", " conexadial", "conxor", "conegexression", "conexression", " conexaison", "conxION", "raneixions", "conenexion", "coneexion", "conexION", "coneixone", "canixion", "conenexione", "coneixion", " conenexions", "coneuxione", " conenexione", "conexioned", "conexone", "coneaxions", "conenexor", "conectionion", "coexpinion", "conenexon", "conexiions", "canxion", "conxion", "ranexion", "conectionions", "conexaion", "cinxaion", "coneexions", "ranexone", "conexaions", "conegexion", "canixao", "canxon", " conexione", "coneaxion", " conenexao", "coexion", "raneixion"], "select": ["which", "sql", "row", "lect", "text", "include", "exec", "parse", "read", "sel", "selected", "where", "setup", "util", "get", "it", "cho", "expr", "success", "ct", "reflect", "delete", "use", "collect", "selection", "SELECT", "print", "call", "reset", "sync", "conn", "q", "source", "construct", "quick", "set", "find", "pull", "copy", "search", "show", "pse", "query", "elect", "edit", "Select", "connect", "insert", "execute", "download", "qu", "serial", "struct", "crit"], "update": ["UPDATE", "make", "updated", "row", "each", "upload", "other", "alt", "where", "ge", "un", "bit", "ut", "util", "upt", "get", "up", "batch", "it", "add", "check", "delete", "use", "now", "Update", "change", "unit", "fill", "write", "put", "apply", "set", "find", "replace", "touch", "pull", "stat", "move", "save", "current", "place", "edit", "ul", "remove", "insert", "execute", "apt", "result"], "rs": ["rt", "ms", "ros", "pps", "eps", "bs", "arms", "rings", "rc", "ubs", "vs", "mc", "ws", "rows", "arts", "rd", "otes", "ps", "Rs", "ns", "rm", "cs", "ts", "rics", "ers", "ows", "ins", "ests", "r", "rl", "rets", "rg", "ats", "hr", "cks", "js", "fs", "res", "vers", "rys", "rx", "rss", "sts", "vals", "ds", "ks", "rpm", "usr", "ris", "ys", "sr", "hs", "rates", "xs", "ras", "RS", "times", "rr", "ars", "ems", "acks", "vr", "ims", "stats", "cases", "qs", "mr"], "codigoProd": ["codigoProl", "codisoPropd", "codukaPROl", "codigoOp", "codigoProdr", "codukaPROd", "codigoPl", "codigoProvdr", "codigoPROdr", "codoselect", "codigoProvl", "codisoProdo", "codigoPropn", "codigoProp", "codisoPropn", "codigoprodr", "codigoComc", "codigopror", "codidoprop", "codigoProdudo", "codigoProvx", "codigaprodid", "codigoComd", "codigaProdid", "codisoProd", "codigoPROd", " codichoselect", "codidoprodo", "codigoKeydo", "codidopror", "codigoComr", "codigaprod", "codigoKeyc", "codigoComdo", "codigoPd", "codigoprodo", "codisoPron", "codigoKeyd", "codisoPropdo", "codigoprol", "codidopron", "codigoProdun", "codidoPron", "codigoprop", "codigaProd", "codidoproc", "codukaPROx", "codigoPropc", "codigoProdo", "codigoProdid", "codigoPdid", "codigopron", "codigaproc", "codisoProc", "codidoProl", "codigoOl", "codigoKeyr", "codichoselect", "codidoProdo", "codigoPROdid", "codigoPror", "codidoprol", "codigoProx", "codigoprod", "codisoPropc", "codigoprox", "codigoProduc", "codigaProc", "codidoProp", " codigoselect", "codigoPROx", "codigoOn", "codigoPc", "codigoPropdo", "codidoprod", "codigoproc", "codidoProc", "codidoProd", "codigoPron", "codidoPror", "codigoOd", "codukaPROdr", "codigoselect", "codigoPropd", "codigaselect", "codigoProc", "codigoPROl", "codukaProx", "codigaprol", "codigoPROc", "codukaProd", "codigaProl", "codukaProdr", "codukaProl", "codigoProdud", "codigoprodid", "codigoProvd"], "filasAfectadas": [" filasAcessados", " filasaffectado", " filasAffectadas", " filasafectado", " filasAcessada", " filasAgregado", " filasAffectado", " filasAgregados", " filasafectados", " filasAgregada", " filasAcessadas", " filasafectadas", " filasaffectados", " filasAffectados", " filasAfectada", " filasAgregadas", " filasaffectada", " filasAffectada", " filasAcessado", " filasafectada", " filasAfectados", " filasaffectadas", " filasAfectado"], "iterador": ["erator", "itador", "formerable", "iterstep", "teramo", "erador", "itator", "Iterato", "iterrane", "Iterator", "literstep", "Iterador", "iteratoramo", "formeracion", "terator", "literador", " iterstep", " iterable", "iterator", "terador", " iterrane", "iteratorador", " iteraton", "eraton", "iteratorator", "Iterrane", "itrane", "Iterstep", "iteratorable", "eraman", "operaman", " iteraman", "literator", " iteracion", "literaman", "iterable", "Iteraton", "iteraman", "literaton", "operamo", " iterator", "iteramo", "operator", "formerador", "iteratoraman", "iteraton", "formeramo", "itato", "iterato", "iteratoracion", "teraman", "literrane", "iteracion", " iteramo", "operador", " iterato"], "prod": ["pubda", "pubdx", " prol", "produr", "produrd", " proda", "Prod", "pubg", "produdx", "Prol", "prorod", "prol", " prond", "produrod", "Proda", "Prodx", "Prond", " prog", " prorod", "produl", "pror", " pror", "pubd", "prond", "Prog", "proda", "Prord", " prord", "prord", "Prorod", "prog", "prodx", " prodx", "Pror", "prodund", "produd"], "exito": [" inexpiration", "exterior", "comito", "comita", "exita", "expiration", "lexito", "compiration", "lexterior", " inexito", " inexterior", "comterior", "lexita", "lexpiration", " inexita"]}}
{"id1": "21308543", "id2": "88047", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFiles", "cpDirectory", "copyfile", "cpFile", "Copyfile", "CopyFiles", "cloneFile", "cloneFiles", "cloneDirectory", "CopyDirectory", "copyFiles", "cpfile", "clonefile", "copyDirectory", "CopyFile"], "src": ["sit", "rt", "ur", "sc", "ripp", "rc", "pkg", "cont", "usc", "ser", "sq", "ins", "req", "rl", "cur", "source", "js", "fx", "rel", "st", "rs", "start", "sb", "rx", "init", "ctr", "iv", "sec", "usr", "sr", "ix", "sys", "Source", "inst", "sur", "subject", "loc", "ipl", "obs"], "target": ["tt", "that", "t", "other", "stop", "goal", "link", "mac", "gt", "mk", "top", "base", "parent", "delete", "eth", "arg", "the", "to", "Target", "patch", "term", "source", "rel", "test", "ARGET", "bolt", "output", "set", "replace", "start", "touch", "dest", "template", "jp", "nt", "next", "arget", "file", "match", "result"], "ic": ["ico", "eric", "wic", "iq", "ci", "nic", "tic", "pic", "ia", "rc", "IC", "cin", "it", "lc", "ice", "isc", "ric", "ib", "cit", "ican", "mic", "iu", "icc", "sic", "anc", "fc", "ip", "cli", "pc", "vc", "arc", "ics", "cu", "ik", "icing", "iac", "i", "ix", "irc", "aic", "bc", "ac"], "oc": ["ico", "nc", "mot", "ci", "ox", "nic", "pic", "gc", "ec", "c", "rc", "og", "ot", "mc", "o", "soc", "isc", "cc", "oci", "ocon", "osc", "od", "ocr", "toc", "oco", "mic", "unc", "anc", "voc", "pc", "oct", "ko", "cu", "arc", "yo", "OC", "oss", "ob", "irc", "aic", "co", "roc", "cos", "bc", "ac", "cus"]}}
{"id1": "350482", "id2": "18433984", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doFeaturecheck", "doVersionTest", " doVersionscheck", "doImageTest", "doVersionInfo", "doFeatureInfo", " doApplicationTest", " doApplicationInfo", "doVersioncheck", "doBuildTest", "doFeatureTest", "doVersionscheck", "doImageQuery", " doVersionsTest", "doApplicationCheck", " doVersionInfo", " doApplicationCheck", "doVersionsUpdate", "doApplicationQuery", " doVersioncheck", "doBuildCheck", " doVersionQuery", " doVersionTest", "doBuildcheck", "doFeatureUpdate", " doVersionsCheck", "doVersionsCheck", " doApplicationQuery", "doApplicationTest", "doBuildUpdate", " doVersionUpdate", "doFeatureQuery", "doImageCheck", "doFeatureCheck", "doImageInfo", " doVersionsUpdate", "doVersionsTest", "doApplicationInfo", "doVersionUpdate", "doVersionQuery"], "view": ["iew", "project", "row", "http", "update", "document", "engine", "component", "h", "version", "block", "check", "ml", "cell", "client", "this", "buffer", "image", "v", "views", "context", "port", "report", "print", "layout", "call", "q", "window", "controller", "see", "widget", "View", "page", "tree", "VIEW", "virtual", "input", "server", "show", "index", "query", "review", "manager", "html", "tv", "pool", "cv", "form", "model", "file", "subject", "box", "vm", "self", "lock", "display", "eye", "browser"], "url": ["pl", "domain", "bel", "ur", "oul", "http", "hl", "link", "b", "ref", "host", "get", "gl", "build", "address", "client", "v", "uri", "l", "f", "sl", "r", "nl", "log", "rl", "str", "rel", "mount", "ssl", "char", "Url", "mail", "ul", "html", "file", "loc", "lb", "ll", "dl", "job", "URL", "browser"], "in": ["gin", "info", " IN", " din", "In", "stream", "cin", "on", "inf", "inn", "ain", "mn", "ins", "can", "rin", "f", "l", "reader", "inc", "out", "source", "n", "ln", "IN", "from", "init", "isin", "inner", "input", "sin", "din", "body", "asin", "i", "mat", "is", "vin"], "bin": ["gin", "re", "bg", "spin", "binary", "buff", "b", "thin", " din", " bins", "ebin", "bn", "cin", "stock", "inn", "brain", "buffer", "ins", "rin", "mon", "by", "reader", "sam", "obin", "out", "cache", "ln", "cos", "bi", "bl", "local", "win", "init", "bur", "rb", "inner", "lib", "con", "all", "jin", "sin", "din", "body", "abin", " Bin", "bed", "session", "conv", "db", "cb", "file", "ran", "len", "nb"], "line": ["record", "LINE", "row", "detail", "column", "err", "parse", "link", "sample", "lo", "rule", "stay", "eline", "range", "tile", "inline", "base", "stream", "block", "ice", "part", " block", "ine", "cell", "message", "Line", "sequence", "port", "l", "log", "print", "lines", "code", "ln", "cmd", "iter", "cat", "lin", "string", "page", "style", "section", "word", "char", "next", "le", "point", "zone", "trace", "frame", "comment", "status", "file", "lane", "channel", "job", "entry", "field", "key", "chain", "liner"], "develBuild": ["deployBuilt", "devBuilder", "desVELBuild", "deffBuild", "deffbuild", "DeVELBuild", "devBuild", "deVELLog", "develBuilt", "desVELbuild", "desvelBuild", "duffBuilt", "DevelBuild", "DeVELbuild", "devLog", "deffBuilder", "depoBuild", "duVELBuilder", "duVELBoot", "Develbuild", "develbuild", "develBoot", "deVELbuild", "deploybuild", "duffBuild", "duvelBuilder", "deployBuild", "duVELBuild", "devbuild", "DevelLog", "duvelbuild", "develLoad", "desVELRelease", "duffBuilder", "develLog", "deeltaBuild", "duffbuild", "desvelRelease", "DeVELBuilt", "deeltaRelease", "desvelLoad", "deployRelease", "duvelBuilt", "deVELBuild", "duVELbuild", "deVELLoad", "depobuild", "depoBuilt", "desVELLoad", "deeltabuild", "deeltaLoad", "deVELBuilt", "deployLoad", "DevelBuilt", "deffBuilt", "deployBoot", "duvelBoot", "depoLog", "deVELBoot", "DeVELLog", "develBuilder", "devBuilt", "develRelease", "devBoot", "duvelBuild", "desvelbuild", "deVELBuilder", "deployBuilder", "deVELRelease"], "stableBuild": ["devBuilder", "secureBuild", "devBuild", " unstableCraft", " stablebuild", " stableBuilder", "activeBuild", "secureCraft", " unstableLong", "stableBoot", " stableLong", " unstablebuild", " unstableBuild", " stableBind", " unstableBind", "stableBind", "devbuild", "securebuild", "activeMake", "stablebuild", " stableBoot", "confirmedLong", "confirmedbuild", " unstableBoot", "devMake", "stableBuilder", "stableLong", "activeBuilder", "confirmedBoot", "confirmedBuild", "stableCraft", "activebuild", " stableCraft", " stableMake", "secureBuilder", " unstableBuilder", "devBind", "stableMake"]}}
{"id1": "16825994", "id2": "11933797", "code1": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"run": ["process", "exec", "fn", "thin", "un", "after", "version", "runs", "su", "check", "name", "runner", "unit", "call", "running", " Run", "Run", "test", "cmd", "sun", "con", "work", "execute", "spawn", "exe"], "out": ["os", "null", "t", "w", "err", "b", "gt", "end", "ch", "o", "up", "aos", "client", "v", "writer", "obj", "to", "log", "outs", "print", "io", "r", "cache", "conn", "write", "n", "res", "output", " OUT", "ex", "Out", "all", "con", "outer", "sum", "ou", "sys", "OU", "cb", "auto", "file", "OUT", " Out", "we", "result", "net"], "srcDir": ["distDir", " srcPath", "srcdir", "rcDIR", "rcDir", "sbD", "sourceDir", "socDir", "sbDir", "srcPath", "socdir", " srcdir", "sceneDir", "sbdir", "socDiv", "sourcedir", "sourceDiv", "srcDiv", "distDIR", "rcD", "srcDIR", "sceneD", "sourcePath", " srcDiv", "socPath", "srcD", "distD", "sceneDIR", "rcdir", "sourceD"], "conf": ["info", "cn", "err", "c", "ch", "ref", "default", "sch", "func", "acc", "cc", "Con", "context", "obj", "map", "log", "f", "lang", "conn", "cache", "gb", "fs", "Config", "cf", "local", "ctx", "etc", "cr", " Conf", "state", "cfg", "def", "con", "share", "conv", "com", "inv", "config", "cm", "cb", "pool", "job", "const", "ca", "Conf", "auth"], "srcFS": ["sourceFS", "srcOS", "srcKS", "rcFs", "reqCS", "srcLS", "srcFs", "sysOS", "sysFs", "newTS", "sysFS", "sourceLS", "sysKS", "srcfs", " srcKS", "reqFS", "sourceCS", "rcFS", " srcFs", "srcCS", "sourceFs", "reqFs", "newFS", "newKS", " srcLS", "rcfs", " srcfs", "sourceTS", "sourcefs", "newFs", "srcTS", " srcOS", "sysLS", " srcCS", "sysTS", " srcTS", "reqfs", "sysfs", "rcOS"], "contents": ["CONTacts", "CONTens", "contains", "consent", "consENTS", "CONTenses", "contenses", "condENTS", "Content", "continents", "stents", " content", "contENTS", "condENT", "condents", "consents", "constacts", "continent", "condains", "continains", "ContENTS", "consENT", "Contacts", "stENTS", "content", " contens", "CONTensions", "condensions", "CONTent", "continENTS", "Contensions", "CONTENTS", "contacts", "Contents", "CONTains", "stENT", "constensions", "contens", "constent", " contenses", "condent", "CONTents", "Contens", "stent", "contensions", "contENT", "Contenses", "constents"], "i": ["ji", "m", "ci", "u", "im", "phi", "j", "ii", "gi", "qi", "my", "I", "o", "ti", "mi", "batch", "base", "oi", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "y", "v", "multi", "ic", "uri", "ai", "\u0438", "q", "x", "ori", "g", "me", "iu", "bi", "cli", "si", "ij", "ki", "ri", "index", "sim", "li", "ix", "ma", "xi", "ami", "is", "cgi", "remote", "key", "ei"], "in": ["gin", "m", "re", "read", " din", "oin", "mi", "up", "cin", "pi", "on", "it", "ini", "inn", "ind", "ze", "min", "ins", "l", "rin", "io", "r", "inc", "source", "one", "IN", "from", "mm", "en", "inner", "bin", "isin", "con", "input", "sin", "din", "body", "ma", "inside", "file", "is", "In"]}}
{"id1": "810342", "id2": "16760971", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersioncheck", "doVersionscheck", "doDateCheck", "doDateFix", "doDatecheck", "doVersionsFix", "doVersionsUpdate", "DoVersioncheck", "doLicensecheck", "DoDatecheck", "doLicenseCheck", "DoDateFix", "DoVersionCheck", "DoDateUpdate", "doVersionsCheck", "DoDateCheck", "doLicenseFix", "doDateUpdate", "DoVersionUpdate", "DoVersionFix", "doVersionFix", "doVersionUpdate", "doLicenseUpdate"], "view": ["iew", "row", "http", "hl", "update", "table", "document", "engine", "component", "open", "get", "host", "util", "block", "check", "blade", "cell", "client", "this", "buffer", "help", "image", "v", "views", "context", "report", "print", "layout", "call", "doc", "wrapper", "out", "q", "window", "console", "controller", "see", "widget", "View", "page", "tree", "VIEW", "input", "server", "show", "index", "query", "review", "manager", "web", "html", "tv", "cv", "form", "model", "file", "subject", "self", "display", "eye", "browser"], "url": ["pl", "lr", "ur", "bel", "null", "oul", "http", "hl", "link", "b", "path", "github", "ls", "host", "gl", "socket", "address", "id", "client", "v", "uri", "l", "f", "sl", "r", "nl", "log", "rl", "str", "org", "date", "rel", "mount", "location", "language", "ssl", "string", "char", "json", "Url", "web", "ul", "html", "file", "loc", "lb", "ll", "dl", "URL", "browser"], "in": ["gin", "info", " IN", "b", " din", "In", "stream", "cin", "inf", "inn", "ain", "mn", "ins", "rin", "l", "f", "reader", "kin", "inc", "out", "source", "n", "ln", "IN", "init", "isin", "inner", "input", "sin", "din", "body", "asin", "i", "mat", "file", "is", "vin"], "bin": ["gin", "bg", "spin", "binary", "buff", "b", "thin", " din", " bins", "ebin", "bn", "cin", "stock", "mem", "inn", "buffer", "rin", "mon", "by", "reader", "sam", "obin", "conn", "out", "cache", "ln", "cos", "bi", "bl", "local", "win", "bur", "rb", "inner", "lib", "con", "sin", "din", "abin", " Bin", "bed", "pipe", "file", "ran", "len", "loader", "nb"], "line": ["record", "LINE", "row", "column", "err", "link", "sample", "lo", "path", "eline", "range", "ls", "inline", "base", "se", " Line", "block", "ice", "ide", "part", "store", "level", "cell", "Line", "port", "l", "log", "print", "lines", "one", "code", "ln", "no", "cmd", "iter", "cat", "lin", "page", "string", "style", "state", "word", "section", "char", "body", "point", "le", "el", "trace", "frame", "comment", "file", "lane", "channel", "job", "entry", "field", "ine", "text", "chain", "liner", "col", "load"], "version": ["info", "project", "usage", "update", "VER", "vision", "versions", "ion", "VERSION", "key", "ver", "value", "release", "python", "scale", "name", "client", "v", "image", "resource", "sequence", "spec", "serial", "feature", "number", "license", "date", "video", "vers", "test", "language", "volume", "string", "title", "virtual", "position", "iso", "index", "Version", "software", "river", "tag", "hash", "latest", "description", "form", "match", "major", "translation", "format", "type", "status", "command", "browser"], "build": ["make", "full", "project", "install", "other", "update", "binary", "built", "b", "link", "where", "old", "util", "ver", "add", "struct", "be", "release", "building", "use", "unit", "last", "log", "print", "uild", "dist", "th", "date", "test", "round", "builder", "ward", "arch", "dev", "load", "style", "lib", "ble", "work", "Build", "boost", "develop", "tag", "db", "hash", "latest", "fail", "match", "ship", "bug", "bor", "hold"]}}
{"id1": "7143591", "id2": "12869602", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"getWebByUrl": ["getWebByString", "getWebbyurl", "getWebFromurl", "getWebByurl", "getUrlbyURL", "getWebbyString", "getWebFromURL", "getWebFromString", "getUrlByUrl", "getWebbyURL", "getUrlbyurl", "getUrlByString", "getUrlByurl", "getUrlbyString", "getWebFromUrl", "getUrlbyUrl", "getWebbyUrl", "getUrlByURL", "getWebByURL"], "strUrl": ["arrUr", "stringDb", "insturl", "txtGl", "nameurl", "txtUrl", " strDb", "nameURL", "volUr", "strEmail", "StrUr", "strUr", "STREmail", "arrStr", "stUrl", "strurl", " strurl", "drDb", "stURL", "strGl", "stringUrl", "arrURL", "instUr", "drURL", " strURL", "txtStr", "StrStr", "volUrl", "arrUrl", "stUr", "drUrl", "STRStr", "drurl", " strUr", "volStr", "stDb", "strStr", "instUrl", "StrUrl", " strGl", "STRUr", "strDb", "txtURL", "STRURL", "stringURL", "drUr", "sturl", "arrurl", "arrEmail", "nameStr", "nameUrl", " strStr", "nameEmail", "nameUr", "strURL", "StrGl", "volURL", "stringUr", "STRUrl", "nameDb", "instURL", "StrURL", "Strurl"], "charset": ["chARSets", "chorsET", "ChARSets", "chorsec", "charsET", "ChARSet", "Charset", "chARSET", "ChARSec", "chARSet", "Charsec", "CharsET", "Charsets", "chorset", "chorsets", "chARSec", "ChARSET", "charsec", "charsets"], "fileIndex": ["bytePath", "stringPath", "ileNum", " fileindex", "fileInd", "ileindex", "fileNum", "filePos", "byteNum", "ileInd", "stringindex", " fileNum", "byteInd", "ileIndex", " fileInd", "byteIndex", "bytePos", "stringIndex", " filePos", "byteindex", "fileindex", "stringPos"], "url": ["ret", "bel", "ur", "http", "hl", "link", "https", "il", "ls", "get", "gl", "socket", "cp", "build", "name", "client", "connection", "resource", "obj", "l", "uri", "f", "sl", "r", "nl", "rl", "str", "g", "rel", "www", "cmd", "bl", "ssl", "con", "Url", "web", "ul", "ll", "dl", "open", "cert", "URL", "browser", "net"], "conn": ["nc", "cn", "c", "ch", "ws", "pg", "socket", "cp", "pas", "Con", "Connection", "connection", "obj", "l", "Conn", "enc", "iw", "ln", "cmd", "ctr", "ctx", "ens", "nec", "en", "act", "comm", "con", "nt", "conv", "oss", "access", "cb", "connect", "sys", "addr", "nw", "open", "ca", "handle", "net"], "is": ["info", "was", "os", "ms", "isl", "im", "http", "in", "bs", "isa", "us", "ws", "ls", "lis", "ios", "has", "it", "isi", "its", "or", "isc", "es", "iss", "ists", "id", "ib", "s", "ins", "isf", "bits", "out", "js", "fs", "res", "ist", "iris", "nis", "ip", "iter", "rs", "si", "ri", "ris", "iso", "i", "sys", "as", "IS", "Is", "ais", "serv", "bis", "ir", "are"], "filePath": ["filePATH", "familyPATH", "fileSystem", "fSystem", "fileName", "fFile", "ioSystem", " filePATH", "FilePATH", "FilePath", "filepath", "fileFile", "FileFile", "ioName", "familyPath", " filepath", "FileName", "fPath", "ioPath", "familySystem", "familypath", "fName", "FileSystem", "Filepath", " fileSystem", "ioFile"], "pw": ["fwd", "fws", "pws", "npwe", "jw", " pwe", "wpv", "fw", "npw", "apwh", "cpw", "jwb", "fW", "pv", "pwt", "npwt", "npv", "jW", "pwb", " pws", "pW", " pwb", "npwd", "mw", " pwh", "Pwd", "mwd", "cpwp", "apwd", "wpw", "npwp", "pwh", " pwd", " pwr", "jwd", "pwd", "pwp", "cpwd", " pwp", "Pwb", "wpwt", "pwe", "pwr", "mwb", "PW", " pW", "Pw", "wpwe", "cpwr", "apwb", " pv", "npwr", " pwt", "Pws", "mwh", "apw"], "fos": ["wOS", "fOS", "flos", "eOS", "wos", "bo", "flo", "woss", "floses", " fo", "fo", "eoss", " foses", "bOs", " foss", " fOS", "boses", "bos", "eos", "wOs", " fOs", "foss", "foses", "eOs", "fOs", "flOs"], "writer": ["editor", "rw", "wb", "w", "written", "handler", "fw", "wright", "aster", "desc", "worker", "rew", "ser", "liner", "wrote", "width", "buffer", "usher", "riter", "master", "writing", "reader", "write", "out", "wr", "member", "window", "aver", "console", "output", "widget", "writ", "player", "nt", "wn", "walker", "ter", "Writer", "println", "woman", "nw", "author", "wp", "builder"], "bReader": ["rbR", "rbReader", "bBuffer", "rbWriter", "aWriter", "bWriter", "bcBuffer", "aReader", "rbRead", "bcClient", "bhReader", " bWriter", "bR", "bClient", " bR", " bRead", "bRead", "aR", " bClient", "bhBuffer", "bhClient", "bcReader", "aRead", " bBuffer"], "sb": ["bh", "wb", "bt", "bg", "rob", "bs", "b", "erb", "stab", "CB", "bf", "kb", "bb", "sq", "sp", "ib", "pb", "bd", "mb", "sf", "sw", "gb", "sth", "lp", "sv", "eb", "sg", "ssl", "zb", "SB", "rb", "sa", "nb", "cb", "lb", "bis", "bsp", "bj"], "rLine": ["bline", "lLine", "lline", "bRow", "brLine", "srFrame", "srChan", "srLe", "bLink", "rline", "rEl", " rL", "srLine", "bLine", "rL", " rChan", " rFrame", " rline", " rLink", "rrChan", "rFrame", " rEl", "rLink", "rRow", "rLe", "rrLe", " rRow", "brL", "brRow", "rrEl", "lLink", "brFrame", "rrLine", " rLe", "lRow", "rChan", "srRow", "srL", "srEl"], "tmp_rLine": ["tmp_bLin", "tmp_hLin", "tmp_rnLin", "tmp_pL", "tmp_RSet", "tmp_bline", "tmp_rObj", "tmp_rnOrig", "tmp_bRow", "tmp_hRule", "tmp_rRow", "tmp_nrVal", "tmp_pSet", "tmp_cObj", "tmp_lVal", "tmp_cline", "tmp_nL", "tmp_cLine", "tmp_rRule", "tmp_rChain", "tmp_RBlock", "tmp_rRecord", "tmp_rnRule", "tmp_RRow", "tmp_lRecord", "tmp_RRecord", "tmp_drRow", "tmp_rL", "tmp_RL", "tmp_lRow", "tmp_drLin", "tmp_drLine", "tmp_nrRow", "tmp_RLine", "tmp_drline", "tmp_eRecord", "tmp_nrLine", "tmp_pBlock", "tmp_eline", "tmp_rgOrig", "tmp_nSet", "tmp_RChain", "tmp_hLine", "tmp_rgRule", "tmp_nBlock", "tmp_eLine", "tmp_lChain", "tmp_pline", "tmp_rBlock", "tmp_rgLine", "tmp_lObj", "tmp_cRow", "tmp_rgLin", "tmp_nLine", "tmp_pLine", "tmp_lLine", "tmp_hOrig", "tmp_rLin", "tmp_eRow", "tmp_pLin", "tmp_rSet", "tmp_bLine", "tmp_rOrig", "tmp_RVal", "tmp_lline", "tmp_eObj", "tmp_Rline", "tmp_rline", "tmp_pRow", "tmp_rnLine", "tmp_nrChain", "tmp_rVal"], "str_len": [" str2len", "string3vec", "str2Len", "string3length", "str3len", " str2ll", "str2len", "str3vec", " str_Len", "string_ls", "str__ls", "str_Len", " str2Len", " str_ls", "string_len", "str2ls", "string_length", "str_ll", "str_length", "str2ll", "str__len", "str__ll", "string3ls", " str_ll", "str__Len", "str3length", "str_ls", "string3len", " str2ls", "str_vec", "str3ls", "string_vec"]}}
{"id1": "822452", "id2": "3801655", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "2642914", "id2": "13333160", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarBw", "addFileToTarGt", "addFileToTarBt", "addFileToTarJw", "addFileToTarGez", "addFileToTarGst", "addFileToTarRw", "addFileToTarRzip", "addFileToTarGsp", "addFileToTarBz", "addFileToTarJx", "addFileToTarRx", "addFileToTarGet", "addFileToTarGsz", "addFileToTarBx", "addFileToTarGx", "addFileToTarGw", "addFileToTarBp", "addFileToTarGszip", "addFileToTarGp", "addFileToTarJz", "addFileToTarGzip", "addFileToTarRz", "addFileToTarJzip", "addFileToTarGep", "addFileToTarBzip", "addFileToTarGezip"], "taro": [" tarro", "ttaro", "tro", "Tamo", "temparo", "thara", " tory", "stro", "starro", "retaco", "toa", "staco", "ttosa", "staro", "tolan", "Tro", " tosa", " taco", "ktarro", "ktrar", "Taro", "qtolan", "tary", "retara", "thamo", "tamo", "ttamo", "qtaro", "qtory", "tharo", "stoa", "Tara", " tamo", "tempro", "maro", "waro", "ktara", "tara", "targo", "tosa", "tory", "tharro", " tro", "Tory", "ktaro", "troa", "Tolan", "Targo", "traro", " tary", "thosa", "tempamo", "taco", "margo", "tempargo", "retaro", "stary", "mro", "wargo", " targo", "wro", " trar", "stamo", "stargo", "Tarro", "qtro", "thrar", "trary", " tolan", "tarro", "marro", " tara", " toa", "trro", "warro", "ttara", "retamo", "trar", "Taco"], "path": ["full", "project", "m", "w", "ath", "c", "h", "url", "ref", "pi", "PATH", "history", "binding", "name", "p", "print", "doc", "transform", "clean", "th", "mount", "ex", "local", "string", "pattern", "core", "kind", "root", "Path", "parts", "file", "entry", "key", "text", "chain", "dir"], "base": ["full", "shadow", "bad", "ase", "b", "bare", "based", "default", "bf", "prefix", "pad", "Base", "part", "parent", "check", "common", "build", "binding", "name", "buffer", "normal", "reset", "padding", "basic", "create", "start", "extra", "relative", "alias", "template", "server", "bas", "root", "db", "absolute", "file", "family"], "f": ["perm", "fed", "far", "ft", "t", "w", "fab", "df", "b", "c", "fp", "F", "h", "o", "fm", "bf", "alf", "e", "life", "inf", "fe", "fb", "v", "y", "p", "uf", "l", "fl", "r", "rf", "sf", "fo", "fs", "fx", "g", "cf", "fc", "lf", "fac", "i", "fr", "elf", "form", "af", "file", "tf", "fi", "fd", "fg", "xf", "fa", "d"], "entryName": ["EntryKey", " entryLetter", "elementPath", "rowLetter", "rowType", "cueType", "elementKey", "ryLetter", "elementname", "ryname", "EntryType", "cueName", "entryLetter", "rowName", " entryname", "ryName", "entryKey", "entryname", "Entryname", "cueKey", " entryKey", "EntryPath", "elementName", "EntryName", "cuename", "entryPath", "rowname", "ryType", " entryPath", " entryType", "entryType"], "goIn": [" goOut", "geIns", "GoIns", "Goin", "moin", "GoIn", "goOut", " goIN", "goIN", "moIn", "poin", "GoOut", "moIN", "goIns", "moIns", "moInput", "poIn", "GoIN", "poOut", "poIN", "geInput", " goIns", " goInput", " goin", "gein", "geIn", "goin", "goInput"], "tarEntry": ["warComponent", "warItem", "warEntry", "tarComponent", "tarItem", " tarEnt", "tarEnt", "tarentry", "rarComponent", "carentry", "rarItem", "carCategory", "tarCategory", " tarComponent", "carEnt", " tarItem", " tarCategory", "rarentry", "warEnt", "carEntry", "rarCategory", "rarEnt", " tarentry", "rarEntry"], "children": ["modules", "each", "packages", "cloud", "kids", "jobs", "pages", "resources", "balls", "batch", "ls", "aos", "roots", "hawks", "files", "many", "parent", "ml", "they", "cs", "users", "these", "items", "blocks", "cache", "members", "fs", "los", "Children", "groups", "gall", "objects", "follow", "all", "keys", "ports", "stories", "json", "reports", "wn", "names", "ul", "ren", "ll", "parents", "ps"], "child": ["row", "pixel", "zip", "close", "c", "ch", "batch", "block", "parent", "count", "name", "cell", "id", "label", "client", "last", "l", "background", "cache", "q", "follow", "page", "lf", "shell", "char", "ph", "Child", "brother", "friend", "fr", "uncle", "comment", "file", "fd", "ll", "job", "entry", "key", "cow", "handle", "col"]}}
{"id1": "12055086", "id2": "4481712", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyDeleting": [" copyDeleving", " copydeletving", " copyDeletting", " copyDeeleting", " copydeletging", " copydeleving", " copydeleing", " copyDeletging", " copydeleging", " copyDelingging", " copydeletting", " copyDeleing", " copyDeeleving", " copyDelingving", " copyDelingting", " copyDeeleing", " copydeleting", " copyDeletving", " copyDelinging", " copyDeeleging", " copyDeleging"], "source": ["ace", "src", "sql", "sample", "SOURCE", "back", "base", "se", "scope", "parent", "store", "sp", "ce", "image", "resource", "spec", "seed", "service", "ource", "site", "from", "local", "start", "init", "origin", "search", "template", "style", "input", "original", "body", "target", "query", "oss", "Source", "form"], "dest": ["tom", "src", "cas", "null", "orig", "w", "Dest", "https", "end", "it", "trans", "way", "del", "pas", "sp", "decl", "port", "rest", "master", "temp", "dist", "th", "st", "cat", "mm", "exp", "origin", "bin", "img", "them", "target", "nom", "lit", "loc", "pub", "comb", "est", "dir", "d"], "buf": ["bh", "buff", "b", "bs", "cap", "pkg", "alph", "ref", "batch", "block", "Buffer", "cp", "comb", "vec", "fb", "buffer", "uf", "tab", "cur", "pause", "str", "Buff", "seq", "aka", "cf", "cmd", "bl", "cat", "eb", "bag", "rb", "img", "br", "conv", "capt", "db", "cb", "cv", "bytes", "box", "data", "cast", "tx", "fg", "bus", "meg", "bc", "prop", "arr"], "in": ["gin", "info", "per", "read", "un", "cin", "on", "it", "or", "ini", "inf", "inn", "ind", "ze", "ins", "ic", "rin", "by", "inc", "ai", "al", "user", "iter", "mm", "from", "IN", "init", "en", "isin", "bin", "inner", "con", "input", "ri", "din", "inside", "i", "el", "is", "In"], "out": ["os", "cn", "t", "end", "ion", "o", "up", "aos", "on", "client", "v", "writer", "can", "obj", "to", "outs", "flush", "log", "by", "io", "write", "conn", "dis", "n", "res", "output", "Out", "en", "inner", "page", "con", "nt", "conv", "outer", "sum", "ou", "oss", "i", "at", "sys", "auto", "OUT", "co", "ne", "net"], "count": ["counter", "t", "z", "read", "cloud", "length", "total", "c", "cont", "cap", "ch", "coll", "amount", "Count", "span", "batch", "add", "acc", "found", "ct", "check", "cc", "ind", "common", "cond", "now", "number", "q", "n", "code", "ount", "ctr", "start", "deep", "conf", "core", "char", "current", "nt", "num", "index", "sum", "comment", "size", "len", "max", "nb"]}}
{"id1": "13122204", "id2": "18696387", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnarchiveModule", "UnarchiveModel", "unzipModule", "unlatemodel", "unzipImage", "Unzipmodel", "UnzipModel", "unzipmodel", "unarchiveModel", "uncodeModel", "unarchiveImage", "unlateModel", "uncodeModule", "uncodeImage", "unarchiveModule", "UnarchiveImage", "UnzipModule", "Unarchivemodel", "uncodemodel", "unlateModule", "unlateImage", "UnzipImage", "unarchivemodel"], "filename": ["sql", "ivo", "FILE", "fn", "mson", "jpg", "FN", "fp", "journal", "path", "dra", "FIL", "username", "SourceFile", "nm", "fle", "name", "nil", "directory", "ename", "nl", "source", "stem", "n", "ln", "txt", "output", "location", "origin", "title", "original", "til", "kl", "river", "fil", "wl", "println", "file", "Filename", "subject", "download"], "tempdir": ["tmpdir", " tempfile", "tmpfolder", "Tempfile", "testpath", "tempdirectory", "testfolder", "tempDir", "temdir", "temDIR", " tempDIR", "tempDIR", " tempDir", "testdir", "temdirectory", "tempfile", "temppath", "tmpdirectory", "tempath", "temfolder", "tmpfile", "Tempdirectory", "tmpDIR", "tempfolder", " tempdirectory", "tmppath", "TempDir", "temDir", "testDir", "Tempdir", "tmpDir"], "dest": ["src", "null", "pos", "send", "Dest", "table", "cont", "document", "default", "stream", "desc", "trans", "parent", "store", "tail", "peer", "slave", "decl", "coord", "dc", "buffer", "port", "generated", "rest", "master", "obj", "writer", "temp", "out", "dist", "write", "source", "test", "st", "output", "ctr", "dat", "dev", "origin", "bin", "deep", "usr", "tr", "nt", "tmp", "nom", "pipe", "target", "inv", "sum", "ptr", "des", "foreign", "loc", "est", "display", "comb", "result", "del"], "fis": ["fjs", "fatis", "flis", "lis", "zatis", "flos", "zi", "fljs", "zjs", "ifatis", "flatis", "los", "zos", "ifos", "fli", "ifis", "li", "fi", "ifi", "ljs"], "BUFFER": ["BBER", "BUBuffer", "BAULT", "MAXFFER", "CUBuffer", "LOCKBuffer", "MAXOUNT", " BUOUNT", " BUULT", "BABER", "BufferBER", "LOCKBER", "BOUNT", "BAFFER", "BLBuffer", "MAXBuffer", "BufferBuffer", "BufferMT", "LOCKFR", "CUFR", "FFERMT", "BAOUNT", " BUFR", "BUBER", "LOCKFFER", "FFERBuffer", " BUBER", "BufferFFER", "BUMT", "BUOUNT", "BLOUNT", "FFERFFER", " BUMT", "BFFER", " BUBuffer", "BUFR", "FFERBER", "MAXBER", "BLBER", "BUULT", "BLFFER", "CUFFER", "CUBER", "BULT"], "zis": [" zris", "fip", "zip", "zeis", "xos", "ozip", " zIS", " zos", "zeos", "xis", "zies", "zi", "fiss", "ozis", "zoneris", " zi", "zees", "Zos", "zios", "Zis", " zip", "ozi", "zIS", "zeIS", "ziis", "zeris", "zoneits", "zos", "Zi", "zris", "zoneis", "Ziss", "ziss", "zits", "zoneiss", "xiss", "zes", "ziIS", " zes", "xi", " zits", "zeiss", "oziss", "fi", " ziss", "zeits"], "entry": ["record", "row", "item", "zip", "link", "Entry", "existent", "table", "jo", "piece", "se", "e", "or", "part", "way", "ce", "system", "cell", "connection", "ze", "image", "zo", "name", "log", "element", "enter", "member", "card", "source", "je", "pe", "jar", "inter", "ie", "def", "word", "char", "nt", "index", "ry", "comment", "escape", "match", "chain", "file", "header", "key", "ent", "result"], "count": ["OUNT", "counter", "z", "read", "cloud", "length", "total", "c", "cont", "amount", "Count", "batch", "base", "add", "acc", "found", "part", "check", "common", "cc", "ct", "cond", "cell", "ce", "buffer", "call", "f", "cache", "number", "n", "code", "ount", "child", "ctr", "start", "page", "all", "current", "core", "nt", "num", "index", "sum", "force", "comment", "size", "match", "len", "max", "nb"], "data": ["ata", "sample", "table", "done", "zero", "DATA", "batch", "raw", "results", "value", "part", "valid", "accept", "message", "ATA", "image", "buffer", "p", "content", "dec", "cache", "out", "str", "n", "window", "rel", "output", "step", "dat", " DATA", "all", "area", "next", "mat", "bytes", "size", "dl", "format", "text", "result", "d"], "fos": ["lOS", "voes", "foes", "Fos", " foes", "fOS", "voses", "Foes", " fios", "loss", "Foss", " foses", "los", "Foses", "fios", " foss", " fOS", "voss", "Fios", "vos", "foss", "foses", "lios", "FOS"]}}
{"id1": "6009527", "id2": "411595", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishShowAttention", "doFinishShowDetachment", "doFinishLoadAssached", "doFinishLoadAttachached", "doFinishShowAttached", "doFinishLoadAssention", "doFinishLoadAssachment", "doFinishLoadAttention", "doFinishLoadDetention", "doFinishLoadAttachention", "doFinishLoadAttached", "doFinishShowAttachment", "doFinishLoadDetachment", "doFinishShowDetached", "doFinishLoadDetached", "doFinishLoadAttachachment", "doFinishShowDetention"], "attachmentId": ["ATTociationKey", "attagramKey", "attachmentid", "attentionById", "ATTachmentId", "attociationid", "detachedId", "attgmentId", "attociationId", "attutationById", "ATTachmentById", "attociationName", "atachmentName", "atachmentId", "atachmentID", "attentionId", "detachedKey", "atachmentById", "attagramById", "attgmentid", "attgmentKey", "atutationID", "attociationKey", "attachedId", "detachmentKey", "attachmentName", "atutationById", "attutationId", "attociationID", "ATTociationid", "attutationID", "attachmentID", "attachmentKey", "atutationId", "atutationName", "attagramId", "detachmentid", "detachmentId", "attutationName", "attentionName", "ATTachmentKey", "attagramid", "attachmentById", "attachedKey", "attociationById", "detachedid", "attentionID", "ATTachmentid", "ATTociationId", "attachedid", "ATTociationById", "attachedById"], "attachment": ["assacher", "attachached", "attachaching", "attachacher", "attociation", " attacher", "attachachment", "assaching", "attention", "ATTention", "attachention", "detacher", "attached", "attment", "attacher", "contached", "addached", "detached", "contment", "ATTachment", "ATTached", "addaching", "addociation", "attachociation", "detachment", "ATTacher", "assention", "addachment", "contachment", "contacher", "attaching", "association", "assachment", " attached", " attment", "assached", "detment"], "attachmentUri": ["attachmentOri", "attachmentTuri", "attentionUri", "attachableOURI", "attachmentUnuri", "attentionUtpi", "attachmentOuri", "attentionUtRI", "attachmentTpi", "attachmentUuri", "attachableOri", "attachmentOURI", "attachableUURI", "attentionUpi", "attentionURI", "attachableUpi", "attentionUrid", "attachmentURI", "attachableUuri", "attachmentUtpi", "attachmentUURI", "attachmentUpi", "attachableUri", "attentionUtri", "attachmentUnpi", "attachmentupi", "attachmenturi", "attachmenturid", "attachmentUnURI", "attachmentTURI", "attachmentUtri", "attachableOpi", "attachmentOpi", "attachmentUnri", "attachmentuRI", "attachmentTri", "attachmentUtRI", "attachmentUrid", "attachableOuri", "attentionUtrid", "attachmentUtrid"], "contentUri": ["ContentUris", "contentURI", "contentUtrid", "ContentUuri", "contentUres", "ContentUsri", "contentuRI", "ContentUsrid", "contentUrric", "contentSiri", "contentUtric", "contentUsri", "contentURri", "contentUtRI", "ContentUri", "resourceUri", "contentUtri", "contentUtiri", "contenturi", "contentUnuri", "contentUrid", "contentUtres", "contentSuri", "contentUsrid", "ContentUsuri", "contentUric", "contentuuri", "contentUnris", "contentUris", "messageUtric", "messageUtri", "resourceUres", "ContentUrid", "contentUuri", "resourceUuri", "messageUri", "messageUric", "contentURres", "contentUsuri", "resourceURRI", "contentUruri", "contentSri", "resourceURuri", "contentUsris", "contentUriri", "contentURuri", "contentUtris", "messageUtiri", "resourceURres", "contentSric", "contentUturi", "contentUnri", "contentures", "contentUiri", "ContentUsris", "contentURRI", "contentUrri", "contentUnrid", "resourceURri", "messageUuri", "resourceURI", "messageUiri", "messageUturi"], "file": ["File", "ile", "zip", "FILE", "link", "disk", "table", "picture", "upload", "document", "il", "fp", "path", "rule", "h", "base", "line", "files", "media", "name", "message", "buffer", "port", "resource", "image", "to", "f", "content", "sf", "play", "folder", "source", "user", "output", "local", "create", "from", "init", "entity", "tree", "page", "save", "template", "work", "le", "db", "pool", "header", "channel", "format", "type", "ca", "filename", "result", "dir", "angle"], "in": ["gin", "sql", " IN", "read", " din", "mi", "up", "cin", "it", "on", "ini", "inf", "inn", "ind", "ain", "ins", "ic", "rin", "l", "io", "inc", "play", "al", "source", "IN", "from", "en", "bin", "isin", "inner", "con", "input", "din", "body", "i", "inside", "is", "ar", "and", "In"], "out": ["os", "null", "w", "b", "o", "aos", "it", "check", "client", "v", "writer", "can", "obj", "to", "outs", "flush", "print", "io", "stable", "write", "put", "ao", "n", "g", "res", "output", "ex", "Out", "all", "con", "screen", "nt", "conv", "outer", "ou", "oss", "i", "sys", "OU", "auto", "OUT", "co", "serv", "net"], "intent": ["Activity", "asso", "skill", "phrase", "activate", "statement", "prom", "condition", "displayText", "verbal", "device", "venture", "ment", "activity", "activation", "context", "animate", "ic", "spirit", "service", "q", "term", "action", "window", "express", "wordpress", "method", "alert", "widget", "act", "agent", "entity", "init", "continue", "voice", "man", "concept", "query", "inv", "json", "communication", "automatic", " Intent", "ence", "xml", "inst", "initial", "ant", "entry", "ident", "ink", "text", "ent", "event", "complete", "intention"]}}
{"id1": "841724", "id2": "7458833", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "21488518", "id2": "6299111", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public static String retrieveQ(String urlToRetrieve) throws MalformedURLException, IOException {\n        URL url = new URL(urlToRetrieve);\n        URLConnection uc = url.openConnection();\n        InputStream is = uc.getInputStream();\n        BufferedReader in = new BufferedReader(new InputStreamReader(is));\n        StringBuilder output = new StringBuilder(16384);\n        String str;\n        boolean first = true;\n        while ((str = in.readLine()) != null) {\n            if (!first) output.append(\"\\n\");\n            first = false;\n            output.append(str);\n        }\n        in.close();\n        System.err.println(((HttpURLConnection) uc).getResponseMessage());\n        return output.toString();\n    }\n", "label": 0, "substitutes": {"createNew": ["createFresh", "CreateFresh", "dataNext", "CreateNew", "getFresh", "CreateResource", "createResource", "dataNew", "dataResource", "getNext", "CreateNext", "dataFresh", "getResource", "createNext", "getNew"], "name": ["NAME", "null", "Name", "old", "end", "path", "key", "base", "prefix", "version", "value", "part", "nm", "none", "common", "use", "address", "id", "now", "client", "normal", "resource", "ename", "password", "only", "source", "one", "action", "n", "code", "no", "local", "create", "named", "missing", "title", "string", "template", "alias", "word", "current", "lat", "body", "index", "names", "ame", "description", "file", "size", "data", "format", "time", "type", "filename", "handle", "event"], "in": ["gin", "t", "err", "vin", "b", "c", "mc", "get", "cin", "it", "inn", "ind", "p", "ins", "s", "rin", "reader", "r", "al", "source", "from", "IN", "mm", "en", "inner", "bin", "isin", "con", "input", "din", "body", "asin", "ma", "i", "mat", "xml", "file", "data", "is", "In"], "length": ["read", "total", "amount", "path", "stream", "value", "count", "message", "buffer", "sequence", "password", "content", "padding", "enc", "height", "input", "position", "Length", "body", "description", "bytes", "size", "data", "len", "max", "text", "duration", "shape"], "contentType": ["Contenttype", "ContentLength", "contentLength", "mediaTypes", "contentTypes", "contenttype", "mediaLength", "mediatype", "ContentTypes", "mediaType", " contentLength", " contenttype", "ContentType", " contentTypes"], "dest": ["src", " dst", "wb", "orig", "disk", "Dest", "table", "resp", "cont", "path", "trans", "mem", "home", "parent", "oe", "there", "coord", "this", "rest", "obj", "temp", "folder", "source", " Dest", "iter", "cat", "dat", "origin", "copy", "tmp", "target", "nom", "lit", " destination", "loc", "self", "comb", "prop", "result", "dir", "d"], "out": ["go", "os", "null", "t", "w", "ent", "po", "end", "ion", "o", "up", "aos", "it", "client", "port", "obj", "s", "to", "outs", "log", "can", "io", "op", "off", "conn", "write", "n", "res", "output", "set", "ex", "Out", "copy", "en", "con", "conv", "outer", "ou", "oss", "sys", "OU", "external", "file", "OUT", "co", "serv", "cos", "col", "net"], "request": ["re", "QUEST", "forward", "params", "url", "reference", "require", "pair", "quest", "message", "report", "req", "library", "begin", "claim", "reset", "enter", "select", "ire", "user", "child", "create", "relative", "search", "move", "push", "input", "current", "query", "remove", "requ", "ask", "Request", "response", "open", "result"]}}
{"id1": "300397", "id2": "149935", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRepend", "readAndrewrites", "readAndResWrite", "readAndReprites", "readAndRewrites", "readAndRewWrite", "readAndReprite", "readAndResrites", "readAndrewrite", "readAndrewWrite", "readAndResend", "readAndrewend", "readAndResrite", "readAndRepWrite", "readAndRewend"], "inFile": [" infile", "inputFilename", "INFace", "inFILE", "INFile", "initFilename", "iFilename", "InFile", "outFilename", "inFace", "Infile", "inPlace", "initPlace", "initFace", "INPlace", "outfile", "initFile", "infile", "INFilename", "inputFile", "inTime", "iFile", "INFILE", "iFILE", "docTime", "INTime", "inputFace", " inFilename", "InFilename", "docFILE", "inFilename", "docFile", "inputPlace", "iTime", "docFilename"], "outFile": ["nameFILE", "toFilename", "inFILE", "nameFile", " outfile", "reportFilename", "outFilename", "reportfile", "namefile", " outFilename", "outfile", "checkFILE", "infile", "reportFILE", "outFILE", "reportFile", "tofile", "nameFilename", "checkfile", "checkFile", "checkFilename", "toFile", "toFILE", "inFilename", " outFILE"], "iis": ["iiisc", " ii", "iIs", "aiis", "ii", "liisc", "aiIs", "iiss", "eIS", "diis", "iiris", "diIs", "eIs", "iIS", "iiIs", "IIs", "dii", " iris", "liis", "iiis", " iiss", "iris", "liris", "Iis", "diiss", "Iiss", " iIS", "aiIS", "Ii", "iisc", "liIs", " iisc", " iIs", "eis"], "dcmParser": ["deromParser", "dcmAdapter", " dcmReader", "deromparser", "dcommReader", "DpmPar", "dcmparser", "dromparser", "dmmAdapter", "dpcPrivate", "dmodulePrivate", "DcmPar", "dpmLoader", " dpmAssistant", "DcmBuilder", "dmoduleReader", "dcomParser", "dcmReader", "Dcmparser", "deromReader", "dpcReader", "dgrReader", "dcfPar", " dpmListener", "dcfStatement", "dcrParser", " dcmparser", "dcmPrivate", "dcfParser", "dcfReader", " dpmPar", " dcmarser", "dcomReader", "Dpmparser", "dpmPrivate", "dromListener", "dgrStatement", " dcmPrivate", "dmmarser", "dfmReader", "DpmReader", "dpmParser", " dcmListener", " dpmReader", " dpmPrivate", "DcmAdapter", "dmmmReader", "DpmParser", "dcrparser", " dpmparser", "dpmarser", " dcmPar", "decmarser", "drumReader", "dmmReader", " dcmStatement", "decmParser", "dmParser", "dromParser", "dmmmParser", "dromarser", "dcrBuilder", " dpmStatement", "deromarser", " dcmBuilder", "dpmStatement", "dpcAssistant", "dmoduleParser", "dmmparser", "DpmBuilder", "dpmListener", "dgrParser", " dcmLoader", "dmparser", "dcommAssistant", "dcmPar", "dmarser", " dcmAssistant", "dmmmparser", "dcommParser", "dfmBuilder", "dcmBuilder", "dpmReader", "dcmLoader", "dcmAssistant", "dmmmAdapter", "dcmStatement", " dpmLoader", "dfmLoader", "dcomBuilder", "dpcParser", "DcmReader", "dromAssistant", "drumParser", "dcmarser", "dpmBuilder", "dmReader", "dpmAdapter", "dcrReader", "dgrPar", "drumBuilder", " dpmParser", "dmoduleAssistant", "dpmPar", "dpmparser", "dmmParser", " dpmarser", "dcmListener", "dcomLoader", "DcmParser", "drumPar", "decmparser", " dpmBuilder", "dromReader", "dfmParser", "dpmAssistant", "DpmAdapter", "decmReader", "dcommListener"], "ds": [" des", "os", "ads", "gd", "eds", "dq", "details", "ils", "eps", "in", "pd", "df", "bs", "qs", "dx", "services", "vs", "dh", "ws", "ls", "ss", "aos", "tes", "its", "ps", "Ds", "ns", "es", "cs", "obs", "s", "ins", "outs", "bd", "gs", "sd", "js", "fs", "sets", "pers", "sv", "rs", "ods", "dat", "ks", " DS", "drivers", "der", "ys", "hs", "xs", "uds", "db", "hd", "des", "sys", "as", "dds", "dt", "data", "dl", "DS", "ims", "da", "dos", "dd", "d"], "pdReader": ["ddRunner", "pedCar", "vdWriter", "vdLoader", "xdHelper", "ddReader", "pedRunner", "hdWriter", "dpLoader", "dpRunner", "xdLoader", "pedReader", "xdWriter", "dpReader", "pdParser", "xdReader", "pdRunner", "tdReader", "ddHelper", "vdHelper", "vdReader", "pdHelper", "ddWriter", "hdReader", "ddParser", "hdParser", "pdRead", "hdRead", "tdRead", "ddRead", "pdCar", "pdLoader", "tdParser", "tdWriter", "ddLoader", "pedLoader", "dpCar", "ddCar"], "out": ["cn", "t", "err", "w", "c", "up", "aos", "log", "flush", "io", "one", "str", "en", "oss", "OUT", "co", "net", "full", "pos", "end", "o", "it", "raw", "desc", "client", "to", "conn", " err", "ou", "pool", "cb", "serv", "we", "status", "go", "in", "gt", "opt", "on", "list", "v", "obj", "sw", "n", "res", "cmd", "txt", "inter", "all", "cfg", "screen", "outer", "tmp", "gen", "msg", "ent", "os", "null", "nr", "ch", "gr", "name", "id", "p", "writer", "ins", "s", "outs", "over", "cache", "js", "output", "ex", "Out", "inner", "con", "nt", "conv", "sum", "inv", "at", "sys", "auto", "data"], "dcmEncParam": ["dcmEscVal", "dmmEncCmd", "dcmDecParam", "dcmEncMsg", "dcmEncPar", "dcmDecMsg", "dcmEnNum", "dcmEscParam", "dmmencNum", "dmmEncParam", "dcmencPar", "dmmencCmd", "dcmDecCmd", "dcmEnVal", "dcmEncVal", "dmmencMsg", "dcmEncCmd", "dcmEscPar", "dcmencParam", "dmmEncVal", "dmmencParam", "dcmencNum", "dmmEnPar", "dmmEncPar", "dcmDecNum", "dcmencMsg", "dcmEnPar", "dmmEnNum", "dcmEscNum", "dmmEncNum", "dmmEnParam", "dcmEncNum", "dcmencCmd", "dmmEncMsg", "dcmEnParam"], "pdWriter": ["pidwriter", "pdWriting", "tdEditor", "dpWrite", "tdwriter", "PDWriter", "tdWriting", "tdWrite", "dpReader", "pcWrite", "pcwriter", "PDReader", "pdEditor", "PDWrite", "tdReader", "pcWriting", "pidWriter", "pcWriter", "pidWriting", "pdWrite", "pdwriter", "tdWriter", "PDEditor", "pidWrite", "dpWriter", "dpEditor"]}}
{"id1": "20365090", "id2": "20663364", "code1": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"execute": ["forward", "send", " proceed", "run", "Forward", "get", " foo", " finish", " find", " invoke", " call", "f", " retrieve", " transfer", "sync", " ping", "request", " forwards", " serve", " write", " dispatch", " now", " query", "next", " expect", " Forward", " perform", " flush"], "forwardResponse": ["forwardSolution", "forwardReturn", "ForwardResponse", "sendResp", "sendReturn", "reverseResponse", " forwardSolution", "forwardRequest", "ForwardRequest", " forwardresponse", "sendRequest", " forwardReturn", "ForwardReturn", "forwardResp", "forwardresponse", "Forwardresponse", "reverseSolution", "reverseresponse", " forwardRequest", " forwardResp", "ForwardResp", "reverseRequest", "sendResponse", "reverseResp", "ForwardSolution"], "fetchSizeLimit": ["fetchOwnerLim", "fetchOffsetTarget", "fetchServiceLim", "fetchColorLim", "fetchSizeFixed", "fatchLengthFixed", "fetchSizeTarget", "fetchsizeTarget", "fatalSIZELim", "fetchsizeLim", "fetchLengthLimit", "fatalSIZELimit", "fatalSize1", "fatchLengthLimit", "fatchSizeLim", "fetchLengthLim", "fetchOwner1", "fetchSIZELimit", "fetchOffsetLimit", "fetchColorLock", "fetchsizeLimit", "fetchLengthLock", "fetchServiceLimit", "fetchSizeLock", "fetchSizeLength", "fetchSizeSize", "fetchsizeSize", "fatalSizeLimit", "fetchOffsetLim", "fetchColorLength", "fatalSIZE1", "fetchSIZE1", "fetchColorLimit", "fetchOwnerLimit", "fatchSizeFixed", "fatchLengthLim", "fatchSizeLimit", "fetchsize1", "fetchSIZELim", "fetchLengthLength", "fetchSize1", "fetchLengthFixed", "fetchOffsetSize", "fetchServiceFixed", "fetchSizeLim", "fatalSizeLim"], "lastContentRange": ["firstContentRange", " lastContentRegion", "lastContentFrame", "lastVersionrange", "lastTimeRange", " lastVersionFrame", "lastVersionRegion", " lastVersionType", "lastVersionPart", " lastContentControl", "lastCacheError", "lastReadRange", "lastHeaderPart", "lastTimeRegion", " lastVersionControl", " lastContentPart", " lastContentrange", "lastVersionLine", "lastCacheRange", "lastContentRegion", "lastFrameLine", "lastFramePart", "lastContentControl", "lastVersionError", "firstCacheError", "lastMediaControl", "lastcontentError", "lastHeaderType", "lastReadrange", "lastcontentRange", "lastFrameRange", " lastVersionRange", "lastTimerange", "lastVersionRole", "lastTimeFrame", "firstContentError", "lastContentError", "lastVersionControl", "lastMediaFrame", "lastMediaRange", " lastContentLine", "lastContentsRange", "lastHeaderRange", "firstCacheRange", "lastContentRole", "lastcontentRole", " lastContentType", "firstContentRole", "lastVersionRange", "lastContentsRegion", "lastVersionFrame", " lastVersionRegion", "lastCacheType", "lastcontentType", "firstCacheRole", "lastHeaderFrame", " lastContentFrame", " lastVersionPart", "lastContentrange", "lastFrameFrame", "lastVersionType", "lastHeaderLine", " lastVersionrange", "lastReadFrame", "lastHeaderControl", "firstCacheType", "lastContentPart", " lastVersionLine", "lastContentType", "lastCacheRole", "lastMediaType", "lastReadRegion", "firstContentType", "lastContentsFrame", "lastContentLine"], "old": ["ret", "less", "older", " previous", "ard", "orig", "other", "olds", "hold", "buff", "ld", " olds", "alt", "diff", "managed", "back", " older", "ref", "nd", "bold", "or", "ind", "now", "build", "olded", "list", "high", "arg", "last", "obj", "md", "rest", "l", "bound", "element", "reset", " low", "al", "low", "told", "ord", "same", "test", "local", "hard", "good", "lower", "art", "inner", "def", "small", "lf", "existing", "ext", "Old", "east", "past", "red", "and", " existing", "aux", "bor", "OLD", "under"], "sendSize": ["sendType", "exportSize", "spreadBytes", "msgLength", " sendStyle", "submitSIZE", "submitSize", "submitBytes", "exportLength", "findBytes", "spreadInfo", "sentLength", "seesize", "sendFontSize", "SendFontSize", "sentSize", " sendBytes", "SendSize", "findFontSize", "sendBytes", "sentInfo", "findLength", "SendStyle", "sentSIZE", "findsize", "msgSize", "msgBytes", "sendStyle", "spreadSize", "sendInfo", " sendLength", " sendType", "sendsize", "sendLength", "seeFontSize", "sentBytes", "msgSIZE", "exportInfo", "exportBytes", " sendSIZE", "Sendsize", "sentStyle", "submitLength", "sendSIZE", "SendLength", "seeSize", "SendType", " sendInfo", "spreadSIZE", "findSize", "seeLength", "findInfo", "sentType"]}}
{"id1": "3330944", "id2": "18693224", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractImage": ["extractorImage", "extractImages", "ExtractImages", "extlateImage", "extprocessFrame", "ExtprocessFrame", "ExtprocessImage", "Extprocessimage", "extractorImages", "extlateFrame", "ExtprocessImages", "extprocessImage", "Extractimage", "extlateImages", "extractFrame", "ExtractFrame", "extractorimage", "extlateimage", "ExtractImage", "extprocessimage", "extprocessImages", "extractorFrame", "extractimage"], "input": ["before", "null", "upload", "sample", "audio", "empty", "rc", "path", "url", "base", "prefix", "it", "raw", "check", "internal", "error", "address", "this", "context", "image", "buffer", "ins", "p", "uri", "background", "seed", "hidden", "out", "request", "Input", "source", "q", "str", "select", "from", "start", "ip", "init", "local", "origin", "string", "txt", "pattern", "partial", "current", "img", "tmp", "index", "query", "i", "config", "qa", "xml", "initial", "file", "data", "hello", "format", "text", "accept"], "output": ["pretty", "PUT", "path", "o", "Output", "prefix", "success", "oe", "icon", "name", "image", "generated", "port", "to", "print", "hidden", "temp", "put", "write", "out", "source", "current", "STDOUT", "target", "OU", "file", "OUT", "response", "type", "format", "display", "filename", "result"], "params": ["pretty", "styles", "modules", "eters", "details", "m", "packages", "pps", "eps", "actions", "phi", "images", "arms", "pkg", "devices", "prop", "docs", "points", "pi", "results", "settings", "pas", "Par", "abilities", "p", "users", "s", "spec", "AMS", "fps", "pins", "proc", "members", "gs", "pro", "param", "Parameters", "caps", "mm", "rs", "ctx", "keys", "types", "ports", "conf", " parameters", "jp", "properties", "units", "par", "photos", "las", "phys", "ims", "terms", "json", "changes", "ams", "parts", "config", "ars", "tools", "names", "marks", "chains", "requires", "stats", "options", "parents", "tags", "ps"], "w": ["m", "hw", "wb", "rw", "wh", "wx", "ws", "h", "o", "W", "e", "v", "p", "writer", "Ws", "f", "we", "sw", "write", "out", "q", "wr", "kw", "window", "n", "ew", "word", "wo", "wl", "wt", "wa", "Writer", "nw", "wal", "wd", "wp", "d"], "in": ["gin", "info", "sql", "null", "include", " IN", "po", "read", "nin", " din", "old", "path", "mc", "mi", "In", "base", "cin", "it", "raw", "e", "ini", "inf", "inn", "id", "name", "p", "ins", "rin", "f", "copy", "out", "al", "Input", "source", "one", "ln", "IN", "mm", "from", "win", "init", "local", "en", "isin", "bin", "inner", "all", "con", "edIn", "conf", "sin", "din", "phys", "ma", "i", "file", "is", "ar", "vin"], "dest": ["src", " dst", "wb", "orig", "Dest", "tif", "alt", "resp", "opt", "end", "cont", "path", "ws", "shape", "trans", "desc", "mem", "way", "oe", "pas", "decl", "p", "port", "rest", "to", "deg", "temp", "out", "dist", "write", "source", "buf", "st", "cat", "csv", "txt", "dat", "origin", "save", "img", "usr", "tmp", "nom", "target", "pipe", "lit", "des", "data", " destination", "loc", "display", "comb", "prop", "result", "dir"], "bi": ["ji", "bra", "obi", "hog", "bh", "bg", "bie", "umi", "rob", "buff", "b", " nib", "gi", "bs", "mu", "qi", "phi", "mi", "oi", "bf", "pi", "be", "beck", "isi", "bm", "bb", "di", "ini", "zi", "ib", "ba", "abi", "bo", "pb", "bank", "ibi", "obo", "vi", "ai", "bits", "ali", "ibe", "iri", "Bi", "jiang", "ni", "bin", "ble", "ki", "BI", "bp", "bil", "bas", "nb", "phy", "li", "i", "fi", "yi", "bis", "bone", "bc"], "os": ["Os", "mot", "ox", "ros", "pos", "bs", "oses", "ot", "us", "ons", "o", "ls", "css", "ios", "aos", "osi", "or", "oid", "es", "oes", "ns", "cs", "ow", "ose", "ts", "ows", "s", "mos", "io", "fs", "los", "acs", "ols", "oos", "ds", "ks", "bos", "ys", "ops", "oss", "sys", "is", "OS", "cos", "oo", "et", "obs"]}}
{"id1": "13421722", "id2": "23672408", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getFileSize": ["getContentLen", "getByteLength", " getFileLength", "getContentBytes", "getFilesSize", " getFilesLength", "getFilesLen", "getFileBytes", "getFileLength", " getFileBytes", "getByteLen", " getFilesBytes", "getFilesLength", "getContentSize", "getFileLen", " getFileLen", "getContentLength", " getFilesSize", "getFilesBytes", " getFilesLen", "getByteSize", "getByteBytes"], "address": ["domain", "email", "table", "host", "base", "prefix", "reference", "add", "name", "message", "port", "directory", "resource", "uri", "password", "report", "street", "number", "route", "country", "argument", "order", "ip", "location", "search", "string", "word", "server", "network", "index", "campus", "point", "Address", "addr", "localhost", "description", "remote", "command", "attribute"], "url": ["re", "ur", "u", "null", "http", "email", "parse", "link", "run", "https", "un", "il", "path", "ref", "ls", "util", "base", "gl", "build", "name", "client", "uri", "l", "f", "sl", "r", "nl", "git", "conn", "rl", "q", "str", "window", "mount", "console", "www", "location", "sb", "ssl", "string", "char", "atl", "Url", "mail", "web", "ul", "el", "xml", "file", "ll", "loc", "dl", "cert", "URL", "browser"], "connection": ["creator", "link", "close", "c", "ion", "object", "termination", "statement", "creation", "character", "reference", "cone", "condition", "version", "socket", "settings", "system", "Connection", "client", "context", "resource", "directory", "to", "password", "message", "event", "pointer", "operation", "conn", "number", "connected", "application", "controller", "function", "output", "language", "section", "position", "network", "session", "relation", "access", "display", "communication", "city", "connect", "subject", "channel", "response", "entry", "translation", "open", "machine", "command", "collection"]}}
{"id1": "21125261", "id2": "7425022", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"test": ["train", "t", "read", "testing", "sample", "fit", "run", "evaluate", "unit", " evaluate", "feature", "example", "T", " sample", " tests", "debug", "server", "launch", "show", "Test", "tests", " testing", "execute", "hello", "load", "volt"], "is": ["os", "sis", "sit", "ms", "in", "bs", "us", "ws", "ls", "lis", "ios", "stream", "has", "isi", "its", "tis", "isc", "es", "ps", "s", "does", "ai", "out", "fs", "mis", "rs", "input", "ri", "ris", "iso", "xs", "i", "sys", "as", "IS", "xml", "Is", "ais", "serv", "isa", "are"], "byteArrayOutputStream": ["byteStringoutputStream", "byteArrayInputForm", "byteStringOutputStream", "byteArrayInputView", "byteArrayOutputView", "byteArray4String", "byteArrayByteSteam", "byteStringOutputString", "byteStringOutputForm", "byteArrayApplicationStream", "byteStringInputSteam", "byteArrayApplicationSteam", "byteStringInputStream", "byteArrayInputSteam", "byteStreamOutputStyle", "byteStringoutputForm", "byteArrayInputStream", "byteStringoutputString", "byteArrayOutputSteam", "byteStringOutputView", "byteArrayApplicationStyle", "byteArrayOutputForm", "byteArrayoutputStream", "byteStreamInputStyle", "byteArrayoutputString", "byteArrayoutputForm", "byteStringInputString", "byteStreamOutputSteam", "byteArray4Stream", "byteStreamInputSteam", "byteStringOutputSteam", "byteStringInputView", "byteStreamOutputStream", "byteArray4Steam", "byteArrayApplicationForm", "byteArrayInputStyle", "byteArrayOutputStyle", "byteStreamInputForm", "byteArrayByteForm", "byteStreamInputStream", "byteStringoutputSteam", "byteArrayByteString", "byteStreamOutputForm", "byteArrayByteView", "byteArrayByteStyle", "byteArrayOutputString", "byteArrayoutputSteam", "byteArrayInputString", "byteArrayByteStream", "byteArray4View"], "def": ["dict", "det", "df", "d", "Def", "dal", "default", "definition", "dem", "desc", "DEF", "decl", "cd", "md", "dec", "pro", "sd", "DE", "define", "de", "sche", "dev", "ds", "conf", "ef", "Definition", "json", "ded", "db", "hd", "des", "defined", "dl", "da", "crit", "del"], "se": ["ene", "ase", "ade", "parse", "sem", "spe", "ee", "sel", "ode", "ge", "engine", "ste", "be", "e", "su", "ide", "ser", "es", "she", "sp", "ce", "ine", "ane", "ze", "ae", "sl", "ve", "sed", "ese", "ses", "sd", "Se", "me", "pe", "de", "see", "set", "sche", "ense", "sea", "ie", "sec", "sa", "le", "pse", "te", "ke", "he", "SE", "so", "ne", "we", "est"], "linkId": ["connectionIdent", "linkid", "lineid", "chainIdent", " linkid", "chainId", "linkName", "linkedId", "linkedID", " linkID", "lineId", "Linkid", "linkIdent", "LinkName", "lineID", " linkName", "lineName", "linkedIdent", "chainID", "connectionId", "connectionID", "LinkID", "linkID", "LinkId"], "segmentId": ["begmentById", "sementid", "segementid", "segroupById", "begmentId", "sementRef", "begmentName", "segmentById", "idegementName", "segementId", "segementName", "idegmentId", "begmentID", "segmentRef", "semissionId", "idegementRef", "segementID", "segroupId", "segmentid", "segmentName", "idegmentid", "begroupId", "semissionid", "segementById", "idegmentRef", "begroupById", "sementID", "semissionRef", "segementRef", "begroupName", "segmentID", "sementById", "sementId", "sementName", "idegementId", "semissionName", "segroupID", "idegmentName", "segroupName", "idegementid", "begroupID"], "linkSegments": ["linkParments", "linkConnectroups", "linkPargments", "linkGgments", " linkSegroups", "linkThreadments", "linkThreadlements", "linkSeables", "linkThreadroups", "linkConnectlements", "linkFragment", "linkConnectets", "linkSegroups", "linkFragments", " linkGgments", "linkBuildables", "linkThreadgments", " linkSegables", " linkBuildments", "linkSements", "linkSeggments", "linkBuildments", "linkConnectments", "linkConnectables", "linkFraggments", "linkGment", "linkBuildroups", "linkSeglements", " linkThreadroups", " linkSeggments", "linkFragroups", "linkBuildment", " linkSegment", "linkBuildets", " linkBuildables", " linkBuildgments", "linkGroups", "linkSeets", "linkParroups", "linkConnectgments", "linkBuildgments", " linkSeglements", "linkSegables", "linkParlements", " linkThreadlements", " linkGments", "linkGments", "linkSegment", " linkGroups", "linkSegets", " linkGment", " linkSegets", " linkThreadments", " linkBuildets", " linkThreadgments"], "segments": ["sectors", " seges", " Seges", " sevals", "vements", "usegins", " sements", "bevals", "parsements", "megins", "segins", "mements", "vegments", "segs", " selements", "parselements", " Segments", " Sements", "seges", "usements", "beges", "parsectors", " segs", "parsegments", "usegments", " Sevals", "megs", "sements", "bements", " segins", "velements", "usegs", "selements", " sectors", "begments", "megments", "sevals", "vectors"], "frameProperties": ["framePropps", " frameByptions", " frameByilities", " frameProptions", "framePrrics", "frameParrics", " framePrperties", "frameComptions", "frameParperties", "frameComrics", " framePrps", "frameParptions", "frameProfptions", " frameProps", "frameComperties", "frameProrics", "frameProfps", " frameByperties", "framePrps", "frameByilities", " frameProrics", "frameProfperties", "frameProptions", "frameProilities", "framePrptions", "framePropptions", "frameProps", "frameParps", "framePropperties", "frameByps", "frameProfilities", "framePropilities", "frameComps", " framePrrics", " framePrptions", " frameProilities", "frameByptions", "frameByperties", " frameByps", "framePrperties"], "time": ["tim", "tt", "before", "each", "counter", "t", "length", "ime", "total", "runtime", "think", "speed", "timer", "version", "value", "etime", "check", "count", "now", "system", "rate", "message", "context", "sequence", "ts", "estamp", "frequency", "trust", "depth", "transform", "x", "window", "date", "set", "start", "step", "Time", "timeout", "distance", "clock", "money", "slow", "second", "point", "times", "trace", "delay", "task", "size", "tx", "year", "event", "duration", "TIME"], "vehicle": ["vehICLE", "verocity", "yardicle", "Vehocity", "yardogram", "verticle", "venticle", "heroICLE", "vertocity", "vehicles", "heroicle", "vehic", "verticles", "verogram", "survendor", "yardendor", "venticles", "Vehicle", " vehICLE", "heroocity", "vertic", " vehicles", "Vehicles", "survocity", "Vehic", "VehICLE", "vehendor", "heroicles", "vehocity", " vehocity", "yardocity", "survicle", "vericle", "ventocity", "vehogram", "verendor", "survogram", "ventic"]}}
{"id1": "20011285", "id2": "6188784", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "pixel", "zip", "link", "gc", "close", "c", "Copy", "delete", "opy", "cp", "php", "p", "to", "sync", "write", "Cop", "cat", "create", "crop", "export", "move", "save", "share", "clip", "slice", "proxy", "split", "transfer", "cut", "clone", "file", "py", "co", "remote", "cop", "download"], "sourceFile": ["srcFILE", " sourceLocal", "sourceLocal", "sourcePlace", "sourceUser", "ourcePath", "sourceDirectory", "aceDate", "packageFILE", " sourceFILE", "ourceDirectory", "sourceLine", "srcFile", "acePlace", "identFiles", "sampleFile", "originFile", " sourcefile", "srcUser", "ourcefile", " sourceDir", "identFile", "sourceFILE", "sourceWeb", "SourceFile", "srcLocal", "SourcePath", "sourceHeader", "packageDirectory", "SourceUnit", "SourceFiles", "srcfile", "sourceFiles", "sampleLocal", "sourceDate", " sourceFiles", " sourcePath", "identPlace", "sourceDir", "initfile", "initHeader", "sourceUnit", "aceFile", "identDate", "packageUser", "srcUnit", "srcHeader", "initFile", "originDir", "initFILE", "SourceLine", "packageFile", "sourcefile", " sourceHeader", "ourceFILE", "originWeb", "srcFiles", "SourceWeb", " sourcePlace", " sourceUnit", "sourceLog", "SourceLog", "ourceLog", "aceFiles", "ourceFile", " sourceDate", "originLine", "srcDirectory", "sourcePath", " sourceLine", " sourceWeb", "Sourcefile", " sourceLog", "samplefile", "SourceDir", "ourceUser", "sampleFILE"], "destinationFile": ["destinatorFILE", "destinatedDisk", "parentinateEmail", "destinateDir", "destinationMail", "resultinationfile", "destentionFILE", "destationFile", "destinateLocation", "destationfile", "estinatorDir", "destensionFile", "destinationEmail", "destensionFILE", "parentinationEmail", "destificationPath", "identinatedMail", "destinatefile", "transinateFile", "identinatedFile", "destinatedFILE", "destinatedMail", "identinatedLine", "destinatorFile", "destationPath", "destumentFile", "destentionFile", "destructionLine", "destinofile", "destinatedfile", "destinoFile", "identinationLine", "destinatedFile", "destinateDisk", "resultinateFile", "destinationDir", "parentinationFile", "destinationKey", "destensionDir", "destentionMail", "destinationPath", "destinationLocation", "destinationLine", "identinatedFILE", "identinationFILE", "parentinateFILE", "estinationFile", "destinoKey", "destmentationDir", "destationDir", "destationKey", "destinatedLocation", "destmentationFILE", "destructionMail", "catinatefile", "destinatorEmail", "transinateFILE", "destificationFile", "destinatorDisk", "identinationFile", "resultinationFile", "catinationfile", "destentionLine", "catinationFile", "resultinateDisk", "catinateFile", "destinatedLine", "resultinationLocation", "destinatorDir", "resultinationDisk", "catinationKey", "resultinatefile", "destructionFILE", "destinatorPath", "destinateFILE", "destinationFILE", "destmentationDisk", "destinationfile", "estinatorfile", "transinateDir", "destumentFILE", "destructionFile", "parentinateFile", "transinationDisk", "destumentEmail", "resultinateLocation", "transinationFile", "estinatorPath", "parentinationFILE", "destmentationFile", "destensionDisk", "destinatorLocation", "destinateEmail", "destinationDisk", "transinationDir", "destificationDir", "estinatorFile", "estinationDir", "destinatorfile", "destinateFile", "catinateKey", "destinateKey", "transinationFILE", "estinationPath", "identinationMail", "transinateDisk", "destificationfile", "estinationfile"], "tmp": ["perm", "tt", "m", "ms", "src", "bt", "cmp", "shots", "t", "aaa", "buff", "pkg", "my", "managed", "mk", "tar", "xxx", "stuff", "files", "sp", "p", "multi", "obj", "tab", "mb", "temp", "cur", "emp", "np", "yy", "buf", "txt", "mm", "etc", "img", "nt", "xs", "split", "pres", "abs", "parts", "cb", "apps", "tf", "data", "msg", "mp", "qq", "nb", "aux", "dir", "obs"], "f": ["full", "m", "u", "t", "w", "z", "fab", "df", "b", "c", "fw", "fp", "F", "o", "h", "a", "bf", "fm", "func", "e", "fe", "ff", "fb", "p", "v", "flo", "obj", "uf", "l", "k", "fl", "sf", "fo", "q", "fs", "g", "cf", "fc", "lf", "fac", "fr", "af", "file", "fd", "fi", "tf", "field", "xf", "fa", "d"], "i": ["ji", "m", "iq", "ms", "ci", "u", "im", "in", "phi", "j", "gi", "ii", "qi", "my", "I", "us", "o", "key", "mi", "ti", "batch", "pi", "it", "e", "di", "ini", "ui", "ind", "hi", "id", "zi", "p", "y", "multi", "v", "ic", "k", "ai", "q", "x", "ori", "me", "iu", "bi", "iter", "ip", "init", "si", "ie", "ij", "ki", "ri", "index", "point", "sim", "li", "ix", "ma", "ami", "xi", "eu", "is", "ims", "ei", "major"], "source": ["info", "src", "before", "storage", "zip", "in", "sample", "SOURCE", "archive", "zero", "score", "base", "stream", "se", "scope", "none", "parent", "store", "ce", "system", "use", "iterator", "image", "resource", "sequence", "spec", "owner", "seed", "service", "scan", "console", "ource", "site", "from", "local", "start", "iter", "init", "origin", "missing", "search", "tree", "style", "template", "ie", "input", "inner", "show", "body", "index", "session", "query", "Source", "comment", "file", "size", "subject", "series", "result", "shell"], "destination": ["Destinator", "combinate", " destation", " destinate", "coordation", " destinator", "destation", "Destation", "destaration", "declinated", "Destination", "Destension", "declinator", " destaration", " destension", "combension", "Destaration", "combination", "declinate", "Destinate", "combation", "coordination", "coordinated", "coordinate", "destinator", "destinate", " destinated", "declaration", "destinated", "destension", "declination", "declation"]}}
{"id1": "22264586", "id2": "13783549", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFiles": ["transferfiles", " copyChildren", "cpfiles", "cpFiles", " copyFile", "copChildren", "copyBlocks", "cpBlocks", "copItems", " copyfiles", " copyBlocks", "transferChildren", "transferFiles", "cpFile", "copfiles", "copyChildren", "CopyFiles", "Copyfiles", "copyFile", "transferItems", "CopyBlocks", "copFiles", "CopyFile", "copyfiles", " copyItems", "copyItems"], "strPath": ["strpath", "StrPath", " strFile", "strWhere", "StrPort", "srcpath", "STRFile", " strWhere", "strName", "StrFile", "strFile", "STRCh", "srcPath", "brPath", "strCh", " strCh", "srcName", "StrName", "strPort", "brPort", "brpath", "brName", "STRWhere", "STRPath", "srcPort", "StrCh", "Strpath", "StrWhere"], "dstPath": ["dptPath", "dptpath", "dptUrl", "ddestpath", "dptName", " dndDir", "sdstpath", "sdstPath", "sdstUrl", "dndUrl", "sddestpath", "dckDir", "dstName", "dstUrl", "sddestUrl", " dndPath", " dndDirectory", "dckDirectory", " dstDirectory", "ddestDir", "ddestFile", "ddestDirectory", "ddestUrl", "dndPath", "dndFile", "dckPath", " dndFile", "dndpath", "dndName", "sddestPath", "dstDir", " dstDir", "ddestName", "dstDirectory", "dstFile", "ddestPath", "dndDirectory", "dstpath", " dstFile", "sdstName", "dckFile", "sddestName", "dndDir"], "src": ["rt", "sit", "sc", "sing", "http", "SOURCE", "sel", "attr", "rc", "pkg", "syn", "cont", "se", "func", "stock", "raw", "desc", "ser", "sq", "sp", "ind", "rest", "ins", "req", "sl", "sf", "cur", "sub", "rl", "source", "str", "rel", "st", "txt", "rs", "ctr", "sb", "rx", "sn", "start", "ssl", "rb", "iv", "sec", "input", "img", "usr", "sin", "sr", "conv", "comp", "via", "abs", "sys", "Source", "inst", "loc", "ipl", "ctrl"], "dest": ["tom", "pl", " dst", "that", "orig", "Dest", "https", "opt", "end", "mk", "func", "desc", "trans", "del", "pas", "decl", "dc", "port", "rest", "master", "to", "deg", "obj", "mt", "doc", "temp", "out", "dist", "source", "sup", "st", "output", "txt", "good", "cat", "dat", "origin", "def", "them", "usr", "priv", "tmp", "target", "des", "vol", "loc", "self", "est", "pub", "comb", "result", "dir", "d"], "list": ["info", "detail", "alist", "dir", "table", "diff", "path", "range", "ls", "batch", "top", "get", "stream", "add", "block", "part", "count", "sort", "delete", "flat", "level", "name", "filter", "v", "sequence", "directory", "id", "spec", "l", "print", "number", "source", "str", "n", "pre", "test", "ist", "set", "feat", "stat", "copy", "tree", "string", "def", "all", "word", "show", "index", "li", "tag", "names", "html", "remove", "form", "LIST", "array", "listed", "format", "dl", "key", "label", "chain", "status", "load", "lists", "arr"], "i": ["ji", "info", "m", "ms", "ci", "u", "im", "in", "phi", "j", "gi", "ii", "gu", "qi", "c", "my", "I", "us", "span", "mi", "ti", "a", "batch", "pi", "it", "di", "ui", "ind", "ski", "id", "hi", "y", "v", "multi", "ic", "uri", "io", "ai", "x", "me", "bi", "set", "ex", "ip", "exp", "init", "inner", "si", "ie", "some", "ri", "conv", "index", "ims", "point", "sim", "li", "ix", "json", "xi", "is", "key", "ei", "major"], "dest1": ["desttab", " dsttab", "dest3", "Dest1", " dst1", "port01", "dest0", " dest3", "src3", " dest2", "dest01", " dest01", "port2", " dest0", "srctab", "Dest2", " dst3", " dst2", "port1", "src2", "port0", "dest2", "Dest01", " desttab", "Dest0"], "src1": ["src0", "rc2", "rc3", "src3", "source3", " src0", "source2", "rc1", " src2", "src2", "rc0", " src3", "source1", "source0"], "sourceChannel": ["ourceChannel", "parentPanel", "sourceGate", "ourceClient", "serviceChan", "srcGate", "fromGate", " sourceCommand", "resourceChannel", "sourcePanel", "sourceConnection", "resourceButton", "srcCommand", "sourcechannel", "srcClient", "targetChan", "fromChan", "targetchannel", "sourceClient", " sourceChan", "parentButton", "targetConnection", "fromChannel", "srcChannel", "ourceChan", "targetStream", "serviceChannel", "sourceCommand", "parentChan", "targetGate", "srcConnection", "resourcePanel", "parentChannel", "resourceChan", "srcChan", " sourceStream", " sourcechannel", " sourceClient", "servicePanel", "ourcechannel", "ourceStream", "ourceCommand", "sourceStream", "serviceButton", "fromConnection", "sourceButton", "sourceChan"], "targetChannel": ["targetConsole", " targetChain", "TargetChannel", " targetManager", "resultchannel", "sourceConnection", "destManager", " targetConnection", "targetManager", "resultChan", " targetConsole", "resultManager", "targetChan", "destChan", "targetchannel", "destChannel", "targetConnection", "TargetConnection", "argetChain", "resultConsole", "sourceChain", " targetChan", "argetChan", "resultConnection", "argetChannel", "Targetchannel", "destConsole", "resultChannel", "TargetChan", " targetchannel", "argetConnection", "targetChain", "sourceChan"]}}
{"id1": "10391753", "id2": "21489105", "code1": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"encrypt": ["cipher", "Encrypt", "decipher", "encryption", "crypted", "decryption", "Encipher", "encrypted", "crypt", "encipher", "cryption", "decrypted", "decrypt", "Encryption", "Encrypted"], "text": ["Text", "hex", "secret", "t", "w", "phrase", "read", "binary", "cont", "document", "path", "TEXT", "prefix", "value", "required", "name", "message", "buffer", "password", "print", "content", "hidden", "x", "str", "source", "code", "txt", "output", "string", "pattern", "input", "word", "char", "nt", "ext", "config", "data", "command"], "toEncrypt": [" toEnreat", " toSecrupt", "toSecrupt", "toEncrypted", "TOEncrypted", "toExplrupt", "toSecrypt", " toEnrypted", " toSecrypted", "toIntegrypt", "TOAcrypt", "toIntegrypted", "toAcrypt", "toSeccrypt", "toExplrypt", "toEnreat", "toInteglect", "toAcreat", "toExplrypted", "TOAcrypted", "toAccrypt", "toEnccrypt", " toEncrypted", "toEnlect", "toEncreat", "toSecrypted", " toEnccrypt", "toExplcrypt", " toSeccrypt", "toEncrupt", " toEnlect", "toIntegreat", " toEnclect", "TOEnccrypt", "TOEncrypt", "toEnclect", " toSecrypt", " toEncreat", "toAclect", "TOAccrypt", "toEnrypted", " toEncrupt", "toAcrypted", " toEnrypt", "toEnrupt", "toEnrypt"], "hexString": [" hexRing", "hwNumber", "exstring", "hexstring", "pexNumber", "hwRing", "hexArray", "hwArray", "hashString", "exStr", " hexstring", " hexStr", "hashBuffer", "exString", "pexRing", "exBuffer", "hexNumber", "expstring", "hexStr", "hexRing", " hexArray", "hwString", "pexArray", "expArray", "hashstring", "pexString", "hexBuffer", "hashStr", "expString", " hexBuffer", "exArray", "expStr", " hexNumber"], "dig": ["dd", "mod", " des", "plug", "pos", "read", "df", "rip", "ld", "get", " Dig", "add", "nd", "rd", "ng", "da", "desc", "del", "ind", "dc", "cd", "md", "mn", "od", "ve", "bd", "dec", "write", "enc", "pat", "dis", "res", "pers", "de", "round", "sign", "find", "exp", "dat", "dr", "comm", "eval", "def", "deep", "dep", "div", "fun", "alg", "db", "hash", "des", "her", "red", "grad", "fin", "vol", "cong", "and", "Dig", "dir", "d"], "pw": ["pws", "cpwal", " pwal", "phpwal", " apW", "tpwd", "tpwr", "Pwr", "cpw", " apw", " pws", "pW", " pwa", "Pwp", "cpwa", "tpw", "Pwd", "tpws", " apwp", "pwal", " pwd", " pwr", "phpwr", "pwa", "pwp", "pwd", "phpwa", " pwp", " apwd", "pwr", "PW", " pW", "Pw", "cpwr", "phpw", "Pws"], "i": ["info", "m", "umi", "err", "c", "us", "I", "oi", "y", "io", "me", "init", "ie", "ms", "j", "gi", "MI", "o", "pi", "it", "ice", "di", "ind", "client", "ai", "\u0438", "q", "you", "bi", "PI", "li", "im", "in", "phi", "ii", "qi", "ion", "ti", "batch", "ini", "ski", "php", "multi", "iy", "uri", "iu", "iter", "ip", "cli", "ki", "xi", "is", "fi", "ei", "ji", "iq", "ci", "gu", "mi", "ui", "id", "sequence", "ic", "g", "ni", "ex", "si", "ri", "sim", "ix", "ami", "ims", "chain", "ity"], "digest": ["decist", "digse", "Digse", "Digested", "Digress", "dester", " digist", "digested", "deceter", "cdest", "hexest", "encest", "digester", "encester", "decest", "encse", " digress", "dist", "DigEST", "cdester", "Digeter", "dested", "dest", " digested", "digeter", "decester", " digse", "hexested", " digEST", "decested", "digist", "digress", "cdEST", "encEST", "Digest", "decEST", "Digester", "digEST", "hexEST", " digester", "hexeter", "cdress"], "digestLength": ["digistryVolume", "digistVolume", "DigestLen", "digidateLen", "digistryInstallation", "digistNumber", "DigestLength", "digestedLength", " digidateLen", "digestNumber", "digestedNumber", "DigistNumber", "digestVolume", " digestInstallation", " digidateInstallation", "digistryLength", " digestLen", "DigistLen", "digestLen", "DigistLength", "digidateVolume", " digidateVolume", "digistryLen", "digestedLen", "digistInstallation", "digesterNumber", " digestVolume", "digistLen", "digesterLength", "DigestNumber", "digistLength", "digidateInstallation", "digidateLength", " digidateLength", "digesterLen", "digestInstallation"]}}
{"id1": "9109613", "id2": "6517139", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 0, "substitutes": {"fileCopy": ["FileCop", "Filecopy", "docopy", "doCopy", "fileUpload", "FileCopy", "doUpload", "fileCop", " fileCop", " fileUpload", " filecopy", "doCop", "FileUpload", "filecopy"], "from_name": [" from_admin", "from_base", "from_user", " from__names", "from_names", "from__name", " from__name", " from_user", " from_value", " from_no", "from_world", "from_no", "from__size", "to_world", "fromptnames", " from_client", " from_type", "from_size", "from_case", "from_type", "from_value", " from_base", "fromptadmin", " from__size", " from_size", "to_case", "from_admin", "from_client", " from_names", "from__names", "fromptname"], "to_name": ["to_names", "into_path", "intoNamepath", " to_Name", "to_Name", "toNamecode", "toNamepath", "into_code", "to_code", "toNamenames", "intoNamecode", "into_names", "to_path", " to_long", "intoNamename", "to_long", "toNamename", " to_names", "into_num", "to_num", "into_name", "intoNamenames"], "fromFile": ["entryFile", "onFILE", "orFile", "startFilename", "FromFile", "normalTime", "givenPage", "normalFile", "normalfile", "sentfile", "boundFile", "oldDo", "boundFILE", "oldLine", "fromPlace", "onFile", " fromPlace", " fromTime", "fromGlobal", "smallFILE", "fromName", "newGlobal", "smallFiles", " fromPage", "fromLine", "boundPlace", "Fromfile", " fromFiles", "smallPlace", "fromFILE", "normalLine", "sentPage", "normalField", "FromLine", "tofile", "smallFile", "newPage", "formFile", "onfile", "oldFile", "orPage", "formName", "toPage", "entryName", "fromField", "fromFiles", "givenFile", "entryfile", "fromDo", "sentFile", "oldfile", " fromFILE", "startName", "sentField", "boundFiles", " fromGlobal", "normalPage", "startfile", "fromFilename", "fromfile", "orLine", "formFilename", "newfile", "orTime", "FromDo", "FromFILE", "fromTime", "formfile", "givenfile", " fromDo", "fromPage", "newFile", "entryFilename", " fromfile", "startFile", "givenGlobal", "toField", " fromLine"], "toFile": ["intoTable", " toTable", "byFile", "etoFile", "TOFile", "TOfile", "etoFILE", "toTable", "Tofile", " toFiles", "templateFILE", "twoPath", "etoDefault", "intoPort", "toFiles", "targetModel", "TOPort", " toFilename", "toProcess", " toPlace", " toTime", "etoProcess", "toName", "thatFile", "toMessage", "twoPort", "fromName", "toFilename", "toPort", "toDefault", "fromMessage", "byPlace", "ToFILE", "bySourceFile", "ToFilename", " toPort", " toSourceFile", "etofile", "tofile", "fromTable", "twoFiles", "intoMessage", "newPlace", "etoMessage", "toPath", "fromFiles", "twoFile", "targetFILE", "intoName", " toDo", " toPath", "toDo", "targetTable", "TOPlace", "intoFiles", "TOSourceFile", "targetPlace", "fromPort", "newSourceFile", "intoProcess", "ToModel", "TOTime", "templateTable", "toModel", " tofile", "newfile", "TOFiles", "thatFILE", " toFILE", "thatDefault", "toSourceFile", "ToFile", "ToFiles", "templateModel", "byfile", "twoTime", " toDefault", "newFile", "intoFile", "twoSourceFile", "targetDo", "ToTable", "TOPath", "toFILE", "twofile", "toTime", "targetFile", "fromProcess", "etoName", "toPlace", "thatfile", "templateFile"], "parent": ["m", "module", "null", "pos", "per", "params", "central", "pid", "where", "my", "rule", "path", "component", "host", "shape", "prefix", "tar", "holder", "pi", "up", "desc", "Parent", "home", "peer", "sp", "name", "snap", "this", "p", "port", "directory", "id", "master", "owner", "mt", "unit", "layout", "spec", "event", "folder", "temp", "paren", "source", "uid", "child", "ip", "timeout", "exp", "origin", "tip", "tree", "page", "mother", "def", "position", "instance", "server", "root", "man", "tmp", "point", "ma", "pool", "global", "form", "file", "remote", "family", "parents", "filename", "chain", "prop"], "dir": ["dd", "mod", "dict", "module", "det", "cont", "coll", "path", "or", "di", "del", "ind", "cond", "dc", "cd", "directory", "direct", "md", "Dir", "folder", "DIR", "dist", "out", "crit", "cur", "str", "rec", "rel", "iter", "good", "init", "dev", "dr", "ds", "def", "tr", "dep", "tmp", "div", "odd", "dim", "db", "addr", "red", "file", "vol", "fin", "fd", "loc", "dl", "wd", "ir", "d"], "from": ["before", "pos", "orig", "in", "link", "old", "empty", "c", "back", "base", "stream", "on", "or", "check", "store", "ce", "client", "false", "normal", "bound", "min", "From", "reset", "by", "with", "out", "clean", "source", "only", "term", "window", "no", "st", "left", "create", "start", "set", "init", "origin", "en", "local", "inner", "style", "con", "input", "and", "com", "fun", "query", "fr", "user", "form", "initial", "vol", "so", "entry", "ent", "sent", "ra"], "to": ["pretty", "tom", "go", "that", "null", "t", "po", "about", "phi", "table", "done", "total", "lo", "o", "top", "base", "pi", "on", "or", "eto", "client", "ts", "this", "tto", "writer", "can", "news", "by", "with", "ato", "write", "out", "toc", "ta", "no", "To", "test", "output", "title", "tree", "token", "two", "too", "target", "te", "please", "into", "auto", "tg", "co", "so", "tty", "TO"], "buffer": ["bar", "memory", "paste", "row", "phrase", "binary", "parse", "buff", "sample", "table", "length", "variable", "document", "batch", "base", "character", "block", "Buffer", "device", "available", "message", "sequence", "event", "queue", "cache", "number", "temp", "window", "buf", "stroke", "page", "template", "result", "word", "char", "database", "frame", "comment", "initial", "entry", "button", "command", "stack", "attribute", "append"], "bytes_read": ["bytes5need", "bytes_q", "bytes_write", "Bytes_q", "bytes2Read", "bytes__read", "Bytes_write", "Bytes_find", "Bytes_have", "Bytes_Read", "bytes5write", "bytes_Read", "bytes2read", "bytes5read", "bytes__write", "bytes2write", "bytes2need", "bytes_need", "Bytes_need", "bytes5Read", "bytes_have", "bytes__q", "Bytes_read", "bytes__find", "bytes_find"]}}
{"id1": "14865947", "id2": "8667872", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"execute": ["process", "Exec", " proceed", " command", "exec", " executed", "run", " interpret", " manage", " executes", " executable", " parse", " evaluate", " operate", "invoke", " Run", "Action", " eval", " Exec", " execution", " executing", " dispatch", " query", " executions", "Command", " resume", "command", " Execution"], "event": ["t", "w", " command", "ee", "Event", "Ev", " environment", "se", "ed", "ce", "EE", "context", " invocation", "ae", "ev", " Event", " EVENT", "E", "de", "pe", "ex", "exc", "te", "xe", "frame", "command", " frame", " events"], "shell": ["sql", "detail", "hl", "b", "ssh", "h", "range", "base", "line", "scope", "sh", "history", "system", "cell", "message", "buffer", "help", "grid", "kernel", "l", "layout", "nl", "quit", "tab", "scroll", "sol", "ja", "window", "js", "console", "round", "widget", "sb", "hell", "cli", "theme", "tree", "pty", "search", "template", "style", "screen", "windows", "body", "root", "session", "query", "tools", "fr", "Shell", "html", "pool", "bot", "sys", "microsoft", "lock", "tool", "handle", "stack"], "view": ["iew", "row", "w", "document", "block", "version", "ui", "list", "v", "views", "image", "buffer", "report", "layout", "ve", "window", "see", "widget", "View", "vp", "tree", "VIEW", "template", "screen", "show", "query", "ou", "review", "web", "html", "tv", "vm", "cv", "display", "eye", "browser"], "rootFolder": ["RootCategory", "coverLibrary", "rootCategory", "bottomFolder", " rootDir", " rootEntry", "parentDirectory", "RootDirectory", " rootDirectory", "RootDir", "parentFolder", "coverDisk", "rootEntry", "rootDirectory", " rootCategory", "rootLibrary", " rootLibrary", "RootArea", " rootArea", "rootDir", "rootDisk", "bottomDisk", "rootArea", "parentEntry", "bottomDirectory", "coverDirectory", "bottomLibrary", "parentDir", "RootEntry", "parentArea", " rootDisk", "coverFolder", "RootFolder", "parentCategory"], "dialog": [" Dialog", "Dialj", "choDialog", "selectog", "dialDialog", "Dialog", "clig", " Dialoc", "dialogs", "dializ", "callogs", "choogs", "dialoc", "clog", "choOG", "clDialog", "dialOG", "closer", "Dialoc", "DialDialog", "callog", "selectDialog", "dloc", "dialj", "dlj", "logig", "logoser", "dlog", "dialoser", "callOG", "Dialogs", "Dializ", "selectig", "dliz", "DialOG", "logog", "selectoser", "choog", "dialig", " Dializ", "logDialog", " Dialj", "callDialog"], "password": ["pass", "paste", "secret", "words", "phrase", "picture", "expression", "Password", "table", "path", "definition", "username", "prefix", "raw", "device", "address", "message", "buffer", "p", "directory", "sword", "login", "reset", "padding", "request", "source", "user", "language", "string", "encrypted", "pattern", "word", "database", "query", "hash", "PASS", "description", "comment", "data", "response", "hello", "entry", "clear", "key", "wd", "command", "shadow", "attribute"], "md5": ["md6", "ma5", "MD3", "mb5", "md3", "MD5", "MD512", "mt4", " md512", "MD64", "m2", " md4", "m3", "mm2", "mm7", "ma2", " md7", "MD7", "md512", "md2", "MD6", "md64", "mb2", "mm6", "mb512", "ma64", "mm5", "mt2", "mb4", "MD2", "md7", "mt3", "MD4", "ma7", "md4", " md64", "m4", "mt5", " md2", " md6", "m5"], "md": ["mod", "m", "ms", " dd", "det", "pd", "mac", "df", "ld", "mk", "dh", "mc", "pm", "nd", "MD", "ct", "ind", "rm", "dig", "cd", "mn", "mt", "od", "bd", "mb", "sm", "mg", "sd", "magic", "de", "cmd", "dm", "mm", "metadata", "pt", "dr", "pdf", "nt", "hash", "hd", " Md", "red", "msg", "dd", "d"]}}
{"id1": "1122585", "id2": "21438069", "code1": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 0, "substitutes": {"copyImageFile": ["copyItemImageHeader", "cpImageFile", "cpimagefile", "copyItemImageFile", "copyItemImagePhoto", "copyImagefile", "cpImagePhoto", "cpimageHeader", "copyimagefile", "copyImagesHeader", "copyImageHeader", "cpimagePhoto", "copyImagesPhoto", "copyimageHeader", "copyItemImagefile", "copyimageFile", "copyImagesfile", "copyImagesFile", "copyImagePhoto", "cpImageHeader", "cpimageFile", "copyimagePhoto", "cpImagefile"], "urlString": ["UrlService", "uriChain", "UrlRest", "imageRest", "uriString", "linkStr", "uriRest", "urlService", "uriService", "linkRest", "UrlChain", "uristring", "urlStr", "linkString", "urlChain", "linkstring", "urlstring", "imageString", " urlRest", "imagestring", " urlChain", "UrlString", "urlRest", " urlService", "imageStr", "uriStr"], "filePath": ["givenpath", "filePATH", "resourceStream", "resourcePath", "outputPath", "resourcePATH", "fileName", "givenPath", " Filepath", " fileName", " filePATH", " FilePath", "givenPATH", "FilePATH", "outputpath", "FilePath", "filepath", "fileStream", "resourcepath", " FilePATH", "givenStream", "outputStream", " filepath", "FileName", " FileName", "Filepath", "outputPATH"], "destination": ["methodachment", "srcinator", "destository", "combinator", " destinate", "srcificate", " destacement", "commentificate", "identinate", "srcaration", "delinator", "continate", "continator", "commentination", "targetribution", "destachment", "destignment", "methodository", "identinated", "commentinate", "portinity", "combinity", "portination", "targetinated", " destository", " destinator", "Destation", "destacement", "methodination", "srcinate", "Destinity", "combation", "terminignment", " destinated", "delribution", "destension", "identination", "srcacement", "contension", "identinator", "identension", " destignment", "targetinator", "methodinator", "commentacement", "destaration", " destificate", "destinity", "portinated", " destachment", "Destination", "terminository", " destaration", "destificate", "srcignment", "targetination", " destribution", "delination", "terminination", "terminaration", "delinated", "Destinator", "termininator", "portinator", "destation", "Destension", "portation", "destribution", " destension", "contination", "combination", "Destinate", "portension", "destinator", "destinate", "destinated", "srcination", "terminachment"], "destination_file": ["destination_File", "destinator___name", "destinator___full", "destination_library", "destATION_name", "destociation_library", "destinator_ile", "destinator___file", "destation_File", "destinator_File", "destATION_entity", "destociation_dir", "destation_file", "destination___ile", "destinator_name", "destinator_table", "destination_no", "destination_full", "destATION____no", "destination____entity", "destination__ile", "destociation_file", "destation_name", "destATION____file", "destinator_port", "destATION____entity", "destinator_FILE", "destation_ile", "destinator_dir", "destATION_file", "destination____name", "destination_name", "destination___name", "destination__name", "destination__file", "destinator___ile", "destination___full", "destination_dir", "destination_table", "destination___file", "destination_FILE", "destination_port", "destination_ile", "destociation_ile", "destinator_file", "destination__full", "destination_entity", "destination____no", "destinator_full", "destination____file", "destATION____name", "destATION_no"], "inLine": ["inliner", " inString", "binString", "binLine", "Inliner", "inString", "inline", " inline", "InLine", "binliner", "InString", " inliner", "Inline", "binline"], "dest_name": ["decl_file", "img_Name", "decl_ma", "Dest_system", "dest_word", "destinalfile", "src_file", "dest__ame", " dest_ame", "dest_NAME", "destationName", "dest_san", "decl_name", " dest_filename", "dest_Name", "dest_names", " dest__NAME", " dest__name", "destinalname", "img_data", "destinalword", "dest_filename", " dest_path", " dest_term", " dest__filename", "destopdescription", "dest_data", "destationnames", "desttname", "Dest_key", "ident_entry", "img_name", "dest__filename", "dest__name", "dest__NAME", "Dest_description", "img_file", "Dest_Name", "destndescription", "dest_term", "destinationname", " dest_size", "decl_word", "desttkey", "destinalma", "desttName", "Dest_file", "destnfile", "destJNAME", "dest_description", "dest__Name", "destationname", "desttsystem", "dest_system", "destationcall", " dest_call", " dest_file", "destinationName", "dest_path", "src_name", "destDname", "destJterm", "ident_word", "Dest_name", "destinationfile", "dest_ma", "dest_call", "destDdescription", " dest_NAME", "dest_ame", "src_Name", "destJname", "src_filename", "destJsize", "dest_entry", "destopsan", "destnname", " dest__Name", "Dest_san", " dest_names", " dest_lock", "destopname", "dest_key", "dest_lock", "dest_size", "ident_name", "destDsan", " dest_Name", "dest_file", "destinationfilename"], "buffer": ["bar", "memory", "paste", "row", "feed", "phrase", "binary", "read", "buff", "b", "length", "table", "variable", "update", "document", "sample", "batch", "base", "stream", "raw", "block", "value", "Buffer", "device", "address", "message", "sequence", "password", "cache", "queue", "source", "FFER", "window", "buf", "function", "iter", "page", "result", "char", "parse", "database", "frame", "comment", "data", "channel", "text", "command", "stack", "shape", "append"], "bytes_read": ["bytes_write", "bytes_length", "bytes_count", " bytes2Read", " bytes2read", "bytes67mix", "Bytes_send", " bytes2reading", "bytes2Read", "bytes_Read", " bytes_readable", "bytes_reading", " bytes_reading", " bytes_count", " bytes_length", "bytes_mix", "Bytes_write", " bytes2readable", "bytes_readable", "bytes2readable", " bytes_Read", " bytes_write", "bytes67write", "bytes_send", "bytes67read", "bytes2read", "Bytes_mix", "bytes2length", "bytes2reading", "bytes67send", "Bytes_read"], "last_offset": ["last___pointer", "last_position", " last_name", "Last_pointer", "Last_Offset", "last_start", "last___position", "last__name", "last___Offset", " last_Offset", "last__Offset", "last__offset", "Last_offset", "last__index", "last___offset", "last_pointer", "last_index", "Last_page", " last_index", "last_flag", "Last_position", "Last_flag", "last_name", "last_Offset", " last_start", "last_page"], "offset": ["empty", "part", "address", "article", "operation", "mask", "left", "timeout", "onet", "index", "type", "attribute", "pos", "unsigned", "table", "end", "amount", "tile", "OFF", "error", "bound", "off", "padding", "order", "location", "step", "seek", "key", "et", "other", "length", "option", "component", "batch", "pad", "after", "store", "iterator", "skip", "element", "pointer", "alias", "position", "outer", "next", "addr", "ace", "offer", "shift", "slot", "offs", "alt", "inline", "prefix", "name", "reset", "Offset", "scroll", "window", "no", "set", "output", "start", "associated", "origin", "inner", "section", "original", "point", "frame", "always", "auto", "size", "field", "entry", "volume", "append"], "imageFile": ["Imagefile", "imagefile", "photoFile", "mediaFile", "imageStream", " imagePlace", "imageSourceFile", "messagefile", " imageStream", "mediaSourceFile", "pictureStream", " imagefile", "ImageSourceFile", " imageSourceFile", "mediaStream", "picturefile", "ImagePlace", "messageFile", "messageReader", "mediafile", "messageStream", "imageReader", "photoReader", "picturePlace", "ImageStream", "pictureFile", "imagePlace", " imageReader", "photoStream", "ImageFile", "photofile"], "url": ["re", "bel", "api", "ur", "http", "hl", "link", "b", "github", "get", "base", "gl", "up", "ml", "build", "address", "image", "resource", "l", "uri", "f", "sl", "r", "nl", "rl", "q", "str", "rel", "mount", "impl", "google", "ssl", "gif", "char", "Url", "web", "abs", "ul", "html", "mail", "ll", "dl", "open", "URL", "browser"], "parentdir": [" parentdict", "parendir", "Parentdir", "tmpdir", "parendiv", "childdir", " parentDir", "childfolder", "childir", "Parentdict", "parentfolder", "Parentlib", " parentlib", "ParentDir", " parentdirectory", "parentdirectory", "rootir", "parentdiv", "childdiv", "tmpdirectory", "rootdir", "rootdiv", "parenir", "childDir", "tmpdict", "parentlib", "parenfolder", "childdirectory", "parentDir", "parentdict", "parentir", "childlib", "rootfolder", "Parentdirectory", "tmpDir"]}}
{"id1": "19849797", "id2": "12172485", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", " copyStream", "transferStream", "transferfile", " cpStream", "transferFiles", " cpfile", " copyfile", "copyfile", " cpFiles", " copyFiles", "copyFiles", "copyStream", " cpFile"], "sourceFile": [" sourcePath", " sourcePage", "srcPath", "ourcePath", "srcLine", "ourceFile", "srcField", "ourceField", "ourceTable", "sourcePage", "sourceLine", "sourcefile", "srcFile", "sourcePath", "srcPage", "ourcePage", " sourceLine", "srcfile", "sourceTable", " sourceField", " sourcefile", "ourceLine", "sourceField", "srcTable", " sourceTable", "ourcefile"], "destFile": ["datPlace", "declEntity", "optFolder", "destDir", "DestFile", "destFilename", "restPlace", "optPath", "optFile", "srcFolder", "DestPath", "srcPath", " destPath", "DestFilename", "DestFiles", " destDir", "destEntity", "restFile", "optFilename", "srcFile", " destFilename", " destPlace", "declFile", "destFolder", "destPath", "optEntity", "srcFiles", "datFilename", "destFiles", "datFiles", "restFiles", "datFile", "DestDir", "srcDir", "destPlace", "srcEntity", "declDir", " destFiles", "restFilename", "declFolder", "optDir"], "source": ["src", "before", "OURCE", "send", "note", "in", "parse", "update", "sample", "local", "SOURCE", "table", "component", "back", "score", "se", "stream", "scope", "none", "parent", "check", "store", "ce", "slave", "iterator", "use", "scale", "image", "resource", "sequence", "spec", "owner", "reader", "service", "console", "ource", "standard", "from", "iter", "start", "create", "init", "origin", "copy", "search", "inner", "style", "ie", "load", "input", "missing", "char", "body", "index", "target", "proxy", "query", "show", "force", "Source", "comment", "cause", "match", "subject", "channel", "attribute", "pose", "series", "result", "shell"], "destination": ["destined", "separment", "Destinator", "decinate", "noninate", "nonination", "decination", "descation", "descinate", "verination", " destation", "restinator", "descinator", "verinated", "termininate", " destinate", " destinator", "noninator", "restinated", "destation", "Destation", " destificate", "veration", "descination", " destment", "separinated", "separation", "Destination", "decined", "separination", "destificate", "Destment", "Destinate", "noninated", "Destinated", "restinate", "destinator", " destined", "destinate", "terminined", " destinated", "termininated", "destinated", "destment", "restination", "decinated", "terminination", "verificate", "Destificate"]}}
{"id1": "13595251", "id2": "14619453", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"descargarArchivo": [" descargoMotive", " descargarActiv", " descargarArchico", " descargoMotico", " descargarMotiv", " descargoArchico", " descargoArchivo", " descargarRico", " descargarArchive", " descargarMotico", " descargarActive", " descargarRive", " descargoMotiv", " descargarActivo", " descargarRiv", " descargarArchiv", " descargarActico", " descargarMotivo", " descargarMotive", " descargoArchiv", " descargoArchive", " descargoMotivo", " descargarRivo"], "fis": ["dfos", "Fos", "ufris", "ufos", "ffris", "fiiss", "fiix", "fiios", "Fris", "fix", " fios", "fiss", " fris", "dfris", " fiss", "fios", "ffix", "dfiss", "fiis", "ffos", "ufiss", "ffis", " fix", "Fiss", "ffios", "dfis", "ufis", "Fis", "fris", "ffiss"], "fos": ["voes", "foes", " foes", "fedbos", "fOS", " fows", "infos", "fows", "woses", "flos", "fedos", "lfoses", "wos", "wows", "waos", "fedOS", "woss", "floses", "flaos", "wbos", "flbos", "lfos", "fbos", "infOs", "faos", " foss", " fOS", "voss", "lfbos", "lfaos", " fbos", "vos", "vows", "fedOs", " fOs", "foss", "infbos", "woes", "foses", "infOS", "fOs"], "inChannel": ["aichannel", "inchannel", "innChan", "innerButton", "inputChan", "inputGray", "inButton", "aiRow", "inConnection", "outRow", "initChan", "inRow", " inchannel", "inputConnection", "innRow", "initChannel", " inChan", "aiChannel", "innerChannel", "InButton", " inButton", "innerChan", "innchannel", "initConnection", "aiChan", "outchannel", "initGray", "inputChannel", "InGray", "InChan", "inGray", "outChan", "innChannel", "Inchannel", "inChan", "InConnection", "innerchannel", "InChannel"], "outChannel": ["inchannel", "OUTChan", "inButton", " outButton", "OUTStream", "OUTConsole", " outConsole", " outStream", "outStream", "OUTButton", "OUTchannel", "outButton", "outchannel", "inConsole", "OUTChannel", "outConsole", " outChan", " outchannel", "outChan", "inStream", "inChan"]}}
{"id1": "6470716", "id2": "5989666", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"st": ["tt", "rt", "ft", "t", "ld", "sty", "stri", "ste", "stream", "se", "nd", "sh", "store", "ost", "sp", "ast", "St", "rest", "stable", "sw", "std", "service", "sm", "th", "str", "sth", "www", "set", "ist", "start", "step", "sn", "ust", "sts", "stra", "sta", "inst", "est", "ST", "d"], "url": ["ret", "pl", "domain", "bel", "ur", "null", "http", "hl", "link", "il", "ch", "github", "ref", "ls", "host", "base", "gl", "build", "address", "client", "rest", "l", "uri", "f", "sl", "fl", "nl", "r", "cl", "str", "rect", "mount", "rel", "impl", "www", "location", "ssl", "string", "char", "li", "Url", "mail", "web", "ul", "el", "addr", "html", "abs", "file", "loc", "dl", "ll", "cert", "URL", "browser", "shell"], "fis": ["Fais", "fier", "tos", "Fos", " f\u00eds", "efi", "xfier", "f\u00eds", "efis", "flis", "tais", "tis", "fliss", "feier", "fiss", "ufisl", "feois", "fais", " fisl", "efiss", "Fi", "Fier", "feis", "tiss", "ufi", "uf\u00eds", " fiss", "fisl", "xfi", "flisl", "xfis", "fli", "fei", "ef\u00eds", "ufiss", "Fiss", "fois", "Fois", "xfois", "ufis", "Fis", "fi", " fais", " fi"], "zis": ["zIs", "fits", "ozisin", "ozits", " zris", "zhis", "zenis", " zisa", "zipisin", "zisin", "zipIs", "ozisa", "czIs", " zos", "zenisi", "czis", "zipits", "zisi", "zhes", "zisa", "fiss", "ozis", " zIs", "zipis", "zenris", "fisi", "ozes", " zisi", "zos", "zhIs", "czisa", "zeniss", "zris", "czits", "zipes", "zhisin", "zits", "ziss", "ozIs", "zes", " zits", " ziss", "fris", "zipos"], "entry": ["record", "info", "row", "item", "null", "zip", "office", "link", "Entry", "existent", "jo", "se", "line", "be", "e", "or", "valid", "way", "sp", "ce", "list", "cell", "name", "system", "zo", "obj", "log", "element", "enter", "member", "out", "card", "source", "de", "jar", "entity", "inter", "ie", "def", "pattern", "word", "char", "nt", "tmp", "index", "fr", "ry", "comment", "form", "match", "chain", "field", "key", "ent", "event", "result", "attribute"], "count": ["counter", "t", "err", "read", "length", "total", "c", "cont", "end", "ch", "amount", "Count", "batch", "base", "add", "acc", "found", "check", "ct", "cc", "ind", "name", "cell", "buffer", "last", "call", "depth", "number", "n", "code", "ount", "iter", "child", "ctr", "start", "page", "current", "char", "core", "nt", "num", "index", "sum", "force", "comment", "size", "match", "len", "max", "nb"], "data": ["ata", "sample", "length", "table", "done", "mu", "zero", "DATA", "batch", "raw", "block", "value", "reason", "mem", "part", "name", "message", "buffer", "image", "number", "out", "cache", "source", "n", "buf", "output", "good", "step", "dat", " DATA", "string", "all", "def", "bin", "area", "next", "json", "bytes", "size", "format", "text", "chain", "result", "d"], "fos": ["wOS", "Fops", "Fos", "fOS", "foops", "his", "Fol", "fioss", "wos", "hOS", "fooss", "woss", "fool", "Foss", "fios", "fiol", " foss", " fOS", "hoss", "wis", "hos", "fiops", "foss", "fops", "fol", "foos"], "dest": ["src", "send", "det", "Dest", "done", "gate", "cont", "gest", "nd", "desc", "trans", "mem", "parent", "way", "pas", "decl", "coord", "dc", "writer", "rest", "master", "std", "out", "dist", "temp", "source", "member", "test", "output", "cat", "exp", "dat", "origin", "bin", "result", "them", "usr", "nt", "nom", "target", "sum", "comp", "pipe", "ptr", "transfer", "des", "foreign", "loc", "comb", "est", "crit"]}}
{"id1": "21979462", "id2": "12197169", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadurltoJSON", " downloadURLoBytes", " downloadURLoJSON", " downloadURL2String", " downloadURLtoBytes", " downloadurloBytes", " downloadURLToJSON", " downloadurloText", " downloadurloString", " downloadURL2Text", " downloadURLToBytes", " downloadURLToText", " downloadurloJSON", " downloadURLtoText", " downloadURLoText", " downloadurltoText", " downloadurltoString", " downloadURLtoJSON", " downloadurltoBytes", " downloadURL2Bytes", " downloadURL2JSON", " downloadURLToString", " downloadURLoString"], "url": ["ret", "domain", "bel", "ur", "http", "link", "run", "un", "ref", "ls", "base", "gl", "address", "id", "name", "resource", "uri", "l", "log", "sl", "uu", "rect", "mount", "location", "ssl", "all", "char", "Url", "web", "mail", "ul", "file", "ll", "job", "dl", "URL", "browser"], "in": ["gin", "info", "re", "read", "thin", "oin", "mc", "up", "cin", "it", "on", "or", "check", "inf", "inn", "ind", "ill", "mn", "ins", "er", "ic", "io", "reader", "by", "inc", "ai", "out", "al", "IN", "from", "copy", "inner", "isin", "bin", "all", "con", "input", "conf", "again", "din", "sum", "ma", "i", "is", "and", "In"], "sb": ["bt", "bg", "bh", "wb", "rob", "gc", "bs", "b", "bn", "erb", "ab", "bf", "kb", "bb", "sq", "sp", "ib", "pb", "bd", "sam", "sf", "mb", "gb", "sd", "lp", "ub", "eb", "pa", "sg", "ssl", "SB", "zb", "rb", "sa", "bp", "gob", "nb", "db", "cb", "sk", "xb", "lb", "bis", "bsp", "bj"], "str": ["m", "re", "t", "err", "exec", "j", "b", "cont", "syn", "ch", "ls", "expr", "Str", "gr", "block", "part", "del", "sp", "list", "p", "obj", "s", "l", "print", "req", "sl", "r", "cur", "source", "n", "st", "bl", "txt", "set", "iter", "cat", "dat", "sts", "string", "comm", "pt", "dr", "def", "char", "tr", "br", "div", "next", "comp", "i", "fr", "comment", "msg", "vol", "text", "chain", "bc", "STR", "arr"]}}
{"id1": "22868825", "id2": "9526031", "code1": "    String sendRequest(String[] getVars, String[] postVars, Object[] fileVars, boolean getSessionKey) throws IOException {\n        String uri = wikiBaseURI;\n        if (getVars != null) for (int i = 0; i + 1 < getVars.length; i += 2) uri += (i == 0 ? '?' : '&') + urlEncode(getVars[i]) + '=' + urlEncode(getVars[i + 1]);\n        URL url = new URL(uri);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        if (!getSessionKey) {\n            String cookie = \"\";\n            for (String key : cookies.keySet()) cookie += (cookie.length() == 0 ? \"\" : \"; \") + key + \"=\" + cookies.get(key);\n            conn.setRequestProperty(\"Cookie\", cookie);\n        }\n        if (fileVars != null) {\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; fileVars != null && i + 2 < fileVars.length; i += 3) {\n                ps.print(\"--\" + boundary + \"\\r\\n\");\n                postFile(ps, conn, (String) fileVars[i], (String) fileVars[i + 1], (byte[]) fileVars[i + 2]);\n            }\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print(\"--\" + boundary + \"\\r\\n\" + \"Content-Disposition: \" + \"form-data; name=\\\"\" + postVars[i] + \"\\\"\\r\\n\\r\\n\" + postVars[i + 1] + \"\\r\\n\");\n            ps.println(\"--\" + boundary + \"--\");\n            ps.close();\n        } else if (postVars != null) {\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print((i == 0 ? \"\" : \"&\") + urlEncode(postVars[i]) + \"=\" + urlEncode(postVars[i + 1]));\n            ps.close();\n        }\n        int httpCode = conn.getResponseCode();\n        if (httpCode != 200) throw new IOException(\"HTTP code: \" + httpCode);\n        if (getSessionKey) getCookies(conn.getHeaderFields().get(\"Set-Cookie\"));\n        InputStream in = conn.getInputStream();\n        response = \"\";\n        byte[] buffer = new byte[1 << 16];\n        for (; ; ) {\n            int len = in.read(buffer);\n            if (len < 0) break;\n            response += new String(buffer, 0, len);\n        }\n        in.close();\n        return response;\n    }\n", "code2": "    public boolean register(Object o) {\n        String passwordAsText;\n        if (o == null) throw new IllegalArgumentException(\"object cannot be null\");\n        if (!(o instanceof User)) {\n            throw new IllegalArgumentException(\"passed argument is not an instance of the User class\");\n        }\n        User newUser = (User) o;\n        passwordAsText = newUser.getPassword();\n        newUser.setPassword(passwordEncoder.encodePassword(passwordAsText, null));\n        newUser.setRegDate(new Date());\n        logger.debug(\"Setting default Authority {} to new user!\", Authority.DEFAULT_NAME);\n        newUser.getAuthorities().add(super.find(Authority.class, 1));\n        logger.debug(\"Creating hash from email address! using Base64\");\n        newUser.setHash(new String(Base64.encodeBase64(newUser.getEmail().getBytes())));\n        logger.debug(\"Creating phpBB forum User, by calling URL: {}\", forumUrl);\n        try {\n            StringBuilder urlString = new StringBuilder(forumUrl);\n            urlString.append(\"phpBB.php?action=register\").append(\"&login=\").append(newUser.getLogin()).append(\"&password=\").append(passwordAsText).append(\"&email=\").append(newUser.getEmail());\n            sqlInjectionPreventer(urlString.toString());\n            logger.debug(\"Connecting to URL: {}\", urlString.toString());\n            URL url = new URL(urlString.toString());\n            URLConnection urlCon = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlCon.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) newUser.setForumID(Integer.valueOf(inputLine));\n            in.close();\n        } catch (IOException io) {\n            logger.error(\"Connecting failed! Msg: {}\", io.getMessage());\n            throw new RuntimeException(\"Couldn't conntect to phpBB\");\n        } catch (NumberFormatException e) {\n            logger.error(\"phpBB user generation failed! Msg: {}\", e.getMessage());\n            throw new RuntimeException(\"phpBB user generation failed!\");\n        }\n        entityManager.persist(newUser);\n        try {\n            sendConfirmationEmail(newUser);\n            return true;\n        } catch (MailException ex) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["submitPost", "formrequest", "submitResponse", " sendResponse", "formPost", "formRequest", "submitRequest", "sendResponse", "sendrequest", " sendPost", "submitrequest", "formResponse", "sendPost", " sendrequest"], "getVars": ["getVariARS", "execVys", "execVariars", "getvals", "getVsars", "getVaolder", "gotVarials", "getHARS", "getVolder", "evalVars", "gettingVsals", "evalVCarp", "getVaars", "execVariARS", "getVsARS", "getVCart", "gotVARS", "getvars", "getHrs", "gotVals", "getPars", "getAttolder", "getVCars", "getvARS", "getVaart", "getHys", "getVarts", "gotVers", "getVariarts", "getPals", "getVsrs", "getPers", "getVarials", "getChar", "gettingVars", "fileVar", "getVARS", "gettingVals", "getChrs", "execVariarts", "getvar", "getVariars", "gettingVsars", "getChars", "fileVARS", "evalVCart", "fileHrs", "fileVrs", "gotVars", "getVariys", "gettingVrs", "getPARS", "execVARS", "getVarp", "getVys", "evalVolder", "execVarts", "getVColder", "getVart", "execVars", "gettingVsrs", "getVals", "getVsals", "getvrs", "gettingVARS", "getVaarp", "gettingVsARS", "fileHar", "getVCarp", "execVariys", "fileHars", "evalVarp", "evalVart", "fileHARS", "getAttars", "gotVariars", "getVers", "getHarts", "getHars", "getChARS", "getHar", "evalVCars", "getVsers", "gotVariers", "evalVColder", "getAttart", "getVariers", "getVar", "gotVariARS", "getVrs", "getAttarp"], "postVars": [" postvys", "postVors", "getVsars", "postCals", " postVables", "postNavols", "postVsables", "putVsARS", "postEvats", "putInvants", "getVaults", " postvables", "putVsals", "postVarials", "postVsants", "postVaols", "postJrs", "postInvars", "postCars", "postJys", "postVariors", "postEvARS", "postVsars", "postVsys", "postVsats", "putVals", "putVants", "postVARS", "postVats", "postInvors", "postVables", "putVsars", " postvars", "postInvals", "getVsaults", "postvars", "postNavaults", "putInvors", "postVrs", "putVars", "getVals", "postNavals", "getVsals", "postEvals", "postCARS", "postInvants", "postvrs", "postNavars", " postVys", " postvrs", "getVols", "postCats", "postVariars", "putVors", "putInvals", "putVats", "postVaaults", "postEvars", "postVaults", "postVariants", "postVsaults", "postVaars", "postvys", "postVsals", "postVols", "postVaals", "postVals", "postVsARS", "postvables", "postVsrs", "postVants", "putVsats", "postVsors", "putInvars", "getVsols", "postVsols", "postJables", " postVrs", "putVARS", "postVys", "postJars"], "fileVars": ["fileVariVar", "fileVolder", "filevParts", " fileVsarp", "fileJars", "fileBaults", "fileVsARS", "fileVolVar", "fileVariarts", " fileVals", "postVariarts", "fileAVARS", "fileBoters", "filevars", "filePars", "filevrs", " filePolder", " filePars", "fileVariavers", " fileVaults", "postVsar", "fileVSels", "fileDevarp", "fileBars", "fileVsolder", " fileVsar", "filevPars", "fileVsavers", "fileParp", "fileDevar", "fileAVaults", "fileInvrs", "fileVariARS", "filePARS", "postVsars", "fileVar", "postVavers", "fileVariarp", " fileVolder", "fileVARS", "filePolder", "postVARS", "fileVarts", "ruleVVar", "ruleVolVar", " fileVoters", "fileVrs", "fileJARS", "postVariARS", "fileDevars", "fileInvar", "fileMar", "ruleVals", "fileInvals", " filePARS", "fileVsrs", " fileVarp", "ruleVars", "fileAVars", "postVrs", "fileVals", "fileVsals", "postVarts", "fileVSARS", " fileVsals", "fileDevals", "fileVolarp", "fileVavers", "ruleVolarp", "fileVSals", "postVariars", "fileMars", "fileVariars", " filePals", "fileVaults", "fileVsar", "fileJolder", " fileVsars", "fileMals", "ruleVolars", "filePVar", "filevPavers", "filevar", "fileVVar", "fileBARS", "ruleVarp", "fileVsarts", "fileJals", "fileVSars", "fileMarp", "postVsals", "postVals", "fileVsarp", "postVariavers", "fileAVoters", "fileVels", "postVsrs", " fileVARS", "fileVsels", "filevPARS", "ruleVolals", "fileVarp", "fileVoters", "fileVsars", " fileVar", "filevals", "fileVolals", "filePals", "fileInvars", "fileVolars", "fileVarials", " fileVels", "postVar"], "getSessionKey": [" getsessionKeys", "getSessionkey", "getsessionName", "getsessionKey", "gettingESSIONName", "gettingESSIONId", "gettingESSIONkey", " getsessionId", "getESSIONId", "gettingSessionkey", " getSessionkey", "gettingSessionId", "getsessionId", "getSessionName", " getSessionKeys", "gettingSessionName", "gettingESSIONKey", "gettingSessionKey", " getsessionkey", "getESSIONkey", "getSessionId", "getsessionKeys", " getsessionKey", "getESSIONKey", " getSessionId", "getsessionkey", "getESSIONName", "getSessionKeys"], "uri": ["domain", "ur", "api", "http", "URI", "link", "phi", "gi", "href", "qi", "us", "path", "du", "range", "base", "prefix", "pi", "general", "wiki", "home", "ui", "address", "hi", "connection", "resource", "directory", "unit", "direction", "folder", "source", "iri", "term", "nu", "location", "origin", "title", "ri", "doi", "target", "query", "html", "description", "file", "subject", "uni", "ugi", "filename", "browser", "dir"], "i": ["info", "m", "t", "err", "c", "us", "I", "oi", "e", "y", "menu", "f", "io", "x", "me", "init", "index", "u", "gi", "j", "o", "pi", "it", "di", "ind", "zi", "ai", "\u0438", "um", "q", "ta", "bi", "li", "loop", "status", "go", "im", "phi", "ii", "lo", "qi", "ti", "batch", "on", "ini", "hi", "list", "v", "multi", "iy", "ree", "iu", "ip", "cli", "ij", "ki", "xi", "is", "ei", "ji", "ci", "mi", "h", "ui", "id", "p", "ic", "l", "g", "set", "exp", "si", "ri", "slice", "sim", "ma", "ix", "ami", "ims", "chain"], "url": ["bel", "api", "ur", "t", "http", "hl", "link", "b", "ld", "https", "un", "il", "ls", "gl", "au", "l", "log", "sl", "r", "nl", "str", "org", "www", "sb", "arl", "att", "ssl", "char", "atl", "Url", "abs", "ul", "el", "ll", "loc", "dl", "job", "open", "URL", "browser", "net"], "conn": ["nc", "cn", "http", "exec", "err", "link", "j", "resp", "close", "pkg", "https", "ch", "tn", "ws", "ls", "secure", "ct", "socket", "pas", "cp", "ns", "sp", "pg", "client", "connection", "p", "cs", "wp", "obj", "req", "call", "cur", "Conn", "enc", "org", "js", "ait", "res", "cmd", "txt", "act", "auth", "init", "ctx", "en", "ssl", "comm", "cfg", "typ", "forge", "con", "jp", "conf", "nt", "conv", "cb", "connect", "canon", "addr", "ann", "fail", "reg", "sys", "loc", "dt", "open", "cert", "fin"], "cookie": ["pretty", "browser", "cn", "cy", "tc", "note", "binary", "gc", "custom", "sample", "c", "stay", "kee", "reason", "none", "value", "cel", "ce", "cell", "client", "label", "menu", "bo", "password", "cache", "temp", "country", "cue", "term", "magic", "cert", "window", "code", "ookie", "no", "cmd", "good", "jar", "csv", "timeout", "copy", "ie", "qq", "cu", "token", "ck", "word", "cook", "KEY", "tmp", "json", "query", "cm", "cb", "comment", "header", "co", "coin", "hello", "ca", "wine", "chain"], "key": ["hop", "row", "item", "cy", "ox", "phrase", "j", "mac", "table", "val", "my", "choice", "property", "prefix", "pair", "ice", "value", "ce", "id", "ow", "y", "label", "cell", "k", "by", "member", "x", "str", "cert", "me", "code", "pe", "set", "child", "ex", "keys", "ie", "KEY", "char", "ke", "te", "tag", "box", "file", "type", "wk", "Key", "chain", "col", "et", "any"], "ps": ["ws", "ts", "proc", "posts", "rep", "ms", "dial", "pos", "eps", "po", "bs", "pp", "fp", "ss", "ups", "its", "pas", "cs", "ress", "checks", "out", "ats", "pers", "sts", "ds", "ys", "ops", "hs", "pres", "gets", "mp", "pt", "pps", "aps", "pd", "ns", "cp", "gs", "ks", "ports", "fps", "pl", "ros", "_", "vs", "Ps", "PS", "ls", "css", "ips", "sp", "p", "amps", "ins", "js", "fs", "als", "rs", "pse", "pr", "plays", "stats"], "name": ["NAME", " filename", "Name", "alt", "val", "component", "range", "add", "value", "part", "address", "id", "n", "extra", "title", "class", "position", "names", "description", "form", "field", "ident", "type", "label", "filename", "format", "dir"]}}
{"id1": "22057083", "id2": "771802", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"Connect": ["Close", "Connector", " Dial", " Connection", "Interface", "Ping", "Dial", "Init", "Connection", "Bind", "Error", "New", "Setup", "Check", "Auth", "Conn", "Log", "Sync", " Open", "Construct", "Login", " Init", "Start", "Create", "connect", "Client", "Open", " Close"], "client": ["api", "http", "handler", "c", "util", "version", "port", "bo", "context", "control", "log", "one", "plugin", "node", "user", "product", "lib", "proxy", "co", "channel", "cgi", "chain", "net", "row", "table", "cell", "to", "conn", "service", "session", "config", "form", "key", "open", "phone", "command", "component", "batch", "secure", "store", "cp", "list", "connection", "buffer", "obj", "pb", "call", "controller", "cmd", "cli", "google", "pattern", "server", "mail", "force", "connect", "response", "remote", "collection", "module", "null", "close", "ch", "url", "name", "resource", "writer", "wrapper", "patch", "reader", "cache", "cl", "window", "local", "create", "pc", "ssl", "con", "core", "man", "manager", "entry", "type", "Client", "handle", "browser", "builder"], "reply": ["ret", "answer", "echo", "link", "resp", "close", "rc", "repl", "mi", "prefix", "line", "success", "error", "address", "message", "ply", "report", "print", "flag", "write", "code", "no", "user", "state", "notice", "vote", "Reply", "next", "query", "bill", "comment", "match", "py", "response", "job", "entry", "translation", "type", "nb", "status", "command", "result", "shell"]}}
{"id1": "6009527", "id2": "2324868", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishShowAttention", "doFinishShowDetachment", "doFinishLoadAssached", "doFinishLoadAttachached", "doFinishShowAttached", "doFinishLoadAssention", "doFinishLoadAssachment", "doFinishLoadAttention", "doFinishLoadDetention", "doFinishLoadAttachention", "doFinishLoadAttached", "doFinishShowAttachment", "doFinishLoadDetachment", "doFinishShowDetached", "doFinishLoadDetached", "doFinishLoadAttachachment", "doFinishShowDetention"], "attachmentId": ["ATTociationKey", "attagramKey", "attachmentid", "attentionById", "ATTachmentId", "attociationid", "detachedId", "attgmentId", "attociationId", "attutationById", "ATTachmentById", "attociationName", "atachmentName", "atachmentId", "atachmentID", "attentionId", "detachedKey", "atachmentById", "attagramById", "attgmentid", "attgmentKey", "atutationID", "attociationKey", "attachedId", "detachmentKey", "attachmentName", "atutationById", "attutationId", "attociationID", "ATTociationid", "attutationID", "attachmentID", "attachmentKey", "atutationId", "atutationName", "attagramId", "detachmentid", "detachmentId", "attutationName", "attentionName", "ATTachmentKey", "attagramid", "attachmentById", "attachedKey", "attociationById", "detachedid", "attentionID", "ATTachmentid", "ATTociationId", "attachedid", "ATTociationById", "attachedById"], "attachment": ["assacher", "attachached", "attachaching", "attachacher", "attociation", " attacher", "attachachment", "assaching", "attention", "ATTention", "attachention", "detacher", "attached", "attment", "attacher", "contached", "addached", "detached", "contment", "ATTachment", "ATTached", "addaching", "addociation", "attachociation", "detachment", "ATTacher", "assention", "addachment", "contachment", "contacher", "attaching", "association", "assachment", " attached", " attment", "assached", "detment"], "attachmentUri": ["attachmentOri", "attachmentTuri", "attentionUri", "attachableOURI", "attachmentUnuri", "attentionUtpi", "attachmentOuri", "attentionUtRI", "attachmentTpi", "attachmentUuri", "attachableOri", "attachmentOURI", "attachableUURI", "attentionUpi", "attentionURI", "attachableUpi", "attentionUrid", "attachmentURI", "attachableUuri", "attachmentUtpi", "attachmentUURI", "attachmentUpi", "attachableUri", "attentionUtri", "attachmentUnpi", "attachmentupi", "attachmenturi", "attachmenturid", "attachmentUnURI", "attachmentTURI", "attachmentUtri", "attachableOpi", "attachmentOpi", "attachmentUnri", "attachmentuRI", "attachmentTri", "attachmentUtRI", "attachmentUrid", "attachableOuri", "attentionUtrid", "attachmentUtrid"], "contentUri": ["ContentUris", "contentURI", "contentUtrid", "ContentUuri", "contentUres", "ContentUsri", "contentuRI", "ContentUsrid", "contentUrric", "contentSiri", "contentUtric", "contentUsri", "contentURri", "contentUtRI", "ContentUri", "resourceUri", "contentUtri", "contentUtiri", "contenturi", "contentUnuri", "contentUrid", "contentUtres", "contentSuri", "contentUsrid", "ContentUsuri", "contentUric", "contentuuri", "contentUnris", "contentUris", "messageUtric", "messageUtri", "resourceUres", "ContentUrid", "contentUuri", "resourceUuri", "messageUri", "messageUric", "contentURres", "contentUsuri", "resourceURRI", "contentUruri", "contentSri", "resourceURuri", "contentUsris", "contentUriri", "contentURuri", "contentUtris", "messageUtiri", "resourceURres", "contentSric", "contentUturi", "contentUnri", "contentures", "contentUiri", "ContentUsris", "contentURRI", "contentUrri", "contentUnrid", "resourceURri", "messageUuri", "resourceURI", "messageUiri", "messageUturi"], "file": ["File", "ile", "zip", "FILE", "link", "disk", "table", "picture", "upload", "document", "il", "fp", "path", "rule", "h", "base", "line", "files", "media", "name", "message", "buffer", "port", "resource", "image", "to", "f", "content", "sf", "play", "folder", "source", "user", "output", "local", "create", "from", "init", "entity", "tree", "page", "save", "template", "work", "le", "db", "pool", "header", "channel", "format", "type", "ca", "filename", "result", "dir", "angle"], "in": ["gin", "sql", " IN", "read", " din", "mi", "up", "cin", "it", "on", "ini", "inf", "inn", "ind", "ain", "ins", "ic", "rin", "l", "io", "inc", "play", "al", "source", "IN", "from", "en", "bin", "isin", "inner", "con", "input", "din", "body", "i", "inside", "is", "ar", "and", "In"], "out": ["os", "null", "w", "b", "o", "aos", "it", "check", "client", "v", "writer", "can", "obj", "to", "outs", "flush", "print", "io", "stable", "write", "put", "ao", "n", "g", "res", "output", "ex", "Out", "all", "con", "screen", "nt", "conv", "outer", "ou", "oss", "i", "sys", "OU", "auto", "OUT", "co", "serv", "net"], "intent": ["Activity", "asso", "skill", "phrase", "activate", "statement", "prom", "condition", "displayText", "verbal", "device", "venture", "ment", "activity", "activation", "context", "animate", "ic", "spirit", "service", "q", "term", "action", "window", "express", "wordpress", "method", "alert", "widget", "act", "agent", "entity", "init", "continue", "voice", "man", "concept", "query", "inv", "json", "communication", "automatic", " Intent", "ence", "xml", "inst", "initial", "ant", "entry", "ident", "ink", "text", "ent", "event", "complete", "intention"]}}
{"id1": "14773782", "id2": "12766394", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" decodeJPPGRasters", " decodeJPEGRasters", " decodeJPEGGrasters", " decodeJPEGGraster", " decodeJPEGPotation", " decodeJPEGRotation", " decodeJPPGRaster", " decodeJPEGRater", " decodeJPPGrater", " decodeJPEGrater", " decodeJPPGRater", " decodeJPEGGrater", " decodeJPPGrasters", " decodeJPPGrotation", " decodeJPEGrotation", " decodeJPEGrasters", " decodeJPEGPater", " decodeJPEGPaster", " decodeJPEGPasters", " decodeJPEGRaster", " decodeJPPGRotation", " decodeJPPGraster", " decodeJPEGraster", " decodeJPEGGrotation"], "IOException": ["ConnectionException", "IOProblem", "ConnectionFailure", "IOFailure", " IOFailure", " IOProblem", "URIException", "URIFailure", "ConnectionProblem", "URIProblem"], "start": ["before", "t", "send", "read", "end", "offset", "get", "started", "top", "base", "it", "wind", "trans", "starting", "birth", "rest", "reset", "print", "seed", "begin", " started", "st", "set", "from", "Start", "step", "init", "create", "art", "wait", "first", "delay", "insert", "initial", "time", "open"], "i": ["info", "m", "iq", "go", "ci", "u", "counter", "im", "in", "phi", "j", "b", "gi", "gu", "qi", "c", "my", "I", "us", "ii", "mi", "ti", "batch", "pi", "it", "di", "ini", "ui", "ind", "ski", "id", "name", "client", "p", "sequence", "multi", "s", "ic", "uu", "f", "ai", "out", "q", "request", "x", "g", "me", "bi", "ex", "exp", "init", "si", "ie", "ij", "ki", "conv", "index", "sim", "li", "ix", "xi", "is", "key", "major"], "url": ["domain", "row", "lr", "ur", "http", "link", "path", "ref", "ls", "host", "gl", "id", "resource", "uri", "l", "log", "r", "nl", "q", "res", "mount", "rel", "hub", "location", "string", "pattern", "gif", "char", "Url", "web", "mail", "ul", "el", "xml", "external", "dl", "job", "ll", "key", "URL", "browser"], "istream": ["iftriver", "istank", "isream", "astream", "stabel", "stStream", "itram", "stream", "aststream", "astram", "istriver", "ISTram", "astroll", "itream", "ISTub", "astabel", "isub", "istub", "istram", "iftream", "ISTstream", "istsabel", "iftank", "ststream", "itstream", "itroll", "iftub", "istsream", "ISTank", "istroll", "isriver", "istsstream", "istabel", "iststream", "ISTroll", "ISTriver", "ISTream", "istsStream", "istStream", "astStream", "isank"], "dec": [" Dec", "DEC", "exec", "det", "De", "ec", "c", "dra", "coll", "dem", "desc", " enc", "valid", "cor", "decl", "dc", "dig", "deg", "bd", "enc", "dis", "agg", "rec", "de", "disc", "dev", "cam", "oct", "ko", "def", "der", "dep", "bec", "div", " DEC", "draw", "Dec", "des", "da", "ra", "del"], "raster": ["braster", "brastered", "rast", "rastered", " rastered", "rmap", "remraphic", " rasters", "mast", "Rasters", "Raster", "rreement", " rmap", "matter", "remasters", "remmap", "Rreement", "Rmap", "ratter", " rraphic", "master", "Rraphic", "replaster", "replatter", "replasters", "brast", " rreement", "Ratter", "rraphic", "rasters", " ratter", "bratter", "replreement", "mastered", "remaster", " rast"], "width": ["w", "length", "fw", "path", "issa", "axy", "displayText", "success", "weight", "wid", "tall", "change", "ose", "layout", "strength", "sw", "write", "padding", "term", "window", "Width", "left", "widget", "step", "ength", "position", "body", "cale", "dim", "cut", "frame", "wa", "orth", "size", "len", "idth", "const", "text", "shape", "resolution"], "height": ["inches", "confidence", "length", "rank", "capacity", "density", "h", "grow", "alpha", "power", "count", "history", "buffer", "dimension", "depth", "padding", "th", "kw", "window", "hang", "cision", "acity", "stroke", "style", "holes", "gravity", "frame", "angle", "size", "ty", "volume", "radius", "Height", "shape", "resolution"], "stop": ["pop", "Stop", "null", "counter", " Stop", "update", "gc", "close", "end", "period", "termination", "ab", "disable", "success", "enable", "it", "wake", "delete", "rest", "post", "obj", "skip", "op", "quit", "commit", "pause", "term", "no", "st", "set", "step", "timeout", "result", "ops", "root", "next", "wait", "trip", "cut", "status", "max", "est", "fin", "jump"]}}
{"id1": "11377441", "id2": "2398448", "code1": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"resolvePlugins": ["resolveLogins", "resolvePluginIns", "resolvePins", "resolveLogIn", "resolvePlugensions", "resolvePlugIns", "resolveLogIns", "resolvingPluginins", "resolvingPlugIns", "resolvePs", "resolvingPlugensions", "resolveLogensions", "resolvingPlugIn", "resolvePluginensions", "resolvePluginIn", "resolvePlugs", "resolvingPluginIns", "resolvePlugIn", "resolvingPluginensions", "resolvingPlugins", "resolvePensions", "resolvingPluginIn", "resolvePIns", "resolvingPlugs", "resolvePIn", "resolvePluginins"], "cacheDir": ["matchAl", "coverSet", " cachedir", "matchSet", " CacheDr", "matchDir", "cacheDirectory", "coverDir", "useDir", "CacheDirectory", " CacheDir", "usedir", "coverAl", "cachedir", " CacheSet", " cacheUrl", "CacheUrl", "Cachedir", "coverDr", "useDirectory", "cacheAl", "cacheUrl", " cacheDirectory", "CacheDir", "useUrl", "cacheDr", "cacheSet", "matchDr", " CacheAl"], "pluginsFile": ["pluginFile", " pluginsClass", " pluginsPath", "cssFine", " pluginsFine", "reportsClass", "pluginfile", " pluginsFiles", "cssLe", "cssFile", "pluginsString", "reportsString", "insfile", "pluginsfile", "pinsPath", "pinsFile", " pluginsfile", "modulesFiles", "pluginsFiles", "bitsLe", "pluginsPath", "pinsFiles", "insFile", "pluginPath", "insPath", " pluginsString", "pluginsFILE", "bitsFile", " pluginsLe", "modulesFile", " pluginsFILE", "bitsfile", "pinsClass", "pluginsFine", "cssfile", "pluginsLe", "pluginsClass", "pinsString", "reportsFILE", "modulesPath", "pinsfile", "pinsFILE", "bitsFine", "reportsFile", "modulesFILE"], "pluginURL": ["pluginsURI", "plugURL", " pluginCL", "plugUR", "pluginUrl", "plugURI", "PluginURL", "pluginsCL", "pluginURI", "prefixREL", "PluginUR", "pluginUR", "pluginCL", " pluginUrl", "prefixUrl", "PluginUrl", "prefixURL", " pluginURI", " pluginUR", "pluginsURL", "pluginREL", "prefixUR", "PluginREL", "plugCL", " pluginREL", "pluginsUR"], "is": ["sis", "ms", "isl", "in", "bs", "ii", "us", "ls", "ios", "lis", "has", "it", "se", "isi", "its", "tis", "isc", "es", "ini", "iss", "ists", "ins", "s", "ir", "fs", "iu", "mis", "rys", "iris", "nis", "ip", "isin", "ics", "ri", "\u00eds", "ris", "iso", "xs", "i", "sys", "IS", "Is", "ires", "ais", "bis", "isa", "are"], "os": ["Os", "mot", "ms", "ox", "pos", "bs", "oses", "us", "ot", "o", "css", "ios", "osi", "ost", "ui", "es", "oS", "oes", "socket", "ose", "er", "s", "ol", "zo", "mos", "io", "out", "res", "los", "ols", "oos", "si", "bos", " Os", "iso", "oss", "i", "sys", "osa", "oa", "as", "des", "OS", "cos", "dos", "ps", "et", "obs"]}}
{"id1": "1769771", "id2": "17729554", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " CopyFiles", " copyStream", " copyLine", " CopyStream", "CopyLine", " copyFiles", "CopyFiles", "copyLine", " CopyLine", "copyFiles", "copyStream", "CopyStream", "CopyFile"], "in": ["gin", "b", "old", "up", "cin", "on", "ini", "inf", "inn", "ind", "ins", "l", "rin", "ic", "io", "r", "inc", "source", " input", "IN", "from", "mm", "init", "en", "isin", "bin", "inner", "input", "din", "i", "el", "is", "In"], "out": ["os", "t", "err", "w", "update", "po", "b", "gt", "c", "ot", "o", "up", "it", "v", "help", "p", "s", "to", "outs", "log", "l", "io", "op", "n", "res", "output", "ex", "Out", "nt", "ou", "at", "file", "OUT", "msg", "serv", "net"], "inChannel": ["inchannel", "inButton", "inCommand", "inConnection", "intChan", "InCommand", "cinChannel", " inCase", "dinConnection", " inCategory", "insideScope", "sinCase", "ainChannel", " inchannel", "sinChannel", "cinCommand", "sinRoom", "innCase", "intChannel", "inCategory", " inChan", "intchannel", "sinButton", " inConnection", "innButton", "outConnection", "insideClient", "intCommand", "sinClient", "inScope", " inButton", "sinCommand", "ainCategory", " inCommand", "dinchannel", "inCase", "dinChan", "outchannel", "inClient", " inRoom", "inRoom", "insideCategory", "innClient", "ainClient", "cinRoom", "InChan", "outChan", "dinChannel", " inScope", "innChannel", "Inchannel", "ainScope", "inChan", "insideChannel", " inClient", "InChannel"], "outChannel": ["outCh", "inchannel", "outputManager", "outGate", "parentGate", "outMany", "outSection", "aosMember", "cnManager", "aosChannel", "neChannel", "blockChannel", "inMember", "cnChannel", "neChan", "outputCh", " outCh", "neMember", "inSection", "outputChan", "aosChan", " outManager", "outManager", "aosSection", "inCh", "parentChan", "neSection", "parentChannel", " outMany", "outchannel", "parentMany", "cnChan", "blockGate", "outputChannel", "blockMany", "outputchannel", "blockChan", " outChan", " outchannel", "outChan", "inChan", " outGate", "outMember"]}}
{"id1": "21821404", "id2": "324679", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["getDebugUrl", "downloadWebPages", "getwebPages", "getLivePage", "downloadwebUrl", "downloadWebUrl", "getwebPage", "getDebugPage", "downloadWebpage", "downloadwebpage", "getLivePages", "getDebugpage", "getwebpage", "getWebUrl", "getWebPages", "downloadwebPage", "getDebugPages", "downloadWebPage", "getwebUrl", "getWebpage", "downloadwebPages", "getLivepage", "getLiveUrl"], "urlObj": ["logInfo", "uriobj", " urlOb", "UrlObject", " urlObject", " urlobj", "httpOb", "urlInd", "uriObj", "UrlOnce", "urlOb", "logOb", " urlInfo", "httpObject", "Urlobj", "urlOnce", "uriOnce", "UrlInd", "httpObj", "UrlCtrl", "uriCtrl", "urlobj", " urlInd", "httpInfo", "urlObject", "urlCtrl", "UrlObj", "uriInd", "uriObject", " urlOnce", " urlCtrl", "urlInfo", "logObj", "logObject"], "content": ["read", "empty", "cont", "document", "Content", "equ", "object", "raw", "value", "reason", "ce", "address", "articles", "message", "buffer", "sequence", "context", "article", "wrapper", "layout", "temp", "write", "comments", "source", "clean", "str", "code", "output", "txt", "complete", "page", "load", "string", "template", "title", "section", "continue", "core", "current", "body", "ext", "cm", "html", "comment", "ontent", "data", "header", "view", "response", "format", "display", "text", "command", "result"], "is": ["sis", "err", "c", "se", "isi", "e", "iss", "isf", "by", "rys", "ris", "as", "isa", "net", "was", "ms", "sit", "isl", "where", "lis", "its", "isc", "his", "ists", "out", "ois", "nis", "iso", "web", "Is", "job", "and", "ir", "re", "other", "in", "ot", "or", "sels", "es", "when", "not", "res", "mis", "iris", "isin", "string", "more", "i", "ais", "ians", "os", "were", "a", "ios", "has", "be", "ism", "tis", "id", "name", "s", "being", "does", "ese", "fs", "ire", "ist", "rs", "internet", "ri", "\u00eds", "sys", "IS", "plays", "bis", "chain", "are"], "reader": ["editor", "row", "per", "read", "ocker", "in", "handler", "rar", "anger", "ner", "dra", "iper", "stream", "roller", "ser", "iterator", "buffer", "writer", "er", "runner", "io", "r", "ipper", "ro", "iter", "Reader", "ader", "inner", "dr", "ri", "reading", "file", "parser", "loader", "liner", "rr"], "line": ["record", "LINE", "row", "detail", "column", "email", "link", "sample", "lo", "eline", "range", "inline", "piece", "e", "block", "part", "cell", "message", "Line", "sequence", "l", "print", "nl", "lined", "ln", "stroke", "lin", "string", "page", "word", "section", "char", "zone", "le", "point", "el", "frame", "comment", "online", "file", "lane", "entry", "ine", "label", "text", "liner"]}}
{"id1": "364438", "id2": "8754809", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conVERT", "compverts", "CONVERT", "unversion", "confer", "Confer", "Converted", "unverts", "consverting", "Conversion", "CONversion", "converting", "compvert", "unfer", "ConVERT", "consversion", "converted", "unprocess", "converts", "CONvert", "Convert", "CONverting", "CONfer", "CONverted", "Converts", "unverted", "compprocess", "unvert", "conprocess", "compversion", "Converting", "consVERT", "consvert", "conversion", "Conprocess"], "src": ["sit", "RC", "sc", "ur", "upload", "orig", "hl", "http", "ebin", "SOURCE", "attr", "rc", "cont", "pkg", "href", "path", "url", "host", "stream", "func", "SourceFile", "its", "cc", "ser", "sq", "rest", "s", "ins", "uri", "req", "buster", "cur", "dist", "source", "str", "scan", "rel", "ource", "st", "from", "rs", "start", "txt", "rx", "iv", "input", "img", "usr", "sin", "sr", "config", "sys", "addr", "Source", "scene", "inst", "file", "loc", "ipl", "filename"], "dest": ["gin", " orig", " dst", "orig", "disk", "Dest", "table", "tif", " Destination", "port", "rest", "write", "temp", "dist", "source", "test", " Dest", "txt", "dat", "img", " destinations", "target", "mat", "foreign", " destination", "est", "result", "dir"], "in": ["m", "sql", "ad", "b", "up", "stream", "cin", "inf", "inn", "ind", "ins", "l", "rin", "io", "reader", "r", "source", "res", "st", "from", "IN", "en", "isin", "inner", "bin", "input", "din", "i", "el", "as", "file", "is", "ar", "serv", "In", "d"], "p": ["rep", "pl", "m", "t", "per", "parse", "pd", "j", "b", "pp", "c", "pkg", "fp", "h", "pm", "pi", "it", "part", "pg", "cp", "sp", "php", "er", "ping", "pb", "l", "post", "f", "r", "op", "pro", "g", "lp", "pre", "pers", "pe", "vp", "dp", "pc", "pa", "pt", "P", "jp", "prot", "ph", "i", "at", "py", "parser", "tp", "wp", "ap", "ps", "d"], "ds": ["df", "aws", "ws", "nas", "ts", "yes", "mys", "edes", "sd", "cks", " DS", "posts", "hd", "des", "iffs", "tags", "dd", "dos", "d", "lists", "eds", "ils", "eps", "bs", "els", "ss", " d", "points", "tes", "its", "di", "cs", "workers", "ats", "sets", "ods", "scripts", "sts", "ys", "hs", " os", "ras", "dl", "qs", "obs", " des", " dd", "gd", "pd", "dh", "docs", "ns", "gs", "dp", "ks", "ports", "terms", "uds", "db", "tests", "dt", "tp", "ps", "ags", "os", "ads", "vs", "ls", "Ds", "amps", "s", "outs", "js", "loads", "rs", "dates", " ads", "drivers", "xs", "dds", "DS", "ands"], "format": ["pretty", "module", "t", "parse", "Format", "table", "mode", "path", "fm", "top", "pi", "it", "version", "MAT", "ct", "settings", "filter", "name", "id", "unit", "spec", "mt", "l", "f", "layout", "feature", " Format", "source", "ats", "cf", "output", "fc", "sche", "feat", "act", "set", "title", "pattern", "template", "style", "lat", "tag", "mat", "at", "form", "file", "size", "policy", "type", "status", "shape"], "hasPixelData": ["HasPixelData", " hasPixeldata", "haspixelData", "haspixeldata", "hasixeldata", "hasFramedata", "Haspixeldata", "HasPixeldata", "haspixelDATA", "HaspixelData", " hasPixelDATA", "HasPixelDATA", "hasixelData", "hasPixeldata", "hasPixelDATA", "HaspixelDATA", "hasFrameDATA", "hasixelDATA", "hasFrameData"], "inflate": ["informat", "inflat", "Inflate", "inflicate", "inFlicate", "invalidate", "inflocate", "inFlocate", "incelocate", "inFlate", "Inflated", " invalidATE", "invalidicate", "infolate", "incelate", "inFLocate", "Informated", "Informocate", "informated", "infolated", "Inflocate", "informocate", " inflocate", "incelATE", " inflATE", "inFLated", "incelicate", "Informat", "Informate", " invalidocate", "inFLate", " invalidicate", "infolocate", "invalidATE", "Inflat", "informate", " invalidate", "inflATE", "invalidocate", "inFLat", "infolat", "inflated", "inFlATE", " inflicate"], "pxlen": ["xplen", "packfun", "phplen", "pixellength", "packln", "pexls", "cplen", "xylen", "packdec", "pxln", "pixellen", "pexlength", "mxlength", "tmplen", "packlen", "pxden", "xpln", "tmpln", "packlength", "pexfun", "pxls", "mxln", "pxfun", "pxlength", "cpden", "pxlin", "phplength", "phpln", "pixells", "xpden", "cplength", "pxdec", "packls", "mmlin", "xylin", "mxdec", "xyln", "tmplength", "pexden", "pexln", "cpln", "tmplin", "xylength", "phpdec", "pixelfun", "mmlength", "pexlen", "xplength", "mmln", "mmlen", "mxlen"], "out": ["pretty", "err", "up", "aos", "prefix", "gr", "store", "list", "name", "client", "writer", "obj", "group", "outs", "log", "print", "io", "temp", "conn", "crit", "res", "ln", "user", "cmd", "output", "ex", "gov", "init", "Out", "inter", "cfg", "screen", "outer", "sum", "ou", "inv", "sys", "msg", "OUT", "dir", "net"]}}
{"id1": "9805906", "id2": "3806532", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"dump": ["info", " describe", "send", "zip", "read", "update", "link", "diff", " println", "store", " show", "flush", "print", "write", "debug", "init", "copy", "stat", "export", "save", "show", "display", " dumps", "println", " debug", "download", " dumped", "load"], "source": ["info", "src", "sql", "sample", "SOURCE", "se", "scope", "parent", "check", "store", "sequence", "resource", "image", "spec", "service", "select", "ource", "site", "from", "local", "start", "iter", "init", "origin", "copy", "search", "ie", "style", "template", "input", "java", "config", "sys", "Source", "form", "script", "file", "view", "remote", "ink", "text", "shell"], "target": ["project", "that", "null", "t", "goal", "link", "mac", "table", "gt", "tif", "host", "top", "base", "compatible", "it", "delete", "arg", "to", "Target", "term", "test", "bolt", "output", "local", "replace", "copy", "dest", "pattern", "template", "style", "current", "proxy", "next", "arget", "file", "match"], "is": ["sis", "ms", "isl", "im", "in", "ii", "ls", "ios", "lis", "has", "it", "its", "isi", "tis", "isc", "es", "iss", "ib", "ists", "ins", "s", "ic", "mos", "isf", "bits", "ai", "ois", "ir", "ist", "iris", "nis", "ip", "act", "init", "isin", "si", "ics", "ri", "ris", "ys", "iso", "xs", "oss", "i", "abs", "sys", "Is", "IS", "ais", "ar", "ims", "bis", "isa", "are"], "os": ["Os", "ants", "ox", "ros", "pos", "bs", "oses", "ot", "o", "ls", "css", "ios", "aos", "ss", "osi", "or", "ost", "oS", "es", "ns", "oes", "uts", "ts", "cs", "ose", "ows", "s", "outs", "mos", "io", "js", "fs", "los", "ols", "oos", "ds", "bos", "oss", "sys", "nos", "OS", "cos", "dos", "ps", "obs"], "done": ["failed", "later", "finished", "progress", "ished", "Done", "du", "pleted", "started", "desc", "shown", "di", "valid", "found", " Done", "enabled", "flag", "seen", "created", "only", "needed", "did", "de", "die", "given", "disabled", "set", "expected", "dirty", "gone", "led", "continue", "checked", "ded", "des", "filled", "made", " continued", "loaded", "complete", "d"]}}
{"id1": "11475527", "id2": "5414088", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addTextFromurl", "addDataFormurl", "addDataToURL", "addDataFormURL", "addDataTourl", "addDatafromURL", "addTextFormURL", "addDatafromUrl", "addDataFormUrl", "addDataFromUrl", "addDatafromLocation", "addDataToLocation", "addTextFromURL", "addDataFromLocation", "addDataFormLocation", "addTextFromUrl", "addTextFormUrl", "addDataFromurl", "addTextFromLocation", "addTextFormLocation", "addTextFormurl", "addDataToUrl", "addDatafromurl"], "theurl": ["TheUrl", "Theuri", "heloader", "heuri", "teURL", " theloader", " theuri", "thloader", "Theurl", " theURL", "theloader", "teuri", "heURL", "heUrl", "teurl", "thefile", "thfile", "heurl", "theUrl", " theUrl", " thefile", "thUrl", "hefile", "teUrl", "theURL", "TheURL", "theuri", "thurl"], "line": ["record", "LINE", "row", "email", "link", "sample", "rule", "ner", "eline", "inline", "block", "ice", "valid", "day", "cell", "name", "message", "Line", "sequence", "l", "print", "source", "lined", "code", "node", "ln", "stroke", " inline", "lin", "page", "string", "char", "point", "le", "zone", "frame", "online", "header", "status", "lane", "comment", "entry", "ine", "text", "chain", "liner"], "in": ["gin", "t", "include", "read", "lo", "old", "oin", "mc", "o", "mi", "cin", "it", "or", "inf", "inn", "id", "ain", "ins", "l", "rin", "f", "ic", "reader", "r", "pin", "inc", "conn", "out", "ai", "al", "source", "proc", "n", "st", "IN", "from", "win", "init", "en", "isin", "bin", "inner", "con", "input", "again", "din", "phys", "ma", "i", "is", "ac", "serv", "open", "In"], "data": ["join", "info", "feed", "ad", "text", "ata", "read", "DATA", "a", "stream", "raw", "iterator", "client", "this", "buffer", "writer", "io", "reader", "content", "dec", "cache", "out", "window", "user", "dat", "def", "input", "body", "next", "pipe", "query", "size", "file", "bus", "da", "result", "d"], "e": ["m", "re", "t", "err", "ee", "b", "ec", "c", "ge", "o", "h", "a", "se", "be", "or", "ed", "es", "oe", "ce", "error", "y", "p", "ze", "er", "ae", "v", "element", "f", "ve", "ele", "r", "x", "E", "n", "g", "me", "pe", "de", "eeee", "ex", "ie", "le", "te", "i", "eu", "ne", "entry", "ine", "ue", "event", "d"]}}
{"id1": "10759917", "id2": "16820041", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 0, "substitutes": {"delete": ["drop", "update", "link", "dump", "get", "destroy", "Delete", "reset", "write", "put", "select", "de", "set", "create", "replace", "touch", "move", "save", "query", "remove", "lete", "insert", "execute", "clear", "download", "command", "load", "del"], "name": ["m", "NAME", "item", "null", "w", "link", "Name", "old", "c", "path", "o", "key", "url", "base", "prefix", "e", "nm", "part", "parent", "value", "common", "version", "id", "message", "error", "lon", "resource", "connection", "l", "term", "str", "source", "n", "code", "me", "local", "create", "string", "search", "title", "alias", "word", "ma", "names", "ame", "comment", "description", "data", "size", "file", "format", "family", "type", "label", "filename", "chain", "time"], "CannotDeleteSystemLinkException": ["CannotDeleteSystemTypeException", "CannotDeleteSystemDataStatus", "CannotDeleteSysLinksException", "CannotDeleteSystemLinkStatus", "CannotDeleteSystemDataEx", "CannotDeleteSystemLinksWarning", "CannotDeleteSystemLinksEx", "CannotDeleteSystemPageStatus", "CannotDeleteSysLinksEx", "CannotDeleteSystemPageError", "CannotDeleteSystemDataError", "CannotDeleteSystemLinksStatus", "CannotDeleteSysLinkError", "CannotDeleteSystemLinkWarning", "CannotDeleteSysLinkStatus", "CannotDeleteSysLinksStatus", "CannotDeleteSystemPageException", "CannotDeleteSysLinksError", "CannotDeleteSystemTypeError", "CannotDeleteSystemTypeWarning", "CannotDeleteSystemLinkError", "CannotDeleteSysLinkException", "CannotDeleteSystemLinkEx", "CannotDeleteSysLinkEx", "CannotDeleteSystemDataException", "CannotDeleteSystemPageEx", "CannotDeleteSystemLinksError", "CannotDeleteSystemLinksException", "CannotDeleteSystemTypeEx"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeIsFindEx", "ClassLinkTypeIsFind ", "ClassLinkTypeIsFoundException", "ClassLinkTypeNotFound ", "ClassLinkTypeIsFoundOver", "ClassLinkTypeNotUsedException", "ClassLinkTypeNotFindException", "ClassLinkTypeNotUsed ", "ClassLinkTypeNotFoundEx", "ClassLinkTypeIsFound ", "ClassLinkTypeIsFoundEx", "ClassLinkTypeNotFindEx", "ClassLinkTypeNotFindOver", "ClassLinkTypeNotFoundOver", "ClassLinkTypeNotUsedOver", "ClassLinkTypeNotUsedEx", "ClassLinkTypeIsFindOver", "ClassLinkTypeIsFindException", "ClassLinkTypeNotFind "], "conn": ["cn", "oc", "t", "err", "ec", "gate", "c", "pkg", "resp", "coll", "ws", "socket", "yes", "port", "bo", "cur", "Conn", "org", "die", "ctx", "en", "conf", "sec", "canon", "co", "nc", "rt", "gc", "pas", "client", "yn", "enc", "act", "cb", "pool", "loc", "open", "pt", "dn", "ang", "pen", "mc", "on", "cc", "ct", "pg", "cp", "ce", "ns", "connection", "obj", "iw", "rel", "cmd", "ens", "comm", "db", "connect", "addr", "ca", "exec", "close", "https", "ch", "mt", "req", "win", "con", "jp", "nt", "conv", "priv", "sys", "cert", "col"], "stmt": ["startMT", "strr", "stattm", "statMT", "constmb", "strpr", "STtm", "stmp", "snMT", " sttm", "Stmm", "statm", " stmb", "STmt", "startmm", "strmt", " str", "startmt", " stpr", "Str", " stm", "consttm", "STMT", "STmm", "strMT", "strm", "stm", "sttx", "statmt", " stMT", "Sttm", "str", "StMT", "Stmp", "Stpt", "Stm", "sttm", "Stpr", "constm", "snmt", "startmp", "snm", "stMT", " stmm", "strmp", "stmb", "STtx", "stpr", " stpt", "stmm", " sttx", "Stmt", "Stmb", "STmb", "STm", "snpt", "stpt", "strmm", "constmt", "Sttx"], "prepTable": ["PrepTier", "prepTier", " prepTier", "Preptable", "PrepTable", "ppTab", "prepTree", "summaryTier", "ppTable", "summarytable", "pptable", " prepTree", "summaryTable", " preptable", "preptable", " prepTab", "PrepTree", "prepTab", "ppTree", "PrepTab"], "objectLinkTable": ["objLinksTable", "objLinktable", " objectLinktable", "objectTypetable", "objectTypeTab", " objectLinkTab", "objectLinkList", "objectLinktable", "objectTypeType", "objectTypeTable", "objLinksList", "objectlinkType", "objectLinkType", "objLinkstable", "objectlinkTab", "objectlinktable", " objectLinkType", "objectLinksController", "objectLinksTable", "objectLinkstable", "objectLinkController", "objLinkList", "objectlinkTable", "objLinkController", "objectLinkTab", "objectLinksList", "objLinkTable", "objLinksController"], "sql": ["join", "scl", "fn", "expression", "url", "expr", "ips", "sq", "sp", "ns", "quote", "s", "spec", "sl", "nl", "spr", "sf", "q", "fields", "str", "sd", "select", "js", "sv", "rel", "csv", "string", "template", "SQL", "query", "json", "inv", "html", "description", "xml", "form", "dl", "format", "qs", "result", "ql"]}}
{"id1": "12306305", "id2": "3806532", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"doCopyFile": [" doCopfile", "doCopFiles", " doCopFile", "doMovefile", " doCopyFiles", "doCopyByte", "doMoveFile", "docopyFile", "doMoveByte", "doCopyFiles", "doCopfile", "docopyfile", " doCopByte", "doCopyfile", " doCopFiles", "doCopByte", "doMoveFiles", " doCopyByte", " doCopyfile", "docopyByte", "doCopFile", "docopyFiles"], "srcFile": ["srcFilename", " srcPath", "srcFILE", "rcile", "destPage", "sourceFile", "rbFilename", "rcFile", "destFilename", "destfile", "locPage", " srcFilename", "rcDir", "sourceDir", " srcDir", "locModel", "locFile", "selFile", "destModel", "selfile", "srcPath", "destile", "srcLine", "rcFilename", " srcFILE", " srcModel", "rbPath", "destLine", "srcModel", "rcfile", "rbFile", "rcLine", "sourceLine", "sourcefile", "selPage", "rcPath", "srcPage", "rcFILE", "srcfile", "selFilename", " srcPage", "srcDir", " srcLine", " srcfile", " srcile", "locFilename", "rcPage", "rbFILE", "srcile"], "destFile": ["memFiles", "memfile", "distDir", "Destfile", "srcFilename", "srcFILE", "destPage", "destDir", "DestFile", "origFile", "destfile", "litfile", "DestFILE", " destDirectory", "destFilename", "critGrid", "destMail", "foreignFILE", "critfile", "memFILE", "litMail", "distFilename", " destPage", "foreignFile", "DestFilename", "destOnly", "DestFiles", "descGrid", "declFILE", "DestMail", "origOnly", " destDir", "DestGrid", "critDir", " destfile", "DestDirectory", "declfile", "distfile", "destFILE", "foreignOnly", "destDirectory", "srcDirectory", "DestPage", "origDir", "srcPage", "declFile", " destFilename", "descDir", " destFILE", "memFile", "destGrid", " destGrid", "srcfile", "srcFiles", "critFile", "srcGrid", "litFILE", "origFILE", "descPage", "destFiles", "srcDir", "DestDir", "distFile", "srcOnly", " destFiles", "foreignDir", "declMail", "descFile", "litFile"], "preserveFileDate": ["preserveFileDuration", "preserveLineDate", "preservefileTime", "preserveFilenameTime", "preservesfileDuration", "preserveLotDay", "presoreFileDate", "preserveFilenameDay", "preservefileDay", "preserveLineSize", "presoreLotdate", "preservesFileTime", "preserveFilesdate", "presoreFiledate", "preservesFileDate", "presoreLotDay", "preserveFileDay", "preserveFilenameDate", "preserveLotSize", "preserveLinedate", "preserveFilesSize", "preserveLotDate", "presoreFileSize", "preservesfileTime", "preservefileDate", "presoreFileDay", "preservesfileDate", "preserveFilenameDuration", "preserveSetDuration", "preserveSetTime", "preservesFileDuration", "preserveLotdate", "presoreLotSize", "preserveFilesDay", "preserveSetDate", "preserveFileTime", "preserveFileSize", "preserveFilesDate", "preservesfileDay", "presoreLotDate", "preserveFiledate", "preserveSetDay", "preservesFileDay", "preservefileDuration", "preserveLineDay"], "input": ["info", "before", "feed", "upload", "http", "in", "read", "exec", "parse", "audio", "archive", "get", "up", "stream", "alpha", "add", "raw", "it", "history", "internal", "client", "buffer", "image", "context", " Input", "focus", "io", "reader", "op", "hidden", "request", "Input", "source", "q", "local", "ip", "from", "init", "start", "iter", "inner", "pattern", "partial", "current", "installed", "index", "json", "xml", "auto", "initial", "entry", "open", "command", "accept"], "output": ["module", "exit", "o", "open", "Output", "stream", "success", "block", "four", "icon", "client", "connection", "buffer", "image", "generated", "port", "message", "writer", "group", "print", "hidden", "write", "put", "out", "console", "page", "section", "network", "outer", "body", "next", "ou", "web", "cut", "latest", "auto", "file", "ilo", "data", "response", "channel", "format", "remote", "display", "text", "result", "net"]}}
{"id1": "14001795", "id2": "17974661", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyoverWarFile", "copyoverWarFiles", "copyOverTarFilename", "copyOverWarFiles", "copyoverwarFiles", "copyOverwarFiles", "copyOverwarfile", "copyOverTarfile", "copyOverTarFile", "copyOverTarFiles", "copyoverwarFilename", "copyoverWarFilename", "copyOverwarFile", "copyOverWarFilename", "copyOverWarfile", "copyoverWarfile", "copyoverwarfile", "copyoverwarFile", "copyOverwarFilename"], "dir": ["dial", "re", "zip", "disk", "df", "old", "ld", "mk", "path", "coll", "url", " d", "add", "desc", "di", "del", "parent", "ind", " Dir", "name", "cd", "directory", "md", "direct", "log", "Dir", "doc", "folder", "out", "DIR", "dist", "cur", "ir", "window", "res", "rel", "dm", "iter", "local", "good", "dat", "dr", "def", "dep", " directory", "tmp", "div", "dim", "db", "addr", "form", "file", "fd", "fin", "dl", "loc", "vol", "wd", "dd", "d"], "ff": [" cf", "ffe", "ft", "fact", " ref", "df", "buff", " eff", "ld", "fp", "F", "aft", " af", "UFF", "bf", "alf", "xff", "wind", "cond", "filter", "aff", " df", " def", "uf", "mt", "fl", "FF", "off", "sf", "fx", "cf", "fc", " aft", "ck", "lf", "ef", " FF", "eff", "cb", "uff", "iff", "af", "file", "fd", "tf", "fg", "xf"], "files": ["faces", "styles", "frames", "bees", "features", "jobs", "forms", "Files", "resources", "rows", "ls", "facts", "balls", "issues", "ails", "values", "flows", "items", "uploads", "lines", "fields", "members", "les", "fs", "assets", "objects", "plates", "keys", "ports", "leases", "iles", "ories", "names", "parts", "tests", "file", "models", "days", "mas", "images", "ions"], "f": ["m", "ft", "t", "w", "fab", "b", "c", "fw", "fp", "F", "h", "a", "bf", "alf", "fm", "e", "fe", "v", "p", "uf", "l", "k", "fl", "rf", "sf", "n", "fs", "g", "cf", "fc", "exp", "def", "lf", "fac", "i", "elf", "file", "tf", "fd", "xf", "fa", "col", "d"], "newFile": ["NewPage", "uniquefile", "uniquePage", "newFiles", "NEWfile", " newfile", "NewNode", " newPlace", "newNode", "secureFile", "newKey", "anotherFile", " newFiles", "oldFilename", "oldfile", "newsKey", "newFilename", "newsfile", " newFilename", "anotherfile", "NewFilename", "uniqueFile", "NewFiles", "Newfile", "anotherFiles", "NewFile", "newsFile", "anotherPlace", "newPage", "oldFile", "secureKey", "securefile", "NEWPage", "NewPlace", "newPlace", "NewKey", "NEWFile", "newfile", "uniqueNode", "NEWNode"], "fi": ["ci", "phi", "ii", "fp", "mi", "ti", "ifa", "bf", "pi", "isi", "di", "ini", "fe", "zi", "flo", "uf", "io", "Fi", "sf", "iu", "cf", "ni", "bi", "afi", "si", "ife", "lf", "ki", "ri", "li", "i", "FI", "fr", "fd", "fa", "fin"], "fo": ["po", "hea", "tif", "sty", "jo", "ti", "o", "opa", "oe", "eto", "hi", "ow", "tto", "zo", "flo", "bo", "tk", "ato", "sf", "uo", "ott", "cf", "eno", "ko", "ki", "fam", "ph", "oooo", "vo", "te", "zz", "wo", "wt", "tf", "co", "mo", "xf", "oo", "FO", "ho"]}}
{"id1": "5744493", "id2": "23672408", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" synchronizedFullCopy", " synchronizedFileCopy", " doStreamCopy", " doPageDownload", " synchronizedFileDownload", " synchronizedFileMove", " doFullMove", " synchronizedFullMove", " doPageCopy", " synchronizedFullDownload", " doFileCopy", " doStreamDownload", " doPageMove", " doFullDownload", " doFileDownload", " doFullCopy", " doStreamMove", " doFileMove"], "in": ["gin", "b", "old", "o", "up", "cin", "it", "or", "inf", "inn", "ind", "ain", "ins", "l", "rin", "ic", "r", "inc", "source", "n", " input", "IN", "from", "ex", "mm", "init", "en", "isin", "ck", "input", "din", "i", "el", "as", "file", "ac", "In"], "out": ["os", "null", "t", "w", "po", "gt", "c", "ot", "ch", "o", "up", "it", "check", "v", "help", "p", "s", "to", "outs", "log", "l", "io", "op", "write", "n", "res", "output", "ex", "Out", "nt", "ou", "at", "as", "file", "OUT", "serv", "ne", "net"], "inChannel": ["outCh", "inchannel", "INChannel", "vinCommand", "inButton", "vinCase", "inCommand", "INStream", "cinChannel", "InCh", " inCase", "dinConnection", " inCategory", " inchannel", "cinCommand", "isinConnection", "inCategory", " inChan", " inConnection", "innButton", "INChan", "innerChannel", "innerStream", "cinCategory", "vinConnection", "cinButton", "innerChan", "inCh", "INchannel", "dinCase", "vinChannel", " inCommand", "outStream", "inCase", " inButton", "dinButton", "outchannel", "dinChan", "isinChannel", " inCh", "isinChan", "innCommand", "isinButton", "InChan", "dinChannel", "outChan", "dinCommand", "inChan", "inStream", "Inchannel", "inConnection", "innChannel", "innCategory", "innerchannel", "InChannel"], "outChannel": ["outerChan", "aosDisk", "outCh", "onConnection", "outSection", "aosMachine", "cosChannel", "OutCh", "OutChan", "OutStream", "aosChannel", "onChan", "outerChannel", " outConnection", "upMachine", "outerStream", "newChan", " outRoom", "outputCh", " outCh", "newConnection", "upChannel", "outputChan", "outerRoom", "outConnection", " outStream", "upSection", "aosSection", "outStream", "outRoom", "outDisk", "newchannel", "upDisk", "onchannel", "outchannel", "newChannel", "cosSection", "outMachine", "outputStream", "inRoom", "outputChannel", "onChannel", "cosDisk", " outChan", " outchannel", "outChan", "cosMachine", "inStream", "inChan", "OutChannel"], "maxCount": [" maxLength", "MAXFlag", "minCast", "minLength", "MaxCast", "maxCast", "MAXCount", "minSize", "minFlag", " maxCast", "MAXLength", " maxSize", "minCount", "MaxCount", "maxSize", "maxFlag", "MaxLength", " maxFlag", "maxLength", "MaxSize"], "size": ["equal", "m", "ms", "send", "shift", "read", "sample", "length", "empty", "close", "total", "capacity", "range", "speed", "score", "SIZE", "space", "count", "scale", "name", "message", "ze", "ose", "readable", "write", "Size", "height", "scroll", "sd", "set", "start", "export", "si", "keys", "ize", "small", "position", "seek", "notice", "area", "body", "show", "sum", "fee", "south", "bytes", "gets", "is", "len", "resolution", "sent", "duration", "shape", "any"], "pos": ["pass", "pl", "os", "row", "slot", "po", "length", "pid", "resp", "zero", "offset", "o", "pi", "it", "part", "pg", "sp", "coord", "p", "port", "spec", "to", "limit", "l", "doc", "off", "pointer", "pro", "x", "n", "seq", "rel", "no", "Position", "left", "exp", "pc", "start", "page", "def", "position", "index", "point", "pr", "i", "loc", "POS", "len", "Pos", "cos", "pose", "ps", "pt"]}}
{"id1": "20426057", "id2": "345515", "code1": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createKeyStore": ["createCertStorage", "createDefaultstore", "createCertChain", " createKeystore", "createDefaultChain", "createCertstore", "createKeystore", " createTrustStore", "createTrustChain", "createTruststore", "createDefaultStore", " createKeyChain", " createTrustStorage", " createKeyStorage", "createCertStore", "createTrustStorage", "createKeyStorage", "createKeyChain", " createTruststore", "createDefaultStorage", " createTrustChain", "createTrustStore"], "url": ["domain", "lr", "ur", "u", "upload", "email", "http", "link", "https", "ld", "un", "path", "github", "ref", "ls", "util", "host", "gl", "add", "au", "store", "build", "address", "name", "list", "id", "context", "image", "rest", "uri", "l", "log", "sl", "uu", "nl", "q", "str", "org", "rect", "mount", "user", " URL", "location", "ssl", "string", "pattern", "server", "char", "Url", "web", "mail", "ul", "el", "addr", "abs", "xml", "html", "file", "dl", "loc", "ll", "job", "cert", "ud", "URL"], "password": ["pass", "project", "secret", "words", "email", "phrase", "expression", "Password", "crypt", "security", "property", "username", "prefix", "power", "device", "store", "address", "message", "directory", "sword", "provided", "reset", "remember", "padding", "wordpress", "user", "stroke", "language", "another", "pattern", "token", "word", " Password", "database", "hash", "PASS", "description", "comment", "command", "hello", "key", "auth", "shadow", "attribute"], "keystore": ["keybase", " keybase", "kstore", "ekchain", "keychain", "ekStore", " keytool", " keycache", "linkstore", "Keybase", "kbase", "Keystorage", "keycase", "kcache", "linkchain", "keyserver", "keyStore", "linkstorage", "keystorage", " keyore", "ekstorage", "linkserver", "Keyore", "printstorage", "KeyStore", " keycase", " keychain", "Keycache", "keytool", "ktool", " keyStore", "linkcase", "printchain", "keycache", "linkore", " keystorage", "Keychain", " keyserver", "Keystore", "keyore", "kStore", "printstore", "linkStore", "ekstore", "Keytool", "Keyserver", "printcase"]}}
{"id1": "16388708", "id2": "2668634", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsfile", "decodeFileToString", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFileFileFile", "decodeStringToString", "decodeStringToFiles", "decodeString2file", "decodeFileTofile", "decodeFile2String", "decodeStringToFile", "decodeString2String", "decodeString2File", "decodeFileFileFiles", "decodeFileAsFiles", "decodeFile2File", "decodeFile2Files", "decodeString2Files", "decodeFileFileString", "decodeFileToFiles", "decodeFile2file", "decodeFileAsString"], "infile": ["isinfolder", "isinfile", "inputname", "Inbase", "outFile", "outfolder", "InFile", "outfilename", "inname", "isinname", "fromFile", "outname", "Infile", "infolder", "frombase", "inFile", "inputFile", "inbase", "fromfilename", "infilename", "inputfile", "isinFile", "fromfile", "Infilename", "inputfolder", "outbase"], "outfile": [" outname", "inFILE", "Outfilename", "Outfile", "outFile", "otname", "outfilename", "otfile", "inname", " outFile", "outname", "todir", "outdir", "otFILE", "tofilename", "inFile", "outFILE", "indir", "tofile", "Outdir", "infilename", "toFile", "OutFile", " outFILE", "otFile"], "in": ["gin", "info", "re", "t", "im", "per", "nin", " din", "oin", "get", "up", "cin", "it", "on", "or", "ini", "inf", "inn", "ind", "id", "ain", "ins", "rin", "by", "pin", "inc", "conn", "amin", "al", "source", "iter", "IN", "from", "init", "en", "inner", "bin", "isin", "con", "input", "din", "i", "inside", "form", "is", "ar", "In"], "out": ["cn", "os", "null", "t", "fn", "b", "gt", "opt", "end", "ion", "ot", "o", "aos", "it", "on", "writer", "can", "to", "outs", "print", "flush", "io", "write", "n", "g", "res", "output", "ex", "Out", "en", "inner", "con", "nt", "outer", "ou", "oss", "at", "sys", "OU", "auto", "file", "OUT", "co", "ne", "net"], "buffer": ["bar", "memory", "info", "paste", "row", "note", "phrase", "binary", "buff", "sample", "table", "column", "variable", "total", "document", "batch", "base", "pad", "character", "block", "mem", "Buffer", "available", "history", "message", "sequence", "black", "library", "print", "password", "attribute", "cache", "number", "temp", "padding", "window", "buf", "template", "frame", "comment", "header", "initial", "view", "button", "display", "bone", "command", "stack", "shape", "append"], "read": ["before", "each", "text", "send", "shift", "Read", "length", "allow", "run", "give", "close", "end", "ok", "range", "get", "stream", "add", "raw", "count", "check", "ind", "need", "ready", "READ", "skip", "req", "print", "reader", "readable", "write", "n", "select", "iter", "find", "start", "set", "push", " Read", "input", "seek", "index", "query", "wait", "through", "first", "i", "connect", "size", "reading", "len", "open", "reads", "load", "hold"], "success": ["ccess", "photo", "successful", "Success", "done", "setup", "danger", " succeed", "ok", "submit", "ratulations", " succ", "condition", "scope", "value", "valid", "release", " failure", "error", "cess", "snap", "growth", "summary", "primary", "commit", "positive", "surv", "crit", "same", "good", "safe", "complete", "continue", "second", "sufficient", " succeeds", "democracy", "town", "unity", "please", " successes", "first", "support", "city", "exist", " successful", "ceed", "fail", "response", "successfully", "status", "result", " okay", "accept"]}}
{"id1": "7981642", "id2": "14053882", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"update": ["UPDATE", "mod", "updated", "feed", "upload", "read", "sample", "username", "register", "up", "add", "check", "delete", "store", "Update", "change", "post", "login", "write", "put", "apply", "alter", "test", "set", "create", "replace", "pack", "touch", "init", "move", "save", "reply", "input", "place", "printf", "edit", "config", "remove", "escape", "insert", "data", "text", "handle", "commit", "auth", "load", "append"], "mail": ["dn", "pl", "m", "domain", "dial", "im", "hold", "zip", "link", "http", "old", "alt", "pkg", "url", "host", "username", "Email", "mem", "gmail", "address", "name", "eth", "message", "label", "port", "md", "grid", "mill", "id", "log", "mun", "print", "mobile", "mails", "enter", "Mail", "n", "mount", "ln", "test", "cmd", "dm", "iter", "mm", "ip", "local", "imp", "virtual", "server", "com", "el", "addr", "file", "msg", "net", "dl", "tp", "cert", "dir", "del"], "email": ["dn", "cn", "domain", "m", "echo", "sql", "detail", "note", "zip", "link", "sample", "il", "object", "url", "Email", "username", "host", "line", "nm", "e", "cdn", "ns", "address", "name", "message", "image", "password", "uri", "log", "nl", "enter", "number", "atom", "example", "n", "date", "ln", "test", "IL", "ip", "entity", "template", "virtual", "server", "html", "el", "addr", "xml", "external", "file", "ilo", "phone", "label", "text", "et", "del"], "pwd": ["Pfx", "psfx", "pws", "presswd", " pword", "dpword", "pgen", "dpwd", "pw", " pw", " pws", "Pgen", "pow", "Pwd", "pressw", "Pword", " pfx", "dpgen", " pow", "ppriv", "pword", "psw", "psow", " ppriv", " pgen", "Pw", "pfx", "pressws", "Ppriv", "presspriv", "dpw", "Pws", "pswd", "Pow"], "firstname": ["lastName", " firstnames", "lastNAME", " firstNAME", " firstparent", "firstrun", "smallrun", "Firstnames", "lastrun", "Firstname", "smallName", "firstName", "firstnames", "smallNAME", "FirstName", "firstparent", "FirstNAME", "lastnames", " firstrun", "Firstparent", "smallname", "lastparent", "firstNAME", " firstName"], "lastname": ["lastName", "fullname", " lastName", "longame", "givennum", "lastame", " lastnum", " lastame", "firstName", "firsttype", "longname", "fullName", "lasttype", "lastnum", "givenName", " lasttype", "firstame", "giventype", "longnum", "longName", "givenname", "firstnum", "fullame"], "connection": ["nc", "creator", "link", "handler", "c", "document", "ion", "engine", "management", "cone", "condition", "system", "Connection", "client", "context", "directory", "resource", "event", "conn", "connected", "application", "onet", "con", "network", "database", "session", "relation", "communication", "city", "pool", "connect", "description", "response", "entry", "command", "collection"], "attrs": ["attrd", "attras", "attps", "actrs", "attributes", "atRs", "adras", "attsras", "atras", "attsributes", "avrs", "addrs", "atters", "attsrics", " attributes", "attrics", "latters", "attRs", " attRs", "atds", " attrd", "attsries", "adrs", "atrys", " attps", "latributes", "atrics", "atries", "atns", "attds", "actrys", "addRs", "attns", " attries", "attachributes", "attrys", "attters", "avras", "adns", "atps", "attries", " attras", "attachras", " attns", "atributes", "avrics", "actributes", " attds", "atrd", "avributes", "addributes", "attachrs", "atrs", "addrd", "attsps", "addras", "attsrs", "actters", "attsds", "adributes", "latrys", "latrs", "attachRs"], "sha": ["ha", "go", "shared", "mac", "ssh", "total", "h", "a", "alpha", "has", "tar", "func", "mem", "sh", "ksh", "sq", "hi", "acl", "md", "git", "sam", "mb", "sm", "ka", "shi", "no", "ya", "sche", "pa", "HA", "sa", "lambda", "iso", "SHA", "sum", "ma", "comp", "wa", "auto", " SHA", "asha", "ppa", "ca", "da", "cos", "shell"], "digest": ["digse", "dge", "redest", "Digested", "Digse", "dests", "mdEST", "digested", "digge", "mdhest", "mdest", "divhest", "digests", "redests", "Digests", "mdests", "DigEST", "redge", "dested", "divse", "Dighest", "dest", "divEST", " digested", "dighest", "redested", "mdse", " digEST", "Digest", "Digge", "digEST", "mdested", " digests", "divest"], "hash": ["shadow", "hex", "ha", "bh", "each", "dump", "mac", "total", "h", "has", "base", "score", "ash", "check", "sh", "flash", "filter", "message", "dig", "md", "password", "print", "rh", "trust", "cache", "proof", "ashes", "ASH", "search", "input", "Hash", "sum", "tag", "html", "format", "key", "handle", "auth", "result"], "ctx": ["nc", "tz", "tc", "cmp", "sc", "gc", "pkg", "rc", "wx", "mk", "xc", "mc", "lc", " cx", "ct", "pg", "sq", "cp", "dc", "context", "obj", "tk", "conn", "Conn", "x", "kw", "np", "cf", "txt", "ctr", "cu", "ck", "jp", "con", "nt", "conv", "tmp", "kl", "gm", "Context", "cm", "cb", "cv", "co", "tx", "loc", "ca", " context", "bc", "ctrl"], "newName": [" newname", "currentNAME", " newKey", " newNAME", "oldHome", " newHome", "newname", "newKey", "finalNames", "Newname", "oldname", "newNames", "finalHome", "newNAME", "currentname", "NewName", "newHome", "NewNAME", "currentName", " newNames", "oldNames", "NewKey", "finalName", "currentKey", "finalname"], "oldName": ["olderKey", "recentName", "oldKey", "olderName", "olderPref", "prevname", "newname", "newOr", "oldOr", "prevPref", "oldname", "smallName", "recentname", "prevName", "recentOr", " oldname", "oldPref", "smallAnd", "smallname", "prevKey", " oldKey", "oldername", "newAnd", "oldAnd", " oldPref", "recentAnd", "smallOr"]}}
{"id1": "3958807", "id2": "20619879", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBignedStream", "loadBixedInput", "loadBbinaryStream", "loadEmbbinaryStream", "loadEmbinaryFile", "loadBixedStreamer", "loadEmbbinaryInput", "loadEmbinaryStreamer", "loadBignedStreamer", "loadBbinaryFile", "loadEmbinaryStream", "loadBignedFile", "loadBinaryStreamer", "loadBignedInput", "loadEmbbinaryStreamer", "loadBinaryInput", "loadBixedFile", "loadBbinaryInput", "loadBinaryFile", "loadBixedStream", "loadEmbinaryInput", "loadBbinaryStreamer", "loadEmbbinaryFile"], "streamName": ["recordNAME", "StreamNAME", "streamType", "StreamName", "recordHandle", "stringType", "recordName", " streamType", "fileNAME", "streamHandle", "fileName", "streamPath", " streamHandle", "resourceName", "resourceNAME", "streamname", "recordname", "stringName", "streamNAME", " streamPath", "longPath", "Streamname", "longNAME", "StreamHandle", " streamNAME", "stringNAME", "resourceType", " streamname", "longName", "filePath"], "streamToLoad": ["stream2Read", "streamToUse", " stream2Use", "streamWillLoad", "stringWillload", "stringToload", " streamToRead", "stringToLoad", " stream2load", "streamToRead", "stringToAdd", "stream2Load", "streamTOAdd", "streamTOload", "streamTOLoad", "streamWillload", " stream2Read", "streamTORead", "stream2Use", " streamToload", "streamTOUse", "streamtoLoad", " stream2Load", "streamToload", " streamWillload", "stream2load", " streamToUse", "stringWillAdd", "streamtoload", "streamToAdd", "stringWillLoad", "streamWillAdd", " streamWillLoad", "streamtoAdd"], "sz": ["Siz", "insch", "sld", " siz", "rsld", "sch", " sze", "rsiz", "sze", "insiz", "Sze", "insze", "insz", "Sld", "rsz", "siz", "Sch", "Sz", " sld", "rsze", " sch"], "req": ["dq", "http", "Requ", "attr", "pkg", "wx", "urg", "require", "gr", "quest", "sq", "pas", "client", "cur", "request", "q", "proc", "org", "res", "seq", "quick", "cmd", "ctx", "rx", "comm", "jp", "usr", "qt", "query", "inv", "comp", "fr", "requ", "Request", "wcs", "qq", "qs"], "resp": ["ret", "rep", "os", "re", "cmp", "pos", "http", "Res", "rend", "https", "wx", "esp", "soc", "gr", "pas", "sp", "client", "p", "obj", "report", "request", "r", "content", "conn", "proc", "wr", "cl", "respond", "sol", "dis", "rec", "res", "rel", " Resp", "respons", "cmd", "fs", "output", "exp", "comm", "jp", "Response", "nt", "body", "conv", "compl", "inv", "fr", "html", "RES", "sys", "Resp", "msg", "vol", "response", "serv", "status", "result"], "out": ["cn", "os", "null", "t", "in", "utt", "w", "bs", "gt", "us", "ot", "o", "ws", "aos", "client", "ts", "obj", "ins", "to", "outs", "log", "io", "sw", "gs", "n", "res", " outs", "output", "ex", "Out", "yout", "nt", "conv", "ou", "oss", "sys", "OUT", "co", "vol", "cos", "net"], "bos": ["fits", "os", "bh", "bones", "bs", "buff", "bat", "oops", "banks", "eros", "ws", "bes", "aos", "ios", "base", "tes", "boards", "uts", "ts", "bo", "mos", "bits", "oids", "bles", "js", "los", "bi", "BS", "ods", "ols", "bin", "oos", "ubis", "bas", "ys", "jas", "oss", "bot", "des", "sys", "bytes", "nos", "bis", "dos", "obs"]}}
{"id1": "7396682", "id2": "22410173", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["pixel", "upload", "zip", "read", "link", "gc", "fit", "archive", "Copy", "repeat", "opy", "delete", "cp", "php", "cross", "map", "sync", "write", "Cop", "cat", "create", "replace", "crop", "move", "share", "core", "clip", "slice", "proxy", "split", "transfer", "clone", "py", "cop", "download", "load"], "srcFS": ["sourceFS", "srcOS", "rcFs", "sourceOS", "srcVS", "srcFs", "srcSF", "sysOS", " srcVS", "sysFs", "sysFS", "srcfs", "sourceCS", "rcFS", " srcFs", "srcCS", "sourceFs", "rcMS", "srFs", "rcfs", " srcfs", "sysVS", "sourcefs", "srcMS", " srcOS", " srcCS", " srcSF", "sourceVS", "sourceSF", "rcVS", "srfs", "srFS", " srcMS", "rcOS", "srMS", "rcCS", "rcSF"], "src": ["sit", "RC", "sc", "http", "SOURCE", "selected", "https", "rc", "cont", "syn", "pkg", "path", "url", "secure", "pri", "desc", "check", "ser", "sq", "nil", "resource", "obj", "spec", "uri", "req", "boot", "sync", "sub", "cur", "proc", "source", "str", "th", "node", "rel", "st", "from", "txt", "start", "sb", "rx", "sn", "ctr", "rs", "dest", "supp", "iv", "init", "sec", "input", "img", "usr", "sin", "sr", "tmp", "target", "comp", "via", "sys", "addr", "Source", "sci", "inst", "subject", "loc", "lb", "filename", "dir", "obs"], "dst": ["dslt", " dDest", "ldest", "lst", "deest", "Dest", "dddest", "dsdest", "dsst", "Dlt", "dDest", "dedest", "lgt", "dhdest", "ddnd", "ddlt", "dST", "dgt", "ddest", "Ddest", "degt", "deslt", "dnd", "dsST", "dhDest", "dsnd", "DST", " ddest", "desdest", "dsest", "desnd", " dest", "dsgt", "DDest", "dest", "lest", " dST", "dlt", "Dst", "desst", " dlt", "ddst", "dhst", "dhlt"], "deleteSource": [" deleteSources", "closeSource", "destroySource", "leteDest", "updateSOURCE", " deleteResult", "removeSource", "removeParent", "DeleteSourceFile", "closeSourceFile", "DeleteSOURCE", "updateSite", "leteResult", "delParent", "DeleteSource", "leteSource", "deleteSOURCE", "destroySources", "leteSOURCE", "deleteSite", "removeSOURCE", "removeDest", "delSource", "leteParent", "delSOURCE", "leteSources", " deleteTarget", "deleteTarget", "updateSource", "destroyResult", "deleteSources", "deleteDest", "DeleteSite", "deleteParent", "closeSite", "deleteSourceFile", "delDest", "destroyTarget", "updateSourceFile", "leteTarget", "closeSOURCE", "deleteResult"], "conf": ["info", "m", "cn", "params", "cms", "ch", "ref", "css", "acc", "check", "cc", "ban", "map", "report", "req", "f", "log", "cache", "conn", "q", "scan", "fs", "param", "ln", "cf", "mm", "plan", "ctx", "comm", "cfg", "def", "lib", "con", "irm", "conv", "com", "hash", "config", "cm", "cb", "pool", "comment", "co", "job", "ca", "Conf", "prop"], "contents": ["Contodes", "contants", " Contents", "CONTresses", " contterms", "constends", " contresses", "CONTENT", "CONTants", " Contresses", "Content", "CONTodes", "constENTS", " content", "contENTS", "CONTends", " ContENTS", " contants", "constaves", " contENTS", "CONTaves", "content", "contaves", "contterms", "CONTent", "ContENT", "CONTENTS", "Contents", " Content", " contENT", "Contterms", "CONTterms", " contends", "Contants", "contresses", "CONTents", "contodes", "contENT", " contodes", "constents", " contaves", "contends"], "i": ["ji", "m", "ms", "iq", "ci", "u", "im", "phi", "j", "ii", "gi", "qi", "my", "I", "us", "span", "o", "key", "mi", "ti", "oi", "pi", "it", "di", "ini", "ui", "ind", "ski", "hi", "id", "client", "y", "multi", "ic", "ai", "\u0438", "q", "x", "n", "ori", "me", "bi", "iter", "ip", "cli", "init", "inner", "si", "ie", "ij", "ki", "index", "sim", "li", "ix", "docker", "json", "ami", "xi", "is", "ims", "ei", "chain"], "in": ["sql", "re", "read", "sample", " din", "mc", "cin", "add", "raw", "ini", "inf", "check", "inn", "ind", "ze", "ins", "by", "r", "reader", "inc", "doc", "out", "source", "from", "IN", "en", "bin", "inner", "isin", "con", "input", "char", "din", "body", "xml", "is", "and", "In"]}}
{"id1": "947406", "id2": "20100809", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["paste", "upload", "link", "gc", "Copy", "ls", "delete", "cp", " cop", "map", "sync", " replicate", "Cop", "cat", "create", "csv", "init", " cp", "move", "save", "printf", "slice", "transfer", "clone", "println", " Copy", "download", "load"], "src": ["sit", "sc", "orig", "bs", "rc", "pkg", "url", "ls", "ser", "sq", "ins", "req", "rl", "sf", "cur", "dist", "source", "fx", "rel", "st", "from", "rs", "start", "sb", "rx", "init", "ctr", "iv", "sec", "input", "img", "usr", "sr", "tmp", "config", "sys", "Source", "inst", "subject", "obs"], "dest": ["mod", "orig", "d", "Dest", "https", "cont", "end", "desc", "trans", "home", "pas", "decl", "id", "rest", "master", "deg", "req", "temp", "dist", "source", "test", "st", "good", "mm", "origin", "usr", "tmp", "nom", "target", "des", "nw", "loc", "pub", "est", "dir", "del"], "in": ["gin", "info", "m", "read", "local", "oin", "mc", "o", "mi", "up", "cin", "it", "on", "or", "raw", "ini", "inf", "inn", "ind", "ain", "min", "ins", "l", "rin", "doc", "pin", "inc", "ai", "al", "conn", "r", "ln", "user", "st", "iter", "IN", "mm", "win", "from", "init", "en", "inner", "isin", "bin", "act", "ck", "con", "input", "ie", "all", "sin", "din", "ma", "i", "inside", "file", "co", "is", "ac", "ar", "In", "net"], "out": ["cn", "os", "null", "t", "note", "nin", "gt", "ot", "o", "up", "aos", "mit", "on", "it", "oe", "ns", "list", "client", "writer", "can", "obj", "to", "outs", "flush", "io", "write", "conn", "not", "one", "res", "no", "cmd", "user", "output", "ex", "Out", "en", "bin", "inner", "con", "nt", "outer", "conv", "sum", "ou", "oss", "rem", "at", "sys", "file", "OUT", "co", "ne", "cos", "net"], "buf": ["bar", "bh", "buff", "b", "bs", "cap", "mu", "pkg", "ref", "prop", "batch", "font", "pad", "block", "mem", "Buffer", "vec", "fb", "buffer", "uf", "log", "tab", "mb", "queue", "cur", "Buff", "seq", "aka", "cf", "cmd", "bl", "cat", "good", "bag", "cam", "rb", "img", "br", "conv", "db", "cb", "gen", "cv", "bytes", "box", "msg", "len", "bus", "bc", "col"], "n": ["nc", "m", "cn", "t", "z", "j", "b", "un", "syn", "span", "nan", "na", "gn", "on", "nm", "acc", " l", "ns", "v", "y", "mn", "l", "k", "nl", "number", "N", "yn", "nu", "no", "nn", "ln", "an", "ni", "sn", "en", "nt", "num", "nor", "i", "names", "ren", "nos", "ll", "len", "max", "ne", "nb", "d"]}}
{"id1": "12537270", "id2": "11865906", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["process", "read", "update", "arse", "close", "se", "pair", "check", "delete", "build", "error", "php", "p", "resource", "ping", "print", "Parser", "replace", "slice", "split", "loop", "match", "layer", "parser", "format", "handle", "load"], "link": ["join", "linked", "path", "se", "line", "add", "e", "block", "Link", "let", "sp", "address", "name", "id", "image", "ping", "l", "uri", "element", "log", "route", "source", "action", "rel", "ln", "local", "start", "links", "ip", "string", "page", "style", "template", "pattern", "word", "char", "index", "le", "tag", "html", "frame", "script", "match", "lock", "loc", "entry", "ink", "type", "label", "load"], "conn": ["nc", "cn", "nav", "err", "resp", "c", "cont", "ch", "ner", "ws", "ls", "gn", "ct", "socket", "pas", "ns", "cp", "client", "connection", "cs", "obj", "yn", "Conn", "enc", "ait", "org", "res", "rel", "ln", "cmd", "txt", "cat", "ctr", "ctx", "act", "cr", "nec", "comm", "con", "nt", "conv", "oss", "cb", "connect", "addr", "ann", "loc", "open", "ctrl"], "rd": ["rt", "lr", "rw", "rob", "ld", "rc", "rog", "rar", "rand", "mr", "erd", "nd", "rer", "raf", "rad", "ra", "reader", "r", "rl", "wr", "hr", "ro", "rs", "rx", "dr", "rb", "ri", "rid", "usr", "sr", "din", "ird", "rr", "fr", "red", "rn", "vr", "rh", "dd", "d"], "kit": ["rot", "rt", "sit", "ang", "bh", "tc", "sc", "sky", "t", "kat", "kt", "pkg", "c", "ok", "mk", "ch", "h", "util", "iz", "base", "maker", "jit", "shop", "ect", "ic", "boot", "k", "tk", "io", "iw", "js", "set", "cat", "iter", "ctx", "init", "pack", "cam", "lib", "cu", "pot", "qt", "html", "bot", "sys", "box", "Kit", "webkit", "et", "net"], "doc": ["ad", "t", "w", "in", "mu", "document", "og", "mk", "di", "sp", "dc", "p", "Doc", "md", "log", "dec", "content", "out", "js", "window", "n", "g", "dat", "dr", "tree", "ds", "def", "page", "pdf", "head", "nt", "body", "man", "div", "json", "db", "html", "config", "xml", "file", "data", "msg", "tx", "dir", "d"], "url": ["pl", "domain", "bel", "ur", "lr", "t", "api", "http", "https", "path", "ref", "ls", "host", "base", "gl", "util", "peer", "address", "resource", "l", "log", "uri", "sl", "r", "nl", "git", "mb", "rl", "org", "impl", "blog", "mount", "ln", "hub", "user", "ssl", "server", "deb", "Url", "mail", "web", "html", "ul", "addr", "el", "xml", "ll", "dl", "loc", "open", "cert", "URL"], "it": ["sit", "IT", "ert", "ci", "t", "im", "in", "ot", "iz", "its", "ct", "ind", "rit", "ic", "l", "io", "out", "iw", "you", "iter", "ip", "pit", "init", "ite", "nt", "It", "li", "wait", "lit", "at", "he", "et"], "elem": ["elelement", "tom", " pelement", " elect", "tlement", "seelt", "sem", "telement", "eleem", "elelem", "belement", "selement", " peom", "llem", " eom", " element", " pelem", "lem", "element", " pelect", "telt", "em", "llement", "selt", "tlem", "seem", "eleelt", "belt", "eelt", "eom", "selem", "elect", "bem", "lelt", "eem", "tem", "tlect", "telem", "belem", "elt"], "s": ["os", "ms", "less", "simple", "ls", "ss", "se", "space", "es", "sq", "sp", "ns", "sym", "cs", "ts", "ins", "spec", "sl", "sam", "sm", "gs", "ats", "sd", "js", "fs", "sv", "S", "als", "st", "set", "rs", "sb", "sg", "sts", "si", "ds", "sa", "ys", "xs", "sys", "is", "ess", "stats", "ps"], "lnk": ["lenak", "nlk", "lintk", "lenj", "linko", "dltk", "nlak", "lnj", "dnn", "nelke", "nlkt", "linn", "lenk", "lnck", "dlck", "dlik", "klek", "lnek", "olnj", "olnk", "linak", "linik", "lnko", "nltk", "linke", "dlk", "dnk", "klko", "olnak", "dln", "lenck", "lank", "olnck", "lankt", "nelk", "olnkt", "lnke", "lanak", "lnkt", "lnik", "linck", "lann", "klke", "linek", "lnn", "klk", "nlko", "linj", "nelek", "dlak", "olnn", "nelko", "lntk", "olnik", "nlck", "nln", "dnko", "dnck", "olnko", "lnak"], "j": ["ji", "t", "pos", "z", "o", "h", "ng", "ind", "adj", "kj", "y", "v", "obj", "bo", "k", "off", "J", "q", "ja", "js", "oj", "g", "je", "n", "uj", "jj", "ij", "jp", "dj", "jl", "br", "div", "li", "prime", "Ja", "aj", "max", "jc", "bj", "jump"], "urlLink": [" urlStart", "httpMatch", " urlLoad", "emailLink", " urlSource", "httpLoad", "sslMatch", "objLink", "objUrl", "urlLinks", " urlLinks", "UrlLock", "objStart", "httpLink", " urlLock", "UrlLink", "emailLock", "strRel", "Urllink", "emailSource", " urllink", "strUrl", "sslLinks", "UrlSource", "urlSource", " urlUrl", " urlMatch", "strLink", "urlRel", "urllink", "urlStart", "urlMatch", "strStart", "urlUrl", "urlLock", "sslLink", "objRel", "sslLoad", "httpLinks", " urlRel", "emaillink", "urlLoad"], "str": ["m", "hex", "t", "w", "pkg", "stri", "coll", "prefix", "Str", "raw", "part", "list", "p", "spec", "print", "f", "stable", "r", "ocr", "temp", "out", "wr", "n", "js", "res", "g", "st", "txt", "exp", "ctr", "string", "dr", "comm", "tree", "inner", "char", "tr", "usr", "br", "div", "fr", "html", "elt", "inst", "msg", "vol", "ll", "text", "chain", "STR", "arr"], "i": ["info", "ms", "m", "ci", "im", "in", "phi", "gi", "ii", "length", "qi", "us", "I", "mi", "ti", "oi", "batch", "o", "a", "pi", "di", "ini", "ui", "zi", "hi", "y", "p", "multi", "iy", "ic", "io", "ai", "\u0438", "x", "ori", "me", "iu", "bi", "ex", "iter", "ip", "cli", "init", "start", "si", "ie", "ki", "PI", "area", "index", "sim", "li", "ix", "xi", "ami", "ims", "ei", "chain", "ity"], "skip": ["pass", "process", " skipped", "fast", "cmp", "note", "stop", "Skip", " skipping", "strip", "warn", "add", "ips", "op", "write", "kill", "iter", "ip", "replace", "complete", "copy", "deep", "clip", "ops", "loop", "sk", " bypass", "jump"]}}
{"id1": "23035537", "id2": "14464131", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["getMedia", "checkcontent", "updatecontent", "updateMedia", " getcontent", "updateContents", "getcontent", "getContents", "checkMedia", "updateContent", "checkContent", " getMedia", "checkContents", " getContents"], "userId": ["jobName", "UserName", "USERById", "UserID", "userById", "authorName", "jobId", "USERName", "humanID", "jobById", " userName", "USERId", "humanId", "authorId", "humanName", "UserById", " userById", "jobID", "userName", "UserId", "userID", "humanById", "USERID", " userID", "authorById", "authorID"], "latestMsgId": ["lastmsgById", "latestMsgID", "latestStrId", "LatestMessageIn", "lastMsgID", "lastMsgId", "latestMessageid", "latestMessageById", "LatestMsgId", "lastmsgid", "latestmsgid", "LatestMsgIn", "LatestMsgById", "latestMessageIn", "latestMessageID", "latestmsgIn", "latestMsgIn", "lastMsgById", "latestStrID", "latestMsgById", "latestmsgID", "lastmsgID", "LatestMsgID", "latestStrIn", "latestmsgId", "lastmsgId", "latestMessageId", "latestmsgById", "latestMsgid", "LatestMessageId", "latestStrById", "LatestMessageById", "lastMsgid", "LatestMessageID"], "targetUrl": ["baseStr", "templateUrl", "targetName", "TargetURL", "templateName", "sourceUr", "targetURL", "targetUr", "baseUr", "TargetUrl", "baseUrl", "sourceStr", " targetName", "sourceUrl", "targetStr", "templateDest", "argetName", " targetDest", "targetDest", "templateURL", "argetDest", "argetURL", "TargetUr", "sourceURL", "baseURL", " targetURL", "TargetStr", "argetUrl"], "url": ["pl", "bel", "ur", "u", "t", "err", "http", "null", "link", "b", "ref", "ls", "key", "base", "gl", "id", "name", "p", "resource", "ol", "l", "uri", "call", "sl", "r", "nl", "str", "mount", "rel", "location", "ssl", "char", "Url", "web", "ul", "el", "xml", "file", "dl", "ll", "open", "URL", "browser"], "in": ["gin", "sql", "null", "t", "mc", "o", "stream", "cin", "it", "or", "inf", "inn", "p", "er", "ins", "s", "l", "rin", "io", "out", "al", "source", "str", "n", "st", "from", "IN", "en", "isin", "inner", "bin", "all", "con", "input", "din", "body", "i", "inside", "el", "xml", "data", "file", "is", "serv", "In"], "list": ["info", "record", "dict", "item", "detail", "t", "null", "table", "ls", "batch", "base", "top", "add", "block", "count", "ml", "filter", "alist", "v", "sequence", "p", "summary", "group", "l", "log", "layout", "out", "queue", "lp", "single", "ist", "st", "set", "tree", "all", "result", "lt", "lat", "li", "ul", "pool", "data", "listed", "array", "dl", "format", "LIST", "chain", "status", "load", "lists", "collection"], "parser": ["asser", "processor", "parse", "per", "handler", "document", "driver", "worker", "maker", "peer", "now", "php", "system", "name", "er", "password", "bank", "reader", "student", "Parser", "service", "proc", "magic", "loader", "lp", "basic", "language", "walker", "arser", "ars", "pool", "xml", "penter", "layer", "format", "policy", "mr", "music"], "dao": [" dta", "datpo", "dnpo", "dpo", "ddta", "ddai", "oao", "daos", " dosa", "dosa", "datao", "oosa", "dnao", "oai", "dnowa", "datowa", "dai", " dpo", "dta", "ddosa", " daos", "dowa", "ota", " dowa", "ddao", " dai", "dataos", "dnaos"]}}
{"id1": "5872038", "id2": "720361", "code1": "    public void parse() throws ParserConfigurationException, SAXException, IOException {\n        DefaultHttpClient httpclient = initialise();\n        HttpResponse result = httpclient.execute(new HttpGet(urlString));\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        if (spf != null) {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(result.getEntity().getContent(), this);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"parse": ["process", "send", "read", "update", "dump", "pp", "document", "url", "se", "value", "python", "build", "scale", "php", "p", "report", "print", "call", "patch", "service", "transform", "request", "apply", "create", "start", "pack", "complete", "save", "eval", "render", "interpret", "next", "query", "xml", "parser", "format", "handle", "load", "shape"], "SAXException": ["SAXception", " SAXPException", "SAXPception", "SAHFailure", " SAXception", "SAVFailure", " SAXFailure", "SAXFailure", "SAVception", "SAXPFailure", "SAXPException", "SAHception", "SAVException", " SAXPFailure", "SAHException", " SAXPception"], "IOException": ["ConnectionException", "IOProblem", "ConnectionFailure", "IOFailure", " IOFailure", " IOProblem", "StreamFailure", "StreamException", "StreamProblem", "ConnectionProblem"], "httpclient": ["hClient", "ttpclient", " httpconnection", "hclient", "ttpcon", "ttpserver", "hconnection", "httpcon", " httpcon", " httpClient", "httpconnection", "httpClient", "httpsclient", "ttpClient", "httpserver", "httpsconnection", "httpsserver", " httpserver", "httpsClient", "httpscon"], "result": ["record", "memory", "make", "answer", "cup", "true", "successful", "table", "success", "results", "su", "there", "now", "client", "message", "this", "the", "report", "cur", "proc", "request", "created", "date", "res", "output", "profile", "dat", "page", "RESULTS", "current", "Result", "description", "data", "response", "successfully", "status", "event"], "spf": ["spfac", "ospFactory", "picfp", "spfp", " spfac", "opf", "opcf", "psF", "spfi", "picf", "spF", "opfi", "picfac", "ispfc", "aspfp", "aspfac", "ispFactory", "pscf", "ospf", "ipcf", "psfi", "ipfi", "spFactory", "lpFactory", "spcf", "psf", "ospfx", "lpfc", "aspf", "lpfx", "lpf", "ispfx", "ispf", "spfx", "ipF", "spfc", "ospfc", "opF", "ipf", " spfp"], "sp": ["pl", "sc", "pic", "spe", "pd", "pp", "esp", "se", "sh", "sq", "spl", "p", "isp", "pb", "sl", "op", "spr", "sam", "sm", "asp", "lp", "sv", "Sp", "pe", "pc", "osp", "ep", "jp", "bp", "SP", "ph", "pr", "sk", "so", "tp", "bsp", "ap", "ps", "pt"]}}
{"id1": "9109613", "id2": "3767903", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["FileCop", "Filecopy", "docopy", "doCopy", "fileUpload", "FileCopy", "doUpload", "fileCop", " fileCop", " fileUpload", " filecopy", "doCop", "FileUpload", "filecopy"], "from_name": [" from_admin", "from_base", "from_user", " from__names", "from_names", "from__name", " from__name", " from_user", " from_value", " from_no", "from_world", "from_no", "from__size", "to_world", "fromptnames", " from_client", " from_type", "from_size", "from_case", "from_type", "from_value", " from_base", "fromptadmin", " from__size", " from_size", "to_case", "from_admin", "from_client", " from_names", "from__names", "fromptname"], "to_name": ["to_names", "into_path", "intoNamepath", " to_Name", "to_Name", "toNamecode", "toNamepath", "into_code", "to_code", "toNamenames", "intoNamecode", "into_names", "to_path", " to_long", "intoNamename", "to_long", "toNamename", " to_names", "into_num", "to_num", "into_name", "intoNamenames"], "fromFile": ["entryFile", "onFILE", "orFile", "startFilename", "FromFile", "normalTime", "givenPage", "normalFile", "normalfile", "sentfile", "boundFile", "oldDo", "boundFILE", "oldLine", "fromPlace", "onFile", " fromPlace", " fromTime", "fromGlobal", "smallFILE", "fromName", "newGlobal", "smallFiles", " fromPage", "fromLine", "boundPlace", "Fromfile", " fromFiles", "smallPlace", "fromFILE", "normalLine", "sentPage", "normalField", "FromLine", "tofile", "smallFile", "newPage", "formFile", "onfile", "oldFile", "orPage", "formName", "toPage", "entryName", "fromField", "fromFiles", "givenFile", "entryfile", "fromDo", "sentFile", "oldfile", " fromFILE", "startName", "sentField", "boundFiles", " fromGlobal", "normalPage", "startfile", "fromFilename", "fromfile", "orLine", "formFilename", "newfile", "orTime", "FromDo", "FromFILE", "fromTime", "formfile", "givenfile", " fromDo", "fromPage", "newFile", "entryFilename", " fromfile", "startFile", "givenGlobal", "toField", " fromLine"], "toFile": ["intoTable", " toTable", "byFile", "etoFile", "TOFile", "TOfile", "etoFILE", "toTable", "Tofile", " toFiles", "templateFILE", "twoPath", "etoDefault", "intoPort", "toFiles", "targetModel", "TOPort", " toFilename", "toProcess", " toPlace", " toTime", "etoProcess", "toName", "thatFile", "toMessage", "twoPort", "fromName", "toFilename", "toPort", "toDefault", "fromMessage", "byPlace", "ToFILE", "bySourceFile", "ToFilename", " toPort", " toSourceFile", "etofile", "tofile", "fromTable", "twoFiles", "intoMessage", "newPlace", "etoMessage", "toPath", "fromFiles", "twoFile", "targetFILE", "intoName", " toDo", " toPath", "toDo", "targetTable", "TOPlace", "intoFiles", "TOSourceFile", "targetPlace", "fromPort", "newSourceFile", "intoProcess", "ToModel", "TOTime", "templateTable", "toModel", " tofile", "newfile", "TOFiles", "thatFILE", " toFILE", "thatDefault", "toSourceFile", "ToFile", "ToFiles", "templateModel", "byfile", "twoTime", " toDefault", "newFile", "intoFile", "twoSourceFile", "targetDo", "ToTable", "TOPath", "toFILE", "twofile", "toTime", "targetFile", "fromProcess", "etoName", "toPlace", "thatfile", "templateFile"], "parent": ["m", "module", "null", "pos", "per", "params", "central", "pid", "where", "my", "rule", "path", "component", "host", "shape", "prefix", "tar", "holder", "pi", "up", "desc", "Parent", "home", "peer", "sp", "name", "snap", "this", "p", "port", "directory", "id", "master", "owner", "mt", "unit", "layout", "spec", "event", "folder", "temp", "paren", "source", "uid", "child", "ip", "timeout", "exp", "origin", "tip", "tree", "page", "mother", "def", "position", "instance", "server", "root", "man", "tmp", "point", "ma", "pool", "global", "form", "file", "remote", "family", "parents", "filename", "chain", "prop"], "dir": ["dd", "mod", "dict", "module", "det", "cont", "coll", "path", "or", "di", "del", "ind", "cond", "dc", "cd", "directory", "direct", "md", "Dir", "folder", "DIR", "dist", "out", "crit", "cur", "str", "rec", "rel", "iter", "good", "init", "dev", "dr", "ds", "def", "tr", "dep", "tmp", "div", "odd", "dim", "db", "addr", "red", "file", "vol", "fin", "fd", "loc", "dl", "wd", "ir", "d"], "from": ["before", "pos", "orig", "in", "link", "old", "empty", "c", "back", "base", "stream", "on", "or", "check", "store", "ce", "client", "false", "normal", "bound", "min", "From", "reset", "by", "with", "out", "clean", "source", "only", "term", "window", "no", "st", "left", "create", "start", "set", "init", "origin", "en", "local", "inner", "style", "con", "input", "and", "com", "fun", "query", "fr", "user", "form", "initial", "vol", "so", "entry", "ent", "sent", "ra"], "to": ["pretty", "tom", "go", "that", "null", "t", "po", "about", "phi", "table", "done", "total", "lo", "o", "top", "base", "pi", "on", "or", "eto", "client", "ts", "this", "tto", "writer", "can", "news", "by", "with", "ato", "write", "out", "toc", "ta", "no", "To", "test", "output", "title", "tree", "token", "two", "too", "target", "te", "please", "into", "auto", "tg", "co", "so", "tty", "TO"], "buffer": ["bar", "memory", "paste", "row", "phrase", "binary", "parse", "buff", "sample", "table", "length", "variable", "document", "batch", "base", "character", "block", "Buffer", "device", "available", "message", "sequence", "event", "queue", "cache", "number", "temp", "window", "buf", "stroke", "page", "template", "result", "word", "char", "database", "frame", "comment", "initial", "entry", "button", "command", "stack", "attribute", "append"], "bytes_read": ["bytes5need", "bytes_q", "bytes_write", "Bytes_q", "bytes2Read", "bytes__read", "Bytes_write", "Bytes_find", "Bytes_have", "Bytes_Read", "bytes5write", "bytes_Read", "bytes2read", "bytes5read", "bytes__write", "bytes2write", "bytes2need", "bytes_need", "Bytes_need", "bytes5Read", "bytes_have", "bytes__q", "Bytes_read", "bytes__find", "bytes_find"]}}
{"id1": "20247400", "id2": "13891080", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"in": ["gin", "info", " din", "up", "cin", "it", "on", "check", "inf", "inn", "ind", "ze", "ins", "rin", "io", "inc", "ai", "source", "from", "IN", "init", "bin", "inner", "isin", "con", "input", "din", "i", "file", "is", "and", "In", "net"], "out": ["os", "null", "t", "err", "exit", "w", "b", "other", "gt", "ot", "o", "line", "it", "or", "check", "list", "name", "client", "writer", "obj", "ins", "to", "log", "print", "report", "io", "r", "outs", "write", "str", "n", "ln", "cmd", "output", "ex", "Out", "con", "screen", "outer", "ou", "oss", "at", "sys", "OU", "println", "auto", "msg", "OUT", "ne", "we", "dir", "net"], "buffer": ["bar", "memory", "processor", "phrase", "binary", "buff", "b", "table", "length", "total", "variable", "document", "sample", "component", "key", "batch", "se", "block", "Buffer", "available", "history", "address", "filter", "message", "sequence", "limit", "flush", "library", "cache", "temp", "queue", "source", "pause", "window", "buf", "function", "output", "iter", "template", "position", "bridge", "database", "index", "stack", "db", "trace", "comment", "header", "data", "view", "match", "channel", "command", "size", "clear", "display", "attribute", "event", "result", "shape", "append"]}}
