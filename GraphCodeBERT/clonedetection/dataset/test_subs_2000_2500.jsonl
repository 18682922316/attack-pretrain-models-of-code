{"id1": "6966398", "id2": "20920051", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["rl", "inner", "Reader", "cer", "ro", "ner", "input", "rar", "parser", "dr", " read", "rs", "rot", "older", "rx", "builder", "io", "wrapper", "handler", "writer", "rer", "row", "rc", "runner", "iter", "roller", "er", "ri", "stream", " readers", "file", "driver", "rr", "loader", "redo", "read", "mr", "query", "r", "ocr", "lr", "this", "sr", "buffer"], "ks": ["ans", "ds", "KS", "kies", "oss", "qs", "keys", "eks", "k", "obs", "kes", "kr", "ki", "cks", "icks", "ss", "hs", "ates", "sk", "vs", "km", "eps", "ces", "sky", "ms", "ls", "akes", "kk", "ys", "ols", "ars", "cs", "uds", "kb", "ke", "kas", "mk", "checks", "ips", "fs", "ses", "ups", "kens", "bs", "nets", "agles", "ck", "uk", "ros"], "key": ["entry", "ca", "link", "null", "Key", "ssh", "keys", "k", "ey", "hash", "root", "obj", "user", "cer", "ek", "base", "y", "tk", "password", "char", "sk", "client", "by", "type", "core", "KEY", "pair", "sky", "sign", "owner", "trust", "info", "er", "ke", "file", "service", "mk", "power", "object", "my", "x", "ox"], "chain": ["ca", "cache", "batch", "code", "list", "sche", "data", "bank", "test", "hash", "root", "string", "base", "group", "c", "table", "sequence", "type", "trace", "password", "form", "ver", "number", "channel", "pair", "box", "sign", "stack", "Chain", "block", "ce", "check", "stream", "file", "range", "piece", "result", "can", "chains", "binary", "component", "path", "pool", "family", "frame"], "os": ["o", "css", "ose", "pos", "js", "oss", "ops", "los", "oos", "cos", "us", "obs", "oses", "oS", "io", "is", "aos", "Os", "oso", "sys", "ms", "ot", "OS", "ios", "ols", "cs", "ys", "bos", "osi", "ts", "fs", "oids", "uts", "ps", "bs", "out", "ds", "oes", "ls", "ox"], "stamper": ["stamter", "strammer", " strampler", " stamPER", "important", "The", "stumpler", " stimpler", "stampler", "stAmper", "New", "Print", "stAmPER", "stramper", " stumper", "stimper", " stcampler", "stimPER", "strampler", " stimper", "stummer", "stimmer", " strammer", "valid", "stramPER", " stamter", " stramper", "stammer", " stcamper", " stummer", "stamPER", " stumter", "println", "font", "annot", " stampler", " stammer", "read", " stimter", "def", " stcammer", "stAmpler", "_", "good", " stumpler", " stimmer", "stAmmer", " stcamter", "this", "stumter", " stramPER", "stimpler", "stumper"], "appearance": ["displayreciation", "suppearance", "patternearances", "apearance", "appendix", "appearances", "ascears", "displaylies", " appeared", "appeared", "displayears", "attlies", "acclies", "Appearances", "displayearance", "Appeared", "accears", "suppeared", " appendix", "displayendix", "suppearances", "apeared", " appearing", "ascearing", "displayeared", "apears", "apreciation", "aceared", "ascearances", "patternendix", "appreciation", "atteared", "attearance", "Applies", "acearance", "Appearance", "patternearing", "displayearances", "accearance", " appearances", "attearances", "aplies", "apearances", "applies", "apearing", "appears", "patternearance", "acreciation", "appearing", "ascearance", "acearances", "accearances", "displayearing"]}}
{"id1": "62362", "id2": "2461169", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"convert": ["Conprocess", "compversion", "converting", "conversion", "Converting", "Converts", "ConVERT", "CONvert", "consVERT", "unprocess", "compvert", "compverts", "consverting", "consversion", "CONversion", "converts", "unfer", "unversion", "Converted", "Conversion", "unverts", "conVERT", "compprocess", "consvert", "CONverting", "Confer", "CONVERT", "converted", "unverted", "confer", "CONfer", "Convert", "conprocess", "CONverted", "unvert"], "src": ["http", "rest", "source", "pkg", "ebin", "SOURCE", "href", "filename", "rel", "ins", "ser", "input", "dist", "attr", "hl", "RC", "req", "rs", "scene", "rx", "loc", "iv", "ipl", "its", "str", "cont", "img", "scan", "sys", "usr", "orig", "func", "rc", "ur", "st", "upload", "ource", "Source", "cur", "stream", "inst", "url", "file", "from", "s", "buster", "start", "sit", "config", "sc", "host", "sin", "addr", "path", "cc", "sr", "txt", "sq", "uri", "SourceFile"], "dest": ["rest", "disk", " dst", " Dest", "dat", "test", "target", "tif", "dist", "table", "Dest", " destinations", "img", "est", "write", " Destination", "dir", "port", "gin", "mat", "result", " orig", "foreign", "temp", " destination", "txt", "orig", "source"], "in": ["inf", "d", "m", "b", "IN", "l", "ad", "inner", "cin", "ins", "el", "input", "res", "reader", "ind", "rin", "bin", "up", "In", "is", "io", "ar", "sql", "isin", "serv", "st", "stream", "file", "from", "en", "as", "inn", "r", "i", "din", "source"], "p": ["ping", "pb", "pl", "d", "parse", "m", "b", "pt", "l", "pg", "ap", "it", "cp", "pkg", "pd", "h", "wp", "post", "pe", "pa", "dp", "parser", "at", "pm", "rep", "c", "pro", "jp", "php", "f", "tp", "fp", "pi", "j", "lp", "sp", "pc", "py", "er", "pers", "t", "P", "pre", "vp", "pp", "ph", "part", "op", "g", "prot", "per", "ps", "r", "i"], "ds": ["ks", "pd", "hd", " os", "hs", "dl", "ys", "uds", " des", "iffs", " ads", "amps", "ps", "dt", "bs", "ils", "terms", "sets", "ws", "qs", "edes", "os", "cks", "dd", "ras", "eps", "ags", "loads", "ts", "ports", "gs", "mys", "js", "tags", "Ds", "points", "aws", "obs", "des", "tests", "df", "vs", "dh", "cs", "eds", " DS", "drivers", "xs", "s", "dds", "sts", "ats", "sd", "ands", "nas", "docs", "di", "db", "outs", "ns", "ls", "d", "dates", "DS", "dp", "gd", "posts", "rs", "yes", "ods", "ss", "ads", "its", "tp", " dd", "dos", "tes", " d", "scripts", "workers", "els", "lists"], "format": ["parse", "lat", "Format", "sche", "mode", "l", "policy", "it", "settings", "filter", "MAT", "at", "status", "template", " Format", "shape", "name", "table", "layout", "type", "cf", "form", "ct", "feature", "f", "style", "top", "fc", "unit", "act", "pi", "fm", "module", "title", "version", "mt", "size", "t", "file", "mat", "feat", "pattern", "ats", "set", "id", "spec", "output", "tag", "path", "pretty", "source"], "hasPixelData": ["hasixelDATA", "HaspixelData", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasPixelDATA", "hasixeldata", "HaspixelDATA", "haspixelDATA", "hasFrameData", "hasixelData", "hasFramedata", "HasPixelData", "Haspixeldata", "haspixelData", "HasPixelDATA", "HasPixeldata", "hasFrameDATA", "hasPixeldata"], "inflate": ["invalidATE", "Informat", "Inflat", " invalidocate", "Informocate", "inflat", "inFLocate", "inFlicate", "inflocate", " invalidate", " inflicate", "informocate", "Informate", " invalidicate", "inFlATE", "informated", "infolated", "invalidocate", "inflated", "infolat", "informate", "inflATE", " invalidATE", "inFLated", "infolate", "incelocate", " inflATE", "inflicate", "informat", "inFlocate", "incelicate", "inFlate", "incelate", "invalidicate", "Inflate", "invalidate", " inflocate", "inFLate", "infolocate", "inFLat", "Inflocate", "Informated", "Inflated", "incelATE"], "pxlen": ["xplen", "pixelfun", "mmlength", "pexlen", "pxden", "pxls", "packls", "pxlength", "pixellength", "packdec", "xpln", "xpden", "pixells", "mxlen", "tmplen", "xylin", "mxln", "mmln", "cplen", "phplength", "pxlin", "packlength", "pexden", "mxlength", "pexlength", "cplength", "pexfun", "mmlin", "xyln", "cpden", "pxln", "tmplength", "phpln", "packln", "xylen", "cpln", "phplen", "pexln", "mmlen", "pexls", "phpdec", "packfun", "xplength", "tmpln", "pxfun", "mxdec", "pxdec", "packlen", "pixellen", "tmplin", "xylength"], "out": ["print", "screen", "list", "conn", "ex", "err", "sum", "obj", "inv", "res", "store", "user", "OUT", "msg", "group", "name", "up", "prefix", "ou", "io", "Out", "writer", "aos", "cmd", "client", "outer", "sys", "init", "dir", "ln", "gov", "crit", "log", "inter", "cfg", "outs", "output", "gr", "temp", "net", "pretty"]}}
{"id1": "19206412", "id2": "3536332", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"md5String": ["md7Str", "MD5Str", "md5string", "MD4string", "md7Bytes", "md2Bytes", "md5Str", "md7string", "md4String", "md4string", "md7String", "md4Str", "MD4String", "MD5Bytes", "md4Bytes", "MD5String", "md2Str", "md2String", "MD5string", "MD4Str", "md5Bytes", "MD4Bytes", "md2string"], "str": ["b", "n", "v", "print", "wcs", "tr", "ctr", "data", "Str", "oct", "obj", "wr", "input", "string", "msg", "c", "name", "arr", "char", "text", "enc", "vol", "ch", "cr", "sp", "e", "br", "st", "cs", "cur", "STR", "w", "t", "s", "piece", "spec", "r", "this", "out", "txt", "p"], "md": ["d", "m", "man", " ms", "mg", " cmd", "ad", "cd", "ld", "html", "mand", " Md", "bd", " de", "pd", "hd", "grad", "MD", "mm", "det", " man", "dr", "ind", "mac", " sch", "exec", "cond", "od", "mod", "cmd", "dd", " mac", "red", "der", "df", "mail", "vol", " dd", "bf", "ms", "me", "nd", "dig", "dir", "dh", "mc", "mt", " img", "mn", "metadata", "add", "mp", "mk", "sm", "del", "sd", " def", "def", "dm", " df", "di", "de", "sha", " cd", "nt"], "hash": ["ashes", "sh", "cache", "print", "ash", "her", "hed", "html", "show", "node", "key", "h", "sum", "has", "filter", "test", "rh", "total", "esh", "mac", "array", "used", "Hash", "char", "flash", "style", "dash", "ch", "ah", "sample", "dig", "score", "where", "stack", "hex", "check", "search", "handle", "map", "oh", "result", "here", "log", "id", "all", "match", "stock", "host", "hz", "history", "sha", "height"], "hexChars": ["exchars", "exChaps", " hexChrs", "hexChords", "hexCHroups", "hexThrs", "exChrs", "hexchaps", "hexChables", "hexCroups", "hexchables", "exChars", "hexCords", "hexchars", "hexCaps", " hexChords", " hexChables", " hexChroups", "hexchrs", "hexCrs", "hexCHords", "exchrs", "hexChrs", "exchaps", "hexCHars", "hexThars", "hexChaps", "hexCHaps", "hexCars", "hexChroups", " hexChaps", "hexThables", "hexThaps"], "res": ["rest", "pr", "js", "rex", "full", "Res", "resp", "reset", "us", "ber", "rel", "ser", "ress", "re", "ins", "response", "req", "rep", "rs", "rx", "rem", "cons", "RES", "red", "resh", "ret", "sys", "usr", "vol", "rc", "rus", "cr", "fresh", "cs", "pas", "rez", "results", "next", "pers", "pres", "ts", "result", "fr", "sol", "expr", "r", "ps", "gr", "bs"], "i": ["m", "multi", "v", "n", "ci", "ui", "o", "in", "it", "ex", "ji", "ei", "gi", "span", "I", "k", "q", "us", "major", "index", "ind", "im", "\u0438", "c", "y", "ki", "ini", "li", "is", "ii", "iq", "gravity", "io", "bi", "json", "u", "j", "pi", "e", "me", "info", "cli", "zi", "ri", "ai", "sim", "t", "z", "series", "mi", "ti", "ix", "hi", "id", "point", "di", "my", "a", "ic", "x", "si", "slice", "xi", "qi", "uri"]}}
{"id1": "18489832", "id2": "2834524", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" tryLoadXippedfile", " tryLoadZZipFile", " tryLoadXZipFile", " tryLoadXZipfile", " tryLoadZippedFile", " tryLoadZressedImage", " tryLoadZressedfile", " tryLoadZppedFile", " tryLoadZZipfile", " tryLoadXippedFile", " tryLoadXippedImage", " tryLoadZZipImage", " tryLoadXippedDir", " tryLoadXZipImage", " tryLoadZppedfile", " tryLoadZppedImage", " tryLoadZressedFile", " tryLoadZZipDir", " tryLoadZippedImage", " tryLoadXZipDir", " tryLoadZppedDir", " tryLoadZippedfile", " tryLoadZippedDir", " tryLoadZressedDir"], "url": ["browser", "http", "b", "parse", "raw", "link", "web", "l", "err", "ll", "xml", "address", "key", "call", "location", "base", "name", "open", "external", "char", "str", "ul", "row", "un", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "mount", "request", "https", "URL", "file", "loader", "log", "Url", "sl", "get", "r", "uri"], "destDir": ["originDIR", "distDir", "sourceFile", "srcFolder", " destFolder", "targetDir", "srcFile", "destFile", "sourceDir", "srcDir", "destDirectory", " destDIR", "distDirectory", "originDirectory", "originFolder", "srcDIR", "sourceDirectory", " destFile", "destFolder", "targetDIR", "destDIR", "originDir", "targetFolder", " destDirectory", "srcDirectory", "sourceFolder", "distFolder", "distDIR", "targetDirectory"], "urlConnection": ["URLConnector", "urlCompany", "urlLink", "urlDialog", "URLClient", "UrlConnect", "URLCompany", "UrlDialog", " urlConnect", "httpConnection", "urlConnector", "streamConnection", "httpConnect", "streamClient", "streamConnector", "UrlLink", " urlDialog", "httpLink", "httpDialog", " urlCompany", " urlLink", " urlClient", "UrlConnection", " urlConnector", "URLConnection", "urlConnect", "streamCompany", "urlClient"], "tmpFile": ["tmpChain", "tempTile", "empFilename", "tempFile", "tempfile", " tmpDir", " tmpfile", "tempFilename", "thisFile", "cmpfile", "destFile", " tmpFilename", "thisfile", "empfile", "cmpFile", "empFile", "empTile", " tmpView", "thisChain", "tmpPage", "empChain", "tmpTile", "thisFilename", "tmpFilename", "tmpfile", "mpfile", "tempChain", "tmpBe", "tempDir", " tmpPage", "tempView", "cmpPage", "empDir", "tempBe", "tmpDir", "mpFile", "cmpFilename", " tmpTile", "tmpView", "empView", "destfile", "destPage", " tmpBe", "tempPage", "destBe"], "in": ["inf", "n", "oin", "IN", "l", "it", "inc", "al", "inner", "cin", "ins", "el", "input", "pass", "re", "index", "ind", "one", "rin", "bin", "im", "up", "inside", "ini", "is", "In", "by", "or", "ze", "isin", "co", "init", "st", "con", "none", "info", "ln", "ma", "iter", "win", "old", "ai", "gin", "from", "mi", "query", "all", "en", "as", "ain", "inn", "on", "sin", "ains", "din", "i", "ie", "source"], "out": ["o", "n", "to", "v", "print", "null", "oss", "ex", "it", "flush", "cos", "obj", "no", "OUT", "na", "at", "one", "os", "up", "Out", "ou", "io", "aos", "col", "writer", "client", "oe", "external", "or", "outer", "sys", "conv", "ch", "co", "write", "note", "con", "t", "ent", "can", "exit", "all", "OU", "output", "po", "tmp", "outs", "on", "net", "cn", "ne", "nt"], "localURL": ["LocalURI", "localhostUL", "localID", " localLL", "LocalUrl", "LocalUR", " localUrl", "LocalID", "localUrl", "localLL", "LocalURL", "publicUrl", "localUR", "localhostURL", "localhostLL", "publicURL", "LocalUL", "LocalLL", " localUL", "localhostID", "localURI", "localUL", " localID", " localUR", " localURI", "publicUR", "publicURI"]}}
{"id1": "22875895", "id2": "2465747", "code1": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 1, "substitutes": {"readVersion": ["loadversion", "readVERSION", "loadVERSION", "getVERSION", "parseVersions", "readVersions", "loadVersion", "parseVersion", "loadVersions", "getVersions", "getversion", "readversion", "parseVERSION", "parseversion", "getVersion"], "url": ["browser", "http", "entry", "v", "link", "web", "l", "ll", "rl", "xml", "address", "server", "rel", "el", "user", "re", "system", "location", "base", "name", "char", "client", "f", "ver", "str", "ul", "mail", "ssl", "org", "dl", "ref", "nl", "mount", "URL", "gl", "file", "resource", "service", "loader", "result", "Url", "sl", "bb", "github", "get", "r", "lr", "arch", "path", "util", "channel", "ls", "uri"], "reader": ["linger", "timer", "book", "consumer", "ipper", "taker", "rl", "inner", "Reader", "controller", "ner", "download", "reading", "parser", "rar", "dr", "holder", "maker", "upper", "load", "older", "builder", "field", "io", "handler", "writer", "dd", "worker", "author", "layer", "row", "bo", "runner", "liner", "iter", "roller", "peer", "er", "stream", "iterator", "resource", "driver", "rr", "range", "loader", "handle", "redo", "auto", "read", "creator", "mr", "event", "lr", "r", "lock", "control", "player", "length", "buffer", "source"], "line": ["entry", "n", "rule", "link", "print", "code", "list", "l", "err", "record", "detail", "lin", "eline", "tab", "cat", "chain", "label", "string", "linux", "lines", "one", "msg", "lo", "sequence", "error", "cli", "cmd", "trace", "char", "col", "style", "str", "cell", "row", "Line", "ine", "inline", "queue", "phrase", "nl", "note", "e", "sample", "liner", "comment", "column", "ln", "block", "word", "level", "port", "stream", "le", "normal", "LINE", "iter", "next", "out", "range", "se", "log", "job", "part", "point", "ve", "message", "display", "channel", "frame", "text", "item", "len"], "version": ["summary", "v", "time", "usage", "server", "Version", "environment", "date", "index", "VERSION", "volume", "status", "name", "description", "type", "license", "feature", "ver", "number", "title", "value", "format", "resource", "release", "tag", "current", "source"], "revision": ["reruction", "revruction", "preision", "revvious", "preruction", "previous", "interruction", "reision", "intervision", "revious", "revvision", "prevision", "interision", "intervious"], "sSec": ["lSecond", "sSEC", " sSecond", "lsSEC", "lsec", "lssec", "tsec", "sSecond", "nsec", "lsSec", "tSec", "nSEC", " ssec", "tDec", "lSEC", "nSecond", "lsDec", "nSec", "tSEC", "sDec", "ssec", "lDec", " sSEC"], "lSec": ["sSEC", "dlSec", "sMs", "lsSEC", "lsec", "lssec", "dlSEC", "dlMs", "LDec", "nsec", "lsSec", "nSEC", "lsMs", "lSEC", "dlsec", " lsec", "nSec", "lMs", "ssec", "lDec", "nDec", " lDec", "Lsec", "LSEC", " lSEC", "LSec"], "compileDate": ["Compiledate", "compileddate", "CompiledDay", "Compileddate", "CompileDate", "compileDay", "composedate", "compiledDay", "CompiledDate", "Compileate", "composeate", "compiledDate", "composeDay", "CompileDay", "compileate", "compilationate", "compiledate", "compilationDay", "compilationDate", "compilationdate", "composeDate"]}}
{"id1": "1769771", "id2": "9261777", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "copyLine", " copyFiles", "copyFiles", " CopyLine", " copyStream", " CopyFiles", "copyStream", "CopyStream", " CopyStream", "CopyLine", " copyLine", "CopyFile", " CopyFile"], "in": ["inf", "b", "IN", "l", "inc", "inner", "cin", "ins", "el", "input", "mm", "ind", "rin", "bin", "up", "In", "ini", "io", "is", "isin", "init", "old", "gin", "from", " input", "en", "inn", "r", "on", "i", "ic", "din", "source"], "out": ["o", "b", "n", "v", "to", "l", "it", "ex", "err", "res", "OUT", "at", "msg", "c", "os", "up", "ou", "Out", "io", "serv", "ot", "w", "t", "file", "s", "help", "log", "gt", "update", "op", "output", "outs", "po", "net", "p", "nt"], "inChannel": ["ainClient", "sinButton", "dinChan", " inCategory", "InChan", " inConnection", " inchannel", " inCommand", "dinConnection", "InChannel", "insideCategory", "inchannel", " inScope", "intChan", "inCase", "sinChannel", "insideChannel", "ainCategory", "intCommand", "inConnection", "ainScope", "dinchannel", "dinChannel", "inChan", "inCommand", "outChan", "innCase", "inCategory", "inScope", " inClient", "innButton", "Inchannel", "outConnection", "outchannel", "inButton", "sinCommand", " inChan", "cinChannel", "sinClient", "ainChannel", "sinRoom", "InCommand", "sinCase", " inRoom", "insideClient", "inRoom", "innClient", "inClient", "insideScope", " inButton", "innChannel", "cinRoom", "cinCommand", "intchannel", "intChannel", " inCase"], "outChannel": ["aosChannel", " outCh", "blockGate", "blockChannel", "inSection", " outManager", "parentChannel", "inchannel", "aosMember", "outGate", "neChan", "outputchannel", "blockChan", "inChan", "inCh", "outCh", "outChan", "inMember", "neChannel", "outchannel", "cnChan", " outchannel", "outputChannel", "outSection", "parentGate", " outChan", "aosChan", "blockMany", "neSection", "aosSection", "parentChan", "parentMany", "outManager", " outMany", "outputChan", "outputCh", "cnChannel", "cnManager", "outputManager", "neMember", "outMember", " outGate", "outMany"]}}
{"id1": "8064604", "id2": "14231545", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 0, "substitutes": {"init": [" Init", "it", "Init", "use", "create", "reset", "dial", "load", "login", "open", "register", "hook", "auth", "setup", "connect", "construct", "dump", "start", "config", "set", "update", "initial", "get", "prep", "bind"], "mgr": ["cmg", "mmg", "cgr", "lmg", "lgr", "rmmg", "lnd", " mdr", "MGr", "rmGr", "rmgr", "mnd", "mGr", " mmg", " mGr", "Mdr", "Mmg", "mdr", "lGr", "cdr", "cGr", "Mgr", "rmnd", " mnd"], "cfg": [" setup", " cs", "ctr", "keys", " conf", " sane", " config", " cc", " sch", " mc", "cf", " sp", "ct", "Config", "Conf", " cp", "cb", " cf", " msg", "map", " md", "config", " caps", "g", "conf", " df", " sched", "db", " cz"], "sock": [" sip", "snip", " sow", "sip", "slip", "snow", "socks", "sox", "slock", "slow", " svc", "svc", "slvc", "jsox", "snock", " socks", "sink", "jsock", "snvc", "jsink", "spocks", "sow", "spox", " sox", " sink", "spink", "jsocks", "spock"], "_cman": [" _cctr", "_dman", "_dctr", "_dgr", "_rgr", "_cctr", "_mml", "_mman", " _dman", "_rman", "_dml", "_cml", " _dgr", " _dml", " _dctr", "_mctr", "_rml", "_mgr", "_cgr", " _cgr", "_rctr", " _cml"], "_sock": [" _socket", "_rsocket", "_csck", "_src", "_ssockey", "_socked", "_rsocked", "_ssek", "_spock", "_rsock", "_svice", "_sourceockey", " _sockey", " _socked", "_dsocks", " _ssockey", " _ssocked", "_nsoc", "_nsock", " _rsocket", "_sq", "_socks", "_sck", "_Sck", "_sice", " _sck", "_dsock", "_spek", " _rsock", "_Socket", "_sourceock", " _rsck", "_Socked", "_spockey", " _ssock", "_dsrc", " _ssek", "_svq", "_tck", "_ssock", "_ssocked", "_csocked", "_sockey", " _rsocked", "_sourceek", "_nsice", "_lsice", "_nsq", "_Src", "_soc", "_csocket", "_sek", " _sek", "_trc", "_svoc", "_lsock", "_dsck", "_lsoc", "_tock", "_tocks", "_Socks", "_svock", "_lsq", "_Sock", "_rsck", "_csock", "_socket", "_sourceocked", "_spocked"], "i": ["m", "ip", "print", "in", "it", "q", "loop", "mac", "c", "y", "ini", "is", "io", "client", "bi", "ity", "pi", "me", "t", "integer", "mi", "ix", "hi", "o", "v", "n", "ex", "index", "im", "ki", "ii", "gu", "u", "j", "id", "set", "ic", "I", "x", "xi", "p", " I", "ci", "ui", "batch", "l", "err", "k", "\u0438", "iu", "f", "info", "ai", "sim", "di", "iy", "si", "ie", "multi", "gi", "ami", "chain", "phi", "us", "name", "li", "sql", "e", "cli", "counter", "g", "this", "my", "ti", "qi"], "key": ["entry", "ip", "n", "important", "print", "list", "command", "code", "ex", "cp", "Key", "sum", "k", "chain", "air", "test", "q", "index", "string", "p", "mac", "cy", "foo", "tip", "name", "y", "prefix", "cert", "cmd", "col", "char", "client", "by", "str", "row", "json", "KEY", "pair", "parent", "ch", "phrase", "title", "word", "check", "primary", "ke", "value", "mk", "def", "conf", "lock", "this", "my", "path", "x", "et", "ie", "item"], "_sout": ["_svco", "_ssout", "_wsamp", " _sres", "_ssamp", "_wsco", "_wsres", "_svres", " _samp", "_wsout", "_sres", " _svout", "_svamp", "_ssco", "_ssres", " _svamp", "_svout", " _svres", " _sco", " _svco", "_sco", "_samp"], "_sinp": [" _sinP", " _sinh", "_senm", "_binm", "_cinm", " _cinh", " _cinp", "_sinh", "_senh", "_cinh", "_binh", "_cinp", "_sinP", "_sinm", "_binP", "_senp", " _sinm", "_cinP", " _cinP", "_binp", " _cinm", "_senP"], "seed": ["dev", "insert", "entry", "then", "shadow", "feed", "secret", "slot", "socket", "serial", "sid", "node", "server", "sum", "test", "ser", "index", "store", "prime", "token", "sequence", "prefix", "finger", "random", "password", "dd", "sett", "row", "mix", "uid", "offset", "sel", "Salt", "sample", "sp", "draw", "iter", "sn", "now", "sudo", "se", "sl", "id", "set", "eed", "zip", "db", "tmp", "stable", " seeded", "temp", "pse", "shift", "delay", "source"], "rand": ["dev", "rest", "pos", "gen", "rt", "rev", "spr", "inv", "ro", "res", "rd", "user", "rad", "dr", "bot", "rot", "reg", "rx", "random", "red", "by", "ng", "sys", "rc", "nd", "draw", "and", "radius", "Rand", "add", "normal", "range", "mk", "mr", "max", "round", "r", "kick", "z"], "hex": ["kw", "raw", "print", "sh", "prop", "tex", "ex", "serial", "html", "rex", "tr", "full", "h", "oct", "alpha", "sex", "rh", "index", "string", "term", "pex", "hl", "mac", "des", "prefix", "hp", "cert", "random", "password", "char", "cf", "form", "str", "json", " Hex", "mix", "hook", "cas", "mem", "ch", "buff", "none", "color", "bytes", "he", "iter", "com", "exp", "wh", "ph", "hw", "tx", "length", "lit", "def", "hello", "zip", "temp", "x"], "pass": ["access", "parse", "print", "pos", "secret", "gen", "val", "push", "ass", "step", "gate", "press", "Pass", "sum", "reset", "test", "pillar", "res", "ress", "process", "rep", "name", "PASS", "prefix", "password", "pack", "str", "ret", "wd", "pair", "send", "act", "phrase", "alt", "strip", "pas", "task", "word", "add", "handle", "allow", "ask", "read", "pp", "def", "conf", "ack", "ps", "path", "fail", "out", "p"], "md5": [" Md2", "md45", "md2", "md23", "MD3", "dig45", "MD64", "MD2", "dig4", "MD_", "MD4", " MD64", " md4", "MD45", " Md4", "hash3", "dig5", " md23", "hash23", "MD5", "md4", " md2", "dig_", "MD23", " md45", " MD3", "md64", " md_", "md3", "hash5", "hash2", " md64", "dig3", " Md5", " MD5", "md_", " md3", " MD2"], "hash": ["browser", "print", "ash", "her", "html", "header", "ssh", "data", "h", "sum", "test", "rh", "total", "mac", "token", "name", "bolt", "random", "Hash", "password", "alph", "cert", "flash", "type", "style", "hat", "title", "version", "crypt", "search", "buster", "handle", "id", "host", "hz", "addr", "temp", "sha", "height"], "banner": ["bugner", " bannel", "scanker", "scanner", "broadnel", "scannel", "Banner", "binker", "bugker", "banker", "binter", "baner", " banler", "baninner", "binner", " baner", "banter", "scaninner", "broadline", "Baninner", "scanline", " baninner", "bininner", "banler", "rainler", "buginner", "banline", "rainer", " banline", "broadinner", "bugter", "rainner", "broadner", "bannel", "raininner", "Baner", "Banler", "scanter"], "txt": ["lt", "print", "words", "priv", "js", "ws", "html", "dat", "rt", "data", "xml", "obj", "res", "tif", "tg", "ext", "msg", "wt", "details", "TEXT", "tch", "fn", "tk", "ct", "str", "text", "json", "tp", "tm", "cont", "ret", "buff", "writers", "qt", "mint", "htm", "out", "t", "btn", "nm", "tn", "plain", "tx", "xt", "tin", "sit", "def", "notes", "typ", "kt", "utt", "tmp", "XT", "ns", "Text", "nt"], "sname": ["lsame", " snam", "spame", "lsnam", "lsname", "ssName", "snam", "spname", "sName", " same", "ssadmin", "ssnam", "same", "ssame", "ssname", "lsadmin", "spnam", "sadmin", " sName", "spadmin"], "spass": ["psred", "sposs", "SPack", "pswd", "ospack", " spred", "ospss", " spASS", "ospASS", "ospred", "spASS", "spss", "psass", "ospwd", "spred", "SPASS", "spwd", " sposs", "SPoss", "osposs", "psss", "spack", "ospass", "SPass", " spack", " spwd", " spss"], "sseed": ["peed", "tsiter", "Sseed", "ssecret", "prandom", "pseed", "sentry", "psentry", "tsser", "tseed", "ssel", "psecret", "wssel", "pspass", " siter", "srandom", "ssser", "wsseed", "tsseed", "pssel", "ssiter", "Ssecret", "ssseed", "wsentry", " sser", "sser", "psseed", "wspass", "Srandom", "siter", "Seed"], "items": ["EMS", "objects", "types", "images", "phones", "orders", "cases", "ops", "blocks", "times", "qs", "keys", "ins", "lines", "rs", "links", "ids", "Items", "aux", "details", "airs", "its", "lets", "abs", "actions", "boxes", "terms", "arts", "ms", "files", "ics", "mods", "ites", "ars", "cats", "results", "ues", "xs", "ips", "groups", "els", "arms", "styles", "faces", "amps", "stats", "ims", "values", "pages", "flows", "stuff", "rows", "item"]}}
{"id1": "18504192", "id2": "10540676", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", "copyfile", " transferFile", " transferFiles", "copyStream", "copyFiles", " transferfile", " CopyFiles", "CopyStream", " CopyStream", "Copyfile", "CopyFile", " transferStream", " CopyFile", " Copyfile"], "in": ["inf", "o", "b", "n", "IN", "l", "inc", "it", "cin", "ins", "el", "input", "mm", "ind", "vin", "rin", "up", "In", "is", "or", "isin", "old", "edIn", "gin", "from", "id", "as", "en", "inn", "on", "ic", "din", "i"], "out": ["o", "b", "n", "v", "to", "l", "it", "ex", "oss", "err", "k", "OUT", "at", "os", "ou", "Out", "io", "serv", "ot", "w", "t", "s", "help", "log", "gt", "g", "output", "outs", "po", "net", "i", "ne", "nt"], "source": ["parse", "access", "secret", "use", "back", "space", "create", "inner", "SOURCE", "input", "store", "system", "instance", "reader", "seed", "volume", "template", "sequence", "inside", "open", "style", "scan", "ources", "subject", "src", "scope", "sample", "me", "force", "init", "comment", "ource", "origin", "copy", "info", "Source", "position", "search", "iterator", "resource", "file", "from", "service", "local", "se", "start", "query", "match", "spec", "sin", "shell", "before", "pse", "ie"], "destination": ["destato", "comregation", "seeension", "seeinated", "restination", "destation", "coordato", "comato", " destification", " destension", "destification", "Destination", " destregation", "Destation", "comination", "coordification", " destato", "seeination", "comification", "Destinated", "destinator", " destation", "restinator", "destinated", "seeinator", " destinator", "restinated", "Destinator", "coordination", "destension", "Destension", "restation", " destinated", "destregation", "coordregation"]}}
{"id1": "6457199", "id2": "23666867", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["processrequest", "dorequest", "processRequest", "handlerequest", "handleQuery", "processResponse", " doQuery", "handleResponse", "processQuery", " doResponse", "handleRequest", " dorequest", "doResponse", "doQuery"], "request": ["http", "report", "command", "project", "create", "xml", "address", "reset", "question", "call", "user", "input", "re", "req", "seek", "transform", "document", "quest", "open", "first", "context", "application", "setup", "position", "each", "search", "Request", "complete", "QUEST", "query", "forward", "initial", "get", "view", "hello", "reference", "message", "frame", "select"], "response": ["http", "report", "feed", "print", "continue", "socket", "header", "xml", "resp", "reset", "respond", "server", "res", "onse", "re", "image", "status", "document", "writer", "render", "json", "send", "connection", "context", "application", "write", "e", "reply", "position", "block", "next", "out", "format", "service", "respons", "Response", "result", "exit", "release", "console", "content", "relation", "view", "output", "fire", "message", "display", "page", "channel", "frame"], "path": ["near", "partial", "raw", "print", "prop", "pointer", "Path", "ex", "pkg", "policy", "full", "key", "href", "chain", "test", "filename", "root", "parts", "uri", "clean", "index", "input", "string", "ath", "p", "location", "template", "base", "transform", "name", "prefix", "error", "type", "trace", "core", "alias", "json", "api", "context", "dir", "mount", "where", "patch", "port", "binding", "url", "format", "local", "primary", "pattern", "log", "PATH", "qualified", "route", "kind", "host", "right", "physical", "message", "relative", "method", "length", "text", "select", "parent"], "internal": ["entry", "in", "back", "inner", "regular", "virtual", "rel", "index", "intern", "template", "bin", "identified", "generic", "name", "inside", "external", "standard", "alias", "inline", "uid", "api", "ret", "valid", "context", "common", "skin", "init", "origin", "real", "Internal", "primary", "normal", "managed", "local", "impl", "url", "original", " external", "san", "id", "central", "console", "inter", "binary", "initial", "invoke", "this", "ident", "relative", "orig"], "resource": ["entry", "print", "socket", "pointer", "resolution", "record", "network", "create", "address", "controller", "res", "store", "system", "re", "directory", "process", "remote", "image", "core", "media", "connection", "context", "resources", "stream", "url", "file", "handle", "service", "range", "library", "result", "local", "model", "release", "console", "binary", "object", "region", "component", "exclusive", "reference", "Resource", "channel", "buffer", "instance", "uri", "source"], "mimeType": ["metyStyle", "mtimetype", "mimePolicy", "mIMEType", "mimeStyle", "miscType", " meshtype", "mIMEStyle", " meshType", "mimetype", "meshType", "meshtype", "mIMEtype", "mimesTypes", "MetyType", " mimetype", "mimesPolicy", " mimeName", "maxStyle", "MetyName", "misctype", "metyTypes", " mimesPolicy", " mimePolicy", "MimeName", "MetyTypes", "MimeType", "metytype", " mimeStyle", "miscTypes", "mimesStyle", "mimeName", " meshName", "mIMEName", "maxTypes", " mimeTypes", "mIMETypes", "metyName", "metyType", "mtimeStyle", "MimeTypes", " mimesTypes", "mimeTypes", "miscName", "mimesType", "Mimetype", "metyPolicy", "maxType", "maxPolicy", " mimesType", "mtimeType", "meshStyle", "meshName", " meshStyle", "Metytype", " mimesStyle", "mtimeName"], "is": ["ris", "isi", "in", "bis", "sis", "has", "isa", "are", "ins", "res", "obs", "rs", "gets", "ais", "si", "icks", "its", "IS", "isf", "Is", "isin", "iso", "ics", "ys", "ios", "cs", "nis", "ri", "s", "iss", "es", "fs", "iris", "as", "mus", "ism", "isl", "ains", "ic", "isc", "i", "ls"], "os": ["o", "ks", "css", "oss", "los", "oos", "us", "res", "obs", "oses", "oS", "des", "ss", "aos", "Os", "sys", "nos", "et", "ms", "ot", "OS", "ios", "ols", "cs", "ys", "er", "s", "bos", "osi", "ts", " Os", "es", "fs", "oz", "as", "ps", "bs", "ds", "oes", "ls", "ox", "ros"]}}
{"id1": "16557837", "id2": "20924119", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["transferfromTo", "copyfromDir", "transferFromFile", "copyFileFrom", "copyFromFile", "copyfromFrom", "transferfromDir", "copyfromFile", "copyFromDir", "copyfromTo", "transferFromFrom", "copyFromFrom", "copyFormFrom", "copyFileDir", "copyFormTo", "transferFromDir", "transferfromFrom", "copyFormDir", "transferfromFile", "transferFromTo", "copyFileFile", "copyFileTo", "copyFormFile"], "srcFile": ["srcPlace", "ivFile", "srcfile", "sbFilename", " srcFILE", "sourceFile", "sortFile", " srcPage", "sbPlace", "ivPage", "destPath", "sourcePath", "rcFiles", "srcPage", "sysFilename", " srcPlace", "rcPage", " srcPath", "sortPage", "srcSourceFile", "srcFILE", "sourceDir", "ivSourceFile", "srcDir", " srcfile", "rcPath", " srcFilename", "ivFILE", "sortFiles", " srcSourceFile", " srcDir", "sourcefile", "destDir", "srcPath", " srcFiles", "srcFilename", "sbFile", "sysPlace", "rcDir", "sysfile", "srcFiles", "sortSourceFile", "rcFile", "rcFILE", "sysFile", "destfile", "destPage", "sbfile", "sortFILE"], "destFile": [" destFiles", "memFILE", "DestPath", "DestFile", "destPath", "restFILE", "memFilename", "DestFilename", "etcDirectory", " destPath", "Destfile", "memfile", "optFilename", "srcDir", "destDirectory", " destFilename", "descDir", "descFILE", "DestFiles", "etcFile", "DestDir", "DestDirectory", "destDir", "srcPath", "restFile", " destFILE", "srcFilename", "etcFilename", " destfile", " destDirectory", "descFile", "restDirectory", "srcDirectory", "DestFILE", "optfile", "srcFiles", "descFilename", "destFILE", "destFiles", "restFilename", "destFilename", "memFile", "optFile", "etcFILE", " destDir", "destfile", "optDir"], "in": ["inf", "o", "m", "n", "ci", "conn", "IN", "l", "it", "inc", "ex", " IN", "inner", "cin", "body", "ins", "input", "mm", "re", "ind", "vin", "rin", "bin", "In", "inside", "is", "io", "ini", "ar", "isin", "co", "init", "con", "info", "iter", "mc", "add", "t", "gin", "from", "local", "read", " input", "can", "id", "all", "en", "ain", "inn", "on", "net", "din", "i", " din", "source"], "out": ["cache", "print", "list", "null", "it", "ins", "desc", "term", "msg", "c", "io", "client", "end", "sys", "ot", "con", "w", "t", "file", " output", "unt", "gr", "ne", "i", "o", "n", "to", "v", "ex", "session", "store", "ext", "at", "os", "over", "up", "Out", "aos", "cmd", "set", "output", "pool", "not", "p", "nt", "summary", "screen", "conn", "sum", "OUT", "writer", "str", "ch", "write", " Out", "can", "all", " OUT", "OU", "outs", "on", "pretty", "or", "tree", "obj", "inv", "res", "no", "det", "group", "table", "ou", "outer", "json", "ret", "co", "ion", "boot", "log", "inter", "cfg", "g", "net", "cn", "txt"], "fis": ["sfisan", "freens", "freis", "Fois", "sfos", "fiss", "cfos", "foois", "freris", "foos", "elfis", "Fist", "cfis", " fois", "cfois", "cfiss", "foens", "fisan", "fens", " fiss", "cois", "Fos", "freois", "foiss", "Fiss", "elfos", "Fis", " fisan", "cens", "cris", "fist", "foris", "sfis", "sfiss", "elfisan", "fois", "cis", "elfiss", " fist", "foist", "fris"], "fos": ["fortos", "pos", "fortres", " foes", "los", "lis", "flres", "pis", "foes", "foos", " fom", "Foss", "fortsys", "poes", "fioes", "fus", "loes", "wres", "fom", "flis", " fios", "fsys", "lus", "floss", "Fsys", "vos", "flot", "voss", "wis", "fooes", "Fos", "fios", "wos", "fiios", "Fres", " foss", "fot", "foss", "fous", "flos", "vot", "fiot", "fois", "pus", " fot", "fres", " fres", "vom", " fsys", "vios", "voes", "wom", "fortoss", "flom"], "srcModified": ["srcmodifier", "curModify", "srcModed", "srcmoded", "curModsified", "curModified", "srcTrified", "srcTrify", "rcModmodified", "srcMODified", "srcHasmodified", "srcModsify", "srcmodify", "curModsmodified", "rcModined", "srcTrined", "curModification", "srcModsmodified", "srcModify", "rcModified", "rcTrify", "srcHasifier", "srcmodified", "curModmodified", "srcMODification", "rcTred", "srcHasified", "srcMODify", "curModsification", "rcTrmodified", "rcTrified", "rcTrifier", "rcModifier", "srcTrifier", "srcTrmodified", "srcModsifier", "srcModmodified", "srcModsification", "rcModify", "srcModification", "srcMODmodified", "srcModifier", "srcMODifier", "curModsify", "srcModsined", "srcModined", "srcHasined", "srcModsified", "rcTrined", "srcTred", "srcMODed", "rcModed"]}}
{"id1": "7006052", "id2": "20375440", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"copyFileTo": [" copyFileOver", "copyfileFrom", "copyFileFrom", "copyToOver", " copyFileThrough", "copyFilesTo", "copyFilesOver", "copyFilesThrough", "copyToTo", "copyfileThrough", "copyFileOver", " copyFilesThrough", "copyFilesFrom", "copyFileThrough", "copyfileOver", "copyToFrom", "copyfileTo", " copyFilesTo", "copyToThrough", " copyFileFrom", " copyFilesOver", " copyFilesFrom"], "src": ["http", "ctr", "pkg", "rl", "rt", "sec", "cos", "rel", "ins", "input", "ser", "obs", "req", "rs", "rx", "iv", "ipl", "cont", "sys", "usr", "rc", "init", "st", "Source", "cur", "sf", "inst", "url", "start", "config", "sit", "sc", "sb", "sin", "bs", "sr", "txt", "sq", "source"], "dest": ["d", "pl", "way", "rest", "them", " dst", "dat", "test", "target", "desc", "dist", "req", "des", "loc", "decl", "Dest", "www", "end", "cont", "trans", "usr", "pub", "est", "mem", "dir", "st", "origin", "port", "result", "home", "exp", "del", "good", "tmp", "nt", "de", "done", "orig", "source"], "destFile": ["srcfile", "sourceFile", "distDo", "DestFile", "sourceFiles", " destPage", "distfile", "newfile", "srcFile", "Destfile", "newPage", "sourceDir", "srcDir", "DestFiles", "newFile", "newDo", "DestDir", "sourcefile", "destDir", " destfile", "srcFiles", "destFiles", "destDo", "distFile", "destfile", "destPage", "distPage", " destDo"], "in": ["inf", "IN", "inc", "it", "al", "inner", "cin", "ins", "el", "input", "mm", "ind", "rin", "im", "bin", "up", "inside", "In", "io", "is", "ini", "ze", "act", "isin", "rc", "init", "con", "info", "iter", "ai", "from", "gin", "read", "en", "ain", "inn", "on", "per", "sin", "ic", "i", "din"], "out": ["o", "b", "v", "to", "n", "null", "it", "ex", "oss", "inner", "cos", "obj", "res", "OUT", "at", "os", "Out", "io", "ou", "writer", "aos", "client", "by", "outer", "sys", "we", "co", "write", "ot", "con", "and", "t", "auto", "gt", "can", "en", "g", "output", "outs", "on", "po", "net", "cn", "ne", "p", "nt"], "buf": ["b", "batch", "aka", "gen", "Buffer", "bh", "prop", "tab", "cat", "cp", "pkg", "data", "obj", "abet", "mu", "seq", "msg", "bin", "arr", "uf", "rb", "cmd", "alph", "bar", "cf", "pad", "bag", "str", "var", "img", "queue", "conv", "br", "buff", "cap", "cb", "box", "bytes", "vec", "cur", "block", "cam", "cv", "log", "tx", "bc", "good", "db", "Buff", "buffer", "bus"], "len": ["pl", "n", "v", "pos", "val", "l", "ld", "ll", "elt", "rel", "el", "no", "lic", "la", "seq", "wid", "lon", "end", "fin", "str", "il", "dl", "count", "compl", "e", "cap", "cmp", "lif", "lan", "ln", "vec", "size", "mun", "coll", "t", "le", "exp", "lf", "del", "Len", "en", "mid", "length", "ls", "z", "nt"]}}
{"id1": "5620792", "id2": "3184073", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": ["HS2", " SHAOne", "sha1", "SHA2", " SHA2", "HS256", " SHA256", "HSOne", "SHAOne", "shaOne", "sha2", "sha256", "SHA256", "HS1"], "text": ["code", "print", "pt", "data", "key", "test", "q", "input", "string", "term", "ext", "msg", "template", "name", "document", "prefix", "TEXT", "password", "form", "ct", "str", "cont", "subject", "act", "comment", "word", "url", "value", "t", "pattern", "read", "config", "tx", "current", "content", "event", "output", "nt", "message", "path", "translation", "out", "Text", "txt", "select", "source"], "HASH_VALUE_SIZE": ["HASH_VALUE_TYPE", "HASH_value_DIR", "HASH_VALUE_Size", "HASH_value_SIZE", "HASH_VAL_NAME", "HASH_VAL_Size", "HASH_VALUE_NAME", "HASH_VALUE_NO", "HASH_value_TYPE", "HASH_VAL_SIZE", "HASH_VALUE_DIR", "HASH_VALUE_SOURCE", "HASH_value_SOURCE", "HASH_VAL_NO"], "md": ["d", "m", " ms", "mg", " cmd", "ad", "cd", " sd", " Md", "mand", "ld", "js", "bd", "ctr", "h", "pd", "hd", "grad", "MD", " mm", "mm", "det", " man", "od", "ind", "cond", " mc", "mod", "cmd", "dd", "mond", " ma", "der", "df", " del", " dd", "ms", "nd", "dig", "dir", "and", "dh", "td", "mc", " rm", "mt", "mn", "add", "metadata", "rm", "mp", "mk", "sm", "sd", "mode", "hm", "dm", "mb", " mo", "ds", " cd"], "sha1hash": ["sha1str", "sha1result", "sha31hash", " SHA1sum", " SHA1have", "SHA1Hash", "SHA1hash", "shaonesum", "sha3hash", "sha5value", "sha1sum", "SHA2hex", "sha1Hash", "ha2Hash", "ha1hash", "ha2hash", "SHA2Hash", "SHA1hex", "sha2Hash", "sha5hash", "sha1hex", "sha2have", "sha2hash", "sha31have", "shaoneresult", " SHA31sum", "sha2value", "SHA2str", "sha31value", "ha1result", "sha5sum", "shaoneHash", "sha7hash", "sha3str", " SHA31have", "sha2result", "sha7hex", "ha1Hash", "sha2str", "sha7str", " SHA1value", "sha1value", "SHA2hash", "ha2sum", "sha5have", "sha3hex", " SHA1hash", "sha3Hash", "sha7Hash", "sha2hex", " SHA31hash", " SHA31value", "sha2sum", "sha31sum", "shaonehash", "ha1sum", "SHA1str", "sha1have", "ha2result"]}}
{"id1": "6966398", "id2": "11082670", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "label": 0, "substitutes": {"reader": ["rl", "inner", "Reader", "cer", "ro", "ner", "input", "rar", "parser", "dr", " read", "rs", "rot", "older", "rx", "builder", "io", "wrapper", "handler", "writer", "rer", "row", "rc", "runner", "iter", "roller", "er", "ri", "stream", " readers", "file", "driver", "rr", "loader", "redo", "read", "mr", "query", "r", "ocr", "lr", "this", "sr", "buffer"], "ks": ["ans", "ds", "KS", "kies", "oss", "qs", "keys", "eks", "k", "obs", "kes", "kr", "ki", "cks", "icks", "ss", "hs", "ates", "sk", "vs", "km", "eps", "ces", "sky", "ms", "ls", "akes", "kk", "ys", "ols", "ars", "cs", "uds", "kb", "ke", "kas", "mk", "checks", "ips", "fs", "ses", "ups", "kens", "bs", "nets", "agles", "ck", "uk", "ros"], "key": ["entry", "ca", "link", "null", "Key", "ssh", "keys", "k", "ey", "hash", "root", "obj", "user", "cer", "ek", "base", "y", "tk", "password", "char", "sk", "client", "by", "type", "core", "KEY", "pair", "sky", "sign", "owner", "trust", "info", "er", "ke", "file", "service", "mk", "power", "object", "my", "x", "ox"], "chain": ["ca", "cache", "batch", "code", "list", "sche", "data", "bank", "test", "hash", "root", "string", "base", "group", "c", "table", "sequence", "type", "trace", "password", "form", "ver", "number", "channel", "pair", "box", "sign", "stack", "Chain", "block", "ce", "check", "stream", "file", "range", "piece", "result", "can", "chains", "binary", "component", "path", "pool", "family", "frame"], "os": ["o", "css", "ose", "pos", "js", "oss", "ops", "los", "oos", "cos", "us", "obs", "oses", "oS", "io", "is", "aos", "Os", "oso", "sys", "ms", "ot", "OS", "ios", "ols", "cs", "ys", "bos", "osi", "ts", "fs", "oids", "uts", "ps", "bs", "out", "ds", "oes", "ls", "ox"], "stamper": ["stamter", "strammer", " strampler", " stamPER", "important", "The", "stumpler", " stimpler", "stampler", "stAmper", "New", "Print", "stAmPER", "stramper", " stumper", "stimper", " stcampler", "stimPER", "strampler", " stimper", "stummer", "stimmer", " strammer", "valid", "stramPER", " stamter", " stramper", "stammer", " stcamper", " stummer", "stamPER", " stumter", "println", "font", "annot", " stampler", " stammer", "read", " stimter", "def", " stcammer", "stAmpler", "_", "good", " stumpler", " stimmer", "stAmmer", " stcamter", "this", "stumter", " stramPER", "stimpler", "stumper"], "appearance": ["displayreciation", "suppearance", "patternearances", "apearance", "appendix", "appearances", "ascears", "displaylies", " appeared", "appeared", "displayears", "attlies", "acclies", "Appearances", "displayearance", "Appeared", "accears", "suppeared", " appendix", "displayendix", "suppearances", "apeared", " appearing", "ascearing", "displayeared", "apears", "apreciation", "aceared", "ascearances", "patternendix", "appreciation", "atteared", "attearance", "Applies", "acearance", "Appearance", "patternearing", "displayearances", "accearance", " appearances", "attearances", "aplies", "apearances", "applies", "apearing", "appears", "patternearance", "acreciation", "appearing", "ascearance", "acearances", "accearances", "displayearing"]}}
{"id1": "1698200", "id2": "3495460", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginByteshare", "loginByteShare", " loginbitShare", " loginBitshare", "loginBitshare", "loginByteStock", "loginbitShare", "loginbitshare", " loginbitStock", " loginBitStock", " loginbitshare", "loginBitStock", "loginbitStock"], "params": ["http", "types", "settings", "tags", "cp", "services", "members", "pins", "keys", "parts", "requires", "points", "hash", "options", "mm", "parser", "posts", "cms", "param", "rs", "caps", "details", "properties", "ams", "json", "photos", "Parameters", "pi", "Par", "auth", "headers", "pas", "metadata", "acl", "changes", "names", "pres", "config", "chains", "stats", "pps", "ps", "ports", "pretty", "comments", "gs", "terms", "p"], "httpclient": ["httpsrequest", "ttpco", "http2", "httpcli", "hyperconnection", "Httpclient", " http2", "hyperclient", "httpsconnection", "Httprequest", "https2", "httpClient", "httpscli", "httco", "httcontroller", "ttpcontroller", "Httpconnection", " httpcli", "httpsco", "httclient", "httpsClient", "ttpClient", " httpconnection", "ttpclient", "httpsclient", "httpscontroller", "hyper2", "httpcontroller", "httpco", " httpClient", "httprequest", "hypercli", "HttpClient", "httClient", " httprequest", "httpconnection"], "httppost": [" httpost", " httpom", " httpppost", "httploint", " httppop", "httposter", "httplpost", "httpom", "httpost", "httppoint", "httpoint", "httppart", "httphpost", "httpplop", " httpop", "httpploint", "httpposter", "httppom", "httmpost", "httpppart", "httppop", "httploster", "httpploster", "httpperop", "httpplpost", "httpart", "httplart", "httpperpost", " httppom", "httpppop", "httphost", "httplost", "httpperom", "httpperost", "httpop", "httpppoint", "httmpart", "httpplost", "httppposter", "httmppost", "httphoint", "httplop", "httplom", "httppppost", "httpppost", "httmpop", "httphoster", "httpplart"], "formparams": ["formerrors", "functionproperties", "formednames", "formauthors", " formParameters", "functionmembers", "condsettings", "inputparams", "formchanges", "formdetails", "formmembers", "foremembers", "foreparams", "functionargs", "formedtags", "forechanges", "formsettings", " formchanges", "condnames", "inputerrors", "batchnames", "formederrors", "feedParameters", "batchparams", "condparams", "batchtags", "formtags", " formnames", "batcherrors", "inputdetails", " formdetails", "foreproperties", "foreargs", "forenames", "formargs", "formnames", "foresettings", "foreauthors", "inputnames", " formparam", "formParameters", "functionparams", " formargs", "foredetails", "inputtags", "inputparam", "formparam", "inputParameters", " formauthors", "condproperties", "feedparam", "feeddetails", " formmembers", "formproperties", "functionchanges", " formproperties", "functiondetails", " formsettings", "formedparams", "feedparams", "functionauthors"], "entity": ["orm", "entry", "security", "ENT", "html", "create", "xml", "data", "body", "el", "eme", "inv", "user", "Entity", "ew", "activity", "ee", "template", "ITY", "document", "person", "form", "line", "ity", "json", "enc", "note", "em", "fee", "comment", "ce", "metadata", "profile", "ent", "quote", "content", "object", "component", "event", "empty", "out", "buffer", "ell"], "httpresponse": ["httpresp", "HTTPconnection", "ttpconnection", "httpresult", "procresult", "HTTPreply", "procresponse", " httpresp", "httpconnection", " httpResponse", "ttpresponse", "HTTPresponse", "httpreply", "procreply", "HTTPresp", "ttpResponse", " httpreply", "HTTPresult", " httpconnection", "ttpresp", "procResponse", "httpResponse", "HTTPResponse", " httpresult"], "it": ["ed", "v", "ip", "l", "ex", "MIT", "al", "rit", "el", "you", "IT", "ind", "at", "It", "im", "ate", "ert", "ect", "li", "is", "its", "il", "itter", "ul", "iz", "act", "est", "init", "ut", "st", "ot", "he", "iter", "itted", "ite", "t", "mit", "ent", "sit", "lit", "ist", "ic", "i", "et"], "escookie": ["esctrl", "isecookie", "eyancel", "desccookie", "eycookie", "iseccookie", "descookie", "eccake", "esccookie", "ecookie", "espcookie", "escace", "ectrl", "eyace", "desctrl", "httpscookie", "ecoder", "ecace", "ecog", "ecue", "Esccookie", "occcake", "escue", "espookie", "escotton", "iseccake", "occcookie", "eccookie", "occookie", "escancel", "espancel", "descue", "Escue", "httpsookie", "httpsotton", "ecancel", "occog", "isecoder", "escoder", "Esctrl", "occoder", "espace", "escog", "ecotton", "occotton", "Escookie", "esccake", "eyookie", "httpsog"]}}
{"id1": "20028790", "id2": "530882", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBundleInfNames", "setBundleInfLabel", "setBundleFileLabel", "setBundleDataLabel", "setBundleInfoLabel", "setBundleFileTitle", "setBundleInfName", "setBundleInfoTitle", "setBundleInfTitle", "setBundleFileNames", "setBundleDataNames", "setBundleDataName", "setBundleFileName", "setBundleInfoNames", "setBundleDataTitle"], "location": ["Location", "command", "l", "address", "filename", "directory", "template", "name", "loc", "area", "document", "layout", "ocation", "language", "LOC", "description", "program", "localhost", "availability", "country", "comment", "color", "where", "position", "resource", "local", "library", "point", "reference", "path", "message", "translation", "history", "remote", "uri"], "list": ["m", "v", "n", "batch", "print", "l", "detail", "L", "chain", "missing", "listed", "status", "LIST", "name", "table", "sequence", "collection", "dl", "stack", "block", "level", "add", "local", "map", "set", "all", "lists", "ist", "spec", "pool", "net", "out", "p"], "url": ["browser", "http", "pl", "b", "link", "l", "ll", "html", "rl", "rel", "el", "hl", "lb", "base", "loc", "open", "google", "char", "f", "str", "ul", "mail", "abs", "ssl", "dl", "ref", "build", "ur", "nl", "bel", "mount", "URL", "Url", "job", "sl", "gb", "lr", "r", "sb", "uri"], "br": ["browser", "b", "BR", "pr", "bh", "tr", "bd", "rel", "ber", "wr", "dr", "bt", "kr", "rb", "bp", "buf", "str", "ch", "cr", "nl", "bro", "div", "er", "be", "next", "mr", "read", "gb", "fr", "hr", "bl", "r", "lr", "gr", "bs", "sr", "Br", "bridge"], "line": ["entry", "rule", "link", "print", "code", "l", "record", "detail", "lin", "source", "header", "eline", "data", "body", "chain", "label", "store", "string", "linux", "lo", "name", "sequence", "trace", "char", "style", "row", "cell", "Line", "ine", "online", "inline", "stay", "sql", "phrase", "nl", "note", "sample", "liner", "comment", "ln", "block", "word", "iter", "next", "le", "LINE", "handle", "se", "piece", "log", "part", "point", "lock", "message", "page", "buffer", "frame", "text"], "pos1": ["pos3", "Pos0", "indexone", "position0", "pos2", "POS0", "Pos1", "POS2", "po1", "POS1", "index1", "pos0", "position1", "posOne", "POSOne", "index3", "PosOne", "poone", " posOne", "posone", "position2", "positionOne", "indexOne", "positionone", "poOne", "Pos2", " pos2", "position3", "po3", " pos0"], "bundleSymbolicName": ["bundleSymboryname", "bundleSyMBolicCode", "bundleSymboryName", "bundleSymbolicNames", "bundleSymbicNames", "bundleSymbolicname", "bundleSymbolicalFamily", "bundleSymbolicalNames", "bundleSyMBicalName", "bundleSyMBolicname", "bundleSymbolicVersion", "bundleSymbicCode", "bundleSymbolicFamily", "bundleSymbularFamily", "bundleSyMBolicType", "bundleSyMBolicVersion", "bundleSymbicalNames", "bundleSymbolicalType", "bundleSymbularname", "bundleSyMBicalname", "bundleSymbolicalName", "bundleSymbololicNames", "bundleSymboryType", "bundleSymbololicType", "bundleSymboryCode", "bundleSyMBicalType", "bundleSyMBicalNames", "bundleSymbicVersion", "bundleSymbularType", "bundleSyMBolicName", "bundleSyMBicalVersion", "bundleSymbularNames", "bundleSymbicalType", "bundleSyMBicalCode", "bundleSymbicalCode", "bundleSymbolicCode", "bundleSymboryVersion", "bundleSymbololicFamily", "bundleSymbicalVersion", "bundleSymbicalname", "bundleSyMBolicNames", "bundleSymboryNames", "bundleSymbicalFamily", "bundleSymbololicName", "bundleSymbolicType", "bundleSymbicName", "bundleSymbularName", "bundleSymbicalName"], "bundleName": ["banchName", "banchname", "brundlename", "banchString", "fundleName", "branchString", "balename", "baleInfo", "fasketType", " bundleInfo", "fundleVersion", "branchname", "banchInfo", "bachmentName", "basketType", "baleType", "bowerVersion", "baleName", "brundleName", "fasketName", " bundlename", "bundleString", "baleVersion", "fundleType", "bundleInfo", "bundleType", "basketVersion", "brundleString", "fundlename", "bowerType", "bachmentInfo", "bachmentname", " banchInfo", "fasketVersion", "basketname", "branchInfo", "bowerName", " banchName", "fasketname", " banchname", "bundlename", "bowerInfo", "bowerString", "branchName", "bowername", "basketName", "brundleInfo", "bundleVersion"], "info": ["inf", "http", "entry", "report", "dev", "INFO", "summary", "Info", "detail", "data", "inner", "fit", "obj", "user", "tf", "index", "ext", "information", "image", "status", "state", "self", "tip", "fo", "error", "details", "f", "alias", "json", "context", "iso", "note", "me", "comment", "iter", "block", "check", "now", "value", "te", "local", "job", "query", "update", "def", "match", "all", "conf", "event", "history", "i", "instance", "item"]}}
{"id1": "8150996", "id2": "8754809", "code1": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpStream", " dupStream", "cpChannel", "CopyStream", "cpFile", " dupDir", "cpDir", " dupChannel", " dupFile", "CopyChannel", "CopyFile", " copyDir", " copyChannel", "CopyDir", " copyStream"], "in": ["inf", "b", "n", "v", "IN", "l", "it", "inc", "cin", "el", "ins", "input", "doc", "ind", "vin", "rin", "In", "by", "or", "isin", "ch", "init", "old", "con", "file", "from", "gin", "s", " input", "id", "as", "en", "inn", "on", "r", "ic", "din", "i", "source"], "out": ["o", "b", "n", "v", "to", "null", "l", "ex", "it", "oss", "obj", "OUT", "at", "one", "Out", "ou", "io", "aos", "ch", "write", "ot", "w", "t", "s", "gt", "can", "set", "output", "outs", "po", "ns", "net", "ne", "p", "nt"], "is": ["ans", "ip", "dis", "ris", "isi", "it", "js", "bis", "atis", "lis", "sis", "isa", "us", "ins", "are", "obs", "ind", "ir", "im", "ais", "vis", "icks", "ires", "ois", "tis", "its", "IS", "abs", "sys", "Is", "mis", "eps", "isin", "iso", "ms", "ics", "init", "ys", "ios", "iter", "cs", "nis", "ri", "xs", "s", "iss", "isal", "es", "fs", "iris", "isl", "ims", "ns", "ils", "i", "ains", "isc", "bs", "si", "ie", "mos"], "os": ["o", "css", "ks", "pos", "oss", "ws", "ops", "los", "js", "less", "oos", "cos", "oses", "obs", "oS", "des", "io", "aos", "ss", "Os", "tis", "ens", "ows", "mes", "vs", "sys", "eps", "nos", "ms", "mot", "dos", "ot", "OS", "ios", "ols", "cs", "acs", "s", "bos", "osi", "ts", "es", "fs", "ost", "outs", "ns", "bs", "ds", "gs", "oes", "ls", "ox", "mos", "ros"], "buffer": ["batch", "cache", "print", "command", "Buffer", "memory", "paste", "window", "padding", "template", "base", "stroke", "table", "sequence", "button", "document", "bar", "pad", "buf", "number", "mem", "phrase", "sample", "buff", "append", "comment", "stack", "iter", "block", "word", "reason", "bridge", "variable", "binary", "initial", "view", "event", "message", "temp", "display", "length", "frame", "tree", "source"], "len": [" clen", "n", "pos", "val", "l", "err", "ld", "ll", "yn", "num", " l", "elt", "body", "L", " le", " length", "rel", "el", "no", "full", "ind", "hl", "seq", "li", "wid", "lon", "end", "fin", "un", "count", "lim", "e", "cap", "lan", "ln", "size", "tl", "le", "t", "coll", "gl", "del", "lf", "sl", " el", "Len", "els", "en", "all", "fl", "length", "et", "ls", "z", "nt"], "ok": ["comp", "ook", "md", "it", "ll", "iro", "oc", "full", "k", "ik", "clean", "arc", "status", "req", "msg", "yes", "state", "quick", "y", "up", "ak", "sk", "OK", "f", "kok", "bo", "valid", "u", "rc", "ch", "ms", "ot", "ko", " okay", "og", "par", "dec", "check", "cs", "coll", "boot", " Ok", "oh", " good", "ku", "good", "ack", "ocr", "ol", "app", "Ok", "ck", "ready"]}}
{"id1": "11556231", "id2": "5543349", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "label": 0, "substitutes": {"ByURL": [" byString", "byHTTP", " byUrl", "ByString", "byUrl", "byURL", " byURL", "byString", " byHTTP", "createURL", "createUrl", "ByHTTP", "ByUrl", "createHTTP", "createString"], "urlstr": ["ulstring", "ulStr", "UrlSTR", "uristring", "Urlobj", "uristr", "lSTR", "urlStr", "urlSTR", "UrlStr", "lstring", "lobj", "uriobj", "Urlstr", "lStr", "Urlstring", "urlstring", "lstr", "urlobj", "ulstr", "uriStr", "ulSTR"], "uri": ["http", "ui", "link", " URI", "html", "address", "href", "q", "iri", "filename", "phi", "string", "system", "directory", "term", "database", "prefix", "io", "description", "uid", "subject", "u", "pi", "ur", "context", "init", "du", "uu", "origin", "https", "URL", "URI", "ri", "doi", "resource", "file", "range", "Url", "query", "id", "reference", "path", "i"], "url": ["browser", "http", "parse", "link", "conn", "l", "socket", "ll", "address", "hub", "parser", "location", "base", "loc", "open", "li", "char", "client", "f", "str", "ul", "mail", "ssl", "build", "ur", "nl", "mount", "URL", "resource", "file", "impl", "Url", "job", "sl", "host", "r", "sb", "ls"], "connection": ["http", "link", "conn", "command", "condition", "socket", "network", "session", "connected", "directory", "database", "response", "Connection", "c", "open", "io", "handler", "client", "engine", "number", "context", "application", "con", "position", "established", "connect", "ion", "resource", "service", "using", "console", "opening", "relation", "channel", "i"], "in": ["inf", "IN", "l", "inner", "cin", "body", "us", "ins", "input", "mm", "ind", "rin", "bin", "In", "client", "f", "isin", "info", "mc", "ma", "stream", "file", "from", "mat", "id", "en", "get", "inn", "sin", "r", "out", "din", "i", " din"], "reader": ["inner", "Reader", "body", "ner", "input", "reading", "parser", "ator", "rar", "dr", "ro", "rx", "builder", "io", "handler", "writer", "row", "context", "runner", "iter", "er", "ri", "stream", "iterator", "resource", "handle", "loader", "read", "r", "buffer"], "is": ["ris", "isi", "bis", "lis", "sis", "has", "isa", "are", "ins", "res", "input", "im", "rs", "ais", "os", "its", "IS", "Is", "sys", "mis", "isin", "sam", "ms", "serv", "info", "ios", "nis", "ri", "sim", "s", "iss", "se", "es", "fs", "iris", "as", "ism", "isc", "i"], "document": ["m", "record", "node", "xml", "Document", "doc", "dom", "information", "response", "template", "collection", "media", "ocument", "context", "application", "element", " Document", "file", "library", "result", "content", "object", "output", "message", "page", "tree"], "source": ["node", "SOURCE", "site", "input", "location", "handler", " src", "number", "context", "src", "ource", "element", "sn", "Source", "resource", "se", "result", "set", "content", "object", "event", "dest", "out", "or", "instance", "select", "tree"], "name": ["code", "named", "node", "Name", "key", "NAME", "property", "label", "attr", "string", "location", "param", "prefix", "description", "type", "attribute", "class", "title", "comment", "version", "names", "value", "format", "file", "id", "variable", "object", "event", "default", "tag", "path"], "namespaceURI": ["namesacementURI", "nsplaceURL", "namesenterUID", "resourcesacementUI", "namesplaceURL", "nsplaceuri", "namesenterRI", "namesaceIX", "namesificationURI", "namesplaceuri", "worksystemuri", "namesenterURI", "namesystemuri", "namesaceUI", "worksystemUID", "namesificationRI", "namespaceUI", "nameseturi", "namespaceIX", "namespaceuri", "namesplaceURI", "namesystemRI", "namesificationuri", "workspaceUID", "nspaceURI", "resourcespaceURI", "resourcespaceUI", "nspaceID", "namesetURL", "resourcesacementIX", "worksystemRI", "namespaceID", "namesystemURI", "namesystemUID", "namesaceURI", "namesacementIX", "namespaceUID", "namesetURI", "namesenteruri", "namespaceRI", "namesetID", "namesacementUI", "namesplaceID", "workspaceRI", "nsplaceID", "namespaceURL", "resourcespaceIX", "namesificationUID", "nspaceURL", "workspaceURI", "nspaceuri", "workspaceuri", "resourcesacementURI", "nsplaceURI", "worksystemURI"], "qualifiedName": ["friendlyName", "localValue", "commonName", "localname", "qualifiedNames", "relativename", "relativeValue", "commonType", "qualifiedValue", "friendlyType", "relativeNames", "friendlyname", "fullName", "fullNames", "localType", "fullValue", "qualifiedname", "commonname", "fullname", "localNames", "qualifiedType", "commonNames", "relativeName", "friendlyNames"], "data": ["command", "mode", "dat", "xml", "key", "body", "address", "buffer", "input", "string", "expression", "response", "image", "error", "description", "type", "password", "definition", "media", "str", "DATA", "ata", "comment", "version", "element", "info", "value", "resource", "format", "pattern", "result", "def", "content", "object", "event", "output", "message", "action", "text"], "tagName": ["tagData", "localData", "Tagname", "tagValue", "qualifiedname", "qualifiedData", "TagValue", "qualifiedValue", "localValue", "localname", "TagData", "TagName"], "target": ["ip", "link", "command", "node", "property", "location", "prefix", "error", "language", "handler", "alias", "subject", "class", "ref", "context", "src", "owner", "title", "binding", "format", "Target", "result", "content", "object", "role", "path", "action", "instance"], "elementId": ["documentID", "objectid", "nodeid", "objectId", "elementID", "documentIndex", "elementid", "documentId", "objectID", "objectIndex", "nodeID", "elementIndex", "documentid", "nodeId", "nodeIndex"], "tagname": ["Tagname", "localnum", "shortname", "Tagid", "shortnum", "tagnum", "shortid", "Tagnum", "shortName", "localname", "tagid", "TagName", "localid"], "localName": ["fixedname", "fixedName", "fixedNAME", "componentName", "supportedNames", "supportedname", "supportedName", "localNAME", "localname", "localNames", "componentNAME", "componentname", "componentNames", "supportedNAME", "fixedNames"]}}
{"id1": "16623181", "id2": "17557289", "code1": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"srcDir": ["sitDirectory", " srcRel", "sitdir", "sourcePath", "srcRel", "sbDirectory", "sbRel", "rcDirectory", "srcdir", "sbPath", " srcdir", " srcPath", "sitPath", "sourceDir", "sitDir", " srcDirectory", "srcPath", "sourceDirectory", "rcdir", "sourceRel", "srcDirectory", "sbDir", "rcDir", "rcPath"], "dstDir": ["ddestFile", " dndDir", " dotir", " dotDir", "ddestdir", "dstir", "ddsir", " dotFile", " dnddir", " dstDirectory", "ddestDirectory", "dstdir", " dndDirectory", "dnddir", "dotDir", "dndir", "destFile", "dndDirectory", "dotdir", "destDirectory", "ddsFile", "dotFile", "dndFile", "dstFile", "destDir", " dstFile", " dstdir", "ddsDir", " dstir", "destdir", "ddestDir", " dotdir", "dotir", "dndDir", "dstDirectory", "ddsdir", " dndFile"], "srcFiles": ["sourceFile", "sourceFiles", " srcFile", "srcFile", "rcFiles", "srcfiles", "rcResources", "srcResources", "sourcefiles", " srcfiles", "sourceResources", "rcFile", " srcResources", "rcfiles"], "f": ["d", "b", "v", "o", "n", "m", "l", "alf", "fe", "full", "h", "k", "perm", "tf", "F", "xf", "elf", "c", "name", "y", "fo", "fi", "cf", "col", "rf", "fp", "fc", "j", "ref", "bf", "e", "fm", "dir", "fac", "fb", "sf", "w", "file", "t", "s", "fd", "fs", "exp", "lf", "part", "fl", "fr", "good", "g", "r", "a", "fx", "i", "z", "p"], "srcChannel": ["sslBuffer", " srcchannel", "sourceChan", "srcConnection", " srcBuffer", "srcchannel", " srcCommand", "sourceButton", "srcChan", "rcBuffer", " srcButton", "srcBuffer", " srcCh", "srcClient", " srcClient", " srcChan", "rcChannel", "rcClient", "sslCh", "srChannel", "sourcePanel", "rxButton", "srConnection", " srcPanel", " srcConnection", "rxPanel", "rxChannel", "srcCh", "rcConnection", "rcCommand", "sourceChannel", "sourcechannel", "srcPanel", "sourceBuffer", "sslChannel", "rcCh", "srClient", "srcCommand", "rxchannel", "sslChan", "sourceClient", "rcChan", "srCommand", "rcchannel", "srcButton"], "dstChannel": ["ddestchannel", "dustChannel", "dblCategory", " dstConnector", "destchannel", "ddestConnection", "destChan", "dotChannel", "DotCategory", " destChan", " dstComponent", "dotConnection", "destConnection", "DotChannel", "DestChan", "dotCategory", "destConnector", "DotChan", "destChannel", "DstCategory", "DstChannel", "DstConnection", "DstChan", "dblChannel", "destComponent", " dstChan", "DestConnection", "DotConnection", "dblChan", "ddestChan", "dotChan", "dstchannel", "dustConnector", "dstConnector", "DestChannel", "ddestComponent", "dustChan", " destChannel", "dotchannel", "dstConnection", "Dstchannel", "ddestCategory", "dustComponent", "dstChan", " destConnector", " destComponent", "Destchannel", "dstCategory", "ddestChannel", "dblConnection", "dstComponent", "ddestConnector"], "buffer": ["summary", "rule", "batch", "cache", "print", "screen", "Buffer", "command", "null", "header", "data", "address", "function", "filter", "chain", "reset", "memory", "grow", "window", "re", "database", "total", "timeout", "template", "base", "shape", "table", "sequence", "button", "document", "hold", "attribute", "ob", "char", "queue", "buf", "number", "context", "phrase", "note", "sample", "buff", "pause", "comment", "stack", "iter", "block", "position", "resource", "library", "result", "variable", "binary", "event", "output", "scroll", "reference", "message", "temp", "history", "channel", "length", "frame", "source"], "nr": ["n", "NR", "bj", "rw", "np", "ctr", "num", "tr", "nir", "wr", " NR", "no", "obs", "attr", "adr", "kr", "arr", "rand", "rb", "nw", "nut", "our", "number", "ng", "sys", "usr", "nc", "nl", "br", "nn", "iter", "ptr", "nv", "Ni", "next", "radius", "ln", "sim", "rr", "nie", "uj", "nor", "nm", "norm", " ni", "mr", "eno", "ni", "tn", "vr", "nz", "inter", "hr", "nb", "r", "addr", "gr", "byter", "ocr", "ns", "out", "sr"]}}
{"id1": "4168534", "id2": "23620712", "code1": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"insertSmsInf": [" insertSmsId", " insertsmsId", " insertSMSById", " insertSmsById", " insertsmsById", " insertSmtById", " insertsmsConf", " insertsmsInf", " insertSmtInf", " insertsMSConf", " insertSMSInf", " insertsMSId", " insertSmbInf", " insertSmsConf", " insertSmbById", " insertSMSConf", " insertSMSId", " insertSmtConf", " insertSmtId", " insertsMSById", " insertsMSInf", " insertSmbConf", " insertSmbId"], "sms": ["Smt", "msms", "scs", "smo", " sems", "Sms", "gsvc", "mscs", "Smb", " spm", "spm", "jsms", " smt", " smm", "mspm", " svc", "gsmo", "gsps", " sts", "esmo", "svc", "msems", "msts", "esms", "ssems", " smo", "msmm", "gsms", "sts", "jsmo", "smb", "Smo", "sems", "ssts", "smt", "jsmt", "esvc", " smb", "jsmb", " scs", "esps", "ssmm", "smm", " sps", "sps", "ssms"], "smsId": ["snsId", "gesmsName", "smsName", "snsID", " smsid", "hsnewsKey", "gesnsID", "smedById", " sessid", "snewsKey", "smmName", " smsID", "sMSKey", "hsmsId", "gesnsName", "smsgID", "smsgId", " smbId", "sessid", " sessId", "hsmsKey", "smmById", "snsid", "gesmsId", "snewsId", "smedId", " smsName", "smsID", "snsById", "sMSID", "smbName", " smsById", "smmId", "smbId", "smsById", "smedID", "sMSid", "smedName", "sessID", " smbById", "hsnewsID", "smsgById", "smsgName", "gesmsById", "snewsID", "hsnewsById", "sessId", "snsKey", " sessID", "gesnsById", "sMSById", "snewsById", "smbID", "snsName", "smsKey", "gesnsId", "hsmsById", "sessById", "smmID", "hsmsID", "gesmsID", "smbById", "smsid", "hsnewsId", " smbID", " sessById", " smbName", "sMSId"], "conn": ["n", "ca", "link", "js", "gate", "np", "pg", "cp", "yn", "rt", "lang", "session", "ann", "sec", "obj", "ctx", "Conn", "res", "exec", "msg", "Connection", "c", "dc", "reg", "loc", "jp", "open", "cert", "cmd", "col", "ct", "ont", "comm", "client", "cont", "enc", "bo", "connection", "org", "nc", "ch", "co", "mem", "sql", "cb", "con", "mc", "cur", "ce", "mt", "connect", "pas", " con", "coll", "out", "handle", "gc", "tn", "ctrl", "close", "en", "cfg", "conf", "db", "ec", "addr", "po", "pool", "cc", "ns", "cn", "conv", "txt", "nt"], "pstmt": ["psstgr", "psstm", "psstmt", "postgr", "pstmod", "ystygr", "pstcmd", "pStem", "pputmt", "pstmr", " pstmod", "prestmn", "pfrmt", " pstmp", "pSTgr", "pctnm", "pfrmp", "pstygr", "pstyrel", "perstmsg", "pstegr", "pputmm", "pSTstat", " pctmt", "pstph", "pctmr", "pstatmt", "prestem", "pputnm", "pstatmp", "pstyg", " pstatmt", " pctm", "pstgr", "perstph", "persetmsg", "psetph", "pstwr", "pstem", "prestmt", "psstygr", " pstatstat", "psstym", "ystymt", " pstatg", "pputmr", " pstmb", "pstmsg", " pststat", "pctgr", "pctstat", "pputstat", "psstymt", "pstatem", "pStmm", " pctmp", "pstecmd", "ystystat", "pstatmod", "pprestmm", "pconstnm", "pconstmr", "pfrm", "ystgr", "pstatstat", "pstymn", "perstmm", " pctmm", " pstatmb", "pstemt", "pstatph", "pstmn", "pctmt", "postmt", "pctmm", "pstymt", "pstmp", "pputg", "postcmd", "pstmm", "pstymb", "psstyrel", "persetmt", " pstg", "pstg", " postgr", "ppstmn", "pstatmb", "pStmt", " postmt", "perstmt", "pprestmn", " postwr", "pststat", " pstmm", "pstmb", "ystmn", "pputcmd", "psstrel", "ppstmt", "pctmn", "psetmt", "pputmb", "pputgr", "pstystat", "pstatgr", "pSTmn", " pctnm", "pstatmm", "pstm", "ystmt", "yststat", "pstatmsg", "pctrel", "ppstem", "pStmn", "psetmm", "pfrmod", "pconstmm", " pstwr", "ppstmm", " pctmr", "postwr", "psetmsg", "pstewr", "pstrel", "pstatmn", " pctmod", "ystymn", "persetmm", " pstgr", "pprestmt", "pprestem", "pstnm", " pstmr", "pctmp", "pSTmt", " pstcmd", " pstm", "pputwr", "pstatg", "prestmm", "pstym", "persetph", "pstatrel", "pstatm", " pstnm", "pconstmt", "pctm", "pctmod", " postcmd"], "buffer": ["b", "batch", "cache", "print", "code", "Buffer", "command", "header", "create", "black", "key", "reset", "function", "server", "memory", "window", "string", "directory", "database", "template", "base", "group", "table", "document", "sequence", "builder", "button", "uf", "trace", "buf", "queue", "bo", "connection", "build", "phrase", "mem", "append", "buff", "comment", "iter", "py", "block", "size", "url", "escape", "file", "profile", "printf", "library", "initial", "quote", "order", "output", "empty", "mb", "message", "temp", "control", "display", "out", "shell", "pool", "join", "history"], "index": ["scale", "access", "zero", "pos", "val", "condition", "gate", "push", "num", "create", "Index", "axis", "thread", "key", "second", "ctx", "ind", "process", "cond", "loc", "rand", "open", "attribute", "card", "number", "row", "mix", "count", "context", "scope", "lex", "init", "append", "draw", "column", "request", "fac", "strip", "position", "size", "with", "check", "ion", "add", "connect", "value", "hex", "IND", "ix", "read", "exp", "set", "exit", "success", "query", "find", "stick", "see", "default", "empty", "x", "EX"], "ex": ["nex", "tex", "rex", "err", "ception", "Ex", "obj", "wx", "re", "ext", "pex", "rx", "exc", "expl", "aux", "external", "or", "lex", "e", "con", "example", "txt", "hex", "cre", "w", "t", "pac", "se", "exp", "exit", " dex", "exe", "event", "ax", "a", "x", "EX", "ox"]}}
{"id1": "14502142", "id2": "8490297", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", "downloadStream", " copyFiles", "transferStream", "copyFiles", "copyPhoto", "downloadFile", "copyStream", "downloadPhoto", " copyPhoto", "downloadFiles", "transferFiles", "transferPhoto", " copyStream"], "source": ["null", "in", "SOURCE", "site", "target", "input", "seed", "image", "template", "base", "scene", "style", "subject", "sql", "src", "scope", "sample", "sp", "init", "ource", "origin", "Source", "sf", "search", "resource", "file", "service", "s", "se", "original", "start", "config", "query", "spec", "shell", "pse", "parent"], "dest": ["d", "pl", "rest", "dev", "comp", "null", "it", "cat", "them", "cp", "dat", "test", "target", "obj", "tif", "desc", "dist", "th", "self", "dc", "loc", "table", "decl", "Dest", "nw", "nom", "cont", "trans", "img", "sys", "usr", "src", "sp", "dir", "st", "origin", "copy", "opt", "result", "master", "etc", "del", "exp", "sit", "gt", "home", "lit", "foreign", "good", "tmp", "tom", "this", "temp", "out", "txt", "orig"], "from": ["d", "entry", "pos", "link", "in", "back", "tr", "without", "inner", "reset", "el", "no", "input", "user", "window", "re", "term", "lo", "base", "up", "da", "tar", "col", "form", "client", "f", "by", "un", "From", "cont", "str", "vol", "so", "a", "init", "owner", "st", "por", "old", "con", "sent", "origin", "ce", "with", "check", "fun", "normal", "before", "rom", "bean", "se", "start", "ent", "part", "can", "query", "low", "en", "fr", "bound", "of", "r", "de", "left", "ra", "or", "ie"], "to": ["b", "null", "total", "io", "client", "top", "bo", "pi", "news", "t", "eto", "te", "will", "file", "tmp", "ne", "o", "pt", "at", "token", "os", "ta", "ts", "see", "stable", "p", "pty", "nt", "toc", "l", " too", "that", "tar", "by", "oto", "sp", "must", "etc", "tt", "can", "all", "po", "on", "tom", "message", "pretty", "out", "or", "parent", "To", "tab", "phi", "target", "no", "table", "pro", "please", "co", "so", "st", "too", "auto", "tx", "op", "net", "TO"]}}
{"id1": "18005010", "id2": "1357662", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"setProfile": [" setProperty", " setDefault", "setProperty", "storeDefault", "storeProperty", " setProf", "SETProperty", "SETProf", "setProf", "storeProfile", "setDefault", "SETDefault", "storeProf", "SETProfile"], "loginName": ["loginNames", " loginKey", "fileKey", "displayKey", "fileNames", "displayNames", "loginKey", " loginNames", "displayname", " loginname", "filename", "loginname", "displayName", "fileName"], "profile": ["report", "summary", "project", "Profile", "settings", "usage", "phone", "policy", "header", "data", "hash", "property", "memory", "user", "p", "username", "template", "base", "plot", "table", "document", "details", "properties", "password", "client", "feature", "style", "panel", "json", "context", "mem", "note", "sample", "title", "position", "port", "account", "result", "log", "config", "update", "picture", "relation", "photo", "output", "face", "option", "role", "pool", "history", "prof", "pse", "buffer", "frame", "FILE", "pty", "line"], "outStream": ["offWriter", "aosPoint", "servstream", " outstream", "exPoint", " outPoint", "servSteam", "offStream", "outPoint", "OutFile", "Outstream", "outputSteam", "outputView", "outputStream", "outWriter", "outstream", "OutStream", "outputstream", "OutWriter", "offstream", "offSteam", "exWriter", "OutSteam", "exSteam", "exStream", "servView", "servStream", "OutView", " outView", "outSteam", "aosStream", "aosSteam", "outFile", "aosWriter", " outFile", "outView", "outputFile", " outWriter", " outSteam"], "url": ["browser", "http", "pl", "parse", "link", "web", "l", "html", "ll", "xml", "address", "q", "rel", "re", "location", "string", "base", "loc", "li", "open", "cert", "char", "client", "email", "f", "str", "abs", "mail", "ssl", "dl", "org", "build", "ur", "nl", "bel", "mount", "https", "URL", "resource", "service", "impl", "Url", "get", "host", "r", "path", "ls", "uri"], "file": ["report", "entry", "print", "link", "null", "web", "body", "filename", "download", "image", "template", "base", "name", "table", "document", "email", "f", "ile", "fp", " File", "info", "port", "le", "resource", "File", "local", "format", "library", "result", "lf", "binary", "output", "db", "path", "pool", "page", "out", "FILE", "tree"], "connection": ["to", "link", "conn", "command", "web", "condition", "pointer", "socket", "network", "generation", "session", "dial", "computer", "city", "no", "statement", "connected", "system", "database", "directory", "response", "Connection", "c", "still", "open", "client", "number", "closure", "cone", "bo", "sql", "nc", "character", "application", "con", "position", "established", "connect", "ion", "resource", "created", "close", "console", "relation", "net", "channel", "communication", "online"], "writer": ["entry", "walker", "rw", "ws", "network", "operator", "node", "inner", "writing", "function", "flush", "wright", "ner", "processor", "window", "reader", "journal", "editor", "maker", "Writer", "wt", "document", "builder", "wrapper", "external", "handler", "fn", "client", "worker", "outer", "commit", "wa", "caster", "write", "writ", "runner", "owner", "liner", "comment", "draw", "riter", "writers", "er", "word", "println", "counter", "w", "written", "iterator", "format", "driver", "loader", "widget", "creator", "wrote", "storage", "variable", "event", "usher", "WR", "buffer"], "myEnum": ["myenumb", "myENUM", "myEnUM", "myEnet", "myEncum", "someENums", "myEnom", "myENumb", " myAnet", "someEnums", "myEnums", "myAnums", "myenum", " myAnum", "myAnet", "myAcums", "myEncom", "someENumb", "myenom", "someEnumb", " myAnom", " myEnums", "myENum", "myEncumb", "myENom", "myEnumb", "myAnumb", " myEnet", "myAnUM", "myAcum", " myEnom", "myAnum", "someEnUM", "someENum", " myENumb", " myAnums", "myENet", " myEnumb", " myENom", " myENum", "myAcom", "someENUM", "myEncums", "myAnom", "myEncUM", "myAcet", "myENums", "someEnum"], "key": ["m", "entry", "n", "v", "val", "ex", "it", "step", "Key", "node", "keys", "k", "chain", "air", "pe", "test", "label", "no", "index", "string", "child", "hash", "ek", "one", "mac", "base", "cond", "token", "name", "field", "prefix", "type", "attribute", "col", "char", "str", "cell", "row", "var", "KEY", "bo", "pair", "parent", "note", "owner", "title", "column", "info", "ace", "element", "word", "primary", "value", "part", "member", "ice", "id", "variable", "host", "a", "i", "text", "item"]}}
{"id1": "16466743", "id2": "13565787", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 1, "substitutes": {"getmd5": ["getmd2", "getsha6", "getmd6", " getMD5", "getMD6", "getmd4", " getmd4", "getMD2", "getsha2", "getMD4", " getmd2", " getMD6", " getmd6", " getMD4", " getMD2", "getMD5", "getsha5", "getsha4"], "password": ["Password", "security", "entry", "shadow", "code", "secret", "data", "key", "address", "hash", "user", "pass", "string", "padding", "database", "ew", "username", "token", "sword", "name", "login", "prefix", "description", "attribute", "email", "wd", "phrase", "auth", "word", "w", "value", "pattern", "wordpress", " Password", "hello", "message", "path", "text", "p"], "pwHash": ["pWhash", "pwdHas", "pwhash", "spwdHash", " pwdSum", "pWHash", "pwdSum", " pwdHas", "pwshash", "pwSum", "pwsHas", "spwdSum", "pswHas", "spwhash", "spwdhash", "pwdHash", "pwsHash", "pwtHas", "pswSum", "pwthash", "spwdHas", " pwSum", " pwhash", "pwtSum", "spwSum", "pswhash", "pwsSum", "pwHas", " pwHas", "spwHas", "spwHash", "pWSum", " pwdHash", "pwdhash", " pwdhash", "pwtHash", "pWHas", "pswHash"], "md": ["d", "m", "man", "mg", "ad", "cd", "material", "ld", " Md", "bd", "pd", "hd", "grad", " mm", "MD", "doc", "mm", "det", "desc", "od", "ind", "pm", "msg", "exec", "cond", " mc", "mod", "cmd", "dd", "red", "der", "df", "ng", "mail", "mem", " dd", "ms", "nd", "dig", "dir", "cmp", "td", "mc", "mt", "mn", "metadata", "add", "rm", "mp", "mk", "sm", "del", "sd", "def", "mo", "dm", "di", "mb", " mo", "ds"], "b": ["d", "m", "v", "batch", "bh", "l", "bis", "bas", "obj", "B", "y", "bu", "bar", "bp", "rb", "f", "ab", "bi", "abs", "ba", "bf", "br", "buff", "reb", "cb", "ib", "bytes", "fb", "be", "w", "gb", "bb", "bc", "eb", "binary", "g", "nb", "db", "mb", "sb", "bs", "a", "ob", "p"], "i": ["m", "v", "ip", "ci", "ui", "n", "multi", "yi", "in", "it", "ji", "l", "ei", "gi", "span", "I", "q", "phi", "us", "index", "ind", "im", "\u0438", "y", "oi", "ki", "ini", "li", "is", "io", "gu", "iu", "ii", "ski", "xi", "json", "bi", "u", "pi", "j", "ms", "init", "o", "iter", "cli", "ij", "ri", "next", "ai", "sim", "ti", "mi", "ix", "hi", "id", "di", "my", "a", "ic", "x", "si", "ie", "qi", "p"]}}
{"id1": "416857", "id2": "20128728", "code1": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"process": ["parse", "step", "create", "filter", "proc", "execute", "loop", "walk", "processor", "input", "exec", "accept", "load", "Process", "program", "scan", "work", "task", "check", "handle", "read", "update", "processing", " ingest", "output", "run", "display"], "dir": ["d", "http", "rect", "disk", "md", "cd", "html", "pkg", "dat", "data", "direct", "deg", "filename", "root", "rel", "desc", "doc", "folder", "det", "DIR", "directory", "dist", "dr", "ind", "window", "ir", "rot", "name", "mod", "loc", "prefix", "tar", "dd", "www", "str", "wd", "org", "vol", "dl", "src", "lim", "div", "old", "cur", "url", "file", "handle", "local", "mk", "fd", "start", "home", "log", "del", "direction", "id", "def", "host", "grad", "db", "tmp", "this", "addr", "lib", "out", "Dir", "txt", "orig"], "list": ["cache", "print", "null", "code", "record", "detail", "data", "listed", "test", "dict", "L", "string", "state", "array", "collection", "other", "dl", "file", "rm", "local", "range", "sort", "get", "tmp", "length", "select", "source", "v", "link", "index", "sequence", "stat", "copy", "ln", "word", "pre", "result", "config", "set", "ist", "spec", "see", "batch", "l", "re", "LIST", "split", "str", "cont", "queue", "write", "note", "now", "map", "def", "all", "match", "left", "history", "out", "ls", "tree", "line", "show", "filter", "chain", "status", "name", "table", "li", "details", "form", "number", "st", "old", "block", "single", "add", "names", "dump", "log", "lists", "delete", "this", "display", "lat"], "n": ["d", "m", "v", "ne", "l", "np", "network", "nan", "num", "no", "total", "na", "c", "name", "len", "nw", "un", "number", "ng", "count", "pi", "j", "nc", "nl", "N", "nn", "ln", "sn", "nr", "w", "nu", "names", "t", "nm", "nor", "norm", "ni", "g", "nb", "net", "ns", " N", "z", "p", "nt"], "bubblesort": ["bubbledorter", "gobbsorter", "robbledorts", "bubbsORT", "bubblingord", "bubblersort", "bubblorter", "bubblsort", "gobbleist", "robbledist", "gobblessort", "bubbleord", "robblesort", "bubblingorter", "gobblesorter", "bubblort", "bubbledord", "gobbsord", "bubblesorts", "bubblesORT", "gobbsORT", "bubbsord", "bubbleorter", "robbledord", "gobblingsort", "bubbledist", "robblessort", "bubblesist", "bubblesorter", "robbledsort", "bubblingorts", "bubblingORT", "gobbsort", "bubblerort", "bubbleist", "gobblesord", "bubbleort", "gobblesORT", "gobblesort", "bubbleserv", "gobblingerv", "bubblerorter", "bubbssort", "robbledorter", "bubblerord", "bubblingerv", "bubblingort", "gobbleorter", "bubbledort", "bubblingsort", "bubbledsort", "robblesorter", "bubblesord", "bubbledORT", "robbledort", "bubbsorter", "gobbleort", "bubbleorts", "gobblingort", "robblesorts", "bubblederv", "gobblesist", "bubbsorts", "bubbsort", "bubbledorts", "bubblerv", "gobblingorter", "robblesist", "bubblessort", "gobbleserv", "robblesord", "bubbsist"], "i": ["m", "in", "it", "record", "ei", "key", "q", "iri", "c", "y", "ini", "is", "io", "bi", "ity", "pi", "me", "init", "iter", "go", "mi", "ix", "exp", "hi", "to", "v", "ex", "index", "im", "oi", "ki", "ii", "u", "j", "eu", "id", "set", "fire", "ic", "I", "x", "xi", "z", "p", "uri", "ci", "ui", "batch", "l", "err", "ind", "iq", "iu", "ai", "sim", "s", "di", "si", "zi", "parent", "ij", "multi", "gi", "ami", "chain", "phi", "us", "li", "e", "cli", "ri", "point", "g", "ims", "this", "my", "ti", "ji", "qi"], "f": ["d", "b", "v", "m", "aff", "l", "fe", "fw", "h", "tf", "fab", "F", "elf", "c", "fi", "cf", "df", "fp", "fc", "bf", "fm", "fac", "fb", "sf", "af", "w", "file", "t", "fd", "fs", "lf", "fr", "p"], "img": ["inf", "orm", "m", "raw", "images", "md", "it", "html", "h", "obj", "tif", "window", "medium", "image", "im", "amp", "jp", "uf", "Image", "buf", "shr", "gif", "gm", "aug", "org", "ref", "j", "small", "src", "fm", "jpg", "og", "anim", "aj", "fig", "now", "imag", "fb", "url", "mp", "impl", "pic", "gb", "imgur", "picture", "good", "dm", "tmp", "mb", "png", "util", " im", "conv"], "whichcase": ["whethertest", " whichstring", "whoseCase", "howtest", "howrule", "howstring", "whorule", "whosecase", "whosematch", "whethercase", "wherecase", "whichCase", "wherecatch", "whopath", "whosetest", "whichspace", "whattest", "howmatch", " whichCase", "whostring", "howcase", "howchar", " whichmatch", "whotest", "whichrule", "whatrule", "whocase", "whatspace", "whichstring", "whatstring", " whichspace", "whichcatch", "whatcase", "whatcatch", "howCase", "whoCase", "howspace", "whichpath", "whatCase", " whichchar", "whosepath", "wheretest", "whethercatch", "whetherrule", "whatmatch", " whichpath", "whichtest", "whererule", "whereCase", "whichchar", " whichtest", "whichmatch", "wherematch", "whatchar", " whichrule"], "lastDigit": ["lastDiguster", "maxDigot", "lastDoubleit", " lastDigiter", " lastDigita", "maxDigit", "lastdigbit", "firstdiguster", "lastDiter", "lastdigiter", "firstdigiter", "lastdiguster", "lastHourit", "maxDigiter", "lastValbit", "lastHourbit", "lastPosit", "lastDoublebit", "lastPosot", "maxdigot", "firstDigit", "lastValiter", "maxdigiter", "maxdigit", "lastPosbit", " lastdigiter", "firstdigbit", "lastdigita", "firstdigi", "lastDoubleuster", "maxdigbit", "lastDigot", "lastDet", "lastdigi", "lastDit", "lastPosuster", "lastDiget", "lastdigot", "lastHourita", "lastDbit", "firstdigot", "firstdigit", "lastPosi", " lastdigbit", "lastDoublei", " lastdiget", "lastdigit", " lastDiget", " lastDigbit", "lastdiget", " lastdigit", "lastDigi", "lastDigiter", "firstDiguster", "firstDigi", "lastPositer", "maxDigbit", "lastValit", "firstDigot", "firstDigiter", "lastValet", "firstDigbit", "lastDigbit", "lastDigita", "lastHourot", " lastDigot"], "sorted": ["unsorted", "sorting", "Sorter", "unsort", " sort", "Sort", "insort", "insorter", "isorter", "unsorter", "isorting", " sorter", "insorted", "Sorting", " sorting", "sorter", "isort", "unsorting", "sort", "Sorted", "isorted", "insorting"], "temp": ["m", "Temp", "v", "fake", "test", " w", "base", "tem", " total", " t", " temporary", "porary", " v", "tim", "level", "w", "t", "mp", "local", "pre", " temperature", "emp", " tmp", "tmp", "stem", "buffer", "txt", "orig"], "tempp": ["compl", "timpps", "comple", "temple", "typl", "timpl", "typle", "timple", "typps", "compp", "tempps", "typp", "templ", "compps", "timpp"]}}
{"id1": "23677142", "id2": "8932510", "code1": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"BubbleSortShort2": ["BubbleSortShortTwo", "BubblesortShortTwo", "BubbleSortIntDouble", "BubblesortIntDouble", "BubblesortShort2", "BubbleSortIntTwo", "BubbleSortShortDouble", "BubblesortShortDouble", "BubbleSortshortDouble", "BubbleSortString4", "BubblesortShort4", "BubbleSortStringDouble", "BubbleSortshort2", "BubblesortInt4", "BubbleSortInt4", "BubbleSortShort4", "BubbleSortString2", "BubbleSortStringTwo", "BubblesortIntTwo", "BubbleSortInt2", "BubblesortInt2", "BubbleSortshortTwo", "BubbleSortshort4"], "num": ["m", "n", "dim", "cache", "zero", "mon", "val", "np", "dat", "alpha", "sum", "test", "missing", "nam", "na", "NUM", "mu", "msg", "im", "uf", "alph", "fn", "form", "comm", "nom", "number", "buf", "img", "tm", "bn", "snap", "rum", "um", "mem", "sam", "note", "save", "cmp", "con", "tim", "old", "hex", "dec", "mun", "check", "info", "mn", "add", "nu", "ums", "mat", "prim", "nm", "om", "coord", "update", "tu", "en", "pn", "get", "cal", "Num", "ver", "net", "txt", "eng", "nt"], "last_exchange": ["last_sexaction", "last_Exchange", "last_EXerence", "last_EXception", "last_Exception", "last_examine", "last_sexamine", "last_exactly", "last_nameamine", "last_xchange", "last_Exerence", "last_exaction", "last_elamine", "last_sexception", "last_pexactly", "last_exerence", "last_exechange", "last_elception", "last_exeception", "last_pexamine", "last_sexactly", "last_exvert", "last_elcessive", "last_xception", "last_elvert", "last_rxchange", "last_rxvert", "last_exevert", "last_xChange", "last_namechange", "last_ExChange", "last_execessive", "last_rxcessive", "last_xerence", "last_sexchange", "last_elaction", "last_EXamine", "last_EXaction", "last_pexception", "last_rxception", "last_nameactly", "last_elchange", "last_exception", "last_nameception", "last_exChange", "last_excessive", "last_EXchange", "last_EXChange", "last_pexchange"], "right_border": ["right_break", "rightflowgap", "rightflowborder", "right_index", "right_gap", " rightflowborder", " right_break", "right_order", "rightPostgap", " rightflowindex", "right_comment", " right_only", " right_order", "rightflowcomment", "rightPostborder", " right_index", "right_only", " right_comment", "rightPostcomment", "rightPostindex", " right_gap", "rightflowindex", " rightflowcomment", " rightflowgap"], "j": ["bj", "it", "ja", "key", "q", "user", "req", "c", "jp", "kj", "jump", "jit", "other", "je", "jl", "ix", "get", " n", "i", "o", "v", "n", "pos", "pt", "index", " J", "im", "jj", "u", "br", " ii", " dj", " Dj", "jen", "jc", "fr", "expr", "kid", " obj", "jack", "oj", "z", "p", "l", "js", "err", "server", "k", "journal", "ind", "f", "note", "og", "aj", "uj", "dj", "jet", "job", "__", "ij", "pr", "jo", "obj", "el", "adj", "jac", "json", "ret", "e", "er", "g", "J", "my", "ji"], "temp": ["kw", "Temp", "acc", "fake", "null", "comb", "dat", "test", "perm", "deg", "attr", "template", "base", "tem", "rem", "mod", " temporary", "porary", " Temp", "mem", "em", "alt", "tim", "fac", "cu", "ptr", "cum", "t", "mp", "dep", "pre", "result", "read", "tt", "unt", " tmp", "emp", "variable", "tmp", "buffer", "tc", "txt", "orig"]}}
{"id1": "3252116", "id2": "21999120", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMC1", "getmd1", "Getmd4", "getMC4", "Getmd10", "GetMD5", "getMD10", "getmd4", "getMC10", "getmd5", "GetMD4", "GetMD10", "getMD4", "getHash1", "getHash4", "getHash5", "getMD1", "GetMD1", "getMC5", "getmd10", "Getmd1", "getHash10", "Getmd5"], "source": ["b", "code", "secret", "null", "data", "SOURCE", "site", "target", "input", "ser", "string", "seed", "image", "template", "base", "c", "name", "sequence", "f", "style", "subject", "src", "sample", "e", "ource", "copy", "origin", "Source", "file", "from", "start", "content", "object", "output", "this", "message", "dest", "buffer", "text"], "s": ["ds", "b", " ans", "bes", "js", " returns", "ws", "parts", "ins", "p", "rs", "gets", "os", "S", "ss", "hs", "ads", "ends", "uns", "its", " sets", "abs", "eps", "cs", " ss", " outputs", "xs", "t", " streams", "ts", "sts", "es", "fs", "ses", "ats", " samples", "ings", " rs", " gets", "sb", " ts", "ps", "ies", "bs", "a", "ns", " ls", "gs", "ls", " fs", " es"], "hexDigits": ["hexDities", "exdigals", "hexdigists", " hexDigals", " hexDigities", "hexFunbits", " hexDigbits", "hexPosits", "hexdigities", "hexDigit", "exDigities", "hexPositions", "exDigals", "hexDigitions", "hexdigbits", "hexDists", "exdigits", "hexDits", " hexDigitions", "hexdigals", "exDigits", "hexFunals", "hexDigities", "hexDigbits", "hexDigists", "hexFunit", " hexDigists", "hexdigit", "exdigities", "exdigitions", "hexdigits", "hexPosals", "exDigitions", "hexDitions", "hexdigitions", "hexDigals", " hexDigit", "hexPosities", "hexFunits"], "md": ["d", "m", "amd", "ad", "cd", "ld", " Md", "bd", "pd", "hd", "grad", "MD", "desc", "mm", "det", "od", "dr", "ind", "cond", "mod", "cmd", "dd", "red", "der", "df", "pdf", "ms", "nd", "dig", "dh", "td", "mt", "mc", "mn", "add", "rm", "mk", "sm", "sd", "dm", "di", "mb", "de", "nt"], "tmp": ["comp", "Temp", "xy", "fake", "yy", "js", "np", "bis", "html", "pkg", "test", "proc", "obj", "ctx", "perm", "dirty", "up", "table", "sup", "bag", "img", "sp", "buff", "cb", "cmp", "bytes", "cur", "xs", "mp", "local", "etc", "tt", "qq", "emp", "params", "sym", "zip", "db", "nb", "mb", "temp", "txt"], "str": ["m", "b", "v", "n", "cast", "print", "list", "it", "cat", "tr", "ctr", "data", "Str", "obj", "string", "arc", "dr", "c", "name", "arr", "stri", "char", "ar", "buf", "vol", "ch", "cr", "sp", "e", "br", "st", "div", "txt", "hex", "cs", "iter", "STR", "w", "t", "sl", "sw", "set", "sc", "fr", "r", "gr", "out", "text", "p"], "k": ["K", "m", "d", "v", "n", "ks", "b", "kw", "l", "unk", "key", "h", "q", "ik", "kh", "c", "ikk", "ak", "kj", "tk", "sk", "f", "kar", "km", "j", "kk", "ko", "ka", "w", "ke", "t", "z", "mk", "id", "kl", "set", "ku", "ck", "kan", "ok", "g", "kt", "kid", "x", "kn", "p"], "i": ["o", "m", "ip", "n", "ci", "ui", "multi", "print", "ij", "in", "it", "ji", "gi", "chain", "phi", "index", "p", "status", "im", " j", "\u0438", "ini", "li", "ii", "io", "iu", "is", "bi", "pi", "j", "u", "conv", "x", "e", "me", "info", "cli", "ri", "ai", "sim", "mi", "ti", "ix", "hi", "inter", "di", "v", "ic", "I", "si", "xi", "qi", "zi"], "byte0": ["Byte1", "Byte140", "byte140", "byte3", "byte1", "Byte3", " byte140", "byte8", " byte8", "pixel6", "pixelElement", "node8", "channel140", "Byte0", "hex1", " byteElement", "pixel1", "Byte8", "byteElement", "channel3", "node2", "byte6", " byte6", "byte2", "hex0", "pixel0", "channel0", " byte3", " byte2", " byte1", "channel1", "Byte2", "node0", "hexElement", "node1", "hex6"]}}
{"id1": "13595251", "id2": "12783713", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"descargarArchivo": [" descargarMotive", " descargarRiv", " descargoArchico", " descargoMotivo", " descargarArchive", " descargarActivo", " descargarActico", " descargarRivo", " descargarArchiv", " descargarMotiv", " descargarActive", " descargarArchico", " descargoMotiv", " descargarRico", " descargoArchivo", " descargarMotico", " descargarMotivo", " descargoArchive", " descargoArchiv", " descargoMotico", " descargarRive", " descargarActiv", " descargoMotive"], "fis": ["dfiss", "ufos", " fris", "fiss", "ufis", "ffos", "fiix", "dfris", " fix", "dfis", " fios", "ffix", "ffiss", "ufris", "fix", " fiss", "ffios", "fios", "ufiss", "fiios", "Fos", "Fris", "ffris", "Fiss", "Fis", "ffis", "dfos", "fiis", "fiiss", "fris"], "fos": ["wbos", "infos", " foes", "infOS", " fbos", "foes", "fows", "fOS", "flaos", "floses", " fOs", " fows", "fedos", "wows", "vos", "woss", "infOs", "infbos", "voss", "woes", "lfbos", "fedOS", "wos", "lfoses", " foss", "lfaos", "vows", "foss", "fbos", "fOs", "flos", " fOS", "lfos", "woses", "fedOs", "foses", "waos", "fedbos", "voes", "faos", "flbos"], "inChannel": ["inputConnection", "inputChan", "InChan", "InButton", " inchannel", "InChannel", "inchannel", "innchannel", "inConnection", "innerChannel", "inChan", "outChan", "initConnection", "inputChannel", "aichannel", "innRow", "Inchannel", "outchannel", "inGray", "inButton", " inChan", "innerchannel", "inputGray", "initChannel", "aiRow", "outRow", "aiChan", "InGray", "aiChannel", "innerChan", "InConnection", "initChan", " inButton", "innChannel", "initGray", "inRow", "innerButton", "innChan"], "outChannel": ["outButton", "inConsole", "OUTChan", "inchannel", "OUTchannel", "inStream", "inChan", "outChan", "outchannel", " outchannel", "inButton", "outConsole", " outConsole", "OUTButton", "OUTConsole", "OUTChannel", " outChan", "outStream", "OUTStream", " outButton", " outStream"]}}
{"id1": "5977352", "id2": "22046596", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyfile", " cpFiles", " copyFolder", " copyFiles", "copyFiles", "cpFile", "cpfile", " cpFile", "cpFiles", " cpFolder", "cpFolder", "copyFolder", " copyfile"], "src": ["rest", "ctr", "pkg", "rl", "SOURCE", "sec", "rel", "ins", "input", "via", "ser", "req", "rs", "loc", "ipl", "cont", "img", "sys", "usr", "orig", "rc", "init", "st", "Source", "sf", "cur", "inst", "from", "start", "sit", "sc", "sb", "sr", "sq", "source"], "dest": ["comp", "rest", "null", "comb", "cat", "them", "source", "dat", " dst", "cp", "test", "target", "desc", "tif", "dist", "th", "self", "name", "loc", "decl", "Dest", "nw", "end", "nom", "cont", "trans", "usr", "est", "sp", "dir", "st", "none", "origin", "copy", "port", "opt", "mk", "result", "master", "etc", "del", "sit", "gt", "coord", "lit", "foreign", "spec", "good", "tmp", "tom", "de", "temp", "txt", "orig", "parent", "nt"], "bufSize": ["bcLen", "ufSIZE", "ufNum", " bufLen", " bufSIZE", "bcSIZE", "fontNum", "bufNum", "bcSize", "bufLen", "bufSIZE", "ufLen", " bufNum", "fontSIZE", "ufSize", " bufferSIZE", "bcNum", "fontSize", " bufferSize", " bufferNum"], "force": ["stall", "forced", "rule", "print", "command", "forcing", "use", "reset", "flag", "fill", "only", "raise", "base", "error", "fast", "cmd", "replace", "form", "f", "send", "Force", "co", "write", "safe", "draw", "forge", "check", " Force", "ce", "allow", "kill", "always", "auto", "require", "close", "quote", "enable", "default", "forces", "apply", "remote", "frame"], "buffer": ["batch", "cache", "print", "command", "Buffer", "memory", "paste", "window", "total", "limit", "template", "base", "shape", "table", "document", "sequence", "attribute", "queue", "buf", "number", "row", "device", "mem", "phrase", "sample", "buff", "comment", "stack", "block", "word", "library", "variable", "binary", "quote", "view", "message", "temp", "display", "history", "length", "frame", "text", "tree"], "read": ["parse", "raw", "print", " Read", "feed", "give", "need", "push", "record", "q", "pe", "input", "reading", "bind", "index", "reader", "fill", "ind", "req", "pass", "im", "load", "shape", "hold", "open", "end", "scan", "str", "row", "word", "reads", "count", "send", "valid", "write", "through", "request", "iter", "size", "check", "wait", "stream", "add", "w", "t", "next", "allow", "range", "connect", "start", "READ", "query", "set", "find", "get", "hello", "run", "r", "i", "before", "length", "Read", "height", "text", "readable", "len"], "in": ["inf", "o", "m", "n", "IN", "l", "inc", "it", "al", "inner", "cin", "ins", "doc", "input", "mm", "ind", "rin", "bin", "im", "up", "inside", "ini", "is", "In", "ar", "or", "isin", "co", "init", "con", "info", "iter", "ma", "irm", "check", "ln", "t", "gin", "from", "local", "include", "mi", "internal", "all", "en", "ain", "get", "inn", "per", "on", "sin", "ic", "din", "i", "ie", "cn", "source"], "out": ["o", "b", "n", "to", "v", "list", "conn", "cache", "l", "oss", "it", "ex", "inner", "sum", "flush", "cos", "obj", "OUT", "at", "one", "os", "up", "Out", "io", "ou", "oe", "aos", "writer", "client", "again", "end", "or", "cmd", "outer", "sys", "conv", "ch", "co", "write", "br", "ot", "con", "ln", "t", "mit", "file", "om", "ent", "gt", "can", "all", "op", "g", "output", "outs", "on", "ns", "net", "cn", "ne", "not", "nt"]}}
{"id1": "23666973", "id2": "13595251", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openStreamRAW", "openFileSimple", "openStreamSimple", "loadSteamSimple", "openResourceInternal", "openResourceSimple", "openSteamRaw", "loadSteamRaw", "openResourceRAW", "openSteamRAW", "openFileRAW", "openStreamInternal", "openSteamSimple", "loadStreamRaw", "loadStreamSimple", "openResourceRaw", "loadSteamRAW", "openFileRaw", "openFileInternal", "openSteamInternal", "loadSteamInternal", "loadStreamInternal", "loadStreamRAW"], "filename": ["ename", "wikipedia", "til", "whatever", "missing", "download", "string", "location", "directory", "journal", "username", "bol", "java", "name", "mson", "sequence", "prefix", "FILE", "description", "fn", "document", "fil", "river", "f", "LCS", "Filename", "fp", "subject", "sql", "mpeg", "src", "bf", "ame", "title", "jpg", "upload", "word", "println", "metadata", "file", "original", "nm", "nil", "lua", "kl", "initial", "ren", "png", "reference", "path", "message", "stem", "length", "txt", "uri", "source"], "stream": ["then", "list", "test", "loop", "collection", "head", "upload", "iter", "peer", "file", "local", "present", "impl", "sl", "get", "channel", "length", "source", "link", "feed", "input", "store", "transform", "load", "still", "open", "dd", "pod", "row", "sample", "mount", "next", "resource", "result", "read", "sw", "set", "console", "find", "content", "zip", "output", "pool", "buffer", "socket", "back", "body", "download", "reader", "response", " Stream", "shape", "cont", "export", "ssl", "valid", "context", "where", "check", "port", "iterator", "Stream", "message", "temp", "history", "ream", "parent", "http", "rest", "filter", "chain", "proc", "clean", "window", "status", "table", "wrapper", "trace", "form", "engine", "draw", "pipe", "stack", "sync", "old", "log", "view", "event", "poll", "control", "conv", "instance"], "url": ["browser", "http", "pl", "b", "link", "web", "l", "ll", "pkg", "rl", "rel", "call", "hl", "loc", "external", "char", "str", "ul", "mail", "ssl", "dl", "build", "ur", "nl", "bel", "mount", "URL", "resource", "file", "gl", "impl", "Url", "job", "sl", "kl", "fl", "cal", "r", "lr", "mb", "path", "ls", "uri"], "cl": ["pl", "sh", "ll", "lc", "rl", "dll", "ctx", "cle", "el", "CL", "hl", "c", "load", "decl", "cf", "ct", "comm", "ssl", "class", "fc", "dl", "lp", "ocl", "cr", "Cl", "com", "acl", "gl", "impl", "loader", "log", "ctrl", "lf", "kl", "fl", "sc", "ck", "scl", "cm", "cc", "tc"], "cn": ["css", "enn", "crow", "conn", "csv", "sen", "nan", "yn", "rn", "cin", "CN", "pan", "oul", "ern", "fn", "cf", "ct", "non", "gn", "aren", "bn", "cdn", "nc", "CNN", "ocon", "cap", "nn", "unc", "tun", "dn", "mn", "arn", "cv", "unn", "bean", "tan", "gc", "atten", "san", "tn", "osen", "can", "jc", "pn", "cm", "wn", "ns", "hn", "avan", "uan", "nic"]}}
{"id1": "647224", "id2": "8135072", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"uploadFile": ["saveImage", "uploadImage", "saveFile", "saveFiles", " uploadFiles", "putImage", "uploadFiles", " uploadfile", "savefile", "putFile", " uploadImage", "putFiles", "putfile", "uploadfile"], "inputFile": ["evalFILE", "inputPath", "InputFiles", "inputFILE", " inputFilename", "fromFILE", "infoFilename", "evalFile", "thisFile", "targetResource", "imgLine", "InputFile", "inputResource", "outputPath", " inputLe", " inputLine", "thisfile", "Inputfile", "imgLe", "evalResource", "inputOne", "fromResource", "fromFile", " inputPath", "thisLine", "updateLe", "inFILE", "inputfile", "outputLine", "inputLe", " inputOne", "outputfile", " inputfile", "fromField", "evalField", "infoFILE", "outputFiles", "thisPath", "updateLine", "inputField", "infoFile", "inputFilename", "imgOne", "inLine", "inFile", " inputFILE", "InputLine", "inputFiles", "inputLine", "infoLine", "targetField", "updateFile", "inFilename", " inputFiles", "targetFILE", "updateOne", "imgFile"], "targetFile": ["sourceFile", "TargetString", "detailDir", "targetFiles", "sourceFiles", "outputFolder", "targetDir", "sourcePath", " targetFilename", "TargetFiles", "targetString", " targetDir", "toFile", "detailString", "outputPath", "detailFile", "sourceDir", "toFolder", " targetPath", "detailFILE", "outputFilename", "TargetPath", "sourceFilename", " targetFILE", "sourcefile", "outputDir", "targetPath", "outputfile", "TargetFile", "targetfile", "targetDate", " targetDate", "tofile", "targetFolder", "outputFiles", "TargetDir", "sourceFolder", "toDir", " targetString", "targetFilename", "TargetFILE", "outputDate", "targetFILE", "sourceDate"], "outputFile": ["outDir", "outputStore", "sourceFile", "targetFiles", " outputfile", "sourceFiles", "outStyle", "putFile", "targetDir", "putfile", "outDo", "nullfile", "inputModel", "outputPlace", "outfile", "outputLog", " outputDo", " outputModel", " outputPlace", " outputFilename", "nullStyle", "outputStyle", "sourceDir", "removeFile", "noFile", "outModel", " outputFILE", "nullFile", "inputDir", "outFiles", "outputFilename", "inputfile", "noPlace", " outputDir", "sourcefile", " outputStore", " outputGe", "outputFILE", "outputDir", "outputfile", "targetfile", "inputLog", "outputModel", "outputGe", "outputDo", "nofile", "putGe", "outputFiles", " outputStyle", "outputDirectory", "inputFilename", "nullModel", " outputLog", "removeStore", "targetFilename", " outputDirectory", "inputDo", "outFile", "putPlace", "inputFiles", " outputFiles", "displayFile", "noGe", "displayStore", "removePlace", "targetDirectory", "displayPlace", "targetLog", "displayFILE", "inputDirectory", "targetModel", "removeFILE"], "in": ["inf", "IN", "l", "inc", "it", "al", "inner", "cin", "ins", "el", "input", "ro", "mm", "ind", "rin", "bin", "im", "inside", "ini", "is", "In", "io", "by", "ar", "ze", "act", "isin", "init", "con", "info", "iter", "mc", "ri", "ai", "read", "en", "ain", "inn", "on", "per", "like", "ic", "din", "i", "source"], "out": ["o", "report", "v", "n", "b", "print", "screen", "null", "IN", "err", "to", "it", "ex", "dis", "inner", "sum", "list", "cos", "obj", "res", "OUT", "at", "name", "os", "up", "Out", "io", "ou", "aos", "writer", "client", "by", "end", "outer", "sys", "we", "vol", "co", "write", "ot", "con", "and", "ln", "put", "println", "t", "s", "cache", "log", "auto", "can", "all", "console", "conf", "g", "output", "outs", "on", "net", "cn", "nt"], "line": ["entry", "rule", "code", "link", "command", "l", "record", "detail", "lin", "eline", "edge", "node", "chain", "label", "entity", "lo", "stroke", "field", "sequence", "row", "cell", "Line", "ine", "inline", "phrase", "nl", "sample", "comment", "column", "ide", "ln", "block", "word", "LINE", "lane", "range", "log", "query", "point", "lock", "message", "page", "frame"], "bytes": ["errors", "frames", "comes", "bes", "classes", "ices", "blocks", "times", "uses", "parts", "amples", "seconds", "lines", "bles", "gets", "bps", "gs", "odes", "xes", "cells", "les", "ends", "ows", "terms", "sofar", "oms", "files", "bits", "steps", "ites", "units", "rows", "tes", "books", "ales", "ips", "es", "lements", "otes", "outs", "ies", "values", "ges", "bs", "pages", "nets", "comments", "Bytes", "gments", "reads", "ls", "vals", "ones"]}}
{"id1": "4938100", "id2": "19322946", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"sha1": ["a256", "md256", "SHA1", "md3", "SHA2", "md2", "a1", "sha2", "sha3", "SHA3", "sha256", "a3", "SHA256", "a2", "md1"], "text": ["code", "print", "command", "pt", "source", "aut", "data", "body", "test", "q", "input", "string", "term", "ext", "msg", "template", "name", "document", "prefix", "TEXT", "password", "form", "ct", "str", "cont", "subject", "act", "context", "title", "comment", "word", "now", "w", "url", "value", "t", "pattern", "read", "tx", "content", "event", "output", "message", "path", "translation", "out", "x", "buffer", "Text", "txt", "select", "nt"], "UnsupportedEncodingException": ["UnsupportedChoderException", "UnsupportedEncoderException", "UnsupportedChodingException", "UnsupportedChoderEx", "UnsupportedEncodingError", "UnsupportedEncgorithmException", "UnsupportedEncodingEx", "UnsupportedEncgorithmEx", "UnsupportedEncgorithmError", "UnsupportedChoderElement", "UnsupportedChoderError", "UnsupportedEncgorithmElement", "UnsupportedEncoderEx", "UnsupportedChodingEx", "UnsupportedChodingError", "UnsupportedEncoderElement", "UnsupportedEncodingElement", "UnsupportedChodingElement", "UnsupportedEncoderError"], "md": ["d", "m", " ms", "mg", " cmd", "ad", "cd", " sd", " Md", "mand", "ld", "pkg", "bd", "ctr", "h", "pd", "hd", "grad", "MD", " mm", "mm", "det", " man", "od", "ind", " mc", "mod", "cmd", "mond", "dd", "red", "der", "df", " dd", "bf", "ms", "nd", "dir", "dh", "td", "mc", " rm", "mt", "mn", "add", "t", "mp", "rm", "mk", "sd", "dm", " df", "di", "mb", " mo", "sha", " cd"], "sha1hash": ["a1sum", "sha1result", "sha3hash", "sha81Hash", "shaonesum", "sha1sum", "sha1href", "sha1Hash", "sha3result", "sha81href", "sha3sha", "aonesha", "ha1hash", "aonehash", " SHA81href", "sha2Hash", "sha1hex", "sha5hash", "shaoneresult", "sha2hash", "aoneHash", "sha2sha", "sha5hex", "sha3href", "haonesha", "ha1result", "sha5sum", "a1sha", "haonehash", "shaoneHash", "haoneresult", "sha5sha", "sha81hex", "haonesum", "a1Hash", "sha5href", "sha3sum", "ha1sha", "sha81hash", " SHA81hash", " SHA1Hash", " SHA1hex", "sha3hex", "shaonesha", " SHA1hash", "sha5result", "sha3Hash", "sha1sha", " SHA81hex", " SHA1href", "sha2sum", "shaonehash", "ha1sum", "sha5Hash", "a1hash", "aonesum", " SHA81Hash"]}}
{"id1": "6871529", "id2": "884867", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"readUrlFile": [" readUrlStream", " readURLfile", "readPathPage", "readUrlPage", " readURLStream", "readurlStream", "readURLFile", "readUrlfile", "readURLStream", "readPathfile", "readURLfile", "readurlfile", " readUrlfile", "readurlPage", " readURLFile", " readURLPage", "readPathFile", " readUrlPage", "readURLPage", "readUrlStream", "readPathStream", "readurlFile"], "fullUrl": ["partialURL", "FullUr", "fulurl", "pathName", "FullName", "partialRoute", "fullRoute", "completeURL", "partialurl", "fulURL", "partialUrl", "Fullurl", "fulUrl", "completeUrl", "pathURL", "fulRoute", "fullurl", "FullURL", "pathUrl", "FullRoute", " fullurl", "fullName", "partialPath", "fullPath", " fullUr", "fullUr", " fullPath", " fullURL", " fullName", "pathUr", "fullURL", "completePath", "completeurl", "FullUrl"], "out": ["o", "report", "b", "to", "n", "print", "screen", "it", "ws", "flush", "us", "res", "OUT", "msg", "c", "os", "table", "Out", "io", "ou", "writer", "aos", "client", "json", "ch", "write", "w", "t", "file", "s", "log", "output", "outs", "pretty", "net", "txt", "p", "nt"], "url": ["browser", "http", "b", "link", "conn", "web", "l", "ll", "rel", "git", "base", "oul", "open", "google", "char", "client", "f", "str", "ul", "mail", "ssl", "dl", "ref", "build", "ur", "nl", "bel", "mount", "URL", "resource", "file", "service", "Url", "config", "sl", "job", "sb", "r", "path", "ls", "uri"], "encoding": ["encoder", "capping", "coded", "encapping", "rcryption", "rcoded", "rcaching", "Encryption", "Encaching", "ENCoder", "ENCoding", "coding", "encaching", "coder", "ENCapping", "ENCoded", "cryption", "Encapping", "caching", "Encoding", "Encoded", "encryption", "encoded", "rcoding", "Encoder"], "in": ["inf", "m", "IN", "l", "data", "inner", "cin", "sum", "body", "ins", "el", "input", "user", "reader", "ind", "rin", "bin", "In", "inside", "io", "f", "sql", "and", "info", "er", "stream", "file", "gin", "from", "id", "conf", "inn", "r", "din", "i", " din", "source"]}}
{"id1": "5061606", "id2": "7911686", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecessesed", "createSettingsIfNacessible", "createSettingsIfNacessesary", "createSettingsIfNacessesar", "createSettingsIfNecessed", "createSettingsIfNeccesary", "createSettingsIfNeccessible", "createSettingsIfNacessary", "createSettingsIfNeccessary", "createSettingsIfNecessar", "createSettingsIfNacessar", "createSettingsIfNeccesible", "createSettingsIfNeccesar", "createSettingsIfNeccesed", "createSettingsIfNecessible", "createSettingsIfNecessesible", "createSettingsIfNacessesed", "createSettingsIfNacessed", "createSettingsIfNeccessar", "createSettingsIfNecessesar", "createSettingsIfNeccessed", "createSettingsIfNecessesary", "createSettingsIfNacessesible"], "out": ["o", "report", "n", "to", "print", "conn", "null", "list", "it", "oss", "ex", "err", "server", "flush", "cos", "obj", "inv", "res", "OUT", "timeout", "that", "one", "yes", "cho", "os", "up", "Out", "ou", "io", "oe", "aos", "writer", "client", "again", "f", "end", "or", "outer", "bo", "sys", "conv", "ch", "co", "write", "note", "init", "ot", "comment", "con", "off", "ion", "w", "go", "t", "file", "gc", "log", "max", "ent", "exit", "can", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "fSettings": ["sfChanges", "bfChanges", " fsettings", "finalOptions", "fSetting", "fsettings", "cfSetting", "eSetting", "sfSetting", "fOptions", "fSetup", "cfSetup", "hSetting", "hsettings", "finalSettings", " fOptions", "sfOptions", " fSetting", "bfsettings", "bfSettings", "finalsettings", " fSetup", "sfsettings", "fChanges", "eSettings", "bfSetting", "sfSetup", "cfSettings", " fChanges", "finalSetting", "esettings", "hSettings", "sfSettings", "cfsettings"], "src": ["syn", "pkg", "rt", "rl", "filename", "root", "rel", "desc", "ser", "attr", "th", "rs", "loc", "rx", "fn", "cont", "img", "sys", "rc", "ur", "ls", "dir", "upload", "cur", "sf", "url", "resource", "sit", "config", "sc", "spec", "view", "sb", "tmp", "dest", "sr", "txt", "sq", "source"], "in": ["inf", "n", "IN", "l", "ad", "inner", "cin", "ins", "input", "vin", "rin", "bin", "In", "inside", "is", "isin", "init", "and", "info", "ln", "iter", "gin", "from", "id", "en", "inn", "sin", "r", "din", "i", " din", "source"]}}
{"id1": "10131427", "id2": "13657103", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", " copyStream", " CopyImage", " cpStream", "CopyStream", "CopyImage", " CopyStream", " cpFile", " cpImage", "Copyfile", "CopyFile", " copyImage", " CopyFile", " Copyfile", " copyfile"], "in": ["inf", "o", "b", "n", "IN", "l", "inc", "it", "cin", "ins", "el", "input", "mm", "ind", "vin", "rin", "up", "In", "is", "ar", "isin", "st", "old", "edIn", "gin", "from", "s", "en", "inn", "on", "r", "ic", "din", "i", "source"], "out": ["o", "b", "v", "n", "to", "l", "it", "ex", "oss", "err", "OUT", "os", "ou", "Out", "io", "str", "ch", "ot", "serv", "check", "w", "t", "file", "s", "help", "log", "gt", "output", "outs", "po", "net", "i", "ne", "nt"], "sourceChannel": ["inputConnection", "inputChan", " sourcechannel", "singleChuck", "ourceStream", " sourceStream", "matchButton", "matchChuck", "SourceConnection", "sourceChan", "srcchannel", "SourceStream", " sourceChain", "sourceButton", "matchChannel", "singleButton", "singleApplication", " sourceButton", "resourcechannel", "inputChannel", "seedChuck", "singleChannel", "ourceChan", " sourceConnection", "inputChain", "sourceChain", "ourceChannel", "ourceConnection", "seedApplication", "sourceConnection", "seedChannel", "sourceChuck", "Sourcechannel", "seedButton", "sourcechannel", "ourceButton", "resourceStream", "matchApplication", "resourceChannel", "ourcechannel", "srcChannel", "SourceChannel", " sourceChan", "sourceApplication", "sourceStream", "srcStream", "ourceChain", "resourceConnection", "srcButton"], "destinationChannel": ["destationChannel", "destinationsConnection", "DestationChan", "destinatoryCow", "destinationConnection", "DestensionClient", "destinatoryBlock", "destinationBlock", "DestensionChannel", "desticationBlock", "destinatedContext", "desticationChan", "destinationClient", "destinatoryChannel", "DestensionConnection", "desticationCow", "DestinationConnection", "DestationBlock", "destationCow", "destinationCow", "DestinationClient", "DestinationChannel", "destinationsChan", "destinatedChan", "destinatoryChan", "destroyChan", "DestinationCow", "destroyConnection", "desticationChannel", "destensionChannel", "DestinationContext", "destinationsContext", "destensionChan", "DestationCow", "destroyClient", "destroyChannel", "DestationChannel", "destinationContext", "destationBlock", "DestensionChan", "destationChan", "destinationChan", "DestinationBlock", "destinatedConnection", "DestinationChan", "destensionConnection", "DestationContext", "destationContext", "destinationsChannel", "destinatedChannel", "destationClient", "DestationConnection", "destensionClient", "destationConnection"]}}
{"id1": "22366505", "id2": "6371589", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"incluir": ["inclouar", "incluiator", "inCLuier", "incluar", "incluier", "inclouir", "inclUar", "inclUir", "inclouier", "inCLuator", "inclUator", "incluator", "incluiier", "inCLUier", "incluiar", "inclUier", "inclouator", "inCLUar", "inCLuir", "inCLuar", "inCLUir", "inCLUator", "incluiir"], "igreja": ["igrejas", "igcrej", " iggreji", " igcreJa", "igopenj", " igrejas", " iggreva", "iggreji", " igcrej", "igarrej", "igcreja", "iggrejas", "iggreva", "iggrej", "igvrej", "igvrejas", "iggreja", " iggrejas", "igreji", " igreva", "igarreJa", " igreJa", " igreji", "igarreji", "igreje", "igrej", "igarreva", "igopenja", "igcreji", "igreJa", "igarreja", "iggreJa", "igvreje", "igopenva", " igcreja", "igreva", " iggrej", "igopenji", " igcreji", " iggreja", "igarrejas", " igrej", " iggreje", "igvreja", "igarreje", " igreje", "iggreje", "igcreJa"], "connection": ["n", "to", "which", "link", "conn", "command", "condition", "socket", "generation", "settings", "network", "gate", "operation", "session", "function", "server", " Connection", "computer", "city", "user", "statement", "connected", "system", "database", "directory", "response", "Connection", "c", "document", "open", "language", "collection", "description", "client", "engine", "container", "context", "application", "section", "con", "setup", "position", "established", "manager", "connect", "ion", "resource", "library", "created", "config", "creator", "close", "query", "relation", "management", "component", "db", "reference", "message", "pool", "communication", "instance", "current"], "sql": ["pl", "plan", "csv", "command", "serial", "install", "xml", "pel", "q", "spr", "inv", "statement", "string", "expression", "ql", "seed", "template", "login", "table", "description", "cmd", "form", "sk", "sys", "sv", "dl", "nl", "title", "ln", "sf", "select", "url", "normal", "series", "log", "san", "sd", "SQL", "query", "spec", "sol", "scl", "zip", "lock", "shell", "sq"], "sql2": ["SQL4", "sd02", "sql1", "sql02", "SQL1", " sql1", "SQL2", "SQL3", " sql3", "SQL02", "ql1", "ql3", "sql4", "sql3", "sd2", " sql02", "sd3", "sd4", "ql2", "ql02", " sql4"], "stmt": [" stmm", "estm", "tmt", "STmb", " stmb", "STmn", "tmb", "Stmm", "estmt", "statMT", "stm", "StMT", "statm", "restmm", "statmt", "STm", "tmm", "statmn", "Ststat", "strm", " stmn", "STmm", "strMT", "stmb", " stm", "STMT", "Stmt", "reststat", "strmb", "ststat", "estmb", "stmm", "Stmb", "stmn", "strmt", "stMT", "estMT", " stMT", "Stm", "restmt", "tMT", "STmt", "restm", "Stmn", " ststat"], "stmt2": ["stMT1", "stmem3", "stmp3", "stmt1", " stMT02", "stMT2", "stmptwo", "sttx3", "stmem1", " stmttwo", "Stmem2", "stmp2", " stmp3", "stm1", "stmrtwo", "stmr2", "stm3", " stmtTwo", "stmpTwo", "stmtTwo", "stmem2", "stMT02", " stmt02", "stMTtwo", "sttm3", "StmemTwo", " stmptwo", "stmttwo", "stmr1", "StmtTwo", "stmTwo", "stmp1", "Stmt1", "Stmem1", "Stmem3", " stMT3", "stmt3", "sttm4", "stMTTwo", " stmt1", " stmt3", " stmpTwo", "Stmt2", "stm02", "sttx1", "stmp4", "sttmTwo", "stmt02", "stmemTwo", "stmt4", "stMT4", " stmp2", " stmp1", "stm2", " stmt4", "sttx02", " stMT2", " stMT1", "sttm2", " stmp4", "sttx2", "Stmt3", "stMT3", "stmr4"], "rs": ["ks", "RS", "ris", "js", "ws", "rt", "qs", "ins", "res", "rd", "ss", "hs", "its", "vers", "ows", "ras", "vs", "eps", "usr", "rc", "ms", "rows", "ys", "ars", "cs", "results", "pers", "xs", "rates", "s", "sts", "Rs", "ts", "ats", "fs", "mr", "rss", "rys", "ims", "ps", "r", "bs", "ns", "ds", "gs", "ls", "sr", "ros"], "retorno": ["altano", " retorne", "montorno", "montorne", "eltorno", "montrero", "gotora", "gotorno", "retogo", "eltogo", "gotorne", "eltorn", "retorne", " retano", "gotrero", " retrero", "retora", " retorn", "retano", "altogo", "montora", " retogo", "altorn", " retora", "eltano", "retrero", "altorno", "retorn"]}}
{"id1": "9796161", "id2": "22752444", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"getMD5": ["getmd2", "getSHA7", "toSHA2", "toSHA7", "getmd4", "getSHA4", "getMD2", "getmd5", "getMD4", "getMD7", "toMD2", "toMD4", "getSHA5", "getmd7", "toSHA5", "toMD7", "getSHA2", "toSHA4", "toMD5"], "s": ["b", "n", "v", "strings", "l", "js", "ws", "space", "data", "h", "ins", "aws", "string", "rs", "gets", "c", "os", "y", "S", "is", "ss", "its", "f", "ends", "str", "abs", "sv", "sql", "src", "ms", "ls", "bytes", "xs", "t", "sts", "ts", "es", "ats", "ses", "fs", " gets", "g", "sb", "ps", "ies", "bs", "i", "ns", "gs", "text", "sq", "p", "source"], "m": ["man", "v", "l", "md", "h", "perm", "mm", "mu", "pm", "mac", "M", "y", "rem", "mod", "tm", "gm", "mut", "ms", "fm", "me", "e", "em", "mc", "mt", "manager", "managed", "am", "rm", "mask", "mk", "sm", "nm", "om", "mr", "mi", "vm", "hm", "bm", "cm", "dm", "g", "mo", "made"]}}
{"id1": "18544890", "id2": "2217889", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"get": ["cache", "print", "list", "create", "show", "post", "call", "download", "Get", "gets", "pull", "getting", "api", "GET", "draw", "info", "put", "search", "game", "range", "read", "query", "all", "match", "stats", "run"], "url": ["http", "pl", "rect", "link", "web", "l", "html", "ll", "rl", "xml", "address", "hub", "q", "string", "location", "hl", "lb", "base", "str", "ul", "mail", "api", "dl", "ssl", "ret", "build", "ur", "nl", "ref", "domain", "mount", "URL", "file", "game", "Url", "sl", "id", "host", "addr", "path", "uri"], "lat": ["Lat", "ip", "att", "rect", "apt", "pos", "xy", "pt", "rt", "wp", "dist", "at", "y", "loc", "area", "sat", "south", "ct", "str", " latitude", "grid", "top", "st", "alt", "feat", "mat", "sta", "ats", "coord", "kt", "addr", "west", "x", "height", "sq"], "lon": ["elong", "n", "lt", "pos", "l", "ll", "lin", "los", "lang", "itude", "location", "geon", "loc", "phy", "fn", "ng", "top", "ong", "lu", "lay", "ino", "ln", "zon", "local", "lol", "mag", "lf", "low", "vert", "on", "west", "land", "las", "x", "lbs", "len"], "count": ["n", "batch", "code", "list", "cache", "num", "more", "amount", "sum", "found", "call", "index", "total", "th", "limit", "cond", "c", "ct", "frequency", "number", "top", "score", "Count", "size", "counter", "search", "last", "range", "start", "max", "ount", "id", "nb", "scroll", "page", "length", "current", "nt"], "req": ["comp", "http", "forced", "rest", "pr", "err", "pkg", "resp", "q", "proc", "rel", "cgi", "inv", "res", "wx", "desc", "dist", "rd", "ind", "quick", "reg", "rx", "aux", "quest", "jp", "requ", "pull", "cmd", "friend", "cert", "client", "sem", "comm", "usr", "org", "j", "sql", "compl", "send", "init", "request", "pas", "https", "cur", "qt", "forge", "urg", "peer", "Request", "search", "crit", "uj", "mk", "next", "rr", "dj", "require", "qq", "tx", "fr", "htt", "sub", "hr", "repl", "conf", "typ", "r", "ps", "gr", "fail", "Requ", "sq"], "gl": ["pl", "list", "l", "lor", "ll", "rl", "rel", "tf", "bal", "als", "hl", "GL", "ogl", "gold", "balls", "il", "gn", "gm", "gif", "dl", "gall", "nl", "ger", "spring", "wal", "Gl", "bel", "tl", "acl", "illas", "gc", "abl", "jl", "wl", "ml", "lol", "vl", "sl", "gel", "gb", "fl", "cl", "console", "igl", "g", "ibl", "bl", "gr", "gz", "gs", "ls"], "br": ["browser", "b", "BR", "pr", "bh", "tr", "ber", "wr", "el", "yr", "dr", "bt", "kr", "arr", "rb", "bp", "shr", "buf", "bi", "str", "ch", "cr", "bg", "sp", "bro", "er", "be", "mr", "vr", "FR", "fr", "hr", "bl", "bm", "lr", "r", "gr", "sr", "Br"], "line": ["entry", "n", "rule", "code", "link", "print", "l", "lin", "eline", "header", "edge", "body", "chain", "el", "label", "user", "string", "msg", "lo", "stroke", "sequence", "error", "trace", "style", "str", "cell", "row", "Line", "ine", "inline", "stay", "valid", "phrase", "note", "e", "sample", "liner", "comment", "ln", "block", "iter", "check", "word", "stream", "le", "LINE", "file", "lane", "range", "log", "train", "point", "console", "message", "page", "display", "channel", "frame", "text"]}}
{"id1": "20519261", "id2": "7149578", "code1": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 0, "substitutes": {"readReferenceText": ["getreferenceText", "readReftext", "getreferenceForm", "readRefMessage", "readRefForm", "getReferenceText", "readLinkMessage", "readreferencetext", "readRefText", "readreferenceText", "readreferenceMessage", "readReferenceForm", "getreferenceMessage", "readLinkText", "getreferencetext", "readReferencetext", "getReferencetext", "readReferenceMessage", "readLinkForm", "readreferenceForm", "readLinktext", "getReferenceForm", "getReferenceMessage"], "ident": ["filename", "instance", "via", "det", "location", "term", "string", "ind", "Ident", "unknown", " identifier", "mod", "loc", "urn", "person", "password", "imp", "row", "text", "sql", "context", "common", "tim", "hex", "word", "inst", "intent", "feat", "local", "prim", "log", "ent", "id", "coord", "match", "spec", "event", "addr", "IDENT", "util", " identify", "idents"], "name": ["n", "named", "Name", "NAME", "key", "data", "filename", "label", "string", "location", "base", "prefix", "type", "str", "alias", "mem", "ame", "me", "title", "comment", "version", "word", "search", "names", "file", "resource", "format", "nm", "id", "path", "family", "text", "source"], "url": ["browser", "http", "pl", "b", "link", "web", "l", "ll", "html", "rel", "location", "hl", "lb", "base", "loc", "li", "ul", "mail", "ssl", "dl", "ref", "ur", "nl", "bel", "mount", "URL", "gl", "file", "resource", "log", "Url", "sl", "r", "lr", "ls", "uri"], "in": ["inf", "n", "null", "IN", "l", "inc", "data", "inner", "cin", "body", "ins", "input", "reader", "ind", "dr", "rin", "bin", "In", "is", "f", "str", "info", "iter", "irm", "ri", "stream", "mn", "file", "from", "inn", "r", "on", "ic", "out", "din", "i", " din"], "isr": [" isrs", "ispr", "osr", " iser", "ISrc", "issr", "osrs", "ospr", "aisr", "aiser", "ISr", "isrc", " ispr", "isser", "isrs", "aisrs", "iser", " isrc", "aisrc", "ISer", "oser", "ISrs", "issrs", "isspr"], "br": ["browser", "b", "BR", "pr", "bh", "tr", "bd", "ber", "wr", "yr", "adr", "dr", "bt", "rb", "bp", "shr", "buf", "bi", "bf", "cr", "bro", "nr", "be", "mr", "vr", "bc", "fr", "hr", "bm", "bl", "r", "lr", "gr", "bs", "sr", "Br", "bridge"], "buffer": ["menu", "batch", "cache", "print", "null", "Buffer", "command", "screen", "black", "memory", "window", "total", "database", "template", "base", "bone", "button", "document", "sequence", "builder", "bar", "table", "collection", "trace", "buf", "row", "queue", "bo", "phrase", "append", "buff", "comment", "iter", "block", "escape", "profile", "library", "console", "binary", "quote", "bm", "output", "sb", "message", "pool", "temp", "channel", "length", "ob", "join", "bridge"], "line": ["entry", "code", "ne", "print", "link", "l", "detail", "lin", "source", "header", "eline", "body", "chain", "label", "no", "string", "lines", "stroke", "sequence", "len", "email", "char", "number", "row", "cell", "Line", "ine", "inline", "online", "stay", "nl", "sample", "liner", "comment", "where", "ln", "block", "position", "zone", "iter", "next", "le", "LINE", "range", "log", "member", "point", "lined", "lock", "message", "page", "length", "frame", "text"]}}
{"id1": "5951610", "id2": "21016435", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["TestNetworkHTML", "testApplicationURL", "testApplicationHTTP", "testNetHTML", "testNetworkHTML", "TestNetHTTP", "testNetURL", "TestNetworkURL", "testNetHTTP", "testApplicationHTML", "TestNetURL", "TestNetHTML", "TestNetworkHTTP", "testNetworkURL"], "url": ["http", "m", "b", "pl", "link", "print", "lt", "web", "l", "conn", "back", "ll", "html", "rl", "address", "rel", "obj", "el", "location", "term", "hl", "lb", "base", "loc", "pull", "cert", "email", "www", "str", "il", "mail", "ul", "ssl", "dl", "u", "org", "ref", "ur", "nl", "ocl", "ret", "mount", "https", "URL", "acl", "resource", "t", "gl", "impl", "log", "norm", "ml", "Url", "sl", "cl", "all", "fl", "github", "bl", "get", "host", "console", "r", "lr", "path", "util", "channel", "blog", "ls", "uri"], "urlConnection": ["implConnector", "lsConn", "utilConnection", "dbPosition", "sslConnection", "httpHandler", "lrResponse", "emailConnector", "emailConnect", " urlPosition", "nameConnection", "sslConnect", "lrConnector", "sslPosition", " urlMachine", "methodConnection", "urlHandler", "managerInfo", " urlInfo", "dbConnect", "urlConnect", "resourceConnection", "mlConnection", "emailConn", "httpListener", "urlService", "urlDiscussion", " urlConnect", "nameConnector", "railHandler", "urlCon", " urlListener", "browserConnection", "urlConnector", " urlDiscussion", "lsConnect", "urlSet", "fileConnection", "mlMachine", "sslConnector", "managerConnect", " urlHandler", "browserConnect", "implConnect", "urlConn", "urlResponse", "httpConn", "httpSet", "methodConnector", " urlResponse", "httpConnector", "fileDiscussion", "nameConnect", "nameConn", "consoleMachine", "consoleConn", "httpConnection", "lsConnector", "lsConnection", "managerConnection", "railListener", " urlService", "utilConn", "methodConnect", "mlConn", " urlConn", "resourceConnector", "lrConn", "utilSet", "httpService", " urlSet", "fileConnect", "dbConn", "mlCon", "consoleConnection", "lrConnection", "utilConnect", "urlInfo", "implConnection", "sslConn", "fileConn", "utilListener", "consoleCon", "urlListener", "railConnect", "sslDiscussion", "httpConnect", "implConn", "managerConnector", "urlMachine", "utilService", "emailConnection", "railConnection", "resourceConn", "utilConnector", "browserConnector", "methodConn", "httpInfo", " urlConnector", "urlPosition", "resourceResponse", "browserConn", " urlCon", "dbConnection"], "rd": ["d", "rw", "RD", "ld", "rax", "nder", "rn", "rt", "rl", "rob", "bd", "grad", "wr", "gd", "rh", "rend", "adr", "dr", "std", "ind", "rs", "ded", "rx", "rand", "rb", "rod", "rown", "dd", "rer", "red", "ered", "ped", "usr", "rus", "rc", "nd", "dig", "dir", "dra", "ptr", "rez", "ri", "rid", "rm", "rr", "fd", "mr", "ined", "ird", "erd", "xd", "drm", "fr", "hr", "rg", "ck", "repl", "r", "lr", "ord", "ra", "art", "din"], "line": ["entry", "link", "continue", "time", "l", "record", "lin", "eline", "edge", "node", " LINE", "loop", "string", "lines", "status", "lo", "load", "error", "len", "email", "side", "number", "row", "inline", "Line", "ine", "cell", "stay", "nl", "liner", "comment", "where", "column", "pipe", "none", "ln", "block", "iter", "zone", "port", "next", "le", "LINE", "file", "check", "range", "log", "part", "ice", "set", "point", "cl", "lock", "message", "page", "LIN", "channel", "length", "buffer", "frame", "online"]}}
{"id1": "7351534", "id2": "10385815", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSystemIdentifer", "getStreamFromSystemIdifer", "getStreamFromSystemIdentification", "getStreamFromSysidentifer", "getStreamFromSysidentifier", "getStreamFromSystemIdification", "getStreamFromSysIdentifier", "getStreamFromSysIdentifiers", "getStreamFromSystemidentifiers", "getStreamFromSysidentification", "getStreamFromSystemidentifer", "getStreamFromSysIdentification", "getStreamFromSystemIdentifiers", "getStreamFromSystemidentifier", "getStreamFromSysIdentifer", "getStreamFromSysidentifiers", "getStreamFromSystemIdifiers", "getStreamFromSystemIdifier", "getStreamFromSystemidentification"], "systemId": ["systemDoes", "cmsDoes", "publicById", "cmsMid", "publicMid", "systemid", "localhostId", "serverid", " systemName", "cmsId", "systemID", "humanIs", "humanID", "localhostDoes", "systemStart", "ystemIn", "serverId", "humanDoes", "sysById", "cmsStart", "ystemid", "ystemId", "systemIn", "humanById", "sysIs", "sysID", "ystemMid", " systemById", "sysId", "humanStart", "systemById", "serverById", "publicId", "humanMid", "ystemById", "serverIn", "publicName", "localhostStart", "systemIs", "localhostMid", "systemName", "systemMid", " systemMid", "ystemID", "publicIn", "ystemIs", "humanId", "publicid", "ystemName"], "resolver": ["resolution", "rsolution", "persolver", "persolved", "resolved", "reolved", "reolve", "persolution", "perslove", "resolutionolution", "reolver", "reerver", "reolving", "reanger", "rserver", "persolve", "resolutionolving", " resolved", "resolving", " reserver", "reserver", "rsolver", "reslove", "resolutionlove", "rsanger", "resanger", "persolving", "reolution", " resanger", " resolution", "resolutionolver", "resolve", "relove", " resolve"], "source": ["rule", "raw", "null", "create", "cause", "inner", "SOURCE", "node", "site", "missing", "target", "input", "store", "system", "ser", "reader", "via", "seed", "image", "status", "string", "template", "base", "response", "table", "sequence", "attribute", "style", "channel", "subject", "sql", "unit", "context", "src", "scope", "sample", "sp", "force", "init", "parent", "ource", "copy", "origin", "Source", "peer", "ce", "proxy", "resource", "file", "from", "service", "iterator", "se", "local", "series", "result", "storage", "console", "spec", "relation", "supp", "component", "get", "object", "shell", "remote", "instance", "uri"], "stream": ["cache", "null", "data", "test", "loop", "hold", "trans", "upload", "peer", "file", "present", "impl", "channel", "length", "feed", "input", "load", "sequence", "open", "pod", "row", "sample", "mount", "REAM", "next", "resource", "result", "read", "progress", "sw", "console", "content", "object", "zip", "output", "pool", "buffer", "batch", "socket", "body", "download", "reader", "response", "shape", "our", "cont", "export", "ssl", "valid", "port", "iterator", "complete", "encrypted", "Stream", "message", "temp", "out", "ream", "http", "proc", "chain", "clean", "window", "wrapper", "form", "pipe", "stack", "sync", "log", "poll", "control", "instance"], "url": ["browser", "http", "b", "link", "null", "web", "l", "back", "ll", "rl", "address", "key", "rel", "system", "location", "window", "term", "hl", "external", "char", "f", "ul", "mail", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "bel", "mount", "URL", "resource", "gl", "service", "Url", "job", "sl", "r", "ls", "uri"]}}
{"id1": "5872038", "id2": "8665321", "code1": "    public void parse() throws ParserConfigurationException, SAXException, IOException {\n        DefaultHttpClient httpclient = initialise();\n        HttpResponse result = httpclient.execute(new HttpGet(urlString));\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        if (spf != null) {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(result.getEntity().getContent(), this);\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"parse": ["report", "scale", "print", "create", "xml", "call", "value", "parser", "p", "process", "transform", "load", "shape", "document", "pack", "render", "php", "send", "build", "save", "request", "patch", "next", "url", "format", "complete", "handle", "service", "eval", "se", "dump", "start", "interpret", "read", "pp", "query", "update", "apply", "python"], "SAXException": ["SAVFailure", "SAXPException", "SAXPception", " SAXFailure", " SAXPException", "SAHFailure", "SAHException", "SAVException", " SAXPception", "SAVception", " SAXception", "SAXFailure", "SAXception", "SAXPFailure", " SAXPFailure", "SAHception"], "IOException": ["ConnectionException", " IOFailure", "StreamProblem", "ConnectionFailure", "IOFailure", "StreamException", "IOProblem", "StreamFailure", " IOProblem", "ConnectionProblem"], "httpclient": ["hClient", "hconnection", "ttpcon", "httpserver", "httpsconnection", "httpClient", "httpscon", "httpsClient", "hclient", "ttpClient", "ttpserver", " httpconnection", "ttpclient", "httpsclient", " httpserver", "httpsserver", " httpClient", " httpcon", "httpconnection", "httpcon"], "result": ["su", "report", "record", "dat", "Result", "data", "proc", "memory", "res", "date", "response", "status", "answer", "table", "description", "cup", "client", "RESULTS", "request", "true", "cur", "results", "now", "successfully", "profile", "created", "successful", "make", "success", "there", "event", "output", "this", "message", "page", "the", "current"], "spf": ["picf", "spfc", "lpf", "ipF", "ispfx", "pscf", "psF", "ipfi", "psfi", "ospFactory", "lpFactory", "ispfc", "lpfx", "spfi", " spfp", "opfi", "ipcf", "spfac", "aspfac", "spFactory", "opf", "picfp", "spcf", "psf", "opF", "spfx", "spF", "opcf", "lpfc", "aspfp", "picfac", "ipf", " spfac", "ospfx", "ospf", "spfp", "ispf", "ispFactory", "ospfc", "aspf"], "sp": ["osp", "pb", "pl", "sh", "pr", "pt", "ap", "esp", "pd", "SP", "spr", "pe", "asp", "jp", "bp", "spe", "sk", "tp", "Sp", "sv", "lp", "so", "sam", "pc", "isp", "spl", "se", "pic", "bsp", "sm", "pp", "ph", "sl", "sc", "op", "ps", "ep", "sq", "p"]}}
{"id1": "19549489", "id2": "5061606", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" Copy", " duplicate", "csv", "cat", "cp", "create", "download", "paste", "Copy", "transfer", "load", "replace", "export", " cp", "write", "save", "upload", "move", "clone", "sync", "add", "rm", "map", "read", "delete", "Cop", "slice", " mirror"], "sourceFile": [" sourcePage", "Sourcefile", " sourcefile", "ourceFilename", "ourceFile", "sourcePage", " sourceLine", "ourceLine", "inputFile", "SourceFilename", "inputfile", "sourceFilename", "sourcefile", "SourceLine", "inputPage", "ourcefile", "SourcePage", "inputLine", "ourcePage", " sourceFilename", "sourceLine", "SourceFile"], "destinationFile": ["estinatedFilename", "destinationsFilename", "estinatedFile", "estinationfile", "declinatorPath", "declinationPlace", "destinatePlace", "destrativePlace", "destinationfile", "destinationsfile", "estinationPlace", "destinatedFile", "declinatorFile", "destinationsFile", "destinatorPath", "destinoFilename", "destinofile", "destinationPlace", "destinationPath", "destinatorFilename", "destinatedfile", "declinationFile", "destrativePath", "destinateFilename", "declinationPath", "destinationsPlace", "estinationFilename", "destinatorFile", "destrativeFile", "destinatePath", "destinoPlace", "declinationFilename", "declinatorPlace", "estinationFile", "destinatedPlace", "declinatorFilename", "destinateFile", "destinationFilename", "estinatedPlace", "estinatedfile", "destrativeFilename", "destinatorPlace", "destinoFile", "destinatedFilename"], "sourceFileChannel": ["sourceLineChannel", " sourceFileChuck", "sourceLinechannel", "sourceFileConnection", "sourceFileApplication", "sourceFileChan", "srcBlockConnection", "ourceFileChan", "sourceStreamChannel", "sourceBaseChuck", "ourceEntryChan", "srcBlockchannel", "ourceEntryConnection", "sourceFileHandler", "sourceStreamChan", "sourceStreamApplication", "sourceEntryChannel", "sourceBlockConnection", "srcBlockEntry", " sourceFileHandler", "sourceFileEntry", "sourceBaseApplication", "sourceBaseHandler", "ourceFileChannel", "sourceBytechannel", "sourceEntryChan", "sourceByteConnection", "sourceBlockEntry", "sourceStreamConnection", "srcBlockChannel", "ourceFilechannel", "sourceByteEntry", "sourceEntryConnection", "sourceStreamchannel", "sourceBlockchannel", "sourceBaseChannel", "srcFileConnection", "sourceByteChannel", "ourceEntrychannel", "sourceLineConnection", "ourceFileConnection", "sourceLineChan", "srcFileChannel", "sourceBlockChannel", "srcFilechannel", "sourceLineEntry", "sourceEntrychannel", "sourceStreamHandler", " sourceFileApplication", "sourceFileChuck", "ourceEntryChannel", "srcFileEntry", "sourceFilechannel", "sourceStreamChuck"], "destinationFileChannel": ["destmentResourcechannel", "destinationFilesChan", "destinatorFilesConnection", "destinationFileConnection", "destmentPageContext", "destinationDirectorychannel", "destinationfileChannel", "destinationfilechannel", "destinationChannelContext", "destinationFileChan", "destinationChannelChan", "destinatorFilesCh", "destmentFilechannel", "destinationfileEntry", "destinationFilesConnection", "destmentPageChan", "destmentFileManager", "destinationfileContext", "destinationFileManager", "destinationResourcechannel", "destinatorFilesChan", "destinationPageEntry", "destinationFilesCh", "destmentFileContext", "destinationfileChan", "destinationDirectoryChan", "destinationDirectoryManager", "destinationFileEntry", "destinationFileCh", "destinationFilechannel", "destmentFileChan", "destinationChannelConnection", "destmentPageEntry", "destmentPageChannel", "destinationResourceChan", "destinatorFileChan", "destmentResourceChannel", "destinatorFileChannel", "destinationChannelChannel", "destinatorFileCh", "destinationfileManager", "destinationResourceManager", "destmentFileChannel", "destmentResourceChan", "destinationPageChan", "destinationPageContext", "destmentFileEntry", "destinationfileConnection", "destinationFileContext", "destinationChannelCh", "destmentResourceManager", "destinationFilesChannel", "destinationChannelEntry", "destinationPageChannel", "destinatorFileConnection", "destinationDirectoryChannel", "destinationResourceChannel", "destinatorFilesChannel", "destinationfileCh"]}}
{"id1": "9647576", "id2": "6371580", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"Reserve": ["Servation", "Resolve", "Conserve", "reserve", "reservation", "Reservation", "Solve", "reserved", "Conservation", "resolve", "Serve", "Served", "Conserved", "Consolve", "Reserved"], "stbookings": ["Stbookings", "Stbooksies", "stbooksing", "Stbookers", "Stbooking", "stbindings", "stbooksings", "stbooking", "stbinding", "stbooksies", "Stbooksing", "Stbookies", "stbookers", "Stbooksers", "Stbooksings", "stbinders", "stbookies", "stBookers", "stBookies", "stbindies", "stBookings", "stBooking", "stbooksers"], "stchartwl": ["STchartwal", "STChartwal", "stchartbook", "stChartbook", "STChartwl", "stplotml", "stChartml", "stChartwal", "stchartml", "STChartbook", "stplotwal", "STchartbook", "stplotwl", "stChartwl", "STchartml", "stpagewl", "stchartwal", "stplotbook", "stpageml", "STChartml", "stpagebook", "stpagewal", "STchartwl"], "sp": ["osp", "pb", "sh", "yp", "pt", "ap", "sil", "esp", "space", "policy", "cp", "SP", "spr", "pe", "sy", "asp", " esp", "jp", "ss", "spe", "sk", "tp", "Sp", "sv", "vol", "lp", "scope", "so", "st", "isp", "sf", "service", "se", "sm", "bsp", "pp", "sw", "sc", "pol", "sb", " SP", "ps", "si", "p"], "userbooksql": ["userbookssql", "agentbookssql", "userbooksQL", "userbindql", "userooksql", "usertypesqs", "usertypessql", "userooksels", "userscriptsql", "userbookQL", "userbookql", "userpagesQL", "usertypesql", "userreadsql", "userscriptsels", "userBooksquer", "userreadsqs", "userbooksels", "userbooksSQL", "userbysquer", "userooksqs", "clientreadsqs", "userscriptselly", "userpagesqs", "userbindsql", "userbyssql", "userbindSQL", "userbookqs", " userbooksSQL", "userpagesql", " userbindsql", "userbysSQL", "clientbooksql", "userBookssql", " userbindquer", "userbookselly", "clientreadselly", "userpagessql", " userbooksquer", " userbindSQL", "agentpagessql", "userreadsels", "agentbooksqs", "userbindquer", "agentpagesqs", "userookselly", "userBooksSQL", "clientbooksqs", "agentpagesQL", "clientreadsels", " userbindql", "userbysql", "agentpagesql", "userBooksql", "clientbooksels", "clientreadsql", "clientbookselly", " userbookssql", "userbooksquer", "userscriptsqs", "userreadselly", "usertypesQL", "agentbooksQL", "userbooksqs"], "agentbooksql": ["agentbookquer", "agentbooksqu", "agentbookssql", "agentletsql", " agentBooksql", "ownerbeansquer", "agentletsquer", "agentletsqu", " agentbookili", " agentbookql", "agentBookssql", "agentBooksqu", "agentbeansili", "agentBooksql", "agentbookili", "agentiquesquer", "agentbookQL", "ownerbooksQL", "agentbeansQL", " agentBooksquer", "agentBooksili", "agentBooksQL", "agentbeansquer", "agentpagesili", "agentletssql", "ownerbeansQL", " agentBookssql", "agentiquesqu", "agentbooksili", "ownerbooksili", "agentiquesQL", " agentbooksqu", "agentiquessql", " agentbookQL", "agentbookql", " agentbooksquer", "ownerbeansili", " agentBooksqu", "ownerbooksql", " agentbookssql", "agentbeansql", "agentpagessql", " agentbooksQL", "agentiquesql", " agentbooksili", "agentpagesQL", "ownerbeansql", "agentpagesql", "ownerbooksquer", "agentbooksquer", "agentiquesili", "agentBooksquer", "agentbooksQL"], "bookingid": ["bookingingids", "bookillingID", "BookingID", "Bookingids", "bookingsID", "bookingsids", "bookingingid", "BookingsID", "bookingids", "bookillingids", "bookingingID", "Bookingid", "bookingsid", "Bookingsids", "Bookingsid", "bookingID", "bookillingid"], "currentcoach": ["currentlycoac", "currentCoarch", " currentcoACH", "currentlyCoech", "currentconac", "currentCoch", "currentCoACH", " currentcoch", "currentcalachable", "currentfoch", "currentlyCoch", " currentcoarch", "currentCOat", "currentCoachable", "currentcalech", "currentfoarch", "currentlycat", "currentfoACH", "currentcalch", "currentfoech", "currentcasp", "currentcoeACH", " currentfoach", "currentfoachable", "currentcoearch", "currentlycoch", "currentfoach", "currentcoac", "currentlycoech", "currentconasp", "currentcat", "currentcoasp", "currentCoach", "currentlycoach", "currentlycac", "currentcalach", "currentcac", "currentcoech", "currentcoarch", "currentconat", " currentfoarch", "currentCOach", "currentlycoasp", "currentlyCoach", "currentcoat", "currentCOac", "currentlyCoachable", "currentlycoachable", "currentlycach", "currentcoachable", "currentCOasp", "currentconach", "currentlycasp", " currentfoACH", "currentcach", " currentfoch", "currentcoch", "currentlycoat", "currentcoACH", "currentcoeach", "currentCoech"], "currentseat": ["reportedport", "currentslot", "currentlysen", "reportedseat", "Currentslot", "currentlysel", "currentsen", "reportedroute", "currentroute", "currentlyslot", "curseat", "currentsel", "Currentsen", "Currentsel", "currentlyseat", "currentport", " currentsel", " currentslot", " currentsen", " currentport", "reportedsel", "cursel", " currentroute", "curroute", "Currentseat", "curport"], "tickpos": ["tickpo", "stickpos", "rickPos", "snappo", "checkpo", "popPos", "ickpos", "popposition", "ickposition", "stickposition", "rickpos", " tickPos", "tickPos", "rickpo", "poppos", "poppo", "testpos", "stickPos", "stickprop", "quoteno", "quoteposition", "snapposition", " tickprop", "testPos", "checkPos", " tickno", "snapPos", "ickpo", "quotePos", "stickpo", "tickposition", "testpo", " tickposition", "checkpos", " tickpo", "snappos", "checkposition", "ickPos", "stickno", "quotepos", "rickprop", "testposition", "tickno", "tickprop"], "chartavailupdsql": ["chartavailupdsQL", "chartavailupdatesq", "chartavailupysQL", "chartavailupsdsq", "chartavailupyssql", "chartavailupdatessql", "chartavailupsdsQL", "chartavailupdssql", "chartavailupdq", "chartavailupsdatessql", "chartavailupsdatesql", "chartavailupdsq", "chartavailupsdatesq", "chartavailupdQL", "chartavailupdatesql", "chartavailupysq", "chartavailupysql", "chartavailupsdatesQL", "chartavailupsdssql", "chartavailupsdsql", "chartavailupdatesQL", "chartavailupdql"]}}
{"id1": "807346", "id2": "397240", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"runScript": ["callscript", "runscript", " runscript", "runProgram", " runProgram", " runCode", "callProgram", "runCode", "executescript", "executeScript", "callScript", "callCode", "executeCode", "executeProgram"], "scriptName": ["ScriptKey", "ScriptPath", "templateFile", "criptFile", "filename", " scriptBody", " scriptFile", "criptPath", "scriptKey", "templatePath", " scriptKey", " scriptPath", "ScriptName", "criptName", "templateName", "Scriptname", "criptBody", "scriptPath", "scriptname", "scriptBody", "templateBody", "filePath", "fileKey", "scriptFile", " scriptname", "fileName"], "data": ["report", "partial", "debug", "cache", "raw", "rew", "command", "list", "n", "some", "to", "step", "html", "dat", "chain", "missing", "extra", "rel", "buffer", "res", "input", "window", "what", "string", "padding", "image", "video", "response", "name", "table", "sequence", "error", "description", "type", "str", "json", "DATA", "row", "ata", "title", "comment", "div", "info", "results", "next", "comments", "value", "t", "format", "reason", "result", "log", "all", "alert", "content", "default", "output", "empty", "this", "message", "a", "out", "action", "text", "p", "source"], "url": ["browser", "http", "b", "pl", "link", "web", "l", "ll", "address", "rel", "user", "hl", "lb", "base", "loc", "open", "char", "f", "str", "ul", "mail", "abs", "ssl", "dl", "build", "ur", "nl", "bel", "mount", "https", "URL", "gl", "resource", "log", "Url", "job", "sl", "get", "r", "out", "uri"], "in": ["inf", "IN", "l", "inc", "it", "val", "al", "inner", "cin", "body", "ins", "input", "mm", "ind", "rin", "bin", "In", "is", "io", "pi", "act", "isin", "serv", "info", "mc", "ma", "check", "stream", "gin", "mat", "all", "en", "inn", "r", "on", "out", "din", "i", " din", "source"], "buffIn": ["buffCon", "bufferOut", "buffOut", "bufferIns", " BuffOut", " BuffIn", "bufedIn", "bufOut", "BuffOut", " buffOut", "BuffedIn", "BuffCon", " buffedIn", "buffIns", "bufferIn", " BuffIns", "buffedIn", "bufIn", "bufferCon", "BuffIns", " BuffCon", "BuffIn"], "temp": ["Temp", "acc", "fake", "cel", "pt", "Temperature", "dat", "thread", "deg", "test", "perm", "wr", "input", "index", "term", "template", "tem", "mod", "sequence", "cert", "cell", "porary", "j", "character", "cap", "tim", "ptr", "cur", "mint", "t", "perature", "result", "read", "emp", "there", "variable", "output", "tmp", "stem", "relative", "i", "length", "buffer", "tc", "txt", "current"]}}
{"id1": "23677128", "id2": "16719805", "code1": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 0, "substitutes": {"sample3a": [" connect6c", " l6A", " connect6b", " connect6A", " l3b", " connect3c", " connect1c", " connect3A", " connect2c", " l6c", " connect3b", " connect1a", " connect1A", " l3a", " connect1b", " connect2a", " l3c", " connect2A", " connect2b", " l6b", " l3A", " connect6a", " l6a", " connect3a"], "ftpserver": ["ftpource", "ftportsserver", "ftportsvr", "ftlsvr", "ftportserver", "ftpuper", "ftpersuper", "ftportsource", "ftlsenter", " ftpsource", "ftperver", "ftsserver", "ftssource", "ftlsource", "ftpsuper", " ftpsenter", "ftlsserver", " ftpersource", "ftpsenter", " ftpsserver", "ftpenter", "ftpsource", " ftssvr", "ftpsvr", "ftlserver", " ftpsuper", " ftssource", " ftssserver", " ftpersenter", "ftssserver", "ftpersenter", "ftssvr", "ftlsuper", " ftperserver", " ftsserver", " ftpersuper", "ftperserver", "ftpersource", "ftpsserver", " ftpsvr"], "ftpport": ["aftpport", "ftsven", "ftven", "aftport", "ftpload", "fpen", " ftpen", "ffport", "aftmph", "ftsmph", " ftpload", "ftmph", "wtpload", "fpport", "ffpport", "wtport", "ftpen", "ftport", "ffven", "wtpen", "ffmph", "fpload", "ftsport", "aftven", " ftport", "fport", "wtpport", "ftspport"], "proxyserver": ["procoysenter", "proxysocket", "procoyession", "procoyerver", "prouxiesenter", "proxysource", "prouxyserver", "proxianserver", "proxyource", "procoyenter", "proxiansenter", "proxotesource", "proxiesenter", "prouxiesocket", "proxieserver", "proxiansocket", "prouxyset", "proxmysenter", "procoysession", "proxieset", "proxianset", "proxyerver", "prouxysocket", "procoyserver", "prouxieserver", "proxmyserver", "proxmyset", "proxiesource", "proxysenter", "proxyession", "procoyource", "proxmysocket", "proxotesenter", "proxiesession", "proxoteserver", "prouxysenter", "procoysource", "prouxieset", "proxiesocket", "proxyset", "proxysession", "proxotesession", "proxyenter"], "proxyport": ["Proxyproxy", " proxyPort", "proxyproxy", "proxyPORT", " proxypport", "piport", "roxyport", "ProxyPORT", "proxyports", "proxyPort", "piproxy", "Proxypport", "roxypport", "Proxyport", "piPort", "Proxyports", " proxyports", "roxyports", " proxyproxy", " proxyPORT", "roxyPort", "piPORT", "ProxyPort", "proxypport"], "username": ["john", "human", "male", "ua", "phone", "knife", "filename", "ugi", "user", "via", "umber", "emale", "term", "albeit", "ome", "login", "sword", "authent", "person", "lead", "sole", "author", "uno", "uo", "pai", "ername", "into", "usr", "subject", "auth", "owner", "title", "him", "mitter", "sudo", "smith", "seat", "creator", "umi", "hello", "kin", "cn"], "password": ["Password", "security", "shadow", "secret", "command", "policy", "address", "key", "knife", "user", "paste", "pass", "padding", "database", "directory", "expression", "token", "template", "stroke", "login", "sword", "PASS", "description", "attribute", "worker", "phrase", "auth", "comment", "remember", "word", "port", "profile", "pattern", "power", "wordpress", "hello", "delete", "message"], "ftpClient": ["fttpObj", "ftpStore", "ftphpConnection", " ftpIn", "fttpclient", "ftphpOb", "ftpEasy", " ftpStore", "ftcpclient", "fttpClient", "ftvpObj", " ftpConnection", "ftpObj", "aftpEasy", "ftcEasy", "ftpConnection", "ftcClient", "ftcpClient", "ftrclient", "ftvpClient", "ftpIn", "aftpObj", " ftpOb", "aftpclient", "ftphpEasy", "aftcObj", "ftcObj", "ftcpOb", "ftpclient", " ftcpclient", "fttpOb", " ftcpConnection", "ftpsclient", "ftphpClient", "fttpConnection", "aftpClient", "ftpsClient", " ftrIn", " ftpclient", "ftrClient", "ftvpclient", "ftpOb", "aftcEasy", "ftrIn", "ftcpConnection", "ftrStore", "ftphpIn", "aftcclient", "ftpsStore", "ftpsIn", "ftphpStore", " ftcpOb", " ftrclient", "aftcClient", "fttpEasy", " ftcpClient", "ftcclient", "ftphpclient", " ftrClient", " ftrStore"]}}
{"id1": "10759917", "id2": "22411381", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 1, "substitutes": {"delete": ["insert", "link", "lete", "command", "Delete", "create", "execute", "destroy", "reset", "download", "load", "remove", "replace", "touch", "clear", "write", "save", "move", "put", "dump", "del", "query", "set", "update", "get", "de", "drop", "select"], "name": ["m", "n", "link", "code", "null", "time", "l", "create", "Name", "NAME", "key", "data", "chain", "filename", "label", "string", "term", "base", "c", "prefix", "error", "description", "type", "url", "lon", "item", "str", "alias", "connection", "common", "ame", "e", "title", "comment", "o", "old", "version", "me", "ma", "word", "size", "search", "names", "value", "local", "resource", "format", "w", "nm", "file", "part", "id", "message", "path", "family", "parent", "source"], "CannotDeleteSystemLinkException": ["CannotDeleteSystemTypeEx", "CannotDeleteSysLinksException", "CannotDeleteSysLinksStatus", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinkError", "CannotDeleteSystemPageEx", "CannotDeleteSystemPageStatus", "CannotDeleteSysLinkError", "CannotDeleteSystemDataStatus", "CannotDeleteSystemLinkEx", "CannotDeleteSystemLinkWarning", "CannotDeleteSystemPageError", "CannotDeleteSystemLinksException", "CannotDeleteSystemTypeWarning", "CannotDeleteSystemDataError", "CannotDeleteSysLinksEx", "CannotDeleteSystemLinksEx", "CannotDeleteSysLinksError", "CannotDeleteSystemLinkStatus", "CannotDeleteSystemLinksStatus", "CannotDeleteSysLinkStatus", "CannotDeleteSystemTypeError", "CannotDeleteSystemTypeException", "CannotDeleteSystemPageException", "CannotDeleteSystemLinksError", "CannotDeleteSysLinkException", "CannotDeleteSystemLinksWarning", "CannotDeleteSystemDataEx", "CannotDeleteSystemDataException"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotFindException", "ClassLinkTypeNotFoundOver", "ClassLinkTypeIsFind ", "ClassLinkTypeNotFind ", "ClassLinkTypeIsFound ", "ClassLinkTypeNotUsedEx", "ClassLinkTypeNotUsedException", "ClassLinkTypeNotFound ", "ClassLinkTypeNotUsedOver", "ClassLinkTypeIsFoundEx", "ClassLinkTypeIsFoundException", "ClassLinkTypeNotFindOver", "ClassLinkTypeIsFindEx", "ClassLinkTypeNotUsed ", "ClassLinkTypeIsFindOver", "ClassLinkTypeIsFoundOver", "ClassLinkTypeNotFindEx", "ClassLinkTypeIsFindException", "ClassLinkTypeNotFoundEx"], "conn": ["pg", "pkg", "rel", "Conn", "req", "c", "loc", "jp", "client", "ens", "ang", "sys", "bo", "act", "org", "nc", "iw", "con", "pas", "https", "win", "connect", "t", "ca", "pt", "priv", "ws", "cp", "rt", "ctx", "exec", "open", "cert", "cmd", "die", "comm", "cb", "coll", "addr", "pool", "nt", "socket", "gate", "err", "yn", "oc", "resp", "sec", "ct", "enc", "ch", "cur", "port", "close", "en", "conf", "ec", "pen", "db", "on", "ns", "canon", "obj", "yes", "col", "connection", "co", "mc", "ce", "dn", "mt", "gc", "cc", "cn", "conv"], "stmt": [" stmm", "sttx", "STmb", " stpt", "STmm", " stmb", "Sttm", "Str", "Stmp", "strpr", "snpt", "statMT", "Stmm", "stm", "StMT", "constmt", "snm", "statmt", "STm", "startMT", "stattm", "strm", "stmp", "sttm", "strMT", "Stpr", "str", "startmm", " stm", " stpr", "strmm", "STMT", "Stmt", " sttm", "STtx", "stmb", "constm", "STmt", " sttx", "Sttx", "stpt", "stmm", "Stpt", "Stmb", "constmb", "strmt", "consttm", "stMT", "stpr", " stMT", "Stm", "snmt", "startmp", "startmt", "strmp", "STtm", "statm", "strr", "snMT", " str"], "prepTable": ["ppTable", " prepTier", " prepTree", "prepTab", "ppTab", "pptable", "PrepTree", " preptable", "summaryTier", "prepTree", "ppTree", "PrepTier", "PrepTab", "prepTier", "Preptable", " prepTab", "preptable", "PrepTable", "summarytable", "summaryTable"], "objectLinkTable": ["objectTypeTab", "objectlinkType", "objLinkList", "objectLinkstable", "objectlinkTable", "objectlinktable", "objLinkTable", "objectLinksTable", "objLinksList", " objectLinkTab", " objectLinkType", "objectLinkList", "objLinktable", "objectTypeType", "objLinkController", " objectLinktable", "objectLinksController", "objectTypeTable", "objectLinkType", "objLinksController", "objectLinkController", "objectLinkTab", "objectLinktable", "objLinksTable", "objLinkstable", "objectTypetable", "objectLinksList", "objectlinkTab"], "sql": ["csv", "js", "html", "xml", "qs", "q", "spr", "rel", "inv", "string", "expression", "ql", "template", "description", "fn", "form", "str", "json", "dl", "sv", "nl", "sp", "sf", "sq", "url", "format", "s", "ips", "result", "sd", "sl", "query", "SQL", "fields", "spec", "quote", "scl", "expr", "ns", "join", "select"]}}
{"id1": "20426057", "id2": "932225", "code1": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"createKeyStore": ["createTrustStorage", " createTrustStorage", "createKeyStorage", "createDefaultStorage", " createKeyStorage", "createTruststore", "createKeystore", "createDefaultStore", "createDefaultstore", "createKeyChain", "createCertStore", " createTrustStore", "createCertStorage", "createDefaultChain", "createCertstore", "createTrustChain", "createCertChain", " createTruststore", " createKeyChain", " createKeystore", " createTrustChain", "createTrustStore"], "url": ["http", "rect", "rest", "link", "list", "web", "l", "ld", "ll", "html", "xml", "address", "server", "q", "el", "user", "store", " URL", "string", "location", "image", "name", "loc", "abs", "cert", "email", "char", "str", "ul", "mail", "un", "ssl", "dl", "org", "u", "ref", "ur", "nl", "context", "build", "ud", "domain", "upload", "mount", "https", "URL", "au", "gl", "file", "add", "pattern", "log", "Url", "job", "sl", "id", "github", "host", "lr", "addr", "path", "util", "ls", "uri", "uu"], "password": ["Password", "security", "shadow", "secret", "command", "words", "project", "key", "address", "reset", "hash", "property", "user", "pass", "store", "padding", "database", "directory", "username", "expression", "token", "stroke", "sword", "PASS", "prefix", "description", "attribute", "language", "email", "device", "phrase", "auth", "provided", "comment", "remember", "another", "word", "crypt", "pattern", "power", "wordpress", " Password", "hello", "message"], "keystore": ["keycache", "keycase", "Keyore", "keyserver", "linkstorage", "linkStore", "Keycache", " keystorage", "ekstorage", "Keytool", "kstore", "Keyserver", " keyserver", "ekstore", "keyStore", "printstore", " keycache", "ktool", "kStore", " keychain", "kbase", "linkserver", " keyore", "Keychain", " keytool", "keybase", "kcache", " keycase", "ekStore", " keybase", "Keystorage", " keyStore", "linkstore", "linkcase", "printchain", "Keystore", "linkore", "keytool", "Keybase", "keychain", "printcase", "printstorage", "keystorage", "keyore", "KeyStore", "ekchain", "linkchain"]}}
{"id1": "3958807", "id2": "12782570", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBixedStream", "loadEmbinaryFile", "loadBinaryInput", "loadEmbinaryStream", "loadBignedInput", "loadEmbbinaryStreamer", "loadEmbbinaryInput", "loadEmbinaryInput", "loadBignedStreamer", "loadBixedFile", "loadBignedStream", "loadEmbinaryStreamer", "loadBbinaryFile", "loadBinaryStreamer", "loadEmbbinaryFile", "loadBignedFile", "loadBbinaryStreamer", "loadBbinaryStream", "loadBbinaryInput", "loadBixedInput", "loadBinaryFile", "loadBixedStreamer", "loadEmbbinaryStream"], "streamName": [" streamNAME", "streamHandle", "streamPath", "longName", "longPath", "stringName", "Streamname", "stringType", "resourceType", "recordNAME", "fileNAME", "streamNAME", "StreamNAME", "StreamName", "resourceName", " streamname", "recordHandle", "streamType", "stringNAME", " streamType", " streamPath", "longNAME", "filePath", "StreamHandle", "recordName", "streamname", "resourceNAME", " streamHandle", "fileName", "recordname"], "streamToLoad": [" streamToload", "streamtoLoad", "streamToRead", "streamToAdd", "streamTOload", "stringWillLoad", " streamToUse", "streamToUse", "streamWillAdd", "stream2load", "streamTORead", "stream2Read", " stream2Load", "stream2Use", "streamtoAdd", " streamWillload", " stream2Read", "stringToAdd", "streamTOLoad", "stringWillAdd", " streamWillLoad", "streamTOAdd", "streamWillLoad", "stringToLoad", " stream2load", "stringToload", "streamtoload", "stream2Load", " stream2Use", "streamWillload", "stringWillload", " streamToRead", "streamTOUse", "streamToload"], "sz": ["insz", "Sch", "sld", "rsld", " sze", "sch", " sld", " sch", "rsz", "Sld", "Siz", "insch", "Sz", "insiz", "rsze", "siz", "insze", "rsiz", "Sze", " siz", "sze"], "req": ["comp", "http", "wcs", "pkg", "qs", "q", "proc", "ctx", "inv", "wx", "dq", "res", "attr", "seq", "quick", "rx", "quest", "jp", "requ", "cmd", "client", "comm", "org", "usr", "request", "pas", "cur", "qt", "urg", "Request", "require", "qq", "query", "fr", "gr", "Requ", "sq"], "resp": ["http", "report", "dis", "pos", "conn", "esp", "html", "Res", "respond", "body", "rel", "proc", "wr", "res", "inv", "rend", "re", "wx", " Resp", "obj", "rec", "response", "rep", "status", "msg", "os", "jp", "RES", "cmd", "client", "comm", "sys", "ret", "vol", "compl", "sp", "serv", "cmp", "request", "pas", "https", "soc", "respons", "Response", "Resp", "exp", "fs", "result", "cl", "fr", "sol", "content", "output", "r", "gr", "conv", "p", "nt"], "out": ["o", "n", "to", "null", "in", "oss", "ex", "ws", "cos", "us", "obj", "ins", "res", "OUT", "os", "Out", "ou", "io", "yout", "aos", "client", "sys", "conv", "vol", "co", "ot", "w", "t", "ts", "log", "sw", "gt", " outs", "utt", "output", "outs", "bs", "net", "cn", "gs", "nt"], "bos": ["bes", "bh", "js", "oss", "bis", "ws", "los", "bas", "banks", "oos", "ubis", "obs", "bot", "bles", "bin", "base", "des", "os", "ods", "aos", "boards", "bi", "BS", "eros", "bo", "sys", "nos", "dos", "bits", "buff", "bytes", "ios", "ys", "ols", "tes", "ts", "fits", "oops", "jas", "bat", "oids", "uts", "bs", "bones", "mos"]}}
{"id1": "20247400", "id2": "5061606", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["inf", "IN", "inc", "it", "inner", "cin", "ins", "input", "ind", "rin", "bin", "up", "In", "is", "io", "ze", "isin", "init", "con", "info", "and", "check", "ai", "file", "gin", "from", "inn", "on", "net", "din", "i", " din", "source"], "out": ["o", "report", "n", "b", "to", "print", "screen", "list", "null", "err", "ex", "oss", "it", "obj", "ins", "OUT", "at", "msg", "name", "os", "Out", "io", "ou", "cmd", "writer", "client", "str", "outer", "sys", "we", "other", "write", "dir", "ot", "con", "ln", "check", "println", "w", "t", "log", "auto", "gt", "exit", "OU", "output", "r", "outs", "net", "or", "ne", "line"], "buffer": ["b", "batch", "cache", "Buffer", "command", "header", "data", "function", "address", "key", "filter", "flush", "memory", "processor", "index", "window", "total", "database", "limit", "available", "template", "shape", "table", "document", "sequence", "bar", "attribute", "trace", "queue", "buf", "channel", "clear", "phrase", "append", "buff", "pause", "comment", "sample", "stack", "iter", "block", "position", "size", "se", "library", "result", "variable", "match", "binary", "view", "event", "component", "output", "db", "message", "temp", "display", "history", "length", "bridge", "source"]}}
{"id1": "13886238", "id2": "6171406", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"init": [" Init", "ping", "rest", "launch", "Init", "create", "reset", "download", "index", "base", "load", "open", "save", " reset", "setup", "version", " initialization", " refresh", "go", "construct", "gc", "start", "release", "update", "get", " initiate"], "backupFile": ["backusterFILE", "BackipFile", "backakFile", "backupidFormat", "Backipfile", " backupfile", "backupLog", " backopfile", "backakLog", "BackupFILE", "backusterFile", "backapFormat", "backakfile", "backupImage", "backipfile", "backupidLock", "backopfile", "backupidLog", "backupLock", "backoreStream", "backipLock", "BackupFormat", "BackipLock", " backopStream", "backusterFormat", "backupStream", "backipFile", "backopFile", "Backupfile", "backapFILE", "backupidfile", "backusterfile", "BackapFile", "backupFILE", " backupImage", " backopImage", "BackupLog", "backipStream", "backapFile", "backapfile", "backupidFILE", "backipImage", "BackupFile", "backoreFile", "backopImage", "backopStream", " backupStream", "BackapFormat", "BackapFILE", " backopFile", "Backapfile", "BackipLog", "backupFormat", "backupfile", "backorefile", "BackupLock", "backoreImage", "backipLog", "backupidFile", "backakLock"], "buff": ["pb", "comp", "b", "xx", "batch", "zero", "null", "tab", "bis", "num", "black", "grow", "wind", "tf", "ind", "req", "msg", "bin", "cond", "hold", "ff", "uf", "cmd", "ob", "emb", "xff", "end", "buf", "bed", "img", "text", "ref", "mem", "bf", "bg", "lim", "cb", "append", "bytes", "nd", "bits", "fb", "font", "printf", "max", "qq", "bb", "binary", "uff", "bm", "bl", "bound", "nb", "bs", "Buff", "prof", "buffer", "butt", "txt"], "in": ["inf", "o", "IN", "l", "inc", "it", "ex", "inner", "cin", "body", "ins", "input", "mm", "ind", "rin", "bin", "im", "up", "inside", "In", "io", "is", "ini", "ze", "isin", "con", "iter", "mc", "ri", "add", "ai", "gin", "mi", "id", "en", "ain", "get", "conf", "inn", "r", "on", "ic", "din", "i", " din"], "out": ["o", "n", "to", "v", "ne", "conn", "ex", "oss", "inner", "full", "cos", "obj", "res", "OUT", "at", "one", "os", "up", "Out", "ou", "io", "aos", "writer", "again", "end", "outer", "sys", "we", "conv", "co", "write", "con", "ion", "w", "auto", "can", "op", "conf", "OU", "output", "outs", "on", "net", "cn", "i"], "read": ["have", "n", "shift", "give", "print", " Read", "need", "raw", "push", "pos", "skip", "show", "buffer", "take", "input", "index", "bind", "tell", "reading", "play", "ind", " write", "seek", "load", "shape", "hold", "open", "remove", "end", "scan", "send", "count", "build", "mem", "write", "old", "copy", "iter", "size", "check", "stream", "add", "next", "start", "ready", "READ", "close", "query", "max", "update", "pop", "find", "get", "ok", "run", "scroll", "before", "length", "Read", "reads", "readable", "len"], "reportWriter": ["summaryTree", " reportTimer", "repairScope", "portHandler", "commentWriter", "xmlHandler", " reportPage", "commentEngine", "repairwriter", "repairMember", "reportEditor", "repairApplication", "reportEngine", "portWrite", " reportScope", "listwriter", "reportWriting", "moduleWriter", "reportPage", "portFile", " reportApplication", " reportWriting", "summaryTimer", "moduleMember", "reportEntry", "createEntry", "summaryWriter", "xmlFile", " reportwriter", "reportApplication", "reportScope", "serviceWriter", "commentWriting", " reportEngine", "xmlWriter", " reportTree", " reportMember", "reportFile", "serviceWriting", "repairEngine", "detailReader", "reportTree", "listPublisher", "xmlReader", "reportMember", " reportContent", "repairContent", "repairHandler", "portWriter", "repairWrite", " reportHandler", "repairEditor", "reportPublisher", "reportTimer", "moduleManager", "listWriter", "detailWriter", "reportContent", "repairTree", "reportWrite", "repairPublisher", "listWrite", "summaryEditor", "servicePage", "portReader", "reportHandler", "commentContent", "modulewriter", "repairPage", "summaryWriting", "repairWriter", "createWriter", "detailFile", "summaryHandler", "reportManager", "repairEntry", "serviceApplication", "createwriter", "portPublisher", "createScope", " reportManager", "repairWriting", "reportReader", "repairManager", " reportEditor", "portwriter", "repairTimer", "reportwriter", "detailHandler", " reportEntry"], "restarting": ["restartsing", "restorting", " restartinging", "startedbing", "restreatinging", "restreating", "starting", "startedating", " restorted", " restorting", "restarteded", "restartinging", "restrictating", "restartedbing", "restartsating", " restartating", "restreated", "restrictinging", "startating", "restarteding", "restartbing", "restorted", "startbing", "restartating", "restortinging", "restartedating", "restortating", "restricted", "restreatating", "restartsed", "restricting", " restortating", " restortinging", "restruptbing", "restruptating", "restrupted", "restartsbing", "restarted", "started", "starteding", " restarted", "restrupting", "starteded"]}}
{"id1": "23672408", "id2": "884867", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyIconfiles", " copyIconImages", "copyiconfiles", "copyiconImages", " copyiconFiles", " copyiconDocuments", " copyIconfiles", "copyIndexfiles", "copyIconImages", "copyiconFiles", " copyiconImages", "copyIconDocuments", "copyiconDocuments", "copyIndexFiles", "copyIndexDocuments", "copyIndexImages", " copyiconfiles", " copyIconDocuments"], "clazz": [" clbo", "classazz", "clbean", " classe", "relaz", " clotted", "chazz", "CLace", "descazz", "colluster", " cluddy", "claz", "colluddy", "Clbo", "callace", " plaz", "descose", "cluster", "descaz", "Close", "CLoser", " plus", "callaz", " closer", "classotted", "sclbean", "escojure", " claz", "relab", "escace", "scloser", "cluddy", "relose", " plub", "classuddy", "escazz", "crub", "chotted", " club", "plazz", "collazz", "Claz", " clus", "escotted", "sclace", "classe", "pkgazz", "chojure", " clbean", "sclazz", "callbo", "CLazz", "pkgasse", "plasse", "clab", "Clab", "classuster", "clace", "close", "clojure", "club", "clus", " clashed", "pkgashed", "chace", "pkgaz", " clojure", "collotted", "Clace", "plashed", "crus", " plazz", "descab", "clashed", "closer", "clbo", "crazz", "plaz", "Clazz", "craz", "clotted", " cluster", "callazz", "relazz", "CLbean", " clace"], "i16": ["amiShort", "li2016", "iniShort", "i19", "iShort", "iri16", "i6", " i24", "ji150", "i63", "ami19", "i160", "ami16", "ami150", "ji63", "i24", " i2016", "ami63", "pi63", "ii160", "i150", "ini2016", "ini24", "ii16", "li19", "ri16", "i157", " i157", " i160", "ri6", "ami2016", " i6", "ini216", "i216", "ini19", "iri6", "ini160", "ji16", "liShort", "iri2016", " i216", "pi150", "iri157", "ami6", "ri2016", "li16", "ini16", "ri157", "pi16", "pi6", "ji6", "ii24", "i2016", "ii216"], "fileType": ["viewTYPE", "iletype", "policyHandler", "webTYPE", "treeTYPE", "fileTime", "fileTyp", "issuePattern", "ilePattern", "treetype", " fileTyp", "formName", " fileValue", "formType", "fieldTyp", "fileDef", "webType", "coreHandler", "coreDef", "fieldDef", " filePattern", "fieldType", "coreType", "ileType", " fileTYPE", "eventUnit", "ileTyp", "resourceTYPE", " filetype", "viewValue", "fieldTYPE", "policyType", "formatTime", "fileList", "FileName", "filetype", "issuetype", "resourceUnit", "relationHandler", "relationFamily", "resourceFormat", "policyFamily", "formtype", "FileType", "coreTyp", "Filetype", "webDef", "issueType", "treeTime", "fileHandler", "filePattern", "FILEType", "fileValue", " fileTime", "FILEName", "formatTYPE", "fileTYPE", "relationTyp", "formattype", " fileList", "eventTYPE", " fileFormat", "formatType", "formatValue", "issueTyp", "fileUnit", "fileFamily", "webList", "fileName", "viewType", "fileFormat", "treeType", "eventFormat", " fileUnit", "coreFamily", "resourceType", "policyTyp", "viewtype", "FILEtype", "relationType", "eventList", "eventType", "webTyp", "coreTYPE"], "desti16": [" destsi18", "destsi160", "destgi216", "destui2016", "destsi16", "resulti24", "resultii2016", "destsi18", "destui216", "resulti216", "desti24", "destui160", "destsi32", "resultii216", "destui32", "destxi160", "resulti2016", "destgi24", "desti160", "destgi16", "destii2016", "destxi32", " destsi16", "destxi18", "destui18", "destui16", "destxi16", "desti18", "resultii16", "destgi2016", "resulti16", "resultii24", " desti18", "destui24", "desti2016", " destsi160", "desti216", "destii216", "destii16", " destsi32", "destii24", " desti160"], "src": ["comp", "syn", "rest", "bh", "ctr", "pkg", "rl", "inner", "rob", "sec", "proc", "rel", "ctx", "ins", "desc", "ser", "via", "obs", "input", "hl", "std", "req", "rs", "bin", "loc", "iv", "rx", "rb", "scan", "cont", "img", "ssl", "sys", "usr", "sel", "rc", "fc", "nl", "sp", "bg", "st", "cmp", "txt", "cb", "sync", "ln", "sn", "cur", "ptr", "inst", "urg", "cli", "iter", "etc", "sit", "sl", "vr", "sc", "bc", "sol", "isl", "ibl", "sub", "rg", "sb", "tmp", "addr", "dest", "sr", "gs", "ls", "sq", "source"], "dst": [" dest", " dcut", "tgt", "tput", " dmn", "ddmn", "Ddest", "rbl", "ddst", "ngt", " dgt", "rdmt", " dput", "rdest", "dnd", "dddest", "dot", "nnd", "derst", "derdest", "tst", "dsts", "fdest", "dcut", "dsst", "ddnd", "dLot", "dLest", "dLst", " dsts", "dLdest", "fnd", "nput", "rcut", "dLnet", "dnet", "dernd", "tnd", " ddest", "dLbl", "dLcut", "dermn", "ddest", "dsnet", " dnet", "dbl", "dgt", " dbl", "ndst", "nst", "Dst", "ndmt", "rdst", "rst", " dmt", "ndest", "dmt", "dmn", "ndsts", "rdsts", "dsest", "Dnd", " dot", " dnd", " ddr", "dsot", "Ddr", "dest", "dput", "ddr", "fst", "fdr"], "i32": ["pi34", "ip34", "i31", " i86", "ic31", "i22", "i48", "xi32", "i86", "ii342", "ip64", "isi32", " i28", "ii32", "i64", "i342", " i342", "ic86", "ic342", " i34", " i31", "i40", "isi86", "xi22", " i40", "ini22", "i28", "ii28", "ip31", "pi64", "ic22", "ii34", "isi64", "ic48", "pi32", "ini31", " i64", "xi31", "ic34", "ic32", "ic28", "pi31", "ic40", "ic64", "ini48", "isi40", "xi48", "i34", "ip32", "ini32"], "desti32": ["targetpi32", "Desti256", "destI31", "targetpi31", "desti34", "desti90", "DestI31", "destpi30", "targeti34", "targeti31", "targetpi30", "DestI32", "destdi32", "Desti90", "destpi31", "destic34", "desti30", "destu90", "destI256", "DestI90", "destic31", "DestI256", "targeti30", "destpi32", "destu32", "targeti32", "destic32", "destI90", "destdi31", "desti31", "destI32", "destu31", "destdi30", "destic30", "Desti31", "destdi34", "destpi34", "Desti32", "destu256", "targetpi34", "desti256"]}}
{"id1": "838844", "id2": "20685385", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 0, "substitutes": {"convert": ["Conprocess", "compversion", "converting", "conversion", "Converting", "Converts", "ConVERT", "CONvert", "consVERT", "unprocess", "compvert", "compverts", "consverting", "consversion", "CONversion", "converts", "unfer", "unversion", "Converted", "Conversion", "unverts", "conVERT", "compprocess", "consvert", "CONverting", "Confer", "CONVERT", "converted", "unverted", "confer", "CONfer", "Convert", "conprocess", "CONverted", "unvert"], "src": ["http", "rest", "source", "pkg", "ebin", "SOURCE", "href", "filename", "rel", "ins", "ser", "input", "dist", "attr", "hl", "RC", "req", "rs", "scene", "rx", "loc", "iv", "ipl", "its", "str", "cont", "img", "scan", "sys", "usr", "orig", "func", "rc", "ur", "st", "upload", "ource", "Source", "cur", "stream", "inst", "url", "file", "from", "s", "buster", "start", "sit", "config", "sc", "host", "sin", "addr", "path", "cc", "sr", "txt", "sq", "uri", "SourceFile"], "dest": ["rest", "disk", " dst", " Dest", "dat", "test", "target", "tif", "dist", "table", "Dest", " destinations", "img", "est", "write", " Destination", "dir", "port", "gin", "mat", "result", " orig", "foreign", "temp", " destination", "txt", "orig", "source"], "in": ["inf", "d", "m", "b", "IN", "l", "ad", "inner", "cin", "ins", "el", "input", "res", "reader", "ind", "rin", "bin", "up", "In", "is", "io", "ar", "sql", "isin", "serv", "st", "stream", "file", "from", "en", "as", "inn", "r", "i", "din", "source"], "p": ["ping", "pb", "pl", "d", "parse", "m", "b", "pt", "l", "pg", "ap", "it", "cp", "pkg", "pd", "h", "wp", "post", "pe", "pa", "dp", "parser", "at", "pm", "rep", "c", "pro", "jp", "php", "f", "tp", "fp", "pi", "j", "lp", "sp", "pc", "py", "er", "pers", "t", "P", "pre", "vp", "pp", "ph", "part", "op", "g", "prot", "per", "ps", "r", "i"], "ds": ["ks", "pd", "hd", " os", "hs", "dl", "ys", "uds", " des", "iffs", " ads", "amps", "ps", "dt", "bs", "ils", "terms", "sets", "ws", "qs", "edes", "os", "cks", "dd", "ras", "eps", "ags", "loads", "ts", "ports", "gs", "mys", "js", "tags", "Ds", "points", "aws", "obs", "des", "tests", "df", "vs", "dh", "cs", "eds", " DS", "drivers", "xs", "s", "dds", "sts", "ats", "sd", "ands", "nas", "docs", "di", "db", "outs", "ns", "ls", "d", "dates", "DS", "dp", "gd", "posts", "rs", "yes", "ods", "ss", "ads", "its", "tp", " dd", "dos", "tes", " d", "scripts", "workers", "els", "lists"], "format": ["parse", "lat", "Format", "sche", "mode", "l", "policy", "it", "settings", "filter", "MAT", "at", "status", "template", " Format", "shape", "name", "table", "layout", "type", "cf", "form", "ct", "feature", "f", "style", "top", "fc", "unit", "act", "pi", "fm", "module", "title", "version", "mt", "size", "t", "file", "mat", "feat", "pattern", "ats", "set", "id", "spec", "output", "tag", "path", "pretty", "source"], "hasPixelData": ["hasixelDATA", "HaspixelData", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasPixelDATA", "hasixeldata", "HaspixelDATA", "haspixelDATA", "hasFrameData", "hasixelData", "hasFramedata", "HasPixelData", "Haspixeldata", "haspixelData", "HasPixelDATA", "HasPixeldata", "hasFrameDATA", "hasPixeldata"], "inflate": ["invalidATE", "Informat", "Inflat", " invalidocate", "Informocate", "inflat", "inFLocate", "inFlicate", "inflocate", " invalidate", " inflicate", "informocate", "Informate", " invalidicate", "inFlATE", "informated", "infolated", "invalidocate", "inflated", "infolat", "informate", "inflATE", " invalidATE", "inFLated", "infolate", "incelocate", " inflATE", "inflicate", "informat", "inFlocate", "incelicate", "inFlate", "incelate", "invalidicate", "Inflate", "invalidate", " inflocate", "inFLate", "infolocate", "inFLat", "Inflocate", "Informated", "Inflated", "incelATE"], "pxlen": ["xplen", "pixelfun", "mmlength", "pexlen", "pxden", "pxls", "packls", "pxlength", "pixellength", "packdec", "xpln", "xpden", "pixells", "mxlen", "tmplen", "xylin", "mxln", "mmln", "cplen", "phplength", "pxlin", "packlength", "pexden", "mxlength", "pexlength", "cplength", "pexfun", "mmlin", "xyln", "cpden", "pxln", "tmplength", "phpln", "packln", "xylen", "cpln", "phplen", "pexln", "mmlen", "pexls", "phpdec", "packfun", "xplength", "tmpln", "pxfun", "mxdec", "pxdec", "packlen", "pixellen", "tmplin", "xylength"], "out": ["print", "screen", "list", "conn", "ex", "err", "sum", "obj", "inv", "res", "store", "user", "OUT", "msg", "group", "name", "up", "prefix", "ou", "io", "Out", "writer", "aos", "cmd", "client", "outer", "sys", "init", "dir", "ln", "gov", "crit", "log", "inter", "cfg", "outs", "output", "gr", "temp", "net", "pretty"]}}
{"id1": "16621499", "id2": "10281203", "code1": "    public static byte[] loadURLToBuffer(URL url) throws IOException {\n        byte[] buf = new byte[4096];\n        byte[] data = null;\n        byte[] temp = null;\n        int iCount = 0;\n        int iTotal = 0;\n        BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480);\n        while ((iCount = in.read(buf, 0, buf.length)) != -1) {\n            if (iTotal == 0) {\n                data = new byte[iCount];\n                System.arraycopy(buf, 0, data, 0, iCount);\n                iTotal = iCount;\n            } else {\n                temp = new byte[iCount + iTotal];\n                System.arraycopy(data, 0, temp, 0, iTotal);\n                System.arraycopy(buf, 0, temp, iTotal, iCount);\n                data = temp;\n                iTotal = iTotal + iCount;\n            }\n        }\n        in.close();\n        return data;\n    }\n", "code2": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadURLToBuffer": ["loadURL2Buff", "loadUrlToBuffer", "loadURLtoBuff", "loadUrl2Buffer", "loadUrl2Buff", "loadUrlToBuff", "loadUrl2Bytes", "loadURLToBytes", "loadURLToBuff", "loadUrlToBytes", "loadURLtoBytes", "loadURLtoBuffer", "loadURL2Buffer", "loadURL2Bytes"], "url": ["browser", "http", "b", "pl", "link", "web", "l", "ll", "html", "address", "xml", "el", "location", "base", "name", "open", "cert", "char", "str", "ul", "mail", "ssl", "dl", "ur", "nl", "bel", "URL", "gl", "file", "loader", "log", "Url", "job", "sl", "r", "page", "ls", "uri"], "buf": ["b", "batch", "capt", "bh", "Buffer", "cat", "tr", "pkg", "dat", "ctx", "desc", "mu", "msg", "bt", "seq", "arr", "bu", "uf", "rb", "bar", "cmd", "bp", "bag", "queue", "str", "img", "bn", "bo", "conv", "br", "buff", "box", "cb", "div", "bytes", "cap", "BU", "vec", "font", "fb", "cv", "log", "tx", "bc", "mus", "bl", "axe", "db", "tmp", "nb", "Buff", "bs", "buffer", "txt", "nt"], "data": ["partial", "cache", "zero", "list", "null", "it", "rel", "total", "only", "msg", "bin", "type", "bo", "ata", "buff", "dec", "tmp", "a", "done", "length", "bus", "to", "raw", "step", "DATA", "br", "next", "value", "result", "part", "set", "content", "good", "default", "output", "buffer", "p", "nt", "batch", "missing", "image", "arr", "str", "bytes", "info", "results", "format", "map", "def", "all", "initial", "di", "message", "out", "action", "dat", " DATA", "obj", "no", "res", "mu", "name", "table", "json", "text", "ret", "count", "div", "size", "this", "txt", "item"], "temp": ["Temp", "v", "cache", "partial", "pos", "fake", "null", "pt", "tr", "dat", "deg", "test", "mm", "term", "template", "tem", "mod", "rem", "tar", "mont", "nom", "tm", "porary", "ret", "met", " Temp", "unit", "mem", "vol", "EMP", "em", "buff", "ta", "div", "alt", "tim", "copy", "ptr", "font", "t", "mp", "pre", "result", "tt", "unt", "emp", "variable", "tmp", "dest", "util", "buffer", "tc", "txt", "current"], "iCount": ["iCall", "iniLength", " iNumber", "giCode", "iCP", "liTotal", "liCount", "iniCount", "aiCounter", "iCategory", "iriNow", "iNow", " iCounter", "diTotal", "giTotal", "iCheck", "aiTotal", " iMark", "iuCP", "phiCount", "iiNow", "iriProcess", "intProcess", "piLength", "iMark", "ciCP", "jTotal", "jCount", "diCount", "dicount", "diCounter", "uiTotal", "uiCount", "iiCall", "iiProcess", " iLength", "uiCall", "phiMark", "intNow", "phiNumber", "iNumber", "aiCount", "iCode", "giCounter", "iniMark", "icount", "biCount", "iuCount", "aicount", "liCounter", "jcount", " iCheck", "iiCount", "piCP", "ciCounter", "liCall", "iProcess", "jLength", "biTotal", "uiCounter", "piTotal", "aiLength", "biCheck", "ciCount", "iuTotal", "biCode", "iniNumber", "intCount", "iriCategory", " iCode", "iCounter", "iiCounter", "iiTotal", "iLength", "intCategory", "iriCount", " icount", "giCheck", "iuCounter", "ciTotal", "phiLength", "piCount", "iiCategory", "giCount", "giLength", "piCounter"], "iTotal": ["phiNew", "imTotal", "liTotal", "aiAll", "liCount", "iComplete", "imZero", "miLast", "iToken", "iNow", "phiTemp", "iDone", "liLast", "liTemp", "diNow", " iZero", "miNew", "diTotal", " itotal", "iParent", "aiTotal", "iiZero", "liNew", "miToken", "phiLast", "miTarget", "jtotal", "iuTarget", "jTotal", "uiDone", "iAll", " iNew", "jCount", "diCount", "iitotal", "miAll", "uiTotal", "uiFull", "piParent", "iuLast", "mitotal", "iTemp", "aiComplete", "jZero", "iLast", " iTemp", "miZero", "iCurrent", "iiCount", "imCount", "piDone", "jCurrent", " iFull", "imtotal", "ciToken", "iTarget", " iParent", "piTotal", " iTarget", " iCurrent", "iZero", "iuNew", "miCurrent", "ciComplete", "iuTotal", "piFull", "itotal", "ciAll", " iNow", "phiTotal", "miTotal", "iiTotal", "miComplete", "ditotal", " iLast", "iNew", "jNow", "liParent", " iDone", "aiToken", "ciTotal", "piCount", "iFull"], "in": ["inf", "b", "v", "IN", "l", "inc", "it", "al", "inner", "cin", "h", "sum", "ins", "input", "mm", "re", "reader", "ind", "bin", "up", "In", "io", "is", "by", "or", "isin", "serv", "con", "and", "info", "mc", "ma", "check", "mn", "add", "from", "en", "get", "conf", "inn", "r", "on", "per", "ic", "out", "din", "i", " din"]}}
{"id1": "1769771", "id2": "21488518", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "copyLine", " copyFiles", "copyFiles", " CopyLine", " copyStream", " CopyFiles", "copyStream", "CopyStream", " CopyStream", "CopyLine", " copyLine", "CopyFile", " CopyFile"], "in": ["inf", "b", "IN", "l", "inc", "inner", "cin", "ins", "el", "input", "mm", "ind", "rin", "bin", "up", "In", "ini", "io", "is", "isin", "init", "old", "gin", "from", " input", "en", "inn", "r", "on", "i", "ic", "din", "source"], "out": ["o", "b", "n", "v", "to", "l", "it", "ex", "err", "res", "OUT", "at", "msg", "c", "os", "up", "ou", "Out", "io", "serv", "ot", "w", "t", "file", "s", "help", "log", "gt", "update", "op", "output", "outs", "po", "net", "p", "nt"], "inChannel": ["ainClient", "sinButton", "dinChan", " inCategory", "InChan", " inConnection", " inchannel", " inCommand", "dinConnection", "InChannel", "insideCategory", "inchannel", " inScope", "intChan", "inCase", "sinChannel", "insideChannel", "ainCategory", "intCommand", "inConnection", "ainScope", "dinchannel", "dinChannel", "inChan", "inCommand", "outChan", "innCase", "inCategory", "inScope", " inClient", "innButton", "Inchannel", "outConnection", "outchannel", "inButton", "sinCommand", " inChan", "cinChannel", "sinClient", "ainChannel", "sinRoom", "InCommand", "sinCase", " inRoom", "insideClient", "inRoom", "innClient", "inClient", "insideScope", " inButton", "innChannel", "cinRoom", "cinCommand", "intchannel", "intChannel", " inCase"], "outChannel": ["aosChannel", " outCh", "blockGate", "blockChannel", "inSection", " outManager", "parentChannel", "inchannel", "aosMember", "outGate", "neChan", "outputchannel", "blockChan", "inChan", "inCh", "outCh", "outChan", "inMember", "neChannel", "outchannel", "cnChan", " outchannel", "outputChannel", "outSection", "parentGate", " outChan", "aosChan", "blockMany", "neSection", "aosSection", "parentChan", "parentMany", "outManager", " outMany", "outputChan", "outputCh", "cnChannel", "cnManager", "outputManager", "neMember", "outMember", " outGate", "outMany"]}}
{"id1": "21979462", "id2": "7143591", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadURLoString", " downloadurltoBytes", " downloadurloText", " downloadURL2Text", " downloadURLoText", " downloadURLtoBytes", " downloadurloString", " downloadURLToBytes", " downloadURL2Bytes", " downloadurltoText", " downloadURLtoText", " downloadURLToJSON", " downloadURLToText", " downloadURLoBytes", " downloadURL2JSON", " downloadurloJSON", " downloadURL2String", " downloadurltoString", " downloadurltoJSON", " downloadURLtoJSON", " downloadURLToString", " downloadurloBytes", " downloadURLoJSON"], "url": ["browser", "http", "rect", "link", "web", "l", "ll", "address", "location", "base", "name", "char", "ul", "un", "mail", "ssl", "dl", "ret", "ref", "ur", "domain", "bel", "mount", "URL", "gl", "file", "resource", "log", "Url", "job", "sl", "id", "all", "run", "ls", "uri", "uu"], "in": ["inf", "oin", "thin", "IN", "ill", "it", "inc", "al", "inner", "cin", "sum", "ins", "input", "re", "reader", "ind", "bin", "up", "In", "is", "io", "again", "by", "or", "isin", "con", "and", "info", "copy", "mc", "er", "check", "ma", "mn", "ai", "gin", "from", "read", "all", "conf", "inn", "on", "ic", "out", "din", "i"], "sb": ["pb", "b", "bj", "bh", "bis", "bd", "rob", "zb", "lb", "ub", "bt", "rb", "bp", "gob", "sk", "ab", "sa", "bn", "ssl", "lp", "bf", "sam", "bg", "sp", "cb", "ib", "sf", "kb", "gc", "bsp", "wb", "sd", "gb", "bb", "eb", "xb", "db", "nb", "mb", "bs", "sg", "erb", "SB", "sq", "pa"], "str": ["syn", "m", "b", "n", "comp", "print", "list", "l", "err", "pt", "cat", "tr", "source", "dat", "Str", "chain", "obj", "string", "re", "dr", "req", "msg", "exec", "arr", "char", "comm", "text", "cont", "j", "vol", "ch", "sp", "ls", "br", "st", "div", "comment", "iter", "block", "cur", "STR", "next", "t", "sts", "s", "del", "part", "sl", "set", "def", "bc", "fr", "bl", "expr", "r", "gr", "i", "txt", "p"]}}
{"id1": "8093133", "id2": "21425787", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXmlAsWeb", "loadXmlAsUrl", "loadXmlFormUrl", "loadXmlAsURL", "loadXMLFormURL", "loadXmlFormFile", "loadXmlAsFile", "loadXMLFromFile", "loadXmlFromWeb", "loadXmlFormURL", "loadXmlWithFile", "loadXmlWithUrl", "loadXmlFormWeb", "loadXMLFormWeb", "loadXmlWithWeb", "loadXmlFromFile", "loadXMLFormFile", "loadXmlWithURL", "loadXMLFromUrl", "loadXMLFormUrl", "loadXMLFromWeb", "loadXMLFromURL", "loadXmlFromURL"], "url": ["http", "b", "n", "link", "web", "l", "in", "ll", "html", "xml", "address", "user", "input", "res", "location", "base", "name", "loc", "document", "open", "char", "str", "abs", "ssl", "u", "build", "ur", "nl", "domain", "bel", "request", "URL", "file", "log", "Url", "job", "sl", "id", "get", "host", "path", "page", "uri"], "timeout": ["to", "capacity", "time", "resolution", "mode", "policy", "duration", "it", "network", "amount", "server", "window", "until", "directory", "term", "seconds", "limit", "monitor", "total", "period", "padding", "sleep", "io", "type", "latest", "password", "Timeout", "client", "frequency", "number", "unit", "version", "size", "wait", "t", "max", "course", "blocking", "exclusive", "OUT", "out", "length", "buffer", "height", "delay"], "xmlType": ["mlUnit", "imageBlock", "complextype", " xmlStyle", "xmlBlock", "fileBlock", " xmltype", "complexUnit", "xmltype", " xmlUnit", "fileStyle", "xmlStyle", " xmlTyp", " xmlBlock", "xmlUnit", " xmlTypes", "fileType", "mlTyp", "fileTypes", "imageStyle", "xmlTypes", "complexTyp", "mltype", "mlType", "imageTypes", "xmlTyp", "complexType", "imageType"], "connection": ["entry", "to", "link", "conn", "command", "condition", "socket", "pointer", "generation", "network", "usage", "session", "computer", "city", "user", "statement", "connected", "system", "database", "directory", "response", "Connection", "c", "builder", "still", "open", "description", "io", "client", "number", "cone", "subject", "nc", "application", "con", "position", "established", "internet", "manager", "connect", "ion", "resource", "creation", "config", "creator", "close", "opening", "relation", "reference", "channel", "communication", "character", "current", "uri"], "buffInputStream": ["BuffOutputStream", "BuffInputForm", "BuffOutputForm", "BuffOutputSteam", "buffIOField", "buffOutputForm", "BuffInputChannel", "buffEntityStream", "buffEntityChannel", "buffOutputSteam", "buffEarForm", "BuffInputStream", "buffOutputStream", "buffIOForm", "buffInputChannel", "buffEarField", "buffEarSteam", "BuffInputField", "buffOutputField", "buffEntityForm", "buffOutputChannel", "buffInputForm", "BuffInputSteam", "buffEarStream", "BuffOutputField", "buffInputSteam", "buffIOStream", "buffInputField", "buffIOSteam", "BuffOutputChannel"]}}
{"id1": "9802073", "id2": "1371265", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 1, "substitutes": {"testAutoCommit": ["testAutoCommits", "testAutoDebute", "testAutoCompute", "testAutoComits", "testAutoComit", "testAutoCommute", "testAutoCompit", "testAutoCompmit", "testAutoCompits", "testAutoDebit", "testAutoComute", "testAutoCommmit", "testAutoDebits", "testAutoDebmit"], "con": ["ca", "conn", "ac", "gen", "cat", "cp", "dial", "canon", "cos", "ctx", "obj", "call", "Conn", "res", "clean", "re", "rec", "c", "xc", "cons", "cf", "col", "ct", "client", "comm", "ver", "bo", "fc", "connection", "nc", "rc", "co", "act", "enc", " conn", "fac", "ln", "mc", "cur", "win", "com", "don", "connect", "coll", "CON", "ran", "go", "local", "gc", "ctrl", "const", "can", "fl", "bc", "en", "ain", "cm", "conf", "cal", "pen", "cc", "out", "cn", "conv", "tc", "Con"], "stmt": [" stmm", " superstmt", "STmb", " stpt", " stmb", " superstm", "Stmp", "Stmm", "stm", "statm", "StMT", "statmt", "STm", "starm", " stmp", "strm", "stmp", "Stct", "stmb", " stm", "strmm", "STMT", "Stmt", "statmm", "strmb", "stpt", "stgr", " stgr", "statmb", "statct", "Stmb", "stmm", "strgr", "STpt", "Stpt", "stct", " superstarm", "strmt", " starm", "stMT", " stMT", "Stm", " superstmb", "strmp", " stct", "STmt", "Starm", "statgr", "STmp"], "rs": ["ks", "irms", "acks", "RS", "ris", "js", "ws", "times", "rt", "qs", "ins", "res", "obs", "rd", "ubs", "ems", "ires", "cks", "ss", "hs", "icks", "vers", "its", "ows", "ras", "vs", "sys", "usr", "rc", "ms", "ls", "ys", "ars", "cs", "ags", "acs", "results", "ues", "xs", "rates", "sts", "dds", "Rs", "ares", "ats", "fs", "mr", "arms", "ers", "rys", "stats", "ims", "ges", "bs", "ra", "ds", "gs", "rows", "sr", "ros"]}}
{"id1": "22431487", "id2": "7499186", "code1": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"doPost": ["doQuery", " doPOST", "DoGet", "DoPOST", "internalGet", " doQuery", "internalPost", " doGet", "doGet", "internalPOST", "internalQuery", "DoQuery", "DoPost", "doPOST"], "URL": ["HTTP", "TL", "Location", "IN", "Path", "Name", "NAME", "SOURCE", "L", "SSL", "PORT", "HTML", "Address", "OUT", "CL", "SR", "RL", "EL", "LL", "AT", "API", "GET", "METHOD", "URI", "STR", "url", "REF", "UL", "Url", "PATH", "RAW", "IL", "DL", "PUT", "ID", "UR", "FILE"], "params": ["batch", "idents", "forms", "words", "settings", "tags", "ops", "members", "requires", "pins", "times", "parts", "keys", "points", "options", "mm", "posts", "lines", "param", "rs", "details", "properties", "ams", "months", "json", "actions", "photos", "Parameters", "AMS", "sql", "Par", "phys", "par", "news", "names", "changes", "packages", "items", "config", "fields", "styles", "amps", "stats", "ps", "pps", "values", "ports", "pages", "marks", "terms", "vals", "p"], "util": ["http", "uh", "security", "ility", "ui", "usage", "install", "utf", "hog", "til", "fu", "mu", "rot", "iu", "form", "hu", "il", "ul", "api", "u", "Ut", "um", "lu", "utils", "wal", "ut", "eu", "info", "cu", "ool", "fun", "url", "nu", "format", "help", "etc", "modern", "tu", "hum", "lib", "ils", "conv", "tree"], "uri": ["http", "wiki", "ui", "link", " URI", "source", "address", "based", "phi", "uni", "location", "term", "directory", "msg", "base", "prefix", "client", "uid", "subject", "api", "u", "pi", "unit", "ur", "sky", "ref", "domain", "du", "URI", "ri", "url", "nu", "resource", "service", "range", "course", "quote", "host", "this", "path", "uu"], "httpclient": ["hClient", "Httpclient", "httpserver", "httpsnet", "httpsconnection", " httpce", "httpClient", "Httpnet", "hce", "Httpconnection", "httpnet", "Httpce", "hclient", "httpsClient", " httpconnection", "httpsclient", " httpnet", " httpserver", " httpClient", "HttpClient", "httpconnection", "httpce", "Httpserver", "hserver"], "postMethod": ["putField", "preMethod", "PostMETHOD", "preRequest", "httpField", "putMETHOD", "httpOperation", "pubOperation", "postField", "postClient", "putClient", "httpMethod", "postOperation", "pubRequest", "handleMethod", "pubMethod", "putOperation", " postMETHOD", "PostOperation", "putMethod", "handleClient", "pubMETHOD", "PostMethod", "preOperation", "postRequest", "putRequest", "handleMETHOD", "PostField", "handleRequest", " postRequest", "httpmethod", "postmethod", "preMETHOD", "putmethod", " postClient", "Postmethod", "PostRequest", "postMETHOD"], "paramString": ["paramSet", "paramBuffer", "ParamUnit", "ParamList", "permChain", "aramString", "pstring", "permFile", "ParamStr", "termNumber", " paramSet", "paramstring", "termString", "processstring", "postStr", "permBuffer", "paramStr", "paramsSet", " paramChain", "attributeBuffer", "paramsUnit", "ParamArray", "attributeArray", " paramFile", " paramNumber", "attributeString", "permNumber", "postBuffer", "postString", "ParamBuffer", "paramsList", "aramStr", "ParamShort", "paramList", "permString", "paramsstring", "paramsStr", " paramUnit", "paramChain", "permByte", "pSet", " paramStr", "attributeByte", "pStr", "termFile", "paramNumber", "paramShort", "paramArray", " paramList", "termChain", "processString", "ParamString", "aramShort", "paramByte", "aramBuffer", "paramsString", "pString", "permArray", "paramUnit", "paramFile", "ParamByte", "postShort", "argString", " paramstring", "argstring"], "i": ["m", "b", "ip", "in", "it", "ei", "key", "q", "c", "y", "iv", "ini", "is", "io", "fi", "bi", "pi", "me", "init", "t", "mi", "ix", "a", "hi", "o", "v", "index", "im", "oi", "ii", "gu", "u", "j", "eu", "id", "ic", "x", "I", "xi", "p", "ci", "ui", "ind", "ql", "ori", "iu", "f", "il", "ms", "info", "ai", "sim", "di", "or", "si", "ie", "d", "ij", "multi", "gi", "ami", "chain", "phi", "us", "li", "ski", "e", "er", "ia", "ims", "my", "slice", "ti", "ji", "qi", "uu"], "xx": ["kw", "xy", "XXXX", "von", "yy", "aaa", "ous", "fw", "wx", "zzy", "xxxxxxxx", "y", "xxxx", "zz", "bu", "xxx", "ang", "ng", " XX", "yk", "enc", "kk", "txt", "hex", "ux", "xs", "XXX", "mk", "smith", "pp", "ck", "hz", "ess", "REDACTED", "fx", "x", "fy", "foo", "xi", "XX"], "httpResponse": [" httpresponse", " httpEntity", "HttpResponse", " httpRes", " httpResp", "httpsResponse", "consoleResponse", "httpAnswer", "consoleEntity", "consoleresponse", "httpResp", "ttpResp", "httpClient", "ttpresponse", "httpresponse", "ttpEntity", "ttpResponse", "HttpResp", "HttpRes", "httpsRes", "httpsresponse", "httpsClient", "ttpClient", "consoleAnswer", "ttpAnswer", "Httpresponse", "httpRes", "httpEntity", " httpClient", " httpAnswer", "ttpRes"], "strResult": ["Strresult", "stringResult", "STRNow", " strRes", "StrNow", "StrResult", "strRest", " strRest", "txtRes", "STRRest", "StrResults", "stringresult", "txtResults", "StrRes", "STRRes", "STRResults", "txtNow", "strNow", "strResults", "strRes", " strresult", "strresult", "STRresult", "txtresult", "txtRest", "stringResults", "txtResult", " strResults", "STRResult", "stringRes"]}}
{"id1": "1180878", "id2": "7087108", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrlFrame", "fetchGETFrame", "fectUrlFrame", "fetchUrlStream", "fectUrlStream", "fectURLStream", "fetchStringStream", "fetchUrlData", "fetchURLStream", "fetchURLFrame", "fetchStringData", "fectURLdata", "fetchStringFrame", "fetchStringdata", "fetchGETStream", "fectURLData", "fetchUrldata", "fectUrldata", "fectURLFrame", "fectUrlData", "fetchGETdata", "fetchURLdata", "fetchGETData"], "url": ["http", "b", "pl", "link", "print", "null", "web", "l", "html", "ll", "xml", "address", "full", "rel", "el", "string", "location", "base", "name", "loc", "ul", "mail", "ssl", "dl", "sql", "ref", "ur", "nl", "lim", "domain", "mount", "https", "URL", "gl", "file", "resource", "pattern", "log", "Url", "sl", "cl", "host", "default", "path", "ls", "uri"], "proxyHost": ["slaveUrl", "roxyHost", "roxyUrl", "slavehost", "ProxyName", "slaveOver", "proxyCheck", "proxyAddress", "roxyLabel", "ProxyUrl", "roxyOver", "ProxyLabel", "slaveHost", "roxyhost", "serverHost", "slaveLabel", "serverhost", "proxyUrl", "roxyCheck", " proxyOver", "proxyName", " proxyName", " proxyhost", "slaveCheck", " proxyAddress", "proxyOver", "proxyhost", "Proxyhost", "serverPort", "serverName", " proxyCheck", "proxyLabel", "roxyAddress", "slaveAddress", "ProxyPort", "ProxyHost"], "proxyPort": ["serverport", "serverAddress", "proxyAddress", "proxyPORT", "aliasPort", "ProxyPORT", "aliasAddress", "serverHost", "aliasport", "Proxyport", " proxyport", "serverPORT", " proxyPORT", " proxyAddress", "proxyport", "serverPort", "ProxyPort", "aliasHost", "ProxyHost"], "con": ["syn", "conn", "gate", "cat", "ex", "cp", "dial", "canon", "cos", "proc", "cgi", "call", "Conn", "rec", "cond", "pan", "c", "xc", "cons", "open", "cf", "col", "cmd", "client", "comm", "non", "fin", "un", "cone", "cont", "trans", "bo", "func", "fc", "connection", "nc", "act", "co", "ocon", "pc", "fac", "cs", "mc", "cur", "ln", "connect", "go", "don", "com", "CON", "ran", "ctrl", "const", "close", "can", "bc", "en", "cover", "mo", "ain", "conf", "cal", "sub", "po", "pen", "lock", "ver", "cc", "cn", "conv", "Con"], "is": ["ip", "dis", "ris", "isi", "in", "oss", "bis", "lis", "sis", "ists", "has", "us", "isa", "are", "was", "ins", "im", "ais", "gets", "rs", "os", "ois", "its", "IS", "abs", "sys", "Is", "mis", "eps", "isin", "iso", "isf", "ms", "bits", "init", "ys", "ios", "isp", "iter", "cs", "ri", "xs", "s", "iss", "ts", "es", "fs", "iris", "ist", "as", "isl", "ims", "ps", "bs", "i", "ains", "isc", "si"], "u": ["su", "o", "ui", "uv", "fu", "us", "uni", "pu", "user", "mu", "c", "up", "bu", "iu", "ou", "uf", "ue", "hu", "ul", "un", "uid", "yu", "lu", "ur", "ud", "ut", "eu", "au", "nu", " nu", "uj", "U", "tu", "g", "i", "ru", "cu", "uri", "uu"], "proxy": ["browser", "http", "ping", "ip", "xy", "cache", "shadow", "link", "null", "web", "project", "pointer", "policy", "pin", "phone", "cp", "socket", "address", "server", "pe", "via", "prime", "timeout", "token", "base", "gp", "aco", "pro", "jp", "friend", " proxies", "roxy", "client", "password", "alias", "cone", "echo", "bo", "pi", "cas", "connection", "ssl", "domain", "pipe", "version", "py", "PRO", "https", "go", "port", "slave", "profile", "map", "pre", "library", "embed", " prox", "host", "Proxy", "zip", "po", "pool", "translation", "pse", "x", "XY"], "baos": ["naows", "BAOs", "baOS", "vaOS", "poos", "BAoss", " baose", "poose", "nao", "aooS", "aoos", "aoOS", "vais", " baOs", "poo", " baoS", "bao", "baoss", "aois", " baOS", "BAo", "naoss", "bais", "vaoS", "BAose", "naos", " bao", "BAows", " baows", " bais", "baOs", "baose", "BAos", "baows", "baoS", " baoss", "vaos", "poOs"]}}
{"id1": "6009527", "id2": "15768167", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishShowAttachment", "doFinishLoadAttachention", "doFinishShowDetention", "doFinishLoadAttachached", "doFinishLoadAttachachment", "doFinishShowDetached", "doFinishShowDetachment", "doFinishLoadDetention", "doFinishLoadAssachment", "doFinishLoadDetachment", "doFinishLoadAttention", "doFinishLoadDetached", "doFinishLoadAttached", "doFinishShowAttention", "doFinishShowAttached", "doFinishLoadAssached", "doFinishLoadAssention"], "attachmentId": ["ATTachmentKey", "attociationKey", "atachmentID", "attachmentKey", "ATTociationKey", "atutationId", "attentionId", "ATTachmentById", "attgmentid", "ATTachmentId", "ATTociationById", "attachmentID", "attachedById", "atutationById", "attentionName", "attachmentName", "detachmentKey", "attociationid", "attachmentById", "attgmentId", "detachedid", "attentionById", "attachmentid", "attociationName", "attagramById", "attgmentKey", "atachmentName", "atachmentId", "detachmentid", "ATTociationId", "attutationID", "attachedId", "attociationID", "detachedKey", "attagramId", "attutationName", "attutationById", "attachedKey", "attentionID", "ATTociationid", "attachedid", "atutationName", "attutationId", "detachmentId", "attagramKey", "attociationById", "attagramid", "atutationID", "atachmentById", "detachedId", "ATTachmentid", "attociationId"], "attachment": ["attached", "contached", "attaching", "attention", "assaching", "assached", "assacher", "detment", " attment", "detached", "attachacher", "addaching", "contment", " attached", "association", "addociation", "assachment", "attachached", "attachaching", "detacher", "ATTachment", "ATTention", "detachment", "attment", "attociation", "assention", "attacher", "attachachment", "ATTached", " attacher", "attachociation", "ATTacher", "contacher", "addached", "attachention", "addachment", "contachment"], "attachmentUri": ["attentionUtri", "attachmentUtrid", "attachmentUpi", "attachmentOURI", "attachmentUtRI", "attachableOri", "attachmentuRI", "attachableOpi", "attachmentUrid", "attachableUri", "attachmentOri", "attachmenturi", "attentionUtpi", "attentionUpi", "attachmentTpi", "attachableUURI", "attachableOURI", "attachableUpi", "attachmentUnURI", "attachmentUnuri", "attentionURI", "attachmenturid", "attachableUuri", "attachmentOpi", "attachmentURI", "attentionUrid", "attachmentTURI", "attachmentupi", "attachmentOuri", "attachmentUnpi", "attachmentUnri", "attachmentUtri", "attachmentUuri", "attachmentUtpi", "attachableOuri", "attachmentTri", "attentionUri", "attachmentUURI", "attentionUtRI", "attachmentTuri", "attentionUtrid"], "contentUri": ["messageUuri", "contentUnri", "contentUsrid", "resourceURuri", "contentUuri", "contentURI", "contentUtiri", "resourceURI", "contentUsri", "ContentUris", "contentUtris", "resourceUri", "contentUsris", "contentUris", "contentUric", "messageUiri", "resourceURres", "contentuRI", "contentUnuri", "contentUtrid", "contentURri", "contentuuri", "contentUrri", "contentUtRI", "ContentUuri", "ContentUrid", "contentUrric", "contentURres", "contentUriri", "messageUtri", "contentUtres", "messageUturi", "messageUric", "contentSri", "contentUturi", "ContentUsris", "contentSiri", "contentUiri", "resourceURri", "contentURuri", "contentUres", "ContentUsri", "contentUsuri", "contenturi", "contentUrid", "contentURRI", "resourceUres", "contentures", "contentSuri", "resourceURRI", "resourceUuri", "contentUtric", "contentUnris", "contentUnrid", "contentSric", "messageUtiri", "contentUtri", "ContentUsuri", "contentUruri", "messageUri", "messageUtric", "ContentUsrid", "ContentUri"], "file": ["to", "ca", "link", "rule", "disk", "header", "create", "angle", "h", "filename", "play", "user", "folder", "entity", "image", "template", "base", "name", "table", "document", "type", "line", "f", "ile", "media", "il", "channel", "fp", "files", "init", "dir", "work", "save", "upload", "sf", "port", "le", "resource", "File", "local", "format", "from", "result", "content", "picture", "zip", "output", "db", "path", "pool", "page", "message", "buffer", "FILE", "tree", "source"], "in": ["inf", "IN", "l", "it", "inc", " IN", "al", "inner", "cin", "body", "ins", "play", "input", "ind", "rin", "bin", "up", "In", "inside", "is", "io", "ini", "ar", "sql", "isin", "con", "and", "gin", "from", "mi", "read", "en", "ain", "inn", "on", "ic", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "v", "print", "null", "screen", "ex", "it", "oss", "flush", "obj", "res", "OUT", "os", "ou", "Out", "io", "aos", "writer", "client", "outer", "sys", "co", "write", "serv", "con", "put", "ao", "check", "w", "auto", "can", "all", "g", "OU", "output", "outs", "stable", "net", "i", "conv", "nt"], "intent": ["man", "entry", "express", "continue", "condition", "xml", " Intent", "q", "inv", "displayText", "statement", "window", "term", "entity", "activity", "ence", "verbal", "activation", "device", "json", "venture", "act", "concept", "context", "ment", "prom", "intention", "activate", "init", "phrase", "Activity", "automatic", "asso", "spirit", "inst", "ant", "agent", "complete", "service", "ent", "widget", "wordpress", "query", "skill", "voice", "alert", "initial", "event", "animate", "ident", "ic", "ink", "method", "action", "communication", "text"]}}
{"id1": "16550855", "id2": "14038176", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"readPage": ["writepage", "writePages", " readArticle", "printPage", "readpage", " readPages", "writePage", "printpage", "readPages", " readpage", "printArticle", "printPages", "readArticle", "writeArticle"], "ignoreComments": ["ignoreQuotes", "oreBlocks", "oreLeaks", "oreNotes", "hideLeaks", " ignoreComment", "hideBlocks", " ignoreQuotes", "ignoreTags", "hideComments", "ignoreComment", " ignoreBlocks", "oreQuotes", " ignoreNotes", "hideNotes", "oreComments", "hideComment", " ignoreLeaks", "hideTags", " ignoreTags", "ignoreBlocks", "oreComment", "oreTags", "ignoreNotes", "hideQuotes", "ignoreLeaks"], "in": ["inf", "m", "b", "thin", "IN", "ill", "inc", "it", "al", "inner", "cin", "sum", "h", "ins", "doc", "input", "mm", "reader", "ind", "rin", "bin", "up", "In", "is", "io", "client", "again", "isin", "init", "con", "and", "info", "old", "mc", "ma", "check", "copy", "mn", "add", "url", "from", "read", "all", "en", "get", "conf", "cal", "cm", "inn", "r", "on", "ic", "out", "din", "i", " din"], "inputLine": ["inputLo", "latLine", "rawline", "rawRow", "indexLine", "resultLINE", "InputCell", "inputEntry", "helloNet", "inputline", "indexLo", "indexLINE", "rawChain", "helloLine", " inputCell", " InputBlock", "resultName", " Inputline", " InputEntry", "latRow", "resultLine", "helloLo", "outputBlock", " inputRecord", " inputName", "InputNet", "multiLo", "outputRow", " inputline", "inputCell", " inputNet", "helloLINE", "Inputline", "helloLin", "multiLINE", "inputRow", "multiLin", "outputLine", "inputChain", " inputBlock", "outputline", "inName", "latline", "helloCell", "inputName", "inputBlock", "inputNet", "inputLin", " inputLINE", " InputLine", " inputEntry", "inputRecord", "resultRecord", "multiLine", "rawLine", "inRecord", "inLINE", "inLine", "inputLINE", "InputLine", " inputRow", "latChain", "helloRow", "helloBlock", " inputChain", "InputRow", "indexLin", "InputBlock", "InputEntry"], "html": ["browser", "att", "cache", "tml", "detail", "header", "data", "full", "hd", "hash", "attr", "total", "msg", "layout", "mail", "https", "url", "rss", "page", "current", "css", "human", "raw", "web", "theme", "enabled", "h", "template", "built", "img", "api", "title", "htm", "emphasis", "value", "result", "content", "alert", "output", "p", "summary", "js", "md", "err", "xml", "hard", "body", "available", "flash", "f", "str", "format", "tt", "db", "esi", "message", "pretty", "sg", "hover", "ht", "http", "multi", "rendered", "has", "HTML", "related", "wrapper", "details", "form", "json", "pdf", "dump", "embed", "plain", "view", "height"]}}
{"id1": "17773263", "id2": "11377441", "code1": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"visar": [" visatar", "visatar", "Visitatar", "Visita", "visa", "Visatar", " visa", "Visa", "Visar", "Visitado", "Visitar", "Visado"], "ClassNotFoundException": ["ClassNotPresentError", "ClassNotSupportedException", "ClassNotFoundError", "ClassDefFoundError", "ClassNotPresentException", "ClassNotfoundException", "ClassNotfoundError", "ClassNotSupportedError", "ClassDefPresentException", "ClassDefPresentError", "ClassDefFoundException"], "Exception": ["Throw", "Example", " exception", "ception", "Index", "Result", "Message", "Operation", "Configuration", "Document", "Connection", "Class", "Context", "Handler", "Record", "Error", "Exit", "Status", "Application", "Warning", "Instance", "File", "E", "None", "Array", "Event"], "conn": ["n", "js", "pg", "gate", "socket", "cp", "yn", "oss", "ann", "wp", "ctx", "rel", "obj", "Conn", "res", "wr", "exec", "rs", "Connection", "c", "jp", "cons", "open", "cert", "cmd", "ct", "ont", "comm", "client", "fin", "gn", "enc", "org", "connection", "sql", "nc", "ch", "co", "sp", "con", "txt", "irm", "cur", "connect", " con", "coll", "ran", "config", "close", "can", "en", "conf", "db", "pen", "ec", "pool", "cc", "ns", "cn", "conv", "Con", "p", "nt"], "ps": ["ping", "css", "pl", " pp", "pr", "pos", "pt", "js", "pg", "ops", "cp", "qs", "pins", "pd", "wp", "proc", "points", "pe", "pa", "ins", "res", "PS", "ress", "posts", "als", "itions", "rs", "jp", "ples", "fps", "plays", "its", "ends", "vs", "fp", "eps", "ms", "sp", "ls", "ys", "pc", "cs", "pas", "pers", "mp", "s", "aps", "ips", "ts", "ats", "fs", "pp", "pres", "gres", "ups", "sts", "Ps", "amps", "stats", "ims", "pps", "ies", "uts", "ports", "bs", "pse", "gs", "p"], "fechaSystem": ["fechoaSTEM", "fetchaBase", "fechaBase", "fechasServer", "fechaServer", "fechasSys", "fespoaSTEM", "fechsaProcess", "fetchaSys", "fechoaServer", "fachoaServer", "fechsaSTEM", "fespaSystem", "fespaProcess", "fechoSys", "fespaSTEM", "fetchaServer", "fachaSys", "fachoaSys", "fechaeServer", "fachoaSystem", "fechaeSys", "fechasBase", "fechoProcess", "fechaSTEM", "fetchaSystem", "fechASys", "fechoaProcess", "fechoSystem", "fechaSys", "fechasSystem", "fechABase", "fechoServer", "fetchoSystem", "fechaProcess", "fetchoBase", "fetchoSys", "fachaSystem", "fechoSTEM", "fechsaSystem", "fechoaSys", "fespoaSystem", "fechaeSystem", "fachaServer", "fechoaSystem", "fetchoServer", "fechASystem", "fespoaProcess", "fechoBase"], "aaaammdd": ["aaalammde", "aaaaammdd", " baambss", " baambds", "aaaaumde", "aaaaammm", "aaaammd", " baammd", "aaaammds", "aaapmd", "aaalammdd", " baammds", " baammss", "aaaambss", "aaaaumd", "aaaammmm", "aaaammde", "aaalammd", "aaapmss", "aaaaamd", "aaaamss", "aaaamd", "aaaaammmm", "aaaamds", " baambdd", "aaaaamdd", "aaapmds", "aaaammss", "aaaaammd", "aaaaummm", "aaaaammde", " baambd", "aaalammmm", "aaaammm", "aaaamdd", "aaaaumdd", "aaaambd", "aaaambds", "aaapmdd", "aaaaamde", "aaaamde", "aaaambdd", " baammdd"], "hhmmss": ["hhtmcss", "HHmmss", "ohmmess", "hhmbcss", "HHMMss", "hhmmess", "hhMMss", "hhmmrss", "ohmmms", "HHmmrss", "hhmmms", "hhmyrss", "hhmmps", "hhmmmess", "ohtmss", "ohtmms", "hhmyss", "hhMMps", "hhmmmcss", "hhMMrss", "ohmmss", "hhtmms", "hhmmmss", "hhmmmms", "hhmbess", "HHMMs", "hhmmmrss", "hhmyps", "hhmbss", "hhtmess", "HHMMrss", "hhMMs", "ohtmess", "ohtmcss", "hhmbms", "hhmmmps", "ohmmcss", "HHmmps", "hhmmcss", "hhtmss", "HHMMps", "hhmys", "HHmms", "hhmms"], "sss": ["ssis", "rssis", "\u00dfis", "cssis", "ysss", "ssh", "cssh", "ssls", "ssd", " ssy", "ssy", "rsss", "rssd", "yssys", "csss", " ssls", "yssy", "yssls", "essys", "essy", " ssys", "\u00dfh", "cssd", "\u00dfs", "esss", "ssys", "essls", "\u00dfd", "rssh"], "ss": ["ping", "css", "js", "oss", "ws", "ass", "less", "ssh", "html", "aws", "sy", "hess", "string", "rs", "os", "ews", "dd", "tis", "ssl", "sys", "sv", "sql", "ms", "SS", "bytes", "ys", "cs", "\u00df", "sf", "https", "tz", "s", "iss", "ts", "se", "pres", "es", "ses", "sd", "course", "tt", "rss", "styles", "sol", "good", "stats", "sb", "esi", "ess", "bs", "pps", "ns", "ds", "ls", "sq"], "sentenciaSql": ["sentenciaSourceql", "sentenciaStringq", "sentenceSsql", "sentenciaInsq", "sentenciaDq", "sentenciaDel", "sentenzaSq", "sentenciaInsel", "sentenciaInssql", "sentenceSQL", "sentenzaInseed", "sentenzaSel", "sentenciaStringsql", "sentenciaDeed", "sentenciaInseed", "sentenciaSourceel", "sentenciaSQL", "sentenciaSsql", "sentenceSq", "sentenzaSql", "sentenzaInsq", "sentenciaSeed", "sentenceSql", "sentenciaInsql", "sentenciaStringQL", "sentenzaSeed", "sentenciaInsQL", "sentenciaSq", "sentenciaDql", "sentenzaInsql", "sentenciaSel", "sentenciaStringql", "sentenzaInsel", "sentenciaSourceq", "sentenciaSourceeed"], "contador": ["\u00e7offer", "contoffer", "contrane", "frontator", " contabo", "portador", "controlator", " Contpointer", "montadr", "contactarter", "contamina", "contabo", "ontamo", "colator", "portainer", " contarter", "ontarter", "constpointer", "colainer", "CONTador", "intador", "controlador", "intadr", "frontador", "ontador", "colador", " contator", "frontamo", "montador", "contactador", "portator", "constoffer", "contarer", "contamo", "contactator", "contactarer", "constadr", " Contamina", "ontadr", "ontator", " Contador", "constano", "constador", " contamo", "contano", "contdoor", "controlarer", "\u00e7ano", "contadr", "contarter", " contdoor", "frontarter", "constrane", " contadr", " contpointer", "intainer", " contoffer", "portabo", "CONTpointer", " contrane", " contamina", " container", "CONTamina", " contorno", "\u00e7orno", "constdoor", "constorno", "montamo", "contator", " contano", "constator", "ontdoor", "ontarer", "constainer", "colabo", " Contator", "CONTator", "container", "controlarter", "contpointer", "intpointer", "montator", "\u00e7ador", "ontrane", "contorno"], "visado": [" visando", "Visado", "Visando", "visada", "Visados", "Visada", "visando", "visados", " visitada", " visados", " visada", " visitando", " visitado", " visitados"]}}
{"id1": "15737836", "id2": "2198730", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["insert", "lete", "link", "Delete", "create", "execute", "destroy", "download", "clean", "database", "load", "remove", "touch", "clear", "write", "save", "move", "add", "dump", "del", "set", "update", "get", "disable", "de", "drop", "select", "quit"], "site": ["http", "rule", "link", "settings", "sites", "network", "source", "theme", "node", "data", "session", "server", "test", "ste", "environment", "chain", "store", "index", "software", "at", "template", "base", "group", "name", "station", "isite", "localhost", "scan", "sys", "ze", "unit", "e", "sample", "domain", "pse", "info", "Site", "ite", "file", "service", "se", "sit", "config", "course", "set", "path", "page", "remote", "item"], "dbo": ["ddbo", "ddado", "dmu", "gBO", "odbu", "sdbu", "sdbo", "sdBO", "Dbo", "delmu", "dbu", "ddBo", "lbo", "draBo", "lBo", "ppo", "lambo", " dado", "drabo", "dBO", "dambo", "DBo", "debugbo", "Dbon", "lpo", "DBO", " dBo", "gbo", "delbo", "pmu", "ddpo", " dbon", "drabon", "debugambo", "odpo", "odBo", "ddbu", "pbo", "delpo", "ddBO", " dBO", " dbu", " dambo", "drapo", "Dmu", "delbu", "dBo", "debugBo", "dpo", "gbu", "dado", "Dbu", "Dpo", "Dado", "odbo", "pbu", " dpo", "dbon", "debugpo"], "connection": ["link", "conn", "command", "condition", "socket", "settings", "generation", "network", "pointer", "usage", "operation", "session", "function", "server", "chain", "computer", " Connection", "city", "controller", "statement", "connected", "system", "location", "database", "directory", "information", "response", "Connection", "c", "table", "document", "open", "collection", "writer", "handler", "client", "engine", "container", "cone", "associated", "closure", "bo", "subject", "context", "application", "intention", "con", "government", "position", "established", "manager", "connect", "ion", "binding", "resource", "library", "auto", "config", "creator", "office", "created", "console", "relation", "management", "output", "po", "db", "reference", "pool", "net", "communication", "character", "current"], "preparedStatement": ["preformedGrant", " prefixedStatement", "preferredStatement", "previsedStatus", "premittedAdapter", "prelatedDevice", "prepparedstatement", "perachedAdapter", "preparableListener", " prefixedQuery", "preculatedQuery", "prepferredStatement", " preachedStatement", " preachedStat", " preparedGrant", "preformedCall", "preppedStatement", "PreppedStatement", "premittedComment", " preparedstatement", "preppedstatement", "premedStatus", "preparedComment", "preachedStyle", " preparedCopy", "prefixedCall", "paredStatus", "pretparedListener", "pparedStat", "preendedStatement", "preparedStat", "PreparedStatement", "prefixedQuery", "previsedStat", "perachedStatement", "preppedStatus", " preparedQuery", " prefixedstatement", "prepparedSQL", "preendedQuery", "paredStat", "preparedStatus", "Preparedstatement", "prepletedDevice", "previsedStatement", "preparableStatement", "premittedStatement", "preferredstatement", "prepletedStatement", "postppedCall", " preachedGrant", "postparedstatement", "prearedCall", "prepferredQuery", "preculatedstatement", "pparedStatement", "preparedCall", "preculatedSQL", "preinitializedComment", "premittedStyle", " preparedCall", "prepletedStat", "preparedQuery", "preachedComment", "preferredCall", "prejectedstatement", "preinitializedAdapter", "perparedComment", "prefixedStatement", "prearedComment", "prepparedCall", "pretparedStatus", "pretparableStatement", "prearedstatement", "preparedListener", "prearedStatement", "preparedGrant", "pparedStatus", "prepferredstatement", "preformedStatement", "prearedDevice", "preppedQuery", "prearedListener", "PrearedDevice", "preinitializedStatement", "prelatedStatement", "preparedStyle", "paredQuery", "Prearedstatement", "prelatedstatement", "preparedCopy", "perparedStatement", "perparedAdapter", " prefixedCopy", "preachedAdapter", "postparedStatement", " preachedCall", "preformedStat", "preparedstatement", "pparedQuery", "prepparedQuery", "perachedStyle", "prearedQuery", "preparedDevice", "prepletedstatement", "postppedStatement", "previsedQuery", "pretparableListener", "prepletedComment", "preparedSQL", "preendedstatement", "PreparedComment", "premedListener", "PreparedQuery", "pretparedStatement", "preculatedStatement", "preachedstatement", "preachedStatement", "prelatedComment", "PreppedQuery", "prepletedGrant", "PrearedStatement", "postppedstatement", "prejectedQuery", "prearedStatus", "PrearedComment", "prearedSQL", "preachedGrant", "preachedCall", "prearedCopy", "prefixedCopy", "premedStatement", "Preppedstatement", "preinitializedStyle", "paredStatement", "preachedStat", "preferredSQL", "perachedComment", "prejectedCopy", "prearedStat", "pretparableStatus", "prepparedStatement", "PreparedDevice", "preppedStat", "postparedCall", "perparedStyle", "prejectedStatement", "preparedAdapter", "preparableStatus", "prepferredSQL", "preppedCall", "prepletedCall", " preparedStat", "prefixedstatement", "preferredQuery"], "resultSet": ["resultsList", "resultHandle", "rowSet", "resultSum", "ResultSource", " resultSum", "responseStream", "characterStream", " resultSource", "characterSum", "resultPath", " resultStream", "resultsStream", "resultSession", "ResultPath", "resultsPath", "responseSet", "rowSource", "rowHandle", "resultStream", "ResultHandle", "ResultSum", "ResultTime", "dataSet", "ResultList", " resultSession", "rowSession", " resultPath", "resultsSet", "resultsUn", "characterSet", " resultHandle", "ResultSession", "ResultSet", "resultList", "ResultStream", " resultList", "responseUn", "dataTime", "ResultUn", "resultUn", "resultSource", "dataStream", "resultTime", " resultTime"], "chkSql": ["chKSk", "chKSq", "chKInsq", "chkRSQL", "chkInsql", "chkRSql", "chkDk", "chkStrQL", "chKDql", "chKSql", "chkStrql", "chkStrq", "chKSyl", "chkInsQL", "chkDql", "chKDQL", "chkSk", "chkSyl", "chKSQL", "chkSQL", "chKDk", "chkRSk", "chKInsql", "chkSq", "chkRSyl", "chkDq", "chkInsq", "chkDQL", "chKInsQL", "chkDyl", "chKDyl"], "selfDefinePath": ["selfDeliningpath", "selfDefidepath", "selfDefINEPath", "selfDefiningDir", "selfDefiningKey", "selfDefinedPath", "selfdefinePattern", "selfDeliningKey", "selfDefinesPath", "selfdefinesPath", "selfDefINEKey", "selfDelineSet", "selfDefideDir", "selfdefinespath", "selfdefinepath", "selfDefinePattern", "selfDefiningSet", "selfDefINESet", "selfDefiningPattern", "selfDefineSet", "selfDefiningPath", "selfdefinesDir", "selfDefinedKey", "selfDeliningSet", "selfdefinePath", "selfDefinedpath", "selfDefinesPattern", "selfDelinePath", "selfDefinedSet", "selfdefineDir", "selfDelineKey", "selfdefinesPattern", "selfDefidePattern", "selfDefinesDir", "selfDefINEpath", "selfDefineDir", "selfDefiningpath", "selfDefidePath", "selfDeliningPath", "selfDefineKey", "selfDelinepath", "selfDefinepath", "selfDefinespath"], "sqlStr": ["sqlName", "sqlSt", "sqWr", "sqlString", "sqlWr", "qlStr", "qlName", "SQLstr", "sqName", " sqlstr", "sqSt", "qlString", " sqlName", "sqlstr", "sqStr", "sqstr", " sqlWr", "qlstr", "sqString", " sqlSt", "SQLStr", "SQLSt", "SQLWr", " sqlString"]}}
{"id1": "539195", "id2": "23666867", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" Copy", "to", "link", "csv", "cat", "cp", "create", "cop", "download", "Copy", " cop", "transfer", "load", "replace", " cp", "save", "init", "upload", "move", "clone", "sync", "println", "gc", "dump", "delete", "Cop", "slice", "ls"], "src": ["comp", "in", "ctr", "pkg", "rl", "rt", "sec", "spr", "filename", "rel", "ins", "input", "ser", "desc", "dist", "attr", "req", "rs", "rx", "iv", "loc", "imp", "str", "img", "sys", "usr", "orig", "sel", "rc", "init", "ls", "st", "cur", "Source", "inst", "urg", "url", "from", "pres", "start", "sit", "sc", "spec", "host", "sb", "addr", "ident", "sin", "this", "sr", "txt", "sq", "uri", "source"], "dest": ["d", "rest", "it", "cat", "them", "test", "deg", "target", "dist", "req", "loc", "decl", "Dest", "nw", "sup", "end", "nom", "cont", "trans", "usr", "mem", "est", "dir", "st", "origin", "https", "opt", "master", "home", "exp", "del", "gt", "id", "tmp", "temp", "way", "orig", "p", "source"], "ifp": ["alfp", " ify", "alfpp", "ibpa", " ifpa", " ifsp", "ifsp", "iby", "Ifcp", "ffy", "aftp", "Ife", "ffsp", " ifcp", "afpc", "ihp", "ifcp", "ihop", "iftpc", "alftp", "ffp", "ifpa", "iftpp", "ife", " ifop", "ifop", " ife", "ify", "ffpa", "Ifop", "ifpp", "alfpc", "iftp", "ifpc", "ibp", "ifttp", "afpp", "Ifp", "ibsp", "ihcp", "ihe", "afp"], "ofp": ["OFjp", "Ofd", "OFd", "ofP", "ofd", "orfp", " ofproc", "offjp", "offp", "ofjp", "OFP", "ofproc", "offd", "ofsp", "Ofsp", "orfd", "Ofjp", "Ofp", "orfsp", " ofsp", "OfP", "Ofproc", " ofd", "offP", "orfproc", "OFp"], "fis": [" fai", "wiss", "gi", "fiss", "fiist", "fliss", "gais", "Fist", "Fais", "flis", "wais", "fi", " fiss", "flai", "wis", "fios", "Fos", "wi", "Fiss", "flais", "Fis", "Fai", "giss", "fist", "gis", " fi", " fais", "fiis", "fiiss", "fai", " fist", "fais"], "fos": [" foes", "foes", "flaos", "Foss", " faos", "fioes", "flis", " fios", "woss", "fiaos", "Foes", "fios", "flios", "Fos", "woes", "wos", "floes", " foss", "foss", "flos", "Foses", " foses", "woses", "fiis", "foses", "waos", "wios", "faos"], "b": ["pb", "d", "v", "batch", "l", "bis", "bd", "blue", "h", "body", "k", "base", "y", "B", "bar", "rb", "f", "ab", "bi", "bit", "j", "ch", "bg", "br", "reb", "cb", "bits", "fb", "be", "wb", "gb", "bb", "bc", "eb", "binary", "g", "db", "nb", "sb", "lib", "bs", "mb", "ob", "z", "p"]}}
{"id1": "8983517", "id2": "11562173", "code1": "    public User getUser(String userlogin) {\n        UserDAO userDAO = new UserDAO();\n        User user = null;\n        try {\n            user = userDAO.load(userlogin);\n            if (user == null) {\n                URL url = Thread.currentThread().getContextClassLoader().getResource(\"users.cfg\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                String linea = br.readLine();\n                while (linea != null) {\n                    StringTokenizer st = new StringTokenizer(linea, \":\");\n                    if (st.countTokens() == 3) {\n                        String login = st.nextToken();\n                        String password = st.nextToken();\n                        String profile = st.nextToken();\n                        if (login.equals(userlogin)) {\n                            user = new User(login, password, profile);\n                            userDAO.save(user);\n                        }\n                    } else {\n                    }\n                    linea = br.readLine();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return user;\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 0, "substitutes": {"getUser": ["loadPerson", "getuser", "loadUsers", "showPerson", "getPerson", " getPerson", " getUsers", "getUsers", "loaduser", "showuser", "showUsers", "loadUser", " getuser", "showUser"], "userlogin": [" userlayout", "userlayout", "usernamelayout", "usernameusername", "UserLogin", "Userlog", "USERusername", "usersubmit", "Userusername", "userusername", "USERlogin", " userLogin", "usernameLogin", "Userblog", " userblog", "userLogin", "USERlog", "userblog", "openusername", "clientsubmit", "usernamesubmit", " usersubmit", "clientusername", " userusername", "openlogin", "clientlogin", "usernamelogin", "openblog", "userlog", "openLogin", "USERLogin", "Userlogin", "clientlayout", "usernamelog"], "userDAO": ["groupCAO", "userCAOA", "groupCAH", "groupDAH", " userDAE", "userCAH", "groupDAO", "userDAOU", "userDAN", "userTAE", "userDaOU", "userTAN", "userdaO", "profileCAo", " userDaN", "userDAPO", "userDOPO", " userDaOU", "userCAO", "userdaE", "userDOO", "profileCAPO", "userSAO", "profileDAo", "userDaN", "profileCAOB", "userCAOB", "userDAOA", "userDOOB", "userTAOU", "userCAo", "userTAO", " userDaO", "profileDAPO", "profileCAO", "userdaOA", "groupDAOA", "userDAE", "groupDAE", "groupCAE", "userDaE", "profileDAOB", "userDAOB", "groupCAOA", " userDAOU", "userCAE", " userDaE", "userSAOB", "userDAo", "userSAPO", "userCAPO", "userDAH", " userDAN", "profileDAO", "userDaO", "userDOo", "userSAo", "userdaH"], "user": ["browser", "list", "null", "project", "record", "User", "ro", "term", "state", "used", "usa", "client", "ver", "we", "vol", "me", "force", "manager", "home", "change", "you", "current", "human", "report", "menu", "to", "person", "char", "device", "row", "u", "word", "resource", "result", "config", "set", "content", "object", "output", "role", "util", "entry", "rule", "body", "re", "entity", "volume", "actor", "author", "by", "core", "usr", "valid", "owner", "info", "from", "account", "job", "can", "match", "bug", "per", "message", "remote", "or", "student", "use", "usage", "clean", "username", "group", "form", "feature", "USER", "uid", "e", "contact", "comment", "er", "creator", "member", "query", "update", "mor", "relation", "instance"], "url": ["browser", "http", "pl", "b", "web", "l", "ll", "html", "rl", "lb", "base", "loc", "open", "li", "cert", "char", "f", "str", "ul", "ssl", "ret", "ref", "context", "ur", "nl", "bel", "mount", "URL", "gl", "resource", "file", "loader", "log", "Url", "sl", "fl", "lr", "r", "path", "ls"], "br": ["browser", "b", "BR", "pr", "bh", "tr", "bd", "rel", "ber", "wr", "dr", "bt", "kr", "rb", "bp", "shr", "buf", "str", "bn", "usr", "ch", "cr", "bf", "nl", "bro", "div", "block", "er", "be", "mr", "vr", "bb", "gb", "bc", "fr", "hr", "bl", "r", "lr", "bs", "Br", "bridge"], "linea": ["linec", "linva", "rowva", " linega", "rowc", " lineaa", "linega", "LINEva", "linkva", "linA", "inea", "ineaa", "lina", "ineA", "linesA", "linesa", "LineA", "Linea", "rowea", "ineva", "linesaa", "linga", "linkea", "lineaa", "linkc", "Linega", "lineva", " lineA", " lineva", "linc", "LINEa", "linesva", "linaa", "LINEaa", "lineea", "rowa", "inega", "LINEga", "linka", "lineA"], "st": ["rest", "pt", "it", "rt", "St", "sty", "ste", "obj", "desc", "th", "std", "ST", "ss", "spe", "ft", "ct", "str", "sv", "ze", "est", "so", "stat", "sp", "ut", "stack", "td", "sn", "mt", "sf", "inst", "sta", "t", "sts", "ts", "se", "start", "ost", "tt", "sw", "sd", "sl", "set", "ist", "const", "sb", "stable", "ust", "et", "nt"], "login": ["ping", "submit", "entry", "summary", "pl", "print", "link", "phone", "pin", "xml", "virtual", "filename", "joined", "label", "index", "string", "username", "layout", "license", "pack", "email", "number", "cell", "mail", "sql", "stat", "script", "ls", "title", "connect", "ilo", "local", "service", "include", "account", "log", "sit", "successful", "id", "match", "ident", "Login", "kin", "join", "select"], "password": ["Password", "shadow", "print", "secret", "command", "policy", "chain", "post", "pass", "string", "padding", "database", "username", "token", "sword", "prefix", "attribute", "device", "phrase", "auth", "comment", "word", "search", "sudo", "mask", "confirmed", "pattern", "creation", "power", "cloud", "encrypted", "picture", "hello", "pool", "pty"], "profile": ["security", "summary", "personal", "menu", "Profile", "policy", "background", "phone", "professional", "knife", "filename", "property", "username", "volume", "template", "name", "plot", "latest", "properties", "style", "alias", "context", "sample", "title", "primary", "metadata", "mobile", "file", "include", "power", "picture", "photo", "face", "role", "history", "prof", "family", "buffer"]}}
{"id1": "22708533", "id2": "19134229", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": [" copyDocumentToURI", " copyDocumenttoURI", " copydocumenttoUrl", " copyDocumentToFile", " copydocumenttoFile", " copyDocumentToUrl", " copyDocumentFromFile", " copydocumentToURI", " copyDocumentAsUrl", " copyDocumentToURL", " copyDocumentAsURL", " copyDocumenttoUrl", " copyDocumenttoURL", " copydocumenttoURI", " copydocumenttoURL", " copyDocumenttoFile", " copyDocumentFromURI", " copyDocumentFromUrl", " copydocumentToURL", " copyDocumentAsFile", " copyDocumentFromURL", " copyDocumentAsURI", " copydocumentToUrl", " copydocumentToFile"], "file": ["rule", "command", "data", "full", "filename", "doc", "input", "string", "image", "base", "name", "table", "document", "attribute", "fil", "f", "ile", "valid", "sample", "work", "title", "where", "origin", "check", "le", "resource", "local", "File", "from", "log", "default", "place", "path", "message", "FILE", "source"], "target": ["to", "link", "print", "project", "back", "root", "rel", "window", "location", "template", "base", "table", "layout", "replace", "alias", "top", "arg", "valid", "scope", "arget", "origin", "local", "Target", "pattern", "result", "home", "ARGET", "update", "component", "host", "view", "this", "dest", "remote", "join", "select", "source"], "is": ["ip", "dis", "ci", "ris", "isi", "oss", "bis", "it", "lis", "sis", "ists", "has", "isa", "us", "ins", "obs", "ir", "ais", "im", "rs", "vis", "ois", "tis", "its", "IS", "abs", "vs", "Is", "isf", "mis", "isin", "iso", "est", "ms", "ics", "bits", "\u00eds", "ys", "ios", "cs", "nis", "ri", "xs", "iss", "isal", "mi", "es", "fs", "iris", "ism", "isl", "ims", "ns", "bs", "i", "ains", "isc", "si", "mos"], "os": ["o", "css", "ose", "ks", "pos", "oin", "osa", "oss", "bis", "oa", "los", "ops", "oos", "cos", "us", "ins", "oses", "obs", "oS", "ori", "des", "ss", "aos", "io", "Os", "ows", "mes", "sys", "eps", "nos", "asis", "et", "ms", "dos", "mot", "ot", "none", "OS", "ios", "ols", "acs", "tes", "bos", "osi", "ts", "ones", "es", "ost", "uts", "ps", "ns", "bs", "out", "oes", "ox", "mos", "ros"], "url": ["http", "n", "link", "conn", "web", "l", "ll", "cp", "address", "rel", "user", "re", "location", "name", "open", "cert", "char", "client", "f", "str", "ul", "ssl", "ur", "nl", "domain", "mount", "con", "https", "URL", "t", "service", "Url", "job", "host", "r", "net", "channel", "ls", "uri"], "connection": ["entry", "n", "link", "conn", "command", "l", "condition", "pointer", "generation", "network", "session", " Connection", "city", "database", "response", "Connection", "c", "document", "still", "open", "description", "client", "number", "cone", "closure", "application", "con", "position", "established", "connect", "ion", "resource", "t", "service", "using", "result", "creation", "close", "opening", "relation", "reference", "net", "channel", "communication", "character", "uri"]}}
{"id1": "15580610", "id2": "20663364", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"trainClassifier": [" trainclassifier", " trainModifier", " trainclassifer", " trainModifer", " trainObjectification", " runClassizer", " runclassizer", " trainClassification", " runclassification", " trainClassifer", " runclassifier", " trainClassizer", " runclassifer", " trainObjectifer", " trainModizer", " trainObjectifier", " runClassifer", " trainObjectizer", " trainModification", " runClassification", " trainclassification", " trainclassizer", " runClassifier"], "dir": ["d", "done", "report", "disk", "pos", "null", "md", "pkg", "data", "direct", "root", "grad", "doc", "dist", "folder", " directory", "directory", "DIR", "dr", "rad", "ir", "base", "loc", "prefix", "io", "dd", "wd", "dl", "src", "files", "module", "div", "url", "local", "log", "config", "dm", "output", "db", "lib", "this", "path", "addr", "tmp", "Dir"], "command": ["menu", "shift", "link", "operation", "condition", "function", "key", "execute", "chain", "Command", "call", "buffer", "paste", "statement", "string", "directory", "expression", "response", "mac", "template", "base", "group", "volume", "button", "sequence", "document", "description", "attribute", "cmd", "password", "program", "form", "clear", "send", "connection", "mpeg", "application", "script", "force", "comment", "and", "request", "column", "position", "multiple", "search", "sudo", "pattern", "requisite", "power", "argument", "config", "three", "query", "set", "binary", "content", "component", "event", "initial", "delete", "option", "message", "shell", "control", "relative", "method", "pretty", "display", "archive", "text", "history"], "length": ["capacity", "shift", "ength", "space", "duration", "full", "fleet", "total", "volume", "distance", "available", "pieces", "limit", "transform", "load", "needs", "shape", "loc", "upper", "sequence", "collection", "form", "pad", "end", "ctors", "number", "SIZE", "count", "build", "Length", "append", "factor", "prototype", "strip", "position", "size", "level", "now", "ENGTH", "depth", "value", "last", "dump", "diff", "max", "creator", "power", "deep", "given", "height", "character", "bus", "len"], "process": ["parse", "link", "complex", "in", "record", "use", "network", "cp", "node", "session", "thread", "function", "proc", "pid", "post", "call", "processor", "system", "term", "status", "exec", "load", "flow", "Process", "cmd", "program", "worker", "channel", "class", "mpeg", "script", "request", "position", "task", "check", "connect", "search", "handle", "service", "result", "start", "pp", "processing", "console", "object", "component", "event", "view", "output", "run", "message", "display", "method", "p"]}}
{"id1": "21491791", "id2": "7846688", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"run": ["su", "command", "use", "execute", "test", "call", "system", "process", "exec", "name", "cmd", "runs", "un", "running", "unit", "runner", "work", "par", "fun", "Run", "don", "eval", "pre", "exit", "apply"], "input": ["http", "partial", "parse", "print", "feed", "in", "back", "it", "background", "xml", "inner", "address", "data", "hub", "index", "system", "audio", "action", "image", "state", "table", "Input", "io", "form", "client", "json", "cont", "context", " inputs", "active", "upload", "request", "info", "iter", "stream", "file", "from", "local", "internal", "start", "read", "config", "initial", "hello", "view", "history", "before", "out", "text", "select", "readable", "source"], "output": ["o", "generated", "print", "web", "hidden", "command", "network", "header", "data", "four", "target", "filename", "memory", "directory", "response", "image", "admin", "table", "ou", "io", "latest", "oe", "external", "outer", "export", "connection", "write", "column", "put", "block", "port", "ilo", "stream", "format", "file", "log", "result", "config", "exit", "update", "success", "console", "binary", "Output", "net", "display", "out", "you", "text", "source"], "reader": ["entry", "rw", "in", "data", "inner", "Reader", "proc", "controller", "ro", "reading", "system", "parser", "window", "dr", "rar", "rx", "table", "builder", "wrapper", "handler", "client", "worker", "row", "usr", "context", "ter", "owner", "draw", "iter", "manager", "er", "stream", "iterator", "resource", "file", "driver", "loader", "read", "penter", "r", "readable"], "writer": ["rw", "wire", "network", "writing", "server", "adder", "target", "processor", "ser", "store", "window", "holder", "Writer", "builder", "wrapper", "handler", "client", "worker", "outer", "connection", "yard", "ter", "write", "writ", "caster", "draw", "pipe", "riter", "writers", "manager", "word", "println", "w", "iterator", "written", "file", "driver", "service", "handle", "loader", "widget", "creator", "close", "wrote", "storage", "variable", "penter", "player", "out"], "pump": ["pumps", "peump", " pong", " pumper", "pmp", "peumps", "Peter", "Pong", "prump", "Pump", " pamp", " pipe", "peter", " pUMP", " pumps", " pmp", " peter", "camp", "Podge", "deter", "Pmp", "Pamp", "PUMP", "damp", " podge", "podge", "cumper", "pipe", "dumper", "pemp", "Pumps", "psumper", "Pumper", "pamp", "psipe", "pUMP", "dump", "cump", "psamp", "prong", "psump", "cUMP", "pripe", "pumper", "pong", "prodge", "peumper", "Pipe"], "counter": ["timer", "code", "zero", "record", "key", "hash", "controller", "loop", "total", "term", "ounter", "collection", "random", "client", "average", "radius", "peer", "loader", "const", "page", "current", "continue", "time", "inner", "recorded", "amount", "second", "memory", "responsible", "index", "sequence", "description", "currency", "row", "common", "column", "console", "entry", "batch", "walker", "pointer", "unique", "system", "Counter", "clock", "cell", "context", "phrase", "vector", "buster", "encrypted", "message", "history", "parent", "condition", "book", "ctr", "thread", "processor", "card", "frequency", "outer", "number", "seen", "container", "count", "ter", "scope", "comment", "cookie", "created", "conv"], "buffer": ["b", "batch", "Buffer", "command", "header", "data", "key", "address", "uffer", "base", "table", "sequence", "document", "uf", "buf", "row", "queue", "context", "phrase", "buff", "bytes", "block", "vector", "size", "value", "result", "binary", "message", "length", "text", "source"], "off": ["ip", "att", "aff", "pos", "offs", "ap", "oa", "oct", "no", " OFF", "ff", "cmd", "after", "end", "offer", "un", "OFF", "offset", "Off", "hand", "origin", "ow", "now", "fun", "eff", " Off", "set", "def", "op", "of", " offset", "Offset", "before", "art", "shift"], "len": ["pos", "val", "l", "ld", "ll", "elt", "body", "rel", "cond", "lon", "line", "end", "fin", "buf", "enc", "lvl", "offset", "vol", "lp", "compl", "nl", "mem", "bf", "alt", "lan", "bytes", "ln", "vec", "size", "fun", "le", "coll", "eff", "written", "mat", "pent", "wl", "lf", "del", "kl", "Len", "fl", "en", "all", "cl", "lib", "length", "mult", "ls"], "rd": ["d", "rw", "RD", "ld", "cd", "md", "rn", "rt", "rl", "bd", "rh", "adr", "dr", "ind", "rs", "rand", "rb", "rod", "dd", "red", "rc", "cr", "nd", "udd", "dig", "dra", "ptr", "rez", "ri", "mn", "rid", "rr", "ard", "mr", "sd", "ird", "xd", "hr", "R", "r", "lr", "sr"]}}
{"id1": "17773263", "id2": "12306305", "code1": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 0, "substitutes": {"visar": [" visatar", "visatar", "Visitatar", "Visita", "visa", "Visatar", " visa", "Visa", "Visar", "Visitado", "Visitar", "Visado"], "ClassNotFoundException": ["ClassNotPresentError", "ClassNotSupportedException", "ClassNotFoundError", "ClassDefFoundError", "ClassNotPresentException", "ClassNotfoundException", "ClassNotfoundError", "ClassNotSupportedError", "ClassDefPresentException", "ClassDefPresentError", "ClassDefFoundException"], "Exception": ["Throw", "Example", " exception", "ception", "Index", "Result", "Message", "Operation", "Configuration", "Document", "Connection", "Class", "Context", "Handler", "Record", "Error", "Exit", "Status", "Application", "Warning", "Instance", "File", "E", "None", "Array", "Event"], "conn": ["n", "js", "pg", "gate", "socket", "cp", "yn", "oss", "ann", "wp", "ctx", "rel", "obj", "Conn", "res", "wr", "exec", "rs", "Connection", "c", "jp", "cons", "open", "cert", "cmd", "ct", "ont", "comm", "client", "fin", "gn", "enc", "org", "connection", "sql", "nc", "ch", "co", "sp", "con", "txt", "irm", "cur", "connect", " con", "coll", "ran", "config", "close", "can", "en", "conf", "db", "pen", "ec", "pool", "cc", "ns", "cn", "conv", "Con", "p", "nt"], "ps": ["ping", "css", "pl", " pp", "pr", "pos", "pt", "js", "pg", "ops", "cp", "qs", "pins", "pd", "wp", "proc", "points", "pe", "pa", "ins", "res", "PS", "ress", "posts", "als", "itions", "rs", "jp", "ples", "fps", "plays", "its", "ends", "vs", "fp", "eps", "ms", "sp", "ls", "ys", "pc", "cs", "pas", "pers", "mp", "s", "aps", "ips", "ts", "ats", "fs", "pp", "pres", "gres", "ups", "sts", "Ps", "amps", "stats", "ims", "pps", "ies", "uts", "ports", "bs", "pse", "gs", "p"], "fechaSystem": ["fechoaSTEM", "fetchaBase", "fechaBase", "fechasServer", "fechaServer", "fechasSys", "fespoaSTEM", "fechsaProcess", "fetchaSys", "fechoaServer", "fachoaServer", "fechsaSTEM", "fespaSystem", "fespaProcess", "fechoSys", "fespaSTEM", "fetchaServer", "fachaSys", "fachoaSys", "fechaeServer", "fachoaSystem", "fechaeSys", "fechasBase", "fechoProcess", "fechaSTEM", "fetchaSystem", "fechASys", "fechoaProcess", "fechoSystem", "fechaSys", "fechasSystem", "fechABase", "fechoServer", "fetchoSystem", "fechaProcess", "fetchoBase", "fetchoSys", "fachaSystem", "fechoSTEM", "fechsaSystem", "fechoaSys", "fespoaSystem", "fechaeSystem", "fachaServer", "fechoaSystem", "fetchoServer", "fechASystem", "fespoaProcess", "fechoBase"], "aaaammdd": ["aaalammde", "aaaaammdd", " baambss", " baambds", "aaaaumde", "aaaaammm", "aaaammd", " baammd", "aaaammds", "aaapmd", "aaalammdd", " baammds", " baammss", "aaaambss", "aaaaumd", "aaaammmm", "aaaammde", "aaalammd", "aaapmss", "aaaaamd", "aaaamss", "aaaamd", "aaaaammmm", "aaaamds", " baambdd", "aaaaamdd", "aaapmds", "aaaammss", "aaaaammd", "aaaaummm", "aaaaammde", " baambd", "aaalammmm", "aaaammm", "aaaamdd", "aaaaumdd", "aaaambd", "aaaambds", "aaapmdd", "aaaaamde", "aaaamde", "aaaambdd", " baammdd"], "hhmmss": ["hhtmcss", "HHmmss", "ohmmess", "hhmbcss", "HHMMss", "hhmmess", "hhMMss", "hhmmrss", "ohmmms", "HHmmrss", "hhmmms", "hhmyrss", "hhmmps", "hhmmmess", "ohtmss", "ohtmms", "hhmyss", "hhMMps", "hhmmmcss", "hhMMrss", "ohmmss", "hhtmms", "hhmmmss", "hhmmmms", "hhmbess", "HHMMs", "hhmmmrss", "hhmyps", "hhmbss", "hhtmess", "HHMMrss", "hhMMs", "ohtmess", "ohtmcss", "hhmbms", "hhmmmps", "ohmmcss", "HHmmps", "hhmmcss", "hhtmss", "HHMMps", "hhmys", "HHmms", "hhmms"], "sss": ["ssis", "rssis", "\u00dfis", "cssis", "ysss", "ssh", "cssh", "ssls", "ssd", " ssy", "ssy", "rsss", "rssd", "yssys", "csss", " ssls", "yssy", "yssls", "essys", "essy", " ssys", "\u00dfh", "cssd", "\u00dfs", "esss", "ssys", "essls", "\u00dfd", "rssh"], "ss": ["ping", "css", "js", "oss", "ws", "ass", "less", "ssh", "html", "aws", "sy", "hess", "string", "rs", "os", "ews", "dd", "tis", "ssl", "sys", "sv", "sql", "ms", "SS", "bytes", "ys", "cs", "\u00df", "sf", "https", "tz", "s", "iss", "ts", "se", "pres", "es", "ses", "sd", "course", "tt", "rss", "styles", "sol", "good", "stats", "sb", "esi", "ess", "bs", "pps", "ns", "ds", "ls", "sq"], "sentenciaSql": ["sentenciaSourceql", "sentenciaStringq", "sentenceSsql", "sentenciaInsq", "sentenciaDq", "sentenciaDel", "sentenzaSq", "sentenciaInsel", "sentenciaInssql", "sentenceSQL", "sentenzaInseed", "sentenzaSel", "sentenciaStringsql", "sentenciaDeed", "sentenciaInseed", "sentenciaSourceel", "sentenciaSQL", "sentenciaSsql", "sentenceSq", "sentenzaSql", "sentenzaInsq", "sentenciaSeed", "sentenceSql", "sentenciaInsql", "sentenciaStringQL", "sentenzaSeed", "sentenciaInsQL", "sentenciaSq", "sentenciaDql", "sentenzaInsql", "sentenciaSel", "sentenciaStringql", "sentenzaInsel", "sentenciaSourceq", "sentenciaSourceeed"], "contador": ["\u00e7offer", "contoffer", "contrane", "frontator", " contabo", "portador", "controlator", " Contpointer", "montadr", "contactarter", "contamina", "contabo", "ontamo", "colator", "portainer", " contarter", "ontarter", "constpointer", "colainer", "CONTador", "intador", "controlador", "intadr", "frontador", "ontador", "colador", " contator", "frontamo", "montador", "contactador", "portator", "constoffer", "contarer", "contamo", "contactator", "contactarer", "constadr", " Contamina", "ontadr", "ontator", " Contador", "constano", "constador", " contamo", "contano", "contdoor", "controlarer", "\u00e7ano", "contadr", "contarter", " contdoor", "frontarter", "constrane", " contadr", " contpointer", "intainer", " contoffer", "portabo", "CONTpointer", " contrane", " contamina", " container", "CONTamina", " contorno", "\u00e7orno", "constdoor", "constorno", "montamo", "contator", " contano", "constator", "ontdoor", "ontarer", "constainer", "colabo", " Contator", "CONTator", "container", "controlarter", "contpointer", "intpointer", "montator", "\u00e7ador", "ontrane", "contorno"], "visado": [" visando", "Visado", "Visando", "visada", "Visados", "Visada", "visando", "visados", " visitada", " visados", " visada", " visitando", " visitado", " visitados"]}}
{"id1": "11546108", "id2": "742465", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"run": ["submit", "launch", "execute", "loop", "call", " Run", "process", "exec", "render", "runs", "scan", "running", "func", "runner", "sample", "evaluate", "block", "wait", "go", "Run", "search", "impl", "start", "find", " runs", "invoke", "hello", "apply"], "in": ["inf", "oin", "IN", "l", "inc", "inner", "cin", "sum", "ins", "input", "p", "reader", "rin", "bin", "In", "is", "again", "f", "line", "fin", "by", "isin", "and", "info", "copy", "ln", "asin", "mc", "er", "ma", "mn", "add", "file", "gin", "from", "read", "all", "get", "conf", "inn", "r", "on", "out", "din", " din", "source"], "ligneEnCours": ["ligneEnACour", "ligneENContours", "ligneENCourses", "ligneEnCsons", "ligneEnCsour", "ligneENCours", "ligneENNres", "ligneEnCRS", "ligneEnChodes", "ligneConCours", "ligneEnCuRS", "ligneEnACurs", "ligneEnCoodes", "ligneENNurs", "ligneEnCres", "ligneConCour", "ligneEnCoour", "ligneENNours", "ligneConCurs", "ligneENcurs", "ligneEncours", "ligneEnChours", "ligneEnContChamp", "ligneConCodes", "ligneEncons", "ligneENContRS", "ligneEnNourses", "ligneEncears", "ligneENCres", "ligneEnCodes", "ligneEncodes", "ligneEnCour", "ligneEnChour", "ligneEnNurs", "ligneEnACours", "ligneEnACears", "ligneEnCoourses", "ligneENCsour", "ligneENcears", "ligneEnNours", "ligneEnChurs", "ligneENcours", "ligneEnCurs", "ligneENContChamp", "ligneEnConturs", "ligneENCour", "ligneEnCChamp", "ligneEnClChamp", "ligneEnCoons", "ligneConcurs", "ligneConcours", "ligneENNourses", "ligneENCsours", "ligneEnCuChamp", "ligneEncurs", "ligneEnClRS", "ligneENConturs", "ligneEnContRS", "ligneENCons", "ligneConcodes", "ligneEnCsurs", "ligneENCurs", "ligneEnContours", "ligneEncour", "ligneENCsurs", "ligneConcour", "ligneEnCuours", "ligneEnClours", "ligneEnCourses", "ligneEnCoours", "ligneEnCsours", "ligneEnNres", "ligneENcour", "ligneEnCons", "ligneEnCuurs", "ligneENCsons", "ligneEnClurs", "ligneEnCears", "ligneENCRS", "ligneEnCores", "ligneENCChamp", "ligneENCears"], "i": [" I", "b", "m", "n", "ci", "ui", "v", "continue", "multi", "l", "it", "ei", "I", "phi", "index", "ind", "ori", " j", "y", "oi", "ini", "li", "is", "io", "ii", "iu", "bi", "pi", "j", "e", "init", "off", "iter", "cli", "ai", "t", "mi", "ti", "ix", "g", "di", "asi", "x", "si", "xi", "p"], "informations": ["instrATIONS", "ingenerations", "informates", "informsates", "Informsions", "informions", "informsation", "informsATIONS", "information", "informsations", "instration", "inflators", "informsators", "Informsation", "ingenerATIONS", "Informsates", "Information", "ingenerions", "Informsations", "inflations", "Informions", "Informates", "inflATIONS", "Informators", "instrators", "instrations", "informators", "Informsators", "ingenerates", "inflation", "informsions", "informATIONS", "inflates", "Informations", "InformsATIONS", "inflions", "InformATIONS"], "version": ["v", "serial", "server", "major", "label", "index", "VERSION", "status", "edition", "sequence", "description", "type", "program", "client", "ver", "number", "class", "title", "position", "port", "format", "value", "versions", "part", "id", "channel", "action", "source"], "url": ["browser", "http", "link", "print", "l", "address", "href", "filename", "download", "label", "location", "base", "loc", "str", "domain", "title", "URL", "format", "file", "resource", "pattern", "Url", "id", "host", "path", "uri", "source"], "texteErreur": ["texteErrorbreuer", "texteErreut", "texteCorseur", "texteErbreul", "texteErrorreure", "texteIrbreur", "texteErrerur", "texteIrbreul", "texteStrreur", "texteCorseure", "texteErrerurs", "texteCorseut", "texteErREur", "texteErreuer", "texteErruleurs", "texteErrorreur", "texteErreUR", "texteErreura", "texteCorreult", "texteErseul", "texteErrerurred", "texteErriul", "texteErrorreuer", "texteIrreul", "texteErseura", "texteErreult", "texteErbreUR", "texteIrreura", "texteStrreurs", "texteErriur", "texteErseult", "texteErruer", "texteErrUR", "texteErrorbreur", "texteErrut", "texteCorseult", "texteIrbreura", "texteErbreura", "texteErseut", "texteErbreur", "texteErleur", "texteErREult", "texteStrneurred", "texteErreurred", "texteErreure", "texteErrorbreure", "texteErREut", "texteErleUR", "texteErrure", "texteErruleurred", "texteErrult", "texteErreurs", "texteErrorbreUR", "texteErneur", "texteErneurred", "texteErbreuer", "texteIrreur", "texteErleure", "texteErbreure", "texteIrreUR", "texteErruleur", "texteErrorreUR", "texteStrneurs", "texteStrneur", "texteErrur", "texteErREure", "texteErreul", "texteIrbreUR", "texteStrreurred", "texteCorreur", "texteCorreure", "texteErseur", "texteErriura", "texteErleuer", "texteErseure", "texteErneurs", "texteErriUR", "texteErseUR", "texteCorreut"], "numErreur": ["numErReurs", "numErr\u00e9urs", "numErReur", "numErreiber", "numErbreiber", "numErneurs", "numErbreUR", "numErReUR", "numerreur", "numErbreau", "numerreurs", "numErReiber", "numerReurs", "numerReUR", "numerreiber", "numErr\u00e9UR", "numErneur", "numerReiber", "numErreurs", "numErneUR", "numErreau", "numErr\u00e9ur", "numErreUR", "numErReau", "numerreUR", "numerReur", "numErr\u00e9iber", "numErbreurs", "numErneau", "numErbreur"], "al": ["att", "stal", "l", "ad", "alf", "ale", "ap", "el", "bal", "als", "sal", " tal", "ali", "pal", "ald", " recal", "fal", " bal", "ar", "ial", " fal", "alog", " sal", "sel", " bl", "a", "wal", "tal", "aval", "ral", "alon", "dal", "Al", "hal", "atal", "af", " cal", "all", "alist", " aval", "bl", "cal", " wal", "mal", " hal", " mal", "AL"]}}
{"id1": "4602568", "id2": "17996547", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"storeImage": ["saveImage", "StoreFile", " storeFile", "StoreImages", "saveFile", "StorePicture", "StoreImage", "savePicture", " storePicture", " storeImages", "saveImages", "storePicture", "storeImages", "storeFile"], "inStream": [" inSteam", "outForm", " inForm", "inputFile", "cinView", " inFile", "inSteam", "fileStream", "fileSteam", "inputStream", "cinStream", "inputView", "cinFile", "outSteam", "inFile", "outFile", "inForm", "inView", "fileFile", "cinSteam", " inView", "inputSteam", "fileForm"], "fileName": ["imagePath", "FileTime", " filePath", "imageInfo", "filename", "fileTime", "FileInfo", "FILEInfo", "resourceTime", "resourceType", "Filename", "FILEName", "imageName", "FileName", "resourceName", "resourcePath", "FILEPath", "FILEname", "FilePath", "fileType", " fileType", " fileInfo", "imagename", " filename", "imageTime", "filePath", "fileInfo", "FileType", "imageType"], "resize": ["Ressize", "resizes", " ressize", "renizes", "Resizes", "Resized", "ressize", "renized", "resized", "rensize", "Resize", " resizes", "renize", " resized"], "rightNow": ["correctToday", "correctNow", "westThen", "rightFuture", " rightNOW", "westToday", "rNow", " RightNow", "rToday", "RightFuture", " rightToday", "westServer", "rightThen", " rightServer", " RightThen", " rightFuture", "rightToday", "westNow", "rightCurrent", " rightCurrent", "rServer", "westNOW", "westCurrent", "correctFuture", "rightServer", " RightCurrent", "correctNOW", "rightNOW", " RightNOW", "RightToday", " rightThen", "rNOW", "westFuture", "RightNow", "RightCurrent"], "dayNamedFolderName": ["dayNamingFolderSize", "dayNamingFoldername", "dayNamedThemename", "dayNamedFilePath", "dayNamedDirectoryName", "dayNamedAreaname", "dayNamedDirectory1", "dayNamingFileNames", "dayNamedThemeName", "dayNamingFolderPath", "dayNamedAreaNames", "dayNamingFilename", "dayNamingDirectoryName", "dayNamedThemeSize", "dayNamedFileSize", "dayNamedArea1", "dayNamingFileName", "dayNamedfolderName", "dayNamedfolderPath", "dayNamedFolderPath", "dayNamedfolderNames", "dayNamingFolderNames", "dayNamedFileNames", "dayNamedThemePath", "dayNamedFolderNames", "dayNamedDirectoryname", "dayNamedDirectoryNames", "dayNamingFolderName", "dayNamingFolder1", "dayNamedFileName", "dayNamingFileSize", "dayNamedfoldername", "dayNamedFoldername", "dayNamedFilename", "dayNamedThemeNames", "dayNamingFilePath", "dayNamedFolderSize", "dayNamingDirectoryNames", "dayNamedfolder1", "dayNamedFolder1", "dayNamingDirectoryname", "dayNamedAreaName", "dayNamingDirectory1"], "uploadDirRoot": ["uploadDirectoryParent", " uploadRelPath", "UploadDirCover", "uploaddirCover", "uploadDbParent", "uploadFolderPath", "uploadRelRoot", "uploadRelroot", " uploadRelroot", "uploadFolderBase", "saveDbParent", " uploadDirPath", "uploaddirRoot", "uploadDirectoryroot", "uploadDirroot", "uploadFolderRoot", "uploadUrlRoot", " uploadRelBase", "uploadNetBase", "uploadDirParent", "uploadRelPath", "uploadDirCover", "uploadDbBase", "saveDbRoot", "UploadDbRoot", "uploadRelBase", " uploadRelRoot", "saveDirroot", "uploadDbroot", "uploadUrlPath", "UploadDbBase", "UploadDirRoot", "uploadNetRoot", "uploadDirBase", "UploadDbroot", "saveDirParent", "UploadDirroot", " uploadDirBase", "uploadNetCover", "uploadDirPath", "uploadUrlParent", "uploadFolderroot", "uploadDirectoryRoot", "UploadDbCover", "uploadDbCover", "uploadUrlroot", "uploadDbRoot", "uploadNetroot", "saveDbroot", "uploaddirBase", "UploadDirBase", "uploaddirroot", "saveDirRoot", "uploadUrlBase", " uploadDirroot"], "file": ["tree", "to", "link", "null", "time", "project", "node", "key", "full", "h", "el", "no", "folder", "entity", "image", "base", "name", "table", "up", "open", "type", "f", "ile", "il", "top", "class", "dir", "work", "force", "task", "port", "resource", "local", "File", "t", "handle", "op", "get", "run", "pool", "page", "channel", "FILE", "parent", "source"], "extension": ["exension", "expend", "xtend", "EXTention", "expended", "expension", "xtention", "EXTended", "dimensions", "extended", "extendant", "extention", "exention", "dimention", "expention", "EXTend", "expensions", "expendant", "extensions", "xtension", "dimension", "exensions", "dimendant", "exendant", "xtended", "EXTension", "extend"], "outFileName": ["inFileSize", "outFileSize", "outFilePath", "outFilesName", "OUTFileName", "outLineNames", "OUTLogname", "outImageName", "outLineKey", "OutFilePath", "outFilename", " outFileNames", "outFilenamename", "outLineName", "outFileInfo", " outFileInfo", "outfileVersion", "OutfileName", "OutfileKey", "outfileKey", "infilename", "OUTFilePath", "outImageNames", " outFilePath", "OUTLogPath", "OUTLogName", "outImagename", "outFileVersion", "infileType", "outfileNames", "outFilesname", " outLineInfo", "OUTFieldName", "outLinePath", "outDirname", "outFilenameNames", "outFileType", "outFieldName", "OUTLogKey", "outfileType", "infileName", "outLinename", "outImagePath", " outLogVersion", "outLogVersion", "outLogname", "outfileName", "outImageInfo", "outfilename", "Outfilename", "outfilePath", "outFilenameSize", "outFilenameType", "OutFileName", "outLogPath", "OutFileKey", " outLineName", "outFileNames", "outfileSize", "outDirPath", "inFileName", " outLogname", " outLinePath", "outFilenameVersion", "outFieldSize", "OUTFieldname", "outDirName", "outLogName", "OUTFilename", "OutfilePath", "outFilenameName", " outLogName", " outLineNames", "OutFilename", " outLogNames", " outFileVersion", "OUTFileKey", "outFieldPath", "infileSize", "outFilenameInfo", "outLineInfo", "outFilenameKey", "outLogNames", "outFilenamePath", "OUTFieldPath", "outLogKey", "outFileKey", "outImageKey", " outFilename", "inFileType", "outFieldname", "inFilename", "outFieldType", "outFilesPath"], "outPathAndName": ["outPathOrNames", "outPathButTime", "outTimeAndPath", "outPathAndSize", "outPortAndName", "outLocationAndNames", "outPathANDLike", "outPortButKey", "outTimeButPath", "outPathOrSize", "outPathANDPath", "outPortAndKey", "outLocationandSize", "outPathandKey", "outPathandNames", "outLocationandName", "outPathButKey", "outPathButLike", "outPortButPath", "outLocationandKey", "outPathButPath", "outTimeButName", "outTimeButTime", "outPathOrKey", "outLocationandNames", "outPathOrTime", "outLocationAndSize", "outTimeButLike", "outPathandPath", "outPathOrPath", "outPathOrName", "outLocationAndName", "outPortButName", "outTimeAndLike", "outPathandSize", "outPathAndKey", "outPathAndNames", "outLocationAndKey", "outTimeAndTime", "outPathAndLike", "outPathANDName", "outTimeAndName", "outPathandName", "outPathAndPath", "outPathANDTime", "outPathOrLike", "outPathButName", "outPathAndTime", "outPortAndPath"], "uploadedFile": ["uploadifiedUnit", "uploadpedUnit", "uploadedF", " UploadmedPlace", " uploadededLine", "uploadiedFile", "uploadededFormat", "uploadredFormat", "uploadifiedF", "uploadedFormat", "uploadiedUnit", "uploadiedF", "presenttedFile", " uploadededF", " UploadmedFile", "uploadedfile", "uploadmedFormat", "uploadededFile", "uploadifiedFile", "uploadpedFile", " UploadedGlobal", "uploadmedGlobal", " uploadedifiedLine", "uploadashedField", "presentedFILE", "uploadpedLine", " UploadedFormat", "uploadedUnit", "uploadashedfile", "uploadashedFile", "presenttedFILE", "uploadredPlace", "presentedFile", "presenttedField", " UploadedPlace", "uploadtedfile", " UploadmedGlobal", " uploadedifiedFile", " UploadedFile", "uploadedFILE", "uploadedLine", "presentedField", "uploadedGlobal", "uploadtedFILE", "uploadiedLine", "uploaderFile", " uploadededUnit", "uploadredGlobal", "uploadededPlace", "uploaderField", "uploadedPlace", "uploaderFILE", "uploadtedFile", " uploadedifiedUnit", "uploaderfile", " UploadmedFormat", "uploadededGlobal", "presentedfile", "uploadredFile", "uploadtedField", "uploadifiedLine", "uploadashedFILE", " uploadedifiedF", " uploadededFile", "uploadpedF", "uploadmedPlace", "presenttedfile", "uploadedField", "uploadmedFile"], "outStream": ["oView", "oStream", "inSteam", "oFile", " outView", "outSteam", "inFile", "outFile", "_", "inView", " outFile", "outView", " outSteam", "oSteam"]}}
{"id1": "20920051", "id2": "16142024", "code1": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"copyTo": ["movePhoto", "opyTo", "transferFrom", "CopyTo", " copyPhoto", "opyPhoto", "CopyFrom", "copyFile", " copyFile", "transferTo", "opyOver", " copyFrom", "moveDir", "transferFiles", " copyDir", "CopyFiles", "transferFile", " copyFiles", "moveOver", "moveTo", "opyDir", "copyFiles", "copyFrom", "copyOver", "copyDir", "copyPhoto", "CopyFile", " copyOver"], "source": ["null", "src", "init", "iter", "file", "local", "flat", "sl", "sort", "get", "component", "shell", "select", "raw", "input", "store", "template", "base", "style", "sample", "copy", "Source", "resource", "start", "config", "part", "id", "spec", "entry", "visible", "oss", "SOURCE", "missing", "image", "subject", "note", "sp", "origin", "search", "from", "service", "s", "empty", "ie", "parent", "use", "site", "target", "seed", "status", "name", "secure", "details", "scan", "sql", "unit", "scope", "none", "ource", "ace", "old", "size", "sf", "se", "original", "query", "sin", "pse"], "dest": ["d", "dev", "to", "rest", "null", "it", "dat", "test", "deg", "target", "desc", "doc", "dist", "folder", "self", "des", "dc", "name", "loc", "pro", "Dest", "end", "nom", "trans", "ref", "est", "src", "dir", "st", "origin", "port", "w", "opt", "result", "master", "del", "good", "tmp", "tom", "this", "path", "out", "txt", "orig", "parent", "nt"], "temp": ["pl", "Temp", "null", "fake", "pt", "tab", "cp", "dat", "test", "mm", "template", "tem", "mod", "rem", "tar", " temporary", "tm", "porary", "EMP", " Temp", "parent", "em", "por", "alt", "mt", "out", "w", "t", "mp", "rm", "local", "mk", "unt", "make", " tmp", "emp", "zip", "empty", "tmp", "path", "stem", "Tem", "buffer", "txt", "orig", "p"], "sel": ["syn", "pl", " sl", "Se", "cel", "sil", "sen", "rl", "fol", "ael", "El", "el", "ser", "Sel", "elect", "selected", "sels", "nel", "nav", "ial", "cell", " lic", "sv", "lv", "nl", "so", "mil", "le", "select", "se", "ml", "del", "lf", "sl", "kl", "zh", "cl", "sc", "kel", "fl", "sol", "selection", "rol", "ls", "ele"], "tempDest": ["tempDe", "temdest", "poraryDest", "ptDest", " tempTemp", "temDir", "tempTemp", "mmDec", "poraryTemp", "poraryDe", "mmDest", "poraryLoc", "destDest", "temDest", " tempDir", "tempdest", " tempdest", " temporaryNeg", " temporarydest", "tempDec", "mmLoc", "ptNeg", "poraryDec", "ptdest", " tempNeg", " temporaryTemp", "mmTemp", "poraryDir", "tempDir", " tempDe", "tempNeg", "destLoc", "porarydest", "destTemp", "temDe", " temporaryDest", "ptTemp", "destDec", "tempLoc"], "sourceCh": [" sourceCr", "ourceCH", "ourceCh", "sourceComp", "startComp", "startCol", "sampleCor", "startCH", "srcCH", "statusCr", "seedCh", "sourceChan", "sampleCh", "statusCh", "seedCol", " sourceCH", "ourceColl", "seedChan", "statusCH", "srcColl", "srcChan", " sourcech", "sourceCor", "seedColl", "startCh", "ourceChan", "sourcech", "ourceComp", "samplech", "sourceCr", "ourceCol", "srcCol", " sourceCol", " sourceCor", "srcCor", " sourceComp", "ourceCr", "srcCh", "sourceCol", "statusCol", "srcch", "sourceCH", "sampleComp", "srcComp", "sourceColl"], "destCh": [" destDest", "usrChan", "targetChan", "destChan", " destChan", " destChar", "destC", "tempCl", "destDest", "destCl", " destCl", "targetC", "targetCh", "estCl", "restCh", "usrChar", "usrCh", "destChar", "estDest", "targetChar", "restCol", "destCol", "tempCol", "tempC", " destC", "tempCh", "estCh", "estC", "restC", "usrC", "restChan", " destCol", "tempChan"]}}
{"id1": "3375722", "id2": "18782385", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importatSelectors", " importarSelectors", " importatSelectero", " importarStor", " importarSelectero", " importarDator", " importatSetr", " importarStero", " importarSelectr", " importarStr", " importatSetors", " importarDatero", " importarDatr", " importarDators", " importatSetero", " importarStors", " importarSetero", " importatSelector", " importatSelectr", " importarSelector", " importarSetors", " importatSetor", " importarSetr"], "pArquivoXLS": ["pArquivoXls", "pArquivoEXLS", "pArquiveXCS", "pArquiveEXCS", "pArquivoOXls", "pArquivoTXLS", "pArquivoDXLS", "pArquarioEXLS", "pArquiveEXLS", "pArquiveEXls", "pArquivoXML", "pArquivoTXls", "pArquivoXXML", "pArquivoXXLS", "pArquivoDXls", "pArquarioXLS", "pArquivoOXML", "pArquarioXML", "pArquivoOXLS", "pArquivoDXML", "pArquivoXXls", "pArquiveEXML", "pArquivoTXCS", "pArquarioEXML", "pArquivoOXCS", "pArquiveXls", "pArquiveXLS", "pArquarioEXls", "pArquarioEXCS", "pArquarioXls", "pArquarioXCS", "pArquivoEXls", "pArquivoTXML", "pArquivoDXCS", "pArquivoXXCS", "pArquiveXML", "pArquivoXCS", "pArquivoEXML", "pArquivoEXCS"], "pCabecalhoSetor": ["pCabecalhaSetter", "pCabecalhoSetter", "pCabecalhoStar", "pCabecalhoStor", "pCabecalhoSetar", "pCabecalhoSetr", "pCabecalhoStter", "pCabecalhoStr", "pCabecalhaSetar", "pCabecalhaSetr", "pCabecalhaSetor"], "pAndamento": ["pandmento", "pandmentos", "pAndamentO", "pAndementos", "pandamente", "pAndimente", "pAndamentos", "pAndimentos", "pAndamente", "pandmentO", "pandamentO", "pAndimentO", "pandamento", "pAndemento", "pandmente", "pAndemente", "pAndmentO", "pAndmento", "pAndmente", "pAndmentos", "pandamentos", "pAndimento", "pAndementO"], "iLinha": ["aiPlanva", "iPlanha", "iEnzo", "iEn\u00e7a", "iEnha", "iPlanva", "iEnva", "aiPlan\u00e7a", "iPlan\u00e7a", "iLin\u00e7a", "iLuha", "iLinzo", "aiLinzo", "iLu\u00e7a", "aiLin\u00e7a", "aiLinva", "aiPlanzo", "aiPlanha", "iLuzo", "aiLinha", "iPlanzo", "iLinva", "iLuva"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialDecinos", "stmtLimpezaInicialDecione", "stmtLimpezaInicialDecINO", "stmtLimpezaInicialdestino", "stmtLimpezaInicialDestination", "stmtLimpezaInicioEstination", "stmtLimpezaIniciodestino", "stmtLimpezaInicialEstinos", "stmtLimpezaInicialEstino", "stmtLimpezaInitalEstINO", "stmtLimpezaInicioDestino", "stmtLimpezaInicioDestination", "stmtLimpezaIniciodestinos", "stmtLimpezaInicialDecino", "stmtLimpezaInitalDestione", "stmtLimpezaInicioEstino", "stmtLimpezaInicialEstINO", "stmtLimpezaInicioDestin", "stmtLimpezaInicialEstin", "stmtLimpezaInicialDestINO", "stmtLimpezaInicioDestINO", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialdestinos", "stmtLimpezaInicialdestination", "stmtLimpezaInicialEstination", "stmtLimpezaInicialEstione", "stmtLimpezaInitalDestino", "stmtLimpezaInicialDestin", "stmtLimpezaIniciodestINO", "stmtLimpezaInicioEstINO", "stmtLimpezaInitalDestINO", "stmtLimpezaInitalDestinos", "stmtLimpezaInicialdestin", "stmtLimpezaInitalEstino", "stmtLimpezaInicioDestinos", "stmtLimpezaIniciodestination", "stmtLimpezaInitalEstinos", "stmtLimpezaInicialDestinos", "stmtLimpezaInicioEstin", "stmtLimpezaInicialDestione", "stmtLimpezaInitalEstione"], "stmtDestino": ["stmtDescino", "stmtDestano", "stmtOrigined", "stmtOrigoin", "stmpDestoin", "stmdestano", "stmtdestination", "stmOrigino", "stmtDesination", "stmtDesano", "stmtOriginos", "stmtOrigin", "stmtDescination", "stmtDescin", "stmtStoin", "stmtDestined", "stmtDestoin", "stmpOrigoin", "stmDestination", "stmtdestano", "stmpDestinos", "stmtOrigino", "stmDestin", "stmtStino", "stmtDestinos", "stmDestined", "stmDestano", "stmtDecino", "stmpOriginos", "stmOrigination", "stmdestino", "stmtOrigination", "stmtDecano", "stmtdestinos", "stmpDestino", "stmtDesin", "stmtDestin", "stmtDecination", "stmOrigined", "stmtdestin", "stmpOrigination", "stmDestino", "stmOrigin", "stmtDestination", "stmdestin", "stmdestination", "stmtStinos", "stmpDestination", "stmtDesino", "stmtDescined", "stmtdestino", "stmtStination", "stmtDecin", "stmtdestoin", "stmpOrigino"], "arquivo": [" arqive", " arquive", "araquarius", " arQuive", "arquarius", "araquario", " arQuario", "arquerario", " arquario", " arqiva", "arquive", " arquiva", "arquerarius", "araquivo", " arQuiva", "arquerivo", " araquive", " araquario", "arqiva", "arquario", "arqario", " arQuivo", "raquiva", "arqive", " araquiva", "rquiva", "rquivo", "arquiva", "arqarius", " araquivo", "rquario", "raquario", "rquarius", "raquarius", "arqueriva", "araquiva", "arqivo", " arqario", "raquivo", " arqivo"], "plan1": [" planner2", " plan2", "plan01", "plan2", " planner0", " planOne", "panel01", "Plan1", " plan01", "Plan01", "PlanOne", "panel1", "planOne", "panel0", "plan0", " plannerOne", "Plan0", "Plan2", "panel2", " plan0", " planner1"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTERos__", "QUANTIDADE_DE_REGISTRANS_", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROs__", "QUANTIDADE_DE_REGISTRos__", "QUANTIDADE_DE_REGISTROs2", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTRAS__", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROS2", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTROS__"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTEROSON", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTRIES2", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTRATESON", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTERosON", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRATIONSON", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROS2", "QUANTIDADE_DE_REGISTRosON", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTROSON"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS_"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimated", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstifated", "quantidadeDeRegistrosEstIMated", "quantidadeDeRegistrosEstipated", "quantidadeDeRegistrosEstIMada", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstIMados", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstifados", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstIMadas", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstipadas"], "vSetor": ["vSETor", "valuesSETora", "vSETar", "valuesSETor", "valuesSETero", "vSelectora", "valuesSetar", "vSelector", "vEndero", "vSelectero", "valuesSETar", "valuesSetero", "vEndar", "vSelectar", "valuesSetor", "vSetar", "valuesSetora", "vSETora", "vEndor", "vSetero", "vSETero", "vSetora", "vEndora"], "vSubsetor": ["vSubetor", "vsubscriptor", "vSubsetOR", "vSubseto", "vsubseto", "vSubsetation", "vSubmentation", "vSubetOR", "vsubsetOR", "vsubsetation", "vSubetation", "vsubscriptOR", "vSubeto", "vSubmentOR", "vSubscriptation", "vSubscripto", "vsubscripto", "vsubscriptation", "vsubsetor", "vSubscriptOR", "vSubscriptor", "vSubmentor", "vSubmento"], "vSegmento": ["vIncreementano", "vSegMENTano", "vSeggmentano", "vIncremento", "vSegemento", "vSegMENTo", "vSeggmentao", "vSegementano", "vIncreementao", "vSegementO", "vIncreementO", "vSeggmentO", "vIncrementano", "vIncreemento", "vSegementao", "vSegmentao", "vSegmentO", "vSegMENTO", "vIncrementao", "vIncrementO", "vSegmentano", "vSegMENTao", "vSeggmento"], "registroAtual": ["RegistroATuel", "Registroatomic", "RegistroAtUAL", "RegistroATUAL", "RegistrosActual", "RegistrosActomic", "RegistrosAtuel", "RegistrosAtomic", "RegistroAtomic", "RegistroAtuel", "RegistroATual", "RegistrosActUAL", "RegistrosAtUAL", "RegistrosAtual", "Registroatuel", "RegistroatUAL", "RegistroActomic", "RegistroATomic", "RegistrosActuel", "Registroatual", "RegistroActuel", "RegistroActUAL", "RegistroActual", "RegistroAtual"], "vPapeisPorSegmento": ["vPapeisPorGmentO", "vPapeisPorSegmentedo", "vPapeisPorSegamento", "vPapeisPorSegmentedO", "vPapeisPorSegamentao", "vPapeisPorGamentO", "vPapeisPorSegementao", "vPapeisPorGmento", "vPapeisPorSegamentO", "vPapeisPorGamento", "vPapeisPorSegamente", "vPapeisPorSegmentao", "vPapeisPorSegmentO", "vPapeisPorGmentao", "vPapeisPorSegmentedao", "vPapeisPorSegmentede", "vPapeisPorGmente", "vPapeisPorGamente", "vPapeisPorSegemento", "vPapeisPorGamentao", "vPapeisPorSegementO", "vPapeisPorSegemente", "vPapeisPorSegmente"], "sql": ["orm", "security", "pr", "csv", "condition", "socket", "js", "pg", "html", "xml", "session", "install", "pel", "spr", "rel", "inv", "statement", "software", "string", "expression", "ql", "seed", "template", "table", "prefix", "description", "fn", "cmd", "details", "email", "str", "json", "mail", "eps", "sv", "dl", "sys", "nl", "sp", "wal", "comment", "select", "url", "s", "series", "log", "sd", "SQL", "query", "params", "spec", "cfg", "sol", "scl", "expr", "db", "ls", "sq"]}}
{"id1": "14764852", "id2": "14590676", "code1": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doRequest": ["runRequest", "DoGet", "runQuery", " doQuery", "DoResponse", "runGet", "doGet", " doResponse", "runResponse", " doGet", "DoQuery", "DoRequest", "doResponse", "doQuery"], "method": ["http", "m", "rest", "command", "mode", "tr", "pkg", "direct", "verb", "hod", "property", "post", "via", "Method", "term", "process", "ind", "th", "period", "mod", "rem", "type", "end", "nom", "top", "met", "class", "send", "eth", "module", "head", "METHOD", "mount", "request", "url", "agent", "right", "mid", "message", "path", "history", "each", "action", "text"], "headers": ["reports", "frames", "images", "dates", "tags", "blocks", "members", "header", "keys", "users", "limits", "options", "links", "rooms", "weights", "issues", "actions", "boxes", "ilers", "files", "bits", "head", "mods", "authors", "writers", "drivers", "names", "events", "xs", "heads", "pres", "checks", "packages", "groups", "modules", "holders", "codes", "fields", "params", "ers", "ppers", "ters", "ports", "terms"], "auth": ["http", "ip", "xy", "Auth", "ac", "priv", "cp", "pkg", "hd", "iam", "login", "authent", "cert", "cmd", "password", "form", "img", "ssl", "act", "pub", "stat", "force", "upload", "cb", "pas", "crypt", "urg", "acl", "anon", "uth", "help", "mk", "read", "aud", "lit", "ok", "ic", "util", "aut", "ht"], "target": ["ip", "to", "link", "address", "root", "rel", "location", "state", "template", "base", "loc", "table", "client", "top", "subject", "eth", "arg", "src", "scope", "arget", "origin", "peer", "iat", "proxy", "url", "resource", "profile", "range", "Target", "ARGET", "tx", "gt", "host", "path", "message", "dest", "uri", "source"], "body": ["b", "report", "dis", "ne", "pos", "null", "bh", "data", "parts", "h", "post", "options", "obs", "msg", "related", "description", "by", "any", "json", "other", "subject", "vol", "note", "reply", "ODY", "bill", "comment", "bytes", "news", "be", "file", "ody", "se", "plain", "part", "query", "odies", "Body", "params", "content", "object", "db", "shell", "message", "bs", "out", " Body", "buffer", "ob", "text", "source"], "con": ["syn", "ca", "conn", "mon", "gate", "cat", "cp", "dat", "dial", "cos", "cgi", "Conn", "rec", "cond", "pan", "c", "xc", "cons", "fn", "cf", "cmd", "col", "ct", "uc", "comm", "ver", "un", "cont", "trans", "bo", "conv", "nc", "compl", "co", "ocon", "cr", "ch", "cb", "cu", "dec", "pas", "cur", "ce", "win", "com", "connect", "ln", "go", "CON", "ran", "ctrl", "can", "en", "ain", "cal", "cm", "conf", "pen", "sin", "bon", "cn", "bur", "Con"], "res": ["rest", "pr", "val", "ex", " Res", "resp", "Res", "reset", "us", "rel", "inv", "obj", "ress", "re", "req", "rep", "rs", "des", "reg", "rem", "cons", "RES", "red", "ret", "ms", "cs", "pas", "news", "results", "ts", "respons", "result", "gr", "ps", "out", "ne", "vals", "nt"]}}
{"id1": "15465293", "id2": "4562786", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"Usage:  URLDumper <URL> <file>\");\n            System.exit(1);\n        }\n        String location = args[0];\n        String file = args[1];\n        URL url = new URL(location);\n        FileOutputStream fos = new FileOutputStream(file);\n        byte[] bytes = new byte[4096];\n        InputStream is = url.openStream();\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            fos.write(bytes, 0, read);\n        }\n        is.close();\n        fos.close();\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"location": ["human", "Location", "command", "settings", "lc", "address", "target", "filename", "folder", "directory", "loc", "area", "document", "layout", "description", "LOC", "program", "localhost", "valid", "sample", "dir", "comment", "where", "info", "origin", "position", "local", "home", "storage", "reference", "place", "path", "history", "translation", "remote", "option", "message", "uri"], "file": ["rule", "link", "to", "data", "angle", "filename", "target", "user", "label", "string", "entity", "base", "name", "table", "document", "fil", "f", "ile", "fp", "dir", "title", "domain", "port", "resource", "local", "File", "le", "log", "output", "path", "place", "message", "page", "out", "FILE", "source"], "url": ["browser", "http", "link", "web", "l", "ll", "rl", "rel", "el", "user", "hl", "lb", "base", "loc", "ly", "char", "f", "str", "ul", "abs", "ssl", "dl", "build", "ur", "nl", "bel", "mount", "https", "URL", "gl", "impl", "log", "ml", "Url", "sl", "gb", "get", "g", "ol", "ls", "uri"], "fos": ["fors", " foes", "sfos", "foes", "toes", "boses", "ifos", "flo", "fo", "floss", "vos", "tis", "sfoes", "Foes", "voss", "baos", "Fos", "floes", "Fors", "foss", " fis", "Fis", "fis", "voses", "flos", "bos", "ifoss", "ifoes", "sfoses", "vo", "ifo", "foses", "boes", "sfaos", "tors", "tos", "vaos", " fors", "voes", "faos"], "bytes": ["reports", "frames", "bes", "words", "classes", "blocks", "services", "parts", "users", "seconds", "lines", "pieces", "pointers", "bles", "gets", "usable", "bps", "odes", "cells", "les", "boxes", "eps", "ms", "files", "bits", "steps", "rows", "tes", "ings", "ips", "checks", "es", "gb", "outs", "ies", "values", "rings", "bs", "pages", "units", "Bytes", "gs", "terms", "vals", "ones"], "is": ["ip", "dis", "ris", "isi", "in", "it", "bis", "lis", "sis", "ists", "has", "isa", "are", "ins", "im", "ais", "os", "vis", "ois", "ii", "ires", "tis", "its", "IS", "abs", "sys", "Is", "isf", "isin", "iso", "ms", "init", "bits", "ios", "does", "nis", "ri", "iss", "es", "iris", "ist", "isl", "ims", "ps", "bs", "ic", "isc", "i"], "read": ["raw", "print", "feed", "val", "in", "push", "skip", "q", "chain", "loop", "play", "input", "index", "bind", "reading", "buffer", "fill", "ind", "pass", "exec", "load", "used", "hold", "open", "height", "end", "count", "send", "valid", "write", "lex", "sample", "ride", "iter", "size", "check", "wait", "stream", "add", "connect", "depth", "allow", "range", "start", "ready", "READ", "query", "set", "find", "get", "hello", "run", "length", "Read", "reads", "text", "select", "readable", "len"]}}
{"id1": "22977189", "id2": "19134229", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["inf", "raw", "IN", "it", "ill", "inc", "inner", "cin", "are", "ins", "ro", "input", "user", "reader", "ind", "rin", "bin", "up", "In", "inside", "is", "ini", "io", "ar", "ze", "init", "con", "iter", "ln", "ri", "gin", "from", "read", "get", "conf", "inn", "on", "r", "i", "ic", "din"], "out": ["o", "b", "to", "n", "v", "conn", "null", "cache", "l", "it", "print", "list", "screen", "inner", "full", "flush", "chain", "obj", "res", "OUT", "at", "timeout", "os", "rem", "Out", "io", "cmd", "writer", "aos", "client", "by", "end", "outer", "sys", "ret", "bit", "mem", "conv", "write", "note", "co", "j", "ot", "con", "report", "news", "port", "w", "result", "auto", "log", "gt", "set", "can", "all", "en", "console", "outs", "output", "on", "db", "tmp", "pool", "net", "or", "i", "not", "nt"], "line": ["entry", "n", "rule", "print", "code", "link", "l", "lin", "eline", "header", "key", "chain", "user", "date", "string", "entity", "base", "stroke", "name", "sequence", "error", "char", "style", "cell", "row", "Line", "ine", "inline", "online", "valid", "character", "comment", "column", "ln", "block", "word", "iter", "next", "le", "LINE", "file", "lane", "ice", "point", "lined", "match", "day", "message", "page", "frame", "text"]}}
{"id1": "13012591", "id2": "22338097", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 1, "substitutes": {"getPasswordHash": ["getPassHash", "getpasswordHash", "getPassSum", "getPassMac", "getUserhash", " getPasswordSum", "getUserMac", " getPassSum", " getPasshash", " getPasswordhash", " getPassHash", " getPassMac", "getPasswordMac", "getPasswordSum", "getpasswordMac", "getPasshash", "getpasswordSum", " getPasswordMac", "getUserSum", "getPasswordhash", "getpasswordhash", "getUserHash"], "password": ["Password", "entry", "raw", "shadow", "secret", "command", "data", "address", "key", "reset", "user", "pass", "input", "string", "padding", "database", "username", "token", "sword", "name", "login", "prefix", "description", "attribute", "email", "wd", "phrase", "word", "w", "value", "pattern", "content", " Password", "hello", "message", "text"], "md": ["d", "m", " ms", "mg", "cd", " sd", "ld", "mand", " Md", "bd", "pd", "hd", "grad", " mm", "MD", "mm", "det", "od", "ind", "mac", "med", " mc", "mod", "cmd", "dd", "red", " ma", "der", "df", "mem", " dd", "ms", "e", "nd", "dir", "and", "dh", "mc", "mt", "mn", "metadata", "add", "rm", "mp", "mk", "sm", "ent", "sd", "mo", "dm", "di", "gr", " mo"], "hash": ["ashes", "report", "sh", "print", "cache", "bh", "ash", "html", "address", "sum", "h", "test", "filter", "square", "has", "index", "total", "esh", "mac", "array", "used", "table", "Hash", "ashed", "char", "style", "number", "sample", "score", "dig", "where", "box", "color", "stack", "hex", "block", "check", "search", "mask", "handle", "map", "oh", "here", "all", "match", "host", "hz", "shift", "sha"], "buf": ["pb", "b", "bh", "Buffer", "hung", "cat", "pkg", "proc", "av", "fam", "mu", "msg", "aux", "bu", "rb", "bar", "cmd", "uf", "ob", "cf", "alph", "bag", "bp", "ov", "bed", "var", "agg", "img", "bo", "abs", "bn", "bg", "buff", "br", "cb", "cap", "box", "bytes", "block", "cur", "forge", "cv", "next", "printf", "bc", "bl", "nb", "db", "tmp", "bs", "Buff", "buffer", "foo", "txt"], "i": ["m", "multi", "ip", "v", "ci", "ui", "n", "o", "yi", "in", "it", "ex", "ji", "ei", "gi", "key", "I", "q", "chain", "phi", "us", "index", "ind", "im", "\u0438", "c", "y", "ki", "ini", "li", "is", "ii", "iq", "gu", "ski", "iu", "xi", "json", "bi", "pi", "u", "j", "ms", "e", "a", "cli", "ri", "ai", "sim", "z", "mi", "ti", "ix", "ogi", "di", "ims", "my", "ic", "x", "si", "hi", "qi", "uri"]}}
{"id1": "841724", "id2": "20920051", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewend", "readAndrewWrite", "readAndResend", "readAndrewrite", "readAndRepend", "readAndRewrites", "readAndResrites", "readAndRewWrite", "readAndRewend", "readAndRepWrite", "readAndResWrite", "readAndResrite", "readAndrewrites", "readAndReprites"], "inFile": ["infile", "InFilename", " inFilename", "docFilename", "inPlace", "outfile", "initFile", "INPlace", "iFILE", "inputFile", "inputPlace", "initFace", "inputFace", "iTime", "outFilename", "INFile", "Infile", "docTime", "InFile", "inFILE", "docFile", "initFilename", "iFilename", " infile", "inFace", "initPlace", "INFilename", "inTime", "inputFilename", "INTime", "inFilename", "iFile", "docFILE", "INFace", "INFILE"], "outFile": ["infile", "nameFILE", "checkFile", "outfile", "toFile", "checkFILE", "toFilename", "nameFilename", "checkfile", "toFILE", "checkFilename", "reportfile", "outFilename", " outFILE", "inFILE", "namefile", "reportFILE", "reportFilename", "tofile", " outfile", " outFilename", "outFILE", "reportFile", "nameFile", "inFilename"], "iis": ["diIs", "liis", "IIs", " iiss", "liris", "iIs", "iiss", " iIs", "iIS", "diis", "liisc", "diiss", "iiris", "eIs", "eIS", "Ii", "iiis", "ii", "liIs", " iIS", "eis", "dii", " iisc", " ii", "Iis", "aiis", "aiIs", "aiIS", "iiIs", " iris", "iiisc", "iris", "iisc", "Iiss"], "dcmParser": ["dcomParser", "dpmBuilder", " dpmPar", "dromParser", "dcommParser", "dfmBuilder", "dgrPar", "dcrparser", "DcmReader", "decmReader", "dmReader", " dpmAssistant", "deromReader", " dcmarser", "dcmStatement", "dcmReader", "dromReader", "dromparser", "dromListener", "dcmLoader", "dmmParser", "dpmLoader", "DpmPar", "dcommAssistant", "dmodulePrivate", "dmarser", "dmParser", "dcrParser", "DcmAdapter", "dcrBuilder", "DpmReader", "dcmPrivate", "dpmparser", " dpmReader", "DpmAdapter", "dmmmParser", "Dcmparser", "dpmStatement", "drumReader", " dpmPrivate", "dpcPrivate", " dpmBuilder", "dcmPar", "dfmLoader", "dgrStatement", "dcfStatement", "dmmmAdapter", " dcmLoader", "dpcParser", "DcmPar", "Dpmparser", "drumPar", "dcfReader", "dpmAdapter", " dpmListener", "dcomLoader", " dcmparser", "dgrReader", "DcmBuilder", "deromparser", "dpmAssistant", "deromParser", "drumParser", " dcmListener", "dpmarser", "decmParser", "drumBuilder", " dpmParser", "dmmarser", " dpmparser", "dcomReader", "dgrParser", "dcommReader", "dmoduleParser", " dpmStatement", "dpcReader", "deromarser", "dcmAssistant", " dcmPar", "dcommListener", "dpcAssistant", "dmoduleReader", "DpmBuilder", "dcmAdapter", "dcrReader", "dpmReader", "dfmReader", "dmmmReader", "decmarser", "dcomBuilder", "dpmPar", "dromAssistant", "dpmPrivate", " dcmBuilder", " dcmAssistant", "dpmParser", "dpmListener", "DcmParser", "dmmmparser", "dmoduleAssistant", "dcfPar", "dcmBuilder", " dcmPrivate", "decmparser", "dcmarser", "dmmparser", "dmparser", "dfmParser", " dcmStatement", "dromarser", "dcmListener", "DpmParser", " dpmarser", "dcmparser", " dcmReader", "dmmReader", " dpmLoader", "dcfParser", "dmmAdapter"], "ds": ["d", "ks", "sets", "js", "in", "ws", "DS", "services", "dat", "bd", "data", "pd", "Ds", "hd", "qs", "gd", "dq", "ins", "obs", "rs", "des", "os", "da", "ods", "ss", "hs", "details", "dd", "aos", "ads", "its", "der", "dx", "df", "vs", "sys", "dl", "eps", "sv", "dos", "ys", "dh", "cs", "uds", "eds", " DS", "drivers", "tes", "pers", "xs", "s", " des", "dds", "es", "fs", "sd", "as", "ims", "ps", "db", "outs", "dt", "bs", "ils", "ns", "gs", "ls"], "pdReader": ["tdReader", "ddLoader", "ddRunner", "xdLoader", "pedCar", "ddCar", "pedLoader", "tdParser", "pedReader", "hdWriter", "pdRead", "ddHelper", "pdCar", "pedRunner", "vdWriter", "pdParser", "vdLoader", "vdHelper", "dpLoader", "hdReader", "ddRead", "hdRead", "xdWriter", "ddReader", "vdReader", "dpRunner", "tdRead", "dpReader", "pdHelper", "pdLoader", "ddWriter", "dpCar", "ddParser", "hdParser", "tdWriter", "xdHelper", "pdRunner", "xdReader"], "out": ["cache", "list", "null", "in", "it", "data", "full", "ins", "desc", "msg", "c", "io", "client", "end", "sys", "we", "serv", "con", "go", "w", "t", "gr", "tmp", "o", "n", "to", "raw", "v", "pos", "ex", "inner", "flush", "at", "os", "over", "up", "Out", "cmd", "aos", " err", "cb", "ent", "sw", "id", "output", "pool", "p", "nt", "screen", "conn", "js", "oss", "err", "sum", "OUT", "one", "writer", "str", "ch", "nr", "opt", "s", "all", "en", "outs", "on", "gen", "obj", "inv", "res", "status", "name", "ou", "outer", "co", "log", "auto", "gt", "inter", "cfg", "net", "cn", "conv", "txt"], "dcmEncParam": ["dcmEscNum", "dcmencParam", "dmmencParam", "dcmDecCmd", "dcmEncPar", "dmmEncMsg", "dmmEncPar", "dcmencPar", "dcmencCmd", "dmmencNum", "dcmEncVal", "dmmEncParam", "dmmEncCmd", "dcmEscPar", "dcmEscVal", "dcmEnNum", "dmmEnPar", "dcmDecMsg", "dcmEncNum", "dcmEncCmd", "dmmEnNum", "dcmencMsg", "dmmencCmd", "dcmDecNum", "dcmEnVal", "dcmEnParam", "dcmEncMsg", "dmmencMsg", "dcmEscParam", "dcmencNum", "dmmEncNum", "dmmEnParam", "dmmEncVal", "dcmDecParam", "dcmEnPar"], "pdWriter": ["pdwriter", "dpWrite", "tdWriting", "pcWriting", "PDWriter", "pcwriter", "pidWriting", "pdWrite", "pdWriting", "PDReader", "PDWrite", "pdEditor", "tdWrite", "PDEditor", "tdwriter", "pidwriter", "pcWrite", "pidWriter", "pcWriter", "dpReader", "pidWrite", "dpEditor", "tdWriter", "tdReader", "tdEditor", "dpWriter"]}}
{"id1": "9275622", "id2": "12783713", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyfile", " cpFiles", " copyFiles", "copyFiles", "copyStream", " duplicateFiles", " duplicatefile", " duplicateFile", " cpStream", " cpFile", " duplicateStream", " copyStream", " copyfile"], "_file1": ["_linkOne", "_ileFirst", "_ileOne", "_fileFirst", "_link2", "_files1", "_FileInit", "_File2", "_fileOne", "_ileInit", "_ile1", "_filesFirst", "_FileFirst", "_linkInit", "_File1", "_ile2", "_filesOne", "_link1", "_fileInit", "_files2", "_FileOne"], "_file2": ["_File02", "_imageb", "_file02", "_filetwo", "_link2", "_image1", " _file02", " _File2", " _FILEb", "_FILE02", " _filetwo", "_FILEb", "_File2", " _fileb", "_image02", "_FILE2", " _FileTwo", "_image2", "_Fileb", "_linktwo", " _FILE02", "_FILE1", "_FileTwo", "_File1", " _Filetwo", "_linkTwo", " _fileTwo", "_fileTwo", " _FILE2", "_link1", " _FILE1", "_fileb", "_Filetwo", " _File1"], "fis": ["cais", " fris", "kos", "Fois", "fiss", "cfris", "cos", "fliss", "ufis", "ufios", "Fios", "qis", "qios", "cfis", " fois", "qos", "flis", " fios", "cfois", "ufi", "cfiss", "fi", " fiss", "kios", "fios", "flios", "ufiss", "Fos", "fli", "Fris", "cios", "Fiss", "kais", "Fis", "kis", " fi", "qiss", " fais", "cis", "fois", "fais", "fris"], "fos": ["hoss", "hos", " foes", "hoes", "mows", " fose", "moes", "sfos", "foes", "fows", " faos", "ffoss", "ffos", " fows", "flis", "fose", "wows", "floss", "woss", "sfoes", "wis", "woes", "wos", " foss", "floes", "foss", "maos", "ffis", "flos", "sfose", "waos", "ffoes", "hose", "sfoss", "faos", "mos"], "canalFuente": ["canallFueree", "canalFuent", "canallfuperor", "canalFienza", "canalFalent", "canalFalestro", "canalFiperor", "canalFalperor", "canalFalje", "canalFaleree", "canallfuente", "canalFiente", "canallfuenza", "canalfuperor", "canalFuenza", "canalUteree", "canalFuperor", "canallFuent", "canallFuje", "canallFuestro", "canalUtestro", "canallFuperor", "canalKuperor", "canalFalente", "canalfuent", "canalfuje", "canalKuje", "canallFuente", "canallfuje", "canalfueree", "canalUtente", "canalTenent", "canalFueree", "canalKuent", "canallFuenza", "canalTenente", "canalfuenza", "canallfuestro", "canalUtent", "canallfuent", "canalFuje", "canalFuestro", "canalKuente", "canalTenenza", "canalTenperor", "canallfueree", "canalfuestro", "canalFient", "canalfuente"]}}
{"id1": "6840241", "id2": "9109613", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["link", "print", "cat", "cp", "cop", "create", "call", "Copy", "system", "clip", "transfer", "load", "replace", "write", "save", "move", "clone", "sync", "size", "gc", "map", "read", "close", "cover", "opy", "delete", "slice", "share"], "source": ["cache", "inner", "SOURCE", "body", "site", "session", "ins", "input", "store", "reader", "image", "status", "state", "base", "template", "table", "inside", "wrapper", "style", "subject", "sql", "context", "src", "scope", "sample", "sp", "ource", "origin", "iter", "info", "Source", "ce", "size", "stream", "resource", "local", "from", "se", "start", "master", "spec", "shell", "pse", "sr", "si", "ie", "select", "parent"], "sink": ["ssink", "Sink", "sender", "slender", "sinker", " sender", "Sinker", " sue", "Sender", "slource", "Sue", "asinker", "Source", "ssender", "asink", "sue", "asender", "slink", "ssource", " sinker", "asource", "slue", "ssinker"]}}
{"id1": "3958807", "id2": "13891080", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBixedStream", "loadEmbinaryFile", "loadBinaryInput", "loadEmbinaryStream", "loadBignedInput", "loadEmbbinaryStreamer", "loadEmbbinaryInput", "loadEmbinaryInput", "loadBignedStreamer", "loadBixedFile", "loadBignedStream", "loadEmbinaryStreamer", "loadBbinaryFile", "loadBinaryStreamer", "loadEmbbinaryFile", "loadBignedFile", "loadBbinaryStreamer", "loadBbinaryStream", "loadBbinaryInput", "loadBixedInput", "loadBinaryFile", "loadBixedStreamer", "loadEmbbinaryStream"], "streamName": [" streamNAME", "streamHandle", "streamPath", "longName", "longPath", "stringName", "Streamname", "stringType", "resourceType", "recordNAME", "fileNAME", "streamNAME", "StreamNAME", "StreamName", "resourceName", " streamname", "recordHandle", "streamType", "stringNAME", " streamType", " streamPath", "longNAME", "filePath", "StreamHandle", "recordName", "streamname", "resourceNAME", " streamHandle", "fileName", "recordname"], "streamToLoad": [" streamToload", "streamtoLoad", "streamToRead", "streamToAdd", "streamTOload", "stringWillLoad", " streamToUse", "streamToUse", "streamWillAdd", "stream2load", "streamTORead", "stream2Read", " stream2Load", "stream2Use", "streamtoAdd", " streamWillload", " stream2Read", "stringToAdd", "streamTOLoad", "stringWillAdd", " streamWillLoad", "streamTOAdd", "streamWillLoad", "stringToLoad", " stream2load", "stringToload", "streamtoload", "stream2Load", " stream2Use", "streamWillload", "stringWillload", " streamToRead", "streamTOUse", "streamToload"], "sz": ["insz", "Sch", "sld", "rsld", " sze", "sch", " sld", " sch", "rsz", "Sld", "Siz", "insch", "Sz", "insiz", "rsze", "siz", "insze", "rsiz", "Sze", " siz", "sze"], "req": ["comp", "http", "wcs", "pkg", "qs", "q", "proc", "ctx", "inv", "wx", "dq", "res", "attr", "seq", "quick", "rx", "quest", "jp", "requ", "cmd", "client", "comm", "org", "usr", "request", "pas", "cur", "qt", "urg", "Request", "require", "qq", "query", "fr", "gr", "Requ", "sq"], "resp": ["http", "report", "dis", "pos", "conn", "esp", "html", "Res", "respond", "body", "rel", "proc", "wr", "res", "inv", "rend", "re", "wx", " Resp", "obj", "rec", "response", "rep", "status", "msg", "os", "jp", "RES", "cmd", "client", "comm", "sys", "ret", "vol", "compl", "sp", "serv", "cmp", "request", "pas", "https", "soc", "respons", "Response", "Resp", "exp", "fs", "result", "cl", "fr", "sol", "content", "output", "r", "gr", "conv", "p", "nt"], "out": ["o", "n", "to", "null", "in", "oss", "ex", "ws", "cos", "us", "obj", "ins", "res", "OUT", "os", "Out", "ou", "io", "yout", "aos", "client", "sys", "conv", "vol", "co", "ot", "w", "t", "ts", "log", "sw", "gt", " outs", "utt", "output", "outs", "bs", "net", "cn", "gs", "nt"], "bos": ["bes", "bh", "js", "oss", "bis", "ws", "los", "bas", "banks", "oos", "ubis", "obs", "bot", "bles", "bin", "base", "des", "os", "ods", "aos", "boards", "bi", "BS", "eros", "bo", "sys", "nos", "dos", "bits", "buff", "bytes", "ios", "ys", "ols", "tes", "ts", "fits", "oops", "jas", "bat", "oids", "uts", "bs", "bones", "mos"]}}
{"id1": "1443205", "id2": "7425022", "code1": "    private void redirect(TargetApp app, HttpServletRequest request, HttpServletResponse response) throws IOException {\n        URL url = new URL(app.getUrl() + request.getRequestURI());\n        s_log.debug(\"Redirecting to \" + url);\n        URLConnection urlConnection = url.openConnection();\n        Map<String, List<String>> fields = urlConnection.getHeaderFields();\n        for (String key : fields.keySet()) {\n            StringBuffer values = new StringBuffer();\n            boolean comma = false;\n            for (String value : fields.get(key)) {\n                if (comma) {\n                    values.append(\", \");\n                }\n                values.append(value);\n                comma = true;\n            }\n            if (key != null) {\n                response.setHeader(key, values.toString());\n            } else {\n                response.setStatus(Integer.parseInt(values.toString().split(\" \")[1]));\n            }\n        }\n        InputStream in = urlConnection.getInputStream();\n        try {\n            ServletOutputStream out = response.getOutputStream();\n            byte[] buff = new byte[1024];\n            int len;\n            while ((len = in.read(buff)) != -1) {\n                out.write(buff, 0, len);\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"redirect": [" redurl", "adir", "Redir", " redir", "adurl", "Redurl", "redirection", " redirection", "redir", "adirection", "adirect", "redurl", "Redirection", "Redirect"], "app": ["browser", "http", "b", "m", "access", "apps", "comp", "conn", "ac", "web", "ca", "project", "ap", "pkg", "server", "atom", "process", "cms", "base", "os", "up", "framework", "comm", "abs", "org", "application", "App", "be", "port", "Application", "com", "service", "map", "pp", "exp", "bb", "g", "APP", "ip", "db", "display", "apply"], "request": ["report", "raw", "command", "project", "create", "address", "reset", "question", "input", "re", "process", "req", "accept", "quest", "attribute", "form", "first", "context", "application", "setup", "position", "task", "now", "each", "complete", "Request", "query", "trip", "initial", "get", "hello", "view", "event", "reference", "message", "change", "frame", "current"], "response": ["http", "report", "print", "continue", "socket", "network", "server", "resp", "respond", "reset", "res", "onse", "window", "index", "status", "image", "document", "sequence", "description", "json", "send", "we", "connection", "context", "application", "write", "sp", "reply", "version", "position", "block", "next", "format", "service", "soc", "respons", "Response", "result", "exit", "release", "success", "model", "content", "relation", "view", "output", "ren", "fire", "message", "display", "page", "frame", "tree"], "url": ["http", "pl", "link", "web", "l", "ll", "xml", "address", "rel", "el", "re", "hl", "base", "name", "cert", "email", "www", "f", "str", "ul", "mail", "abs", "ret", "ssl", "dl", "org", "build", "ur", "nl", "ref", "bel", "mount", "https", "URL", "acl", "gl", "service", "Url", "sl", "get", "r", "path", "util", "ob", "ls", "uri"], "urlConnection": ["sslClient", "UrlConnect", "UrlClient", "sslConnection", " urlConnect", "httpConnection", " urlconnection", "httpClient", "UrlPosition", " urlOpen", "urlconnection", "httpPosition", "httpConnect", " urlPosition", "sslConnect", "sslconnection", "Urlconnection", "urlOpen", "httpOpen", "UrlOpen", "UrlConnection", "urlPosition", "urlConnect", "httpconnection", "urlClient"], "fields": ["forms", "phones", "dates", "types", "sets", "words", "orders", "tags", "services", "members", "keys", "users", "uploads", "views", "lines", "gets", "levels", "details", "balls", "vers", "boxes", "packs", "rules", "ms", "files", "ls", "headers", "atts", "rows", "drivers", "loads", "names", "changes", "heads", "relations", "checks", "groups", "fs", "flags", "workers", "holders", "hips", "lists", "faces", "masters", "sections", "lights", "pages", "keepers", "ports", "terms"], "key": ["entry", "rule", "important", "code", "null", "val", "step", "pkg", "Key", "keys", "k", "chain", "major", "hash", "property", "label", "date", "index", "string", "what", "token", "base", "tip", "name", "y", "field", "prefix", "description", "attribute", "type", "char", "item", "by", "row", "var", "json", "KEY", "phrase", "owner", "title", "sign", "column", "info", "word", "er", "primary", "ke", "pattern", "part", "id", "set", "variable", "kind", "default", "option", "kid", "tag", "et", "parent", "source"], "values": ["errors", "strings", "objects", "sets", "phones", "forms", "csv", "tags", "settings", "blocks", "times", "services", "pins", "keys", "members", "users", "options", "obs", "als", "lines", "gets", "places", "cells", "ends", "lets", "vs", "actions", "boxes", "files", "videos", "rows", "bytes", "results", "drivers", "changes", "versions", "Values", "checks", "items", "beans", "flags", "ups", "lists", "states", "uts", "ports", "maps", "marks", "units", "terms", "vals"], "value": ["entry", "v", "null", "val", "node", "data", "create", "test", "property", "label", "string", "database", "state", "name", "field", "sequence", "description", "attribute", "language", "password", "feature", "ue", "style", "json", "cell", "VALUE", "other", "pair", "unit", "sample", "example", "version", "element", "block", "vector", "zone", "Value", "widget", "point", "variable", "object", "hello", "default", "message", "python"], "comma": ["cumda", "COMpa", "calma", "scheMA", "centa", "COMma", "compda", "calbo", "commonenta", "combo", "calenta", "qualma", "qualota", "scheenta", "COMMA", "cpa", "calda", "schepa", "cumbo", "compmission", "compbo", "cma", "compma", "comMA", "compota", "comda", "comota", "compa", "qualenta", "cumma", "cumenta", "commonmission", "schema", "COMenta", "qualmission", "comenta", "commonota", "commission", "commonma", "cMA", "compenta"], "in": ["inf", "o", "n", "conn", "IN", "inc", "it", "al", "inner", "cin", "body", "ins", "input", "reader", "ind", "up", "In", "ini", "is", "inside", "io", "form", "f", "pi", "isin", "init", "old", "info", "con", "iter", "stream", "ai", "t", "from", "file", "read", "en", "ain", "get", "inn", "r", "on", "ic", "din", "i"], "out": ["o", "b", "n", "to", "v", "print", "oss", "inner", "flush", "inv", "res", "OUT", "at", "os", "ou", "Out", "io", "aos", "writer", "external", "end", "outer", "sys", "we", "co", "write", "e", "con", "w", "t", "en", "OU", "output", "outs", "on", "r", "net", "i", "cn", "ne", "nt"], "buff": [" buf", "pb", "b", "butt", "xx", "batch", "comp", "tab", "dat", "oct", "hd", "grow", "obs", "ext", "ind", "seq", "ff", "uf", "cmd", "buf", "bed", "bo", "mem", "bf", "nd", "bg", "box", "cb", "stack", "fac", "hex", "fb", "printf", "lf", "qq", "cod", "bb", "fr", "uff", "bl", "bound", "tmp", "bs", "Buff", "ck", "buffer", "ob", "txt"], "len": ["pl", "n", "pos", "val", "l", "js", "err", "ld", "ll", "num", "elt", "full", "el", "ell", "ind", "seq", "lon", "end", "fin", "str", "buf", "dl", "count", "vol", "mem", "lim", "cap", "lif", "cmp", "lan", "ln", "vec", "fun", "coll", "t", "gl", "exp", "lf", "del", "cod", "Len", "cl", "en", "all", "bl", "lib", "nt", "length", "ls", "z"]}}
{"id1": "2168610", "id2": "13333160", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 0, "substitutes": {"update": ["print", "num", "user", "database", "fill", "grade", "state", "msg", "commit", "init", "diff", "get", "component", "change", "select", "current", "report", "continue", "updated", "index", "load", "up", "row", "offset", "u", "save", "value", "resource", "handle", "result", "set", "id", "find", "run", "insert", "batch", "equal", " UPDATE", "call", "date", "remove", "send", "write", "where", "info", "put", "check", "now", "out", "action", "http", " Update", "dates", "use", "Update", "edit", "create", "status", "login", "latest", "touch", "ul", "count", "draw", "size", "add", "exit", "op", "delete", "UPDATE"], "o": ["m", "n", "to", "oin", "oid", "l", "oa", "h", "k", "q", "obj", "lo", "aco", "c", "O", "os", "fo", "ooo", "cont", "onet", "bo", "iso", "co", "e", "oco", "ao", "ilo", "t", "om", "mo", "object", "oo", "po", "a", "out", "i", "ob", "p"], "contact": ["report", "entry", "att", "print", "impact", "CONT", "l", "phone", "detail", "cp", "address", "form", "controller", "responsible", "transfer", "group", "aco", "Contact", "lead", "details", "compliance", "client", "ct", "char", "acts", "comm", "panel", "cont", "cell", "mail", "consider", "trans", "act", "connection", "claim", "country", "force", "international", "conduct", "info", "title", "work", "module", "check", "port", "add", "format", "service", "pp", "config", "close", "match", "company", "content", "hello", "component", "addr", "message", "ACT", "control", "cc", "display", "translation", "action", "communication", "character", "fax", "charge"], "pst": ["dst", "prst", "pset", "vpset", " pster", "dpster", "presth", "pster", "apSt", "Ppt", "vpst", " pST", "Pse", "pct", "jpst", "bpst", "pingstra", "ipsth", "apst", "phpct", "ipmt", "lst", "preth", "tpct", " pSt", "pstan", "apost", "jpsy", " pct", "apstan", "pingsta", "tpst", "pest", "epct", "jpSt", "prct", "PST", "pingst", "preSt", "ply", "jpset", "pept", "phpst", "psth", "pSt", "epnt", " ply", "jply", "pmt", "pth", "lST", "pect", "phpnt", "ipST", "pingstal", "ipst", "post", "epst", "bpstan", " pstra", "pST", "dpct", "drest", "psy", "psta", " psth", "jpmt", "phpstal", " pstan", "tpstra", " pmt", "prse", " post", "pingth", "pstal", "ipth", " psy", "pingct", "Prest", "prest", "lse", "pingSt", "bpost", "dpsy", "dpt", "perest", "presta", "lct", "bpSt", "jpST", "ppt", "jpster", "vpct", "jpct", "epstal", "Pst", "Pct", " pset", "tpstal", "ipct", "prST", "ipSt", "pstra", "dct", "vply", "prect", " pnt", " pstal", "ipsta", "pnt", "pse", "dpst"]}}
{"id1": "3024987", "id2": "15896098", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "label": 0, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStream_Encoded"], "in": ["inf", "m", "n", "ac", "IN", "l", "it", "inc", " IN", "data", "inner", "cin", "ins", "input", "mm", "ind", "rin", "bin", "up", "In", "ini", "is", "inside", "Input", "cont", "act", "isin", "init", "con", "info", "copy", "iter", "mc", "from", "gin", "local", "mi", "read", "as", "inn", "sin", "r", "din", "i", "p", "source"], "reader": ["ocker", "rl", "data", "inner", "Reader", "ro", "input", "ner", "rar", "parser", "reading", "dr", "req", "rot", "rx", "io", "handler", "writer", "oe", "rise", "red", "row", "phrase", "iter", "er", "iterator", "file", "rr", "driver", "loader", "read", "mr", "query", "Larry", "r", "per", "buffer"], "baout": ["boos", " baot", "yaot", "yaout", "beanOut", "haOut", " bain", "cain", "caOut", "beanout", "baot", "BAout", "haout", "baOut", "BAot", " bares", "yares", "baos", "caout", "BAin", "beanouts", "BAres", "caos", "oaOut", "oaos", "oain", "bain", "beanin", "baouts", "haouts", "boOut", "hain", "bares", "caouts", "oaout", "yain", "boin", "boout"], "out": ["o", "b", "n", "to", "batch", "null", "oss", "ex", "cos", "res", "OUT", "os", "Out", "ou", "io", "cmd", " os", "client", "outer", "sys", "bo", " bout", "conv", "con", "copy", "ao", "t", " output", " Out", "auto", "gt", "update", "all", " outs", " OUT", "OU", "output", "outs", "stable", "net", "cn", "ne"], "bytes": ["reports", "strings", "frames", "objects", "raw", "words", "classes", "blocks", "services", "data", "parts", "users", "seconds", "lines", "pieces", "gets", "des", "bps", "latest", "cells", "les", "its", "issues", "pdf", "files", "bits", "resources", "ites", "videos", "letters", "results", "tes", "names", "comments", "ings", "versions", "ips", "es", "groups", "binary", "faces", "outs", "ies", "values", "bs", "pages", "unks", "units", "Bytes", "gs", "reads", "terms", "vals", "ones"]}}
{"id1": "3024987", "id2": "16308040", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public boolean update(String dbName, Query[] queries) throws ServiceException {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n        int rows = 0;\n        try {\n            con = getDbConnection().getConnection(dbName);\n            con.setAutoCommit(false);\n            for (int i = 0; i < queries.length; i++) {\n                Query query = queries[i];\n                System.out.println(query.getSql());\n                pstmt = con.prepareStatement(query.getSql());\n                addParametersToQuery(query, pstmt);\n                rows += pstmt.executeUpdate();\n            }\n            con.commit();\n            return rows > 0;\n        } catch (DbException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            log.error(\"[DAOService::update] Execute rollback \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } catch (SQLException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } finally {\n            closeConnection(con, pstmt, null);\n        }\n    }\n", "label": 0, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStream_Encoded"], "in": ["inf", "m", "n", "ac", "IN", "l", "it", "inc", " IN", "data", "inner", "cin", "ins", "input", "mm", "ind", "rin", "bin", "up", "In", "ini", "is", "inside", "Input", "cont", "act", "isin", "init", "con", "info", "copy", "iter", "mc", "from", "gin", "local", "mi", "read", "as", "inn", "sin", "r", "din", "i", "p", "source"], "reader": ["ocker", "rl", "data", "inner", "Reader", "ro", "input", "ner", "rar", "parser", "reading", "dr", "req", "rot", "rx", "io", "handler", "writer", "oe", "rise", "red", "row", "phrase", "iter", "er", "iterator", "file", "rr", "driver", "loader", "read", "mr", "query", "Larry", "r", "per", "buffer"], "baout": ["boos", " baot", "yaot", "yaout", "beanOut", "haOut", " bain", "cain", "caOut", "beanout", "baot", "BAout", "haout", "baOut", "BAot", " bares", "yares", "baos", "caout", "BAin", "beanouts", "BAres", "caos", "oaOut", "oaos", "oain", "bain", "beanin", "baouts", "haouts", "boOut", "hain", "bares", "caouts", "oaout", "yain", "boin", "boout"], "out": ["o", "b", "n", "to", "batch", "null", "oss", "ex", "cos", "res", "OUT", "os", "Out", "ou", "io", "cmd", " os", "client", "outer", "sys", "bo", " bout", "conv", "con", "copy", "ao", "t", " output", " Out", "auto", "gt", "update", "all", " outs", " OUT", "OU", "output", "outs", "stable", "net", "cn", "ne"], "bytes": ["reports", "strings", "frames", "objects", "raw", "words", "classes", "blocks", "services", "data", "parts", "users", "seconds", "lines", "pieces", "gets", "des", "bps", "latest", "cells", "les", "its", "issues", "pdf", "files", "bits", "resources", "ites", "videos", "letters", "results", "tes", "names", "comments", "ings", "versions", "ips", "es", "groups", "binary", "faces", "outs", "ies", "values", "bs", "pages", "unks", "units", "Bytes", "gs", "reads", "terms", "vals", "ones"]}}
{"id1": "20267500", "id2": "22801734", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWapFromString", "getWapfromString", "getWapFromURI", "getWapFromURL", "getWavFromString", "getWapfromUrl", "getWavfromURL", "getWavByURL", "getWavFromUrl", "getWapFromUrl", "getWapfromURL", "getWavByURI", "getWavfromString", "getWavfromURI", "getWapfromURI", "getWavfromUrl", "getWavByString", "getWavByUrl", "getWavFromURI"], "urlstr": ["dlSTR", "strstr", "dlstring", "strstring", "Urlname", "UrlSTR", "URLr", "dlstr", "urlSTR", " urlr", "URLSTR", "URLstr", " urlname", "URLstring", "dlname", " urlstring", "urlr", "urlname", "Urlstr", "Urlstring", " urlSTR", "urlstring", "strSTR", "strr"], "url": ["http", "pl", "web", "l", "ll", "cp", "xml", "address", "h", "q", "rel", "res", "hl", "base", "load", "loc", "open", "char", "f", "str", "ul", "mail", "il", "ssl", "dl", "u", "build", "ur", "nl", "cr", "mount", "con", "https", "URL", "com", "gl", "file", "ml", "Url", "job", "sl", "cl", "host", "cal", "r", "lr", "path", "ls", "uri"], "ais": ["ca", "ac", "ris", "osa", "ua", "bis", "ws", "ei", "lis", "oos", "ami", "isa", "iam", "us", "asio", "aba", "aa", "aci", "aus", "asar", "opus", "ois", "is", "ahi", "aos", "ias", "aer", "ras", "sa", "pai", "asis", "aim", "sam", "wi", "a", " arra", "asia", "acs", "ai", "au", "aida", "auc", "ia", "osi", "ians", "as", "nas", " ain", " ado", "hz", "asi", "asm", "ava", "audi", "AI", "pa"], "c": ["b", "v", "n", "ci", "ca", "ac", "l", "cd", "cp", "lc", "cin", "cos", "dc", "anc", "col", "ct", "f", "cont", "enc", "fc", "conv", "nc", "ch", "co", "cr", "rc", "cb", "con", "cs", "mc", "cur", "ce", "com", "coll", "ctrl", "cl", "bc", "C", "cm", "r", "ec", "cc", "cu", "tc"], "stream": ["m", "v", "in", "data", "chain", "iam", "input", "store", "reader", "io", "is", "open", "form", "f", "row", "cont", "channel", "enc", "context", "sam", "sample", "st", "pipe", "stack", "REAM", "port", "resource", "t", "file", "present", "result", "read", "sl", "console", "content", "Stream", "output", "path", "out", "buffer", "ream", "source"]}}
{"id1": "5998352", "id2": "11377441", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"testStandardTee": [" teststandardTees", " testStandardEette", " testStandardNees", " testStandardMees", " testStandardNe", " testStandardMette", " teststandardTette", " teststandardTe", " testStandardMe", " testStandardNee", " teststandardMe", " testStandardMee", " testStandardEees", " teststandardTee", " testStandardEe", " teststandardMee", " testStandardTe", " testStandardNette", " testStandardEee", " testStandardTees", " teststandardMees", " teststandardMette", " testStandardTette"], "reference": ["report", "print", "link", "operation", "condition", "pointer", "back", "resolution", "use", "address", "function", "specified", "test", "key", "filename", "memory", "re", "string", "directory", "expression", "information", "template", "name", "document", "sequence", "prefix", "description", "attribute", "type", "external", "approximately", "definition", "register", "collection", "alias", "associated", "reverse", "ref", "note", "sample", "title", "section", "example", "request", "position", "word", "search", "value", "internal", "service", "using", "pattern", "library", "argument", "relation", "hello", "see", "message", "relative", "remote", "Reference"], "source": ["operator", "inner", "SOURCE", "target", "input", "ser", "store", "reader", "seed", "username", "template", "base", "sequence", "core", "style", "unit", "sql", "context", "src", "sample", "force", "ource", "copy", "Source", "stream", "iterator", "resource", "file", "from", "service", "format", "loader", "console", "spec", "get", "shell", "buffer", "instance", "select"], "destination1": ["destension1", "Destinator1", "destension2", "destationOne", "destregation1", "destificationOne", "destregationone", "desturationOne", "destinatorName", "destificationone", "Destination01", "destinator01", "destinationone", "destinatorone", "destificationName", "Destinatorone", "destination01", "destregationName", "DestinationName", "desturation2", "destificate1", "destation01", "DestinatorOne", "destificate01", "desturation1", "Destination1", "destensionOne", "destation1", "Destinator01", "destificateOne", "stinationOne", "destinationFirst", "stensionOne", "stination1", "destinationName", "stensionFirst", "destinations2", "destregationOne", "destensionFirst", "destinationOne", "DestinatorName", "Destinationone", "destinatorOne", "destification1", "stinationFirst", "stension2", "desturationFirst", "destinationsFirst", "DestinationOne", "stination2", "destinationsOne", "destinator1", "destinations1", "stension1"], "destination2": ["destinated2", "destension1", " desturation4", "destinate2", "destension2", "destensionB", " destinationB", " destinationtwo", "Destension1", "destinition2", "estinition2", "destinationTwo", " destination4", "destinated52", " desturation2", "estinition3", "estination3", "desturationB", "desturation2", "destinition52", "DestensionTwo", "destinition3", "Destension2", "destinateTwo", "estination52", " desturationB", " desturationtwo", "destendant2", "Destination1", "destination3", "destensiontwo", "destension4", "DestinationTwo", "destinationB", "destinator2", "destensionTwo", "destendantB", "Destination2", "desturation4", "desturationtwo", "destendant4", "destinated3", "destociation2", "destinate1", "destinator52", "destination52", "destination4", "destinationtwo", "destociation1", "estination2", "estinition52", "destociationTwo", "destinator3", "destendanttwo"], "tee": ["seoe", "chee", "peE", "teee", "ieea", "ceee", " teer", "teoe", "seee", "chete", "teer", " teoe", " teea", "pees", "ceer", "ceE", "tete", "cees", "teea", "ieee", "iee", "peoe", " tees", "cheea", "tees", "peer", "teE", " teee", "cheee", "cee", "seE", "iete", "see", " tete", " teE", "peee", "ceoe", "pee"]}}
{"id1": "21488868", "id2": "18782385", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileAsFile", "encodeFiletoFiles", "encodeFileFromDisk", "encodeFileAsStream", "encodeStringToDisk", "encodeStringToFiles", "encodeStringAsFiles", "encodeFileFromStream", "encodeFileToFiles", "encodeFiletoFile", "encodeStringAsFile", "encodeFileToStream", "encodeFiletoDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileFromFile", "encodeFiletoStream", "encodeStringToStream", "encodeStringToFile", "encodeStringAsDisk", "encodeFileAsDisk", "encodeStringAsStream", "encodeFileAsFiles"], "infile": ["outfilename", "inpath", "inputpath", " inbase", " infilename", "outbase", "inputFile", "Inbase", "inbase", " inFile", "Infile", "InFile", "inputfilename", "inputfile", "outpath", "Inpath", "inFile", "outFile", " inpath", "infilename"], "outfile": ["indir", "newfile", "outfilename", "outname", "infp", "toFile", " outfilename", "newfilename", "fromFile", "newFile", "outdir", "todir", "inname", "fromdir", "fromfp", "tofile", "inFile", " outname", "fromfile", "outFile", "outfp", "newname", "tofp", "infilename", " outFile"], "in": ["inf", "conn", "oin", "IN", "it", "inc", "pin", "al", "inner", "cin", "ins", "ro", "input", "re", "ind", "image", "rin", "bin", "im", "up", "In", "inside", "is", "ini", "form", "by", "or", "ar", "amin", "isin", "init", "con", "info", "iter", "nin", "t", "gin", "from", "id", "en", "ain", "get", "inn", "on", "per", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "print", "null", "ex", "oss", "it", "inner", "flush", "res", "OUT", "at", "os", "up", "io", "ou", "Out", "aos", "writer", "fn", "end", "outer", "sys", "co", "write", "ot", "con", "ion", "opt", "t", "file", "gt", "can", "en", "g", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "header", "black", "memory", "paste", "window", "padding", "total", "available", "template", "base", "bone", "button", "table", "sequence", "document", "bar", "attribute", "password", "pad", "buf", "number", "row", "queue", "mem", "phrase", "note", "sample", "buff", "append", "comment", "stack", "info", "column", "block", "library", "variable", "binary", "initial", "view", "message", "temp", "display", "history", "length", "frame", "character"], "read": ["n", "need", "give", " Read", "raw", "print", "push", "skip", "input", "reading", "index", "reader", "ind", "req", "seek", "load", "hold", "open", "Read", "end", "count", "send", "first", "write", "through", "iter", "size", "check", "wait", "connect", "add", "stream", "allow", "range", "start", "READ", "close", "query", "set", "find", "get", "ok", "run", "i", "before", "each", "length", "ready", "reads", "text", "select", "readable", "len"], "success": ["submit", "sufficient", "summary", " Success", "continue", "Success", "condition", "warning", "second", "cess", "city", " succ", "status", " successful", "ccess", "response", "accept", "democracy", "error", "town", "unity", "danger", "please", "commit", "snap", "valid", "first", "safe", "surv", " failure", "ceed", "setup", " okay", "ith", " successes", "primary", "same", "support", "value", "complete", "crit", "successfully", "result", "successful", "release", "ratulations", "good", "photo", "ok", "fail", "done", "positive", "growth"]}}
{"id1": "4778473", "id2": "5676111", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadProproperties", "loadproperties", "loadPropperties", "loadProdates", "initPrperties", "loadprodates", "initProproperties", "initProps", "loadproproperties", "loadProps", "loadPrdates", "initProperties", "initProdates", "initPrproperties", "loadPrproperties", "loadPrperties", "initPrps", "loadPropps", "loadPrps", "loadPropproperties", "initPrdates", "loadPropdates", "loadprops"], "properties": ["reports", "to", "types", "objects", "bugs", "prop", "settings", "policy", "members", "keys", "parts", "property", "options", "posts", "features", "database", "papers", "pro", "details", "people", "sheets", "facts", "tests", "organisms", "rules", "where", "rows", "units", "results", "metadata", "jobs", "names", "changes", "relations", "packages", "beans", "modules", "holders", "notes", "params", "states", "builders", "ps", "projects", "this", "abilities", "perties", "ports", "marks", "comments", "poses", "values", "terms", "prints"], "url": ["browser", "http", "b", "rect", "l", "ll", "rl", "address", "obj", "user", "p", "location", "open", "char", "f", "str", "abs", "ret", "dl", "u", "ref", "build", "ur", "nl", "context", "bel", "mount", "URL", "resource", "file", "service", "loader", "result", "Url", "config", "sl", "kl", "id", "sb", "ls", "uri"]}}
{"id1": "18358467", "id2": "3945236", "code1": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"parseDocument": ["parsePackage", "createPackage", "processPackage", "createRecord", "handleDocument", "processFile", "processRecord", "createDocument", "processDocument", "handleRecord", "handleFile", "handlePackage", "parseFile", "createFile", "parseRecord"], "url": ["browser", "http", "report", "b", "rect", "pl", "link", "web", "l", "ll", "rl", "data", "address", "rel", "download", "el", "string", "location", "image", "name", "loc", "char", "f", "str", "abs", "dl", "ur", "mount", "https", "URL", "resource", "file", "loader", "log", "result", "Url", "job", "sl", "id", "get", "r", "db", "page", "ls", "uri"], "DocumentHandlerException": [" DocumentFilterEx", "DocumenthandlerException", "DocumentHandleException", " DocumentFilterExit", "DocumentFilterException", "DocumentFilterEx", "DocumentHandleStatus", "DocumentHandlerAction", " DocumenthandlerAction", "DocumentListenerException", " DocumenthandlerError", "DocumentHandlerExit", "DocumentListenerAction", "DocumentHandlerError", " DocumentHandlerEx", " DocumentHandlerExit", "DocumenthandlerStatus", "DocumentListenerStatus", "DocumentEngineExit", "DocumentEngineEx", " DocumentHandlerError", "DocumentFilterExit", "DocumentEngineException", "DocumenthandlerError", " DocumenthandlerException", " DocumentFilterException", " DocumentHandlerAction", "DocumentHandleAction", "DocumenthandlerAction", " DocumenthandlerStatus", " DocumentHandlerStatus", "DocumentHandlerStatus", "DocumentListenerError", "DocumentHandlerEx", "DocumentHandleError"], "inputStream": ["InputSteam", "imageSteam", "activeFile", "inputstream", " inputFile", "formStreamer", "contextForm", "inputSource", "outForm", "InputSource", "inputStreamer", "imageStream", "InputStream", "InputFile", "channelstream", "imageForm", " inputSource", "contextstream", "contextSteam", "inputFile", "contextSource", "channelStreamer", "InputForm", " inputForm", "outstream", "channelSteam", "formStream", " inputstream", " inputSteam", "Inputstream", "activeSteam", "inputForm", "activeStream", "outStreamer", "formSteam", "formstream", "outSteam", "outStream", "imagestream", "channelStream", "inputSteam", "activestream", "contextStream"], "extractor": ["exension", "exract", "intraction", "detceptor", "exractor", "Extraction", "extor", "exraction", "intractor", "detract", "exor", "explceptor", "extraction", "explraction", "Extor", "Extension", "extceptor", "Extractor", "Extract", "xtract", "xtraction", "extension", "intor", "detraction", "explractor", "extract", "detractor", "xtor", "Extceptor", "intension", "explract", "xtractor"], "info": ["inf", "report", "INFO", "summary", "entry", "to", "cache", "Info", "time", "detail", "data", "full", "key", "inner", "obj", "res", "util", "index", "information", "status", "state", "about", "unknown", "name", "fo", "area", "admin", "is", "details", "meta", "description", "properties", "type", "basic", "f", "by", "json", "row", "sys", "ret", "auth", "stat", "check", "metadata", "diff", "result", "config", "progress", "id", "success", "def", "update", "good", "conf", "event", "history", "recent", "ti", "i", "txt", "item"], "docSummary": ["docBasic", "collSummary", "dateStatistics", "collSum", "msgDetails", "cmdSum", "txsummary", "maxSummary", "decSum", "maxStatus", "dateDetails", "mkSummary", "mkStatistics", " docsummary", "docSum", "divSummary", "wordDetails", "msgStatistics", "strSum", "dateSum", "goodSummary", "docssummary", "mkMemory", "documentSummary", "collMemory", " docThumbnail", "valsummary", "goodSum", " docAverage", "wordStatistics", "mkDetails", "docSimple", "divAverage", "msgsummary", "mkList", "collList", "wordWide", "docWide", "valSum", " docExecutive", "mkSum", "maxSum", "strDefault", "docDefault", "docDetails", "docMemory", "documentStatistics", "docStatistics", "cmdSummary", "txSummary", "documentBasic", " docDetails", " docSimple", "docThumbnail", "txStatistics", "mksummary", "camSummary", "txDetails", "goodStatistics", "docsSum", "docsummary", "msgWide", "decSummary", "contentSimple", "wordSum", "camThumbnail", "goodAverage", "cmdExecutive", "cmdThumbnail", "maxSimple", "dateBasic", "docStatus", " docMemory", "divStatistics", "strSummary", "contentSummary", "docsDefault", "valDefault", "docsSummary", "decBasic", "camExecutive", "camSum", " docStatistics", "contentSum", "msgSummary", "valSummary", " docSum", "wordsummary", "dateSummary", " docList", "divSum", "msgSum", "contentStatus", "docAverage", "strsummary", "decStatistics", "docExecutive", "documentSum", "wordSummary", "mkWide", "datesummary", "docList", " docStatus"], "authors": ["agents", "strings", "types", "classes", "tags", "members", "users", "papers", "owners", "Investigators", "articles", "people", "ctors", "rers", "authored", "headers", "letters", "writers", "drivers", "names", "books", "workers", "creator", "ors", "ers", "builders", "archives", "comments", "terms"], "contentReader": ["contentParser", "contentWriter", "documentWriter", "summaryParser", "sequenceReader", "summaryWriter", "documentIterator", "documentReader", "contentIterator", "summaryIterator", "sequenceParser", "summaryReader", "sequenceWriter", "sequenceIterator", "documentParser"], "creationDate": ["createTime", "createdNumber", "creationNumber", "generationNumber", "createDate", "createYear", "createdDate", "createNumber", "createdTime", "creationTime", "generationDate", "creationYear", "generationTime", "generationYear", "createdYear"], "keywords": ["skyterms", "skyword", "skyWords", "keyswords", "keysWords", " keytools", "keysterms", "Keywords", " keyWords", "keyword", "Keyword", "KeyWords", " keyword", "keyWords", "keyterms", "defaultwords", "skywords", "keystools", "Keytools", "defaultword", "keysword", "defaultWords", "defaultterms", "keytools"], "modificationDate": ["Modulationdate", "modificationTime", "modulationDays", "modulationDate", "modifierDays", "modulationdate", "modifierdate", "modificationdate", "ModificationDays", "modifierDate", "modionDate", "ModulationDays", "ModificationTime", "ModulationTime", "modionTime", "modificationDays", "ModulationDate", "modionDays", "modulationTime", "modiondate", "ModificationDate", "Modificationdate", "modifierTime"], "title": ["summary", "header", "itles", "key", "filename", "label", "term", "status", "name", "itle", "prefix", "description", "type", "author", "subject", "Title", "section", "version", "metadata", "doi", "format", "value", "heading", "id", "content", "published", "text", "source"]}}
{"id1": "5441579", "id2": "4599372", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"createPseudoUUID": ["createPseudoRandomUID", "createPseudoRandomID", "createPseudoRandomuid", "createPseudoUniqueuid", "createPseudoUUUID", "createPseanUId", "createPseudoUID", "createPseudoUId", "createPseanUID", "createPseanRandomID", "createPseudoUUId", "createPseanRandomuid", "createPseudoUniqueUID", "createPseanUuid", "createPseudoUniqueId", "createPseudoRandomId", "createPseudoUUuid", "createPseanRandomId", "createPseanUUID", "createPseanRandomUID", "createPseudoUuid", "createPseudoUniqueID"], "messageDigest": ["numberDigests", "messageHasester", "messageLocse", "messagedigifier", "messageDigested", "numberDesignist", "messageDester", " messageDigested", "messageDrise", " messagedigment", " messageDesignest", "messageMacest", "messageDesignester", "messageHasests", "messageMacested", "messageDigse", "messageDesignist", "messagedigse", "messagedigest", "messageDigment", "messageDesignest", " messageDiger", "numberDigest", "numberDesignests", "numberDesignest", " messageDigist", " messageDesignester", "messageLocifier", "messageDiger", "messageMacer", "messageDigester", "numberDesignester", "messagedigested", "messagedigester", " messageDigse", "messageDigifier", "messagediger", "messageLocment", "messageMacse", "messageHasist", "messagedigment", "messageDigests", "messageHasest", "messageDigist", "messageDist", " messagedigifier", "messageDests", " messageDesignse", "messageDesignse", " messagedigest", "numberDigester", "messageDriester", "messageDriist", "messageLocest", " messagedigse", " messageDigester", "messageDest", "messageDriest", "messagedigist", " messageDigment", "messageDesignests", " messageDigifier", " messageDesignist", "numberDigist"], "localHost": ["localPort", "localhostServer", "localAddress", " localAddress", "remotehost", "remoteHost", " localPort", " localhost", "LocalPort", "localhost", "Localhost", "LocalAddress", "LocalServer", "remotePort", " localServer", "localhostHost", "localhostPort", "localhosthost", "localServer", "remoteAddress", "LocalHost"], "digestBytes": ["mixestBytes", "digESTBytes", "mixestedBytes", "drivenesterValues", "drivenesterParts", "digesterArgs", "DigestServices", "drivenestBytes", "drivenestParts", "digetbytes", "drivenesterBytes", "digesterResults", " digestedValues", "digestValues", "diggestbytes", "digestedAttributes", "DiggestParts", " digestedbytes", "mixestedServices", "digstServices", "diggestKeys", "diggestExamples", " digestbytes", "digestbytes", "digestedResults", "digestResults", "digstParts", "digestedArgs", "digestedBytes", "drivenesterBs", "diggestBytes", "digestBs", "digetServices", "DiggestBytes", "mixestServices", "digestServices", "diggeBytes", "DiggestServices", "digesterBs", "digesterParts", "digestLinks", "digesterbytes", "mixestedLinks", "digstBytes", "digesterLinks", "mixestbytes", "digestArgs", "digestedBs", "mixestLinks", "digesterBytes", "mixestParts", "digestedValues", " digestParts", "mixestedArgs", "digestedServices", "digistanceExamples", "mixestedbytes", "digestExamples", "diggeParts", "diggeServices", "mixestAttributes", "DigestParts", " digestResults", "mixestArgs", "Diggestbytes", "digetParts", "mixestedParts", "digestParts", "drivenestValues", " digestedBytes", "diggestParts", "digestedLinks", "digESTLinks", "digestAttributes", "mixestedAttributes", "digstAttributes", "digESTArgs", " digestValues", "diggeAttributes", "digetBytes", "digESTValues", "Digestbytes", " digestKeys", "drivenestBs", "digistanceBytes", "DigestBytes", "digestedParts", "digestKeys", "diggestServices", "digestedbytes", " digestArgs", " digestExamples", "digesterValues", "digESTbytes", "digistanceKeys"], "sb": ["pb", "b", "abb", "bj", "sh", "bh", "pg", "bis", "bash", "sbm", "rob", "zb", "lb", "ub", "bt", "stab", "bps", "jp", "rb", "gob", "bp", "sa", "ssl", "sv", "bn", "lp", "src", "sam", "bg", "bf", "sp", "cb", "ib", "sn", "fb", "sf", "obb", "kb", "sth", "gc", "wb", "ctrl", "tn", "sl", "sw", "gb", "bb", "storage", "eb", "sd", "ibl", "nb", "db", "shell", "bs", "sg", "esm", "erb", "SB"]}}
{"id1": "6470716", "id2": "11562173", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 1, "substitutes": {"st": ["d", "sh", "rest", "ld", "ast", "step", "rt", "St", "sty", "ste", "store", "th", "std", "ST", "stri", "ft", "www", "str", "est", "sp", "nd", "sn", "inst", "stream", "sta", "sts", "service", "t", "se", "sm", "start", "ost", "sth", "tt", "sw", "set", "ist", "stable", "ust", "stra"], "url": ["browser", "http", "pl", "rect", "rest", "link", "null", "web", "l", "ll", "html", "address", "rel", "el", "string", "location", "hl", "base", "loc", "li", "cert", "char", "client", "www", "f", "str", "ul", "mail", "abs", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "ch", "bel", "mount", "domain", "URL", "gl", "file", "il", "impl", "Url", "sl", "fl", "cl", "github", "host", "r", "addr", "shell", "ls", "uri"], "fis": ["feis", "fei", "Fois", "fiss", "fier", "xfier", "fliss", "ufis", "xfois", "Fais", "flis", "f\u00eds", "tiss", "ufi", "efi", "fi", "tais", "efis", " fiss", "tis", "xfis", "ef\u00eds", "ufiss", "Fos", "flisl", "ufisl", "fli", "Fier", "feier", "Fiss", "uf\u00eds", "Fis", " fi", " fais", "efiss", "fois", "feois", "tos", " fisl", "fais", "Fi", " f\u00eds", "fisl", "xfi"], "zis": ["zris", "fisi", "ozis", "fiss", "ozits", "czits", " zris", " zisa", "ozes", "ozIs", "zeniss", "zipits", "czisa", " zIs", "czIs", "czis", " zisi", "zenris", " zits", "zenis", "zipis", " zos", "ziss", "zisi", "ozisa", "zits", "zhis", "zes", "zhisin", "zhes", "zisa", "zipIs", "fits", "zIs", " ziss", "zipes", "zenisi", "zipos", "zisin", "zhIs", "ozisin", "zos", "fris", "zipisin"], "entry": ["way", "jar", "link", "list", "null", "record", "source", "key", "jo", "chain", "obj", "index", "system", "entity", "name", "field", "attribute", "card", "form", "char", "line", "cell", "row", "valid", "e", "sp", "comment", "info", "element", "enter", "ce", "be", "word", "existent", "zo", "se", "result", "log", "pattern", "ent", "office", "member", "def", "match", "inter", "fr", "event", "zip", "tmp", "Entry", "de", "out", "or", "ie", "ry", "item", "nt"], "count": ["n", "acc", "code", "batch", "err", "ctr", "num", "amount", "sum", "found", "call", "index", "total", "child", "ind", "base", "c", "name", "len", "char", "ct", "end", "core", "number", "cell", "cont", "ch", "force", "comment", "Count", "iter", "size", "check", "counter", "add", "t", "depth", "last", "start", "read", "max", "ount", "match", "nb", "page", "cc", "length", "buffer", "current", "nt"], "data": ["d", "done", "n", "raw", "batch", "cache", "zero", "step", "dat", " DATA", "chain", "string", "mu", "image", "bin", "name", "area", "table", "number", "json", "DATA", "buf", "ata", "mem", "sample", "bytes", "block", "size", "next", "value", "format", "reason", "result", "part", "def", "all", "good", "output", "message", "out", "length", "buffer", "text", "source"], "fos": ["hoss", "hos", "fioss", "foos", "fol", "fOS", "Foss", "foops", "fiops", "fiol", "woss", "Fol", "fios", "wis", "Fos", "wos", " foss", "Fops", "his", "foss", "wOS", " fOS", "fooss", "fops", "fool", "hOS"], "dest": ["comp", "way", "rest", "comb", "gest", "gate", "cat", "them", "dat", "sum", "test", "target", "desc", "dist", "det", "std", "transfer", "bin", "des", "dc", "loc", "decl", "Dest", "writer", "nom", "cont", "trans", "send", "usr", "mem", "est", "src", "nd", "pipe", "origin", "ptr", "pas", "crit", "master", "result", "exp", "member", "coord", "foreign", "output", "nt", "temp", "out", "done", "parent", "source"]}}
{"id1": "1362", "id2": "2217889", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubargeLess", "bubblesSort", "gobbleCompare", "bubblingLess", "gobblingSort", "gobbleSort", "gobblingCompare", "bubblingCompare", "bubargeSort", "bubblingSort", "bubargeCompare", "bubbleCompare", "bubbleLess", "bubblesLess", "gobblingLess", "gobbleLess", "bubblesCompare"], "a": ["o", "b", "v", "att", "cache", "aka", "ac", "ed", "list", "l", "aaa", "ap", "oa", "data", "alpha", "h", "isa", "el", "window", "na", "aa", "la", "array", "c", "arr", "area", "da", "eas", "trace", "apa", "form", "f", "ab", "aaaa", "sa", "act", "ata", "ma", "ao", "va", "go", "w", "ga", "changes", "am", "ia", "au", "t", "es", "an", "all", "as", "ae", "order", "g", "app", "era", "history", "out", "A", "ea", "z", "p"], "swapped": ["wapping", "scapped", "swapping", "stickaps", "Swaped", " swaps", "waps", "swaped", "snapping", "SWaped", " snap", "stickapped", "Swapping", " snapping", "SWap", "stickaped", " swapping", " snaped", "SWapping", "swaps", "wapped", " snapped", "SWapped", "snapped", "snaps", "stickapping", "waped", "Swap", "scaped", " swap", "Swapped", "scaps", "snaped", "swap", "scapping", " swaped"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "uli", "in", "it", "ji", "ei", "gi", "key", "ami", "chain", "iri", "phi", "us", "index", "ind", "status", "im", "base", "c", "ori", "y", "oi", "ki", "si", "ini", "li", "is", "ii", "io", "iu", "gu", "client", "xi", "f", "bi", "pi", "u", "j", "iso", "x", "me", "init", "origin", "cli", "zi", "ri", "ai", "sim", "t", "mi", "ti", "ix", "hi", "ir", "id", "di", "my", "ic", "I", "ie", "qi", "uri"], "tmp": ["comp", "m", "xy", "cache", "np", "pkg", "test", "perm", "ctx", "obj", "tf", "tg", "attr", "clip", "timeout", "amp", "prefix", "MP", "sup", "nom", "mut", "gm", "orig", "sam", "sp", "cmp", "td", "cur", "managed", "same", "t", "mp", "mk", "result", "pre", "etc", "tt", "emp", "db", "nb", "my", "temp", "lib", "txt", "sq"]}}
{"id1": "886783", "id2": "3266833", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 0, "substitutes": {"doGet": ["handleGet", "doPut", " doget", "DoGet", "DoGET", "Doget", " doGET", "doGET", " doPut", "handleget", "handlePut", "doget", "handleGET", "DoPut"], "lni": ["lini", "rni", "lnis", "lti", "Lnis", "Lti", " lti", "rnis", "slini", "lne", "Lini", " lnis", "Lni", "rne", "Lne", "slne", "rti", " lne", "slni", " lini", "slti"], "itemHandle": ["itemID", " itemH", "Itemhandle", "issueID", "ItemH", "itID", "itHand", "issueHandle", "issuehandle", "itHandle", " itemID", "itemH", " itemhandle", "ItemID", "itemhandle", "ithandle", "itemHand", "issueH", " itemHand", "ItemHandle", "ItemHand"], "packager": ["facenger", "packsaler", " packenger", " packagger", "packaler", " packagers", "packageagers", "packaging", "facaler", "packsenger", "facagger", "packenger", "packsager", " packaging", "packsagers", "packageaging", "packagger", "facager", "packageagger", "packsaging", "packsagger", "packagers", "packageager", " packaler"], "output": ["o", "generated", "print", "absolute", "hidden", "xml", "data", "key", "filename", "target", "label", "input", "string", "location", "directory", "username", "response", "name", "prefix", "error", "ou", "client", "outer", "connection", "unit", "write", "column", "put", "port", "ilo", "written", "format", "file", "handle", "value", "resource", "log", "region", "Output", "OU", "message", "path", "PUT", "page", "display", "buffer", "temp", "text", "current", "source"], "endpoint": ["EndPoint", "beginpoints", "endpt", "endspoints", "endpoints", "ndpt", "endsPoint", "ndpoint", "endPoint", "Endpoints", "ndpoints", "beginpt", "Endpoint", "endspt", "Endpt", "beginpoint", "endspoint", "ndPoint", "beginPoint"], "ProtocolException": ["PrototypeError", "proticationException", "ProtilingError", "protocolWarning", "protocolException", "protocolError", "ProtocolWarning", "ProtilingException", "PrototypeWarning", "ProtilingWarning", "proticationError", "proticationWarning", "PrototypeException", "ProticationException", "ProtocolError", "ProticationWarning", "ProticationError"], "IOException": ["RuntimeException", "NetworkGroup", "NetworkOver", "IOOver", "RuntimeGroup", " IOOver", "IOGroup", "RuntimeOver", " IOGroup", "NetworkException"], "FileNotFoundException": ["FileAlreadyFound ", "FileAlreadyFoundWarning", "FileNotPresentException", "FileAlreadyPresentException", "FileAlreadyPresent ", "FileNotFoundError", "FileNotFound ", "FileNotPresentWarning", "FileNotFoundWarning", "FileAlreadyFoundError", "FileNotPresent ", "FileAlreadyPresentError", "FileAlreadyFoundException", "FileNotPresentError", "FileAlreadyPresentWarning"], "itemURI": ["resourceURL", "itemID", "storeURL", "resourceURI", "ItemURI", "itemURL", "ItemURL", "itemuri", "storeRI", "resourceuri", " itemuri", " itemURL", "storeuri", " itemID", "resourceID", "storeURI", "ItemRI", "ItemID", " itemRI", "itemRI", "Itemuri"], "url": ["browser", "http", "pl", "null", "web", "l", "ll", "html", "rl", "xml", "key", "server", "q", "el", "res", "re", "location", "parser", "term", "base", "name", "loc", "cmd", "char", "client", "f", "str", "ul", "abs", "un", "ssl", "dl", "org", "ref", "build", "ur", "nl", "sql", "bel", "domain", "mount", "con", "URL", "il", "handle", "impl", "gc", "log", "Url", "sl", "kl", "fl", "get", "host", "r", "sb", "this", "path", "ls", "uri"], "conn": ["syn", "org", "att", "gen", "err", "ws", "pg", "cp", "yn", "sys", "socket", "ann", "resp", "canon", "wp", "obj", "ctx", "call", "Conn", "res", "desc", "req", "that", "exec", "msg", "c", "jp", "open", "cert", "cmd", "ct", "client", "comm", "fin", "cont", "cell", "enc", "ssl", "connection", "act", "nc", "ch", "auth", "iw", "subject", "init", "cb", "stat", "con", "compl", "sync", "pas", "cur", "connect", "ctrl", "close", "en", "cfg", "typ", "conf", "db", "addr", "ns", "net", "cn", "conv", "nt"], "status": ["d", "http", "access", "code", "ex", "use", "html", "esp", "magic", "xml", "uses", "server", "resp", "sex", "cgi", "res", "ser", "index", "re", "US", "response", "state", "msg", "login", "name", "prefix", "is", "compliance", "str", "json", "number", "ssl", "wa", "ret", "compl", "stat", "iso", "e", "score", "Status", "st", "STAT", "version", "size", "wait", "sem", "format", " Status", "s", "service", "pres", "result", "es", "fs", "progress", "id", "success", "sc", "current", "sw", "spec", "stats", "atus", "x", "z", "source"], "in": ["inf", "IN", "it", "inc", "xml", "inner", "cin", "body", "ins", "input", "mm", "re", "ind", "dr", "rin", "bin", "im", "up", "inside", "In", "is", "min", "ini", "str", "cont", "isin", "init", "st", "old", "ln", "iter", "irm", "mn", "ai", "gin", "from", "read", "id", "en", "inn", "sin", "r", "on", "din", "i", " din", "source"], "out": ["o", "to", "n", "v", "null", "list", "ex", "oss", "err", "it", "inner", "sum", "cos", "inv", "res", "OUT", "at", "os", "Out", "ou", "io", "cmd", "aos", "writer", "outer", "cont", "sys", "vol", "conv", "ch", "co", "check", "t", "ent", "gt", "set", "all", "en", "g", "good", "outs", "OU", "net", "cn", "ne", "nt"]}}
{"id1": "7044153", "id2": "14324112", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendErrortoClient", "sendExceptionTOServer", "sendExceptionTOHost", "sendExceptiontoClient", "sendExceptionTOClient", "sendErrorToServer", "sendExceptionToClient", "sendErrortoServer", "sendExceptionToHost", "sendExceptiontoServer", "sendErrorToHost", "sendErrorToClient", "sendErrortoHost", "sendExceptiontoHost"], "server": ["v", "code", "null", "address", "test", "site", "ser", "store", "string", "base", "env", "description", "password", "email", "client", "localhost", "ver", "channel", "Server", "serv", "version", "port", "value", "service", "erver", "host", "remote"], "ex": ["nex", "except", "rex", "err", "it", "ception", "Ex", "test", "obj", "el", "wx", "re", "ext", "pex", "one", "ry", "rx", "exc", "xc", "error", "expl", "aux", "eas", "or", "any", "e", "lex", "none", "example", "hex", "com", "Exc", "exp", "tx", "ix", "exit", "an", "exe", "event", "exclusive", "ic", "fail", "x", "EX", "ox", "Exception"], "config": ["cache", "debug", "settings", "figure", "Configuration", "input", "param", "env", "c", "cert", "password", "form", "Config", "ct", "context", "auth", "rc", "fig", "service", "log", "params", "content", "cfg", "conf", "control", "channel", "text"], "prob": ["prbj", "Probe", "probj", "Prob", "probes", " prb", "prbe", " prbes", "Probes", " prbe", "Probj", "probe", "prb", " prbj", "prbes"], "dataSB": ["debugSF", "defSB", "windowSN", "relBB", " dataQB", "joinSF", "dataSW", "ataSN", "ataNB", " dataBP", "cacheBS", "dataSF", "divBS", "contentSN", "relationBS", "valueBB", "imageSN", "ataSL", "imageBP", "jsonSF", "windowSF", " dataSW", "keySL", " dataSN", " dataBW", "ataSR", "dataBW", "dataQB", "cacheBW", "datMB", "mapSB", "defGB", "dataSw", "divNB", "partialSB", "dataHB", "jsonSw", "dataMB", "ataSA", "imageSL", "imageSw", "divBW", "ataSW", " dataRB", "mapBS", "partialGB", "reasonSF", "relationSF", "DATASW", "imageBS", "dataBP", "nextBB", " dataNB", "cachesb", "relationMB", " dataSA", "dateBu", "ataBu", " dataGB", "ataBP", "relBS", " dataHB", "imageSR", "listsb", "dataGB", "keyBS", "contentBS", "DATASB", "contentSR", "joinSB", "dateQB", "relationSB", "joinsb", "windowBS", "keySB", "reasonSB", "nextSB", "listBB", "cacheBB", "cacheSB", "nextBS", "mapSL", "debugRB", "cacheSM", "mapSN", " dataSL", " dataSF", "relSB", "datWB", "reasonSW", "debugBB", " dataSM", "imagesb", "listSF", "relationQB", "datSB", "ataWB", "divSquare", "mapSF", "relationSL", "relationSN", "ataBS", "ataBB", "listSI", "resourcesb", "partialSL", "ataSF", "joinWB", "partialBB", "dataSR", "listMB", "imageSB", "listSB", "relationBB", "DATASF", "debugSB", "dataSM", "divSB", "divSN", "windowSL", " dataBS", "dataWB", "nextSF", " dataSw", "ataSB", "jsonSB", "cacheSF", "resourceSI", "dataBS", "mapGB", "mapHB", "dataSI", " dataSquare", "divSF", "keyBB", "windowSB", "dataSL", "relationNB", "joinSL", " dataSI", "imageSF", "resourceSF", "imageBB", "divBB", "ataEB", " dataEB", "atasb", "contentNB", "valueSB", "ataQB", "datasb", "dataBB", "dataSA", "reasonBS", "dataSN", "jsonsb", "nextQB", "dataSquare", "relationRB", "imageQB", "defQB", "datSL", "cacheSA", "imageSM", " dataBB", "defBB", "dataEB", "contentSB", "imageNB", "dataBu", "resourceSB", "dataNB", "relationBu", "relSW", "DATABS", "relationSquare", "dateBS", "valueSW", " datasb", " dataMB", "imageHB", "ataMB", "dataRB", "listEB", "windowBB", "valueBS", "mapBB", "dateSB", "joinMB", "contentSF", "nextGB"], "trace": ["report", "debug", "batch", "list", "fake", "time", "detail", "tr", "network", "span", "create", "data", "address", "thread", "body", "tty", "test", "chain", "store", "th", "transform", "track", "table", "sequence", "feature", " Trace", "style", "tm", "tile", "sample", "comment", "stack", "ace", "true", "mt", "be", "stream", "te", "profile", "range", "dump", "se", "log", "race", "stable", "role", "message", "history", "temp", "buffer", "frame"]}}
{"id1": "3309233", "id2": "6421904", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doIfBackground", "doInAsync", "doAsAsync", " doIntAsync", " doAsHttp", " doInMemory", " doAsAsync", " doIntMemory", " doIfHttp", " doIntHttp", " doAsBackground", "doInHttp", "doAsBackground", "doInMemory", "doAsHttp", " doInHttp", " doAsMemory", "doAsMemory", " doInAsync", " doIntBackground", " doIfMemory", " doIfAsync"], "params": ["reports", "types", "images", "words", "js", "settings", "tags", "times", "members", "data", "keys", "parts", "pins", "points", "services", "options", "aws", "posts", "lines", "ids", "shape", "details", "properties", "ams", "months", "json", "photos", "vs", "actions", "fixes", "sql", "ms", "ls", "steps", "resources", "results", "names", "xs", "items", "models", "styles", "amps", "stats", "ims", "ps", "pps", "values", "units", "terms", "p"], "param": ["minute", "m", "parse", "conn", "ad", "project", "space", "cp", "num", "perm", "proc", "ctx", "property", "iam", "Param", "meter", "input", "mm", "pm", "aram", "amp", "rem", "min", "admin", "jp", "form", "ams", "pai", "Parameter", "arg", "mem", "prom", "sam", "sp", "dem", "pri", "par", "sem", "resource", "am", "sm", "ram", "power", "config", "member", "set", "vm", "initial", "cm", "conf", "cal", "dm", "option", "pool", "rank", "p"], "client": ["http", "ip", "cache", "conn", "phone", "cp", "server", "city", "call", "system", "Client", "response", "c", "secure", "io", "wrapper", "cmd", "google", "cell", "grid", "channel", "api", "connection", "context", "ch", "co", "con", "cli", "resource", "local", "service", "close", "cl", "console", "cm", "app", "net", "remote", "cn", "tc"], "post": ["submit", "http", "parse", "rest", "follow", "feed", "link", "ld", "create", "install", "body", "wp", " Post", "pass", "process", "req", "mod", " POST", "after", "dd", "form", "pod", "end", "col", "row", "send", "build", "write", "save", "head", "upload", "and", "request", "put", "patch", "next", "add", "pre", "ost", "pp", "read", "tx", "set", "def", "op", "get", "zip", "Post", "POST", "p"], "resp": ["comp", "http", "rest", "pos", "conn", "err", "rex", "esp", "html", "body", "respond", "proc", "obj", "rel", "inv", "res", "desc", "re", "rec", "response", "req", "rep", "status", "rem", "jp", "cmd", "col", "comm", "dl", "sp", "serv", "cb", "cmp", "https", "wait", "soc", "respons", "Response", "Resp", "exp", "cl", "bb", "responsive", "repl", "ess", "bs", "out", "conv"], "entity": ["orm", "entry", "security", "detail", "data", "xml", "body", "obj", "pe", "el", "eme", "Entity", "activity", "response", "ee", "cy", "group", "document", "person", "details", "email", "ity", "json", "enc", "unit", "note", "e", "me", "active", "owner", "info", "ce", "le", "resource", "existent", "se", "ent", "member", "encrypted", "content", "object", "event", "output", "my", "line"], "result": ["report", "summary", "continue", "csv", "detail", "Result", "test", "root", "res", "date", "total", "response", "status", "group", "answer", "table", "sequence", "description", "feature", "currency", "ret", "valid", "comment", "request", "true", "results", "complete", "profile", "successful", "success", "match", "relation", "product", "output", "message", "join", "current"]}}
{"id1": "11840277", "id2": "6301863", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"clearTables": ["clearContiles", "clearSables", "resetTates", "resetTableates", "clearDables", "clearLables", "clearTells", "clearSates", "resetTables", "resetTableashes", "clearTates", "clearLates", "cleartTable", "clearSTable", "clearContables", "cleartables", "clearDates", "cleanTates", "clearLiles", "clearTableashes", "clearLells", "resetTTable", "clearSashes", "clearDiles", "clearTableates", "clearDells", "cleanTables", "resetTableables", "clearContells", "cleartashes", "cleartates", "clearTashes", "clearTableTable", "clearTableables", "clearTiles", "cleanLells", "cleanLates", "cleanLiles", "cleanTells", "resetTableTable", "resetTashes", "clearContates", "cleanLables", "clearTTable", "cleanTiles"], "conn": ["pg", "rel", "Conn", "user", "req", "Connection", "c", "cf", "client", "ont", "ang", "bo", "org", "act", "wd", "nc", "iw", "sys", "con", "pas", "connect", "com", "ds", "n", "ca", "link", "pt", "priv", "ws", "cp", "rt", "h", "ctx", "exec", "open", "cert", "cmd", "die", "comm", "gn", "cb", "forge", "coll", "addr", "pool", "nt", "gate", "oss", "yn", "oc", "resp", "cons", "ct", "enc", "ch", "note", "cur", "close", "en", "conf", "db", "on", "ns", "out", "gen", "lang", "canon", "obj", "yes", "col", "tp", "connection", "co", "mc", "mt", "dn", "ce", "gc", "cfg", "cc", "cn", "conv"], "stmt": [" stmm", " superstmt", "usetry", "stymr", "stdmt", "STm", "astMT", "strm", "astm", "STmm", " superstlamm", "restgr", "startmr", "stymm", "stgt", "startgr", "Stmsg", "estmm", "STlt", "klmt", "STpt", "Stgr", "strmt", " stMT", "ostmm", "STmt", "putmsg", " stlamm", "restmm", "stmr", "astmt", "contlt", "statgt", "Stlt", "stymt", "Stmp", "restlamm", "Stmm", "strpt", "statMT", "estmt", "stm", "Stmr", "startmg", " stm", "STMT", "contmt", "stgr", "stdpt", " stgt", "restMT", "putmg", "statm", "sttry", "Stmg", " stpt", "klMT", "klgr", "StMT", "ostMT", "esttry", "statmt", "ostmr", "stmsg", "restmr", " stmp", "putMT", "strmm", "estmg", "stpt", " stgr", "stmm", "astmr", "stdlamm", "ostmt", " stmr", "stMT", "stmg", "Stm", "ustmt", "restmt", "startmt", "estmsg", "ustm", " superstpt", "useMT", "stlt", "ustmsg", "Stgt", "contMT", " stmg", "stmp", "Stmt", "usemm", "ustmg", "styMT", "usemt", " sttry", "estMT", " stmsg", "putmt", "stlamm", "kllamm", "STmp"]}}
{"id1": "23677142", "id2": "12172485", "code1": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"BubbleSortShort2": ["BubbleSortShortTwo", "BubblesortShortTwo", "BubbleSortIntDouble", "BubblesortIntDouble", "BubblesortShort2", "BubbleSortIntTwo", "BubbleSortShortDouble", "BubblesortShortDouble", "BubbleSortshortDouble", "BubbleSortString4", "BubblesortShort4", "BubbleSortStringDouble", "BubbleSortshort2", "BubblesortInt4", "BubbleSortInt4", "BubbleSortShort4", "BubbleSortString2", "BubbleSortStringTwo", "BubblesortIntTwo", "BubbleSortInt2", "BubblesortInt2", "BubbleSortshortTwo", "BubbleSortshort4"], "num": ["m", "n", "dim", "cache", "zero", "mon", "val", "np", "dat", "alpha", "sum", "test", "missing", "nam", "na", "NUM", "mu", "msg", "im", "uf", "alph", "fn", "form", "comm", "nom", "number", "buf", "img", "tm", "bn", "snap", "rum", "um", "mem", "sam", "note", "save", "cmp", "con", "tim", "old", "hex", "dec", "mun", "check", "info", "mn", "add", "nu", "ums", "mat", "prim", "nm", "om", "coord", "update", "tu", "en", "pn", "get", "cal", "Num", "ver", "net", "txt", "eng", "nt"], "last_exchange": ["last_sexaction", "last_Exchange", "last_EXerence", "last_EXception", "last_Exception", "last_examine", "last_sexamine", "last_exactly", "last_nameamine", "last_xchange", "last_Exerence", "last_exaction", "last_elamine", "last_sexception", "last_pexactly", "last_exerence", "last_exechange", "last_elception", "last_exeception", "last_pexamine", "last_sexactly", "last_exvert", "last_elcessive", "last_xception", "last_elvert", "last_rxchange", "last_rxvert", "last_exevert", "last_xChange", "last_namechange", "last_ExChange", "last_execessive", "last_rxcessive", "last_xerence", "last_sexchange", "last_elaction", "last_EXamine", "last_EXaction", "last_pexception", "last_rxception", "last_nameactly", "last_elchange", "last_exception", "last_nameception", "last_exChange", "last_excessive", "last_EXchange", "last_EXChange", "last_pexchange"], "right_border": ["right_break", "rightflowgap", "rightflowborder", "right_index", "right_gap", " rightflowborder", " right_break", "right_order", "rightPostgap", " rightflowindex", "right_comment", " right_only", " right_order", "rightflowcomment", "rightPostborder", " right_index", "right_only", " right_comment", "rightPostcomment", "rightPostindex", " right_gap", "rightflowindex", " rightflowcomment", " rightflowgap"], "j": ["bj", "it", "ja", "key", "q", "user", "req", "c", "jp", "kj", "jump", "jit", "other", "je", "jl", "ix", "get", " n", "i", "o", "v", "n", "pos", "pt", "index", " J", "im", "jj", "u", "br", " ii", " dj", " Dj", "jen", "jc", "fr", "expr", "kid", " obj", "jack", "oj", "z", "p", "l", "js", "err", "server", "k", "journal", "ind", "f", "note", "og", "aj", "uj", "dj", "jet", "job", "__", "ij", "pr", "jo", "obj", "el", "adj", "jac", "json", "ret", "e", "er", "g", "J", "my", "ji"], "temp": ["kw", "Temp", "acc", "fake", "null", "comb", "dat", "test", "perm", "deg", "attr", "template", "base", "tem", "rem", "mod", " temporary", "porary", " Temp", "mem", "em", "alt", "tim", "fac", "cu", "ptr", "cum", "t", "mp", "dep", "pre", "result", "read", "tt", "unt", " tmp", "emp", "variable", "tmp", "buffer", "tc", "txt", "orig"]}}
{"id1": "15241397", "id2": "15500892", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"doGet": ["handleGet", "doPut", " doget", "DoGet", "DoGET", "Doget", " doGET", "doGET", " doPut", "handleget", "handlePut", "doget", "handleGET", "DoPut"], "request": ["http", "report", "command", "in", "create", "address", "server", "reset", "question", "user", "input", "re", "req", "transform", "document", "quest", "attribute", "the", "client", "first", "connection", "context", "application", "setup", "position", "each", "complete", "Request", "start", "QUEST", "query", "initial", "forward", "get", "hello", "reference", "message", "frame", "current"], "response": ["http", "report", "print", "network", "xml", "session", "resp", "reset", "respond", "body", "server", "site", "res", "onse", "status", "image", "answer", "document", "sequence", "description", "form", "json", "send", "connection", "context", "write", "application", "reply", "version", "position", "ce", "ve", "block", "next", "resource", "service", "Response", "result", "exit", "success", "console", "content", "object", "view", "output", "fire", "message", "page", "frame"], "rewrittenQueryString": ["rewartedQueryString", "rewartedHeaderstring", "rewwrittenQuerystring", "rewrittenHeaderStr", "rewartedHeaderString", "rewrittenQueryStream", "rewrittenqueryStream", "rewrittenQueryQuery", "rewwrittenQueryString", "rewartedHeaderStream", "rewwrittenqueryQuery", "rewartedHeaderStr", "rewrittenquerystring", "rewwrittenQueryStr", "rewrittenURLStream", "rewrittenQuestionString", "rewrittenQuerystring", "rewwrittenQueryQuery", "rewrittenURLStr", "rewrittenURLstring", "rewrittenqueryQuery", "rewliedqueryStream", "rewrittenQustring", "rewliedQueryStream", "rewrittenqueryString", "rewrittenQuStream", "rewliedqueryString", "rewwrittenquerystring", "rewrittenHeaderString", "rewartedQueryStr", "rewrittenCurrentstring", "rewrittenQuString", "rewliedQueryStr", "rewrittenHeaderStream", "rewwrittenqueryString", "rewrittenCurrentStr", "rewrittenHeaderstring", "rewliedQueryString", "rewrittenqueryStr", "rewrittenRequestQuery", "rewartedQuerystring", "rewrittenCurrentString", "rewwrittenqueryStr", "rewrittenRequestStr", "rewrittenQuestionStr", "rewartedQueryStream", "rewrittenRequestString", "rewrittenQueryStr", "rewrittenQuestionStream", "rewrittenRequeststring", "rewrittenQuStr", "rewrittenURLString", "rewliedqueryStr", "rewrittenCurrentQuery"], "rewrittenUrl": ["rewrittenString", "rewriterURL", "RewrittenUr", "rewwrittenURL", "rewartedPosition", "rewartedURL", "rewrapedUr", "rewroteLink", "rewriteUrl", "RewrittenUrl", "rewartedUrl", "RewwrittenLink", "rewrapedUrl", "rewedUr", "rewrittenPosition", "rewittenurl", "rewartedUr", "rewrownUr", "rewadjustedPort", "rewedUrl", "rewwrittenString", "RewrittenString", "rewwrittenUr", "RewrittenPort", "rewedString", "rewrittenURL", "RewwrittenString", "rewriddenPosition", "rewriteUr", "rewriteURL", "rewriteurl", "rewwrittenPosition", "RewwrittenPosition", "rewroteUr", "RewrittenLink", "rewrittenPort", "RewwrittenPort", "RewwrittenURL", "rewartedurl", "RewwrittenUr", "rewrittenLink", "rewriterString", "rewittenLink", "rewrapedURL", "rewadjustedUrl", "rewrapedPort", "rewriterUrl", "RewrittenPosition", "rewadjustedUr", "rewrotePosition", "rewedURL", "Rewrittenurl", "rewrownUrl", "rewwrittenUrl", "rewroteURL", "rewwrittenurl", "rewwrittenPort", "rewriddenURL", "rewroteUrl", "rewrittenurl", "rewriddenUrl", "rewroteurl", "rewrownURL", "rewriterUr", "RewwrittenUrl", "rewittenURL", "RewrittenURL", "Rewwrittenurl", "rewadjustedURL", "rewrownPosition", "rewittenUrl", "rewwrittenLink", "rewriddenUr", "rewrittenUr"], "httpURLConnection": ["httpRLApplication", "httpURLControl", " httpURLApplication", "httpSRConnect", "httpFileConnect", "httpRLConnection", " httpUrlconnection", "ttpUrlConnect", " httpURLConnect", " httpUrlConnect", "httpSRConnection", "ttpUrlControl", "HttpURLconnection", " httpURLconnection", "httpMLConnection", "HttpUrlconnection", "httpHTTPApplication", "httpUrlConnect", "ttpUrlConnection", "httpURLconnection", "httpSRControl", "HttpURLConnect", "httpMLConnect", "httpURLConn", "ttpURLConnect", "httpURLApplication", "httpFileApplication", "httpMLApplication", "ttpURLControl", "ttpUrlconnection", "httpUrlControl", "HttpUrlConnection", "HttpHTTPConfiguration", "HttpURLApplication", "httpUrlConfiguration", "HttpURLConnection", "httpUrlApplication", "ttpURLConn", "HttpHTTPconnection", "HttpHTTPApplication", "httpHTTPControl", "httpUrlConnection", "httpRLConnect", "httpUrlconnection", "httpHTTPConn", "httpFileConn", "httpHTTPConfiguration", "ttpUrlApplication", "httpURLConnect", "ttpURLconnection", "httpHTTPConnect", "httpUrlConn", "httpSRApplication", " httpUrlApplication", "httpSRconnection", "HttpHTTPConnect", "httpSRConfiguration", "httpURLConfiguration", "ttpUrlConn", "httpHTTPconnection", "ttpURLConnection", "httpHTTPConnection", "httpMLconnection", "httpFileConnection", " httpUrlConnection", "HttpHTTPConnection", "HttpUrlConnect", "httpRLconnection", "HttpURLConfiguration", "ttpURLApplication"], "header": ["rule", "hidden", "detail", "policy", "operator", "Header", "address", "h", "filter", "hash", "user", "padding", "term", "dr", "status", "holder", "token", "state", "field", "prefix", "wrapper", "meta", "attribute", "handler", "feature", "client", "layer", "core", "device", "ter", "init", "head", "comment", "section", "column", "version", "title", "info", "block", "er", "peer", "zone", "check", "metadata", "port", "format", "handle", "heading", "argument", "part", "query", "variable", "relation", "component", "event", "headers", "option", "tag", "page", "shift", "buffer", "line"], "value": ["entry", "v", "val", "record", "create", "data", "key", "server", "address", "test", "hash", "property", "label", "string", "expression", "des", "name", "field", "sequence", "language", "attribute", "description", "password", "email", "ue", "text", "json", "VALUE", "pair", "sv", "unit", "sample", "save", "comment", "example", "version", "element", "vector", "zone", "format", "Value", "job", "content", "hello", "see", "default", "values", "message", "instance", "current", "python"], "inputStream": ["inputstream", "InputLoop", " inputThread", " inputLoop", "InputStream", "inputThread", "outputSteam", "outputView", "outputLoop", "errorWindow", "outputThread", "InputThread", "inputLoop", "outputstream", "InputView", " inputstream", "errorSteam", " inputSteam", "inputWindow", "inputView", "errorstream", " inputWindow", "inputSteam", " inputView", "outputWindow", "errorStream"], "outputStream": ["inputstream", "outputLength", "OutputStream", "OutputSteam", "responseStream", " outputForm", "displaystream", "responseForm", "outputSteam", "outputView", " outputView", "displayView", " outputSteam", " outputstream", "responseSteam", "outputstream", "outputForm", " outputLength", "displaySteam", "inputView", "OutputForm", "inputSteam", "OutputLength", "displayStream", "responseLength"]}}
{"id1": "12236729", "id2": "22993368", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": [" Copy", " duplicate", " append", " dup", " operate", "cp", "paste", " replicate", "Copy", " restore", "transfer", " seek", " upload", " recover", " cp", " delete", " merge", " cat", " combine", " move", " parallel", " clone", "read", " download", " join", " transfer", " copying", " paste"], "inputFile": ["inputPath", "argumentfile", "argumentPath", "inile", "inputile", "configfile", "outputPath", " inputile", "inputPost", "outputile", "inputDir", " inputPath", "configFile", "inputfile", "inPath", "inDir", "outputDir", "argumentFile", " inputfile", "configPost", "configPath", "argumentPost", " inputDir", "inFile", " inputPost"], "outputFile": ["outDir", "inputPath", "targetDir", "outfile", "outputPlace", " outputPlace", " outputFilename", "outputPath", "outFilename", "outputFilename", "inputDir", "outPath", "targetFile", "outPlace", "inputfile", " outputDir", "outputDir", "targetPath", "outputfile", "targetfile", "writePlace", "writeFilename", "writeFile", "outFile", "writeDir"], "in": ["inf", "IN", "inc", "it", "al", "inner", "cin", "ins", "input", "reader", "ind", "rin", "ir", "bin", "min", "up", "inside", "is", "In", "ini", "ze", "isin", "init", "con", "old", "info", "iter", "ri", "ai", "gin", "from", "read", "all", "en", "inn", "per", "sin", "on", "ic", "i", "din", " din"], "out": ["o", "n", "to", "cache", "v", "null", "dis", "print", "ex", "it", "flush", "cos", "obj", "user", "res", "OUT", "at", "one", "os", "ou", "Out", "io", "aos", "writer", "client", "by", "end", "outer", "sys", "co", "write", "ot", "con", "check", "log", "auto", "can", "en", "g", "output", "outs", "on", "net", "cn", "ne", "nt"], "c": ["d", "v", "n", "cache", "code", "ac", "l", "cd", "cp", "lc", "k", "chain", "cos", "arc", "cf", "char", "ct", "uc", "f", "cont", "count", "u", "rc", "ch", "nc", "cr", "cap", "cb", "con", "unc", "cu", "cs", "mc", "ce", "pc", "t", "gc", "cod", "current", "cl", "bc", "C", "cm", "conf", "r", "ec", "cc", "x", "i", "character", "z"]}}
{"id1": "9099457", "id2": "21827619", "code1": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"hash": ["shadow", "print", "code", "link", "address", "sum", "h", "key", "index", "string", "name", "type", "Hash", "str", "sign", "hex", "check", "format", "dump", "id", "update", "component", "message", "tag", " hashing", "text", "uri"], "value": ["tree", "v", "raw", "null", "val", "data", "key", "test", "label", "input", "string", "expression", "name", "sequence", "document", "description", "attribute", "type", "password", "language", "python", "json", "VALUE", "sample", "title", "example", "version", "position", "vector", "word", "now", "result", "Value", "current", "variable", "content", "object", "hello", "output", "values", "message", "this", "text", "select", "item", "source"], "md": ["d", "m", "amd", "mg", " cmd", "ad", "ld", " sd", "pt", "mand", "strong", "bd", "pd", "h", "hd", "grad", "MD", "mm", "det", "od", "ind", "pm", "msg", " mc", "mod", "down", "cmd", "dd", "red", "der", "df", "gm", " sm", "met", " dd", "sam", "ms", "dir", "and", "td", " rm", "mn", "add", "ke", "rm", "mk", "sm", "sd", "dm", "di", "mb", "de", "nt"], "md5hash": [" md5sha", "md50print", "md2Hash", "md5hex", "md45sha", "md45hex", "md3sha", " md5hex", "md50cache", "md3print", " md3print", "md4hash", "MD5sum", "md4Hash", " md5sum", " md5cache", "md7Hash", "md2print", "md2hex", "md7hash", "md45sum", "md7sum", "MD2hash", "MD2Hash", "md3cache", "md2sha", "md2hash", "MD5Hash", "md5h", "md50sum", "md3hash", "md7h", " md3hash", " md5print", "md50hash", "md5Hash", "MD2sum", "md4sum", "md3sum", "md5cache", "MD2h", " md3hex", "MD5h", " md3sha", "md2sum", "md4h", "md5print", "md2h", "md2cache", "MD5hash", "md45hash", " md3sum", "md3hex", "md5sha", " md3cache", "md5sum"]}}
{"id1": "3731077", "id2": "8625346", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " cpfile", "copyfile", " cpFiles", "copyFiles", "downloadDirectory", "downloadFile", "CopyDirectory", " cpFile", "downloadFiles", "Copyfile", "copyDirectory", "CopyFile", " cpDirectory", "downloadfile"], "from": ["link", "html", "data", "without", "reset", "star", "input", "string", "what", "term", "at", "base", "name", "pro", "form", "by", "f", "From", "un", "str", "s", "org", "vol", "so", "por", "st", "old", "info", "origin", "with", "add", "url", "bean", "rom", "range", "se", "local", "start", "file", "before", "config", "part", "original", "query", "as", "fr", "view", "of", "db", "ol", "path", "a", "or", "orig", "source"], "to": ["o", "tree", "To", "toc", "null", "pt", "it", "html", "full", "target", "phi", "no", "total", "th", "one", "token", "that", "base", "template", "name", "table", "by", "f", "top", "bo", "into", "org", "oto", "co", "ta", "st", "too", "none", "must", "size", "t", "eto", "te", "file", "auto", "tt", "etc", "tu", "output", "po", "on", "tom", "this", "temp", "two", "dest", "or", "pretty", "TO", "parent", "nt"], "parentDir": ["ParentFile", "Parentdir", "netDir", " parentDirectory", "rootFile", " parentFile", "parentDirectory", "parentFile", "ParentDir", "parentdir", " parentFolder", " parentdir", "netFolder", "masterDir", "masterDirectory", "ParentFolder", "rootdir", "netFile", "masterFile", "rootDir", "masterFolder", "ParentDirectory", "rootFolder", "parentFolder", "netdir"], "in": ["inf", "o", "raw", "print", "IN", "inc", "it", " IN", "al", "xml", "inner", "cin", "ins", "doc", "input", "mm", "re", "ind", "vin", "one", "rin", "bin", "ir", "up", "In", "inside", "ini", "is", "min", "form", "isin", "init", "con", "mc", "irc", "win", "ri", "ma", "gin", "local", "mi", "config", "id", "update", "all", "en", "ain", "get", "conf", "inn", "on", "sin", "net", "din", "i", "source"], "out": ["o", "b", "n", "v", "list", "null", "css", "oss", "it", "ex", "err", "cos", "obj", "ro", "res", "no", "OUT", "na", "at", "one", "c", "os", "Out", "io", "ou", "aos", "cmd", "client", "again", "or", "outer", "sys", "vol", "conv", "co", "write", "ot", "con", "ln", "go", "ion", "t", "file", "gc", "auto", "gt", "can", "all", "op", "g", "output", "outs", "on", "ns", "net", "i", "cn", "ne", "nin", "nt"], "ic": ["tic", "mic", "ci", "ip", "eric", "ac", "it", "inc", "wic", "cin", "ins", "ik", "arc", "c", "icy", "iu", "cus", "ican", "IC", "icon", "fc", "rc", "ric", "co", "ics", "ot", "sic", "pc", "irc", "icc", "isc", "ico", "pic", "ix", "cc", "bc", "aic", "vc", "i", "iac", "cu", "tc", "nic"], "oc": ["osc", "o", "mic", "ci", "ac", "toc", "cot", "oct", "cos", "arc", "oci", "aco", "c", "voc", "cus", "OC", "oe", "anc", "yo", "nc", "ric", "co", "ocon", "mot", "ot", "oco", "unc", "ict", "og", "irc", "pc", "ico", "gc", "soc", "pic", "oca", "alloc", "aic", "roc", "ec", "ocr", "ucc", "vc", "oly", "cu", "tc", "ox", "nic"]}}
{"id1": "5836744", "id2": "9687813", "code1": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"read": ["report", "access", "parse", "print", "show", "create", "data", "test", "download", "buffer", "input", "reading", "index", "reader", "process", "seek", "load", "open", "scan", "write", "stat", "init", "sync", "check", "stream", "connect", "handle", "ready", "READ", "close", "query", "find", "get", "run", "Read", "reads", "readable"], "name": ["n", "search", "code", "link", "null", "named", "create", "Name", "NAME", "data", "address", "key", "filename", "no", "uri", "string", "location", "term", "image", "state", "base", "mod", "prefix", "type", "client", "str", "ref", "mem", "nl", "ame", "sp", "title", "comment", "domain", "old", "info", "version", "ma", "word", "size", "w", "names", "file", "local", "t", "normal", "nm", "start", "value", "part", "id", "order", "event", "default", "on", "path", "message", "parent"], "status": ["ping", "report", "scale", "summary", "access", "print", "v", "continue", "code", "err", "use", "ex", "mode", "uses", "xml", "server", "index", "flag", "US", "dr", "state", "msg", "login", "sequence", "prefix", "error", "details", "description", "type", "char", "str", "json", "ssl", "iso", "stat", "score", "st", "Status", "version", "sync", "cli", "size", "wait", "check", "gl", "complete", "s", "service", "iss", "gc", "format", "result", "handle", "progress", "id", "success", "sc", "console", "update", "exit", "set", "comments", "x", "source"], "url": ["browser", "http", "link", "web", "l", "ll", "html", "pkg", "rl", "rel", "user", "hl", "base", "li", "open", "cert", "char", "client", "www", "f", "str", "ul", "mail", "ssl", "dl", "ref", "build", "ur", "nl", "bel", "mount", "URL", "gl", "service", "log", "Url", "sl", "fl", "cl", "host", "r", "net"], "in": ["m", "IN", "inc", "pin", "al", "inner", "cin", "sum", "body", "ins", "input", "reader", "im", "bin", "rin", "In", "ini", "is", "io", "form", "client", "or", "isin", "serv", "con", "pc", "mc", "ma", "stream", "ai", "file", "gin", "from", "mi", "all", "en", "inn", "i", "out", "din", "source"]}}
{"id1": "23611770", "id2": "23531898", "code1": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"handle": [" encode", " release", " rename", " replay", " operate", " reload", " handler", " repair", " rotation", " roll", " modify", " restore", " accept", " reopen", "rot", " recover", " terminate", " resize", " cleanup", " reset", " rewrite", " move", " resume", " migrate", " restart", " transform", " schedule", " paste"], "srcChannel": ["destConnection", "sourceChannel", "srcChan", "destChan", " srcButton", "sourceButton", "sourceConnection", "destButton", "srcConnection", "sourceChan", " srcChan", " srcConnection", "srcButton"], "destChannel": ["targetChan", "targetConnection", "destChan", " destChan", "srcConnection", "sourceChan", "resultEntry", "resultChan", "DestMember", "targetEntry", "sourceButton", "destConnection", "DestChan", "targetButton", "srcChan", "resultConnection", "targetChannel", "destEntry", " destConnection", "DestConnection", "sourceConnection", "destButton", "DestChannel", "resultChannel", "descChannel", "descConnection", "srcEntry", "destMember", "sourceChannel", "descChan", " destMember", "descMember", "srcButton"], "destOutFile": ["declOutFile", "destInsAll", " destIntFile", "destOUTL", "altZoneDir", "destOUTFILE", "destOutField", "destOutDir", "declOutField", "declOUTField", "startFreeFILE", "destoutPath", "destOutFILE", "startOutFile", "destInRow", "startFreeFile", " destOutPath", "destZoneFile", "altZoneAll", "declOUTL", "createdOUTFile", "destOUTfile", "destExDownload", "destOutL", "startOutFILE", "srcExfile", "destoutile", "createdOUTFILE", " destOutputRow", "createdOUTPath", "srcOutDir", "destIntfile", "destoutKey", "declOUTFile", "destNoFILE", "altOutFile", "createdOutPath", "destZonePoint", "destoutFile", "destOutKey", "destExFile", " destOutKey", "destInfile", " destOutputfile", "destIntPath", "altOutPoint", "srcOutfile", "destOutPoint", "createdOutFILE", "destExFilename", " destOutRow", " destIntfile", "destOutile", "destOutAll", "altZonePoint", " destIntPath", "altOutAll", "destoutFILE", "destFreeile", "createdOutFile", "destExField", "srcExFile", "destFreeFile", "destInFile", "declOutL", "destExDir", "destOutFilename", "destIntFile", "destExPath", "destOutputFile", "destOutputRow", "createdOutDownload", "destOUTFile", "destOutPath", "destIntKey", "destExfile", " destOutfile", "destNoFile", " destIntKey", "altZoneFile", "destNewDownload", "destoutDir", "destNewPath", "destInFilename", "destZoneDir", "destoutfile", "destNoile", "destZoneAll", "destOUTPath", "srcExDir", "destOutfile", "destInsPoint", "destOUTDownload", " destOutputFile", "destNewFile", "srcExFilename", "destOUTField", "destOUTRow", "destExFILE", "destOutDownload", "createdOUTDownload", "startOutile", "destExL", "destFreeFILE", "srcOutFilename", "destOutputfile", "destInsFile", "startFreeile", "altOutDir", "destoutFilename", "destOutRow", "destInDir", "srcOutFile", "destInsDir", "destNewFILE"], "destOutFileCompressed": ["destOutfileCompression", "destOutFileomplied", "destOutFieldZipress", "destOutFileCombured", "destOutFileComponentured", "destOutFieldZiprypted", "destOutFileCondression", "destOutFileExpression", "destOutFileComponentiled", "destOutfilecompured", "destOutfilecompress", "destOutFilenameComponentlied", "destOutfileCompress", "destOutfilecompressed", "destOutFieldCompress", "destOutFileCondosed", "destOutFilecompured", "destOutFileompended", "destOutFilenameComplied", "destOutFileCompended", "destOutFileZipress", "destOutFileompress", "destOutFileCombosed", "destOutFilenameComponentured", "destOutFileComblied", "destOutFilecompression", "destOutFieldComprypted", "destOutFileCombressed", "destOutFilenameComponentressed", "destOutFieldZipressed", "destOutFileComponentression", "destOutFileompressed", "destOutFileZiplied", "destOutFilenameCompured", "destOutFileComposed", "destOutFileCondress", "destOutFileComprypted", "destOutFileHighended", "destOutFileExplied", "destOutFileComponentress", "destOutFilenameComponentiled", "destOutFileExpured", "destOutFileCompress", "destOutFileExpress", "destOutFileComponentosed", "destOutFileZipressed", "destOutFilecompressed", "destOutFileComponentressed", "destOutFilecompress", "destOutFileComponentlied", "destOutFileCompured", "destOutFieldZipression", "destOutFileCompression", "destOutFileExpressed", "destOutFileZipured", "destOutFileHighlied", "destOutfileCompressed", "destOutfileCompured", "destOutFileComplied", "destOutFileCompiled", "destOutfilecompression", "destOutFileHighress", "destOutFileZipiled", "destOutFileExpended", "destOutFileCombiled", "destOutFieldCompressed", "destOutFilenameCompiled", "destOutFileZiprypted", "destOutFileHighressed", "destOutFilenameCompressed", "destOutFieldCompression", "destOutFileCondured", "destOutFileComponentrypted", "destOutFilecomprypted", "destOutFileCombression", "destOutFileZipression", "destOutFileCondressed"], "out": ["o", "n", "to", "batch", "conn", "null", "cache", "l", "oss", "ex", "it", "pos", "full", "cos", "obj", "buffer", "res", "OUT", "at", "one", "timeout", "bin", "c", "os", "ou", "Out", "io", "aos", "writer", "client", "end", "outer", "mem", "ch", "co", "write", "ot", "serv", "con", "opt", "file", "t", "gc", "log", "auto", "result", "can", "all", "g", "output", "db", "outs", "this", "r", "pool", "net", "cn", "conv", "p", "nt"], "in": ["inf", "o", "oin", "IN", "null", "it", "inc", "al", "inner", "cin", "body", "ins", "input", "mm", "reader", "ind", "rin", "bin", "up", "In", "inside", "io", "is", "ini", "ar", "isin", "init", "con", "info", "iter", "ri", "ai", "file", "from", "gin", "read", "en", "conf", "inn", "sin", "on", "r", "ic", "din", "nin", "source"], "buf": ["b", "batch", "code", "cache", "aka", "Buffer", "prop", "err", "cat", "tr", "pkg", "cp", "data", "doc", "obs", "seq", "msg", "bin", "arr", "uf", "rb", "bar", "cmd", "cf", "alph", "bag", "queue", "var", "str", "row", "img", "ret", "conv", "mem", "text", "br", "buff", "box", "cb", "cap", "bytes", "pause", "iter", "block", "vec", "cur", "cv", "map", "log", "result", "tx", "bc", "bl", "db", "tmp", "buffer", "txt"], "len": ["pl", "n", "pos", "val", "l", "err", "ld", "ll", "elt", "h", "el", "seq", "li", "lon", "end", "fin", "il", "count", "nl", "e", "cap", "cmp", "bytes", "lan", "ln", "vec", "iter", "mun", "fun", "le", "t", "coll", "ler", "lf", "part", "Len", "all", "en", "repl", "lib", "length", "ls", "z", "nt"]}}
{"id1": "20924119", "id2": "20128728", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"gzip": ["GZip", "mZip", "marchive", "Gzip", "Garchive", " gZip", "garchive", "Gdef", " garchive", " gdef", "mdef", "mzip", "gdef", "gZip"], "zipout": ["pipein", "pipenet", "gzOut", "zipconn", "gzop", "gzconn", " zipnet", " zipop", "lockconn", "zin", " zipo", "pipeout", "login", "zOut", "gzin", "gzo", "logout", "zipo", "zouts", "zipin", "zipop", "gzout", "zout", " zipin", " zipconn", "zipOut", "locko", "logouts", " zipou", "zipou", "lockop", "znet", "pipeou", "zou", "lockout", "zipnet", "zipouts", "gzouts", "logOut"], "buffer": ["batch", "code", "cache", "Buffer", "command", "header", "data", "memory", "paste", "window", "string", "database", "seed", "limit", "table", "sequence", "document", "button", "attribute", "password", "char", "pad", "buf", "number", "row", "queue", "device", "mem", "phrase", "append", "buff", "sample", "comment", "bytes", "stack", "block", "size", "word", "stream", "result", "variable", "binary", "message", "history", "frame", "line"], "dir": ["d", "rect", "pos", "md", "cd", "pkg", "dat", "direct", "rel", "root", "doc", "desc", "dist", "folder", " directory", "directory", "DIR", "dr", "ind", "self", "det", "ir", "cond", "req", "loc", "dd", "fin", "df", "wd", "dl", "vol", "parent", " Dir", "dra", "div", "draw", "ory", "iter", "cur", " director", "add", "file", "mk", "fd", "del", "part", "def", "db", "tmp", "path", "ord", "out", "Dir", "tree"], "in": ["inf", "oin", "IN", "inc", "ex", "it", "al", "inner", "cin", "ins", "el", "input", "reader", "ind", "rin", "bin", "im", "up", "inside", "In", "is", "ini", "form", "act", "isin", "init", "and", "iter", "win", "ri", "check", "gin", "from", "read", "en", "ain", "inn", "sin", "on", "like", "ic", "out", "din", "i", "source"], "length": ["capacity", "time", "l", "ength", "duration", "data", "angle", "full", "body", "index", "total", "padding", "database", "ind", "available", "distance", "volume", "load", "shape", "sequence", "type", "char", "end", "frequency", "number", "row", "SIZE", "join", "count", "character", "Length", "position", "size", "port", "ENGTH", "impl", "start", "needed", "read", "tail", "match", "hello", "component", "message", "history", "before", "family", "height", "text", "len"]}}
{"id1": "15409512", "id2": "15768167", "code1": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"inFileName": ["inFileSize", "intFileName", " inFileNames", "inFilenameFace", "intFilename", " infileFace", "inFileNames", "inFILEPath", "inFILESource", "inFilenamePath", "inStreamName", "inStreamPath", "inPageNames", "inModelName", " infilePath", "infileNames", "inFilenameSource", "infileSource", "inFilenameName", "infileFace", " infileNames", " inFileSize", "inFILEName", "infileSize", " infileSize", "inFileSource", "inPagename", "intModelSource", "inModelname", " infileName", " inFileFace", "infilePath", "inModelSource", "intFileSource", "intModelNames", "inPageName", "intModelName", "inFilenameNames", "inFileFace", "inFilenameSize", "inFILEFace", "intFileNames", "intModelname", " infileSource", " inFilePath", "inModelNames", "infileName", "inStreamNames", "infilename", " inFileSource", "inFilename", "inStreamSize", "inFilePath", "inPageSource"], "outFileName": ["outFilenameName", "outFileDef", "outFILEName", "outfileDir", "inFileNames", "outfileDef", " outFilePath", "inFileFile", "inFilenameDir", "outFileParent", "outFilePath", "outfileName", "inFilenamePath", "outFILEPath", "outPathDir", "outFILEParent", "outFilenameFile", "infileNames", "outTileName", "outfileNames", " outFilenameParent", "outFilenameDir", "inFilenameName", "outfilePath", "infileFile", "outTileDef", "outTileNames", "outFilenameParent", "outPathNames", "inFileDef", "outfileParent", " outFilenamePath", "outFilenameNames", "outTileFile", " outFileNames", "outFileNames", "outFileFile", "inFilenameNames", "outFileDir", "outPathName", "outFILENames", " outFileParent", "outFilenamePath", " outFilenameNames", " outFilenameName", "infileDef", "infileName", "outfileFile", "outFilenameDef", "outPathPath", "inFileDir", "inFilePath"], "position": ["capacity", "to", "zero", "pos", "command", "condition", "slot", "pointer", "operation", "usage", "resolution", "address", "amount", "memory", "no", "index", "total", "location", "padding", "journal", "expression", "limit", "volume", "seek", "document", "layout", "sequence", "description", "type", "osition", "number", "offset", "connection", "ment", "application", "request", "move", "size", "block", "port", "ion", "POS", "now", "value", "from", "present", "start", "direction", "point", "minimum", "initial", "Position", "see", "relation", "order", "reference", "option", "portion", "length", "buffer", "character", "p", "source"], "bis": ["irs", "ris", "bes", "bh", "js", "oss", "onis", "los", "lis", "pins", "oris", "ubis", "abin", "cgi", "obs", "ubs", "rison", "ais", "bps", "oi", "opus", "is", "fps", "ads", "its", "bi", "phis", "BS", "isin", "idis", "ints", "bits", "ls", "dos", "rots", "ios", "uds", "bil", "avi", "nis", "obb", "iris", "bb", "bid", "bat", "bs", "obos", "conv", "lbs"], "bos": ["bes", "bh", "oss", "los", "pins", "oos", "ubis", "cos", "ths", "obs", "bys", "ubs", "webkit", "aus", "os", "ods", "oks", "tis", "aos", "boards", "ows", "bi", "BS", "eros", "bo", "nos", "dos", "bits", "ols", "ios", "rots", "uds", "tes", "asket", "ippers", "ts", "ats", "oops", "fs", "fits", "jas", "oids", "bs", "ots", "ns", "bones"], "b": ["pb", "d", "v", "m", "batch", "bh", "l", "back", "h", "body", "q", "base", "bin", "c", "B", "bar", "rb", "bp", "f", "ab", "buf", "bit", "j", "ch", "bg", "br", "cb", "ib", "fb", "be", "t", "gb", "bb", "bc", "eb", "g", "nb", "db", "sb", "mb", "bs", "a", "i", "ob", "p"]}}
{"id1": "23672408", "id2": "3197876", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"copyIconFiles": ["copyIconfiles", " copyIconImages", "copyiconfiles", "copyiconImages", " copyiconFiles", " copyiconDocuments", " copyIconfiles", "copyIndexfiles", "copyIconImages", "copyiconFiles", " copyiconImages", "copyIconDocuments", "copyiconDocuments", "copyIndexFiles", "copyIndexDocuments", "copyIndexImages", " copyiconfiles", " copyIconDocuments"], "clazz": [" clbo", "classazz", "clbean", " classe", "relaz", " clotted", "chazz", "CLace", "descazz", "colluster", " cluddy", "claz", "colluddy", "Clbo", "callace", " plaz", "descose", "cluster", "descaz", "Close", "CLoser", " plus", "callaz", " closer", "classotted", "sclbean", "escojure", " claz", "relab", "escace", "scloser", "cluddy", "relose", " plub", "classuddy", "escazz", "crub", "chotted", " club", "plazz", "collazz", "Claz", " clus", "escotted", "sclace", "classe", "pkgazz", "chojure", " clbean", "sclazz", "callbo", "CLazz", "pkgasse", "plasse", "clab", "Clab", "classuster", "clace", "close", "clojure", "club", "clus", " clashed", "pkgashed", "chace", "pkgaz", " clojure", "collotted", "Clace", "plashed", "crus", " plazz", "descab", "clashed", "closer", "clbo", "crazz", "plaz", "Clazz", "craz", "clotted", " cluster", "callazz", "relazz", "CLbean", " clace"], "i16": ["amiShort", "li2016", "iniShort", "i19", "iShort", "iri16", "i6", " i24", "ji150", "i63", "ami19", "i160", "ami16", "ami150", "ji63", "i24", " i2016", "ami63", "pi63", "ii160", "i150", "ini2016", "ini24", "ii16", "li19", "ri16", "i157", " i157", " i160", "ri6", "ami2016", " i6", "ini216", "i216", "ini19", "iri6", "ini160", "ji16", "liShort", "iri2016", " i216", "pi150", "iri157", "ami6", "ri2016", "li16", "ini16", "ri157", "pi16", "pi6", "ji6", "ii24", "i2016", "ii216"], "fileType": ["viewTYPE", "iletype", "policyHandler", "webTYPE", "treeTYPE", "fileTime", "fileTyp", "issuePattern", "ilePattern", "treetype", " fileTyp", "formName", " fileValue", "formType", "fieldTyp", "fileDef", "webType", "coreHandler", "coreDef", "fieldDef", " filePattern", "fieldType", "coreType", "ileType", " fileTYPE", "eventUnit", "ileTyp", "resourceTYPE", " filetype", "viewValue", "fieldTYPE", "policyType", "formatTime", "fileList", "FileName", "filetype", "issuetype", "resourceUnit", "relationHandler", "relationFamily", "resourceFormat", "policyFamily", "formtype", "FileType", "coreTyp", "Filetype", "webDef", "issueType", "treeTime", "fileHandler", "filePattern", "FILEType", "fileValue", " fileTime", "FILEName", "formatTYPE", "fileTYPE", "relationTyp", "formattype", " fileList", "eventTYPE", " fileFormat", "formatType", "formatValue", "issueTyp", "fileUnit", "fileFamily", "webList", "fileName", "viewType", "fileFormat", "treeType", "eventFormat", " fileUnit", "coreFamily", "resourceType", "policyTyp", "viewtype", "FILEtype", "relationType", "eventList", "eventType", "webTyp", "coreTYPE"], "desti16": [" destsi18", "destsi160", "destgi216", "destui2016", "destsi16", "resulti24", "resultii2016", "destsi18", "destui216", "resulti216", "desti24", "destui160", "destsi32", "resultii216", "destui32", "destxi160", "resulti2016", "destgi24", "desti160", "destgi16", "destii2016", "destxi32", " destsi16", "destxi18", "destui18", "destui16", "destxi16", "desti18", "resultii16", "destgi2016", "resulti16", "resultii24", " desti18", "destui24", "desti2016", " destsi160", "desti216", "destii216", "destii16", " destsi32", "destii24", " desti160"], "src": ["comp", "syn", "rest", "bh", "ctr", "pkg", "rl", "inner", "rob", "sec", "proc", "rel", "ctx", "ins", "desc", "ser", "via", "obs", "input", "hl", "std", "req", "rs", "bin", "loc", "iv", "rx", "rb", "scan", "cont", "img", "ssl", "sys", "usr", "sel", "rc", "fc", "nl", "sp", "bg", "st", "cmp", "txt", "cb", "sync", "ln", "sn", "cur", "ptr", "inst", "urg", "cli", "iter", "etc", "sit", "sl", "vr", "sc", "bc", "sol", "isl", "ibl", "sub", "rg", "sb", "tmp", "addr", "dest", "sr", "gs", "ls", "sq", "source"], "dst": [" dest", " dcut", "tgt", "tput", " dmn", "ddmn", "Ddest", "rbl", "ddst", "ngt", " dgt", "rdmt", " dput", "rdest", "dnd", "dddest", "dot", "nnd", "derst", "derdest", "tst", "dsts", "fdest", "dcut", "dsst", "ddnd", "dLot", "dLest", "dLst", " dsts", "dLdest", "fnd", "nput", "rcut", "dLnet", "dnet", "dernd", "tnd", " ddest", "dLbl", "dLcut", "dermn", "ddest", "dsnet", " dnet", "dbl", "dgt", " dbl", "ndst", "nst", "Dst", "ndmt", "rdst", "rst", " dmt", "ndest", "dmt", "dmn", "ndsts", "rdsts", "dsest", "Dnd", " dot", " dnd", " ddr", "dsot", "Ddr", "dest", "dput", "ddr", "fst", "fdr"], "i32": ["pi34", "ip34", "i31", " i86", "ic31", "i22", "i48", "xi32", "i86", "ii342", "ip64", "isi32", " i28", "ii32", "i64", "i342", " i342", "ic86", "ic342", " i34", " i31", "i40", "isi86", "xi22", " i40", "ini22", "i28", "ii28", "ip31", "pi64", "ic22", "ii34", "isi64", "ic48", "pi32", "ini31", " i64", "xi31", "ic34", "ic32", "ic28", "pi31", "ic40", "ic64", "ini48", "isi40", "xi48", "i34", "ip32", "ini32"], "desti32": ["targetpi32", "Desti256", "destI31", "targetpi31", "desti34", "desti90", "DestI31", "destpi30", "targeti34", "targeti31", "targetpi30", "DestI32", "destdi32", "Desti90", "destpi31", "destic34", "desti30", "destu90", "destI256", "DestI90", "destic31", "DestI256", "targeti30", "destpi32", "destu32", "targeti32", "destic32", "destI90", "destdi31", "desti31", "destI32", "destu31", "destdi30", "destic30", "Desti31", "destdi34", "destpi34", "Desti32", "destu256", "targetpi34", "desti256"]}}
{"id1": "21092340", "id2": "421042", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addToArchive": ["addToZipZip", "addInArchFile", "addInArchiver", "addToZipiver", "addToHarZip", "addToArchiver", "addInArchive", "addToExZip", "addToArchZip", "addInHarZip", "addToHariver", "addToHarive", "addInArchZip", "addToArchFile", "addToZipive", "addToExiver", "addInHarFile", "addInHarive", "addInHariver", "addToHarFile", "addToExFile", "addToExive", "addToZipFile"], "pod": ["report", "disk", "ad", "project", "policy", "pkg", "cp", "body", "wp", "proc", "post", "od", "volume", "pick", "table", "ods", "pack", "pad", "device", "top", "module", "pc", "Pod", "task", "check", "zone", "start", "job", "point", "spec", "op", "component", "ack", "poll", "message", "archive", "p"], "podArchiveOutputStream": ["podArchiverInputStream", "podArchiveInputSteam", "podArchiveOutputSync", "podArchiveStreamSync", "podArchiveInputForm", "podArchiverInputSync", "podArchiveInputMap", "podArchiveInputStreamer", "podArchiveEntryPoint", "podArchiveOutputstream", "podArchiveResourcestream", "podArchiveResourceContext", "podArchiveInputContext", "podArchiveOutputContext", "podArchiveoutputStream", "podArchiveOUStream", "podArchiveInputstream", "podArchiveMainStream", "podArchiveResourceSteam", "podArchiveMainSteam", "podArchiveMainForm", "podArchiveOutstream", "podArchiveOUForm", "podArchiveStreamForm", "podArchiverOutputstream", "podArchiverInputMap", "podArchiveStreamStream", "podArchiverInputPoint", "podArchiveResourceStream", "podArchiveoutputForm", "podArchiveStreamMap", "podArchiverOutputStreamer", "podArchiveOutContext", "podArchiveOUSync", "podArchiverOutputForm", "podArchiveOutputSteam", "podArchiverOutputContext", "podArchiverOutputSteam", "podArchiveInputStream", "podArchiveOUMap", "podArchiverInputSteam", "podArchiveEntryStream", "podArchiverOutputPoint", "podArchiveOutputForm", "podArchiveoutputSteam", "podArchiveOutputStreamer", "podArchiverOutputStream", "podArchiverInputstream", "podArchiverInputContext", "podArchiveOutputMap", "podArchiverOutputMap", "podArchiveInputPoint", "podArchiveInputSync", "podArchiverInputStreamer", "podArchiveOutputPoint", "podArchiveMainStreamer", "podArchiveOutPoint", "podArchiverInputForm", "podArchiverOutputSync", "podArchiveOutStream", "podArchiveoutputStreamer", "podArchiveOutSteam", "podArchiveEntrySteam"], "filename": ["ename", "key", "NAME", "folder", "string", "location", "directory", "username", "p", "name", "prefix", "FILE", "description", "fn", "latest", "fil", "Filename", "fp", "subject", "ame", "title", "jpg", "upload", "version", "println", "url", "names", "file", "resource", "original", "nm", "nil", "kl", "release", "FN", "binary", "output", "png", "path", "message", "stem", "family", "archive", "txt", "uri"], "source": ["use", "inner", "SOURCE", "body", "proc", "address", "ser", "store", "input", "seed", "image", "template", "sequence", "password", "style", "sql", "context", "src", "sample", "force", "ource", "copy", "info", "Source", "stream", "iterator", "resource", "file", "from", "service", "series", "loader", "start", "spec", "get", "supp", "component", "view", "shell", "select"], "entry": ["link", "record", "book", "data", "key", "obj", "system", "quick", "attribute", "card", "char", "line", "sheet", "row", "cell", "connection", "ment", "cue", "comment", "element", "ace", "enter", "ce", "task", "word", "resource", "file", "se", "log", "ent", "job", "set", "query", "component", "good", "zip", "tmp", "Entry", "channel", "or", "archive", "ie", "ry", "nt"]}}
{"id1": "10451698", "id2": "9347451", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"copy": ["link", "continue", "cat", "cp", "create", "cop", "perm", "download", "paste", "Copy", "pixel", "clip", "transfer", "split", "remove", "core", "export", "write", "co", "move", "clone", "sync", "proxy", "file", "crop", "gc", "map", "opy", "zip", "delete", "Cop", "slice", "share", "archive"], "source": ["http", "entry", "raw", "cache", "null", "in", "use", "space", "create", "inner", "SOURCE", "body", "site", "target", "store", "instance", "index", "directory", "image", "status", "template", "base", "name", "table", "secure", "details", "style", "subject", "class", "unit", "sql", "src", "scope", "note", "init", "sp", "none", "force", "ource", "origin", "Source", "size", "ce", "resource", "file", "from", "service", "local", "se", "original", "start", "config", "sit", "query", "spec", "get", "empty", "shell", "sin", "remote", "ie", "current", "parent"], "destinationDirectory": ["destinationApplication", "identinatorInternal", "destationApplication", " destinationFolder", "targetinationdirectory", "destinateApplication", "destationFolder", "targetinationsDir", "targetinationFolder", "destinatorDirectory", "destationDirectory", "identinationDirectory", "destationdirectory", " destinationdirectory", "targetinationsDirectory", "destinatorLocation", "destinedirectory", " destationdirectory", "destineApplication", "targetinationDir", "targetinationsFolder", "destarationInternal", "destinationsdirectory", "destineFolder", "identinatorLocation", "destinationFolder", "identinatorDirectory", " destationFolder", "identinationInternal", "destinationDir", "destinatedirectory", "destarationDirectory", "destinationsFolder", "identinationLocation", "destinationsDirectory", "destmentDir", "destinationsLocation", "destinatorInternal", "targetinationDirectory", "destineDirectory", "destmentFolder", "destmentDirectory", "destinationsInternal", "destinationLocation", " destinationApplication", " destationApplication", "destinationdirectory", "destarationLocation", "destinateDirectory", "targetinationsdirectory", "destinationsDir", "destinationInternal", "destinateFolder", " destationDirectory", "destmentdirectory"], "newDir": [" newDirectory", "NewFile", "newsFile", "newsDirectory", "Newdir", "nextFile", "NewDirectory", "newsdir", "NewRel", "nextDir", " newFolder", " newRel", "newsFolder", "newsDir", "newDirectory", "NewDir", "newFolder", "newRel", "NewFolder", "nextRel", "newdir", "nextdir", " newdir"], "children": ["reports", "objects", "cache", "images", "follow", "apps", "Children", "classes", "blocks", "members", "times", "services", "keys", "users", "uploads", "desc", "child", "lines", "related", "unknown", "ids", "links", "parents", "many", "details", "its", "cont", "when", "may", "files", "his", "resources", "each", "jobs", "names", "gc", "relations", "pres", "groups", "modules", "items", "packages", "ml", "nil", "kids", "these", "bc", "all", "sub", "ren", "projects", "pages", "ports", "stories", "ls"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "batch", "in", "ex", "ji", "it", "gi", "span", "key", "q", "chain", "phi", "us", "index", "base", "im", "y", "oi", "ki", "si", "iq", "li", "is", "ski", "gu", "ini", "iu", "ii", "client", "ie", "io", "xi", "bi", "json", "pi", "j", "u", "um", "x", "ms", "me", "init", "info", "iter", "ri", "ai", "sim", "t", "ti", "mi", "ix", "id", "point", "g", "ims", "di", "my", "ic", "remote", "I", "you", "hi", "qi", "uu"], "newFile": ["createfile", "goodSourceFile", "ewDir", "NewFile", "ewFile", "newsfile", "newSourceFile", "ewLe", "newsFile", "newfile", "nextFile", "createFile", "newLe", "goodfile", "NEWTh", "NEWDir", "nextLe", "NewTh", "nextfile", " newfile", " newSourceFile", "nextDir", "newsGlobal", "NEWFile", " newGlobal", "ewfile", "NEWfile", "newsDir", "NewDir", "createSourceFile", "Newfile", "newGlobal", "goodFile", "newsTh", "createDir", "NewGlobal", "newTh", "goodDir", "NewLe"], "output": ["batch", "print", "web", "network", "enabled", "blue", "four", "body", "response", "monitor", "admin", "document", "io", "open", "writer", "client", "outer", "export", "cut", "text", "connection", "write", "put", "position", "block", "ilo", "out", "next", "stream", "file", "internal", "format", "connect", "result", "auto", "config", "exit", "success", "update", "console", "object", "Output", "message", "display", "net", "pretty", "buffer", "online", "current", "parent"], "input": ["inf", "insert", "ip", "raw", "feed", "in", "it", "inc", "back", "operator", "inner", "unsigned", "buffer", "child", "reader", "image", "exec", "Input", "error", "io", "open", "ahead", "form", "rc", "init", "active", "upload", "info", "iter", "add", "before", "internal", "from", "local", "start", "storage", "initial", "op", "get", "ic", "ink", "out", "current"], "buff": [" buf", "pb", "b", "xx", "batch", "comp", "tab", "cat", "data", "black", "ind", "msg", "seq", "bin", "cond", "hold", "ff", "uf", "cmd", "xff", "buf", "text", "bed", "img", "bo", "mem", "ch", "bf", "bg", "nd", "box", "cb", "bytes", "old", "fb", "printf", "tt", "qq", "gb", "bb", "eb", "uff", "bl", "bound", "nb", "sb", "mb", "bs", "Buff", "buffer", "txt"], "read": ["d", "raw", "print", " Read", "give", "need", "feed", "in", "push", " count", "skip", "q", "test", " write", "buffer", "index", "bind", "reading", "tell", "ind", "seek", "load", "hold", "height", "end", "str", "count", "send", "mem", "write", "and", "old", "iter", "size", "check", "wait", "stream", "add", "before", "t", "handle", "start", "ready", "READ", "config", "query", "set", "en", "find", "get", "hello", "run", "like", "ink", "each", "length", "Read", "reads", "text", "select", "readable", "len"]}}
{"id1": "530882", "id2": "9846843", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewend", "readAndrewWrite", "readAndResend", "readAndrewrite", "readAndRepend", "readAndRewrites", "readAndResrites", "readAndRewWrite", "readAndRewend", "readAndRepWrite", "readAndResWrite", "readAndResrite", "readAndrewrites", "readAndReprites"], "inFile": ["infile", "InFilename", " inFilename", "docFilename", "inPlace", "outfile", "initFile", "INPlace", "iFILE", "inputFile", "inputPlace", "initFace", "inputFace", "iTime", "outFilename", "INFile", "Infile", "docTime", "InFile", "inFILE", "docFile", "initFilename", "iFilename", " infile", "inFace", "initPlace", "INFilename", "inTime", "inputFilename", "INTime", "inFilename", "iFile", "docFILE", "INFace", "INFILE"], "outFile": ["infile", "nameFILE", "checkFile", "outfile", "toFile", "checkFILE", "toFilename", "nameFilename", "checkfile", "toFILE", "checkFilename", "reportfile", "outFilename", " outFILE", "inFILE", "namefile", "reportFILE", "reportFilename", "tofile", " outfile", " outFilename", "outFILE", "reportFile", "nameFile", "inFilename"], "iis": ["diIs", "liis", "IIs", " iiss", "liris", "iIs", "iiss", " iIs", "iIS", "diis", "liisc", "diiss", "iiris", "eIs", "eIS", "Ii", "iiis", "ii", "liIs", " iIS", "eis", "dii", " iisc", " ii", "Iis", "aiis", "aiIs", "aiIS", "iiIs", " iris", "iiisc", "iris", "iisc", "Iiss"], "dcmParser": ["dcomParser", "dpmBuilder", " dpmPar", "dromParser", "dcommParser", "dfmBuilder", "dgrPar", "dcrparser", "DcmReader", "decmReader", "dmReader", " dpmAssistant", "deromReader", " dcmarser", "dcmStatement", "dcmReader", "dromReader", "dromparser", "dromListener", "dcmLoader", "dmmParser", "dpmLoader", "DpmPar", "dcommAssistant", "dmodulePrivate", "dmarser", "dmParser", "dcrParser", "DcmAdapter", "dcrBuilder", "DpmReader", "dcmPrivate", "dpmparser", " dpmReader", "DpmAdapter", "dmmmParser", "Dcmparser", "dpmStatement", "drumReader", " dpmPrivate", "dpcPrivate", " dpmBuilder", "dcmPar", "dfmLoader", "dgrStatement", "dcfStatement", "dmmmAdapter", " dcmLoader", "dpcParser", "DcmPar", "Dpmparser", "drumPar", "dcfReader", "dpmAdapter", " dpmListener", "dcomLoader", " dcmparser", "dgrReader", "DcmBuilder", "deromparser", "dpmAssistant", "deromParser", "drumParser", " dcmListener", "dpmarser", "decmParser", "drumBuilder", " dpmParser", "dmmarser", " dpmparser", "dcomReader", "dgrParser", "dcommReader", "dmoduleParser", " dpmStatement", "dpcReader", "deromarser", "dcmAssistant", " dcmPar", "dcommListener", "dpcAssistant", "dmoduleReader", "DpmBuilder", "dcmAdapter", "dcrReader", "dpmReader", "dfmReader", "dmmmReader", "decmarser", "dcomBuilder", "dpmPar", "dromAssistant", "dpmPrivate", " dcmBuilder", " dcmAssistant", "dpmParser", "dpmListener", "DcmParser", "dmmmparser", "dmoduleAssistant", "dcfPar", "dcmBuilder", " dcmPrivate", "decmparser", "dcmarser", "dmmparser", "dmparser", "dfmParser", " dcmStatement", "dromarser", "dcmListener", "DpmParser", " dpmarser", "dcmparser", " dcmReader", "dmmReader", " dpmLoader", "dcfParser", "dmmAdapter"], "ds": ["d", "ks", "sets", "js", "in", "ws", "DS", "services", "dat", "bd", "data", "pd", "Ds", "hd", "qs", "gd", "dq", "ins", "obs", "rs", "des", "os", "da", "ods", "ss", "hs", "details", "dd", "aos", "ads", "its", "der", "dx", "df", "vs", "sys", "dl", "eps", "sv", "dos", "ys", "dh", "cs", "uds", "eds", " DS", "drivers", "tes", "pers", "xs", "s", " des", "dds", "es", "fs", "sd", "as", "ims", "ps", "db", "outs", "dt", "bs", "ils", "ns", "gs", "ls"], "pdReader": ["tdReader", "ddLoader", "ddRunner", "xdLoader", "pedCar", "ddCar", "pedLoader", "tdParser", "pedReader", "hdWriter", "pdRead", "ddHelper", "pdCar", "pedRunner", "vdWriter", "pdParser", "vdLoader", "vdHelper", "dpLoader", "hdReader", "ddRead", "hdRead", "xdWriter", "ddReader", "vdReader", "dpRunner", "tdRead", "dpReader", "pdHelper", "pdLoader", "ddWriter", "dpCar", "ddParser", "hdParser", "tdWriter", "xdHelper", "pdRunner", "xdReader"], "out": ["cache", "list", "null", "in", "it", "data", "full", "ins", "desc", "msg", "c", "io", "client", "end", "sys", "we", "serv", "con", "go", "w", "t", "gr", "tmp", "o", "n", "to", "raw", "v", "pos", "ex", "inner", "flush", "at", "os", "over", "up", "Out", "cmd", "aos", " err", "cb", "ent", "sw", "id", "output", "pool", "p", "nt", "screen", "conn", "js", "oss", "err", "sum", "OUT", "one", "writer", "str", "ch", "nr", "opt", "s", "all", "en", "outs", "on", "gen", "obj", "inv", "res", "status", "name", "ou", "outer", "co", "log", "auto", "gt", "inter", "cfg", "net", "cn", "conv", "txt"], "dcmEncParam": ["dcmEscNum", "dcmencParam", "dmmencParam", "dcmDecCmd", "dcmEncPar", "dmmEncMsg", "dmmEncPar", "dcmencPar", "dcmencCmd", "dmmencNum", "dcmEncVal", "dmmEncParam", "dmmEncCmd", "dcmEscPar", "dcmEscVal", "dcmEnNum", "dmmEnPar", "dcmDecMsg", "dcmEncNum", "dcmEncCmd", "dmmEnNum", "dcmencMsg", "dmmencCmd", "dcmDecNum", "dcmEnVal", "dcmEnParam", "dcmEncMsg", "dmmencMsg", "dcmEscParam", "dcmencNum", "dmmEncNum", "dmmEnParam", "dmmEncVal", "dcmDecParam", "dcmEnPar"], "pdWriter": ["pdwriter", "dpWrite", "tdWriting", "pcWriting", "PDWriter", "pcwriter", "pidWriting", "pdWrite", "pdWriting", "PDReader", "PDWrite", "pdEditor", "tdWrite", "PDEditor", "tdwriter", "pidwriter", "pcWrite", "pidWriter", "pcWriter", "dpReader", "pidWrite", "dpEditor", "tdWriter", "tdReader", "tdEditor", "dpWriter"]}}
{"id1": "21224967", "id2": "2936678", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"crear": [" necessado", " Creas", " Crear", " executar", " Creada", " necessada", "creada", "creado", " Creado", " executado", " necessar", " executas", "creas", " necessas", " executada"], "result": ["su", "report", "continue", "command", "tr", "duration", "num", "Result", "test", "unique", "res", "user", "date", "total", "process", "status", "sequence", "die", "card", "feature", "currency", "number", "df", "row", "ret", "count", "valid", "rc", "br", "comment", "draw", "true", "results", "ULT", "search", "complete", "value", "integer", "successfully", "diff", "power", "successful", "success", "relation", "order", "event", "run", "r", "conf", "message", "length"], "sql": ["csv", "condition", "ws", "xml", "qs", "pel", "q", "spr", "string", "expression", "ql", "status", "seed", "template", "description", "fn", "cmd", "mail", "dl", "sv", "sel", "nl", "sp", "ls", "serv", "sf", "sq", "url", "s", "sd", "query", "SQL", "params", "quote", "sol", "sb", "db", "join", "select"], "connection": ["to", "link", "conn", "command", "condition", "socket", "pointer", "network", "session", "server", "function", "reset", "computer", " Connection", "statement", "connected", "system", "location", "database", "directory", "response", "Connection", "c", "document", "open", "handler", "writer", "platform", "collection", "client", "engine", "number", "we", "context", "nc", "application", "con", "position", "port", "connect", "ion", "resource", "driver", "library", "created", "creator", "close", "query", "relation", "reference", "pool", "channel", "communication", "character", "current"], "ps": ["ping", "pb", "pr", "pt", "pg", "cp", "pd", "proc", "pe", "pa", "res", "statement", "PS", "rs", "jp", "fps", "fp", "eps", "pi", "sp", "cs", "pas", "ptr", "pers", "mp", "s", "aps", "ts", "gres", "ips", "pp", "Ps", "prep", "po", "pps", "bs", "pse", "ds", "p"]}}
{"id1": "3024970", "id2": "7458833", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamtoInputSteam", "testCopy_inputStreamTooutputFile", "testCopy_inputStreamtoInputStream", "testCopy_inputStreamToInputFile", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamToInputstream", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamToInputStream"], "in": ["inf", "n", "ac", "IN", "l", "it", "al", "xml", "inner", "cin", "h", "q", "ins", "inv", "input", "el", "p", "mm", "doc", "ind", "rin", "bin", "im", "c", "up", "In", "ini", "is", "inside", "io", "scan", "sql", "isin", "init", "con", "copy", "iter", "mc", "ai", "nin", "gin", "from", "mi", "log", "read", "en", "ain", "inn", "sin", "r", "on", "this", "ic", "din", "i", " din", "source"], "baout": ["kain", "abaOut", " baot", " bain", "cain", "caOut", " baend", "baot", "BAout", "caio", "BaOut", "Balog", "caend", "baOut", "BAot", "kaend", "caout", "BAin", "boin", "oaio", "boio", " balog", "kaout", "oaOut", "balog", " baOut", "Baout", "abaot", "baio", "oain", "bain", "BAOut", "baouts", "baend", "boOut", "Baouts", "abain", "abaout", "caouts", "kaOut", "oaout", " baouts", "calog", "boout"], "out": ["o", "b", "n", "to", "list", "null", "oss", "it", "ex", "sum", "obj", "res", "OUT", "at", "up", "Out", "ou", "io", "cmd", "aos", "client", "sys", "co", "serv", "ot", "con", "copy", "check", "t", "log", " Out", "gt", "set", "all", "g", "OU", "output", "gr", "outs", "net", "conv"], "count": ["code", "ctr", "num", "skip", "amount", "sum", "resp", "found", "index", "total", "c", "ct", "number", "N", "Count", "size", "counter", "z", "start", "read", "ount", "id", "nb", "length", "current", "nt"]}}
{"id1": "21182766", "id2": "19113613", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"load": ["parse", "cache", "link", "use", " reload", "Load", "create", "test", "download", "store", "system", "process", "loaded", "define", "name", "open", "pack", "register", "build", "append", "init", "save", "check", "loads", "add", "file", "construct", "dump", "loader", "map", "include", "read", "config", "require", "set", "get"], "propsName": ["prorsFile", "proPSname", " propertiesname", " propertiesFile", " propsFile", "pevsFile", "prorsName", "provsname", "propsname", "proPSStr", "prorsname", "propertiesStr", " propsname", " propertiesStr", "pepsname", "proPSPath", "pevsname", "pevsPath", " propertiesName", "provsFile", "pevsName", "pepsName", "prorsPath", "propsFile", "propsPath", "propertiesName", "proPSName", "propertiesFile", "proPSFile", "provsPath", "provsName", "propertiesname", "pepsFile", " propsStr", "pepsPath", "prorsStr", "propsStr"], "props": ["robps", "preps", "robpt", "prperties", " procs", "scheps", "prcs", "prebes", "provs", "prrs", "prept", "properties", "Prors", "prors", "prpt", " provs", "robperties", " prors", "procs", "propt", "probes", "robbes", "prps", "Props", "schevs", "preperties", "schers", "Provs", " properties", "Procs", "Properties", "prbes", "scheperties"], "url": ["browser", "http", "l", "err", "ll", "rl", "address", "rel", "obj", "user", "location", "loc", "open", "char", "f", "str", "abs", "ul", "ref", "build", "ur", "nl", "context", "mount", "URL", "resource", "file", "service", "loader", "result", "Url", "config", "sl", "gb", "cl", "lr", "sb", "this", "path", "ls", "uri"]}}
{"id1": "21491791", "id2": "22560224", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"run": ["su", "command", "use", "execute", "test", "call", "system", "process", "exec", "name", "cmd", "runs", "un", "running", "unit", "runner", "work", "par", "fun", "Run", "don", "eval", "pre", "exit", "apply"], "input": ["http", "partial", "parse", "print", "feed", "in", "back", "it", "background", "xml", "inner", "address", "data", "hub", "index", "system", "audio", "action", "image", "state", "table", "Input", "io", "form", "client", "json", "cont", "context", " inputs", "active", "upload", "request", "info", "iter", "stream", "file", "from", "local", "internal", "start", "read", "config", "initial", "hello", "view", "history", "before", "out", "text", "select", "readable", "source"], "output": ["o", "generated", "print", "web", "hidden", "command", "network", "header", "data", "four", "target", "filename", "memory", "directory", "response", "image", "admin", "table", "ou", "io", "latest", "oe", "external", "outer", "export", "connection", "write", "column", "put", "block", "port", "ilo", "stream", "format", "file", "log", "result", "config", "exit", "update", "success", "console", "binary", "Output", "net", "display", "out", "you", "text", "source"], "reader": ["entry", "rw", "in", "data", "inner", "Reader", "proc", "controller", "ro", "reading", "system", "parser", "window", "dr", "rar", "rx", "table", "builder", "wrapper", "handler", "client", "worker", "row", "usr", "context", "ter", "owner", "draw", "iter", "manager", "er", "stream", "iterator", "resource", "file", "driver", "loader", "read", "penter", "r", "readable"], "writer": ["rw", "wire", "network", "writing", "server", "adder", "target", "processor", "ser", "store", "window", "holder", "Writer", "builder", "wrapper", "handler", "client", "worker", "outer", "connection", "yard", "ter", "write", "writ", "caster", "draw", "pipe", "riter", "writers", "manager", "word", "println", "w", "iterator", "written", "file", "driver", "service", "handle", "loader", "widget", "creator", "close", "wrote", "storage", "variable", "penter", "player", "out"], "pump": ["pumps", "peump", " pong", " pumper", "pmp", "peumps", "Peter", "Pong", "prump", "Pump", " pamp", " pipe", "peter", " pUMP", " pumps", " pmp", " peter", "camp", "Podge", "deter", "Pmp", "Pamp", "PUMP", "damp", " podge", "podge", "cumper", "pipe", "dumper", "pemp", "Pumps", "psumper", "Pumper", "pamp", "psipe", "pUMP", "dump", "cump", "psamp", "prong", "psump", "cUMP", "pripe", "pumper", "pong", "prodge", "peumper", "Pipe"], "counter": ["timer", "code", "zero", "record", "key", "hash", "controller", "loop", "total", "term", "ounter", "collection", "random", "client", "average", "radius", "peer", "loader", "const", "page", "current", "continue", "time", "inner", "recorded", "amount", "second", "memory", "responsible", "index", "sequence", "description", "currency", "row", "common", "column", "console", "entry", "batch", "walker", "pointer", "unique", "system", "Counter", "clock", "cell", "context", "phrase", "vector", "buster", "encrypted", "message", "history", "parent", "condition", "book", "ctr", "thread", "processor", "card", "frequency", "outer", "number", "seen", "container", "count", "ter", "scope", "comment", "cookie", "created", "conv"], "buffer": ["b", "batch", "Buffer", "command", "header", "data", "key", "address", "uffer", "base", "table", "sequence", "document", "uf", "buf", "row", "queue", "context", "phrase", "buff", "bytes", "block", "vector", "size", "value", "result", "binary", "message", "length", "text", "source"], "off": ["ip", "att", "aff", "pos", "offs", "ap", "oa", "oct", "no", " OFF", "ff", "cmd", "after", "end", "offer", "un", "OFF", "offset", "Off", "hand", "origin", "ow", "now", "fun", "eff", " Off", "set", "def", "op", "of", " offset", "Offset", "before", "art", "shift"], "len": ["pos", "val", "l", "ld", "ll", "elt", "body", "rel", "cond", "lon", "line", "end", "fin", "buf", "enc", "lvl", "offset", "vol", "lp", "compl", "nl", "mem", "bf", "alt", "lan", "bytes", "ln", "vec", "size", "fun", "le", "coll", "eff", "written", "mat", "pent", "wl", "lf", "del", "kl", "Len", "fl", "en", "all", "cl", "lib", "length", "mult", "ls"], "rd": ["d", "rw", "RD", "ld", "cd", "md", "rn", "rt", "rl", "bd", "rh", "adr", "dr", "ind", "rs", "rand", "rb", "rod", "dd", "red", "rc", "cr", "nd", "udd", "dig", "dra", "ptr", "rez", "ri", "mn", "rid", "rr", "ard", "mr", "sd", "ird", "xd", "hr", "R", "r", "lr", "sr"]}}
{"id1": "14783950", "id2": "11477906", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compresswithzip", "composeWithZip", "composeWithzip", "compresswithExt", "compresswithFiles", "compressWithFiles", "compresswithZip", "compressByzip", "composeWithoutzip", "compressWithExt", "compressWithoutzip", "compressWithzip", "compressByExt", "composeWithExt", "composeWithoutFiles", "composeWithFiles", "compressByZip", "compressByFiles", "composeWithoutZip", "compressWithoutZip", "compressWithoutFiles", "composeWithoutExt", "compressWithoutExt"], "fileList": [" fileLIST", "wordList", "fileSet", "fileLIST", "wordLIST", " filelist", " FileSet", " FileCode", "itemNames", "wordIterator", " fileSet", "fileL", " fileL", "itemLock", " fileIterator", "itemList", "fileNames", "pageList", "resourceList", " fileLock", "ileList", "fileCode", "resourceLock", "fileLock", "tileList", "pageLIST", " FileLIST", "pageSet", " fileNames", " fileCode", "tileIterator", "filelist", "pageCode", "tileLIST", "tileSet", "ileL", "wordSet", "resourceNames", "ileLIST", "pageL", " FileList", "ilelist", "fileIterator", "pagelist"], "zipFileName": [" zipfileNames", "zipfileFilename", "zipDirNames", " zipFilePath", "zipDirName", " zipFileNames", "zipilePath", "zipfileName", "zipFilePath", "zipFilename", "zipFilenameName", "zipileName", "zipFilenameNames", "zipilename", "zipFileNames", "zipfileNames", "zFileFilename", "zipDirPath", " zipFileFilename", "zFilename", "zFileName", "zFilenameName", "zipFileFilename", " zipfilePath", "zipFilenamePath", "zipDirFilename", "zFilePath", " zipfileName", "zipFilenameFilename", "zFilenamePath", "zipileFilename", " zipfileFilename", "zipFilenamename", "zipfilePath", "zipfilename", "zFilenameFilename", "zFilenamename"], "fos": ["flOS", "los", "foos", "fOS", "Foss", "flis", "Foos", " foos", "woss", "Fos", "wos", "floos", "lOS", "loss", "foss", "FOS", "lfOS", "flos", "loos", "wOS", "lfos", " fOS", "woos", "lfoos", "lfis"], "zos": ["enos", "iners", "enz", "css", "zero", "bes", "js", "oss", "less", "zar", "los", "ws", "sis", "sbm", "ez", "zb", "hess", "zin", "webkit", "zik", "zag", "os", "ss", "zers", "zer", "eros", "zzle", "zu", "ze", "cz", "za", "rez", "zen", "zon", "zes", "ippers", "zo", "Sax", "es", "ses", "ossus", "zh", "jas", "nz", "iaz", "han", "zan", "rys", "zip", "hz", "ps", "ess", "z", "zi"], "iter": ["ip", "list", "walker", "it", "tr", "ipper", "inner", "fer", "cer", "loop", "ner", "ser", "former", "ator", "kit", "re", "user", "el", "orient", "ee", "ir", "reader", "maker", "vis", "loc", "iv", "is", "li", "Iterator", "its", "izer", "ver", "outer", "valid", "ter", "ger", "where", "ptr", "er", "liter", "iterator", "oper", "coll", "loader", "here", "exp", "train", "inter", "iner", "Iter", "order", "ait", "iver", "i", "gener"], "fileName": ["fileSource", "fileStore", "fieldName", " fileCurrent", "getname", "ilePath", "fileNumber", "fileSet", "fname", " fileStore", "fName", "FileNames", "tableSet", "fieldNAME", " filePath", "ileSet", "ileCurrent", " fileSet", "ileBody", "filename", "localname", "ileNAME", "tablePath", "getSource", "shortname", "fileNames", "ileSource", "ileString", "fileString", "getName", "localName", "ileList", "getStore", " fileString", "localList", "fileBody", "fileNAME", "Filename", " fileSource", "FileName", "ileNumber", "fSource", " fileBody", "ilename", "shortStore", "localNAME", " fileNames", "FilePath", "FileCurrent", "tableName", "fBody", "FileString", "ileName", " filename", "filePath", "fNumber", "fString", " fileNumber", "fNames", "fieldname", "fieldList", "fileCurrent", "shortSource"], "ind": ["d", "pred", "pl", "n", "att", "roll", "Ind", "pos", "ld", "md", "inc", "cd", "num", "dial", "wind", "index", "bind", "seed", "req", "med", "cond", "cand", "ded", "mod", "loc", "red", "count", "j", "nd", "sign", "div", "draw", "td", "ptr", "mind", "inder", "dj", "IND", "ent", "cod", "hend", "find", "typ", "kind", "stick", "inn", "i", "butt"], "shortName": ["quickname", "shortKey", "recentname", " shortname", "fullType", "ShortName", "smallName", "ShortString", "shortname", "recentCode", "quickName", "Shortname", " shortString", "recentFilename", "recentName", "fullString", "smallCode", "ShortFilename", "quickString", "ShortType", "smallFilename", "shortType", "ShortKey", "fullName", " shortKey", "ShortCode", "shortCode", "smallname", "fullname", "shortFilename", " shortType", "quickKey", "shortString"], "fis": [" fIs", "hois", " fris", "cfris", "fIs", "pis", "ufois", "sfIs", "ufis", "hris", "cfis", "FIs", "cfi", "cfois", "ufris", "ufi", "wIs", "fi", "ufIs", "Fris", "wis", "pi", "wi", "his", "wois", "Fis", "sfois", "sfi", "sfis", "pois", "pris", "fois", "fris", "hi"], "buf": ["b", "batch", "aka", "Buffer", "tab", "cat", "tr", "pkg", "buffer", "fam", "mu", "msg", "seq", "bin", "arr", "uf", "bar", "cmd", "rb", "bag", "bed", "var", "img", "ref", "mem", "fg", "br", "buff", "cap", "cb", "box", "bytes", "block", "vec", "fb", "cur", "cv", "wb", "bc", "bl", "db", "Buff", "temp", "conv", "orig", "bus"], "bytesRead": ["bytesNeed", "linesNeed", "linesWritten", " bytesLoad", " bytesWritten", "BytesNeed", "bytesLength", "postsRead", "blocksLoad", " bytesNeed", "usersFind", " bytesWrite", "BytesWritten", "secondsWrite", "secondsWritten", "BytesLength", "usersLoad", "flowsReady", "bytesFind", "flowsLoad", "linesRead", "postsLoad", "secondsRead", " bytesLength", "blocksRead", "postsReady", "blocksWrite", "bytesReady", "flowsRead", "bytesWrite", "postsFind", "linesLength", "usersRead", "bytesLoad", "BytesRead", "secondsLoad", "usersReady", "bytesWritten", "blocksWritten", "flowsFind"]}}
{"id1": "2398448", "id2": "16969205", "code1": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"handleURL": ["checkURL", "handleURI", "HandleURI", "processUR", "processUrl", "handleUR", "handleUrl", "HandleURL", "HandleUrl", "processURL", "HandleUR", "checkUR", "checkUrl", "processURI", "checkURI"], "IOException": ["SecurityError", "SecurityProblem", "ImportError", "ImportException", " IOError", "ImportProblem", "SecurityException", "IOProblem", " IOProblem", "IOError"], "in_map": ["inPronode", "inlaymap", " in_Map", "in_array", "inProarray", " in_list", "in__Map", "in__dict", "in_dict", " in_dict", "out_node", "out_Map", "inlaynode", "in_node", "in__list", "inPromap", "out_array", "inlayarray", "in_Map", "in__map", "inProMap", "in_list", "inlayMap"], "in_str": ["inMemjs", "in_Str", "in_buf", "inMbuf", "inMemStr", "inMstr", "in_js", "inMembr", " in_js", "inMemstr", "in_br", " in_buf", " in_arr", "inMarr", " in_br", "in_arr", " in_Str"], "input": ["submit", "ip", "raw", "batch", "feed", "command", "in", "it", "data", "cin", "q", "image", "unknown", "Input", " Input", "form", "str", "qa", "sample", "active", "request", "add", "pattern", "start", "read", "query", "all", "initial", "get", "hello", "output", "PUT", "history", "out", "buffer", "text", "current", "source"], "conn": ["syn", "ca", "gen", "pos", "js", "pg", "ws", "ld", "cp", "yn", "pkg", "oss", "ann", "dial", "obj", "rel", "call", "Conn", "ctx", "c", "reg", "cho", "open", "cert", "cmd", "col", "client", "ct", "comm", "ens", "fin", "cont", "enc", "org", "connection", "act", "nc", "ch", "co", "init", "cb", "con", "pas", "cur", "nec", "connect", "com", "url", "coll", "soc", "cod", "en", "db", "addr", "ns", "cn", "conv", "ls", "wn", "nt"], "os": ["o", "ks", "ose", "pos", "osa", "oss", "ops", "los", "oa", "oos", "cos", "oses", "obs", "oS", "io", "aos", "Os", "ows", "sys", "nos", "so", "ot", "OS", "ios", "ols", "ys", "s", "bos", "soc", "osi", "ts", "ost", "ps", "ess", "bs", "ns", "out", "si", "oes", "ox", "ros"], "is": ["ip", "ris", "isi", "in", "oss", "bis", "lis", "sis", "isa", "are", "ins", "rs", "ais", "its", "IS", "Is", "sys", "iso", "ms", "ios", "info", "cs", "nis", "ri", "out", "s", "iss", "se", "fs", "iris", "isl", "bs", "i", "isc", "si"], "reader": ["dev", "parse", "in", "her", "rl", "data", "inner", "Reader", "ro", "ser", "rd", "parser", "rar", "via", "dr", "ner", "rs", "rot", "rx", "io", "handler", "writer", "rer", "red", "row", "rc", "runner", "iter", "er", "ri", "stream", "url", "iterator", "rr", "loader", "result", "read", "mr", "fr", "get", "per", "r", "ack", "buffer", "readable"], "s_buf": ["sockwav", "sockbuf", "s_buff", "s_mu", "sptbin", " s2wav", " s_wav", "s_wav", "sfxmu", "sgrbin", "s_var", "sgrbuff", " s_bin", "s2wav", "sfxbuf", " s_cur", " s2buff", "s_cur", " s_buff", " s2buf", "sptvar", " s_mu", " s_var", "sptbuff", "sfxwav", "sockmu", "sockbuff", "sptbuf", "sgrvar", "sfxbuff", "s_bin", "s2buf", "sgrbuf", " s2mu", "s2buff", "s2mu", "s_bag", " s_bag"], "tmp_buf": ["tmp_cur", "tmp_buffer", " tmp_buffer", "same_prop", "tmpPcur", "same_bu", "same_buf", "tmpgrbuf", "tmp_tmp", "tmpgrprop", " tmp_tmp", "sameptbu", " tmp_cur", "sameptbuf", "tmpgrbu", "tmpptbag", "tmpPbuf", "tmpptbu", "tmp_bag", "same_bag", "tmp_uf", "tmpptprop", "tmpgrbag", "tmp_bu", " tmp_uf", "tmp_prop", "sameptbag", "tmpPuf", "tmp_conv", "tmpptbuf", "tmpPconv", "sameptprop", " tmp_conv"], "count": ["report", "n", "acc", "code", "cache", "print", "batch", "cd", "ctr", "num", "span", "more", "amount", "sum", "q", "call", "index", "total", "ind", "cond", "c", "cmd", "len", "char", "ct", "cycle", "core", "CC", "cont", "cell", "number", "ch", "cap", "force", "comment", "Count", "size", "counter", "check", "go", "coll", "add", "z", "start", "max", "read", "const", "ount", "all", "conf", "nb", "cc", "length", "buffer", "current", "nt"], "out_map": ["report_dict", "out_dict", "outingbuf", "outingap", "in_buf", "outingmap", "outverobj", "reportverobj", "reportvermap", "out_Map", "report_map", "out_addr", "to_addr", "to_Map", "report_obj", "to_dict", "out_obj", "reportverdict", "outverdict", "in_ap", "out_ap", "outvermap", "to_map", "out_buf"]}}
{"id1": "11477906", "id2": "2199604", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["readdefaultSettings", "loaddefaultsettings", "loaddefaultSettings", "loaddefaultSetting", "loadDefaultSetting", "loaddefaultValues", "loadDefaultValues", "loadFAULTSetting", "readDefaultValues", "readDefaultSettings", "loadFAULTSettings", "loadDefaultsettings", "readDefaultsettings", "readDefaultSetting", "loadFAULTValues", "readdefaultSetting", "readdefaultValues", "loadFAULTsettings", "readdefaultsettings"], "configFileName": ["configFilenamename", "configFileNames", "configFILEPath", "configFileLocation", "configStreamname", "configPagePath", "configFilenameName", "configFilenameLocation", "configStreamName", "configFilePath", "configFilenameNames", "configfilePath", "confFileNames", "configFILEName", "conffileNames", "confFilename", "configStreamLocation", "configFilenamePath", "conffilePath", "confFilenameName", "configPagename", "confFilePath", "confFileLocation", "configStreamPath", "confFilenamePath", "configfileNames", "configPageNames", "configfileName", "configFILELocation", "configFilename", "conffilename", "confFileName", "configPageName", "configFILEname", "conffileName", "confFilenamename", "confFilenameLocation", "configfilename"], "in": ["inf", "m", "o", "n", "IN", "l", "it", "ad", "al", "inner", "cin", "ins", "doc", "input", "user", "re", "ro", "ind", "rin", "bin", "im", "up", "In", "ini", "is", "ar", "or", "ze", "isin", "e", "init", "con", "info", "mc", "ma", "check", "ai", "t", "gin", "from", "mi", "id", "en", "ain", "run", "inn", "on", "i", "din", "ls", " din", "source"], "out": ["m", "cache", "null", "it", "ins", "user", "io", "client", "sys", "ge", "init", "ot", "con", "w", "t", "file", "ne", "o", "n", "to", "raw", "v", "ex", "store", "at", "os", "over", "up", "Out", "aos", "copy", "une", "handle", "read", "ent", "output", "de", "not", "nt", "oss", "server", "ing", "OUT", "ind", "des", "writer", "off", "check", "port", "can", "all", "en", "OU", "outs", "po", "or", "obj", "are", "res", "ou", "co", "ion", "gc", "log", "auto", "gt", "update", "net", "cn", "conv"]}}
{"id1": "11049257", "id2": "22552318", "code1": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "code2": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"generate": [" Generator", " obfuscates", "generize", " Generate", " obfuscate", " obfuscize", "generator", " obfuscator", "generates", "validator", " Generize", " Generates", "validate", "validize", "validates"], "secure": ["security", "protect", "debug", "conn", "secret", "strong", "server", "sec", "prime", "status", " securely", "client", " insecure", "ie", "sys", "ssl", "sp", "safe", "active", "force", "domain", "sync", "trust", "https", "crypt", "quiet", "confirmed", "close", "query", "encrypted", "nice", " Secure", "stable", "control", "sr", "Secure", "ls"], "sep": ["SEp", "asepc", "asepa", "asep", "aseep", "seq", " elep", "peps", " seep", "sepa", "peq", "SEps", "seps", " elepa", "keps", "sepc", "seep", " eleep", "SEpa", "pep", " sepa", "SEq", "kepa", "kep", " elepc", "pepa", " sepc", "keq"], "messagedigest": ["messagedagester", "messagediffist", "messagediget", "messagedaggest", "messagedissest", "messagedegester", "messagigist", "messagigest", "messributedegest", "messagingeger", "messageger", "messagedeggest", "messageddigest", "messagingegester", "messagedequer", "messageddigist", "messagingeggest", "messagedigerer", "messagedigoener", "messagediggest", "messagegener", "messagediffener", "messagedequest", "messagedigener", "messageddiger", "messagedigergest", "messagingigest", "messageregment", "messagegest", "messagedigoment", "messagediffer", "messagedegest", "messageddigener", "messagedeger", "messagedequment", "messagedagest", "messagedager", "messagiger", "messributedigment", "messagedigerester", "messagedigoer", "messagingegest", "messagedigester", "messagedigoest", "messagigener", "messagediger", "messagegist", "messagerigener", "messributedeget", "messagingiger", "messagedequener", "messagerigest", "messagedissester", "messagedigment", "messagedigoester", "messagedissment", "messageriger", "messributedigest", "messagedegist", "messagedigoet", "messagingiggest", "messageregest", "messagedisset", "messagedegener", "messageregener", "messagereger", "messagedeget", "messagediffest", "messributedegment", "messributedigester", "messagedigist", "messributedegester", "messagedegment", "messagerigment", "messagingigester", "messagedigerest", "messributediget"], "stringbuffer": ["chaintemplate", "stringservice", "librarybuffer", "libraryvector", "stringsequence", "ringattribute", "soundtemplate", " stringtemplate", " stringappend", "bufferqueue", "bufferbuffer", " stringBuffer", "Stringbuffer", " stringdatabase", " stringattribute", "Stringservice", "joinappend", "stringserver", "bufferbuilder", "stringbuilder", "resourcetemplate", "soundvector", " stringdocument", "ringBuffer", "joinbuilder", "joinloader", "commentdocument", "resourcebuff", "soundtable", "joinpage", "bufferloader", "stringvector", " stringsequence", "stringdatabase", "sequenceserver", "buffercommand", "commenttemplate", "ringbuffer", " stringstyle", "soundbuffer", "ringqueue", "chaincommand", " stringpage", "bufferattribute", "sequencebuffer", "chainbuffer", " stringvector", "stringBuffer", "stringattribute", "ringappend", "stringstyle", "stringloader", " stringbuff", "stringcommand", "ringtemplate", "commentbuff", "resourcebuffer", " stringloader", "stringappend", " stringservice", "resourcedocument", "bufferserver", "stringtemplate", "stringtable", "stringbuff", " stringtable", "ringpage", "chainqueue", " stringbuilder", "joinattribute", "sequencedatabase", "Stringsequence", "librarytable", "bufferdatabase", "bufferstyle", "ringservice", "stringdocument", "ringsequence", "stringpage", "sequencestyle", "librarytemplate", " stringserver", "ringcommand", "stringqueue", "joinbuffer", "buffertemplate", "commentbuffer"], "stringbuffer2": ["stringBuffer02", "stringcache32", "stringmodel32", "stringvector32", "statusbuffer52", "stringbuff6", "relationfilter22", "stringqueue2", "statusbuffer\t", "relationfilter3", "stringbatch2", "stringconstTwo", "relationfilter2", "stringqueue1", "stringdirectory15", " stringbatch4", "stringbatch6", "numberbuff2", "storeference14", "stringfilter32", "stringbatch52", "statusbuffer102", "listbuffer2", "stringcell102", "storeference52", "stringlevel2", "stringdirectory22", "relationfilter32", "statusbuffer2", "stringrequest102", " stringbuffer9", "storebuffer52", "stringmodel6", "sequencebuff5", "listbuff4", "stringvector15", "stringbuff5", "storeference2", " stringwindow32", "stringblock1", "numberbuff5", "stringcell52", "stringrecord2", "stringprofile4", " stringmodel4", "listbuff52", " stringbuffer32", "stringblock4", "stringbatch14", "listbufferTwo", " stringblock02", "relationbuffer32", "stringflake2", " stringmodel6", "stringbuf02", "stringdirectory52", "stringBuffer1", "stringconst2", "stringbuff15", "listbuffer32", "stringdirectory9", "relationbuffer3", "numberbuff32", "stringprofile2", " stringmodel32", "statusbatch102", "stringdocument2", "stringrecord4", "stringqueueTwo", "statusbatch\t", "stringrecord02", "stringBuffer4", "stringbatch4", " stringbatch2", "stringbutton102", "stringbuff14", "stringdocument6", "stringbutton2", "listcacheTwo", "stringbuff32", "stringqueue02", " stringblock1", "numberbuffer32", "stringfilter3", "stringBufferTwo", "listbuffer4", "stringbuffer5", "stringdirectory3", "numberbuffer5", "stringwindow182", "numberqueue1", "listcache2", "stringvector9", "stringference102", "listbuff2", " stringbatch14", "stringdirectory2", "stringbufferTwo", "listcache4", "listbuff15", "listcache32", "sequencebuff4", "stringbuffer102", "stringvector182", "stringwindow9", "stringcell\t", "stringmodel2", "stringcell2", "stringvector52", "stringbutton\t", "stringrequest2", "stringcacheTwo", "stringlevel14", "stringbuffer15", "stringbuffer14", "stringwindow32", "stringBuffer2", " stringblock4", "stringbutton52", "statusbatch52", "stringmodel4", "listbuffer52", "numberqueueTwo", "stringfilter2", "stringbatch5", "stringdirectory32", "stringBuffer3", "stringference52", "stringflake32", "stringbuffer182", "stringconst32", "stringvector2", "sequencebuffer2", "storebuffer102", "stringbuffer3", "stringcomment2", " stringbuffer02", "sequencebuffer5", "stringcomment5", "stringblock2", " stringwindow9", "storebuffer2", "statusbatch2", "stringvector4", "stringbatch102", " stringblock2", "relationbuffer22", "stringdocument4", "stringbuf2", "numberqueue2", "stringbuffer52", "stringdirectory4", "numberbufferTwo", "stringbuff4", "sequencebuff2", "stringbuffer22", "storeference102", "stringcomment32", "stringprofileTwo", "stringference14", "stringbuf1", "stringbuffer6", "numberbuffer02", "numberbuffer1", " stringwindow2", "numberbuffer2", "numberqueue02", "stringrecord1", "stringcache6", "stringbuffer02", "stringbuffer4", " stringbuffer4", "stringwindow2", " stringwindow182", "stringbuffer32", "stringrequest14", "stringlevel102", "listbuffer15", " stringbuffer14", "stringrequest52", "stringcache4", "stringbatch\t", "stringbuffer9", "stringdirectory182", "stringBuffer32", "stringconst4", "stringbufTwo", "relationbuffer2", " stringbuffer6", " stringbatch6", "stringblock02", "stringdocument14", "stringflake5", "stringference2", "stringcache5", "stringlevel52", " stringmodel2", "stringfilter22", "stringprofile32", "storebuffer14", "stringcache2", "sequencebuffer4", " stringbuffer182", "stringbuff52", "stringbuff2", "stringBuffer22"], "inetaddress": ["ptonmedia", "socketaddress", "socketchannel", "inetbuffer", "bitcoinmedia", "jsonmedia", "ixAddress", "ixchannel", "socketaddr", "etchannel", "bitcoinaddress", "bitcoinattribute", "etaddress", "inetaddr", "jsonaddress", "ixaddr", "inetAddress", "etaddr", "inetattribute", "jsonattribute", "ixaddress", "inetchannel", "ptonbuffer", "inetmedia", "bitcoinbuffer", "ptonaddress", "etAddress", "ptonattribute", "socketAddress", "jsonbuffer"], "l": ["d", "m", "b", "n", "lt", "ld", "ll", "lc", "lang", "L", "el", "locking", "loc", "li", "dl", "u", "lp", "nl", "ln", "tl", "le", "t", "local", "lit", "g", "r", "left", "x", "ls", "z", "p", "len"], "l1": ["l11", "fl001", "ll0", "fl01", " l11", "lfasso", "l0", "L0", "lock001", "li2", "lc0", "lang2", "lOne", " L2", "lang11", "li0", "L1", "lf01", "li1", "lang1", "lock01", "lav", "lc1", "lcav", "lcau", "lock1", "lf001", "langOne", "lockasso", "fl1", "llav", "lf1", " lOne", "L11", "l001", "lasso", "llau", " l0", " LOne", "ll1", "L2", " lav", "l2", " L1", "lau", "li11", "l01", " l2", " lau", " L11", "flasso"], "abyte0": ["bone0", "abyte1", "byte1", "slice5", "byte5", "bone19", "abyte160", "there0", "binary5", "ano1", " bite19", "abyte19", "gment19", "bone160", "abyteee", "byte9", "ano9", "sliceee", "byteee", "byte6", "gment000", "abyte6", " bite0", "there9", "ano6", "slice0", "abyte9", "ano0", " bite000", "abyte000", "gment0", "there1", "gment160", "there6", " bite160", "binary0", "byte0", "binaryee", "abyte5", "bone000"], "stringbuffer1": ["sqlbank3", "Stringbuffer01", "stringbatch1", "Stringbuffer1", "stringBufferOne", "stringbuf1", "stringbank3", "StringbufferOne", "resourcebuffer1", " stringcache8", "stringBuffer01", "sqlbuffer3", "stringbatch2", "stringbankOne", "stringBuffer2", " stringbuffer3", "stringblock8", "stringBuffer1", "stringbuffer8", "stringbank01", " stringbuffer8", "resourcecache2", "sqlbuffer1", "stringbuffer01", "resourcecache1", "stringbufferOne", "resourcebuffer3", "stringBuffer3", "sqlbuffer2", "stringcache01", "StringBuffer1", "stringcache3", "sqlbuffer01", "resourcebuffer01", "sqlbank2", "stringbuffer3", "stringcache8", " stringcache1", "StringBufferOne", "stringbuff01", " stringcache3", "Stringbuffer2", "sqlbank1", "resourcecache3", "stringbuff1", "sqlbank01", "stringbank1", "stringbuf3", "stringbatch01", "stringbatch3", "stringblock3", "StringBuffer2", "stringbuf8", "stringbatchOne", "stringcache1", "stringblock1", "resourcecache01", "stringcache2", "StringBuffer01", "resourcebuffer2", "stringbuff3", "stringbank2", "stringbuff2"], "i": ["m", "multi", "ip", "v", "ci", "ui", "PI", "print", "ij", "o", "in", "it", "ji", "gi", "ami", "I", "q", "chain", "phi", "us", "uri", "ind", "im", "\u0438", "y", "ki", "ini", "li", "ii", "io", "is", "iq", "ie", "bi", "json", "pi", "u", "me", "init", "info", "cli", "ri", "ai", "mi", "ti", "ix", "id", "di", "ic", "x", "si", "xi", "qi", "zi"], "j": ["ij", "o", "v", "n", "bj", "b", "m", "js", "it", "ja", "k", "q", "obj", "ind", "y", "jp", "kj", "jj", "jump", "json", "bi", "jit", "note", "br", "aj", "dj", "jl", "uj", "nm", "ix", "job", "jc", "g", "J", "x", "oj", "ji", "z", "p"], "s": ["ashes", "m", "b", "n", "v", "js", "less", "qs", "h", "parts", "string", "als", "erences", "rs", "c", "gs", "y", "S", "is", "ss", "hs", "details", "f", "comm", "its", "str", "abs", "ends", "sys", "sv", "sql", "ms", "e", "sample", "bits", "ches", "cs", "t", "sts", "ts", "ings", "ats", "fs", "es", "stats", "ims", "r", "sb", "ps", "bs", "ns", "ds", "ls", "sq", "p"]}}
{"id1": "16931472", "id2": "12172485", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"handler": ["execute", "proc", "controller", "processor", "index", "handled", "accept", "transform", "render", "end", "callback", "Handler", "hook", "received", "init", "request", "handle", "read", "success", "processing", "update", "forward", "output", "Handle", "adapt", "done", "action"], "result": ["report", "cache", "list", "mate", "Result", "full", "data", "hash", "found", "memory", "res", "total", "response", "status", "table", "sequence", "details", "RESULTS", "ret", "met", "valid", "results", "complete", "profile", "map", "created", "master", "successful", "make", "success", "all", "product", "output", "page", "out", "done", "buffer", "current", "source"], "target": ["project", "it", "detail", "pkg", "test", "controller", "tif", "term", "expected", "layout", "jp", "external", "bolt", "type", "top", "iter", "manager", "peer", "proxy", "t", "local", "Target", "component", "page", "source", "report", "to", "link", "self", "template", "base", "transform", "cmd", "style", "version", "task", "next", "handle", "master", "object", "output", "translation", "buffer", "goal", "node", "that", "closure", "subject", "arg", "valid", "info", "prototype", "format", "complete", "internal", "service", "match", "tool", "history", "remote", "parent", "tree", "http", "thread", "window", "name", "table", "trace", "alias", "scope", "e", "arget", "primary", "gt", "trigger", "view", "this", "dest"], "url": ["browser", "http", "link", "web", "l", "ll", "html", "rl", "address", "hub", "rel", "el", "git", "hl", "base", "loc", "cert", "char", "client", "f", "ul", "mail", "ssl", "dl", "connection", "build", "ur", "nl", "bel", "mount", "URL", "file", "service", "impl", "loader", "Url", "sl", "lr", "ls", "uri"], "reader": ["linger", "operator", "rl", "inner", "Reader", "ro", "ner", "reading", "rar", "parser", "uri", "rot", "upper", "older", "builder", "writer", "layer", "row", "context", "review", "runner", "liner", "and", "iter", "er", "cur", "stream", "iterator", "resource", "driver", "rr", "file", "loader", "redo", "read", "buffer", "readable"], "line": ["ip", "rule", "link", "continue", "code", "print", "l", "detail", "lin", "eline", "network", "node", "body", "chain", "loop", "no", "date", "user", "string", "store", "entity", "lines", "limit", "status", "lo", "base", "state", "sequence", "trace", "email", "style", "queue", "row", "inline", "Line", "ine", "stay", "cell", "text", "nl", "sample", "liner", "comment", "section", "ln", "block", "iter", "word", "port", "next", "le", "now", "LINE", "file", "level", "range", "log", "point", "zone", "lock", "message", "page", "out", "buffer", "frame", "online", "source"], "entry": ["ary", "list", "record", "it", "ex", "key", "inner", "pixel", "term", "quick", "field", "char", "ie", "cell", "row", "pair", "e", "comment", "element", "ace", "enter", "check", "search", "add", "escape", "se", "ent", "office", "member", "part", "job", "def", "exit", "match", "object", "deep", "Entry", "or", "instance", "ry"], "fromIndex": ["leftindex", "fromInt", "forIndex", " fromindex", "FromInd", " fromAlpha", "FromLink", "minIndex", "leftIndex", "minInt", "minindex", "oldAlpha", "FromAlpha", "leftPosition", " fromLink", "normalInt", "forindex", "forPosition", " fromInt", "oldIndex", "oldLink", " fromPosition", "FromIndex", " fromInd", "fromAlpha", "forInd", "normalIndex", "leftInd", "normalInd", "fromInd", "fromPosition", "normalindex", "oldInd", "fromindex", "minInd", "fromLink"], "r": ["m", "b", "v", "n", "rect", "l", "err", "rt", "q", "res", "rd", "re", "rar", "dr", "rs", "kr", "rb", "render", "ar", "str", "rate", "u", "rc", "cr", "e", "nr", "er", "w", "rr", "range", "mr", "vr", "fr", "R", "rg", "g", "sr", "p"]}}
{"id1": "1362", "id2": "18544890", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubargeLess", "bubblesSort", "gobbleCompare", "bubblingLess", "gobblingSort", "gobbleSort", "gobblingCompare", "bubblingCompare", "bubargeSort", "bubblingSort", "bubargeCompare", "bubbleCompare", "bubbleLess", "bubblesLess", "gobblingLess", "gobbleLess", "bubblesCompare"], "a": ["o", "b", "v", "att", "cache", "aka", "ac", "ed", "list", "l", "aaa", "ap", "oa", "data", "alpha", "h", "isa", "el", "window", "na", "aa", "la", "array", "c", "arr", "area", "da", "eas", "trace", "apa", "form", "f", "ab", "aaaa", "sa", "act", "ata", "ma", "ao", "va", "go", "w", "ga", "changes", "am", "ia", "au", "t", "es", "an", "all", "as", "ae", "order", "g", "app", "era", "history", "out", "A", "ea", "z", "p"], "swapped": ["wapping", "scapped", "swapping", "stickaps", "Swaped", " swaps", "waps", "swaped", "snapping", "SWaped", " snap", "stickapped", "Swapping", " snapping", "SWap", "stickaped", " swapping", " snaped", "SWapping", "swaps", "wapped", " snapped", "SWapped", "snapped", "snaps", "stickapping", "waped", "Swap", "scaped", " swap", "Swapped", "scaps", "snaped", "swap", "scapping", " swaped"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "uli", "in", "it", "ji", "ei", "gi", "key", "ami", "chain", "iri", "phi", "us", "index", "ind", "status", "im", "base", "c", "ori", "y", "oi", "ki", "si", "ini", "li", "is", "ii", "io", "iu", "gu", "client", "xi", "f", "bi", "pi", "u", "j", "iso", "x", "me", "init", "origin", "cli", "zi", "ri", "ai", "sim", "t", "mi", "ti", "ix", "hi", "ir", "id", "di", "my", "ic", "I", "ie", "qi", "uri"], "tmp": ["comp", "m", "xy", "cache", "np", "pkg", "test", "perm", "ctx", "obj", "tf", "tg", "attr", "clip", "timeout", "amp", "prefix", "MP", "sup", "nom", "mut", "gm", "orig", "sam", "sp", "cmp", "td", "cur", "managed", "same", "t", "mp", "mk", "result", "pre", "etc", "tt", "emp", "db", "nb", "my", "temp", "lib", "txt", "sq"]}}
{"id1": "9805906", "id2": "13783549", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"dump": ["debug", "print", " dumped", " println", "link", "show", " show", " debug", "flush", "download", "store", " describe", "load", "export", "send", "write", "stat", "save", "init", "info", "copy", "println", "diff", "read", "update", " dumps", "zip", "display"], "source": ["SOURCE", "site", "input", "store", "image", "template", "java", "sequence", "form", "ie", "style", "sys", "sql", "src", "scope", "sample", "script", "init", "ource", "origin", "copy", "iter", "Source", "check", "info", "search", "resource", "file", "from", "service", "local", "se", "start", "config", "spec", "view", "shell", "ink", "remote", "text", "select", "parent"], "target": ["goal", "to", "link", "null", "project", "it", "test", "tif", "term", "that", "mac", "template", "base", "table", "bolt", "replace", "style", "compatible", "top", "arg", "arget", "copy", "proxy", "next", "t", "file", "local", "Target", "pattern", "gt", "match", "host", "output", "delete", "dest", "current"], "is": ["ip", "ris", "isi", "in", "it", "bis", "oss", "lis", "sis", "ists", "has", "isa", "are", "ins", "im", "ais", "ir", "si", "ois", "ii", "tis", "its", "ar", "IS", "abs", "isf", "Is", "sys", "act", "isin", "iso", "ms", "ics", "bits", "init", "ib", "ys", "ios", "nis", "ri", "ai", "xs", "s", "iss", "es", "iris", "ist", "isl", "ims", "ic", "isc", "i", "ls", "mos"], "os": ["o", "css", "ose", "ds", "pos", "js", "oss", "los", "oos", "cos", "oses", "obs", "oS", "ss", "aos", "io", "Os", "ows", "sys", "nos", "ants", "dos", "ot", "ols", "ios", "OS", "cs", "s", "bos", "osi", "ts", "es", "ost", "fs", "uts", "ps", "outs", "bs", "ns", "or", "oes", "ls", "ox", "mos", "ros"], "done": ["d", "disabled", "continue", "pleted", " Done", "enabled", "found", "desc", "flag", "only", "loaded", "failed", "checked", "dirty", "des", "ded", "expected", "did", "die", "later", "seen", "led", "valid", "ished", "du", "complete", "created", "needed", "shown", " continued", "progress", "set", "Done", "started", "gone", "filled", "di", "de", "given", "finished", "made"]}}
{"id1": "9210168", "id2": "16931472", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"run": ["launch", "show", "function", "thread", "execute", "test", "call", "play", "pass", "process", "exec", "name", "begin", "render", "runs", "running", "func", "class", "work", "true", "block", "Run", "normal", "start", "result", "close", "exit", "def", "all", "get", "invoke", "default", "display", "apply"], "url": ["browser", "http", "b", "pl", "rect", "web", "l", "rl", "rel", "res", "hl", "io", "char", "f", "str", "abs", "gif", "ret", "ssl", "ref", "ur", "nl", "bel", "mount", "https", "URL", "resource", "file", "gl", "impl", "Url", "sl", "fl", "lr", "path", "ls", "uri"], "fis": ["ifIS", " fIs", "fiIs", "dfiss", "fien", "fbis", "fiss", "fIs", "sfIs", "dfis", "dfibus", "fibus", "dfi", "fi", "ifien", " fiss", "fiien", "fiim", "lfim", "fiIS", "ifIs", "ifis", "fIS", "sfIS", "fbi", "fim", "fbibus", " fibus", "lfIs", " fi", "fiis", "sfis", "sfien", "fbiss", " fim", "lfis"], "r": ["b", "rect", "pr", "l", "tr", "rn", "rt", "rl", "rel", "ro", "res", "rd", "rar", "re", "reader", "dr", "rec", "rs", "kr", "rx", "rb", "rf", "f", "ar", "rc", "ur", "cr", "nr", "er", "ri", "rr", "ran", "mr", "vr", "hr", "R", "fr", "gr", "ra", "sr", "p"], "br": ["browser", "b", "n", "BR", "pr", "bh", "err", "tr", "bd", "rel", "ber", "p", "adr", "dr", "bt", "kr", "rx", "rb", "bp", "ab", "buf", "str", "cr", "cb", "bro", "nr", "be", "mr", "vr", "bb", "fr", "hr", "bl", "bm", "lr", "nb", "bs", "sr", "Br", "bridge"], "line": ["entry", "n", "number", "code", "link", "print", "l", "record", "lin", "eline", "no", "user", "string", " inline", "entity", "lines", "base", "stroke", "name", "sequence", "li", "char", "email", " error", "str", "cell", "row", " chunk", "ine", " row", " entry", "Line", "inline", "bo", "nl", "valid", "e", "sample", "liner", "comment", " frame", "ln", "block", "word", "zone", "check", " status", "LINE", "file", "le", "lane", "log", "model", "point", "page", " block", "frame"], "sb": ["pb", "b", "bj", "bh", "bis", "bd", "sbm", "rob", "zb", "lb", "ub", "bt", "stab", "gs", "rb", "sa", "ssl", "sv", "bn", "lp", "bf", "sam", "sp", "bg", "nl", "cb", "ib", "sync", "sn", "sf", "kb", "sth", "soc", "bsp", "orb", "gb", "bb", "eb", "xb", "nb", "db", "mb", "bs", "sg", "shell", "si", "erb", "SB", "sq"], "text": ["b", "n", "print", "code", "lt", "html", "data", "body", "displayText", "term", "ext", "msg", "name", "layout", "TEXT", "end", "str", "cont", "pdf", "note", "title", "st", "comment", "word", "value", "t", "format", "read", "config", "content", "output", "message", "path", "translation", "out", "x", "buffer", "Text", "txt", "source"]}}
{"id1": "15018553", "id2": "20426057", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"encrypt": ["uncode", "enccrypt", " encrypted", " encode", "uncrypted", "encrypted", "uncrypt", " enccrypt", "Encrypt", "Encrypted", "unccrypt", "Encode", "Enccrypt", "encode"], "text": ["v", "code", "print", "pt", "source", "data", "body", "q", "test", "input", "string", "ext", "th", "msg", "name", "document", "TEXT", "password", "form", "ct", "str", "cont", "act", "phrase", "ut", "comment", "title", "word", "now", "w", "url", "value", "t", "pattern", "read", "tx", "content", "output", "message", "path", "translation", "x", "buffer", "Text", "txt", "select", "p", "nt"], "md": ["d", "m", "mg", " cmd", "ad", "cd", "err", "ld", "mand", "pkg", "mode", "bd", "h", "pd", "hd", "hash", "grad", "MD", "doc", "mm", "det", "od", "ind", "pm", "msg", "mac", "c", "mod", "cmd", "dd", "mond", "ct", "der", "df", "img", "mem", " dd", "ms", "nd", "dig", "cmp", "and", "dh", "mc", "mt", "mn", "metadata", "t", "mp", "rm", "mk", "del", "mo", "dm", "di", "mb", "de", "sha", " cd"], "md5hash": [" md5sha", "md2Hash", "md5hex", "md3sha", " md5hex", "md512sum", " md5sum", " md2hash", "md2hex", " md5Hash", "md512Hash", "md3cloth", " md3Hash", " md5h", "md2sha", "md2hash", "md5h", "md3h", "md3hash", " md3hash", "md5Hash", " md2cloth", "md512h", "md3sum", " md2sum", " md3sha", "md2sum", " md5cloth", "md512hash", "md2h", " md3h", "md3Hash", "md512sha", " md2hex", " md3sum", "md3hex", "md5sha", "md5cloth", "md2cloth", "md5sum"]}}
{"id1": "20623709", "id2": "1188100", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"split": ["scale", "parse", "disk", "batch", "use", "process", "transfer", "seek", "open", "align", "scan", "count", "unit", "write", "append", "upload", "sync", "copy", "format", "map", "read", "part", "Split", "lock", "slice", "share", "join"], "targetDirectory": ["TargetDirect", "localdirectory", "TargetDirectory", "baseFile", "targetDir", " targetFolder", "localFile", "localDirectory", "baseDir", "basedirectory", "testDirectory", " targetDir", "TargetFolder", "baseFolder", "targetDirect", " targetMemory", "targetLocation", " targetFile", "targetFile", "Targetdirectory", " targetdirectory", "testLocation", "targetdirectory", "targetMemory", "baseDirectory", "targetFolder", "TargetLocation", "testDir", "TargetDir", "localDir", "testDirect", " targetDirect", "baseDirect", "baseMemory", " targetLocation", "TargetMemory"], "prefix": ["zero", "command", "pkg", "key", "filename", "root", "uri", "index", " suffix", "directory", "padding", "username", "status", "base", "template", "name", "fix", "type", "password", "division", "localhost", "alias", "PRE", "fixes", "pi", "FIX", "title", "version", "size", "format", "pres", "pattern", "pre", "ix", "Pref", "fixed", "this", "tag", "path", "p"], "maxUnitBases": ["maxUnitBages", "maxUnitbounds", "maxUnitReplages", "maxUnitChicas", "maxUnitChounds", "maxUnityLases", "maxUnitBades", "maxUnitChias", "maxUnitChases", "maxUnitReplicas", "maxUnitChades", "maxUnityLounds", "maxUnityBicas", "maxUnityBages", "maxUnityBias", "maxUnitReplases", "maxUnitAliounds", "maxUnitReplounds", "maxUnitbades", "maxUnityAliases", "maxUnitLages", "maxUnityAliounds", "maxUnitLases", "maxUnitBounds", "maxUnityLages", "maxUnityBases", "maxUnityBounds", "maxUnitLicas", "maxUnityAliades", "maxUnitAliades", "maxUnityLicas", "maxUnitBicas", "maxUnitbias", "maxUnitbases", "maxUnitAliases", "maxUnityBades", "maxUnitChages", "maxUnityAliias", "maxUnitBias", "maxUnitLounds", "maxUnitAliias"], "maxUnitEntries": ["maxunitEntries", "maxUnitentrs", "maxunitEntires", "maxUnitErrys", "maxUnitentires", "maxUnityentries", "maxUnityEntires", "maxUnitEntrys", "maxUnitErrs", "maxUnitentries", "maxUnitEntryires", "maxUnitIntegires", "maxUnitEntriers", "maxUnitErires", "maxUnitEntryries", "maxUnitEntryrys", "maxUnitEntryriers", "maxUnitIntegrys", "maxUnitEntrs", "maxUnityEntrs", "maxunitEntrys", "maxUnitIntegries", "maxUnitentrys", "maxUnityEntrys", "maxunitEntrs", "maxUnitIntegriers", "maxUnitErries", "maxUnityentrys", "maxUnityentrs", "maxUnityentires", "maxUnityEntries", "maxUnitEntires"], "fis": ["fic", "Fic", "fiss", "Fii", "vi", "vis", "fi", " fiss", " fic", "viss", "ifis", "Fiss", "ific", "Fci", "Fis", "ifii", "fii", "ifci", " fi", " fii", "vic", "Fi"], "fci": [" fai", "Fini", "fic", "Fic", "Fco", "fico", "fini", "cfic", "cfis", "tcu", " fcu", " fic", "tci", "cfco", " fico", "mcu", "mii", "Fci", "Fis", "tco", " fini", "Fai", "fcu", "tii", "cfini", "fii", " fii", "cfci", "cfai", "mco", "fai", "cfico", "Fico", "mci"], "fos": ["wbos", "yos", "yaos", "flOS", " fbos", "flaos", "fOS", "Foss", " faos", "ybos", " fios", "floss", "fios", "Fos", "wos", " foss", "foss", "FOS", "fbos", "flos", " fOS", "waos", "Faos", "yios", "wios", "faos"], "fco": ["fcon", "ccon", "cdo", "Fcos", "Fco", "pco", "cso", "tcos", "toco", "Fcon", "fso", "Fdo", " fcon", "tdo", "Foco", "fcos", " foco", "fdo", "foco", "Fci", "tco", " fso", "pci", " fdo", "Fso", " fcos", "pcos", "cco", "pso"], "buffer": ["entry", "batch", "cache", "print", "Buffer", "command", "record", "data", "black", "function", "address", "filter", "reset", "memory", "flush", "index", "window", "padding", "database", "holder", "limit", "timeout", "template", "button", "document", "table", "sequence", "char", "callback", "queue", "buf", "row", "phrase", "note", "sample", "buff", "pause", "comment", "append", "stack", "iter", "block", "position", "complete", "library", "result", "read", "match", "binary", "order", "event", "message", "temp", "channel", "length", "bridge", "source"], "currentBasesCount": ["currentbaseCode", "currentBaseCode", "currentbasesCode", "currentBasesLength", "currentbaseCount", "currentBadesCode", "currentbasesLength", "currentBadesCount", "currentBasesCode", "currentBasedCode", "currentBasedCount", "currentbasesCount", "currentBaseCount", "currentBaseLength", "currentBasedLength", "currentBadesLength", "currentbaseLength"], "currentEntriesCount": ["currentEntriesFlag", "currentEntiesCount", "currentEntrsCode", "currentEntiesCode", "currentEntrysFlag", "currentEntrysCount", "currentEntrysCode", "currentEntiesFlag", "currentEntriesCode", "currentEntrsFlag", "currentEntrsCount"], "targetCount": ["targetAmount", "targetNum", "TargetInfo", " targetAmount", "argetCount", "argetAmount", "TargetAmount", " targetInfo", "TargetNum", "argetNum", "argetInfo", "TargetCount", "targetInfo", " targetNum"], "fastaChannel": ["fastoStream", " fastaQueue", " fastoStream", " fastoChan", "fastoChannel", "fastoProvider", "fastaConnection", "fastoChan", "fastaStream", " fastaStream", "fastaiStream", "fastaiChannel", "fastoConnection", "fastpaConnection", " fastaProvider", "fastityChannel", "fastaButton", " fastoChannel", "fastityStream", "fastpaButton", "fastaiQueue", "fastaProvider", " fastaButton", "fastityQueue", "fastaChan", " fastaConnection", "fastpaChannel", "fastoQueue", "fastpaProvider", "fastaQueue", "fastityChan", "fastaiChan", "fastoButton", " fastoQueue", " fastaChan"], "totalSeqCount": ["totalSeqsCount", "totalSegSize", "totalSeqSize", "totalSegCount", "totalSeQCount", "totalSeQCode", "totalSeQSize", "totalSeqCode", "totalSegCode", "totalSeqsSize", "totalSegCounter", "totalSeqCounter", "totalSeQCounter", "totalSeqsCounter", "totalSeqsCode"], "totalResiduesCount": ["totalResidueCount", "totalResIdueCode", "totalResidueFlag", "totalResiduationsFlag", "totalResIduesCode", "totalResidusCount", "totalResIdueCount", "totalResiduesFlag", "totalResiduationsCode", "totalResIduesFlag", "totalResiduesCode", "totalResidusFlag", "totalResIdueFlag", "totalResiduationsCount", "totalResidusCode", "totalResidueCode", "totalResIduesCount"], "prevTime": [" prevT", "prevT", " prevThread", "parTime", "prevThread", " previousTime", "parThread", " previousT", " previousThread", "parT"], "fastaFileSize": ["fastAFileHeight", "fastAFileSize", "fastafileSIZE", "fastoFileSize", "fastaChainLength", "fastoFileOwner", "fastaTableLength", "fastaFilesSize", "fastoTableSIZE", "fastoTableSize", "fastaReaderSize", "fastoFileLength", "fastATableName", "fastaFileName", "fastaFilesHeight", "fastafileLength", "fastaFileLength", "fastaFileSIZE", "fastATableSize", "fastATableHeight", "fastaTableSize", "fastaTableHeight", "fastaTableOwner", "fastaChainSize", "fastaFilesName", "fastaFileHeight", "fastATableLength", "fastafileOwner", "fastoTableLength", "fastaReaderLength", "fastAFileLength", "fastaReaderHeight", "fastaTableName", "fastaFileOwner", "fastaChainSIZE", "fastoFileSIZE", "fastafileSize", "fastaTableSIZE", "fastaReaderName", "fastaFilesLength", "fastAFileName", "fastaChainOwner", "fastoTableOwner"], "fastaFileReadOffset": ["fastaChainCurrentLocation", "fastaFileWriteOffset", "fastaFileViewPos", "fastaFileLoadLength", "fastaFileReadPosition", "fastaFileReadLength", "fastaFileLoadOrder", "fastaFileInputAmount", "fastaFileInputPosition", "fastaPageReadOffset", "fastaChainCurrentoffset", "fastaFileReaderLocation", "fastaFileInputLocation", "fastaFileInputOrder", "fastaFilereadOrder", "fastaFileWriteAmount", "fastaChainReadPosition", "fastaFileViewOffset", "fastaFileReadoffset", "fastaFileInputoffset", "fastaChainReadoffset", "fastaFileReaderOffset", "fastaFilereadOffset", "fastaPageLoadOrder", "fastaFileInputOffset", "fastaFilesLoadLength", "fastaFileLoadAmount", "fastaPageLoadPos", "fastaFilereadPos", "fastaFilereadAmount", "fastaFileCurrentoffset", "fastaFileReadOrder", "fastaFileReaderoffset", "fastaPageReadOrder", "fastaFileReaderPosition", "fastaChainReadLocation", "fastaFileLoadOffset", "fastaPageReadAmount", "fastaFileCurrentLocation", "fastaFileCurrentPosition", "fastaFileViewAmount", "fastaFileInputLength", "fastaPageReadPos", "fastaFileViewOrder", "fastaFileWriteOrder", "fastaFilesLoadOffset", "fastaFileLoadPos", "fastaFilesReadOrder", "fastaFileCurrentOffset", "fastaPageLoadAmount", "fastaFileReadPos", "fastaFileReadLocation", "fastaFilesReadAmount", "fastaFilesLoadAmount", "fastaFilesLoadOrder", "fastaFileReadAmount", "fastaChainCurrentOffset", "fastaFileWriteLength", "fastaFilesReadOffset", "fastaChainReadOffset", "fastaChainCurrentPosition", "fastaFilesReadLength", "fastaPageLoadOffset"], "partitionStartOffset": ["partitonStartingPosition", "partitionStartingPoint", "partitionStartingOff", "partitionDataPosition", "partitonStartOffset", "partitonStartingOff", "partitionStartingOffset", "partitionStartPosition", "partitionStartingPosition", "partitionDataOffset", "partitonStartingPoint", "partitionEndPosition", "partitionEndPoint", "partitionStartPoint", "partitionDataOff", "partitonStartPoint", "partitonStartOff", "partitionEndOff", "partitionDataPoint", "partitonStartPosition", "partitonStartingOffset", "partitionStartOff"], "bufferSize": ["BufferName", "buffLength", "buffName", "bufferSIZE", "bufSize", "bufferCode", "sequenceSize", "BufferSIZE", "BufferLength", "buffSize", "BufferSize", " bufferCode", "bufSIZE", "bufLength", "tableSize", "bufferName", "sequenceCode", "bufCode", "tableName", "tableSIZE", " bufferLength", "tableLength", "sequenceSIZE", " bufferSIZE", "buffSIZE", "bufferLength", "sequenceLength"], "fastaBuffer": ["fastuMemory", "fastaDB", "FastmaBuff", "fastmaCache", "fastmaBuilder", "fastoCounter", "fastaBuilder", " fastoBuffer", "fastalQueue", "fastsaChannel", "wildaBuff", "fastcaBuffer", "fastanCache", "fastanRequest", "fastoBuffer", "wildanBuff", "fastasCounter", "fasteBuffer", " fastaBuilder", "fastsaBuffer", "fastcaRequest", "fastmaBuff", " fastaCache", "FastmaStore", "fastsaBuff", "fastasBuff", "fastasCache", "fastoRequest", "fastoBuff", "fastuDB", "fastasBuilder", "fastalCounter", "FastaBuffer", "FastmaBuffer", "fasteMemory", "fastanBuffer", "wildaCache", "fastuBuff", "wildaBuffer", " fastoQueue", "fastcaCache", "fastmaQueue", "fastaBuff", "fastanBuff", " fastoBuff", "FastaBuff", "fastasBuffer", "FastaRequest", "fastcaBuff", "fastaCache", " fastaBuff", "fastaRequest", "FastaStore", "fastasRequest", "fastalBuffer", "wildanBuffer", "wildanRequest", "fastmaBuffer", "FastmaRequest", " fastaDB", " fastaCounter", "fastuBuffer", "wildaRequest", "fastmaStore", " fastoCounter", " fastaQueue", "fasteBuff", "fastsaQueue", "fasteDB", "fastaStore", "fastmaRequest", "fastoStore", " fastaMemory", "fastasStore", "fastasQueue", "fastaCounter", "fastoQueue", "fastmaChannel", "fastaQueue", "fastalBuff", "wildanCache", "fastaMemory"], "fastaReadState": ["fastaReaderState", "fastaCurrentType", "fastoReaderSTATE", "fastoReaderStatus", "fastoReadState", "fastoReaderType", "fastaLoadStatus", "fastoReadStatus", "fastaLoadType", "fastaReaderStatus", "fastaReaderType", "fastoReadSTATE", "fastaCurrentState", "fastaReaderSTATE", "fastoReaderState", "fastaLoadSTATE", "fastaCurrentStatus", "fastaReadSTATE", "fastaReadType", "fastaCurrentSTATE", "fastaReadStatus", "fastaLoadState", "fastoReadType"], "nBytes": ["nsWords", "nsParts", " nItems", " nbytes", " nBlocks", " nNs", "numBlocks", "numNs", "NParts", "noBytes", " nWords", "noBlocks", "nItems", "nBlocks", "noNs", "nrBytes", "nbytes", "nobytes", "nrbytes", "Nbytes", "nParts", "nNs", "NKeys", "nsbytes", "nsBytes", "nKeys", "NItems", "numBytes", "nrKeys", "NBytes", "NWords", "numbytes", "nrItems", "nWords", " nParts", " nKeys"]}}
{"id1": "6379126", "id2": "18489832", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": [" crearTeoyScreen", " crearTiaryPage", " crearTeoyServer", " crearTiaryPages", " crearTeoyPage", " crearTeutorialPage", " crearTiaryServer", " crearTiblPages", " crearTeutorialScreen", " crearToyServer", " crearTiaryScreen", " crearToyPage", " crearTiblPage", " crearToyPages", " crearToyScreen", " crearTeutorialPages", " crearTiblServer", " crearTiblScreen", " crearTeoyPages", " crearTutorialScreen", " crearTutorialPages", " crearTutorialPage", " crearTeutorialServer", " crearTutorialServer"], "indexDir": ["htmlFolder", "indexFolder", "htmlDir", "scriptDir", "appPath", "appFolder", "scriptFolder", "indexDIR", "htmlPath", "appDir", "appDIR", "scriptDIR", "htmlDIR", "indexPath", "scriptPath"], "cssDir": ["cssdir", "ssDb", "statsUrl", "stylesDir", "ssDIR", "stylesUrl", "csUrl", "cssDIR", "ssUrl", "stylesdir", "ssRect", "stylesDirectory", "csDir", "icsDirectory", "icsdir", "icsDir", "ssDirectory", "cssUrl", "csDirectory", "cmsDIR", "cmsDir", "csRect", "ssDir", "csdir", "icsRect", "cmsDirectory", "cssRect", "ssdir", "statsDb", "stylesDIR", "cmsdir", "cssDirectory", "statsDir", "cssDb", "stylesDb"], "capDir": ["capTier", "configDb", "configTier", "CapFile", "CapTier", "cmpDb", "CapDir", "CapDb", "capDb", "configDir", "cmpFile", "capFile", "cmpDir", "configFile", "cmpTier"], "licDir": ["licRot", "liaDir", "vidRot", "liaDb", "libDir", "libDs", "liaRot", "libRot", "vidDs", "licDs", "liaDs", "libDb", "vidDir", "vidDb", "licDb"], "midDir": ["manDirectory", "midDirectory", "pidRot", "mnCat", "mnDirectory", "mnRot", "manCat", "pidCat", "pidDir", "midCat", "midRot", "manRot", "mnDir", "manDir", "pidDirectory"], "filesDir": ["tagsJar", "filesIter", "videosdir", "framesJar", "videosDIR", "framesIter", "pagesDir", "framesdir", "filesFix", "tagsRect", "framesRect", "framesDIR", "pagesFolder", "framesFolder", "sectionsJar", "filesRel", "sectionsIter", "framesFix", "imagesDir", "filesDIR", "framesRel", "imagesFix", "filesRect", "framesDir", "pagesdir", "tagsDir", "videosFolder", "sectionsRect", "imagesDIR", "tagsIter", "sectionsDir", "filesJar", "imagesFolder", "pagesRel", "filesdir", "videosRel", "videosFix", "filesFolder"], "videosDir": ["versionsDir", "videosdir", "videosFile", "videoFolder", "imagesFile", " videosFile", "videodir", " videosFolder", "imagesDir", "videoDir", "videosFolder", "imagesFolder", " videosdir", "versionsFolder", "versionsFile", "imagesdir"], "imagensDir": ["imagensesIn", "imagearsIn", "imagmesDir", "imgensDIR", "imagetsDIR", "imagensDb", "imagotsDIR", "imgetsDIR", "imagmesFolder", "imagetsDir", " imagetsFolder", "imagmesDirectory", "imagotsDir", "imagensDIR", " imagetsDir", "imagensesDir", "imagensesFolder", "imagotsFolder", "imagensFolder", "imagearsDir", " imagensIn", "imgensDirectory", "imagearsDb", "imagetsFolder", "imagotsDirectory", "imgensDir", "imgetsDir", "imgetsDirectory", "imagearsFolder", "imgensFolder", " imagetsDb", "imagetsIn", "imagetsDb", " imagensDb", "imagetsDirectory", "imagensIn", " imagensFolder", "imagensDirectory", " imagetsIn", "imagmesDIR", "imagensesDb", "imgetsFolder"], "local": ["http", "shared", "personal", "simple", "list", "val", "l", "serial", "back", "al", "install", "alpha", "full", "server", "test", "pid", "root", "system", "location", "self", "state", "base", "pal", "upper", "loc", "south", "standard", "client", "localhost", "global", "mail", "western", "valid", "Local", "installed", "dir", "where", "single", "managed", "internal", "present", "home", "part", "central", "hid", "initial", "lib", "tmp", "lock", "temp", "land", "util", "remote", "current", "parent"], "srcCss1": ["srcCxx1", "srcLass1", "srcScss2", "srcCcss3", "srcLass2", "srcSCass3", "srcCfg3", "srcSss1", "srcLassOnce", "srcCson2", "srcCxx0", "srcCcss10", "srcSCass2", "srcCssasso", "srcCsonOnce", "srcCass3", "srcCSS0", "srcSCass0", "srcScss1", "srcChess1", "srcSss3", "srcCfg2", "srcLss1", "srcCfg1", "srcChessasso", "srcScss3", "srcCcss1", "srcCss10", "srcCxx10", "srcSCss3", "srcCss0", "srcScssOnce", "srcCxxasso", "srcSCss1", "srcCcss0", "srcSCss2", "srcCcssOnce", "srcCssOnce", "srcSssOnce", "srcLss10", "srcSss2", "srcCSS1", "srcCson1", "srcCass1", "srcLssOnce", "srcLass10", "srcCassasso", "srcCass10", "srcSCass1", "srcCson10", "srcCcss2", "srcCass2", "srcCfgOnce", "srcCSS3", "srcCSS2", "srcCassOnce", "srcCass0", "srcLss2", "srcChess0", "srcSCss0", "srcChess10"], "destCss1": ["destSss2", "destSass0", "destCssPre", "destCcss0", "destScss5", "destCass5", "destCcss5", "destCxx0", "destScss2", "destCass100", "destSass1", "destChess1", "destChess2", "destCrss0", "destCass0", "destCcssPre", "destChess0", "destCcss100", "destCss0", "destCxxPre", "destCrss5", "destCass2", "destCrss1", "destSss0", "destSssPre", "destCss100", "destCrss2", "destCassPre", "destCcss1", "destChess100", "destCass1", "destCcss2", "destSassPre", "destCxx1", "destSass100", "destSss5", "destSass2", "destScss1", "destScss0", "destSss100", "destCxx2", "destSss1"], "srcCss2": ["srcCtx2", "srcCson4", "srcCssTwo", "srcCcss3", "srcCson2", "srcCass4", "srcCffee3", "srcSCass2", "srcCsv52", "srcCcss4", "srcCfg2", "srcCfg1", "srcCsv48", "srcCcss52", "srcCsv3", "srcCss52", "srcCffee52", "srcCcss1", "srcCffee2", "srcCfg4", "srcSCss1", "srcCfg8", "srcCsv2", "srcSCss2", "srcCassTwo", "srcSCss4", "srcCson1", "srcCass1", "srcCcss48", "srcSCssTwo", "srcSCass4", "srcCtx1", "srcSCassTwo", "srcCtxTwo", "srcSCass1", "srcCss8", "srcCcss2", "srcCsv1", "srcCass2", "srcCcssTwo", "srcCtx4", "srcCson8", "srcCcss8", "srcCss48", "srcCffee1"], "destCss2": ["destSss2", "destCcss56", "destCss56", "destCcs2", "destCSS42", "destSass3", "destCcss3", "destSss3", "destCcs02", "destChess3", "destCcss02", "destSass1", "destChess1", "destSass56", "destCrosse4", "destChess2", "destCSS02", "destCss42", "destCass3", "destCcs42", "destCSS2", "destCrosse1", "destCss02", "destCcss42", "destCass2", "destCass4", "destCrosse2", "destCcss1", "destChess56", "destCcss2", "destCass1", "destSss56", "destCSS3", "destSass2", "destCcs3", "destCass56", "destSss1", "destCcss4"], "srcCss3": ["srcCcss3", "srcCessThree", "srcCass4", "srcSss03", "srcCassThird", "srcCxx03", "srcScss3", "srcCssThird", "srcCcssThree", "srcCss03", "srcCxx3", "srcCcss43", "srcCSS2", "srcCrss3", "srcCxx43", "srcCassThree", "srcCessthree", "srcCass03", "srcCcss03", "srcCcss6", "srcCSS3", "srcCss43", "srcCess4", "srcCssthree", "srcCess6", "srcCcssThird", "srcCessThird", "srcSss3", "srcCsv3", "srcCoss6", "srcCsv2", "srcCSS1", "srcCass43", "srcCrss2", "srcSss43", "srcCess3", "srcCssThree", "srcCrss1", "srcCcssthree", "srcCoss3", "srcCass3", "srcCcss4", "srcCossthree", "srcScss43", "srcScss03", "srcCsv1"], "destCss3": ["destCfg23", "destCls3", "destCss03", "destCcss3", "destCcss23", "destCfg03", "destCSS1", "destCss30", "destCls53", "destCass3", "destCls83", "destCass03", "destCass23", "destCss23", "destCSS2", "destCfg3", "destCess3", "destCcss53", "destCess83", "destCass30", "destCass2", "destCss83", "destCcss1", "destCess53", "destCss53", "destCass1", "destCcss2", "destCcss30", "destCSS3", "destCcss03", "destCSS30", "destCcss83"], "srcCss4": ["srcScss2", "srcScss5", "srcCsvFour", "srcCsv5", "srcCcss5", "srcCcss4", "srcScss4", "srcCsv2", "srcCssFour", "srcSss2", "srcScssFour", "srcCSS4", "srcSssFour", "srcSss4", "srcCcssFour", "srcCcss2", "srcSss5", "srcCsv4", "srcCSS2", "srcCSS5", "srcCSSFour"]}}
{"id1": "18238468", "id2": "8150996", "code1": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"testLoadSource": [" testAddSource", " testloadSources", " testAddSources", "testloadSources", " testAddFile", " testloadFile", " testAddSourceFile", " testloadSourceFile", "testLoadSourceFile", "testloadFile", "testloadSource", "testLoadFile", " testLoadSourceFile", " testLoadFile", " testloadSource", "testloadSourceFile", " testLoadSources", "testLoadSources"], "metadata": ["m", "report", "summary", "ad", "md", "adata", "material", "policy", "detail", "header", "data", "xml", "desc", "parser", "directory", "activity", "template", "dirty", "unknown", "about", "document", "layout", "still", "meta", "license", "cmd", "properties", "dd", "basic", "password", "details", "definition", "json", "sheet", "df", "wrapper", "met", "valid", "pdf", "common", "sample", "info", "mt", "manager", "primary", "managed", "iterator", "mk", "map", "config", "article", "params", "content", "default", "payment", "tmp", "message", "my"], "inputStream": ["InputSteam", "thisPresent", "inputstream", "currentStreamer", "formForm", " inputStreamer", "dataStreamer", "dataSteam", "thisStream", "inputStreamer", "thisSteam", "loadstream", "InputStream", " inputPort", "inputPort", "loadSteam", "inputStore", "InputForm", " inputForm", "formStream", "currentStream", "InputView", " inputstream", " inputSteam", "loadStream", "Inputstream", "loadStore", "dataPort", "thisView", "inputForm", "inputPresent", "InputStore", " inputPresent", "formSteam", "inputView", " inputStore", "dataStream", "inputSteam", "currentPort", " inputView", "InputPresent", "currentSteam"], "writer": ["rew", "to", "walker", "null", "wire", "her", "network", "operator", "inner", "writing", "adder", "wright", "unsigned", "window", "reader", "string", "editor", "maker", "Writer", "builder", "wrapper", "handler", "worker", "outer", "channel", "caster", "write", "writ", "riter", "writers", "manager", "counter", "stream", "w", "iterator", "written", "out", "loader", "master", "creator", "wrote", "storage", "console", "order", "event", "output", "temp", "woman", "WR", "buffer"], "contents": ["utfented", " CONTENT", "contodes", "CONTents", "utfents", "CONTent", "Contens", "utfent", "Contented", " CONTens", "Contodes", "Content", "Contents", "contens", "contented", " contens", " CONTodes", " CONTents", "ContENT", "CONTented", "content", "contENT", " contodes", " contENT"]}}
{"id1": "13757855", "id2": "6840241", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"process": ["parse", "project", "step", "create", "filter", "proc", "execute", "loop", "call", "processor", "transform", "load", "Process", "render", "replace", "build", "write", "save", "task", "add", "format", "handle", "processing", "run", "display", "apply"], "tpl": ["stbl", "Tbl", "timpg", "tpg", " tbl", " tpp", "tplug", "Tspl", "ttPL", "atpl", "itplate", " tph", "tPL", "ttph", "atplate", "ptld", "tuple", "tph", "itPL", "timbl", "terld", "otpl", "stopl", "timspl", " tplate", "otbl", "tmpp", "tyurtle", "ttpl", "ttopl", "stplate", "atuple", "ttpg", "ptbl", "tmplate", "terpl", "temPL", " tuple", "tsurtle", "ttplug", "itbl", "tpr", "tempr", "timplug", "otld", " tld", "Tph", "tmbl", "tmplates", "topl", "stpg", "stplug", "tmpl", "terplate", "turtle", "tplate", "ptplates", "templ", "Tpr", "tpp", " turtle", "tld", "tplates", "tsPL", "tspr", "ptpl", " tPL", "ttbl", "Tpp", "stpl", "tyPL", "timplate", "itpl", "tmPL", "typl", "timpl", "otplate", "TPL", "Tplate", "stspl", " tplates", "Tpl", "Tplates", "tspl", "timopl", "atld", "tsbl", "Tld", "teruple", "tbl", "tembl"], "model": ["m", "tree", "project", "md", "record", "html", "node", "data", "el", "Document", "base", "M", "document", " models", "module", "Model", " Model", "file", "log", "ml", "models", "content", "object", "product", "parent"], "packageName": ["PackageRoot", "packageFamily", "packagename", "packageClass", "packageVersion", " packageNames", "pkgName", " packageRoot", "groupName", "groupNames", "packageNames", "Packagename", "viewName", "packageRoot", " packageFamily", " packageClass", "groupFamily", " packagename", "pkgNames", "PackageName", "viewRoot", "pkgVersion", " packageVersion", "groupVersion", "PackageClass", "viewname", "pkgFamily", "viewClass"], "outFileName": [" outFilenameSize", "outFileSize", "inFileNames", "outFilePath", "outImageName", "outFNames", " outTablePath", "outFilenameChain", "outfileTime", " outfilename", "inFileTime", "outFilename", " outFileNames", "infileTime", "outFilenamename", " outTableTime", "outStreamName", "outImageSize", " outFileTime", "outTablename", "outStreamTime", "outTableName", " outFilePath", "outDirTime", " outfilePath", "outImagename", "infileType", "infileNames", "outfileNames", " outFileChain", "outStreamNames", " outFilenamePath", "outFilenameNames", "infilePath", "outFileType", " outFileSize", "outfileType", "infileName", "outImagePath", "outFname", "outfileName", "outfilename", " outFilenamename", "outfilePath", "outFilenameSize", " outFilenameType", "outFilenameType", "outTableTime", "outTableChain", "outTableType", "outFileNames", "outDirPath", "inFileName", " outfileName", "outFPath", " outTableSize", "outTableSize", "outFileChain", "outDirName", " outTableName", "outFileTime", "outFilenameName", " outfileNames", " outFileType", " outFilenameChain", "outTablePath", "outFName", "outfileChain", "outStreamType", "outFilenamePath", " outFilenameName", " outFilename", "inFileType", "outStreamPath", "outFilenameTime", "inFilePath", "outDirSize"], "xsltParam": ["xltConf", "xsmlParam", "xmlConf", "xltParam", "xsltConf", "xsqlParameter", "xsslParameter", "xsltParameter", "xsqlConf", "xsslParam", "xsslConf", "xsmlParameter", "xmlParam", "xsqlParam", "xltParameter", "xmlParameter", "xsmlConf"], "artifact": ["anificial", "ardificial", "Artifact", "partifact", " artifacts", "artificial", " artificial", "anifacts", "ardificate", "ardifact", "artifacts", "artificate", "arifact", "Artifacts", " artificate", "anificate", "arifacts", "anifact", "ardifacts", "partifacts"], "destinationPath": ["destinationInfo", "DestificationDir", "destinatorpath", "desturationpath", "destositoryParent", "destensionPod", "identinationChain", "destinatedTarget", "DestinationDir", "destventionDriver", "delinationPath", "destinationChain", "estinationPath", "desticationPod", "destociationPath", "DestensionTemp", "termininationTarget", "destinateLocation", "destATIONHost", "destinantPod", "desturationTarget", " destinationTarget", "destensionDir", "destinationPart", "destinerSystem", "destociationDir", "destinationDisk", "descositoryPath", "destinateAt", "destesticPath", "estionpath", "destociationLog", "destensionHost", "estinationpath", "chaininatedDisk", "destinateHost", "destigationChain", "destociationDriver", "DestinationHost", "destinoDir", "destationDir", "identinationInfo", "destinatePath", "descinationPath", "destitutionPATH", "destinateChain", "estinationPoint", "descositoryPort", "estionPath", "destinationSystem", "origininatedForm", "destinationHost", "destinatePart", "DestinationPoint", "DestificationUrl", "destinateLog", "destinerPath", "termininerJar", "destociationHost", "estationPart", "chaininatedHome", "estinationHost", "destinatedNow", "identinateInfo", "destociationTarget", "destigationPath", "estationHost", "destinationDriver", "descinationParent", "destesticAt", "termininerpath", "destATIONParent", "destificationDir", "destacementName", "destinerHost", "estionPATH", "destinationPoints", "destranceForm", "delinateForm", "chaininationPath", "generinationPath", "destinoPath", "DestensionDir", "destinationPATH", "origininatedPath", "desturationPath", "destinatedDriver", "chaininatedPath", "destinatorChain", "destinatedForm", "destinationTime", "destventionHome", "desticationPath", "estinationTime", "chaininatedDriver", "destionPATH", "destinateName", "destociationPoints", "destificationUrl", "identinateChain", "origininationPath", " destinationDisk", " destociationDisk", "estationPath", "destregationPath", "destionPath", "DestificationPath", "destinationHome", "delinatePath", "origininationNow", "destinateNow", "destinatorInfo", "destinatepath", "estinationKey", "destinoKey", "destinatorKey", "destregationDisk", "DestensionPoint", "destinatorPATH", "destitutionPath", "DestensionPod", "destionpath", "termininationPath", "destinateDir", "origininatedNow", "generinateJar", "DestinationPod", "estinoPath", "destinatedpath", "destationPath", "destranceLog", "termininationpath", "estinationName", "destationUrl", "destacementTime", " destociationpath", "destinatorParent", "termininerTarget", "destionPoint", "destinatorPath", "delinationLog", "destinateKey", "destinationTarget", "destinatedDisk", " destociationPath", "destregationpath", "DestinationLocation", "destigationNow", "destinationPoint", "delinateLog", "destesticJar", "estationDir", "destinoName", "destificationPath", "identinationKey", "desticationDir", "destinationDir", "destinerJar", "destensionTemp", "chaininationHome", "destinationName", "destinateSystem", "destationHost", "termininationJar", "destinationpath", "destacementPath", "destATIONPath", "destinantPath", "destinantTemp", "DestensionHost", "destinationAt", "destinateUrl", "destinationKey", "destociationForm", "estinationPart", "descositoryParent", "destensionPath", "destinatedKey", "destinationLocation", "destigationForm", "chaininationDriver", "generinateAt", "destinoHost", "destociationDisk", "destinationPod", "generinatePath", "chaininationDisk", "destinateForm", "destinationParent", "destositoryPath", "desturationJar", "destinationPort", "destositoryPort", "destinerPart", "generinationSystem", "destinantDir", "destificationLocation", "destinationLog", "termininerPath", "DestinationPath", "destventionPath", "descositoryHost", "desticationTemp", "descinationHost", "generinateSystem", "destinationTemp", "destinatedInfo", "destitutionPoint", "destinatedChain", "destositoryHost", "origininationChain", "destinerpath", "destregationTarget", " destociationTarget", "destensionPoint", "delinationForm", "origininationForm", "destinatorPoint", "destinatePoints", "destinationNow", "identinationPath", "destinateInfo", "DestinationUrl", "estinoTime", "descinationPort", "generinationJar", "identinateKey", "estinationPATH", "estinoKey", "DestinationTemp", "destinatorHost", "destinerAt", "destinationForm", "destationLocation", "destinateJar", "destesticSystem", "destociationpath", "destacementKey", "destinationUrl", "destinationJar", "destociationHome", "delinationPoints", "generinationAt", "destinateTime", "destinatedHome", "DestensionPath", "destrancePoints", "destinoTime", "destinatedPath", "destATIONPort", "estinoName", "destitutionpath", "estionPoint", "destinerDir", "destinatorPort", "origininatedChain", "destrancePath", "destationPart", "destociationPoint", "DestificationLocation", "identinatePath", " destinationpath", "estinationDir", "destventionDisk", "delinatePoints", "destinateTarget", "destinoPoint", "destinerTarget"], "in": ["d", "m", "o", "n", "IN", "l", " IN", "inner", "ins", "doc", "input", "reader", "bin", "c", "In", "io", "f", "info", "w", "t", "file", "id", "r", "din", "i"], "out": ["o", "report", "n", "to", "dis", "print", "screen", "null", "conn", "list", "err", "ex", "raw", "gen", "it", "l", "inner", "obj", "ins", "res", "inv", "OUT", "msg", "c", "os", "up", "Out", "io", "ou", "aos", "cmd", "writer", "oe", "client", "f", "or", "outer", "sys", "u", "ch", "ger", "co", "e", "write", "con", "ln", "nr", "println", "go", "w", "file", "s", "t", "cache", "log", "can", "all", "cfg", "conf", "output", "outs", "gr", "v", "net", "cn", "b", "p", "nt"], "root": ["m", "graph", "node", "data", "create", "roots", "chain", "p", "child", "New", "group", "name", "parents", "table", "json", "Template", "parent", "context", "scope", "dir", "println", "impl", "dump", "se", "start", "config", "id", "Root", "def", "initial", "ok", "_", "r", "de", " roots", "tree"]}}
{"id1": "6625074", "id2": "2982747", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {\n        this.inFile = fileStr;\n        this.type = type;\n        System.out.println(\"File str \" + fileStr);\n        if (fileStr.indexOf(\"http://\") == 0) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"File\")) {\n            File inFile = new File(fileStr);\n            size = inFile.length();\n            inStream = new FileInputStream(inFile);\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URL\")) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URLZip\")) {\n            URL url = new URL(fileStr);\n            inStream = new GZIPInputStream(url.openStream(), 16384);\n            InputStreamReader zis = new InputStreamReader(inStream);\n            bufReader = new BufferedReader(zis, 16384);\n        } else {\n            System.out.println(\"Unknown FileParse inType \" + type);\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": ["HS2", " SHAOne", "sha512", "sha1", "HS512", "SHA2", "SHA512", " SHA2", "HSOne", "SHAOne", "sha2", " SHA512", "shaOne", "HS1"], "text": ["v", "code", "print", "pt", "it", "data", "sum", "body", "test", "q", "doc", "input", "string", "ext", "msg", "template", "name", "document", "TEXT", "password", "form", "str", "cont", "act", "title", "comment", "ut", "hex", "word", "url", "value", "t", "read", "tx", "content", "event", "output", "nt", "message", "path", "translation", "buffer", "Text", "txt", "source"], "sha1hash": ["sha31hash", "SHA1hash", "sha3message", "SHA1Hash", "sha3hash", "sha31Hash", "sha0Hash", "shaonemessage", "sha1sum", "shaonesum", "sha1message", "SHA2hex", "sha1Hash", "ha2Hash", "ha1hash", "ha2hash", "SHA2Hash", "SHA1hex", "sha2Hash", "sha1hex", "ha1address", "sha2hash", "sha0address", "sha31address", "shaoneHash", "haonehash", "ha2address", "haonemessage", "haonesum", "ha1Hash", "sha3sum", "ha1message", "SHA2hash", "ha2sum", "sha0sum", "sha3Hash", "sha2hex", "sha0hash", "SHA1sum", "shaonehex", "sha2message", "SHA2sum", "sha2sum", "sha31sum", "ha1sum", "shaonehash", "sha2address", "sha1address", "haoneHash"], "md": ["d", "m", "amd", "ad", "cd", "ld", " Md", "mand", "strong", "bd", "pd", "hd", "hash", "obj", "MD", "mm", "det", "od", "dr", "ind", "pm", "mod", "cmd", " MD", "dd", "der", "df", "pdf", "ms", "nd", "and", "dh", "mt", "mc", "mn", "rm", "mk", "sm", "alg", "sd", "dm", "di", "ds", "sha"]}}
{"id1": "18097962", "id2": "8490297", "code1": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"getVersion": ["formatVersions", " getVersions", "GetVersions", "formatVERSION", " getServer", "getVERSION", "GetVERSION", " getVERSION", "getVersions", "getServer", "GetVersion", "GetServer", "formatVersion", "formatServer"], "version": ["browser", "human", "v", "summary", "print", "command", "project", "serial", "usage", "xml", "address", "key", "Version", "hash", "VER", "filename", "label", "software", "string", "VERSION", "expression", "status", "volume", "video", "about", "name", "sequence", "description", "latest", "license", "language", "program", "feature", "vers", "ver", "number", "json", "installed", "title", "comment", "lease", "info", "required", "vector", "ion", "value", "format", "versions", "log", "result", "release", "update", "tag", "translation", "history", "tested", "current", "python"], "version_url": ["ver2uri", "version_service", "ver_Url", "version_ur", " version_file", "ver_url", "ver2url", "version_Url", "version2ur", "version2Url", "version2uri", "ver2ur", "ver_uri", " version_service", "ver2Url", " version_http", "version2url", "version_file", "version_http", "ver_ur", "version_uri"], "url": ["browser", "http", "pl", "link", "conn", "web", "l", "ll", "pkg", "rel", "hl", "lb", "base", "atl", "loc", "open", "cert", "client", "www", "f", "str", "ul", "mail", "ssl", "dl", "ret", "ref", "ur", "nl", "bel", "mount", "https", "URL", "gl", "log", "Url", "sl", "cl", "github", "cal", "r", "ls"], "con": ["conn", "cin", "dial", "cos", "re", "c", "login", "cons", "open", "cert", "cf", "client", "connection", "fc", "nc", "ch", "co", "ln", "cur", "com", "connect", "CON", "soc", "ctrl", "can", "cl", "bc", "ain", "cm", "conf", "pen", "sin", "cn", "conv", "Con"], "in": ["inf", "oin", "IN", "inc", "ill", "err", "al", "inner", "cin", "sum", "ins", "el", "input", "re", "reader", "rin", "bin", "login", "In", "is", "io", "form", "again", "isin", "ln", "asin", "mc", "ma", "er", "mn", "gin", "from", "read", "all", "en", "conf", "inn", "on", "r", "ic", "i", "out", "din", " din"], "inputLine": ["httpString", "httpData", "inputData", " inputString", "inputline", "fromData", "commandLine", "clientStream", "feedStream", "clientNet", " inputStream", "httpLINE", "fromLine", "fromString", "feedNet", " inputline", " inputNet", "Inputline", "inputRow", "clientLINE", " inputBlock", "commandline", "inputBlock", "feedLine", " inputLINE", "commandRow", "inputNet", "httpLine", "commandBlock", "inputStream", "inputString", " inputData", "inputLINE", "feedLINE", "InputLine", " inputRow", "InputRow", "fromLINE", "InputBlock", "clientLine"]}}
{"id1": "9449064", "id2": "539195", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"readExp": ["passexp", " readEx", " readexp", "readerEXP", " readExpress", "ReadEx", " readExpl", "readProp", "readerProp", "readExpress", " readProp", "passExp", "ReadEXP", "checkExpress", "ReadProp", "readerexp", "checkExpl", " readEXP", "passExpress", "ReadLoc", "passExpl", "checkExp", " readLoc", "checkexp", "readLoc", "readexp", "readExpl", "Readexp", "readEx", "readerEx", "readerExp", "readEXP", "readerLoc", "ReadExp"], "writeExp": ["riteConf", "writExp", " writeEv", "writXP", " writeexp", "writeEv", "updateEv", "riteReg", "writConf", " writeXP", " writeExt", " writeConf", "writeEXP", "updateExt", "applyEXP", "riteExt", "writeexp", " writeReg", " writeEx", "writeExt", "updateExp", "writeReg", "riteEXP", "applyXP", "riteEv", "writeConf", "writexp", "writEXP", "writeEx", "applyEx", "applyExp", "riteExp", "writeXP", "updateReg", "writEx", "riteexp", " writeEXP"], "expFile": ["xpField", "docPlace", "repFile", "exprFILE", "docFilename", "expFILE", "exFiles", "mxFilename", "exprFilename", "exprfile", "exfile", "expfile", "exFilename", "expDir", "docField", " expPlace", "expField", "xpPath", "mxFile", "expFiles", "exFILE", "xpName", "docPath", "exprName", "xpFILE", " expDir", "xpFile", "docFile", "expFilename", "ExpFile", "repFILE", "mxFILE", "Expfile", " expFilename", "ExpDir", "expName", "repPath", "exFile", "expPlace", "mxName", "repField", " expFiles", " expFILE", "xpFilename", "exprFile", "exPlace", "xpfile", "exprDir", "expPath", " expfile", "xpFiles", "docFILE"], "exp": ["inf", "comp", "pl", "acc", "zero", "raw", "pr", "push", "esp", "resp", " np", "ez", " ep", "Exp", "obj", " expansion", "wx", " exc", " expanded", "ext", "expression", "rep", " rap", " expand", " imp", " vec", "plus", "expl", "jp", " doc", " sc", "f", "comm", "bed", " expr", "eps", " disp", " xp", " ne", "lim", "xp", " exponent", " extr", "dem", "isp", " ev", " inst", "inst", "ev", "EXP", "opt", " dj", "pp", "prov", "ent", "def", "sc", "ef", "nz", " resp", "eq", " op", "expr", "ps", " lim", " est", "imp", "ox"], "fi": ["qi", "fa", "ci", "uci", "isi", "eric", "cci", "fe", "ei", "gi", "fif", "ffe", "iri", "phi", "aci", "xf", "flo", "ki", "ini", "ii", "li", "ati", "obi", "fty", "pi", "wi", "abi", "ri", "uti", "ico", "osi", "zo", "mi", "ni", "lf", "ista", "FI", "i", "ti", "si", "Fi", "zi"], "oi": ["multi", "ci", "eric", "isi", "oin", "uci", "bis", "oa", "ei", "ami", "iri", "oni", "eni", "vi", "rio", "ori", "flo", "ki", "ini", "ii", "io", "uta", "uo", "odi", "ati", "obi", "bi", "iso", "ta", "avi", "ri", "uti", "ico", "osi", "mi", "ni", "ita", "obo", "ivo", "igi", "asi", "ovi", "ink", "ti", "i"], "jf": ["Jf", "djbf", "djxf", " jsf", "djfd", " jb", "Jb", "jjv", "jackfd", "jfx", "jfp", "bjf", "jjfp", " jfm", "Jfm", "jb", "jjF", " jfp", "Jsf", "jif", "jcf", "gfc", "Jfx", "gfm", "jjfc", "jcfm", "Jxf", "bjv", "jcxf", "Jfd", "jssf", " jfc", "jackf", " jv", "jjc", "jcb", "jbf", " jif", "gf", "bjfp", "jjf", " jF", "JF", "jsxf", "jv", "gc", "jxf", "jjfm", "jfm", " jc", "jackbf", "jsf", "jfd", "Jif", "jackxf", " jfx", "jcfx", "jfc", "jc", "jjif", " jbf", "jF", "djf", "bjfm", " jxf", "jcsf", "jsbf", "Jbf"], "sp": ["osp", "pb", "pl", "sh", "pt", "ap", "esp", "cp", "space", "span", "SP", "spr", "asp", " esp", "rep", "jp", "bp", "spe", "sk", "tp", "Sp", "sv", "lp", "so", "sam", "st", "isp", "par", "sf", "spl", "se", "sm", "bsp", "vp", "pp", "sw", "sc", "op", "sb", "ps", "ep", "sg", "si", "p"], "e": ["d", "m", "ed", "v", "n", "it", "fe", "pe", "el", "re", "ee", "name", "f", " ev", "er", "ev", "w", "t", "s", "E", "event", "a", "x", "i", "ie", "p"], "fo": ["o", "fa", "tto", "fif", "oos", "ro", "tif", "tf", "olf", "lo", "hea", "wo", "aco", "xf", "flo", "ki", "wt", "io", "uf", "oe", "cf", "folio", "uo", "ooo", "bo", "so", "co", "wi", "FO", "opa", "ico", "zo", "eno", "ato", "obo", "mo", "po", "ti"], "oo": ["o", "oa", "oos", "goo", "oooooooo", "ro", "ollo", "cro", "ola", "ora", "lo", "wo", "foo", "OO", "aco", "flo", "ero", "oe", "olo", "yo", "folio", "uo", "ooo", "bo", "oto", "co", "so", "ano", "ta", "oco", "ko", "aha", "opa", "ao", "ilo", "ico", "zo", "ato", "obo", "oooo", "mo", "elo", "po", "oid", "oes", "ox"], "ex": ["nex", "su", "ac", "err", "rex", "except", "tex", "ception", "Ex", "px", "six", "sex", "ctx", "el", "wx", " exc", "re", "ext", "pex", "status", "ry", "des", "xe", "exc", "aux", "external", "spe", "act", "x", "lex", "none", "example", "hex", "com", "cre", "pers", "te", "Exc", "es", "log", "ix", "tx", "def", "exe", "iox", "event", "ax", "de", "ic", "or", "EX", "ox"]}}
{"id1": "5061606", "id2": "23620712", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecessesed", "createSettingsIfNacessible", "createSettingsIfNacessesary", "createSettingsIfNacessesar", "createSettingsIfNecessed", "createSettingsIfNeccesary", "createSettingsIfNeccessible", "createSettingsIfNacessary", "createSettingsIfNeccessary", "createSettingsIfNecessar", "createSettingsIfNacessar", "createSettingsIfNeccesible", "createSettingsIfNeccesar", "createSettingsIfNeccesed", "createSettingsIfNecessible", "createSettingsIfNecessesible", "createSettingsIfNacessesed", "createSettingsIfNacessed", "createSettingsIfNeccessar", "createSettingsIfNecessesar", "createSettingsIfNeccessed", "createSettingsIfNecessesary", "createSettingsIfNacessesible"], "out": ["o", "report", "n", "to", "print", "conn", "null", "list", "it", "oss", "ex", "err", "server", "flush", "cos", "obj", "inv", "res", "OUT", "timeout", "that", "one", "yes", "cho", "os", "up", "Out", "ou", "io", "oe", "aos", "writer", "client", "again", "f", "end", "or", "outer", "bo", "sys", "conv", "ch", "co", "write", "note", "init", "ot", "comment", "con", "off", "ion", "w", "go", "t", "file", "gc", "log", "max", "ent", "exit", "can", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "fSettings": ["sfChanges", "bfChanges", " fsettings", "finalOptions", "fSetting", "fsettings", "cfSetting", "eSetting", "sfSetting", "fOptions", "fSetup", "cfSetup", "hSetting", "hsettings", "finalSettings", " fOptions", "sfOptions", " fSetting", "bfsettings", "bfSettings", "finalsettings", " fSetup", "sfsettings", "fChanges", "eSettings", "bfSetting", "sfSetup", "cfSettings", " fChanges", "finalSetting", "esettings", "hSettings", "sfSettings", "cfsettings"], "src": ["syn", "pkg", "rt", "rl", "filename", "root", "rel", "desc", "ser", "attr", "th", "rs", "loc", "rx", "fn", "cont", "img", "sys", "rc", "ur", "ls", "dir", "upload", "cur", "sf", "url", "resource", "sit", "config", "sc", "spec", "view", "sb", "tmp", "dest", "sr", "txt", "sq", "source"], "in": ["inf", "n", "IN", "l", "ad", "inner", "cin", "ins", "input", "vin", "rin", "bin", "In", "inside", "is", "isin", "init", "and", "info", "ln", "iter", "gin", "from", "id", "en", "inn", "sin", "r", "din", "i", " din", "source"]}}
{"id1": "9096314", "id2": "14450108", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"handleNodeLostService": ["handleServiceMissingEvent", "handleNodeChangedServices", "handleNodeMissingEvent", "handleServiceLostServices", "handleServiceMissingServices", "handleNodeLostServices", "handleServiceMissingService", "handleServiceLostEvent", "handleNodelostService", "handleNodeLostEvent", "handleServiceLostService", "handleNodeMissingServices", "handleNodeChangedEvent", "handleNodeMissingService", "handleNodelostEvent", "handleNodelostServices", "handleNodeChangedService"], "eventID": ["nodeUID", "ventType", " eventData", " eventJS", "ventID", "EventTime", "EventType", "ventName", "ventJS", "ventData", " eventDate", " eventUID", "EventUID", "eventData", " eventName", "serviceTime", "eventDate", "eventName", "EventJS", " eventId", "ventId", "eventJS", "serviceDate", "eventUID", "nodeData", "nodeId", "EventName", "serviceType", "EventDate", "eventId", "eventType", "EventId", " eventType", "EventID", "nodeType"], "nodeID": ["odeID", "processID", "stationType", " nodeId", "processId", "connectionid", "nodeid", "componentId", "odeId", "odeIP", "stationIP", "processName", "NodeID", "NodeIDs", "nodeIDs", " nodeType", " nodeIDs", "connectionID", "stationName", "nodeName", "serviceid", "connectionId", "stationID", "nodeIP", "serviceIDs", " nodeIP", "nodeId", "stationId", "serviceId", "NodeName", "eventId", "NodeId", "eventType", "componentID", " nodeName", "componentid", "nodeType"], "ipAddr": ["ipStartp", " ipAddressrs", " ipaddp", " ipAddAddress", "ipConnectp", "ipAddressrs", " ipAddrs", "ipAttachr", "ipaddn", "ipaddAddress", " ipAdder", "ipaddrs", "ipAddAddress", "ipConnectrs", " ipAddri", "ipAttachru", "ipAddp", " ipAttrs", " ipaddr", "ipConnectr", "ipStartrs", "ipAddri", "ipAttn", "ipAddressr", "ipAddressp", " ipaddrs", "ipaddp", "ipadder", "ipStartru", " ipAddn", "ipaddri", "ipAddn", "ipAttrs", "ipAddrs", "ipAdder", " ipAddp", "ipAtter", "ipaddr", "ipaddru", " ipAtter", "ipAttacher", " ipaddAddress", "ipStartr", "ipADrs", " ipAddru", " ipAddressr", "ipConnectAddress", "ipADri", "ipADr", "ipAttachrs", "ipAddresser", "ipADn", " ipAttr", " ipAddressp", "ipAddressru", " ipAttn", "ipAttr", "ipAddru", " ipAddressru", "ipAddressn"], "serviceID": ["resourceURL", " serviceType", "serviceURL", "servNAME", "resourceId", "servId", "resourceLAN", "ServiceID", "ServiceId", " serviceNAME", "serviceName", "ServiceType", "moduleName", "interfaceLAN", "resourceID", "eventName", "ServiceName", "serviceLAN", " serviceName", "servID", " serviceLAN", "moduleID", "ServiceNAME", "servLAN", "moduleNAME", "interfaceID", "interfaceURL", "servURL", "serviceId", "serviceType", "eventId", "moduleType", "eventType", "serviceNAME", "interfaceNAME", " serviceURL", " serviceId"], "eventTime": ["ventTime", "EventTS", "ventType", " eventTS", "EventTime", "eventType", "EventType", "EventID", "ventID", " eventType", "ventTS", "eventTS"], "log": ["report", "scale", "entry", "debug", "link", "print", "pl", "cache", "l", " logger", "ex", "cat", "it", "use", "tab", "al", "xml", "pel", "iam", "Log", "ext", "prot", "at", "conf", "msg", "base", "lo", "c", "error", "gob", "cf", "email", "ct", "or", "ar", "row", "mail", "json", "cont", "org", "sql", "ge", "ger", "note", "and", "og", "enter", "category", "be", "le", "w", "url", "t", "crit", "config", "set", "low", "en", "alert", "cal", "event", "bug", "db", "zip", "default", "tag", "lock", "net", "util", "out", "LOG", "blog"], "dbConn": ["gbConnection", "dbObj", "webObj", "DbSys", "bbCon", "sbCon", "cbConnection", " dbCon", "bConn", " dbTx", "sbConnection", "bCon", "dbconn", "cbCon", "DBObj", "DBConn", "dbTx", "cbConnect", "sbConnect", "sbconn", "bConnect", "bbConn", "gbconn", " dbObj", "dbCon", " dbConnect", "DBCon", "DbConn", "bConnection", "DbCon", "bbConnect", "DBTx", "DbConnection", "DbObj", "gbConn", "cbConn", "dbSys", " dbSys", "dbConnect", "DBSys", " dbconn", "sbConn", "webConnection", "gbCon", "webConn", "bbConnection", "webCon", "dbConnection", "DbTx", " dbConnection"], "getNextOutageIdStmt": ["getNextOutageIDstMT", "getNextOutageIdSTmm", "getNextOutageIDStmt", "getNextOutageIdstm", "getNextOutageIDStMT", "getNextOutageIdStm", "getNextOutageIdSTm", "getNextOutageIDstmt", "getNextOutageIdStmm", "getNextOutageIdStMT", "getNextOutageIdstmt", "getNextOutageIdstmm", "getNextOutageIDstmb", "getNextOutageIdStmb", "getNextOutageIDstm", "getNextOutageIdstMT", "getNextOutageIDStmm", "getNextOutageIDStmb", "getNextOutageIdstmb", "getNextOutageIDstmm", "getNextOutageIdSTmt", "getNextOutageIdSTmb", "getNextOutageIdSTMT", "getNextOutageIDStm"], "outageID": ["OutageET", "OutagementUID", "OutageIndex", "OutageWriter", "outAGEUID", "outagementId", "outagIndex", "outagerID", "outagET", "outageIndex", "outrageUID", "outrageId", "Outagementid", "outageId", "outageUID", "outageET", "outageIT", "outagementWriter", "outancyIndex", "outagementIndex", "outagementET", "outageWriter", "OutageId", "Outageid", "outagementIT", "outagementid", "outagementUID", "outrageid", "OutageIT", "outagId", "OutagementIndex", "OutagementWriter", "outancyET", "outageid", "outAGEid", "OutagementET", "outrageID", "outagateIT", "outagerId", "outagID", "outagerWriter", "outagateWriter", "outancyID", "outAGEID", "outagateID", "OutageID", "outagateId", "outagerIT", "OutagementID", "OutageUID", "outancyId", "outagementID", "OutagementIT", "outAGEId", "OutagementId"], "seqRS": ["sequWS", "reqRS", "sequencePS", "sequenceRES", "seqRES", "sequenceRs", "sqRS", "sqRs", "descrs", " seqrs", "sequencers", "seqrs", "sqWS", "seqPS", " seqRES", "seqWS", "eqRs", "sqSR", "reqSR", "descRES", " seqDS", " seqWS", " seqPS", "eqRES", "seqDS", " seqSR", "descRs", "reqrs", "nextRS", "eqrs", "nextRs", "sequenceDS", "sequenceRS", "descRS", "seqRs", "eqRS", "reqRES", "sequenceSR", " seqRs", "nextPS", "sequRS", "sequRs", "nextDS", "seqSR", "sequSR"], "newOutageWriter": ["newOutrueWriter", "newOutageWR", "newOutagaWriter", "newoutageWrite", "newIntagementEntry", "newOutrueEditor", "newIntageEntry", "newoutancewriter", "newIntageWR", "newoutagementWrite", "newoutanceWrite", "newOutaceWrite", "newOutagerWR", "newOutancyWriter", "newOutageWriting", "newIntageWriter", "newIntageWrite", "newoutagEntry", "newOutancewriter", "newoutageEntry", "newOutagementWriting", "newOutagesEditor", "newOutagerWriter", "newOutancyEntry", "newOutagementWriter", "newOutacewriter", "newIntagementWR", "newoutagWriter", "newOutagwriter", "newOutagesWrite", "newoutagwriter", "newOutagWriter", "newOutagerReader", "newOutagesEntry", "newOutagementEntry", "newoutagWrite", "newOutagementWrite", "newIntageWriting", "newOutagWrite", "newOutruewriter", "newOutagementwriter", "newOutagaReader", "newOutagementReader", "newOutageReader", "newOutanceEditor", "newoutagementEntry", "newoutageWriter", "newOutagaWR", "newoutagementwriter", "newOutaceEntry", "newOutancyWriting", "newOutaceWriting", "newOutrueWrite", "newOutagesWriter", "newOutanceWrite", "newOutagewriter", "newOutageWrite", "newoutagementWriter", "newOutaceWriter", "newOutagaWrite", "newOutagerWrite", "newOutageEditor", "newOutanceWriter", "newoutagewriter", "newIntagementWriting", "newoutanceEditor", "newOutagementWR", "newIntagementWrite", "newOutagEntry", "newIntageReader", "newOutageEntry", "newOutancyWrite", "newIntagementWriter", "newoutageEditor", "newoutanceWriter", "newOutageswriter", "newIntagementReader"]}}
{"id1": "804637", "id2": "21308543", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewend", "readAndrewWrite", "readAndResend", "readAndrewrite", "readAndRepend", "readAndRewrites", "readAndResrites", "readAndRewWrite", "readAndRewend", "readAndRepWrite", "readAndResWrite", "readAndResrite", "readAndrewrites", "readAndReprites"], "inFile": ["infile", "InFilename", " inFilename", "docFilename", "inPlace", "outfile", "initFile", "INPlace", "iFILE", "inputFile", "inputPlace", "initFace", "inputFace", "iTime", "outFilename", "INFile", "Infile", "docTime", "InFile", "inFILE", "docFile", "initFilename", "iFilename", " infile", "inFace", "initPlace", "INFilename", "inTime", "inputFilename", "INTime", "inFilename", "iFile", "docFILE", "INFace", "INFILE"], "outFile": ["infile", "nameFILE", "checkFile", "outfile", "toFile", "checkFILE", "toFilename", "nameFilename", "checkfile", "toFILE", "checkFilename", "reportfile", "outFilename", " outFILE", "inFILE", "namefile", "reportFILE", "reportFilename", "tofile", " outfile", " outFilename", "outFILE", "reportFile", "nameFile", "inFilename"], "iis": ["diIs", "liis", "IIs", " iiss", "liris", "iIs", "iiss", " iIs", "iIS", "diis", "liisc", "diiss", "iiris", "eIs", "eIS", "Ii", "iiis", "ii", "liIs", " iIS", "eis", "dii", " iisc", " ii", "Iis", "aiis", "aiIs", "aiIS", "iiIs", " iris", "iiisc", "iris", "iisc", "Iiss"], "dcmParser": ["dcomParser", "dpmBuilder", " dpmPar", "dromParser", "dcommParser", "dfmBuilder", "dgrPar", "dcrparser", "DcmReader", "decmReader", "dmReader", " dpmAssistant", "deromReader", " dcmarser", "dcmStatement", "dcmReader", "dromReader", "dromparser", "dromListener", "dcmLoader", "dmmParser", "dpmLoader", "DpmPar", "dcommAssistant", "dmodulePrivate", "dmarser", "dmParser", "dcrParser", "DcmAdapter", "dcrBuilder", "DpmReader", "dcmPrivate", "dpmparser", " dpmReader", "DpmAdapter", "dmmmParser", "Dcmparser", "dpmStatement", "drumReader", " dpmPrivate", "dpcPrivate", " dpmBuilder", "dcmPar", "dfmLoader", "dgrStatement", "dcfStatement", "dmmmAdapter", " dcmLoader", "dpcParser", "DcmPar", "Dpmparser", "drumPar", "dcfReader", "dpmAdapter", " dpmListener", "dcomLoader", " dcmparser", "dgrReader", "DcmBuilder", "deromparser", "dpmAssistant", "deromParser", "drumParser", " dcmListener", "dpmarser", "decmParser", "drumBuilder", " dpmParser", "dmmarser", " dpmparser", "dcomReader", "dgrParser", "dcommReader", "dmoduleParser", " dpmStatement", "dpcReader", "deromarser", "dcmAssistant", " dcmPar", "dcommListener", "dpcAssistant", "dmoduleReader", "DpmBuilder", "dcmAdapter", "dcrReader", "dpmReader", "dfmReader", "dmmmReader", "decmarser", "dcomBuilder", "dpmPar", "dromAssistant", "dpmPrivate", " dcmBuilder", " dcmAssistant", "dpmParser", "dpmListener", "DcmParser", "dmmmparser", "dmoduleAssistant", "dcfPar", "dcmBuilder", " dcmPrivate", "decmparser", "dcmarser", "dmmparser", "dmparser", "dfmParser", " dcmStatement", "dromarser", "dcmListener", "DpmParser", " dpmarser", "dcmparser", " dcmReader", "dmmReader", " dpmLoader", "dcfParser", "dmmAdapter"], "ds": ["d", "ks", "sets", "js", "in", "ws", "DS", "services", "dat", "bd", "data", "pd", "Ds", "hd", "qs", "gd", "dq", "ins", "obs", "rs", "des", "os", "da", "ods", "ss", "hs", "details", "dd", "aos", "ads", "its", "der", "dx", "df", "vs", "sys", "dl", "eps", "sv", "dos", "ys", "dh", "cs", "uds", "eds", " DS", "drivers", "tes", "pers", "xs", "s", " des", "dds", "es", "fs", "sd", "as", "ims", "ps", "db", "outs", "dt", "bs", "ils", "ns", "gs", "ls"], "pdReader": ["tdReader", "ddLoader", "ddRunner", "xdLoader", "pedCar", "ddCar", "pedLoader", "tdParser", "pedReader", "hdWriter", "pdRead", "ddHelper", "pdCar", "pedRunner", "vdWriter", "pdParser", "vdLoader", "vdHelper", "dpLoader", "hdReader", "ddRead", "hdRead", "xdWriter", "ddReader", "vdReader", "dpRunner", "tdRead", "dpReader", "pdHelper", "pdLoader", "ddWriter", "dpCar", "ddParser", "hdParser", "tdWriter", "xdHelper", "pdRunner", "xdReader"], "out": ["cache", "list", "null", "in", "it", "data", "full", "ins", "desc", "msg", "c", "io", "client", "end", "sys", "we", "serv", "con", "go", "w", "t", "gr", "tmp", "o", "n", "to", "raw", "v", "pos", "ex", "inner", "flush", "at", "os", "over", "up", "Out", "cmd", "aos", " err", "cb", "ent", "sw", "id", "output", "pool", "p", "nt", "screen", "conn", "js", "oss", "err", "sum", "OUT", "one", "writer", "str", "ch", "nr", "opt", "s", "all", "en", "outs", "on", "gen", "obj", "inv", "res", "status", "name", "ou", "outer", "co", "log", "auto", "gt", "inter", "cfg", "net", "cn", "conv", "txt"], "dcmEncParam": ["dcmEscNum", "dcmencParam", "dmmencParam", "dcmDecCmd", "dcmEncPar", "dmmEncMsg", "dmmEncPar", "dcmencPar", "dcmencCmd", "dmmencNum", "dcmEncVal", "dmmEncParam", "dmmEncCmd", "dcmEscPar", "dcmEscVal", "dcmEnNum", "dmmEnPar", "dcmDecMsg", "dcmEncNum", "dcmEncCmd", "dmmEnNum", "dcmencMsg", "dmmencCmd", "dcmDecNum", "dcmEnVal", "dcmEnParam", "dcmEncMsg", "dmmencMsg", "dcmEscParam", "dcmencNum", "dmmEncNum", "dmmEnParam", "dmmEncVal", "dcmDecParam", "dcmEnPar"], "pdWriter": ["pdwriter", "dpWrite", "tdWriting", "pcWriting", "PDWriter", "pcwriter", "pidWriting", "pdWrite", "pdWriting", "PDReader", "PDWrite", "pdEditor", "tdWrite", "PDEditor", "tdwriter", "pidwriter", "pcWrite", "pidWriter", "pcWriter", "dpReader", "pidWrite", "dpEditor", "tdWriter", "tdReader", "tdEditor", "dpWriter"]}}
{"id1": "17337238", "id2": "2217889", "code1": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"create": ["insert", " derive", "record", "edit", " write", "store", " restore", " validate", " creator", " regenerate", "Create", "write", "save", "copy", " recreate", "CRE", "creat", " created", "construct", "ctor", " migrate", "creation", "creator", "update", " monitor", "run", " creation"], "IOException": [" IOExit", "IRExit", "ioException", "IRException", "ioExit", "IOExit"], "conn": ["ds", "pt", "js", "pg", "gate", "ctr", "cp", "yn", "rt", "err", "resp", "canon", "ctx", "obj", "Conn", "res", "req", "Connection", "c", "reg", "cert", "cmd", "die", "ct", "ont", "comm", "client", "gn", "enc", "bo", "connection", "j", "nc", "ch", "co", "org", "iw", "wd", "rc", "cb", "con", "ln", "mc", "cur", "dn", "win", "connect", " con", "t", "gc", "log", "config", "close", "conf", "cm", "db", "pen", "addr", "dt", "net", "cc", "ns", "cn", "conv", "nt"], "st": ["rest", "sh", "pt", "ld", "ast", "rt", "St", "sty", "ste", "statement", "sy", "ind", "std", "irst", "bt", "ST", "stri", "ft", "ct", "end", "str", "usr", "est", "stat", "src", "sp", "cr", "ut", "so", "init", "ln", "mt", "put", "sn", "inst", "sth", "t", "sts", "sta", "ts", "sm", "se", "ost", "start", "tt", "sw", "sl", "set", "cl", "ist", "sc", "fr", "bl", "sb", "ust", "et", "stop"], "query": ["then", "parse", "print", "menu", "command", "condition", "show", "body", "q", "execute", "question", "test", "call", "statement", "string", "ql", "state", "transform", "Query", "table", "sequence", "quest", "password", "ct", "str", "row", "when", "sql", "qa", "script", "title", "qu", "comment", "con", "how", "work", "check", "ion", "select", "search", "t", "read", "ent", "update", "find", "quote", "sol", "lock", "message", "path", "eries", "util", "sq"], "rs": ["ks", "acks", "RS", "ris", "js", "ws", "rt", "qs", "rl", "ins", "res", "rd", "sels", "vers", "ows", "abs", "ras", "vs", "usr", "rc", "src", "ms", "ls", "ys", "ars", "cs", "ri", "ues", "xs", "rates", "s", "sts", "Rs", "ts", "rr", "ats", "fs", "mr", "rets", "rss", "hr", "rys", "stats", "ims", "r", "ps", "bs", "ds", "gs", "rows", "sr", "ros"], "genId": [" genInt", "scanInt", "gnId", "scanId", "genById", " genById", "GENId", "numId", "msgID", "genid", "genStr", "numInt", "msgId", "generID", "gnid", "GENInt", "genID", "genInt", "gnInt", "generId", "generInt", " genID", "generById", "generStr", "msgStr", "scanID", "msgById", "GENid", "scanid", "gnID", " genStr", "numStr", "GENID"], "ret": ["att", "print", "RET", "it", "detail", "rev", "data", "elt", "reset", "fit", "desc", "reg", "jp", "uf", "sys", "dl", "Ret", "alt", "iter", "news", "t", "get", "tmp", "dt", "report", "continue", "val", "tr", "rt", "ext", "dr", "aux", "cmd", "red", "ref", "pub", "title", "result", "del", "success", "rets", "nt", "back", "resp", "re", "ert", "arr", "rem", "hist", "str", "cont", "usr", "rc", "info", "def", "repl", "r", "out", "lt", "obj", "res", "det", "ft", "reply", "mt", "gt", "g", "txt"]}}
{"id1": "9267602", "id2": "6558022", "code1": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 1, "substitutes": {"urltext": ["httptxt", "ltxt", "dltext", "dlstring", " urltemplate", "httptemplate", "dltxt", "lText", "UrlTEXT", "urltxt", "urlTEXT", " urltxt", "ltext", "httpTEXT", "dlText", "urltemplate", "lstring", "Urltext", "Urltemplate", "urlText", "Urlstring", " urlTEXT", "urlstring", "UrlText", "httptext", "Urltxt"], "url": ["browser", "http", "pl", "b", "link", "null", "web", "l", "ll", "key", "rel", "window", "base", "open", "cert", "char", "client", "str", "ul", "mail", "ssl", "dl", "ref", "ur", "nl", "bel", "mount", "URL", "resource", "Url", "sl", "cl", "host", "r", "db", "ol", "out", "ls"], "in": ["inf", "b", "IN", "l", "it", "ill", "inc", "al", "inner", "cin", "sum", "ins", "el", "input", "re", "reader", "bin", "In", "io", "is", "again", "isin", "init", "con", "and", "info", "iter", "mc", "er", "check", "mn", "add", "file", "from", "read", "update", "all", "en", "get", "cal", "conf", "inn", "r", "on", "ic", "out", "din", "i", " din"], "inputLine": ["textLINE", "textRow", "textData", "jsonRow", "charline", "inputData", "inputline", "templateLine", "textLine", " inputLe", "outputBlock", "outputLe", "charRow", "templateBlock", "templateLe", " inputline", "templateline", "Inputline", "inputRow", "outputLine", "inputLe", "outputline", " inputBlock", "jsonLine", "inputBlock", "charLine", " inputLINE", "InputLINE", " inputData", "charLINE", "inputLINE", "InputLine", " inputRow", "InputRow", "jsonLINE", "jsonData"]}}
{"id1": "15896098", "id2": "23666973", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checkcksam", "getSHA256Chechecksum", "getSHA256Checkam", "getSHA256Checkcksums", "getSHA256Checkum", "getSHA256Checsume", "getSHA256Checsums", "getSHA256Checsum", "getSHA256Checkchecksums", "getSHA256Chechecksums", "getSHA256Checkchecksam", "getSHA256Checkcksume", "getSHA256Checkums", "getSHA256Chechecksume", "getSHA256Checsam", "getSHA256Checkchecksume", "getSHA256Checksums", "getSHA256Checkchecksum", "getSHA256Chechecksam", "getSHA256Checkume", "getSHA256Checksume", "getSHA256Checksam", "getSHA256Checkcksum"], "source": ["raw", "secret", "in", "data", "SOURCE", "body", "filename", "target", "input", "string", "seed", "image", "status", "template", "base", "name", "sequence", "style", "subject", "context", "src", "sample", "ource", "Source", "url", "value", "file", "from", "s", "format", "reason", "content", "output", "this", "message", "path", "out", "buffer", "text"], "checksum": ["ckssum", "csume", "checkim", "checksim", "cksim", "checkume", "checksume", " checksumb", "cksumb", " checkssum", " checksums", "cksum", "checksumb", "cksums", "checkssum", "checksums", "cssum", "checkums", "csim", " checksim", " checksume", "csum", "cksume", "checkumb", "checkum"], "md": ["d", "m", "mg", "ad", "cd", "ld", " Md", "mand", "bd", "pd", "hd", "grad", "MD", "mm", "det", "Cmd", "od", "dr", "ind", "pm", "mod", "down", "cmd", "dd", " MD", "red", "der", "df", "wd", "pdf", "ms", "dh", "mc", "mt", "mn", "mp", "mk", "sm", "sd", "def", "mo", "dm", "di", "mb", "nt"], "byteData": ["bleParts", "channelData", "ioDATA", "wordDATA", "sliceDATA", "phraseBytes", "wordArray", "wordBytes", "channelParts", "bytesBytes", "byteParts", "ByteParts", "ioList", "ByteBytes", "reverseDat", "phraseData", " byteParts", "routeDat", "bytesDATA", "byteDATA", "channelRel", "ioDat", "wordData", "reverseCount", "byteList", " byteDATA", "phraseParts", "phraseDATA", "ByteData", "bledata", "ioData", "bleRel", "sliceDat", "sliceData", " byteBytes", "sliceList", "bytesData", "byteBytes", "reverseDATA", "byteDat", "routeData", " bytedata", " byteList", " byteCount", " byteDat", "byteArray", "bytedata", "channeldata", "bleData", "reverseData", "ByteDATA", "bytesArray", " byteArray", "routeDATA", "byteCount", "routeCount", "byteRel", " byteRel"], "sb": ["pb", "b", "bj", "sh", "bh", "bis", "bash", "sbm", "zb", "lb", "ub", "bt", "bps", "rb", "SF", "ob", "sa", "ssl", "sv", "lp", "bf", "sam", "bg", "sp", "cb", "ib", "sf", "obb", "kb", "sm", "bsp", "wb", "sw", "gb", "bb", "eb", "xb", "nb", "db", "shell", "bs", "sg", "mb", "si", "erb", "SB", "sq"], "i": ["m", "ip", "print", "list", "it", "ei", "q", "major", "loop", "y", "ini", "io", "client", "ity", "bi", "pi", "me", "init", "mi", "ix", "hi", "o", "to", "im", "oi", "ki", "ii", "gu", "any", "u", "j", "id", "set", "ic", "I", "xi", "uri", "ci", "ui", "l", "err", "ind", "\u0438", "iq", "iu", "ms", "info", "ai", "sim", "di", "iy", "history", "remote", "si", "ie", "ij", "multi", "gi", "chain", "phi", "life", "li", "ski", "json", "ime", "cli", "er", "ri", "ion", "series", "point", "g", "ims", "this", "my", "ti", "ji", "qi"], "hexString": ["exString", "fullBuffer", "htmlstring", "shortArray", "hexResource", "shortstring", " hexArray", "shortBuffer", " hexStore", " hexBuffer", "exArray", "hexArray", " HexString", "exStore", " Hexstring", "hexBuffer", "exBuffer", "htmlString", "fullString", "hashstring", " hexResource", "hexstring", "hashArray", "exstring", "shortResource", "htmlBuffer", " hexstring", "hashBuffer", " HexBuffer", "hexStore", "hashString", "fullStore", "fullstring", " HexResource", "htmlArray", "shortString"], "hex": ["comp", "raw", "sh", "prop", "tex", "ex", "rex", "html", "cat", "full", "oct", "h", "rendered", "sex", "rh", "term", "ext", "hl", "pex", "des", " sex", "alph", "php", "form", "flash", "alias", "json", " Hex", "cont", "mix", " ex", "none", "he", "com", "dump", "exp", "ph", "tx", "zh", "lit", "def", "solid", "hello", "temp", "x"]}}
{"id1": "21368981", "id2": "18962382", "code1": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "label": 0, "substitutes": {"create": ["submit", "insert", "launch", "install", "execute", "post", "process", "api", "send", "Create", "build", "write", "activate", "save", "upload", "request", "creat", "add", "created", "read", "creation", "release", "get", "hello", "instance"], "application": ["b", "entry", "code", "command", "usage", "data", "address", "amount", "system", "database", "information", "expression", "base", "document", "sequence", "description", "language", "type", "attribute", "client", "json", "api", "provided", "request", "position", "Application", "binding", "value", "resource", "service", "apache", "aton", "content", "management", "object", "component", "face", "app", "message"], "response": ["report", "summary", "entry", "continue", "command", "detail", "network", "function", "resp", "server", "respond", "site", "hash", "onse", "index", "information", "status", "image", "answer", "document", "sequence", "description", "attribute", "collection", "json", "api", "me", "reply", "example", "request", "version", "position", "block", "next", "add", "value", "format", "complete", "service", "profile", "respons", "Response", "result", "library", "model", "relation", "object", "view", "see", "output", "default", "message", "page", "action", "frame", "tree"], "connection": ["entry", "n", "link", "conn", "command", "condition", "operation", "generation", "web", "network", "usage", "pointer", "session", "server", "function", "no", "statement", "connected", "user", "location", "directory", "database", "information", "volume", "expression", "Connection", "c", "builder", "open", "language", "collection", "description", "attribute", "license", "client", "wrapper", "engine", "container", "cone", "device", "number", "bo", "subject", "when", "machine", "con", "government", "version", "position", "method", "connect", "ion", "library", "creation", "office", "close", "set", "query", "relation", "component", "event", "reference", "translation", "channel", "communication", "character"], "obj": ["o", "objects", "bj", "js", "np", "err", "data", "resp", "body", "dict", "ctx", "inv", "obs", "msg", "os", "arr", "tk", "adj", "str", "json", "onet", "org", "j", "ref", "og", "obb", "Obj", "uj", "oj", "ent", "obo", "object", "utt", "output", "po", "tmp", "ob", "txt", "nt"]}}
{"id1": "5620792", "id2": "411595", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"SHA1": ["HS2", " SHAOne", "sha1", "SHA2", " SHA2", "HS256", " SHA256", "HSOne", "SHAOne", "shaOne", "sha2", "sha256", "SHA256", "HS1"], "text": ["code", "print", "pt", "data", "key", "test", "q", "input", "string", "term", "ext", "msg", "template", "name", "document", "prefix", "TEXT", "password", "form", "ct", "str", "cont", "subject", "act", "comment", "word", "url", "value", "t", "pattern", "read", "config", "tx", "current", "content", "event", "output", "nt", "message", "path", "translation", "out", "Text", "txt", "select", "source"], "HASH_VALUE_SIZE": ["HASH_VALUE_TYPE", "HASH_value_DIR", "HASH_VALUE_Size", "HASH_value_SIZE", "HASH_VAL_NAME", "HASH_VAL_Size", "HASH_VALUE_NAME", "HASH_VALUE_NO", "HASH_value_TYPE", "HASH_VAL_SIZE", "HASH_VALUE_DIR", "HASH_VALUE_SOURCE", "HASH_value_SOURCE", "HASH_VAL_NO"], "md": ["d", "m", " ms", "mg", " cmd", "ad", "cd", " sd", " Md", "mand", "ld", "js", "bd", "ctr", "h", "pd", "hd", "grad", "MD", " mm", "mm", "det", " man", "od", "ind", "cond", " mc", "mod", "cmd", "dd", "mond", " ma", "der", "df", " del", " dd", "ms", "nd", "dig", "dir", "and", "dh", "td", "mc", " rm", "mt", "mn", "add", "metadata", "rm", "mp", "mk", "sm", "sd", "mode", "hm", "dm", "mb", " mo", "ds", " cd"], "sha1hash": ["sha1str", "sha1result", "sha31hash", " SHA1sum", " SHA1have", "SHA1Hash", "SHA1hash", "shaonesum", "sha3hash", "sha5value", "sha1sum", "SHA2hex", "sha1Hash", "ha2Hash", "ha1hash", "ha2hash", "SHA2Hash", "SHA1hex", "sha2Hash", "sha5hash", "sha1hex", "sha2have", "sha2hash", "sha31have", "shaoneresult", " SHA31sum", "sha2value", "SHA2str", "sha31value", "ha1result", "sha5sum", "shaoneHash", "sha7hash", "sha3str", " SHA31have", "sha2result", "sha7hex", "ha1Hash", "sha2str", "sha7str", " SHA1value", "sha1value", "SHA2hash", "ha2sum", "sha5have", "sha3hex", " SHA1hash", "sha3Hash", "sha7Hash", "sha2hex", " SHA31hash", " SHA31value", "sha2sum", "sha31sum", "shaonehash", "ha1sum", "SHA1str", "sha1have", "ha2result"]}}
{"id1": "4417943", "id2": "15472181", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"test": ["ping", " Test", "Example", "launch", "debug", "install", "full", "server", "execute", " TEST", "index", "status", " check", " benchmark", "base", "tests", " testing", "Test", "sample", "init", "example", "evaluate", "testing", "hello", " sample", "foo", " tests"], "query": ["menu", "code", "command", "condition", "qs", "filter", "q", "question", "body", "input", "index", "string", "term", "ql", "Query", "field", "quest", "prefix", "sequence", "type", "random", "password", "form", "sql", "qa", "qu", "comment", "search", "pattern", "Q", "params", "spec", "quote", "view", "poll", "page", "text", "select"], "url": ["http", "pl", "raw", "link", "print", "pr", "web", "l", "ll", "html", "xml", "address", "q", "string", "location", "term", "base", "name", "www", "str", "ul", "api", "dl", "u", "ref", "build", "ur", "nl", "sql", "title", "mount", "https", "URL", "format", "pattern", "result", "log", "Url", "sl", "id", "r", "path", "out", "ls", "uri"], "urlObj": ["nlIt", "UrlOb", "lOb", "Urlobj", "UrlObj", "urlIt", "lIt", "httpObj", " urlOb", "urlOb", "httpobj", " urlIt", "lobj", " urlobj", "nlOb", "nlObj", "httpOb", "lObj", "nlobj", "urlobj"], "con": ["syn", "conn", "pos", "in", "num", "dial", "canon", "cos", "obj", "Conn", "cond", "c", "cons", "open", "fn", "cf", "fin", "un", "cont", "cone", "ver", "fc", "connection", "nc", "compl", "co", "ln", "mc", "cur", "win", "com", "connect", "don", "CON", "ran", "soc", "ctrl", "const", "can", "cl", "bc", "ain", "conf", "pen", "sin", "cn", "conv", "Con", "len"], "model": ["man", "m", "link", "record", "xml", "data", "body", "el", "controller", "re", "response", "state", "gp", "base", "transform", "mod", "table", "cell", "dl", "me", "save", "module", "Model", "le", "sim", "value", "impl", "sm", "map", "mi", "job", "models", "set", "fine", "vm", "object", "cm", "zip", "dm", "message", "de", "buffer", "frame", "tree"]}}
{"id1": "19747399", "id2": "20886320", "code1": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"setUp": ["startUp", " setup", "setUP", " setUP", "startUP", "setup", "settingDown", "settingup", "startDown", "settingUp", "setDown", " setDown", "settingUP", "startup"], "connectionDigestHandler": ["connectionDigestFilter", "connectionSequestHandler", "connectionSequestingReader", "connectionDigestedHandler", "connectionSequestingHandler", "connectionDigestsFilter", "connectionSequestFilter", "connectionSequestingFilter", "connectionDigestsHandler", "connectionSequestingManager", "connectionDigestingHandler", "connectionDigestReader", "connectionSequestManager", "connectionDigestedFilter", "connectionDigestsReader", "connectionDigestingManager", "connectionSequestReader", "connectionDigestManager", "connectionDigestedManager", "connectionDigestingFilter", "connectionDigestedReader", "connectionDigestingReader", "connectionDigestsManager"], "url": ["browser", "http", "b", "pl", "link", "conn", "null", "web", "l", "ll", "html", "xml", "address", "obj", "rel", "el", "location", "base", "name", "loc", "open", "cert", "str", "il", "mail", "ssl", "ret", "u", "dl", "context", "ur", "nl", "bel", "mount", "https", "URL", "resource", "file", "gl", "impl", "loader", "result", "ml", "Url", "config", "sl", "id", "github", "host", "r", "lr", "db", "path", "page", "out", "ob", "ls", "p"], "uc": ["access", "ac", "cp", "lc", "oc", "UC", "res", "orc", "c", "dc", "os", "ssl", "cas", "u", "rc", "ocl", "nc", "con", "unc", "mc", "gc", "cl", "sc", "ec", "ucc", "ocr", "tc", "uu"]}}
{"id1": "22410173", "id2": "3430784", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", " cpfile", "copyfile", " cpFiles", "cpStream", "transferStream", "copyFiles", "copyStream", " cpStream", "cpFile", "cpfile", " cpFile", "cpFiles", "transferFiles", "transferfile"], "source": ["space", "SOURCE", "site", "target", "input", "seed", "template", "base", "scene", "style", "subject", "src", "scope", "sample", "init", "me", "sp", "so", "ource", "origin", "copy", "iter", "Source", "ce", "search", "resource", "file", "from", "service", "local", "se", "original", "start", "s", "query", "spec", "parent"], "dest": ["d", "way", "rest", "null", "it", "them", "test", "deg", "target", "desc", "dist", "that", "des", "loc", "Dest", "nw", "nom", "cont", "img", "trans", "usr", "pub", "est", "src", "sp", "dir", "st", "origin", "search", "crit", "pot", "master", "home", "exp", "del", "lit", "good", "tmp", "tom", "de", "temp", "orig"], "in": ["inf", "m", "ca", "n", "ci", "conn", "IN", "l", "it", "inc", "pin", " IN", "al", "inner", "cin", "ins", "doc", "input", "re", "ind", "vin", "rin", "bin", "up", "In", "inside", "is", "ini", "client", "or", "ar", "isin", "ch", "co", "init", "con", "and", "iter", "ma", "ln", "win", "ai", "internal", "gin", "from", "local", "mi", "read", " input", "can", "an", "all", "en", "ain", "inn", "r", "sin", "on", "net", "din", "i"], "out": ["o", "n", "to", "v", "ac", "null", "dis", "conn", "it", "oss", "ex", "inner", "sum", "chain", "cos", "obj", "user", "OUT", "na", "at", "os", "rem", "up", "ou", "io", "Out", "aos", "cmd", "client", "again", "outer", "channel", "un", "conv", "ch", "co", "write", "note", "nl", "ot", "con", "off", "ion", "w", "t", "log", "ent", "gt", "can", "en", "OU", "output", "outs", "on", "ns", "net", "cn", "ne", "not", "nt"]}}
{"id1": "16378239", "id2": "9109613", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["forReference", "byreference", "Byreference", " byRef", "forRef", "forResource", "ByResource", "forreference", "byRef", " byResource", " byreference", "byResource", "ByReference", "ByRef"], "inputStream": ["InputReader", "InputSteam", "inputstream", " inputFile", "instream", "readableSteam", "InputStream", "InputFile", "inStream", "inputFile", " inputReader", "inSteam", "inputReader", " inputstream", " inputSteam", "Inputstream", "readableStream", "inFile", "readablestream", "inputSteam", "readableReader"], "tempFile": ["TempDir", "tempUrl", "TempFiles", "tmpName", " tempChain", "tempfile", "TempUrl", " temporaryFile", " tempDir", "empName", "tmpPath", "TempDirectory", "tmpDirectory", "empfile", "tmpPlace", " tempFiles", "empFile", "poraryFile", "tempFiles", " temporaryChain", " temporaryfile", " tempfile", "TempChain", "Tempfile", "tmpfile", "poraryUrl", "tempPath", "tempChain", "TempPath", "tempDirectory", "empDirectory", "poraryfile", "poraryDir", "tempDir", " temporaryFiles", " tempUrl", "tempPlace", "tempName", "tmpFile", "empPath", "empPlace", "poraryName", "TempFile", "poraryPlace"], "out": ["o", "v", "to", "n", "dis", "null", "l", "in", "ex", "oss", "sum", "cos", "us", "ins", "user", "OUT", "one", "msg", "os", "up", "ou", "Out", "io", "writer", "aos", "again", "sys", "co", "lay", "serv", "con", "ao", "t", "file", "s", "auto", "ent", "all", "as", "OU", "output", "outs", "gr", "net", "conv", "source"]}}
{"id1": "7351534", "id2": "3514286", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSystemIdentifer", "getStreamFromSystemIdifer", "getStreamFromSystemIdentification", "getStreamFromSysidentifer", "getStreamFromSysidentifier", "getStreamFromSystemIdification", "getStreamFromSysIdentifier", "getStreamFromSysIdentifiers", "getStreamFromSystemidentifiers", "getStreamFromSysidentification", "getStreamFromSystemidentifer", "getStreamFromSysIdentification", "getStreamFromSystemIdentifiers", "getStreamFromSystemidentifier", "getStreamFromSysIdentifer", "getStreamFromSysidentifiers", "getStreamFromSystemIdifiers", "getStreamFromSystemIdifier", "getStreamFromSystemidentification"], "systemId": ["systemDoes", "cmsDoes", "publicById", "cmsMid", "publicMid", "systemid", "localhostId", "serverid", " systemName", "cmsId", "systemID", "humanIs", "humanID", "localhostDoes", "systemStart", "ystemIn", "serverId", "humanDoes", "sysById", "cmsStart", "ystemid", "ystemId", "systemIn", "humanById", "sysIs", "sysID", "ystemMid", " systemById", "sysId", "humanStart", "systemById", "serverById", "publicId", "humanMid", "ystemById", "serverIn", "publicName", "localhostStart", "systemIs", "localhostMid", "systemName", "systemMid", " systemMid", "ystemID", "publicIn", "ystemIs", "humanId", "publicid", "ystemName"], "resolver": ["resolution", "rsolution", "persolver", "persolved", "resolved", "reolved", "reolve", "persolution", "perslove", "resolutionolution", "reolver", "reerver", "reolving", "reanger", "rserver", "persolve", "resolutionolving", " resolved", "resolving", " reserver", "reserver", "rsolver", "reslove", "resolutionlove", "rsanger", "resanger", "persolving", "reolution", " resanger", " resolution", "resolutionolver", "resolve", "relove", " resolve"], "source": ["rule", "raw", "null", "create", "cause", "inner", "SOURCE", "node", "site", "missing", "target", "input", "store", "system", "ser", "reader", "via", "seed", "image", "status", "string", "template", "base", "response", "table", "sequence", "attribute", "style", "channel", "subject", "sql", "unit", "context", "src", "scope", "sample", "sp", "force", "init", "parent", "ource", "copy", "origin", "Source", "peer", "ce", "proxy", "resource", "file", "from", "service", "iterator", "se", "local", "series", "result", "storage", "console", "spec", "relation", "supp", "component", "get", "object", "shell", "remote", "instance", "uri"], "stream": ["cache", "null", "data", "test", "loop", "hold", "trans", "upload", "peer", "file", "present", "impl", "channel", "length", "feed", "input", "load", "sequence", "open", "pod", "row", "sample", "mount", "REAM", "next", "resource", "result", "read", "progress", "sw", "console", "content", "object", "zip", "output", "pool", "buffer", "batch", "socket", "body", "download", "reader", "response", "shape", "our", "cont", "export", "ssl", "valid", "port", "iterator", "complete", "encrypted", "Stream", "message", "temp", "out", "ream", "http", "proc", "chain", "clean", "window", "wrapper", "form", "pipe", "stack", "sync", "log", "poll", "control", "instance"], "url": ["browser", "http", "b", "link", "null", "web", "l", "back", "ll", "rl", "address", "key", "rel", "system", "location", "window", "term", "hl", "external", "char", "f", "ul", "mail", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "bel", "mount", "URL", "resource", "gl", "service", "Url", "job", "sl", "r", "ls", "uri"]}}
{"id1": "20568568", "id2": "8770016", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "label": 0, "substitutes": {"createHTML": ["CreateHTML", "CreateHT", "seeURL", "CreateSQL", "createSQL", "seeSQL", " createHT", "CreateURL", " createURL", "createURL", "seeHTML", "seeHT", "createHT", " createSQL"], "requestPage": ["responseLine", "Requestpage", " requestFrame", "responseFrame", "RequestFrame", "questionpage", "referenceApp", "RequestLine", "requestpage", "RequestType", "RequestApp", "RequestPage", "requestLine", "responseType", "requestFrame", "questionPage", "referencePage", "requestApp", "questionApp", "referenceType", "requestType", " requestType", "questionType", " requestLine", "referencepage", "responsePage"], "result": ["report", "summary", "cache", "command", "detail", "html", "Result", "function", "figure", "root", "memory", "res", "date", "term", "response", "answer", "document", "error", "sequence", "prefix", "description", "trace", "cup", "feature", "line", "render", "json", "work", "section", "comment", "request", "true", "word", "results", "search", "complete", "format", "value", "reason", "success", "all", "params", "match", "relation", "product", "output", "r", "this", "message", "page", "out", "buffer", "join", "source"], "url": ["browser", "http", "link", "web", "l", "in", "ws", "ll", "html", "rl", "xml", "rel", "res", "re", "base", "open", "char", "f", "str", "il", "abs", "ssl", "dl", "ref", "ur", "nl", "URL", "gl", "resource", "loader", "fs", "Url", "sl", "get", "lr", "sb", "ol", "r", "ls", "uri"], "ins": ["ks", "lins", "ris", "in", "ws", "pins", "qs", "cin", "inner", "res", "input", "reader", "als", "gs", "is", "its", "vs", "Ins", "rus", "isin", "ints", "ics", "con", "din", "includes", "cs", "uds", "asin", "ln", "eds", "ars", "pers", "rates", "gin", "sts", "kins", "ts", "ips", "ats", "fs", "mr", "rys", "INS", "ils", "ains", "bs", "ds", " in", "ls", " din"], "bufferedReader": ["bufferedBuilder", "bufferingReader", "buffiledContainer", "buffedWriter", "buffedLoader", "buffedReader", "buffererWriter", " bufferedBuilder", " buffedReader", " buffererWriter", "buffererReader", "bufferingWriter", "buffedreader", "bufferedContainer", " buffedreader", " bufferedWriter", "bufferedWriter", "bufferedreader", " bufferedreader", " buffererReader", "bufferingContainer", " buffedContainer", "buffaredWriter", "bufferingreader", "buffiledReader", "buffedBuilder", "buffaredBuilder", " buffedWriter", "buffiledreader", "buffaredReader", "buffaredLoader", " bufferedLoader", "buffererBuilder", " buffererBuilder", " buffererLoader", " bufferedContainer", "buffedContainer", "buffiledWriter", "buffererLoader", "bufferedLoader"], "cssLine": ["cssLin", "cssline", "ssline", "styleData", "ssLine", "CSSLine", "rssBlock", "javascriptLin", "csData", "rssLine", "javascriptLine", "styleRow", "csRow", "cssBlock", "cosLine", "cssData", "cssRow", "csline", "CSSBlock", "ssBody", "CSSRow", "ssData", "cosBlock", "cssBody", "csLine", "rssRow", "cosBody", "ssRow", "ssLin", "javascriptRow", "javascriptBlock", "ssBlock", "cosRow", "styleLine", "rssBody", "CSSLin", "styleline"], "e1": ["ee1", " e5", "e01", "ee0", "o5", " e01", " e0", "E1", "ee3", "o1", "o01", " e3", "e5", "E0", "e0", "o0", "E2", "e3", "ee5", "ee01", "o2", "ee2", "e2", " e2", "E3"], "queryZoom": ["queryZome", "queryDoo", "queryZoneolution", "queryXom", "viewzome", " queryZooming", "queryDom", "queryZolution", "queryZoo", "queryzoo", " queryzolution", " queryzoom", "viewzom", " queryZolution", "viewZom", "queryZXolution", "queryzom", "queryZom", "queryXome", "queryzolution", " queryzom", "queryDoom", "queryDome", " queryzooming", "queryZoneoom", "viewzoom", "queryZXoom", "viewZome", "queryzoom", "queryzooming", "queryzome", "queryXoo", " queryZom", "viewzoo", "queryZoneooming", "viewZoo", "queryXoom", "queryZXooming", "viewZoom", "queryZXom", "queryZooming", "queryZoneom"], "appendToHome": ["appendTOQuery", "addToQuery", "addtoMenu", "appendToUrl", "appendetoUrl", "appendetoHome", "appendtoHome", "addToUrl", "addtoHome", "appendToQuery", "appendTOUrl", "appendtoUrl", "appendetoMenu", "appendTOHome", "appendToMenu", "addtoUrl", "addtoQuery", "appendetoQuery", "appendtoMenu", "addToHome", "appendtoQuery", "appendTOMenu", "addToMenu"], "sql": ["csv", "condition", "xml", "q", "spr", "rel", "inv", "statement", "string", "expression", "ql", "table", "fn", "cmd", "imp", "json", "sys", "dl", "sv", "sel", "nl", "ms", "sp", "qu", "where", "setup", "ma", "mt", "sn", "select", "QL", "series", "sd", "SQL", "query", "params", "quote", "spec", "sol", "scl", "expr", "db", "ls", "sq"], "pstmt": [" pStst", "pStMT", "pstmr", "postsql", " pfrpr", "pfrmt", "postpr", " pstms", "pstatmt", " pfrmt", "pstrmr", " pStmt", " pstrmt", "pStst", "pstbl", "pstrpr", "psem", "pstartst", "postm", "pmtpr", "prstStatement", "pmtmt", "psebl", "pstrmt", "pstStatement", "psthStatement", "pstsql", " pfrsql", "pstrm", "pfrm", "prstpr", "pSTst", " pstrmr", "postmt", "pSTpr", "pstartms", " pStms", "psemt", "pstpr", "psthmt", "pstst", "pStmt", "pstartMT", "prsthStatement", " pstsql", "pstrsql", " pstbl", " pstrm", "prsthst", "pstm", "prsthpr", "prstst", "pstMT", "pstms", "pSTMT", "psthst", " pstrbl", "pstrbl", "pstartmt", "pmtStatement", "psemr", " pfrm", "pStms", " pstpr", "prstmt", "pSTStatement", " pstmr", "pSTmt", " pstm", " pStMT", "psthpr", "pSTms", "pfrpr", " pstst", "pstatm", "pmtst", " pstMT", "prsthmt", "pstatbl", "pstatmr", "pfrsql"], "rs": ["ks", "RS", "ris", "ws", "rt", "res", "rd", "os", "ss", "its", "ows", "ras", "rc", "ms", "rows", "ys", "ars", "cs", "ues", "xs", "rates", "sts", "Rs", "ts", "ats", "fs", "mr", "rys", "ims", "ps", "bs", "ds", "gs", "ls"]}}
{"id1": "5759961", "id2": "9081749", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"saveUser": [" saveuser", " manipulateAccount", " enrichGroup", " enrichuser", " manipulateuser", " saveAccount", "saveGroup", " enrichUser", " manipulateUser", " saveGroup", " enrichAccount", "saveuser", " manipulateGroup", "saveAccount"], "user": ["report", "human", "rule", "entry", "print", "v", "project", "use", "record", "usage", "create", "data", "User", "server", "test", "post", "us", "responsible", "store", "ro", "username", "response", "base", "load", "name", "login", "used", "table", "person", "actor", "cert", "password", "email", "client", "char", "by", "replace", "ver", "USER", "row", "author", "uid", "usr", "u", "auth", "write", "e", "me", "force", "owner", "info", "version", "word", "add", "url", "file", "profile", "account", "result", "job", "update", "content", "object", "get", "per", "this", "message", "or", "item"], "digest": ["mdested", "hashests", "digests", "Digested", "Digest", " digested", "compests", " digEST", " digester", "readester", "compress", "hashest", "mdest", "DigEST", "digested", "hashester", "readest", "mdester", " digress", "hashress", "readse", " digests", " digse", "compest", "Digse", "digEST", "digester", "digress", "hashested", "mdse", "readested", "digse", "compested", "hashEST", "Digester"], "hash": ["ashes", "uh", "sh", "cache", "ash", "hed", "html", "her", "num", "key", "sum", "h", "test", "has", "full", "rh", "index", "mac", "type", "password", "Hash", "char", "number", "count", "dig", "init", "version", "hex", "block", "size", "check", "search", "add", "mask", "handle", "result", "max", "id", "tag", "sha", "height"], "bigInt": ["littleint", "littleINT", "hugeLong", "bigINT", " bigint", "Bigint", "BigLong", "pgInt", "pgINT", "littleInt", "bigInteger", "hugeint", "BigInteger", "BigInt", "hugeInteger", "hugeInt", "bigLong", "longINT", "longint", "bigint", " bigInteger", "pgint", " bigLong", "longInt"], "hashtext": ["sumtext", "hexvalue", "Hashinfo", "hexread", "ashtext", "ashText", "shaText", "hashtxt", " hashtxt", " hashvalue", "Hashpath", "Hashfunction", "ashstr", "ashinfo", "hashText", " hashinfo", "shatxt", "hashpath", "hashread", "hexText", "hashvalue", "sumText", "hextext", " hashfunction", "hextxt", "shavalue", "shatext", " hashstr", " hashText", "sumfunction", "HashText", "ashtxt", "hashstr", "hashinfo", "Hashtext", "sumstr", "hexpath", "hashfunction", " hashread", "ashread", "sumpath", "Hashstr"]}}
{"id1": "1362", "id2": "3514286", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubargeLess", "bubblesSort", "gobbleCompare", "bubblingLess", "gobblingSort", "gobbleSort", "gobblingCompare", "bubblingCompare", "bubargeSort", "bubblingSort", "bubargeCompare", "bubbleCompare", "bubbleLess", "bubblesLess", "gobblingLess", "gobbleLess", "bubblesCompare"], "a": ["o", "b", "v", "att", "cache", "aka", "ac", "ed", "list", "l", "aaa", "ap", "oa", "data", "alpha", "h", "isa", "el", "window", "na", "aa", "la", "array", "c", "arr", "area", "da", "eas", "trace", "apa", "form", "f", "ab", "aaaa", "sa", "act", "ata", "ma", "ao", "va", "go", "w", "ga", "changes", "am", "ia", "au", "t", "es", "an", "all", "as", "ae", "order", "g", "app", "era", "history", "out", "A", "ea", "z", "p"], "swapped": ["wapping", "scapped", "swapping", "stickaps", "Swaped", " swaps", "waps", "swaped", "snapping", "SWaped", " snap", "stickapped", "Swapping", " snapping", "SWap", "stickaped", " swapping", " snaped", "SWapping", "swaps", "wapped", " snapped", "SWapped", "snapped", "snaps", "stickapping", "waped", "Swap", "scaped", " swap", "Swapped", "scaps", "snaped", "swap", "scapping", " swaped"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "uli", "in", "it", "ji", "ei", "gi", "key", "ami", "chain", "iri", "phi", "us", "index", "ind", "status", "im", "base", "c", "ori", "y", "oi", "ki", "si", "ini", "li", "is", "ii", "io", "iu", "gu", "client", "xi", "f", "bi", "pi", "u", "j", "iso", "x", "me", "init", "origin", "cli", "zi", "ri", "ai", "sim", "t", "mi", "ti", "ix", "hi", "ir", "id", "di", "my", "ic", "I", "ie", "qi", "uri"], "tmp": ["comp", "m", "xy", "cache", "np", "pkg", "test", "perm", "ctx", "obj", "tf", "tg", "attr", "clip", "timeout", "amp", "prefix", "MP", "sup", "nom", "mut", "gm", "orig", "sam", "sp", "cmp", "td", "cur", "managed", "same", "t", "mp", "mk", "result", "pre", "etc", "tt", "emp", "db", "nb", "my", "temp", "lib", "txt", "sq"]}}
{"id1": "15241397", "id2": "23452437", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "doPut", " doget", "DoGet", "DoGET", "Doget", " doGET", "doGET", " doPut", "handleget", "handlePut", "doget", "handleGET", "DoPut"], "request": ["http", "report", "command", "in", "create", "address", "server", "reset", "question", "user", "input", "re", "req", "transform", "document", "quest", "attribute", "the", "client", "first", "connection", "context", "application", "setup", "position", "each", "complete", "Request", "start", "QUEST", "query", "initial", "forward", "get", "hello", "reference", "message", "frame", "current"], "response": ["http", "report", "print", "network", "xml", "session", "resp", "reset", "respond", "body", "server", "site", "res", "onse", "status", "image", "answer", "document", "sequence", "description", "form", "json", "send", "connection", "context", "write", "application", "reply", "version", "position", "ce", "ve", "block", "next", "resource", "service", "Response", "result", "exit", "success", "console", "content", "object", "view", "output", "fire", "message", "page", "frame"], "rewrittenQueryString": ["rewartedQueryString", "rewartedHeaderstring", "rewwrittenQuerystring", "rewrittenHeaderStr", "rewartedHeaderString", "rewrittenQueryStream", "rewrittenqueryStream", "rewrittenQueryQuery", "rewwrittenQueryString", "rewartedHeaderStream", "rewwrittenqueryQuery", "rewartedHeaderStr", "rewrittenquerystring", "rewwrittenQueryStr", "rewrittenURLStream", "rewrittenQuestionString", "rewrittenQuerystring", "rewwrittenQueryQuery", "rewrittenURLStr", "rewrittenURLstring", "rewrittenqueryQuery", "rewliedqueryStream", "rewrittenQustring", "rewliedQueryStream", "rewrittenqueryString", "rewrittenQuStream", "rewliedqueryString", "rewwrittenquerystring", "rewrittenHeaderString", "rewartedQueryStr", "rewrittenCurrentstring", "rewrittenQuString", "rewliedQueryStr", "rewrittenHeaderStream", "rewwrittenqueryString", "rewrittenCurrentStr", "rewrittenHeaderstring", "rewliedQueryString", "rewrittenqueryStr", "rewrittenRequestQuery", "rewartedQuerystring", "rewrittenCurrentString", "rewwrittenqueryStr", "rewrittenRequestStr", "rewrittenQuestionStr", "rewartedQueryStream", "rewrittenRequestString", "rewrittenQueryStr", "rewrittenQuestionStream", "rewrittenRequeststring", "rewrittenQuStr", "rewrittenURLString", "rewliedqueryStr", "rewrittenCurrentQuery"], "rewrittenUrl": ["rewrittenString", "rewriterURL", "RewrittenUr", "rewwrittenURL", "rewartedPosition", "rewartedURL", "rewrapedUr", "rewroteLink", "rewriteUrl", "RewrittenUrl", "rewartedUrl", "RewwrittenLink", "rewrapedUrl", "rewedUr", "rewrittenPosition", "rewittenurl", "rewartedUr", "rewrownUr", "rewadjustedPort", "rewedUrl", "rewwrittenString", "RewrittenString", "rewwrittenUr", "RewrittenPort", "rewedString", "rewrittenURL", "RewwrittenString", "rewriddenPosition", "rewriteUr", "rewriteURL", "rewriteurl", "rewwrittenPosition", "RewwrittenPosition", "rewroteUr", "RewrittenLink", "rewrittenPort", "RewwrittenPort", "RewwrittenURL", "rewartedurl", "RewwrittenUr", "rewrittenLink", "rewriterString", "rewittenLink", "rewrapedURL", "rewadjustedUrl", "rewrapedPort", "rewriterUrl", "RewrittenPosition", "rewadjustedUr", "rewrotePosition", "rewedURL", "Rewrittenurl", "rewrownUrl", "rewwrittenUrl", "rewroteURL", "rewwrittenurl", "rewwrittenPort", "rewriddenURL", "rewroteUrl", "rewrittenurl", "rewriddenUrl", "rewroteurl", "rewrownURL", "rewriterUr", "RewwrittenUrl", "rewittenURL", "RewrittenURL", "Rewwrittenurl", "rewadjustedURL", "rewrownPosition", "rewittenUrl", "rewwrittenLink", "rewriddenUr", "rewrittenUr"], "httpURLConnection": ["httpRLApplication", "httpURLControl", " httpURLApplication", "httpSRConnect", "httpFileConnect", "httpRLConnection", " httpUrlconnection", "ttpUrlConnect", " httpURLConnect", " httpUrlConnect", "httpSRConnection", "ttpUrlControl", "HttpURLconnection", " httpURLconnection", "httpMLConnection", "HttpUrlconnection", "httpHTTPApplication", "httpUrlConnect", "ttpUrlConnection", "httpURLconnection", "httpSRControl", "HttpURLConnect", "httpMLConnect", "httpURLConn", "ttpURLConnect", "httpURLApplication", "httpFileApplication", "httpMLApplication", "ttpURLControl", "ttpUrlconnection", "httpUrlControl", "HttpUrlConnection", "HttpHTTPConfiguration", "HttpURLApplication", "httpUrlConfiguration", "HttpURLConnection", "httpUrlApplication", "ttpURLConn", "HttpHTTPconnection", "HttpHTTPApplication", "httpHTTPControl", "httpUrlConnection", "httpRLConnect", "httpUrlconnection", "httpHTTPConn", "httpFileConn", "httpHTTPConfiguration", "ttpUrlApplication", "httpURLConnect", "ttpURLconnection", "httpHTTPConnect", "httpUrlConn", "httpSRApplication", " httpUrlApplication", "httpSRconnection", "HttpHTTPConnect", "httpSRConfiguration", "httpURLConfiguration", "ttpUrlConn", "httpHTTPconnection", "ttpURLConnection", "httpHTTPConnection", "httpMLconnection", "httpFileConnection", " httpUrlConnection", "HttpHTTPConnection", "HttpUrlConnect", "httpRLconnection", "HttpURLConfiguration", "ttpURLApplication"], "header": ["rule", "hidden", "detail", "policy", "operator", "Header", "address", "h", "filter", "hash", "user", "padding", "term", "dr", "status", "holder", "token", "state", "field", "prefix", "wrapper", "meta", "attribute", "handler", "feature", "client", "layer", "core", "device", "ter", "init", "head", "comment", "section", "column", "version", "title", "info", "block", "er", "peer", "zone", "check", "metadata", "port", "format", "handle", "heading", "argument", "part", "query", "variable", "relation", "component", "event", "headers", "option", "tag", "page", "shift", "buffer", "line"], "value": ["entry", "v", "val", "record", "create", "data", "key", "server", "address", "test", "hash", "property", "label", "string", "expression", "des", "name", "field", "sequence", "language", "attribute", "description", "password", "email", "ue", "text", "json", "VALUE", "pair", "sv", "unit", "sample", "save", "comment", "example", "version", "element", "vector", "zone", "format", "Value", "job", "content", "hello", "see", "default", "values", "message", "instance", "current", "python"], "inputStream": ["inputstream", "InputLoop", " inputThread", " inputLoop", "InputStream", "inputThread", "outputSteam", "outputView", "outputLoop", "errorWindow", "outputThread", "InputThread", "inputLoop", "outputstream", "InputView", " inputstream", "errorSteam", " inputSteam", "inputWindow", "inputView", "errorstream", " inputWindow", "inputSteam", " inputView", "outputWindow", "errorStream"], "outputStream": ["inputstream", "outputLength", "OutputStream", "OutputSteam", "responseStream", " outputForm", "displaystream", "responseForm", "outputSteam", "outputView", " outputView", "displayView", " outputSteam", " outputstream", "responseSteam", "outputstream", "outputForm", " outputLength", "displaySteam", "inputView", "OutputForm", "inputSteam", "OutputLength", "displayStream", "responseLength"]}}
{"id1": "12055086", "id2": "22536033", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeleing", " copydeleting", " copydeletving", " copyDeletging", " copyDeeleing", " copyDeleging", " copydeletging", " copyDeeleving", " copyDelingging", " copyDeeleging", " copyDeeleting", " copyDeleving", " copydeletting", " copyDeleing", " copyDeletving", " copydeleving", " copyDelingving", " copyDelinging", " copydeleging", " copyDelingting", " copyDeletting"], "source": ["back", "oss", "SOURCE", "body", "site", "target", "input", "store", "seed", "image", "template", "base", "form", "style", "sql", "src", "scope", "sp", "init", "sample", "ource", "origin", "ace", "Source", "ce", "search", "resource", "from", "local", "service", "se", "original", "start", "query", "spec", "parent"], "dest": ["d", "rest", "null", "comb", "it", "cat", "them", "target", "dist", "mm", "th", "bin", "loc", "decl", "Dest", "end", "nom", "trans", "img", "cas", "pub", "est", "src", "sp", "dir", "st", "origin", "pas", "https", "port", "w", "master", "exp", "del", "lit", "tom", "temp", "way", "orig"], "buf": ["b", "cast", "batch", "capt", "aka", "comb", "bh", "Buffer", "prop", "tab", "cat", "pkg", "cp", "data", "meg", "buffer", "seq", "arr", "uf", "rb", "cmd", "alph", "cf", "bag", "str", "img", "ref", "fg", "br", "buff", "cap", "cb", "box", "bytes", "pause", "vec", "block", "cur", "fb", "cv", "tx", "bc", "eb", "bl", "db", "Buff", "bs", "conv", "bus"], "in": ["inf", "IN", "inc", "it", "al", "inner", "cin", "ins", "user", "input", "mm", "el", "ind", "rin", "bin", "inside", "In", "ini", "is", "by", "or", "un", "ze", "isin", "init", "con", "info", "iter", "ri", "ai", "from", "gin", "read", "en", "inn", "on", "per", "ic", "din", "i"], "out": ["o", "v", "to", "n", "dis", "conn", "oss", "inner", "sum", "flush", "obj", "res", "OUT", "at", "os", "up", "ou", "Out", "io", "aos", "writer", "client", "by", "end", "outer", "sys", "conv", "co", "write", "con", "ion", "t", "log", "auto", "can", "en", "output", "outs", "on", "net", "i", "cn", "ne", "page", "nt"], "count": ["n", "acc", "code", "batch", "ctr", "num", "span", "amount", "sum", "q", "found", "index", "total", "ind", "cond", "c", "len", "char", "ct", "core", "number", "cont", "ch", "common", "cap", "comment", "Count", "counter", "size", "check", "add", "t", "coll", "now", "start", "max", "cloud", "read", "ount", "current", "deep", "conf", "nb", "cc", "length", "z", "nt"]}}
{"id1": "2381663", "id2": "237493", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedAndrethows", "malformedGadgetSpecIsCachedandthows", "malformedGadgetSpecIsCachedAndthrown", "malformedGadgetSpecIsCachedAndThThrow", "malformedGadgetSpecIsCachedAndThows", "malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedAndrethrows", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedAndthThrow", "malformedGadgetSpecIsCachedAndrethThrow", "malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedandthrows", "malformedGadgetSpecIsCachedAndthows", "malformedGadgetSpecIsCachedAndrethrown", "malformedGadgetSpecIsCachedandthThrow", "malformedGadgetSpecIsCachedandThThrow", "malformedGadgetSpecIsCachedAndthrows", "malformedGadgetSpecIsCachedandThows"], "request": ["http", "report", "ip", "parse", "command", "condition", "project", "record", "create", "xml", "q", "question", "call", "input", "response", "req", "document", "quest", "requ", "pull", "client", "pair", "first", "context", "task", "next", "url", "resource", "Request", "map", "result", "query", "forward", "initial", "object", "reference", "message", "this", "frame", "instance", "p"]}}
{"id1": "9272325", "id2": "21608109", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"sendPost": ["sendPOST", "executeRequest", "sendGet", "httpPOST", "httpPost", "httpGet", "executePOST", "executePost", "sendRequest", "doGet", "executeGet", "httpRequest", "doRequest", "doPOST", "doPost"], "reqUrl": ["reqStr", "requName", " reqLink", "requURL", " reqName", "resURL", "requestStr", " reqURL", "reqLink", "requestUrl", "reqPath", "seqName", "seqUrl", "seqLink", " reqPath", "reqURL", "requestPath", "reqName", "seqURL", "requestURL", " reqStr", "resPath", "requUrl", "resUrl", "resStr", "requLink"], "parameters": ["prometers", "publiceter", "prommes", "paramams", "equations", "parameter", "paramuments", "pareter", "arameter", "aramuments", "promations", "publiceters", "parmes", "arammes", "arameters", "paramations", "promams", "paruments", "publicams", "pareters", "equeters", "publications", "promuments", "equeter", "parammes", "prometer", "equams"], "urlConn": ["URLCon", "relconn", "utilConnection", "sslConnection", "leftConn", "webconn", "URLconn", " urlWr", "belCond", "urlCtrl", "sslConnect", "URLConn", "mountConnector", "leftConnect", " urlCtrl", "mountWr", " urlLink", " urlconn", "urlConnect", "webConn", "leftconn", "rowConn", " urlConnect", "sslCo", "urlCon", "sslDesc", "urlConnector", "mountLink", "retConn", "fileConnection", "belDesc", "sslConnector", "relConn", "fileconn", "objConn", "urlCo", "resourceWr", "rowconn", "httpConn", "rowCo", "belConn", "retConnect", "belConnection", "mountCtrl", "httpConnector", "URLConnect", "urlconn", "httpConnection", "resourceLink", " urlCo", "mountCo", "sslCond", "urlDesc", "sslCon", "implCond", "utilConn", "sslconn", "nlConn", "resourceconn", "relCo", "urlLink", "urlConnection", "mountConn", "objCo", "nlConnector", "utilConnect", "rowConnection", "implConnection", "implDesc", "sslConn", "objCtrl", "fileConn", "nlConnection", "mountconn", "httpConnect", "implConn", "nlConnect", "relConnection", "objconn", "urlWr", "utilConnector", "resourceConn", "leftCon", "relConnector", "retconn", "fileCon", " urlConnector", "urlCond", " urlConnection", "webConnect", " urlCon"], "params": ["m", "v", "types", "tags", "services", "pins", "data", "keys", "points", "options", "posts", "string", "padding", "param", "base", "rs", "prefix", "properties", "password", "ams", "json", "Parameters", "AMS", "phys", "files", "bytes", "results", "names", "changes", "s", "config", "conf", "pps", "ps", "values", "units", "terms", "p"], "url": ["http", "web", "l", "ll", "pkg", "rl", "el", "location", "hl", "lb", "self", "base", "name", "loc", "f", "str", "ul", "il", "abs", "ssl", "dl", "build", "ur", "nl", "bel", "mount", "https", "URL", "au", "t", "loader", "log", "Url", "sl", "get", "r", "sb", "out", "ls", "uri", "uu"], "b": ["d", "m", "v", "n", "batch", "l", "it", "bis", "obj", "base", "bin", "B", "rb", "bp", "f", "buf", "u", "bit", "bf", "br", "buff", "bits", "cb", "bytes", "fb", "block", "be", "w", "s", "orb", "gb", "bb", "bc", "eb", "binary", "db", "sb", "mb", "nb", "bs", "r", "a", "i", "buffer", "ob", "z", "p"]}}
{"id1": "23199071", "id2": "6008635", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getReadBody", "getOutputStream", "newInputBody", "getContentFile", "getInputSource", "newOutputFile", "getInputBody", "getOutputFile", "newOutputBody", "getContentBody", "newInputSource", "newInputStream", "newOutputStream", "getOutputBody", "getReadFile", "getInputFile", "getContentSource", "getReadSource", "newOutputSource", "getContentStream", "newInputFile", "getOutputSource", "getReadStream"], "url": ["browser", "http", "pl", "raw", "link", "print", "null", "web", "l", "err", "val", "html", "ll", "address", "server", "full", "q", "rel", "res", "string", "location", "hl", "base", "loc", "email", "f", "str", "row", "mail", "ul", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "u", "api", "mount", "https", "URL", "resource", "internal", "impl", "log", "pp", "Url", "sl", "id", "host", "r", "lr", "this", "path", "page", "remote", "ls", "uri"], "file": ["rule", "link", "print", "fe", "full", "filename", "obj", "user", "folder", "entity", "image", "checked", "base", "template", "name", "table", "field", "language", "fi", "f", "ile", "mail", "fp", "tile", "ref", "dir", "info", "check", "le", "resource", "t", "local", "File", "library", "job", "relation", "object", "event", "db", "lib", "path", "message", "page", "util", "buffer", "FILE", "uri", "source"]}}
{"id1": "13757855", "id2": "8079516", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"process": ["parse", "project", "step", "create", "filter", "proc", "execute", "loop", "call", "processor", "transform", "load", "Process", "render", "replace", "build", "write", "save", "task", "add", "format", "handle", "processing", "run", "display", "apply"], "tpl": ["stbl", "Tbl", "timpg", "tpg", " tbl", " tpp", "tplug", "Tspl", "ttPL", "atpl", "itplate", " tph", "tPL", "ttph", "atplate", "ptld", "tuple", "tph", "itPL", "timbl", "terld", "otpl", "stopl", "timspl", " tplate", "otbl", "tmpp", "tyurtle", "ttpl", "ttopl", "stplate", "atuple", "ttpg", "ptbl", "tmplate", "terpl", "temPL", " tuple", "tsurtle", "ttplug", "itbl", "tpr", "tempr", "timplug", "otld", " tld", "Tph", "tmbl", "tmplates", "topl", "stpg", "stplug", "tmpl", "terplate", "turtle", "tplate", "ptplates", "templ", "Tpr", "tpp", " turtle", "tld", "tplates", "tsPL", "tspr", "ptpl", " tPL", "ttbl", "Tpp", "stpl", "tyPL", "timplate", "itpl", "tmPL", "typl", "timpl", "otplate", "TPL", "Tplate", "stspl", " tplates", "Tpl", "Tplates", "tspl", "timopl", "atld", "tsbl", "Tld", "teruple", "tbl", "tembl"], "model": ["m", "tree", "project", "md", "record", "html", "node", "data", "el", "Document", "base", "M", "document", " models", "module", "Model", " Model", "file", "log", "ml", "models", "content", "object", "product", "parent"], "packageName": ["PackageRoot", "packageFamily", "packagename", "packageClass", "packageVersion", " packageNames", "pkgName", " packageRoot", "groupName", "groupNames", "packageNames", "Packagename", "viewName", "packageRoot", " packageFamily", " packageClass", "groupFamily", " packagename", "pkgNames", "PackageName", "viewRoot", "pkgVersion", " packageVersion", "groupVersion", "PackageClass", "viewname", "pkgFamily", "viewClass"], "outFileName": [" outFilenameSize", "outFileSize", "inFileNames", "outFilePath", "outImageName", "outFNames", " outTablePath", "outFilenameChain", "outfileTime", " outfilename", "inFileTime", "outFilename", " outFileNames", "infileTime", "outFilenamename", " outTableTime", "outStreamName", "outImageSize", " outFileTime", "outTablename", "outStreamTime", "outTableName", " outFilePath", "outDirTime", " outfilePath", "outImagename", "infileType", "infileNames", "outfileNames", " outFileChain", "outStreamNames", " outFilenamePath", "outFilenameNames", "infilePath", "outFileType", " outFileSize", "outfileType", "infileName", "outImagePath", "outFname", "outfileName", "outfilename", " outFilenamename", "outfilePath", "outFilenameSize", " outFilenameType", "outFilenameType", "outTableTime", "outTableChain", "outTableType", "outFileNames", "outDirPath", "inFileName", " outfileName", "outFPath", " outTableSize", "outTableSize", "outFileChain", "outDirName", " outTableName", "outFileTime", "outFilenameName", " outfileNames", " outFileType", " outFilenameChain", "outTablePath", "outFName", "outfileChain", "outStreamType", "outFilenamePath", " outFilenameName", " outFilename", "inFileType", "outStreamPath", "outFilenameTime", "inFilePath", "outDirSize"], "xsltParam": ["xltConf", "xsmlParam", "xmlConf", "xltParam", "xsltConf", "xsqlParameter", "xsslParameter", "xsltParameter", "xsqlConf", "xsslParam", "xsslConf", "xsmlParameter", "xmlParam", "xsqlParam", "xltParameter", "xmlParameter", "xsmlConf"], "artifact": ["anificial", "ardificial", "Artifact", "partifact", " artifacts", "artificial", " artificial", "anifacts", "ardificate", "ardifact", "artifacts", "artificate", "arifact", "Artifacts", " artificate", "anificate", "arifacts", "anifact", "ardifacts", "partifacts"], "destinationPath": ["destinationInfo", "DestificationDir", "destinatorpath", "desturationpath", "destositoryParent", "destensionPod", "identinationChain", "destinatedTarget", "DestinationDir", "destventionDriver", "delinationPath", "destinationChain", "estinationPath", "desticationPod", "destociationPath", "DestensionTemp", "termininationTarget", "destinateLocation", "destATIONHost", "destinantPod", "desturationTarget", " destinationTarget", "destensionDir", "destinationPart", "destinerSystem", "destociationDir", "destinationDisk", "descositoryPath", "destinateAt", "destesticPath", "estionpath", "destociationLog", "destensionHost", "estinationpath", "chaininatedDisk", "destinateHost", "destigationChain", "destociationDriver", "DestinationHost", "destinoDir", "destationDir", "identinationInfo", "destinatePath", "descinationPath", "destitutionPATH", "destinateChain", "estinationPoint", "descositoryPort", "estionPath", "destinationSystem", "origininatedForm", "destinationHost", "destinatePart", "DestinationPoint", "DestificationUrl", "destinateLog", "destinerPath", "termininerJar", "destociationHost", "estationPart", "chaininatedHome", "estinationHost", "destinatedNow", "identinateInfo", "destociationTarget", "destigationPath", "estationHost", "destinationDriver", "descinationParent", "destesticAt", "termininerpath", "destATIONParent", "destificationDir", "destacementName", "destinerHost", "estionPATH", "destinationPoints", "destranceForm", "delinateForm", "chaininationPath", "generinationPath", "destinoPath", "DestensionDir", "destinationPATH", "origininatedPath", "desturationPath", "destinatedDriver", "chaininatedPath", "destinatorChain", "destinatedForm", "destinationTime", "destventionHome", "desticationPath", "estinationTime", "chaininatedDriver", "destionPATH", "destinateName", "destociationPoints", "destificationUrl", "identinateChain", "origininationPath", " destinationDisk", " destociationDisk", "estationPath", "destregationPath", "destionPath", "DestificationPath", "destinationHome", "delinatePath", "origininationNow", "destinateNow", "destinatorInfo", "destinatepath", "estinationKey", "destinoKey", "destinatorKey", "destregationDisk", "DestensionPoint", "destinatorPATH", "destitutionPath", "DestensionPod", "destionpath", "termininationPath", "destinateDir", "origininatedNow", "generinateJar", "DestinationPod", "estinoPath", "destinatedpath", "destationPath", "destranceLog", "termininationpath", "estinationName", "destationUrl", "destacementTime", " destociationpath", "destinatorParent", "termininerTarget", "destionPoint", "destinatorPath", "delinationLog", "destinateKey", "destinationTarget", "destinatedDisk", " destociationPath", "destregationpath", "DestinationLocation", "destigationNow", "destinationPoint", "delinateLog", "destesticJar", "estationDir", "destinoName", "destificationPath", "identinationKey", "desticationDir", "destinationDir", "destinerJar", "destensionTemp", "chaininationHome", "destinationName", "destinateSystem", "destationHost", "termininationJar", "destinationpath", "destacementPath", "destATIONPath", "destinantPath", "destinantTemp", "DestensionHost", "destinationAt", "destinateUrl", "destinationKey", "destociationForm", "estinationPart", "descositoryParent", "destensionPath", "destinatedKey", "destinationLocation", "destigationForm", "chaininationDriver", "generinateAt", "destinoHost", "destociationDisk", "destinationPod", "generinatePath", "chaininationDisk", "destinateForm", "destinationParent", "destositoryPath", "desturationJar", "destinationPort", "destositoryPort", "destinerPart", "generinationSystem", "destinantDir", "destificationLocation", "destinationLog", "termininerPath", "DestinationPath", "destventionPath", "descositoryHost", "desticationTemp", "descinationHost", "generinateSystem", "destinationTemp", "destinatedInfo", "destitutionPoint", "destinatedChain", "destositoryHost", "origininationChain", "destinerpath", "destregationTarget", " destociationTarget", "destensionPoint", "delinationForm", "origininationForm", "destinatorPoint", "destinatePoints", "destinationNow", "identinationPath", "destinateInfo", "DestinationUrl", "estinoTime", "descinationPort", "generinationJar", "identinateKey", "estinationPATH", "estinoKey", "DestinationTemp", "destinatorHost", "destinerAt", "destinationForm", "destationLocation", "destinateJar", "destesticSystem", "destociationpath", "destacementKey", "destinationUrl", "destinationJar", "destociationHome", "delinationPoints", "generinationAt", "destinateTime", "destinatedHome", "DestensionPath", "destrancePoints", "destinoTime", "destinatedPath", "destATIONPort", "estinoName", "destitutionpath", "estionPoint", "destinerDir", "destinatorPort", "origininatedChain", "destrancePath", "destationPart", "destociationPoint", "DestificationLocation", "identinatePath", " destinationpath", "estinationDir", "destventionDisk", "delinatePoints", "destinateTarget", "destinoPoint", "destinerTarget"], "in": ["d", "m", "o", "n", "IN", "l", " IN", "inner", "ins", "doc", "input", "reader", "bin", "c", "In", "io", "f", "info", "w", "t", "file", "id", "r", "din", "i"], "out": ["o", "report", "n", "to", "dis", "print", "screen", "null", "conn", "list", "err", "ex", "raw", "gen", "it", "l", "inner", "obj", "ins", "res", "inv", "OUT", "msg", "c", "os", "up", "Out", "io", "ou", "aos", "cmd", "writer", "oe", "client", "f", "or", "outer", "sys", "u", "ch", "ger", "co", "e", "write", "con", "ln", "nr", "println", "go", "w", "file", "s", "t", "cache", "log", "can", "all", "cfg", "conf", "output", "outs", "gr", "v", "net", "cn", "b", "p", "nt"], "root": ["m", "graph", "node", "data", "create", "roots", "chain", "p", "child", "New", "group", "name", "parents", "table", "json", "Template", "parent", "context", "scope", "dir", "println", "impl", "dump", "se", "start", "config", "id", "Root", "def", "initial", "ok", "_", "r", "de", " roots", "tree"]}}
{"id1": "21555906", "id2": "23291583", "code1": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["actionPeruted", "Actionperuted", "actionExecformed", "ActionPeruted", "Actionperformed", "ActionPerformed", "actionExecceived", "actionPerressed", "actionTransuted", "actionperceived", "actionTransformed", "actionPerceived", "actionTransressed", "actionTransceived", "ActionPerressed", "actionperressed", "Actionperceived", "actionExecuted", "actionperformed", "Actionperressed", "actionperuted", "ActionPerceived", "actionExecressed"], "ae": ["ane", "ene", "ca", "fe", "ei", "pe", " je", "eeee", "re", "aa", "ee", "xe", "oe", "ra", " ge", "ue", "sa", "ze", "ge", " ace", "arde", "me", "e", "za", "eu", "ace", "ase", "ce", "er", "je", "ke", "te", "ape", "se", "ese", "es", "AE", "event", "de", "iae", "ade", "a", "action", "ea", " pe"], "toservlet": ["tooservlet", "tooservole", "toserverole", "toserverlets", "tooservlets", "toserverLET", "tooservle", "tosuperlet", "tosservLET", "tooservert", "tosuperole", "tooserverle", "toservlets", "tosupert", "tosuperle", "toservt", "toserverlet", "tooservt", "toservert", "tooserverlets", "tosourcelet", "tosuperLET", "tosourcele", "tooserverole", "toservLET", "tosservlets", "toservole", "tosourcet", "tosservle", "tosourceole", "tooservLET", "tosuperlets", "toserverle", "tooserverLET", "tosservlet", "tooserverlet", "toservle"], "servleturl": ["servveturl", "servleteloc", "selectbleUrl", "serviceletconnection", "servlurl", "selectletloc", "servbleloc", "serviceletname", "servlname", "selectletUrl", "selectbleloc", "servbleconn", "serviceleturl", "serviceletsurl", "servlconnection", "servleteUrl", "selectbleconn", "servlUrl", "servletconn", "servbleUrl", "selectletconn", "servletloc", "serviceletsconnection", "servletname", "servleconn", "serviceletsname", "serviceletsUrl", "servleteurl", "servletUrl", "selectleturl", "servletsconnection", "servleUrl", "servvetname", "serviceletUrl", "servletsurl", "servvetUrl", "servbleurl", "servleurl", "servletsname", "servletsUrl", "servleloc", "servvetconnection", "servleteconn", "selectbleurl"], "servletconnection": ["serviceletopen", "servleteconnection", "servvetconn", "serviceantconn", "portLETconnection", "servletopen", "servantopen", "serviceantConnection", " servletConnection", "servletclient", "servLETConnection", "servleteurl", " servletscontext", "servvetConnection", "ervletconn", " servletsclient", "servleteclient", "portletconnection", "serviceletconn", "servletConnection", "servletecontext", "ervleteConnection", "servLETurl", "servvetopen", "ervletConnection", " servletconn", "servLETconnect", "serviceletConnection", "servletsclient", "servletconn", "serviceantopen", "ervleteconn", "servLETconnection", "servleconn", " servetconnection", "portletConnection", " servletconnect", "servletscharacter", "servlecharacter", "servletsurl", "servletconnect", " servletclient", "servleteconn", " servetconnect", "servletecharacter", "servleConnection", "servetcharacter", "servantconn", "servlexconnection", " servletcontext", "portLETConnection", "portletconnect", "servlecontext", "servetconnection", "servletscontext", "portLETurl", "servletsconnect", "servetConnection", " servetcharacter", "ervletecharacter", "servleconnection", " servletsconnection", "servlexconn", "servleteConnection", "portleturl", "servantConnection", "servletsopen", "ervletcharacter", " servletsConnection", "portLETconnect", "servleclient", "ervletconnection", "servletcharacter", "servetconn", " servletcharacter", "serviceletconnection", " servetConnection", "servantconnection", "servleconnect", "serviceantconnection", "servletcontext", "servlexconnect", "servletsConnection", "servleteconnect", "ervleteconnection", " servetconn", "servlexcharacter", "servletsconnection", "servetconnect", "servvetconnection", "servletsconn"], "inputFromClient": ["InputFromclient", " inputToServer", "InputFromRemote", "inputFromclient", "InputToClient", "inputInclient", "inputWithclient", " inputToCurrent", "inputStreamCase", " inputfromServer", "InputFromClient", "inputfromCase", "inputToRemote", " inputFromclient", "inputInCurrent", " inputFromCase", "inputFromServer", " inputFromServer", " inputfromCase", "inputfromRemote", "inputWithRemote", "inputfromCurrent", "InputToclient", "inputStreamClient", "inputFromCase", "inputInServer", " inputfromclient", " inputToClient", "inputfromClient", " inputFromCurrent", " inputfromClient", " inputfromRemote", "inputInRemote", "inputfromclient", "inputToServer", "inputInClient", "inputStreamclient", "inputToCurrent", "inputStreamRemote", "inputFromCurrent", " inputFromRemote", "inputFromRemote", "inputfromServer", "InputToRemote", "inputToClient", "inputWithClient", "inputToclient"], "fos": ["bOS", " foes", "sfos", "foes", "toes", "fows", "fOS", " fows", "tows", "sfoes", "Foes", "Fos", "FOS", "bos", "Foses", " fOS", " foses", "sfoses", "sfOS", "foses", "boes", "tos", "tOS", "bows"], "buf": ["b", "batch", "gen", "Buffer", "tab", "cat", "pkg", "cp", "buffer", "doc", "mu", "seq", "msg", "arr", "uf", "rb", "bar", "cmd", "cf", "bag", "bed", "img", "ref", "mem", "fg", "br", "buff", "cap", "cb", "box", "bytes", "pause", "iter", "block", "vec", "fb", "cur", "cv", "bc", "db", "tmp", "Buff", "temp", "conv", "txt", "orig"], "bytesread": ["Bytesread", "bpsload", " bytesneed", "bytesneed", " bytesload", " bytesrun", "bitsload", "bpsread", " bytesreadable", "ampleswrite", " bytesprint", "bitsprint", "secondsrun", "bytesload", "amplesread", "secondsreadable", "Bytesneed", "bytesadd", " bytesadd", "secondswrite", "fieldswrite", "Bytesneeded", "bytesneeded", " bytesneeded", "bytesprint", "fieldsread", "amplesneed", "secondsread", "bitsadd", "bpsprint", "fieldsrun", " byteswrite", "amplesneeded", "byteswrite", "bytesreadable", "Byteswrite", "bytesrun", "bpsadd", "bitsread", "fieldsreadable"]}}
{"id1": "7087108", "id2": "7149578", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"doGet": ["doSet", " doget", "invokeget", " handleSet", " doGET", "doGET", "invokeGet", "invokeSet", "invokeGET", " handleGet", " handleGET", " handleget", "doget", " doSet"], "request": ["http", "report", "raw", " Request", "command", "project", "create", "xml", "address", "server", "reset", "question", "post", "call", "controller", "input", "index", "re", "store", "req", "transform", "document", "quest", "open", "requ", "attribute", "the", "begin", "remove", "client", "worker", "core", "subject", "first", "context", "application", "setup", "version", "enter", "position", "info", "each", "search", "url", "complete", "Request", "construct", "handle", "local", "QUEST", "query", "model", "initial", "forward", "get", "hello", "order", "reference", "message", "relative", "change", "frame", "instance", "select"], "response": ["http", "report", "print", "xml", "resp", "body", "respond", "server", "res", "onse", "re", "image", "one", "status", "os", "description", "render", "connection", "context", "application", "write", "reply", "ce", "next", "respons", "Response", "result", "success", "view", "default", "output", "message", "page", "out", "frame"], "path": ["print", "project", "prop", "Path", "pkg", "key", "full", "test", "chain", "filename", "system", "location", "string", "ath", "th", "p", "template", "transform", "base", "name", "prefix", "title", "dir", "where", "mount", "hex", "check", "patch", "url", "value", "pattern", "log", "config", "PATH", "query", "route", "output", "temp", "dest", "relative", "text", "select", "uri"], "file": ["report", "ca", "to", "rule", "disk", "null", "link", "fe", "full", "key", "chain", "filename", "user", "bool", "image", "base", "load", "name", "table", "document", "bar", "form", "f", "ile", "mail", "bo", "valid", "e", "upload", "real", "word", "be", "port", "check", "le", "resource", "File", "handle", "local", "library", "result", "job", "model", "console", "binary", "relation", "object", "spec", "view", "output", "db", "run", "lock", "page", "channel", "FILE", "tree", "source"], "in": ["thin", "IN", "inc", "it", "l", "al", "inner", "cin", "sum", "ins", "input", "mm", "reader", "ind", "one", "rin", "bin", "up", "In", "ini", "is", "again", "or", "isin", "kin", "sample", "con", "and", "copy", "asin", "mc", "mn", "gin", "s", "pic", "read", "en", "as", "ck", "cm", "inn", "sin", "on", "ic", "out", "din", "i", " din", "source"]}}
{"id1": "16760971", "id2": "10158738", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"generateHash": ["generateKey", " GeneratesHash", " Generateshash", "generatesIndex", "generatedIndex", "generatedHash", "generateIndex", " GeneratesKey", "generificateIndex", "generatehash", " GeneratesIndex", " GenerateIndex", "generatesHash", " GenerateHash", "generificatehash", " Generatehash", "generatesKey", " GenerateKey", "generificateKey", "generificateHash", "generateshash", "generatedhash", "generatedKey"], "key": ["code", "link", "secret", "command", "policy", "Key", "node", "data", "sum", "keys", "k", "hash", "input", "string", "prime", "username", "seed", "mac", "token", "template", "base", "name", "y", "prefix", "type", "password", "char", "client", "sk", "json", "KEY", "context", "phrase", "e", "sign", "hex", "crypt", "value", "service", "id", "my", "path", "message", "x", "text", "source"], "md": ["d", "m", "comp", " ms", "mg", " cmd", "ad", "cd", "ld", " Md", "mand", "bd", "h", "pd", "hd", "grad", "MD", " mm", "desc", "mm", "det", "od", "ind", "dr", "msg", "exec", " mc", "mod", "cmd", "dd", " MD", " mac", "red", "der", "df", " dd", "ms", "nd", "dig", "dh", "td", "mc", "mt", " rm", "mn", "metadata", "add", "rm", "mp", "mk", "sm", "sd", "def", "mo", "dm", "di", "mb", "de", " mo", "ds", " cd", "nt"], "bytes": ["ashes", "b", "strings", "frames", "clips", "bes", "some", "classes", "words", "bis", "blocks", "keys", "ebin", "buffer", "bys", "seconds", "lines", "pieces", "bles", "gets", "bps", "cells", "its", "vs", "terms", "ms", "files", "bits", "steps", "ios", "loads", "tes", "xs", "s", "ings", "bos", "es", "fs", "gb", "ions", "binary", "ies", "values", "bs", "nets", "Bytes", "gs", "ls", "ones"], "buff": ["pb", "comp", "b", "ary", "frames", "bj", "butt", "Buffer", "alf", "np", "tab", "grow", "wind", "tf", "cond", "aux", "ff", "zz", "uf", "cmd", "alph", "ust", "buf", "df", " Buff", "bed", "bo", "agg", "pdf", "conv", "bg", "append", "cb", "fb", "font", "obb", "printf", "pp", "qq", "bb", "eb", "fr", "uff", "bound", "supp", "prep", "backed", "nb", "zip", "mb", "Buff", "bs", "prof", "buffer", "ob", "txt", "quit"], "l": ["d", "m", "pl", "n", "b", "v", "list", "ld", "ll", "al", "lc", "lang", "L", "k", "q", "el", "loop", "hl", "lb", "lo", "la", "dL", "c", "loc", "li", " Li", "ly", "ul", "il", "dl", "lv", "j", "lp", "nl", "lay", "ln", "tl", "le", "coll", "t", "jl", "ml", "length", "yl", "sl", "kl", "fl", "lit", "cl", "g", "like", "left", "x", "i", "ls", "z", "ell"], "hx": ["Hxe", " hix", "hrxe", " hxf", "handleex", "hX", "rex", "hrex", "ohex", "ohx", "rpx", "handlex", "rx", "ohxe", " hpx", "Hex", "hix", "handlexf", "Hix", "hxe", "hrX", "hpx", "hex", "Hxf", "hrx", " hex", "HX", "hxf", "handleix", "rxf", "ohX", "Hpx", "Hx"]}}
{"id1": "3024992", "id2": "8625346", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2null_", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_NullOut", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter_NULLIn"], "baout": ["abaOut", "BAouth", "bait", "BAouts", " bain", "cain", "caOut", "BAout", "BAoul", "gaouth", "buout", "baOut", "baouth", "gaout", "baoul", "caout", "BAin", "abait", "buouts", "cait", "gaoul", " baOut", "BAit", "buin", "bain", "gain", "BAOut", "dbout", "dbin", "baouts", "abain", "abaout", " baouts", "dboul", "dbouth", "buOut"], "out": ["o", "n", "gen", "null", "in", "it", "err", "ex", "res", "ser", "OUT", "Out", "io", "sys", "write", "serv", "er", "result", " OUT", "output", "outs", "tmp", "gr", "pool", "net"], "writer": ["killer", "print", "null", "rw", "data", "inner", "NULL", "target", "wright", "processor", "window", "reader", "maker", "Writer", "builder", "document", "handler", "nw", "client", "worker", "outer", "channel", "write", "writ", "riter", "er", "println", "w", "file", "driver", "service", "widget", "wrote", "output", "this", "usher", "woman", "player", "buffer"]}}
{"id1": "13563706", "id2": "18046717", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "label": 0, "substitutes": {"doGet": ["handleGet", "doPut", " doget", "DoGet", "DoGET", "Doget", " doGET", "doGET", " doPut", "handleget", "handlePut", "doget", "handleGET", "DoPut"], "request": ["http", "report", "command", "project", "use", "socket", "create", "xml", "address", "reset", "call", "user", "input", "re", "directory", "transform", "document", "attribute", "subject", "first", "connection", "context", "application", "setup", "version", "position", "each", "search", "url", "resource", "Request", "complete", "QUEST", "query", "route", "initial", "forward", "get", "hello", "order", "view", "event", "reference", "message", "path", "frame", "current", "parent"], "response": ["http", "report", "summary", "zero", "print", "continue", "security", "condition", "network", "header", "resp", "server", "respond", "hash", "res", "image", "status", "answer", "document", "sequence", "description", "collection", "render", "json", "connection", "application", "write", "foundation", "reply", "example", "version", "position", "ce", "ve", "block", "next", "search", "format", "service", "Response", "result", "exit", "success", "console", "relation", "view", "see", "output", "default", "fire", "message", "display", "frame", "tree"], "selectedPage": ["selectFile", "matchedFrame", "verifiedpage", "selectionPage", "lectedItem", "electionDocument", "namedPage", "namedToken", "singlePort", "namedKey", " selectedPort", " selectedPath", "selectedItem", "lectedRow", "singlePage", "electedPort", "electionPage", "specifiedDocument", "specifiedPort", "singleFrame", "selectionPort", "namedpage", "lectedPort", "selectLine", "selectionToken", "selectedPath", "selectedpage", "lectedFrame", " selectedLine", "matchedPort", "selectionLine", "selectedKey", "lectedpage", " selectedFile", " selectedFrame", "namedLine", "selectedRow", "electedpage", "selectedPort", "selectionItem", "lectedKey", "selectedFrame", "selectPage", "lectedPage", "selectedLine", "electedFrame", " selectedpage", "lectedDocument", "selectedToken", " selectedRow", "electedPage", "electionPort", "specifiedPage", " selectedKey", "lectedPath", "matchedPage", "verifiedFile", "lectedToken", "selectedDocument", "electionFrame", "matchedpage", "verifiedPage", "specifiedFrame", "namedPort", "lectedLine", "singlepage", "selectPort", "selectedFile", "selectionFile", "selectPath", "namedFrame", "lectedFile", "verifiedRow", "selectItem"], "page": ["age", "cache", "project", "record", "user", "layout", "collection", "client", "Page", "associated", "me", "force", " Page", "peer", "proxy", "url", "pp", "office", "channel", "current", "to", "menu", "network", "address", "self", "language", "row", "version", "position", "next", "resource", "profile", "result", "object", "output", "pool", "p", "rule", "pointer", "phone", "node", "server", "image", "document", "phrase", "application", "be", "port", "complete", "successful", "message", "pages", "frame", "parent", "line", "policy", "filter", "site", "chain", "window", "group", "table", "form", "number", "block", "log", "created", "point", "view", "display", "instance"], "portalRequest": ["portualEvent", "PortaleQuery", "portpalThread", "terminalRequest", "portpalContext", "portaleAccess", "terminalResponse", "terminalidRequest", "portortalEvent", "portortalThread", "portalerequest", " portalAccess", "portsortalResponse", "portsalrequest", "portortalQuery", " portalCall", "portalityRequest", "portalingAccess", "portpalResponse", "portalidQuery", "portalAccess", " portaleAccess", "portaleApply", "portalQuery", "portortalContext", "PortalContext", "portortalResponse", "portaleContext", "portalidSession", "terminalQuery", " portaleCall", "portralResponse", "portalityFrame", "portaleFrame", " portaleRequest", "portsortalEvent", "portalrequest", "portalingApply", "terminalidSession", "portalSession", " portaleApply", "portualResponse", "portalidResponse", "portralRequest", "terminalSession", "portalaRequest", "portsalRequest", "portortalRequest", "portalEvent", "portpalRequest", "PortalRequest", "portortalrequest", "PortalFrame", "portalResponse", "PortaleRequest", "portsalEvent", "portaleEvent", "portaleThread", "portralSession", "portalThread", "PortaleResponse", "portalCall", "portaleRequest", "PortalThread", "portsortalRequest", "portalityResponse", "portalaApply", "PortaleFrame", "portalingCall", "portalFrame", "PortalResponse", "portaleSession", "portalContext", "portaleResponse", "portaleQuery", "PortaleThread", "portalaAccess", "portralQuery", " portalApply", "portalidFrame", "portalityContext", "PortaleContext", "portaleCall", "portralContext", "portalApply", "portsortalrequest", "portsalResponse", "portalidRequest", "portalingRequest", "portalidContext", "portualrequest", "terminalidQuery", "portualRequest", "terminalidResponse", "PortalQuery", "portalaCall"], "pageProp": ["agePr", "pagePr", "poolProp", "sectionProp", "pageProperty", " pagePr", "pagePred", " pagePro", "sectionZip", "keyProp", "ageProp", "propertyPriv", "pageZip", "pagePro", "propertyDef", "keyComp", "agePred", "propertyProp", " pagePred", "agePro", "profileZip", "propertyPack", "officeProp", " pageDef", "poolPro", "phrasePr", "officePack", "sectionPro", "phraseProperty", "imagePr", "imageProp", "officePriv", "profilePro", " pageProperty", "officeDef", " pageComp", "keyProperty", " pagePriv", "poolZip", "keyPr", "pageComp", "phraseProp", "pageDef", "profileProp", " pagePack", "pagePack", "imagePro", "phraseComp", "profilePred", "imagePred", "poolPred", "pagePriv", "sectionPred"], "possiblePage": [" packedCollection", "possiblyTag", "PossibleUser", "pablePage", "possiblepage", " possibleLine", "pspecifiedPage", "pableTag", "pibleUser", "possiblyPage", "PossiblePage", "possibleUser", "PossiblyChild", "pbableCollection", "packedLine", "pspecifiedpage", "Possiblepage", "pbablePage", "PossibleCollection", "pentialPages", "possibleLine", "packedTag", "possibleTag", "pspecifiedPages", "PossiblyPage", "pableLine", "possibleChild", "possiblyChild", " packedLine", "possiblyUser", "pableCollection", "possiblyCollection", "PossiblyCollection", "pibleCollection", "possiblePages", "PossiblyUser", "PossiblePages", " possibleCollection", "packedCollection", "pibleChild", "pspecifiedTag", " possibleTag", "pbableChild", "piblePage", "pbableUser", "pentialTag", "pentialPage", " packedPage", "packedPage", "pentialpage", "PossibleTag", "PossibleChild", "possibleCollection", " packedTag", "possiblyLine"], "property": ["rue", "rule", "command", "prop", "policy", "header", "operator", "key", "function", "address", "second", "string", "location", "expression", "name", "field", "description", "attribute", "type", "properties", "feature", "definition", "behavior", "trace", "class", "phrase", "owner", "title", "domain", "position", "Property", "metadata", "value", "resource", "service", "integer", "config", "variable", "relation", "object", "message", "frame", "p"], "referer": ["relerer", "defered", "reered", "retered", "relrer", "reeree", "reportrer", "rangeender", "refering", "reerer", "rangeener", "redrer", "Referer", "rangerer", "refered", "referee", "verrer", "rangeerer", "Refrer", "reterer", "refarer", "rerer", "refrer", "rearer", "relering", "reonder", "verrier", "reporterer", "defrer", "refonder", "ferer", "reere", "refrier", "printrier", "frer", "rorrer", "reender", "deferer", "Refere", "printerer", "refere", "rorered", "refener", "requrer", "refender", "diffonder", " refrer", "aferer", "referential", "fering", "reportarer", "printerential", "vererential", "diffrer", " refered", "redere", "differing", "relender", "requonder", "rederer", "reportered", "rederee", "afrer", "relerential", "retarer", "refirect", "reener", "defirect", "requerer", "rorirect", "vererer", "printrer", " refirect", "differer", "afener", "relener", "reerential", "reering", "Referee", "rerier", "requering", "rorerer", "fener", "aferential", "retrer"], "e": ["o", "m", "n", "err", "ception", "h", "eeee", "ee", "error", "oe", "f", "echo", "ge", "me", "eu", "er", "t", "te", "se", "es", "E", "eg", "ae", "g", "event", "r", "de", "a", "x", "eur", "ie", "p"]}}
{"id1": "7169984", "id2": "8330057", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"connRemote": [" validateRemote", " authAsync", " connBase", " authBase", " validateBase", " communicateAsync", " connLocal", " communicateRemote", " validateLocal", " validateAsync", " communicateBase", " authRemote", " connAsync", " communicateLocal", " authLocal"], "jsonObject": ["jsobject", "xmlObj", "jsonAst", "JSONArray", "jsArray", " jsonArray", " jsonobject", "xmlAst", "JSONObj", "jsonobject", "xmlObject", "jsonArray", "jsonElement", "JSONobject", "jsObj", "jsonObj", " jsonObj", "JSONElement", "JSONObject", "jsObject", "JSONAst", " jsonAst", " jsonElement", "xmlElement"], "OPCode": ["OPData", "OPName", "OPCause", "opcode", "OpName", " OPCause", " OPType", " OPName", " OpType", " OpCause", "OpData", "OPcode", " OPData", " OpCode", "OpCause", " OPcode", "OpCode", " OpName", "opData", "opCode", "OPType", "opType", "OpType", "Opcode"], "retSrc": ["retSRC", " retInsrc", "retRssrc", " retInsource", "retNRC", "retNrc", "returnScr", "retStrource", "returnSRC", "retInsrc", "retSsrc", "returnSetrc", "returnSrc", "RetSsrc", "retAsRC", "retRsrc", "RetSRC", " retInssrc", " retSsrc", "retStrrs", " retSRC", "retInsource", "retInsrs", "retSrs", "retScr", "retSetcr", "returnSetsrc", "retRsource", "retAssrc", "retStrRC", "retStrrc", "retInssrc", "RetStrrc", "retAsrc", "retInscr", "RetStrsrc", "retSetrc", "returnSetcr", "RetStrRC", "RetSrs", "retNsrc", "retStrsrc", " retSource", "returnSetRC", "returnSsrc", "retRsRC", " retInsRC", "retSetsrc", "retAsrs", "RetStrrs", "RetSrc", "retSource", "retNcr", "retSetRC", "retInsRC"], "httpClient": ["httpNet", "httpGe", "HttpSystem", "ttpSystem", " httpConnect", "ttpStore", " httpGe", "httpConnect", "httpSystem", " httpStore", "httpStore", "healthCo", "ttpClient", " httpNet", "healthClient", "ttpConnect", "HttpStore", "upperNet", "healthNet", "httpCo", "healthGe", "upperClient", "upperCo", "HttpClient", " httpSystem", "upperGe", " httpCo", "HttpConnect"], "httpPost": ["hoverPOST", "ttppost", "httpPOST", "ttpPut", " httppost", "ttpPre", " httpPre", "healthPost", " httpPut", "HTTPPost", "hoverPre", "httpsPost", " httpPOST", "hoverPost", "healthPress", " httpPress", "httpPut", "healthPOST", "hPost", "httppost", "httpsPress", "httpPre", "hPOST", "ttpPost", "HTTPpost", "hpost", "HTTPPOST", "ttpPOST", "HTTPPut", "httpPress", "httpsPOST", "hoverpost"], "httpParams": ["ttpPrps", "ttpParars", " httpParms", "httpPrants", " httpPams", "httpparms", "httpParms", "httpPams", "ttpPrars", "httpParants", "httpPps", "httpparps", "httpPrps", "httpSharms", "httpPms", "httpParars", "httpPars", "httpPgs", "httpSharams", " httpPargs", "httpParps", "httpPrms", "ttpPrms", "ttpParps", "httpPants", "ttpPrams", "httpSharants", "httpPrgs", " httpParants", "httpparams", "httpShargs", "httpPrams", " httpPms", "ttpParms", " httpPants", "ttpParams", "httpPrars", "httpparars", "httpPargs", " httpPgs"], "nameValuePair": ["nameValuesppair", "nameValuePareter", "nameValueChpair", "nameKeyParpair", "nameValuepairs", "nameValuePersair", "nameValuePerspair", "nameValueChairs", "nameValuespair", "nameValuesPair", "nameKeyPairs", "nameNameParair", "nameKeyPpair", "nameKeyParair", "nameValueppair", "nameNamePpair", "nameKeyPair", "nameValuePartatch", "nameValuePerseter", "nameValuePersairs", "nameValuepiece", "nameValueParair", "nameValuepair", "nameValuePartpair", "nameValuesPiece", "nameValueChair", "nameNameParpair", "nameValuePointair", "nameValuePointpair", "nameKeyPeter", "nameValueParatch", "nameValuesPairs", "nameKeyPareter", "nameValuepatch", "nameValuePairs", "nameNameParatch", "nameValuePartair", "nameValuePatch", "nameValuePeter", "nameValuesPpair", "nameValuePpair", "nameValueParairs", "nameValuepeter", "nameValuePariece", "nameValuespiece", "nameValuePointiece", "nameKeyParairs", "nameNamePatch", "nameValuespairs", "nameValuePiece", "nameValuePointairs", "nameNamePair", "nameValueParpair"], "response": ["report", "entry", "cache", "command", "network", "data", "xml", "resp", "body", "respond", "res", "onse", "entity", "image", "answer", "document", "sequence", "still", "description", "trace", "json", "social", "connection", "application", "e", "reply", "request", "block", "next", "service", "result", "Response", " responding", "relation", "object", "view", "output", "message", "given", "frame", "tree"]}}
{"id1": "19086952", "id2": "22114133", "code1": "    public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException {\n        String fullPath = url.toString();\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        final long length = conn.getContentLength();\n        if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\");\n        return createInputStreamResponse(in, conn.getContentType(), length, connection);\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createUrlResponse": ["createFileResp", "createurlResponse", "createURLresponse", "createurlResp", "createUrlView", " createURLresponse", " createURLResponse", "createUrlResp", "createURLView", " createUrlView", " createUrlResp", " createURLResp", " createUrlresponse", "createFileView", "createFileResponse", "createFileresponse", "createurlresponse", " createURLView", "createURLResponse", "createUrlresponse", "createurlView", "createURLResp"], "url": ["browser", "http", "b", "pl", "link", "web", "l", "ll", "html", "xml", "address", "el", "call", "string", "location", "parser", "image", "base", "name", "loc", "document", "cert", "email", "client", "char", "str", "mail", "ssl", "dl", "org", "sql", "build", "ur", "nl", "domain", "bel", "mount", "URL", "gl", "file", "Url", "job", "get", "host", "path", "ls", "uri"], "connection": ["entry", "to", "link", "command", "condition", "socket", "generation", "network", "usage", "session", "thread", "computer", "server", "ctx", "controller", "processor", "connected", "window", "location", "database", "directory", "process", "response", "remote", "self", "Connection", "c", "document", "builder", "open", "description", "handler", "writer", "client", "callback", "number", "subject", "nc", "context", "application", "intention", "con", "position", "connect", "ion", "using", "reason", "log", "creator", "config", "close", "relation", "output", "message", "pool", "channel", "communication", "current"], "fullPath": ["FullName", " fullpath", "fullpath", " fullPort", "Fullpath", "partialUrl", "fullPort", "FullPath", "fullUrl", "partialpath", "fullName", "partialPath", "partialName", " fullUrl", " fullName", "partialPort", "FullPort", "FullUrl"], "conn": ["n", "pg", "oss", "cp", "num", "ann", "resp", "canon", "proc", "ctx", "obj", "res", "Conn", "connected", "desc", "exec", "Connection", "c", "reg", "loc", "jp", "open", "cert", "cmd", "col", "ct", "comm", "cell", "cont", "enc", "j", "nc", "ch", "co", "iw", "init", "cb", "con", "cur", "connect", "alloc", "cfg", "conf", "ns", "conv", "nt"], "in": ["inf", "m", "n", "IN", "ad", "inc", "inner", "cin", "sum", "body", "ins", "user", "input", "reader", "ind", "rin", "bin", "inside", "In", "is", "or", "sql", "isin", "and", "ma", "mc", "stream", "file", "gin", "from", "mi", "en", "get", "inn", "on", "out", "din", "i"], "length": ["time", "l", "ength", "duration", "data", "amount", "h", "address", "phi", "loop", "filename", "total", "string", "padding", "volume", "distance", "load", "shape", "sequence", "description", "type", "width", "end", "number", "enc", "offset", "count", " Length", "Length", "loss", "position", "size", "value", "ENGTH", "impl", "result", "HH", "frame", "path", "left", "message", "history", "family", "buffer", "height", "text", "len"]}}
{"id1": "14794404", "id2": "22401746", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["decryptPassword", "encipherpassword", "decryptedpassword", "decryptedPassword", "encryptionPassword", "encryptionPass", "encryptionpassword", "encryptedSecret", "decryptpassword", "encryptedpassword", "encryptPass", "encryptSecret", "decryptSecret", "decryptedSecret", "decryptPass", "decryptedPass", "encipherSecret", "encipherPass", "encryptedPass", "encipherPassword", "encryptpassword", "encryptionSecret"], "password": ["Password", "entry", "shadow", "secret", "command", "data", "address", "key", "reset", "hash", "filename", "user", "input", "pass", "string", "padding", "database", "username", "directory", "token", "sword", "name", "login", "prefix", "description", "attribute", "email", "number", "phrase", "word", "w", "value", "pattern", "wordpress", "content", "past", "message", "path", "text"], "encryptedPassword": ["encryptedGuest", "confirmedPassword", "installedPassword", "confirmedDatabase", "coloredConnection", "finishedGuest", "ryptedDirectory", " encryptedConnection", "coloredStatement", "finishedPassword", "initializedConnection", "confirmedpassword", "encryptedDirectory", "updatedDatabase", "coloredPassword", "encryptedStatement", "updatedPassword", "encryptedConnection", "confirmedDirectory", "encryptedpassword", "installedAttribute", "finishedpassword", "coloredDatabase", "encryptedAttribute", "encryptedDatabase", "initializedPassword", "installedDirectory", "updatedDirectory", " encryptedDirectory", "initializedStatement", "finishedDatabase", " encryptedGuest", " encryptedpassword", "ryptedPassword", "installedDatabase", "ryptedpassword", "ryptedDatabase", " encryptedAttribute", "updatedGuest", "initializedDatabase", "updatedpassword", "updatedAttribute", " encryptedDatabase", " encryptedStatement"], "md5": [" md512", " Md3", "md2", " md7", "MD3", " Mdle", "dig25", "sha2", " mdle", "sha512", " MD8", "MD2", "MD25", "md7", "MD512", "dig5", " md25", "sha5", "MD5", " md2", "md8", "mdle", "dig2", " MD3", "md3", " MDle", "MD7", " Md8", "dig3", "md25", "md512", " Md5", " MD5", " md3", "sha7", " md8", " MD2"], "digest": ["mdested", "mdEST", "digests", "Digested", "Digester", "hashum", "Digest", "Digests", " digEST", "Digness", "hashest", "mdness", "DigEST", "mdest", "mdum", "digested", "mdests", "hashester", "digum", "mdester", " digests", " digse", "hexested", "digEST", "Digse", "digester", "hashested", "digness", "mdse", "hexEST", "digse", "hexness", "hashEST", "Digum", "hexest"], "i": ["m", "multi", "n", "b", "ci", "ui", "ip", "ij", "yi", "o", "err", "in", "it", "ji", "ei", "span", "gi", "key", "I", "q", "phi", "major", "uri", "index", "ind", "im", "\u0438", "c", "y", "iq", "li", "io", "is", "gu", "ski", "ii", "xi", "bi", "u", "pi", "j", "conv", "me", "init", "iter", "ri", "ai", "sim", "t", "z", "mi", "ti", "ix", "hi", "id", "point", "di", "my", "a", "ic", "x", "si", "ie", "qi", "zi"], "hex": ["comp", "kw", "raw", "sh", "print", "tex", "ex", "rex", "html", "serial", "full", "oct", "h", "alpha", "hash", "sex", "rendered", "unsigned", "rh", "term", "pex", "hl", "xf", "uint", "des", "cert", "cf", "cmd", "form", "flash", "str", "json", " Hex", "mix", "sv", "percent", "ch", "br", "none", "color", "iter", "check", "com", "dump", "exp", "ph", "tx", "def", "lit", "solid", "zip", "temp", "x", "ne", "txt"]}}
{"id1": "5760649", "id2": "2511579", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"createFile": ["createfile", "uploadFile", "saveFile", "saveFiles", "createFiles", "savefile", "uploadFiles", "uploadStream", " createFiles", "createStream", " createfile", "uploadfile", "saveStream", " createStream"], "src": ["comp", "rect", "ctr", "source", "SOURCE", "sec", "obj", "res", "input", "ser", "sr", "rs", "rx", "loc", "pour", "is", "str", "abs", "fp", "sys", "fc", "rc", "st", "cur", "inst", "stream", "url", "resource", "from", "start", "config", "sit", "sc", "sb", "dest", "ipl", "txt", "sq", "uri", "SourceFile"], "filename": ["n", "v", "ename", "string", "location", "username", "name", "prefix", "fn", "fil", "xxx", "Filename", "fp", "subject", "nl", "bf", "title", "jpg", "txt", "ln", "println", "file", "nm", "nil", "kl", "FN", "ren", "output", "png", "path", "stem", "family", "FILE", "SourceFile"], "fis": ["ffIS", "fisi", "ffisi", "afais", "fiss", "Fios", "ffos", "bfis", "Fisi", "afiss", "bfos", " fios", "bfios", "bfiss", "sfais", " fiss", "fios", "Fos", " fisi", "afios", "Fiss", "fIS", "Fis", "ffis", " fIS", "sfios", "sfis", " fais", "sfiss", "afis", "FIS", "fais"], "fos": ["vOS", " foes", "bis", "wor", "foes", "fOS", "Foss", "toss", "flis", "floss", "tis", "tios", "woss", "vos", "Foes", "wis", "fios", "flios", "Fos", "wos", " foss", "foss", "Fis", "voses", "flos", "bos", "wOS", " fOS", " foses", "woses", "foses", "boes", "vor", "tos", "boss", "wios"]}}
{"id1": "19934218", "id2": "5399593", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"doCrypt": [" doHash", " doDec", " docrypt", "DoCrypt", "DoDec", "DoHash", "docrypt", "Docrypt", " doesCrypt", " doesHash", "doDec", " doesDec", "doHash", " doescrypt"], "text": ["code", "print", "command", "pt", "source", "aut", "data", "key", "body", "test", "input", "string", "term", "ext", "msg", "template", "name", "document", "TEXT", "password", "form", "ct", "str", "cont", "subject", "act", "context", "title", "comment", "word", "now", "w", "url", "value", "t", "format", "pattern", "log", "read", "config", "tx", "content", "binary", "event", "output", "message", "path", "translation", "x", "buffer", "Text", "txt", "select", "nt"], "UnsupportedEncodingException": ["UnsupportedChoderException", "UnsupportedChodingExit", "UnsupportedEncryptionExit", "UnsupportedEncoderException", "UnsupportedChodingException", "UnsupportedChoderEx", "UnsupportedEncodingError", "UnsupportedEncgorithmException", "UnsupportedEncodingEx", "UnsupportedEncgorithmEx", "UnsupportedEncgorithmError", "UnsupportedEncodingExit", "UnsupportedEncgorithmExit", "UnsupportedChoderExit", "UnsupportedChoderError", "UnsupportedEncoderEx", "UnsupportedChodingEx", "UnsupportedChodingError", "UnsupportedEncryptionEx", "UnsupportedEncryptionException", "UnsupportedEncoderExit", "UnsupportedEncryptionError", "UnsupportedEncoderError"], "md": ["d", "m", " ms", "mg", " cmd", "ad", "cd", "ld", " Md", "mand", "bd", "pd", "hd", "grad", "MD", "mm", "det", " man", "od", "ind", "cmd", "dd", " mac", "red", "der", "df", " od", "gm", " dd", "ms", "nd", " mp", "dir", "td", "mc", " rm", "mt", "mn", "add", "rm", " maj", "mp", "mk", "sm", "ent", "sd", "dm", " df", "di", "mb", " mo", " exec", "sha", " cd"], "sha1hash": ["shaOnesum", "shaOnehash", "shaonecache", "SHA1hash", " SHA1sum", "SHA1Hash", "shaonesum", "sha3hash", "sha1sum", "SHA2hex", "sha1Hash", "sha1header", "sha4sum", "sha4hash", "ha1hash", "SHA2Hash", " SHAOnesum", "SHA1hex", "sha1key", "sha2Hash", "sha512cache", "sha1hex", "sha2hash", "sha512sum", "sha2header", "SHA2key", "haonecache", "sha1cache", "sha512Hash", " SHA1cache", "shaoneHash", "haonehash", "sha2cache", "haonesum", "ha1Hash", "shaonekey", "sha4header", "SHA2hash", " SHAOneheader", "sha3hex", " SHA1header", " SHA1hash", "sha4cache", "sha3Hash", "shaOneheader", "sha3key", "sha2hex", "sha512hash", "shaonehex", "sha2sum", "shaOnecache", "shaonehash", "ha1sum", "sha2key", "SHA1key", " SHAOnehash", " SHAOnecache", "ha1cache", "haoneHash"]}}
{"id1": "14877116", "id2": "8788371", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"cpFile": [" copFile", " dupStream", "pasteSingle", "pasteFile", " cpSingle", " cpBuffer", " cpStream", "pasteStream", " dupSingle", " dupBuffer", " copSingle", " dupFile", " copStream", "pasteBuffer", " copBuffer"], "source": ["comp", "null", "in", "string", "init", "peer", "file", "local", "get", "component", "shell", "before", "select", "current", "input", "store", "self", "template", "base", "up", "attribute", "char", "style", "sample", "copy", "Source", "stream", "resource", "start", "config", "find", "spec", "SOURCE", "image", "subject", "sp", "origin", "search", "format", "from", "service", "remote", "ie", "parent", "use", "create", "site", "status", "scene", "name", "secure", "form", "scan", "sql", "unit", "scope", "none", "ource", "ace", "old", "ce", "series", "se", "original", "query", "this", "path", "dest"], "target": ["print", "null", "project", "it", "test", "tif", " targ", "type", "bolt", "top", "force", "peer", "normal", "t", "file", "local", "range", "Target", "tmp", "current", "dev", "to", "link", "theme", " dst", "template", "base", "transform", "style", "global", "build", "mount", "next", "resource", "handle", "master", "set", "tor", "default", "output", "buffer", "goal", "secondary", "that", "localhost", "arg", "origin", "port", "format", "internal", " Target", "tool", "host", "remote", "parent", "tree", "site", "root", "window", "table", "alias", "scope", "arget", "primary", "ARGET", "gt", "point", "update", "this", "path", "dest", "join"], "replace": ["repair", "insert", "report", "link", "null", "ignore", "use", "record", "keep", "store", "fill", "only", "load", "prefix", "fix", "places", "remove", "register", "compatible", "inline", "first", "placed", "write", "hide", "append", "save", "force", "copy", "repeat", "add", "search", "format", "rm", " Replace", "include", "close", "update", "match", "find", "enable", "repl", "share", "delete", "place", "display", "apply", "remote", "change", "join"], "bufferSize": ["BufferName", "blockStyle", "bufferSIZE", "BufferStyle", "bufferCount", "blockSize", "BufferSIZE", "windowCount", "windowName", "BufferSize", " bufferStyle", "windowSIZE", " bufferCount", "bufferStyle", "blockCount", "bufferName", "blockSIZE", "windowSize", "BufferCount", " bufferSIZE", " bufferName"], "src": ["syn", "http", "in", "ctr", "rl", "rt", "SOURCE", "sec", "proc", "obj", "ins", "ser", "input", "req", "RC", "std", "rs", "bin", "rx", "secure", "rb", "str", "img", "sys", "usr", "fc", "rc", "sp", "init", "st", "copy", "iter", "sync", "Source", "sf", "inst", "stream", "cur", "read", "sl", "sc", "supp", "sub", "sb", "sin", "tmp", "dest", "out", "sr", "conv", "txt", "sq"], "tarn": ["tann", "wtara", "pourn", "parm", "vtarm", "thorn", "tourn", " tard", "Tarm", "yarn", "thourn", "yarp", " tara", "tharn", " tann", "wtinn", "starl", "storn", "starm", " tourn", "starn", " tarl", "tard", "Tarn", "stourn", "yarm", "vtann", "Tard", "Torn", "utard", " tarm", " tinn", " tarp", "Tara", "Tourn", " torn", "Tinn", "vtorn", "wtann", "tarl", "pann", "yourn", "tara", "tharl", "vtarn", "torn", "tinn", "utarn", "tarp", "utann", "tarm", "starp", "wtarn", "parn", "porn", "utorn", "Tann"], "tardir": [" tarddir", "tardart", " tarnr", " tartir", "tadr", "taredint", "tartar", " tartore", "taredir", " tartart", " tardar", " tardr", "tartir", "tarnint", "tartore", "tarnr", "tartdir", "tarddir", " tartr", "tradore", "tarnar", "tartr", "tardr", " tardint", " tarnint", "tradr", " tarnar", "tarnir", " tarndir", "tardint", "tarnart", "tadar", "taredar", "tarndir", "tradart", "tareddir", "tardar", "tadir", " tarnir", "tradir", "tarnore", "taddir", "tardore", " tardart", " tardore", "tadint", "tartart"], "n": ["d", "m", "l", "nan", "num", "k", "index", "na", "ind", "c", "y", "un", "number", "count", "j", "nc", "nl", "x", "N", "nn", "con", "ln", "nr", "sn", "mn", "next", "nu", "w", "t", "nm", "norm", "max", "en", "g", "nb", "on", "ns", "cn", "i", "z", "nt"], "tar": ["parse", "cast", "csv", "cat", "tr", "ctr", "cube", "cot", "sum", "star", "tf", "tg", "store", "rar", "cro", "tap", "tif", "dr", "sea", "war", "Tar", "gob", "bolt", "pack", "nut", "ar", "sv", "vol", "qa", "bare", "box", "gre", "mar", "dra", "copy", "par", "add", "te", "tan", "mask", "trap", "part", "car", "tor", "zip", "stable", "gz", "roo", "drop", "or", "buffer", "archive", "txt"], "bytes": ["reports", "strings", "frames", "words", "classes", "some", "blocks", "services", "pins", "qs", "parts", "users", "bags", "seconds", "lines", "pieces", "bles", "gets", "bps", "cells", "les", "its", "elines", "boxes", "files", "steps", "bits", "resources", "ls", "cs", "tes", "versions", "ings", "series", "ips", "es", "groups", "outs", "values", "pages", "bs", "unks", "Bytes", "gs", "rows", "vals", "ones"], "readn": ["rolln", "printle", "readl", " readl", "writen", "loadn", "loadN", "readle", " readnl", "readns", "rollns", "rolll", "writenn", "ReadN", "Readnn", "writel", "writele", "Readn", " Readnl", "printl", " Readl", "writens", "loadnn", "loadl", "Readl", "readN", " Readn", "Readnl", "printns", "rollle", "printn", "readnl", "writeN", "readnn"]}}
{"id1": "7757297", "id2": "12869602", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"submit": ["report", "print", "launch", "edit", "create", "execute", "post", "download", "input", "process", "accept", "login", " submission", "open", "form", "send", "save", "upload", "Submit", "request", "format", "close", "update", "sub", "run", "display", "apply"], "uri": ["http", "report", "wiki", "ui", "link", " URI", "campus", "address", "href", "iri", "filename", "location", "directory", "term", "msg", "name", "prefix", "description", "password", "subject", "pi", "ur", "title", "du", "info", "origin", "URL", "URI", "ri", "doi", "file", "resource", "range", "course", "id", "path", "message", "i", "source"], "Exception": ["Throw", "null", "ception", "Result", "Failure", "Message", "Document", "Default", "Connection", "Class", "T", "Error", "API", "Exit", "Status", "Application", "Warning", "Response", "E", "X", "Event", "EX"], "encodedrdf": ["encuredrp", "encodedrsl", "encodingrdf", "encuredrl", "encodedrdp", "encodedrsfs", "encodedwsfx", "encodingrsl", "encodeddrfc", "encuredrfc", "encodedrdfc", "encodedwsl", "encuredrdf", "encuredrdfc", "encodedrp", "encodedrsf", "encodingrsfs", "encodedrdl", "encodingrdfs", "encodedrtfx", "encodedrdfx", "encodingrdl", "encodedwsfs", "encodedwsf", "encodeddrl", "encuredrdl", "encodingrsf", "encodedridfc", "encuredrdp", "encodeddrf", "encodedrtf", "encodedrtfs", "encodedrsfx", "encodedrtl", "encodeddrp", "encodedrfc", "encodedrf", "encodingrdfx", "encodedridf", "encodedrdfs", "encodingrsfx", "encuredrf", "encodedridp", "encodedrl", "encodedridl"], "url": ["browser", "http", "b", "m", "link", "conn", "web", "l", "socket", "ll", "address", "p", "location", "base", "name", "loc", "li", "open", "cert", "client", "str", "ul", "ssl", "build", "ur", "nl", "mount", "con", "https", "URL", "resource", "file", "service", "log", "Url", "sl", "r", "sb", "ls"], "connection": ["entry", "n", "ticket", "link", "conn", "command", "l", "socket", "in", "web", "network", "generation", "condition", "session", "server", "function", "statement", "connected", "index", "database", "response", "Connection", "c", "document", "still", "open", "description", "io", "writer", "handler", "client", "number", "channel", "context", "application", "con", "position", "https", "established", "connect", "ion", "resource", "using", "result", "creator", "relation", "output", "message", "communication"], "lastUser": ["LastDate", "LastAuthor", " lastDate", "latestCategory", " lastCategory", "lastAuthor", " lastAuthor", "lastDate", "latestAuthor", "latestDate", "LastCategory", "lastCategory", "latestUser", "LastUser"], "out": ["o", "report", "to", "raw", "n", "print", "v", "screen", "list", "in", "ex", "it", "err", "null", "conn", "inner", "server", "chain", "obj", "inv", "res", "window", "OUT", "at", "timeout", "rem", "table", "up", "Out", "io", "ou", "writer", "cmd", "aos", "client", "line", "json", "cont", "sys", "ch", "co", "write", "init", "serv", "con", "check", "format", "cache", "help", "log", "ent", "set", "query", "all", "conf", "outs", "output", "gr", "pool", "net", "pretty", "conv", "txt", "p", "nt"]}}
{"id1": "14567939", "id2": "13783549", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"baseHash": [" baseSign", " baseKey", "basicKey", "BaseKey", "Basehash", "BaseHash", "baseKey", "basicHash", "basicSign", "BaseSign", "basichash", "basehash", "baseSign", " basehash"], "name": ["john", "n", "named", "create", "Name", "NAME", "key", "address", "hash", "user", "term", "username", "login", "admin", "person", "prefix", "table", "author", "alias", "common", "ame", "title", "domain", "info", "word", "search", "names", "local", "account", "id", "initial", "order", "default", "run", "ident", "family", "current", "parent"], "password": ["Password", "entry", "shadow", "secret", "command", "key", "session", "reset", "hash", "user", "pass", "padding", "database", "username", "token", "sword", "login", "prefix", "description", "attribute", "wd", "phrase", "auth", "restricted", "remember", "word", "crypt", "value", "picture", "hello", "message"], "digest": ["mdested", "mdEST", " Diger", "Digested", "decester", " Digend", "dEST", "descester", "Digest", " digested", " digum", " digester", "displayester", "dgest", "Digum", " Digest", " digend", "diger", "mdgest", " diger", " Digester", "mdest", "DigEST", "digested", "descse", "diggest", "decest", "digum", "mdester", "displayum", "decgest", "displayest", "Digse", "Diger", "digester", "digEST", "decested", "digend", "Diggest", "displayested", "descgest", "mdse", "Digend", "descest", "digse", "descested", "displayEST", "dest", "dested", "Digester"]}}
{"id1": "16048516", "id2": "21999120", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 0, "substitutes": {"load": ["parse", " reconstruct", " Load", " reload", "Load", "create", "download", " restore", " overload", "open", "LOAD", "build", "init", "upload", " loads", "loads", " loader", "construct", "dump", "loader", "read", "config", "content", "get", " loaded", " fill", " download"], "urlConfiguracion": ["urlconfiguracion", "urlConfigruatable", "urlExecuracion", "urlConfigruacion", "urlConfiguicion", "urlconfiguacion", "urlconfiguATION", "urlConfiguratable", "urlconfigoraton", "urlConfiguriacion", "urlConfigurateatable", "urlConfiguricion", "urlConfiguacion", "urlConfigoracion", "urlExecurateator", "urlConfigulacion", "urlConfigureacion", "urlExecuratable", "urlConfiguraton", "urlConfigURacion", "urlConfigruator", "urlExecurateaton", "urlConfigoraci", "urlConfigruaton", "urlconfigoricion", "urlconfiguaci", "urlConfigureator", "urlConfigURaci", "urlConfigurateator", "urlconfigurATION", "urlConfigureaton", "urlconfigoraci", "urlConfigURaton", "urlConfigurator", "urlConfigurateaton", "urlConfigulaton", "urlConfiguATION", "urlConfiguriaci", "urlConfiguaci", "urlConfigureatable", "urlConfigulATION", "urlConfigurATION", "urlconfiguraton", "urlconfiguricion", "urlConfiguraci", "urlConfiguriaton", "urlConfiguriicion", "urlConfiguaton", "urlConfigURATION", "urlconfigoracion", "urlConfigulaci", "urlExecuraton", "urlConfigurateacion", "urlConfigoricion", "urlExecurateatable", "urlExecurateacion", "urlconfiguraci", "urlExecurator", "urlconfiguaton", "urlConfigoraton"], "configuracion": ["figurance", "execurableation", "configureraton", "configurableation", " configureacion", "configureATION", "configurance", "configuraci", "configauricion", "configaurcation", "configureracion", "configurericion", "configurateaci", "configuratecation", "configauracion", "configuration", "configurationATION", "configurATION", "configurableacion", "execurableATION", " configurATION", "figureaton", " configureaci", "figureicion", " configuraton", "figuracion", "configureacion", "execurableaton", " configureicion", "configuicion", "configauraci", "configuance", "configurationation", "execurATION", "configureicion", "configureation", " configurecation", "configurateacion", "execuration", "configurationacion", "execurableacion", "configureaton", "execuracion", "configauraton", "configurationaton", " configuricion", "configurationicion", "figuraton", "configureaci", "configurateaton", "configuaton", "configurerATION", "configurcation", "figuricion", "configuricion", "configurecation", "configaurance", "figureance", "configurableaton", " configureATION", " configuraci", "configureance", "configurableATION", "configuacion", " configureaton", "figureacion", "configuraton", " configurcation", "execuraton"], "xenc": ["xorc", " xvec", " xEnc", " xen", "axorc", "axdec", "xEnc", "uxdec", "uxenc", "xen", "XEnc", "axvec", "xec", "rxec", "xvec", "uxvec", " xorc", " xdec", "Xen", "xtdec", " xec", "xten", "xdec", "uxorc", "Xenc", "xtenc", "axenc", "rxen", "rxenc", "rxEnc", "xtEnc", "Xec", "Xdec"]}}
{"id1": "11962480", "id2": "13152325", "code1": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"read": ["parse", " Read", "create", "download", "store", "reading", "index", "define", "seek", "load", "open", "write", "init", "copy", "loads", "file", "construct", "library", "config", "READ", "update", "find", "empty", "delete", "Read", "reads", "readable"], "skeletonFilename": ["Skeletonfilename", "skeletonResource", "soleFilename", " skeletonURL", "Skelfilename", "sootFilename", "SkeletonResource", "SkeletonBas", "SkeletonString", " skelSourceFile", " skelURL", "skeletonSourceFile", "satelliteString", "SkeletonFile", "skelBas", "sanefilename", "saneResource", "skelFile", "sootTitle", "saltFile", "skelSourceFile", "siteString", "siteBas", "satelliteFilename", "soleFormat", "saneFilename", "skelFormat", "saltURL", "siteFilename", "soleFile", "SkelTitle", "sadeFilename", "SkeletonTitle", "skelURL", "saltSourceFile", "SkelResource", "skeletonfilename", "satelliteFile", "skeletonString", "SkeletonFormat", "SkelFilename", "skeletonFile", "skelFilename", "SkelFile", "skeletonURL", "sadefilename", "skelTitle", "skelString", "siteFile", "soleTitle", "skelfilename", "sootFormat", " skeletonFile", "skeletonFormat", "skeletonTitle", "skeletonBas", "SkelString", "SkeletonFilename", "satelliteBas", " skeletonSourceFile", "SkelFormat", "sadeFile", "sadeResource", " skelFile", "saltFilename", "SkelBas", "skelResource", "sootFile", "saneFile", " skelFilename"], "loader": ["l", "inner", "kernel", "loop", "label", "folder", "system", "parser", "hl", "loaded", "load", "older", "upper", "builder", "wrapper", "language", "handler", "license", "later", "program", "container", "class", "context", "owner", "module", "finder", "er", "loads", "acl", "resource", "Loader", "library", "cl", "lib", "loading", "lr", "pool"], "url": ["browser", "http", "b", "entry", "link", "web", "l", "html", "rl", "address", "server", "key", "rel", "user", "location", "lb", "base", "load", "name", "loc", "builder", "open", "client", "f", "mail", "dl", "org", "ref", "build", "ur", "nl", "mount", "manager", "URL", "resource", "file", "impl", "result", "Url", "job", "sl", "github", "host", "lr", "path", "util", "channel", "ls", "uri"], "line": ["entry", "rule", " lineage", " message", "link", "print", "l", "continue", "lin", "eline", "L", " LINE", " headline", "body", "chain", "label", "string", " inline", "lines", " comment", "lo", "area", "sequence", "field", " sequence", "cmd", " error", "side", "text", "row", "inline", " chunk", "ine", " row", " entry", "Line", "cell", "channel", "nl", "e", "sample", "liner", " frame", "column", "comment", "ln", "block", "word", "zone", " linen", "next", "le", "normal", "LINE", "file", "lane", "level", "value", "log", " code", "job", " blank", "ice", "point", "part", "message", "page", " block", " equation", "buffer", "frame", "online"], "section": ["entry", "summary", "setting", "list", "null", "tab", "network", "header", "session", "function", "key", "second", "ner", "statement", "user", "string", "system", "journal", "room", "state", "group", "area", "sequence", "table", "prefix", "description", "field", "writer", "language", "division", "side", "number", "row", "sect", "connection", "ment", "unit", "script", "Section", "comment", "position", "block", "format", "se", "library", "job", "part", "member", "set", "storage", "article", "variable", "region", "event", "sections", "sector", "option", "termination", "tag", "page", "channel", "length", "buffer", "character"], "reader": ["entry", "rl", "inner", "Reader", "ro", "ser", "input", "parser", "reading", "ner", "anger", "rar", "rot", "upper", "older", "rx", "builder", "reverse", "handler", "writer", "layer", "oder", "row", "context", "runner", "iter", "roller", "cur", "er", " Reader", "stream", "iterator", "file", "rr", "driver", "mr", "r", "length", "buffer"]}}
{"id1": "4778473", "id2": "9687813", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadProproperties", "loadproperties", "loadPropperties", "loadProdates", "initPrperties", "loadprodates", "initProproperties", "initProps", "loadproproperties", "loadProps", "loadPrdates", "initProperties", "initProdates", "initPrproperties", "loadPrproperties", "loadPrperties", "initPrps", "loadPropps", "loadPrps", "loadPropproperties", "initPrdates", "loadPropdates", "loadprops"], "properties": ["reports", "to", "types", "objects", "bugs", "prop", "settings", "policy", "members", "keys", "parts", "property", "options", "posts", "features", "database", "papers", "pro", "details", "people", "sheets", "facts", "tests", "organisms", "rules", "where", "rows", "units", "results", "metadata", "jobs", "names", "changes", "relations", "packages", "beans", "modules", "holders", "notes", "params", "states", "builders", "ps", "projects", "this", "abilities", "perties", "ports", "marks", "comments", "poses", "values", "terms", "prints"], "url": ["browser", "http", "b", "rect", "l", "ll", "rl", "address", "obj", "user", "p", "location", "open", "char", "f", "str", "abs", "ret", "dl", "u", "ref", "build", "ur", "nl", "context", "bel", "mount", "URL", "resource", "file", "service", "loader", "result", "Url", "config", "sl", "kl", "id", "sb", "ls", "uri"]}}
{"id1": "5436973", "id2": "15472181", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"httpToStringStupid": ["httpToStrStuid", "httpToStrStuff", "httpToStringUuid", "httpToStrUuid", "httpToStrStupid", "httpToStringRestuid", "httpToStringRestupid", "httpToStringRestuff", "httpToStringUuff", "httpToStringUamp", "httpToStringSnuff", "httpToStringSnamp", "httpToStrUamp", "httpToStringUupid", "httpToStrUupid", "httpToStringStuff", "httpToStringSnuid", "httpToStrUuff", "httpToStrStamp", "httpToStringStuid", "httpToStringSnupid", "httpToStringRestamp", "httpToStringStamp"], "url": ["http", "b", "pl", "link", "web", "l", "ll", "address", "key", "server", "string", "location", "p", "base", "name", "loc", "password", "char", "str", "ul", "ssl", "dl", "u", "ref", "ret", "ur", "https", "URL", "file", "pattern", "result", "Url", "id", "host", "path", "page", "out", "i", "ls", "uri"], "IOException": ["TimeoutError", "TimeoutException", "ioException", "ioError", " IOError", "IOError"], "HttpException": ["RuntimeException", "HttpError", "HTTPError", "httpException", "HTTPException", "httpError", "RuntimeError"], "InterruptedException": [" InterruptException", "InterruptionEx", "InterruptionError", "InterinterruptedEx", "InterruptEx", "InterruptedEx", "InterinterruptedException", "InterruptError", "InterruptedError", " InterruptedError", " InterruptError", "InterinterruptedError", " InterruptedEx", "InterruptionException", " InterruptEx", "InterruptException"], "URISyntaxException": ["URISyntlexEx", "URISyntlexWarning", "URISeticaxEx", "URISeticntaxWarning", "URISyntixEx", "URISeticntaxEx", "URISyntntaxWarning", "URISyntaxEx", "URISyntixWarning", "URISyntntaxException", "URISeticntaxException", "URISyntaxWarning", "URISeticaxWarning", "URISyntlexException", "URISyntixException", "URISyntntaxEx", "URISeticaxException"], "pageDump": ["pageStump", "pageSump", "pageStdump", "pageDoumper", " pageDumper", "pageDumps", "pageSumper", "pagePash", "pagedump", "pageDoump", " pageDamp", "pageDumper", "pagedumps", "pagePdump", "pageStash", "pagePump", "pageStamp", "PageDumps", "pageDodump", "pageSumps", "pageDoumps", "PageDumper", "PageDdump", "pageDdump", "pagePamp", "PageDump", "pageddump", "pageSdump", "pagedumper", " pageDumps", "pageDamp", " pageDash", "pageDash", " pageDdump"], "httpget": [" httpGET", " httpfind", "ttppost", "httpcall", " httppost", "ttpcall", "ttpget", "httpGET", "HTTPget", "hoverGet", "httpfind", " httpGet", "ttpGet", "HTTPGet", "httpcreate", "HTTPfind", "Httppost", "Httpget", " httpcreate", "hoverGET", "ttpfind", "Httpfind", "httppost", "HTTPGET", "hovercreate", "ttpcreate", "hoverget", "HTTPcreate", "httpGet", "Httpcall", " httpcall"], "response": ["entry", "report", "pos", "command", "resp", "body", "respond", "res", "onse", "status", "that", "yes", "answer", "document", "sequence", "still", "description", "attribute", "open", "json", "connection", "application", "reply", "request", "block", "next", "service", "profile", "result", "Response", "successful", "content", "object", "event", "output", "message", "given", "page", "remote", "frame"], "entity": ["entry", "security", "detail", "address", "body", "obj", "pe", "el", "inv", "environment", "Entity", "activity", "image", "ee", "group", "ITY", "document", "person", "email", "json", "ity", "icon", "unit", "e", "me", "comment", "ce", "metadata", "resource", "existent", "result", "ent", "model", "encrypted", "voice", "content", "object", "event", "output", "page", "ie", "line"]}}
{"id1": "2834524", "id2": "17729554", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"write": ["print", "link", "rite", "create", "flush", "filter", "download", "end", "export", "commit", "append", "save", " rewrite", "check", "println", "next", "add", "file", "handle", "service", " overwrite", "dump", "Write", "read", "update", "zip", "lock", "apply"], "jarOut": ["jamOver", "javaStore", "JarOver", "javaIn", "JarNet", "jarStore", "JarStore", "javaOutput", "pkgNet", "JarOut", " jarIn", " jarStore", "jamIn", "JarIn", "javaout", "jarOver", "pkgOut", "browserOut", "jarOutput", "jarIn", "pkgIn", "pkgOver", "browserIn", "jarGen", "javaGen", " jarGen", "Jarout", "jarout", "browserOutput", "javaOut", "JarGen", "jarNet", "browserout", " jarOutput", " jarout", "jamOut", "jamNet", "JarOutput"], "allEntries": ["allEntarts", "allents", "allentrys", " allentries", "allEnarts", "allEntlections", "allEntryies", " allEntrys", "allentries", " allentrys", "allentlections", "allEntryrys", " allenties", " allEnts", " allEntarts", "allENTies", "allEntrys", "allENTrys", "allEnts", "allENTries", "allentarts", "allEnies", "allEntryries", " allEntlections", "allEnties", " allEnties", "allenties", "allENTlections", "allEnrys", "allEnries", " allents"], "iterator": ["menu", "timer", "walker", "list", "continue", "pointer", "operator", "ippy", "inner", "members", "loop", "former", "instance", "ator", "reader", "database", "starter", "table", "sequence", "builder", "immigration", "ski", "collection", "writer", "trace", "Iterator", "inator", "river", "number", "issues", "outer", "ter", "sample", "runner", "liner", "pie", "finder", "copy", "iter", "size", "vector", "internet", "next", "stream", "counter", "versions", "series", "loader", "range", "integer", "creator", "set", "iner", "pee", "tmp", "values", "iver", "i", "rows", "current"], "jar": ["browser", "entry", "parse", "batch", "tab", "pkg", "magic", "cp", "jo", "folder", "rar", "war", "java", "tar", "jp", "cert", "cf", "pack", "char", "pod", "bag", "jj", "json", "class", "j", "vol", "sp", "bare", "module", "dir", "Jar", "be", "zone", "gem", "resource", "file", "library", "job", "car", "binary", "zip", "lib", "archive"], "jarEntries": ["jarEntires", " jarEnties", "jarContities", " jarEntents", "Jarenties", "jarContries", "jarContrys", "Jarentires", "jarentents", "jarentrs", "jarEnrys", "Jarentrs", " jarContents", "jarMatires", "jarEnties", " jarenties", "Jarentries", " jarContrys", " jarEntities", "jarEnries", "JarEntries", "JarEntrs", " jarentarts", "jarAddents", "jarIntrs", "jarMaties", "jarMatrs", "jarAddies", "jarInties", " jarContries", "jarentires", "jarenties", "jarEntents", "jarEntarts", "jarIntires", "JarEntires", "jarentries", "jarentarts", "jarEarts", "jarAddries", " jarEntrys", "jarEnents", "jarIntries", " jarentries", "jarMatries", "jarContents", "jarEnities", "JarEnties", "jarEries", "jarAddarts", "jarEents", " jarEntarts", " jarentents", "jarEntrs", "jarEies", "jarEntrys", "jarEntities", " jarContities"], "o1": ["oa11", "aOne", "os1", "eOne", "os512", "o5", "icoone", "co11", " o0", "e1", " oone", "a0", "a2", "ico512", "e512", "oOne", " o512", "o10", "oo10", " o2", "a1", "o8", "oa6", " oOne", " o10", " o5", "oo8", "e5", " o11", "ico2", "co6", "e0", "o0", " o8", " o6", "ico1", "oa8", "o11", "eone", "co2", "co1", "oo1", "o2", "o512", "e2", "oa1", "os5", "oone", "oa2", "os2", "oa10", "o6"], "entryStream": ["EntrySteam", "resultSteam", "resultPage", "enterStream", "inputStreamer", " entryPage", "entryStreamer", "rowStream", "EntryForm", "resultStream", "entrySteam", "EntryStream", "enterForm", "inputForm", "enterStreamer", "inputStream", "rowPoint", "resultPoint", "entryForm", "EntryStreamer", "entryPoint", "enterSteam", "rowPage", "rowSteam", "entryPage", "inputSteam", " entryPoint", " entrySteam"]}}
{"id1": "12055086", "id2": "3375718", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"copyDeleting": [" copydeleing", " copydeleting", " copydeletving", " copyDeletging", " copyDeeleing", " copyDeleging", " copydeletging", " copyDeeleving", " copyDelingging", " copyDeeleging", " copyDeeleting", " copyDeleving", " copydeletting", " copyDeleing", " copyDeletving", " copydeleving", " copyDelingving", " copyDelinging", " copydeleging", " copyDelingting", " copyDeletting"], "source": ["back", "oss", "SOURCE", "body", "site", "target", "input", "store", "seed", "image", "template", "base", "form", "style", "sql", "src", "scope", "sp", "init", "sample", "ource", "origin", "ace", "Source", "ce", "search", "resource", "from", "local", "service", "se", "original", "start", "query", "spec", "parent"], "dest": ["d", "rest", "null", "comb", "it", "cat", "them", "target", "dist", "mm", "th", "bin", "loc", "decl", "Dest", "end", "nom", "trans", "img", "cas", "pub", "est", "src", "sp", "dir", "st", "origin", "pas", "https", "port", "w", "master", "exp", "del", "lit", "tom", "temp", "way", "orig"], "buf": ["b", "cast", "batch", "capt", "aka", "comb", "bh", "Buffer", "prop", "tab", "cat", "pkg", "cp", "data", "meg", "buffer", "seq", "arr", "uf", "rb", "cmd", "alph", "cf", "bag", "str", "img", "ref", "fg", "br", "buff", "cap", "cb", "box", "bytes", "pause", "vec", "block", "cur", "fb", "cv", "tx", "bc", "eb", "bl", "db", "Buff", "bs", "conv", "bus"], "in": ["inf", "IN", "inc", "it", "al", "inner", "cin", "ins", "user", "input", "mm", "el", "ind", "rin", "bin", "inside", "In", "ini", "is", "by", "or", "un", "ze", "isin", "init", "con", "info", "iter", "ri", "ai", "from", "gin", "read", "en", "inn", "on", "per", "ic", "din", "i"], "out": ["o", "v", "to", "n", "dis", "conn", "oss", "inner", "sum", "flush", "obj", "res", "OUT", "at", "os", "up", "ou", "Out", "io", "aos", "writer", "client", "by", "end", "outer", "sys", "conv", "co", "write", "con", "ion", "t", "log", "auto", "can", "en", "output", "outs", "on", "net", "i", "cn", "ne", "page", "nt"], "count": ["n", "acc", "code", "batch", "ctr", "num", "span", "amount", "sum", "q", "found", "index", "total", "ind", "cond", "c", "len", "char", "ct", "core", "number", "cont", "ch", "common", "cap", "comment", "Count", "counter", "size", "check", "add", "t", "coll", "now", "start", "max", "cloud", "read", "ount", "current", "deep", "conf", "nb", "cc", "length", "z", "nt"]}}
{"id1": "17083703", "id2": "19147281", "code1": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"savaRolePerm": ["sDeleteRolePERm", "sDeleteRoleProm", "sDeleteResourcePerms", "sDeleteRolePerms", "sDeleteResourcePerM", "sDeleteRolePerm", "sDeleteRoleProms", "sDeleteRolePERms", "sDeleteResourcePerm", "sDeleteResourceProm", "sDeleteRoleProperm", "sDeleteRolePERperm", "sDeleteResourcePerperm", "sDeleteRolePerM", "sDeleteResourceProperm", "sDeleteRolePERM", "sDeleteResourceProms", "sDeleteResourceProM", "sDeleteRolePerperm", "sDeleteRoleProM"], "roleid": ["roleoid", "relationids", "rooid", "rolepid", " roleoid", "resourceId", "oleoid", "relationid", "resourceids", " roleId", "roleId", "roid", " rolepid", " roleids", "oleid", " rolename", "oleinfo", "olename", "roleinfo", "resourceid", "relationId", "rolename", "roinfo", "roname", "roleids", "relationpid", "resourcepid", " roleinfo"], "role_perm_collect": ["role_priv_collection", "role_compl_ct", "role_perm_draw", "role_priv2collection", "role_per_cont", "role_priv_Collect", "role_perm2collect", "role_per_coll", "role_perm_ct", "role_per_draw", "role_priv2coll", "role_perm_coll", "role_compl_coll", "role_perm_cont", "role_priv_coll", "role_perm_Collect", "role_perm2Collect", "role_permptdraw", "role_priv2collect", "role_perm2collection", "role_priv2Collect", "role_compl_collect", "role_permptcoll", "role_permptcont", "role_permptcollect", "role_perm_collection", "role_priv_collect", "role_perm2coll", "role_per_collect"], "cp": ["CP", "priv", "cd", "pkg", "cop", "lc", "px", "pd", "wp", "proc", "ctx", "Conn", "c", "jp", "cmd", "cf", "ct", "core", "fp", "tp", "rc", "cr", "ch", "cap", "cb", "cmp", "con", "pc", "cs", " CP", "mp", "mk", "vp", "pp", "ctrl", "cod", "cfg", "cm", "ec", "ps", "cc", "cn", "p"], "conn": ["pg", "pkg", "dial", "rel", "Conn", "req", "msg", "c", "jp", "cf", "client", "ont", "bo", "org", "wd", "act", "nc", "mem", "con", "pas", "connect", " con", "t", "local", " cur", "dt", "n", "ca", " ac", "link", "session", "ctx", "open", "cert", "cmd", "fn", "die", "comm", "gn", "j", "cb", "coll", "handle", " cx", "config", "addr", "pool", "p", "nt", "syn", "gate", "yn", "rn", "ann", "resp", "call", " cc", "ct", "enc", "ssl", "ch", "og", "trust", "cur", "mn", "close", "ain", "conf", "db", "on", "out", "ns", "bind", "ctr", "lang", "wp", "obj", "dc", "col", "tp", "connection", "sql", "co", "sync", "mt", "ce", "dn", "gc", "cfg", "g", "ait", "cc", "cn", "conv"], "rs": ["ds", "RS", "ris", " cs", "rt", "rl", "res", "ro", "re", "os", "rc", " rc", " res", "ls", "cs", " ss", "ri", "rm", "s", "Rs", "ts", "mr", "ps", " ra", "ns", " ls", " ps", "sr"], "pstmt": ["pstyms", "pStbl", "pstmk", "Pstmd", "pstcond", "pstatms", "pputmt", "apStbl", "postsql", "prestmn", " pswmb", "pstatemt", "apstbl", "pstdst", "postmn", " pstmd", " pstms", "pstrmg", "pstdbl", "pstatmt", "Pstat\t", "prestlt", " psttr", " pstatmt", "apStmt", "Pstatmd", "pstart\t", "pstmg", "psttr", " pStmt", "pStst", "pstbl", "pestms", "pst\t", "Pstatmk", "PstatMT", "Pstmt", "apStmb", "prestmt", "Pstsql", "postmd", " pStmb", "pctMT", "pstdmb", " prestmn", "postm", "Pstrs", "pstatlt", "Pstatlt", "Pstlt", " pstmb", "pstmsg", " pststat", "pstrmt", "pstmd", "Pstcond", "pstatrs", "pstlt", "pSTtr", "pstatem", "Pstatrs", "pstsql", "pconstmb", "Pstmg", " pstatm", "pstrm", "prestMT", " pstemb", "Pstatmg", "pstatstat", "pconstm", "prestm", " pstatmn", "pswemb", "Pstm", "pstmn", "pstyemb", "pctmt", "pputmk", "postmt", "Pstatmsg", " presttr", "postmsg", "pstremb", "pstymt", "pStm", "apstst", " pstatmd", "pconststat", "Pstmk", "apStst", "pstatst", "pstatecond", "ptrym", "pstymb", "pswmt", "Pstatmt", "pestmt", " pswemb", "pputm", "pctmd", "pstatmb", "pStmt", "pstst", "pstrmn", "apstmb", "Pst\t", " prestMT", "pststat", "pstmb", "Pstatcond", "pstrmb", "pstrmd", " pswmt", "pstatMT", "pStstat", "prest\t", "pstatmk", "pSTmn", "Pstms", "pputcond", "pestMT", " pstmn", "pstat\t", "pstm", "pstatmd", "pswmb", "pstatmsg", " pStm", "Pstatms", "pstrrs", "pstatsql", "pstartm", "pstartlt", "pstatemk", "pstMT", "pstms", "pSTMT", "pputrs", " prestmt", "pstemb", "pstartmt", "presttr", "pstrs", "pstatmn", "ptrymsg", "ptrysql", "pctms", "Pstatm", "pstrms", "pSTmt", "pstatcond", "pstdmt", "Pstatsql", " pstm", "Pstmsg", "PstMT", "pstatmg", "pStmb", "pestm", "pstatm", "pputmg", " pstMT", "pconstmt", "pstattr", "ptrymt", "pswms", " pswms", "pctm", "pstatbl", " pStstat", "apstmt"], "factory": [" foo", "cfictionary", "fictionary", "tade", " fFactory", "fFactory", "tFactory", "FFactory", "cfFactory", " fade", "tactory", "Fictionary", "cfactory", "fade", "Factory", "tacter", "Facter", "cfoo", "Foo", "facter", " facter", " fictionary", "Fade", "foo"], "op": ["o", " dop", "operation", " operate", "ops", " ep", "Operation", "OP", " cop", " opt", "Op", " act", "oe", " ov", " oper", " opp", " pop", " ip", " operator", " OP", "oper", " operational", " ops", " Operation", " Op", "iop", "p", " co"], "role_perm_ir": ["role_proc_et", "role_permrenet", "role_proc_i", "role_permmmi", "role_permobjyr", "role_permobjir", "role_permrenir", "role_perm_i", "role_permrenier", "role_proc_yr", "role_perm_ier", "role_proc_ir", "role_perm_et", "role_permmmyr", "role_priv_IR", "role_priv_iter", "role_permobjoi", "role_permmmoi", "role_perm_IR", "role_proc_ier", "role_perm_yr", "role_proc_iter", "role_permmmir", "role_permobji", "role_perm_iter", "role_proc_oi", "role_priv_i", "role_permreniter", "role_perm_oi", "role_priv_ir"], "rolePerm": ["olePerm", "olePERmission", "roleParp", "rolePersM", "rolePERmission", "rolePERmn", "olePerperm", "oleParperm", "rolePartm", " rolePerM", "rolePermn", "roleperM", " rolePerp", "rolePartperm", "rolePersl", "roleParg", "rolePERm", "rolePM", "rolePartr", "rolePp", "olePERg", "roleElem", "rolePERp", "oleParm", "roleParm", "rolePc", "roleParM", " roleParm", "roleEleM", "rolePerperm", "roleEleg", "rolePERc", " roleParM", "olePerl", "rolePermission", "roleParc", "rolePerg", "roleLikemn", "roleperl", "olePerg", "roleperm", "roleElemn", "roleLikeM", "rolePERperm", "rolePERM", "rolePerc", "olePERl", "rolePerM", " roleParp", "roleLikeg", "rolePersmission", "oleParg", "rolePerl", " rolePerc", "rolePERr", "olePERm", "olePERmn", "rolePersm", "roleParperm", "olePermission", "olePermn", "roleParr", " roleParc", "rolePERg", "olePERM", "rolePERl", "rolePerr", "oleParr", "rolePartg", "olePerM", "rolepermission", "olePerr", "rolePerp", "roleLikem", "rolePm"]}}
{"id1": "20924119", "id2": "13595251", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"gzip": ["GZip", "mZip", "marchive", "Gzip", "Garchive", " gZip", "garchive", "Gdef", " garchive", " gdef", "mdef", "mzip", "gdef", "gZip"], "zipout": ["pipein", "pipenet", "gzOut", "zipconn", "gzop", "gzconn", " zipnet", " zipop", "lockconn", "zin", " zipo", "pipeout", "login", "zOut", "gzin", "gzo", "logout", "zipo", "zouts", "zipin", "zipop", "gzout", "zout", " zipin", " zipconn", "zipOut", "locko", "logouts", " zipou", "zipou", "lockop", "znet", "pipeou", "zou", "lockout", "zipnet", "zipouts", "gzouts", "logOut"], "buffer": ["batch", "code", "cache", "Buffer", "command", "header", "data", "memory", "paste", "window", "string", "database", "seed", "limit", "table", "sequence", "document", "button", "attribute", "password", "char", "pad", "buf", "number", "row", "queue", "device", "mem", "phrase", "append", "buff", "sample", "comment", "bytes", "stack", "block", "size", "word", "stream", "result", "variable", "binary", "message", "history", "frame", "line"], "dir": ["d", "rect", "pos", "md", "cd", "pkg", "dat", "direct", "rel", "root", "doc", "desc", "dist", "folder", " directory", "directory", "DIR", "dr", "ind", "self", "det", "ir", "cond", "req", "loc", "dd", "fin", "df", "wd", "dl", "vol", "parent", " Dir", "dra", "div", "draw", "ory", "iter", "cur", " director", "add", "file", "mk", "fd", "del", "part", "def", "db", "tmp", "path", "ord", "out", "Dir", "tree"], "in": ["inf", "oin", "IN", "inc", "ex", "it", "al", "inner", "cin", "ins", "el", "input", "reader", "ind", "rin", "bin", "im", "up", "inside", "In", "is", "ini", "form", "act", "isin", "init", "and", "iter", "win", "ri", "check", "gin", "from", "read", "en", "ain", "inn", "sin", "on", "like", "ic", "out", "din", "i", "source"], "length": ["capacity", "time", "l", "ength", "duration", "data", "angle", "full", "body", "index", "total", "padding", "database", "ind", "available", "distance", "volume", "load", "shape", "sequence", "type", "char", "end", "frequency", "number", "row", "SIZE", "join", "count", "character", "Length", "position", "size", "port", "ENGTH", "impl", "start", "needed", "read", "tail", "match", "hello", "component", "message", "history", "before", "family", "height", "text", "len"]}}
{"id1": "17724879", "id2": "16556717", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getDigest": ["getdigest", " getMDse", "getHashested", "getdigse", "getDigEST", "getMDEST", "getMDest", "getDigse", "getDigested", " getMDEST", "getHashest", "getdigested", " getMDested", " getMDest", "getMDested", " getDigested", "getdigEST", " getDigse", "getMDse", "getHashEST", " getDigEST", "getHashse"], "attribute": ["report", "entry", "att", "Attribute", "operation", "command", "policy", "space", "operator", "al", "data", "address", "missing", "property", "input", "attr", "directory", "expression", "information", "at", "name", "document", "description", "type", "password", "definition", "associated", "subject", "pair", "application", "and", "element", "request", "position", "word", "metadata", "add", "value", "argument", "qualified", "ribute", "member", "variable", "article", "relation", "object", "management", "event", "ident", "message", "option", "reference", "a", "each", "communication", "character", "item"], "digestAlgorithm": ["digestPalgorith", "digestalgorithm", "digestSchego", "digestALgorithm", "digesterAlgorith", "digestSchegorithm", "digesterAlgo", "digesterAlgorithm", "digestsAlgorithm", "digestPalgo", "digestALgebra", "digestalgo", "digesteralgorithm", "digestsAlgo", "digestAlgorith", "digestPalgebra", "digestAlgo", "digestalgorith", "digesteralgebra", "digestAlgebra", "digesteralgo", "digestSchegebra", "digesterAlgebra", "digestALgorith", "digestsalgebra", "digestsalgorithm", "digestALgo", "digestsAlgebra", "digesteralgorith", "digestalgebra", "digestsalgo", "digestPalgorithm"], "digest": ["mdested", "equest", "digests", "Digested", "diagnitude", " digist", "Digest", " digested", "Digests", " digEST", "Digist", "equend", "designests", "designest", "hashest", "mdtest", "digitude", "DigEST", "mdest", "digested", "diagnested", "hashend", "Digtest", "mditude", " digests", "diagnest", " digse", "digtest", "equEST", "digEST", "Digse", "designEST", " digtest", " digitude", "digend", "hashested", "diagnse", "mdse", "digist", "Digend", "digse", "designist", "hashEST", "equested"], "md": ["d", "m", "amd", "mg", "pt", "cd", "js", "ld", "strong", "bd", "pd", "hd", "grad", "MD", "mm", "det", "dr", "ind", "pm", "mac", "cond", "mod", "rpm", "cmd", "dd", "ct", "red", "der", "df", "met", "wd", "pdf", "ms", "nd", "ud", "dh", "mc", "mt", "ma", "mn", "managed", "metadata", "rm", "mind", "mk", "sm", "fd", "sd", "good", "dm", "di", "esm", "mb", "ds", "nt"]}}
{"id1": "14390569", "id2": "23161545", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"title": ["summary", "theme", "html", "header", "TIT", "parts", "hd", "question", "filename", "hash", "label", "string", "padding", "term", "msg", "template", "tip", "name", "itle", "layout", "prefix", "description", "type", "lead", "password", "details", "notice", " Title", "subject", "Title", "setup", "size", "metadata", "t", "help", "start", "heading", "content", "message", "holiday", "text"], "imageURL": ["mediaID", "fileURL", "photoURI", "ImageURI", "imageURI", "ImageURL", "imageUrl", "fileUrl", "mediaURL", " imageUR", "imageUR", "imageString", "fileString", " imageUrl", "ImageID", "photoURL", "ImageUR", " imageURI", "fileURI", "ImageUrl", "imageID", "mediaUrl", "photoUR", " imageString", "photoID", "photoUrl", "mediaURI", "photoString"], "jd": ["simD", "ujD", "Jp", "simmd", "ujdt", "djc", "jjD", "simd", "djad", " jsd", "ajpd", "kd", "jobdo", " jdt", "qdo", "javapd", "jbd", "djsd", "simdt", "JD", "kdo", "zad", "djdo", "jdm", "kds", "Jbd", "gdo", "jpd", "qds", "jds", "djd", "ijds", "zsd", " jc", "jc", "jsdm", "jspd", "Jc", " jad", "jdo", "gbd", "Jmd", "jsD", " jD", "jmd", "Jd", "ijd", "javad", " jds", "gds", "ujd", "jsd", "ajds", "jjd", "qd", "qD", "kdt", "Jdt", "ujmd", "qbd", "Jds", "ijD", "gd", "jobd", "javads", "qp", "ajd", "ujad", "kbd", "Jdo", "jdt", "djds", "Jad", "jjbd", "zd", "ajdm", "javadm", " jdo", "jjp", "jsds", "jad", "jobdt", "jD"], "jl": ["syn", "ij", "bj", "js", " li", "rl", "ja", "elt", "dll", "bol", "li", "kj", "dyl", "jj", "jac", "il", "gn", "dl", "lv", "jin", "j", "lp", " ol", "nl", "lu", "txt", "Label", "ln", "dj", "uj", "abl", "jet", "yl", "kl", "jc", "kel", "jah", "ijk", "igl", "isl", "ibl", "elle", "J", "elly", "mil", "ji", "kn", "ell"], "icon": ["syn", " tip", "fa", " captcha", " intent", "eric", "conn", "ex", " lang", "label", "image", " screen", "addon", "fn", "Icon", " Icon", "chron", "iao", "icons", "cil", "ocon", " conn", "con", "font", "ion", "ico", " ion", "gc", "pic", "jc", " canvas", "iban", " ancestor", " fruit", "icol", "pen", "png", "ICO", " widget", "lock", "ic", "\u4e2d", "cn", "conv", "nic"], "chooser": ["poose", "boerer", " choicer", " chooder", "poicer", "choose", "Choose", "pooder", "choosen", "chooder", "composer", " choerer", "booser", "compicer", "CHOosen", "boose", " choosen", "CHOose", "compose", "choerer", "pooser", "Chooser", "boosen", "choicer", "Choosen", " choose", "CHOicer", "Choicer", "comperer", "composen", "CHOoser", "Chooder"], "jp": ["ij", "bj", "js", "np", " sip", "ja", " np", " gp", " je", " joint", "kj", "bp", " sp", " pic", "j", "jin", " cp", "sp", " mp", " ip", "JP", " dj", " ap", "btn", "pic", "jc", " pl", " ja", "p"], "jb": ["jbd", "Jb", "qbd", "kjcb", " jcb", "Jbd", "jcb", "qcb", "Jcb", "kjbd", "qb", "kjb", " jbd"], "e": ["d", "o", "m", "v", "n", "ed", "it", "re", "ee", "c", "f", "u", "er", "ev", "w", "t", "s", "te", "es", "E", "en", "g", "event", "Event", "a", "or", "ie", "p"], "returnVal": ["retVAL", " returnVol", "getVAL", "ReturnVal", "getVol", " returnVAL", "responseVol", "getValid", " returnValue", "retValue", "returnValid", "returnval", "responseVal", "Returnval", "returnVAL", " returnval", "returnValue", "responseValid", "ReturnVAL", "returnVol", "responseVAL", "getVal", "ReturnValue", " returnValid", "retVal", "retval"], "file": ["http", "report", "to", "rule", "link", "null", "fe", "create", "angle", "h", "body", "full", "filename", "target", "user", "image", "status", "base", "name", "table", "document", "open", "io", "type", "f", "ile", "core", "il", "channel", "fp", "class", "valid", "stat", "dir", "work", "real", "info", "word", "be", "port", "le", "resource", "handle", "File", "format", "local", "library", "fs", "model", "relation", "get", "run", "db", "path", "place", "page", "drop", "or", "buffer", "foo", "FILE", "tree", "source"], "fileName": [" fileSystem", "taskFace", "entitySet", "fileSet", "handlename", "FileNames", "imagePath", "fileExt", " filePath", "FILENames", "ileNAME", "filename", "FILEExt", "FILENAME", " fileNAME", "entityNAME", "taskPath", "fileFace", "FileExt", "FileSet", "fileNames", "fileClass", " fileExt", "FILESystem", "FileNAME", "FILESet", "fileNAME", "Filename", "FileSystem", "FILEName", "fileSystem", "entityPath", "entityName", "FileName", "ilename", "taskName", "FILEPath", "handleNAME", "FileFace", "FilePath", "ileClass", " fileNames", "ileName", "imagename", " filename", "taskname", "filePath", " fileClass", "imageFace", "handleClass", "imageNAME", "handleName", "imageName"], "ext": ["ex", "test", "desc", "EXT", "ind", "req", "exc", "aux", "external", "cmd", "pat", "ct", "end", "cont", "ag", "Ext", "enc", "lex", "xp", "dir", "off", "hex", "word", "sem", "t", "exp", "ix", "part", "xt", "cod", "def", "exe", "fr", "vert", "typ", "prot", "ec", "lib", "ord", "eur", "txt", "len"], "i": ["m", "ci", "ui", "print", "it", "ei", "gi", "phi", "index", "status", "ori", "y", "ini", "li", "ii", "iu", "is", "fi", "bi", "pi", "j", "init", "info", "cli", "ai", "ti", "mi", "hi", "id", "di", "I", "si", "xi", "qi"], "doIt": [" doWhich", " doIs", "didIs", "donIt", " doit", "waIt", "doHe", "donIT", "odoHe", "doit", "didYou", "doneIt", "doneit", "diIt", "doWhich", " doYou", "didit", "doYou", "waIs", "donit", "odoIT", "doIs", "donYou", "diit", "odoWhich", "odoIt", " doHe", "diHe", "didIt", "doneIT", "odoit", "doIT", " doIT", "donIs", "diWhich", "waIT"], "src": ["syn", "http", "comp", "rest", "sh", "ctr", "rl", "rt", "inner", "rob", "proc", "sec", "rel", "ins", "ser", "input", "lb", "rs", "rx", "loc", "rb", "ources", "trans", "cont", "ssl", "usr", "sys", "conv", "rc", "init", "st", "ource", "copy", "ptr", "https", "inst", "url", "crop", "from", "impl", "start", "sl", "sc", "sub", "sb", "tmp", "r", "sr", "gs", "sq", "source"], "dest": ["way", "rest", "comb", "gest", "cat", "cp", "dat", "proc", "target", "rel", "desc", "dist", "des", "loc", "decl", "Dest", "nw", "nom", "cont", "trans", "sys", "usr", "mem", "est", "sp", "dir", "st", "pipe", "origin", "iter", "pas", "https", "port", "slave", "local", "pot", "master", "can", "coord", "foreign", "output", "tmp", "temp", "out", "orig", "source"]}}
{"id1": "2642914", "id2": "16931472", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"addFileToTarGz": ["addFileToTarJz", "addFileToTarGsp", "addFileToTarGszip", "addFileToTarJw", "addFileToTarBx", "addFileToTarGezip", "addFileToTarJx", "addFileToTarRx", "addFileToTarBz", "addFileToTarBt", "addFileToTarRzip", "addFileToTarGet", "addFileToTarRw", "addFileToTarBw", "addFileToTarGt", "addFileToTarGw", "addFileToTarRz", "addFileToTarBzip", "addFileToTarGez", "addFileToTarGx", "addFileToTarGep", "addFileToTarGst", "addFileToTarBp", "addFileToTarGp", "addFileToTarJzip", "addFileToTarGzip", "addFileToTarGsz"], "taro": ["qtaro", "toa", "tary", "qtro", "ktarro", "trary", "thara", " tolan", " tro", "Tara", "margo", "tara", "thosa", "temparo", "targo", "ktaro", "qtory", "waro", " targo", "tamo", "warro", "retara", "starro", "marro", "Tolan", " toa", "stamo", "ttosa", " tary", "tharro", "tharo", " tamo", "Taco", "Tory", "ttamo", "Tarro", "trar", "mro", "Taro", "tro", "stro", "stoa", "traro", "tosa", "staco", "qtolan", "wro", "stargo", "maro", "ktrar", "Tro", "ktara", "retaco", "wargo", "ttara", " taco", "troa", "thamo", "thrar", " tara", "tempro", " tory", "tarro", "trro", " tosa", "Targo", "tempamo", "taco", " trar", "staro", "ttaro", " tarro", "retamo", "retaro", "stary", "tolan", "tory", "Tamo", "tempargo"], "path": ["m", "entry", "print", "project", "ex", "Path", "full", "h", "key", "chain", "parts", "root", "doc", "clean", "string", "ath", "th", "transform", "c", "name", "core", "pi", "ref", "dir", "mount", "binding", "w", "url", "file", "local", "pattern", "PATH", "kind", "history", "text", "p"], "base": ["b", "shadow", "absolute", "bad", "bas", "create", "full", "server", "reset", "based", "extra", "root", "padding", "Base", "template", "name", "prefix", "basic", "pad", "alias", "build", "common", "bf", "bare", "ase", "check", "binding", "normal", "file", "start", "part", "default", "db", "relative", "family", "buffer", "parent"], "f": ["d", "b", "v", "fa", "o", "inf", "l", "alf", "fe", "h", "far", "perm", "tf", "life", "fab", "F", "xf", "elf", "c", "y", "fo", "uf", "fi", "cf", "ft", "rf", "form", "df", "fp", "fc", "fed", "fg", "bf", "fm", "e", "fac", "fb", "sf", "af", "w", "file", "t", "fd", "fs", "lf", "fl", "fr", "g", "r", "fx", "i", "p"], "entryName": ["ryLetter", "EntryType", "elementName", "rowType", " entryKey", "ryname", "entryLetter", "elementKey", "entryKey", "entryType", " entryLetter", "EntryKey", " entryType", "ryName", "cueName", "cueType", "rowname", " entryPath", "entryPath", "elementname", "rowLetter", "cuename", "ryType", "elementPath", "rowName", "cueKey", "EntryPath", "entryname", "Entryname", " entryname", "EntryName"], "goIn": ["moIN", " goOut", "goIN", " goIns", "poOut", "poIN", "GoIns", "goIns", " goin", "geIn", "GoOut", " goInput", "GoIn", "Goin", "poin", "gein", "moIn", "moin", "geIns", "goin", "goOut", "goInput", "geInput", "moIns", "GoIN", "moInput", " goIN", "poIn"], "tarEntry": ["tarCategory", "rarItem", "carentry", "rarCategory", "carEnt", "rarEntry", "rarComponent", "rarentry", "warItem", "tarentry", "warEntry", "tarItem", "carCategory", "rarEnt", "warComponent", "tarEnt", " tarItem", "warEnt", "tarComponent", " tarEnt", " tarentry", "carEntry", " tarComponent", " tarCategory"], "children": ["reports", "objects", "follow", "batch", "cache", "Children", "blocks", "los", "members", "ll", "keys", "roots", "users", "parents", "many", "balls", "aos", "json", "ul", "gall", "files", "resources", "cs", "each", "jobs", "names", "packages", "items", "groups", "modules", "cloud", "fs", "ml", "kids", "these", "all", "hawks", "they", "ren", "ps", "ports", "pages", "stories", "ls", "wn", "parent"], "child": ["entry", "follow", "batch", "cache", "l", "cow", "ll", "background", "key", "q", "label", "pixel", "Child", "c", "name", "friend", "col", "char", "client", "cell", "row", "count", "ch", "comment", "brother", "block", "file", "handle", "last", "fd", "ph", "lf", "id", "close", "job", "fr", "zip", "uncle", "shell", "page", "parent"]}}
{"id1": "18544890", "id2": "481364", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"get": ["cache", "print", "list", "create", "show", "post", "call", "download", "Get", "gets", "pull", "getting", "api", "GET", "draw", "info", "put", "search", "game", "range", "read", "query", "all", "match", "stats", "run"], "url": ["http", "pl", "rect", "link", "web", "l", "html", "ll", "rl", "xml", "address", "hub", "q", "string", "location", "hl", "lb", "base", "str", "ul", "mail", "api", "dl", "ssl", "ret", "build", "ur", "nl", "ref", "domain", "mount", "URL", "file", "game", "Url", "sl", "id", "host", "addr", "path", "uri"], "lat": ["Lat", "ip", "att", "rect", "apt", "pos", "xy", "pt", "rt", "wp", "dist", "at", "y", "loc", "area", "sat", "south", "ct", "str", " latitude", "grid", "top", "st", "alt", "feat", "mat", "sta", "ats", "coord", "kt", "addr", "west", "x", "height", "sq"], "lon": ["elong", "n", "lt", "pos", "l", "ll", "lin", "los", "lang", "itude", "location", "geon", "loc", "phy", "fn", "ng", "top", "ong", "lu", "lay", "ino", "ln", "zon", "local", "lol", "mag", "lf", "low", "vert", "on", "west", "land", "las", "x", "lbs", "len"], "count": ["n", "batch", "code", "list", "cache", "num", "more", "amount", "sum", "found", "call", "index", "total", "th", "limit", "cond", "c", "ct", "frequency", "number", "top", "score", "Count", "size", "counter", "search", "last", "range", "start", "max", "ount", "id", "nb", "scroll", "page", "length", "current", "nt"], "req": ["comp", "http", "forced", "rest", "pr", "err", "pkg", "resp", "q", "proc", "rel", "cgi", "inv", "res", "wx", "desc", "dist", "rd", "ind", "quick", "reg", "rx", "aux", "quest", "jp", "requ", "pull", "cmd", "friend", "cert", "client", "sem", "comm", "usr", "org", "j", "sql", "compl", "send", "init", "request", "pas", "https", "cur", "qt", "forge", "urg", "peer", "Request", "search", "crit", "uj", "mk", "next", "rr", "dj", "require", "qq", "tx", "fr", "htt", "sub", "hr", "repl", "conf", "typ", "r", "ps", "gr", "fail", "Requ", "sq"], "gl": ["pl", "list", "l", "lor", "ll", "rl", "rel", "tf", "bal", "als", "hl", "GL", "ogl", "gold", "balls", "il", "gn", "gm", "gif", "dl", "gall", "nl", "ger", "spring", "wal", "Gl", "bel", "tl", "acl", "illas", "gc", "abl", "jl", "wl", "ml", "lol", "vl", "sl", "gel", "gb", "fl", "cl", "console", "igl", "g", "ibl", "bl", "gr", "gz", "gs", "ls"], "br": ["browser", "b", "BR", "pr", "bh", "tr", "ber", "wr", "el", "yr", "dr", "bt", "kr", "arr", "rb", "bp", "shr", "buf", "bi", "str", "ch", "cr", "bg", "sp", "bro", "er", "be", "mr", "vr", "FR", "fr", "hr", "bl", "bm", "lr", "r", "gr", "sr", "Br"], "line": ["entry", "n", "rule", "code", "link", "print", "l", "lin", "eline", "header", "edge", "body", "chain", "el", "label", "user", "string", "msg", "lo", "stroke", "sequence", "error", "trace", "style", "str", "cell", "row", "Line", "ine", "inline", "stay", "valid", "phrase", "note", "e", "sample", "liner", "comment", "ln", "block", "iter", "check", "word", "stream", "le", "LINE", "file", "lane", "range", "log", "train", "point", "console", "message", "page", "display", "channel", "frame", "text"]}}
{"id1": "20247400", "id2": "13063241", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"in": ["inf", "IN", "inc", "it", "inner", "cin", "ins", "input", "ind", "rin", "bin", "up", "In", "is", "io", "ze", "isin", "init", "con", "info", "and", "check", "ai", "file", "gin", "from", "inn", "on", "net", "din", "i", " din", "source"], "out": ["o", "report", "n", "b", "to", "print", "screen", "list", "null", "err", "ex", "oss", "it", "obj", "ins", "OUT", "at", "msg", "name", "os", "Out", "io", "ou", "cmd", "writer", "client", "str", "outer", "sys", "we", "other", "write", "dir", "ot", "con", "ln", "check", "println", "w", "t", "log", "auto", "gt", "exit", "OU", "output", "r", "outs", "net", "or", "ne", "line"], "buffer": ["b", "batch", "cache", "Buffer", "command", "header", "data", "function", "address", "key", "filter", "flush", "memory", "processor", "index", "window", "total", "database", "limit", "available", "template", "shape", "table", "document", "sequence", "bar", "attribute", "trace", "queue", "buf", "channel", "clear", "phrase", "append", "buff", "pause", "comment", "sample", "stack", "iter", "block", "position", "size", "se", "library", "result", "variable", "match", "binary", "view", "event", "component", "output", "db", "message", "temp", "display", "history", "length", "bridge", "source"]}}
{"id1": "10759917", "id2": "17627195", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["insert", "link", "lete", "command", "Delete", "create", "execute", "destroy", "reset", "download", "load", "remove", "replace", "touch", "clear", "write", "save", "move", "put", "dump", "del", "query", "set", "update", "get", "de", "drop", "select"], "name": ["m", "n", "link", "code", "null", "time", "l", "create", "Name", "NAME", "key", "data", "chain", "filename", "label", "string", "term", "base", "c", "prefix", "error", "description", "type", "url", "lon", "item", "str", "alias", "connection", "common", "ame", "e", "title", "comment", "o", "old", "version", "me", "ma", "word", "size", "search", "names", "value", "local", "resource", "format", "w", "nm", "file", "part", "id", "message", "path", "family", "parent", "source"], "CannotDeleteSystemLinkException": ["CannotDeleteSystemTypeEx", "CannotDeleteSysLinksException", "CannotDeleteSysLinksStatus", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinkError", "CannotDeleteSystemPageEx", "CannotDeleteSystemPageStatus", "CannotDeleteSysLinkError", "CannotDeleteSystemDataStatus", "CannotDeleteSystemLinkEx", "CannotDeleteSystemLinkWarning", "CannotDeleteSystemPageError", "CannotDeleteSystemLinksException", "CannotDeleteSystemTypeWarning", "CannotDeleteSystemDataError", "CannotDeleteSysLinksEx", "CannotDeleteSystemLinksEx", "CannotDeleteSysLinksError", "CannotDeleteSystemLinkStatus", "CannotDeleteSystemLinksStatus", "CannotDeleteSysLinkStatus", "CannotDeleteSystemTypeError", "CannotDeleteSystemTypeException", "CannotDeleteSystemPageException", "CannotDeleteSystemLinksError", "CannotDeleteSysLinkException", "CannotDeleteSystemLinksWarning", "CannotDeleteSystemDataEx", "CannotDeleteSystemDataException"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotFindException", "ClassLinkTypeNotFoundOver", "ClassLinkTypeIsFind ", "ClassLinkTypeNotFind ", "ClassLinkTypeIsFound ", "ClassLinkTypeNotUsedEx", "ClassLinkTypeNotUsedException", "ClassLinkTypeNotFound ", "ClassLinkTypeNotUsedOver", "ClassLinkTypeIsFoundEx", "ClassLinkTypeIsFoundException", "ClassLinkTypeNotFindOver", "ClassLinkTypeIsFindEx", "ClassLinkTypeNotUsed ", "ClassLinkTypeIsFindOver", "ClassLinkTypeIsFoundOver", "ClassLinkTypeNotFindEx", "ClassLinkTypeIsFindException", "ClassLinkTypeNotFoundEx"], "conn": ["pg", "pkg", "rel", "Conn", "req", "c", "loc", "jp", "client", "ens", "ang", "sys", "bo", "act", "org", "nc", "iw", "con", "pas", "https", "win", "connect", "t", "ca", "pt", "priv", "ws", "cp", "rt", "ctx", "exec", "open", "cert", "cmd", "die", "comm", "cb", "coll", "addr", "pool", "nt", "socket", "gate", "err", "yn", "oc", "resp", "sec", "ct", "enc", "ch", "cur", "port", "close", "en", "conf", "ec", "pen", "db", "on", "ns", "canon", "obj", "yes", "col", "connection", "co", "mc", "ce", "dn", "mt", "gc", "cc", "cn", "conv"], "stmt": [" stmm", "sttx", "STmb", " stpt", "STmm", " stmb", "Sttm", "Str", "Stmp", "strpr", "snpt", "statMT", "Stmm", "stm", "StMT", "constmt", "snm", "statmt", "STm", "startMT", "stattm", "strm", "stmp", "sttm", "strMT", "Stpr", "str", "startmm", " stm", " stpr", "strmm", "STMT", "Stmt", " sttm", "STtx", "stmb", "constm", "STmt", " sttx", "Sttx", "stpt", "stmm", "Stpt", "Stmb", "constmb", "strmt", "consttm", "stMT", "stpr", " stMT", "Stm", "snmt", "startmp", "startmt", "strmp", "STtm", "statm", "strr", "snMT", " str"], "prepTable": ["ppTable", " prepTier", " prepTree", "prepTab", "ppTab", "pptable", "PrepTree", " preptable", "summaryTier", "prepTree", "ppTree", "PrepTier", "PrepTab", "prepTier", "Preptable", " prepTab", "preptable", "PrepTable", "summarytable", "summaryTable"], "objectLinkTable": ["objectTypeTab", "objectlinkType", "objLinkList", "objectLinkstable", "objectlinkTable", "objectlinktable", "objLinkTable", "objectLinksTable", "objLinksList", " objectLinkTab", " objectLinkType", "objectLinkList", "objLinktable", "objectTypeType", "objLinkController", " objectLinktable", "objectLinksController", "objectTypeTable", "objectLinkType", "objLinksController", "objectLinkController", "objectLinkTab", "objectLinktable", "objLinksTable", "objLinkstable", "objectTypetable", "objectLinksList", "objectlinkTab"], "sql": ["csv", "js", "html", "xml", "qs", "q", "spr", "rel", "inv", "string", "expression", "ql", "template", "description", "fn", "form", "str", "json", "dl", "sv", "nl", "sp", "sf", "sq", "url", "format", "s", "ips", "result", "sd", "sl", "query", "SQL", "fields", "spec", "quote", "scl", "expr", "ns", "join", "select"]}}
{"id1": "17999474", "id2": "19322941", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"getZipAsFile": ["getZipTofile", "getZipFromfile", "getBoxFromfile", "getZipToPath", "getBoxFromLocal", "getZipInLocal", "getBoxFromFile", "getZipFromPath", "getBoxFromPath", "getBoxAsLocal", "getBoxAsFile", "getBoxAsPath", "getZipInPath", "getZipFromFile", "getZipToLocal", "getZipToFile", "getZipInFile", "getZipAsLocal", "getZipAsPath", "getZipAsfile", "getZipInfile", "getBoxAsfile", "getZipFromLocal"], "digOb": ["chemEx", "chemObj", "DigObject", " digOcc", "digObject", "digOB", "DigEx", "DigOb", "digEx", "DigOcc", "divObj", "DigObj", "digOcc", "gradOb", " digObj", "gradObject", "divObject", "divOb", " digObject", "divOcc", " digOB", "gradOB", "chemOB", "DigOB", "chemOb", "gradObj", " digEx", "digObj"], "folderName": ["FolderNames", "folderSize", "foldername", "Foldername", "FolderPath", "folderNames", "fileNames", "foldNames", " folderNames", "foldSize", "foldname", " foldername", "folderPath", "FolderName", "foldPath", " folderKey", " folderSize", "folderKey", "fileKey", "foldKey", "foldName", "fileSize", " folderPath", "fileName"], "tmpFolder": [" tmpfolder", "mpDirectory", "mpDir", "mpFolder", " tmpDir", "cmpDir", "tmpParent", "cmpFolder", "tmpDirectory", " tmpDirectory", "cmpParent", "tempfolder", "tempDirectory", "tempDir", "mpfolder", "cmpfolder", "tmpDir", "tempFolder", "tmpfolder", "tempParent", "mpParent"], "zip": ["report", "jar", "entry", "ip", "link", "feed", "csv", "project", "pkg", "xml", "install", "body", "test", "post", "folder", "drop", "sea", "template", "tar", "io", "cf", "pack", "form", "col", "bag", "f", "sheet", "json", "mail", "row", "pdf", "sample", "box", "sp", "upload", "ow", "zone", "proxy", "file", "se", "library", "exp", "cloud", "Zip", "wrap", "quote", "content", "lock", "tmp", "gz", "pool", "temp", "archive", "z"], "out": ["o", "to", "n", "print", "v", "null", "list", "in", "ex", "oss", "it", "inner", "flush", "cos", "us", "inv", "ins", "res", "OUT", "one", "os", "up", "ou", "Out", "io", "aos", "writer", "co", "write", "sp", "serv", "copy", "ln", "check", "t", "s", "auto", "ent", "set", "all", "en", "OU", "output", "outs", "tmp", "net", "i", "conv"]}}
{"id1": "12349563", "id2": "7044153", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"resourceExists": [" resourceIsits", " pathExits", " resourceIsistent", " pathexistent", " resourceexistent", " pathExists", " pathexists", " resourceexits", " resourceexists", " resourceexisted", " resourceExits", " resourceIsisted", " resourceIsists", " pathExistent", " pathExisted", " resourceExisted", " resourceExistent", " pathexits", " pathexisted"], "location": ["human", "Location", "command", "slot", "resolution", "usage", "address", "href", "server", "filename", "window", "directory", "string", "padding", "system", "family", "available", "template", "name", "loc", "area", "document", "layout", "ocation", "description", "LOC", "behavior", "program", "localhost", "connection", "availability", "country", "module", "color", "where", "comment", "uration", "position", "zone", "ion", "search", "resource", "file", "local", "value", "zo", "library", "direction", "point", "hello", "reference", "path", "translation", "message", "history", "remote", "uri"], "url": ["http", "b", "n", "pl", "l", "ll", "pkg", "address", "h", "call", "user", "res", "hl", "base", "loc", "open", "cert", "cmd", "google", "char", "www", "f", "client", "str", "ul", "mail", "ssl", "dl", "u", "ret", "build", "ur", "nl", "bel", "mount", "con", "https", "URL", "gl", "t", "Url", "sl", "r", "out", "ls"], "cxn": ["Cxns", "conn", "ctxns", " cexnor", "Cxn", "cxns", " cxnor", "ctxn", " cexN", "Ctxn", "cexnor", "cwxnn", "ctxnn", "cxxN", " cxns", "Ctxns", "cwxns", "conN", "cxxnor", "cexn", "Cxnn", "cexN", "ctxnor", "cxxns", "connn", " cxN", "cwxN", "CxN", "cxN", "cxnn", "ctxN", "cxnor", "cxxn", " cexns", "Ctxnn", "cwxn", "conns", "CtxN", " cexn", "cexns"], "is": ["ip", "dis", "ris", "isi", "in", "oss", "bis", "lis", "sis", "ists", "has", "isa", "was", "ir", "rs", "im", "ais", "os", "ois", "ires", "still", "tis", "its", "IS", "abs", "Is", "isf", "sys", "isin", "iso", "ms", "bits", "serv", "init", "ys", "ios", "info", "does", "s", "iss", "ts", "es", "fs", "iris", "as", "isl", "ims", "ps", "bs", "i", "isc", "si"], "byteBuffer": ["bufferSet", "noteMatrix", " byteFlow", "byteMatrix", "noteFlow", "basicBuffer", " byteContext", "binaryBuffer", "binaryContext", "binaryWindow", "bufferContext", "bufferWindow", " byteMatrix", "byteFlow", "basicFlow", "byteWindow", "binarySet", "noteQueue", " byteWindow", "basicQueue", "byteSet", "basicMatrix", "byteContext", " byteSet", "noteBuffer", " byteQueue", "byteQueue", "bufferBuffer"]}}
{"id1": "13666876", "id2": "2511579", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["processSinglefile", "transformSingleSourceFile", "transformSimpleRecord", "transformSingleFiles", "transformSingleModel", "transformOneSourceFile", "TransformSinglePage", "transformOnefile", "transformsingleRecord", "processsingleSourceFile", "transformMultiModel", "transformMultiSourceFile", "transformMultiPage", "transformSinglefile", "transformsingleModel", "transformOneFile", "transformSimplePage", "transformSimpleFile", "transformsinglefile", "transformMultiRecord", "TransformSimpleModel", "transformMultiFile", "TransformSimpleFile", "transformMultifile", "TransformSingleFile", "processsinglefile", "processSingleFile", "transformsingleFile", "transformsingleFiles", "processsingleFiles", "TransformSimpleRecord", "TransformSimplePage", "processSingleFiles", "transformSimpleModel", "transformOneFiles", "processSingleSourceFile", "TransformSingleModel", "TransformSingleRecord", "transformsingleSourceFile", "transformsinglePage", "transformMultiFiles", "processsingleFile", "transformSingleRecord", "transformSinglePage"], "xed": ["txED", "txer", "rxeds", "Xeded", " xented", "uxED", "wxED", "exED", "exeded", "uxed", " xred", "wxred", "xeds", "xer", "wxEd", " xED", "txeds", "passed", "Xeds", "xied", "rxed", "Xed", "xEd", "uxented", "passred", " xied", "pxed", "rxer", "uxied", " xEd", "exeds", "wxied", "exed", "xented", "xeded", "passED", "pxeds", "wxented", "pxED", "txed", "rxED", "XED", "xED", "pxeded", "Xer", "xred", "wxed", "passEd"], "node": ["entry", "n", "link", "edge", "create", "post", "no", "index", "directory", "entity", "seed", "image", "one", "remote", "array", "process", "load", "scene", "name", "station", "stage", "feature", "our", "row", "parent", "note", "Node", "and", "hand", "word", "resource", "range", "map", "job", "set", "day", "ode", "object", "view", "event", "right", "component", "de", "channel", "tree", "line"], "dob": [" dab", " dobar", " doy", "Dobar", "drod", "dab", "drob", "drab", "Dab", " dobb", "dobb", "Doy", "adobar", "diab", "doy", "drobb", "dod", "adob", "diobb", "diod", "adoy", " dod", "diob", "dobar", "adab", "Dob"], "mySrc": ["myDesRC", "mySelources", "myDesources", "mySingsrc", "mySourceource", "mySfc", "myDesrc", "MySRC", "myInsfc", "MySrc", "mySelRC", "MySsrc", "mySingrc", " mySRC", "mySingfc", "mySelsrc", "myAsrc", "myAsource", "MySource", "myInssrc", "myDessrc", "myAsRC", "mySourcesrc", "mySelrc", " mySfc", "MySources", "myInsrc", "mySsrc", "mySRC", "myAssrc", " mySsrc", "mySources", "myInsRC", "mySource", "mySingRC", "mySourcerc", "mySourceRC"], "mySrcF": ["mySsrcO", "mySourceO", "mySsrcI", "myMrcFP", "mySsrcC", "mySourceFP", "myMourceFP", "mySrcP", "mySufO", "mySourceV", "mySufF", "mySRCF", "mySrtI", "mySourceF", "mySrtF", "myMrcF", "mySufV", "mySsrcF", "myMourceF", "myMrcV", "mySrcFP", "mySrcV", "mySRCC", "mySrtC", "myMourceO", "mySRCI", "mySufFP", "mySsrcP", "mySrcI", "myMourceV", "myMrcO", "mySsrcFP", "mySrcC", "mySrtP", "mySRCP", "mySsrcV", "mySrcO"], "myOutF": ["myOffDF", "myOutFile", "myOffE", " myOutC", "mysOutL", "myCoW", "myObjFile", "myOutputV", "myOutputE", " myOutE", "myArtW", "myInV", "myObjF", " myOutV", "myOutputFs", " myoutV", "myOutL", "mysOutFL", "myNetE", "MyInFs", "myOutW", "MyOutFile", "MyOutF", "myOutE", "myOutC", "myInFile", "myObjFs", "myOutputDF", "myOutFL", "MyOutFs", "myOffFile", "myOffF", " myoutF", "MyInFile", " myNetDF", "myOutputF", "myCoF", "MyInV", "myOutFs", "myInF", "myArtFL", "myoutC", "mysNetL", "myOutDF", "mysOutF", "mysNetFL", " myoutL", " myOutL", "myArtF", "myoutV", "myCoL", " myOutFile", "myNetF", "MyOutV", "myNetL", "myOutV", "myNetFile", "myNetW", " myNetF", "myOutputC", "mysNetW", "myCoFL", " myOutDF", "myInL", "MyInF", "myNetFL", "myOutputL", "myoutF", "mysOutW", "myArtL", " myNetFile", "myObjV", "myNetDF", " myNetE", "myOutputFile", " myoutC", "myoutL", "mysNetF", "myInC", "myInFs"], "co": ["o", "ca", "ci", "cache", "CO", "ror", "lc", "cop", "ho", "oc", "cos", "obj", "no", "ro", "lo", "wo", "yes", "aco", "c", "flo", "cho", "loc", "xc", "fo", "io", "col", "fc", "nc", "so", "ko", "con", "ace", "copy", "cs", "ce", "cv", "com", "ico", "coll", "go", "gc", "soc", "ctrl", "cod", "coord", "can", "cl", "cover", "mo", "roc", "cal", "cm", "po", "Co", "cc", "ck", "cu", " Co"], "x3dvFile": ["x3dtfile", "x3dvsFilename", "x3dbfile", "x3cdVFilename", "x3pdbString", "x3davFile", "x3dvsFile", "x3dbString", "x3pdvFile", "x3cdVFile", "x3davPath", "x3cdvFile", "x3dvPath", "x3pdbFilename", "x3pdbFile", "x3dtFilename", "x3dVPath", "x3dtFile", "x3dVfile", "x3dVFilename", "x3dvfile", "x3dvFilename", "x3cdvFilename", "x3dbFilename", "x3dVFile", "x3dbFile", "x3dvString", "x3dtString", "x3pdvFilename", "x3pdvfile", "x3cdvPath", "x3dvsPath", "x3pdbfile", "x3dVString", "x3pdvString", "x3cdVPath", "x3davFilename"], "fis": ["fisi", "fliz", "fires", "bis", "bisi", "fiss", "frie", "fliss", " fiz", "flis", " fie", "fiz", "fileiz", " fiss", " fires", " fisi", "frisi", "biss", "fie", "friss", "fileires", "fileis", "bie", "flires", "fileiss", "fris"], "gzos": ["ggops", "ggies", "zipnos", "gzoss", "gtoss", "gtos", "gsos", "gos", "gties", "ziposs", "gzops", "gznos", "zoes", "gzaos", "sslos", "gzo", "ggos", "zoss", "gsoss", "gzoes", "goss", "gsops", "gtoes", "sslaos", "zaos", "gsnos", "ssloss", "go", "gaos", "zo", "sslo", "gtops", "zies", "zipos", "gzies", "zops", "zipops", "zos", "ggoes", "gtnos"], "buf": ["b", "cast", "batch", "raw", "aka", "Buffer", "tab", "cat", "pkg", "buffer", "mu", "seq", "arr", "uf", "rb", "cmd", "bar", "cf", "bag", "emb", "img", "var", "ref", "mem", "br", "buff", "box", "cap", "cb", "bytes", "block", "vec", "font", "cam", "cv", "fb", "cur", "wb", "max", "good", "Buff", "conv", "orig", "bus"], "ret": ["v", "att", "print", "continue", "val", "RET", "err", "back", "tr", "ctr", "rt", "elt", "deg", "test", "obj", "res", "re", "ext", "aux", "cert", "cmd", "ft", "red", "end", " Ret", "cont", "arg", "ref", "ter", "Ret", "alt", "iter", "ptr", "mt", "pret", "gt", "def", "inter", "repl", "r", "nt", "out", "rets", "et", "ry", "len"]}}
{"id1": "13596891", "id2": "23532405", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 0, "substitutes": {"doTransfer": [" doSend", " doRequest", "DoTransfer", "DoDownload", "doDownload", "handleTransfer", "doSend", "DoSend", "handleSend", "handleRequest", "handleDownload", " doDownload", "DoRequest", "doRequest"], "request": ["http", "report", "have", "raw", "command", "in", "record", "use", "header", "create", "xml", "session", "server", "reset", "question", "address", "call", "user", "input", "re", "process", "remote", "req", "name", "document", "quest", "requ", "attribute", "remove", "client", "subject", "connection", "context", "application", "setup", "version", "position", "resource", "Request", "complete", "log", "result", "config", "QUEST", "query", "params", "initial", "get", "object", "order", "reference", "message", "this", "change", "frame", "current", "parent"], "response": ["http", "report", "summary", "print", "pos", "session", "resp", "reset", "respond", "site", "server", "body", "res", "onse", "image", "status", "one", "answer", "document", "sequence", "wrapper", "description", "json", "send", "connection", "context", "application", "write", "reply", "version", "position", "ce", "block", "proxy", "next", "service", "respons", "result", "Response", "exit", "success", "content", "view", "object", "default", "output", "this", "message", "page", "out", "frame"], "method": ["http", "m", "report", "command", "tr", "num", "verb", "hod", "property", "call", "post", "Method", "string", "th", "timeout", "transform", "period", "name", "mod", "prefix", "type", "form", "subject", "send", "eth", "other", "dir", "METHOD", "version", "service", "reason", "direction", "ETHOD", "right", "message", "length", "instance"], "servletContext": [" servantDefinition", "servletsEvent", "servlerChain", "ServletsEvent", " servletcontext", "servletDefinition", "servantDefinition", "ServletsConfig", " servantComponent", " servantcontext", "servantComponent", "servletsChain", "ServletConfig", "servfilecontext", "servantcontext", "servLETConfig", " servletComponent", "servletcontext", "servletEvent", "servLETComponent", "servfileDefinition", "servletsConfig", " servletDefinition", "servlerContext", " servantContext", "servLETDefinition", "servantContext", "servLETcontext", "ServletEvent", "ServletChain", "ServletContext", "servLETContext", "servletConfig", "servLETChain", "servLETEvent", "ServletsChain", "ServletsContext", "servletChain", "servfileContext", "servlerConfig", "servlerEvent", "servletsContext", "servletComponent", "servfileComponent"], "wac": ["bAC", " wacs", "wacc", "wbacs", "wbacc", "wbac", "wAC", "bacs", "wbAC", "bacc", "wacs", "bac", " wAC", " wacc"], "szUrl": ["szGl", "szeGl", " szeUr", "desgzPath", "szStr", " szePath", "sldPath", "szUr", "sldUrl", "sZGl", "szarUr", "szURL", "szeLoc", "deszPath", "sldGl", "sziUr", "sziUrl", "sizUrl", "desgzURL", "desgzUrl", " szurl", "szePath", " szeLoc", "sZurl", "szLoc", " szeURL", " szUr", "sizURL", "szaURL", "szurl", "szeUrl", " szeGl", "sziGl", "szaLoc", "sizStr", "desgzStr", " szeUrl", "szaUrl", "deszURL", "szeStr", "sgzUr", "sgzPath", "szeurl", "szPath", "szarGl", "szarPath", "deszStr", " szGl", "sZUrl", "sldUr", "szaUr", "sgzUrl", "sgzStr", " szPath", "szeURL", "sgzURL", "szeUr", " szURL", "sizPath", " szLoc", "deszUrl", "sZUr", "szarUrl", "sgzLoc", "sziurl", " szeurl"], "url": ["browser", "http", "pl", "link", "conn", "web", "l", "socket", "ll", "rl", "xml", "address", "date", "re", "location", "lb", "base", "name", "loc", "open", "cert", "char", "client", "www", "f", "str", "il", "ul", "mail", "ssl", "org", "u", "un", "ref", "ur", "nl", "build", "connection", "ret", "bel", "mount", "https", "URL", "gl", "file", "t", "impl", "gc", "ml", "Url", "sl", "host", "prot", "ol", "util", "ob", "ls", "uri"], "is": ["ip", "ris", "isi", "in", "bis", "lis", "sis", "isa", "us", "ins", " bis", "res", "ir", "os", "ois", "ii", "tis", "its", "IS", "sys", "Is", "isin", "iso", "ms", " cis", "serv", "info", "ios", "cs", "nis", "ri", "s", "iss", "es", "id", "as", "ism", "ps", "bs", "ic", "i", "isc", "si"], "sout": ["wsout", "lscho", "wsj", "wsos", "lsin", "osout", " sos", "south", " scho", "lsOut", " sOut", "sj", "lsos", "osin", "sOut", "lsouth", "osOut", "sos", " south", "lsout", "scho", "sin", " sj", "wscho", "lsj", "osouth", " sin"], "con": ["cache", "code", "thin", "num", "dial", "Conn", "req", "c", "cf", "client", "ver", "un", "act", "nc", "com", "connect", "don", "local", "ran", "apache", "const", "cm", "change", "current", "cp", "h", "ctx", "cmd", "comm", "fc", "compl", "common", "stat", "fac", "ln", "coll", "CON", "config", "cal", "util", "syn", "conn", "socket", "cos", "call", "re", "cons", "cell", "rc", "cur", "cv", "ven", "internal", "ctrl", "can", "fl", "bc", "en", "ain", "conf", "pen", "on", "http", "condition", "create", "canon", "obj", "cgi", "res", "cond", "acon", "cone", "connection", "co", "ion", "log", "control", "cn", "conv", "Con"], "hNames": ["hWords", "hrNames", "hmNames", "hmAMES", " hWords", "dhIDs", "tNames", "bKeys", "htAMES", "hrWords", "hAMES", "dhNames", " hKeys", "dhKeys", "htNames", "hmKeys", "tStates", "hmUsers", " hNs", "hKeys", "htUsers", "dhWords", "hUsers", "hrKeys", "htKeys", "tKeys", "bNames", "hIDs", "bNs", "bStates", " hIDs", "hrIDs", " hAMES", " hUsers", "hNs", "tNs", " hStates", "hStates"], "txt": ["kw", "xx", "lt", "pt", "tab", "pkg", "dat", "elt", "test", "obj", "filename", "tf", "ext", "msg", "bt", "wt", "TEXT", "fn", "tk", "xxx", "ct", "str", "tm", "lv", "sp", "cmp", "mt", "qt", "nv", "htm", "nu", "t", "te", "btn", "dj", "nm", "tt", "xt", "tx", "gt", "typ", "kt", "tmp", "XT", "ns", "ht", "text", "nt"], "inBody": ["cinBlock", " inbody", "inBoot", "inThread", "inReader", "InBody", " INBox", " inThread", "inBlock", "inBox", "inputThread", "cinBody", "Inbody", "InReader", "inputBody", "dinReader", " INBlock", "inputBox", " INBoot", "cinBox", "dinBody", " INBody", "cinBoot", "InBox", " inReader", "inbody", " inBoot", "InThread", "dinbody", " inBlock", " inBox"], "bufCh": ["bufferCh", "BufferCH", " bufComp", "buffBuff", "BufferComp", "cbCH", " bufch", "ufCH", "BufferCh", "bufChar", " bufCol", "cbCol", "ufChar", "cbCh", "bufComp", "buffCh", "buffCH", "bufBuff", "bufCH", " bufCH", "BufferChar", " bufChar", "ufCh", "bufferBuff", "buffch", "ufCol", " bufBuff", "bufch", "bufferch", "buffChar", "bufCol", "cbChar", "buffComp", "bufferCH"], "r": ["d", "o", "n", "v", "rw", "l", "err", "rt", "h", "q", "k", "res", "rd", "rar", "re", "dr", "rec", "rs", "c", "arr", "rb", "f", "ar", "or", "rate", "u", "rc", "ch", "cr", "e", "nr", "er", "w", "t", "rr", "mr", "hr", "R", "lr", "gr", "out", "x", "i", "sr", "z", "p"], "outReq": ["outSej", "outREq", "inRech", " outRecqs", "outResch", " outRecque", "outTeQ", "outRech", "outSeq", "outResq", " outConch", " outRecek", "outConquest", " outReQ", "outConj", " outConj", " outRej", "outTequest", "inRej", "outResquest", " outRech", " outRecq", "outREqs", "outRecquest", " outConq", "outTeqs", "outReQ", " outReek", "outResj", "outRecqs", "outSech", "outREque", "inRequest", "outSeck", "outREek", "inSech", "outConqs", "outConque", "outRequest", "outConck", "outFrej", " outRequest", "outRecque", "outConq", " outConck", "inSequest", " outReque", "outFreq", "outRecq", "outConQ", "outConch", "outReek", "outFreck", "inSeq", " outReqs", "outReqs", "outRej", "outConek", "outFrech", "inSej", "outRecek", " outConQ", "inReq", " outConquest", " outConqs", "outReck", "outRecQ", "outTeq", "outReque", " outReck", "outSequest"], "buff": ["comp", " buf", "bj", "bin", "cond", "cho", "ff", "uf", "alph", "cmd", "emb", "buf", "img", "ref", "mem", "nd", "cb", "off", "info", "font", "be", " buffers", "ph", "cod", "bb", "Buff", "buffer", "eng"]}}
{"id1": "19467540", "id2": "20851065", "code1": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"updateProductIfAvailable": ["updateProductOravailable", "updateProductsIfAvailable", "updateProductIsValid", "updateProductsIfValid", "updateProductWhereAvailable", "updateProductIfValid", "updateProductWhereavailable", "updateProductOrAvailable", "updateProductsIfavailable", "updateProductWhereValid", "updateProductIsavailable", "updateProductsOrValid", "updateProductOrValid", "updateProductIsAvailable", "updateProductsOrAvailable", "updateProductIfavailable", "updateProductsOravailable"], "carro": ["CarRO", "Carrom", "contlo", " carrob", "barlo", "carrob", " caraco", "Carros", "carlo", "barro", "Carlo", "Caraco", "carrom", "contro", "carri", "barros", "Carrob", " carlo", "barRO", "barri", " carros", "Carri", "barrom", "baraco", "contros", "controb", "Carro", "carRO", "barrob", "caraco", " carrom", "carros", " carri", " carRO"], "request": ["http", "report", "access", "list", "web", "project", "push", "use", "xml", "session", "data", "address", "reset", "question", "environment", "server", "uri", "input", "respect", "user", "response", "req", "template", "accept", "document", "quest", "framework", "collection", "attribute", "platform", "client", "media", "context", "application", "foundation", "contact", "setup", "enter", "search", "resource", "Request", "apache", "query", "model", "exit", "get", "object", "view", "reference", "message", "pool", "join", "current", "parent"], "listado": ["Listato", "parentato", "parentament", " listament", "parentados", " listados", " listato", "parentado", "listament", "listados", "listato", "Listados", "Listado", "Listament"], "conexion": ["coexpison", "conexioned", "conxor", " conexione", "conexao", "conegexression", "conexiions", "coneixions", "conexor", "ranexone", "cinxaions", "canixION", " conexions", "conegexion", "conexione", "conexpione", "coexinion", "cinxison", "conenexone", "canxao", "canixao", "coneixao", "coneuxion", "conenexao", "conenexion", "ranexions", "canxon", "conexadial", "conexpinion", "conexpison", "conexION", "conexpression", "conexon", "ranexion", "conxions", "cinxioned", "canixion", "coneexION", "conectionioned", "cinxions", "conenexione", "conenexon", "coneixion", " conexaions", "conenexison", "conexpions", " conexaison", "canxION", "conxion", "coneuxinion", "coneexions", " conexdial", "raneixion", " conexaion", "conexiao", "canxion", "coexpinion", "cinxion", "conexpdial", "coneaxison", "raneixions", "conexison", "coneexor", "conegexinion", "coneixone", " conenexao", "conenexION", "coneaxion", "conexpion", "conectionions", " conexao", "coneuxao", "coneixon", "cinxaioned", "conxION", "conegexison", " conexison", "conexaion", "conexior", "conexinion", "coneuxions", "conexaison", " conenexion", "coneuxione", "canixon", "coneuxison", "conexiION", "conexaioned", "conexpao", "coneaxdial", "coneexone", "cinxaison", "conectionison", "coexression", "conectionion", "conenexioned", "coexpression", "raneixone", "conexaions", " conenexions", "conexression", "coexpion", "conexdial", "conenexions", "conexions", "conenexor", "coneexion", " conexadial", "conexiion", "coexison", "coneixION", "cinxaion", " conenexione", "coneuxression", "coexion", "conexone", "coneaxions"], "select": ["insert", "parse", "which", "collect", "print", "conn", "struct", "it", "use", "serial", "edit", "show", "execute", "q", "reset", "download", "selection", "call", "elect", "exec", "cho", "quick", "selected", "pull", "Select", "ct", "row", "sel", "sql", "qu", "where", "setup", "copy", "sync", "connect", "lect", "search", "construct", "crit", "include", "read", "query", "set", "reflect", "success", "find", "get", "expr", "delete", "SELECT", "util", "pse", "text", "source"], "update": ["insert", "batch", "apt", "updated", "it", "Update", "use", "edit", "execute", "util", "upt", "fill", "up", "pull", "UPDATE", "remove", "replace", "touch", "ul", "un", "row", "other", "bit", "ge", "unit", "write", "stat", "save", "ut", "upload", "where", "alt", "move", "put", "check", "now", "add", "result", "make", "set", "current", "find", "get", "delete", "place", "apply", "each", "change"], "rs": ["ks", "acks", "RS", "ris", "js", "cases", "ws", "times", "rt", "rl", "qs", "ins", "res", "rd", "ubs", "rx", "rpm", "ems", "cks", "hs", "vers", "ows", "vs", "ras", "eps", "usr", "rc", "arts", "ms", "ys", "ars", "cs", "mc", "xs", "rm", "sts", "rr", "Rs", "rates", "ts", "ats", "fs", "mr", "vr", "rets", "rss", "arms", "hr", "ers", "rg", "rys", "ests", "otes", "ims", "ps", "r", "rics", "stats", "bs", "rings", "pps", "ns", "ds", "rows", "vals", "sr", "ros"], "codigoProd": ["codigaprodid", "codigoProvd", "codukaProx", "codigaProc", "codidopron", "codigoselect", "codisoPropd", "codigoPropd", "codukaPROdr", "codigoProvx", "codidoprodo", "codigoPron", "codigoprodr", "codigoPror", "codigoPdid", "codisoPropn", "codigoprodo", "codisoPropdo", "codigoKeyc", "codigoprodid", "codigoprod", "codigoPc", "codidoprod", "codigoPROl", "codigoComc", "codigoproc", "codidoprol", " codichoselect", "codigoPROc", "codigoProdun", "codigaproc", "codigaProd", "codigaProdid", "codigoProdr", "codidoPron", "codidoProl", "codisoProd", "codigoPropc", "codigoKeyd", "codigoOl", "codigoPROd", "codisoPropc", "codidoPror", "codigoComdo", "codigoPROx", " codigoselect", "codigoPd", "codigaselect", "codigoProx", "codukaPROd", "codukaProl", "codigoProvl", "codigoPl", "codukaProd", "codigaprod", "codigoOp", "codigaprol", "codigoOn", "codoselect", "codidopror", "codigoProdo", "codigoprop", "codukaProdr", "codigoPropn", "codidoProc", "codigoProduc", "codigoprox", "codigoProdudo", "codigoProp", "codigoprol", "codigoPropdo", "codidoProp", "codigoComd", "codidoprop", "codigoComr", "codidoProd", "codisoProdo", "codigoPROdr", "codigaProl", "codigoProvdr", "codigoKeyr", "codigopror", "codigoProdud", "codukaPROx", "codisoPron", "codigoKeydo", "codigoOd", "codigoProdid", "codigoProl", "codigoPROdid", "codichoselect", "codigopron", "codisoProc", "codukaPROl", "codidoProdo", "codigoProc", "codidoproc"], "filasAfectadas": [" filasAffectadas", " filasafectados", " filasAffectados", " filasAffectada", " filasAfectada", " filasAfectado", " filasAfectados", " filasAgregado", " filasaffectadas", " filasafectada", " filasAgregadas", " filasaffectada", " filasAcessada", " filasAgregada", " filasAcessado", " filasAcessados", " filasAffectado", " filasafectado", " filasAgregados", " filasaffectados", " filasAcessadas", " filasaffectado", " filasafectadas"], "iterador": ["iteraman", "eraman", "itator", "iteratoracion", "iterrane", "eraton", "operaman", " iteraton", "iterable", "operator", " iterator", "literaman", " iterable", " iteracion", " iterstep", "literstep", " iterato", "itador", "iteratorable", " iteramo", "itrane", "erator", "erador", "iteratorator", "itato", "iteratoraman", "Iterrane", "Iterator", "Iteraton", "iterstep", "iteratorador", " iteraman", "iteracion", "literrane", "teramo", "iterator", "iteramo", "formeracion", "formerable", "literator", "Iterador", "literador", "formerador", "literaton", "iteratoramo", "iterato", " iterrane", "operamo", "formeramo", "terador", "operador", "teraman", "Iterato", "Iterstep", "terator", "iteraton"], "prod": ["Pror", "proda", "Prod", "prorod", "produr", "prog", "produdx", " pror", " prond", "pubdx", "Prond", "prond", "prol", "Prol", "pror", " prol", " prodx", "Prog", "pubda", "produrd", " prord", "produl", "produd", "pubd", " prorod", "Prorod", "prord", "prodund", "prodx", "pubg", "Prord", "produrod", " proda", "Prodx", " prog", "Proda"], "exito": ["exita", "expiration", " inexpiration", " inexito", " inexita", "compiration", "lexito", "comita", "comito", "lexita", "exterior", "lexterior", "comterior", " inexterior", "lexpiration"]}}
{"id1": "10385815", "id2": "7087108", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" duplicate", "csv", "cat", "cp", "cop", "create", "download", "paste", "Copy", "clip", "transfer", "load", "replace", "write", "save", "upload", "move", "clone", "sync", "file", "rm", "read", "opy", " copying", "delete", "Cop", "slice"], "fileFrom": ["sampleFrom", "projectInitial", " fileInitial", "sampleA", "inputFrom", " fileStart", "fileInitial", "sampleInitial", "inputTo", "projectStart", "ileObject", "projectA", "FileObject", "fileStart", "inputObject", "fileA", "ileFrom", "fileObject", "ileTo", "FileFrom", "FileForm", "inputForm", "ileForm", "sampleStart", " fileA", "FileTo", "projectFrom", "fileForm"], "fileTo": ["modelTo", "fileTarget", "ileTarget", "FileTarget", "ile2", " fileDest", " fileTarget", " file2", "modelTarget", "fileTO", "ileTo", " fileTO", "FileDest", "modelTO", "ileDest", "modelDest", "fileDest", "FileTO", "FileTo", "File2", "file2"], "inputStream": ["eventStream", "InputSteam", "imageSteam", "audioSteam", "inputstream", " inputFile", "activeChannel", "imageStreamer", "inputSource", "eventSteam", "imageChannel", "InputSource", "audioStreamer", "inputStreamer", "imageStream", "eventstream", "InputStream", "InputFile", " inputSource", "audiostream", "inputFile", "eventStreamer", "importFile", "InputStreamer", "importSteam", "sourceSource", "activeStreamer", "importStream", " inputSteam", "importChannel", "activeSteam", "audioStream", "InputChannel", "activeStream", "sourceChannel", "imagestream", "sourceSteam", "inputSteam", "sourceStream"], "outputStream": ["writeStream", "inputstream", "OutputStream", "OutputSteam", " outputSocket", " outputFile", "webString", "outputString", "resultSteam", "displaystream", "webFile", "outputSteam", " outputSteam", "outputSocket", "writeChannel", "webChannel", "resultStream", "outputstream", "resultSocket", "writeSocket", "writeSteam", "webStream", "OutputFile", " outputString", "displaySteam", "Outputstream", "resultChannel", "displayStream", "inputString", "webSteam", "displayChannel", "OutputChannel", "outputFile", "inputSteam"], "inputChannel": ["inputConnection", "inputChan", "operatorCamera", "currentChan", "localChan", "readChan", "readChain", "readableChan", "readChannel", " inputCategory", "InputStream", "localConnection", "outputSteam", " inputCamera", "createChan", "operatorConnection", "createStream", " inputConnection", "createChannel", "readableChannel", "outputConnection", "currentChannel", "inputCamera", "operatorChannel", "inputChain", "readableConnection", "currentChain", "createSteam", " inputSteam", "localChannel", " inputChan", "InputCamera", "InputChannel", "currentCategory", "outputChan", "operatorStream", "InputChan", "readCategory", " inputChain", "inputCategory", "inputSteam", "InputConnection"], "outputChannel": ["OutputStream", "updateChan", " outputConnection", "successConnection", "Outputchannel", "hiddenChan", "outputchannel", "updateChannel", "OutputConnection", "writeContext", "OutputContext", "hiddenCategory", "writeChannel", "putStream", "putChan", "successChannel", "OutputCategory", "writeConnection", "outputConnection", " outputContext", "putchannel", "writeChan", "putChannel", "outputContext", "hiddenchannel", "successStream", "OutputChan", "successchannel", "hiddenChannel", "outputChan", "updatechannel", "updateCategory", "outputCategory", "OutputChannel", " outputchannel", " outputChan"]}}
{"id1": "3514286", "id2": "8667872", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"getHashedPassword": ["getHackedpassword", "getShashSecret", "getHackedUser", "getHashespassword", "getShashUser", "getHashSecret", "getShashedpassword", "getHackedSecret", "getShashpassword", "getHashpassword", "getHashUser", "getShashedPassword", "getHashedpassword", "getShashPassword", "getHashesSecret", "getShashedUser", "getHackedPassword", "getHashPassword", "getHashedSecret", "getHashesPassword", "getShashedSecret", "getHashedUser", "getHashesUser"], "password": ["Password", "raw", "shadow", "secret", "command", "data", "address", "key", "reset", "hash", "user", "pass", "input", "string", "padding", "database", "username", "token", "sword", "login", "name", "prefix", "description", "attribute", "email", "wd", "phrase", "word", "value", "pattern", "wordpress", "default", "message", "REDACTED", "text"], "digest": ["dests", "hashests", "digests", "Digested", " Digse", "hashse", "Digest", " digested", "Digests", " digester", " Digest", "hashest", " Digester", "mdest", "hashester", "digested", "mdests", "mdester", " digests", " digse", "Digse", "digester", "hashested", "mdse", "digse", "dest", "dested", "Digester"], "hashedInt": ["hashedInteger", "happedTx", "happedId", "hashedTx", "hashedId", "hashInt", "hhedInt", "hhedInteger", "hashashingInt", "hashashingINT", "hhedTx", "hhedId", "hushedId", "hushedInt", "hashingInt", " hashedId", "hashashedINT", " hushedId", "hashingInteger", "hcheckedInteger", " hushedInteger", "hashINT", "happedInt", " hashedTx", "hcheckedINT", "hashInteger", " hashedInteger", "hushedTx", "hashashedInt", "hashashingInteger", " hushedTx", "hashingINT", "hcheckedInt", "hashashedInteger", "hashedINT", " hushedInt", "happedInteger", "hushedInteger"]}}
{"id1": "15510198", "id2": "21232043", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"buildParser": ["newParser", "buildProxy", "createProxy", "newparser", "Buildparser", "BuildParser", "createParser", "newProxy", "createparser", "createReader", "newReader", "buildparser", "BuildProxy", "buildReader", "BuildReader"], "url": ["http", "b", "pl", "link", "web", "l", "ll", "address", "string", "location", "base", "name", "document", "char", "email", "str", "ul", "mail", "ssl", "dl", "ref", "build", "domain", "mount", "URL", "resource", "file", "log", "Url", "job", "sl", "host", "run", "path", "page", "util", "ls", "uri"], "ParserException": ["parserError", "parserEvent", "ReaderException", "parseError", "ReaderEvent", "ParserError", "ReaderError", "ParserEvent", "ReaderWarning", "parseWarning", "parseEvent", "parseException", "ParserWarning", "parserException", "parserWarning"], "parser": ["parse", "Parser", "policy", "consumer", "taker", "xml", "inner", "bank", "payer", "could", "util", "processor", "reader", " soup", " parsed", "builder", "document", "still", "handler", "writer", "language", "php", " provider", "program", "worker", "asser", "layer", "json", "fp", "pair", "lp", "runner", "jack", "manager", "peer", "er", "format", "driver", "loader", "library", "master", " parsing", "job", " parse", "arser", "jp", "message", "pool", " scanner", "instance", "p", "arson"], "connection": ["http", "entry", "to", "link", "conn", "command", "condition", "pointer", "generation", "network", "session", "server", "computer", "instance", "connected", "database", "directory", "response", "remote", "Connection", "c", "document", "still", "open", "handler", "client", "cone", "associated", "currently", "application", "con", "position", "established", "now", "connect", "ion", "resource", "creation", "created", "close", "closed", "relation", "message", "pool", "channel", "communication", "character", "current"]}}
{"id1": "13362846", "id2": "3187685", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setcontensenU", "setContennue", "setContenux", "setCont\u00ednue", "setContenue", "setContennu", "setContensenue", "setCont\u00ednU", "setContennU", "setcontenu", "setContennux", "setcontensenux", "setContensenux", "setCont\u00ednux", "setContenU", "setcontensenue", "setcontensenu", "setcontenue", "setcontenux", "setCont\u00ednu", "setContensenu", "setContensenU", "setcontenU"], "contenuFichier": ["contenuFsichier", "contenuFicheaire", "contenuFichaire", "contenuVchiere", "contenuFuffier", "contenuFachiere", "contenuVechiest", "contenuFiverier", "contenuFignier", "contenuMicher", "contenuMicheier", "contenuFihier", "contenuFithiere", "contenuFamilyichie", "contenuFrenchaire", "contenuFamilyichorie", "contenuFechieri", "contenuFChiere", "contenuFicheie", "contenuFechier", "contenuFachorie", "contenuFolfire", "contenuFolfer", "contenuVichier", "contenuFicher", "contenuFochie", "contenuFicheire", "contenuMichier", "contenuFihyr", "contenuFicheieri", "contenuFicheiere", "contenuFichieri", "contenuFsechier", "contenuFChier", "contenuFichyr", "contenuFichorie", "contenuVechiere", "contenuFsrenchieri", "contenuFichiest", "contenuFrenchier", "contenuFamilyachiere", "contenuFsicher", "contenuFsrenchire", "contenuFamilyachier", "contenuFithyr", "contenuFileichie", "contenuFiverieri", "contenuVechyr", "contenuFamilyichiere", "contenuFrenchieri", "contenuFichtie", "contenuFchiere", "contenuFuffire", "contenuFihiere", "contenuFsechire", "contenuFichIER", "contenuFithorie", "contenuFicheer", "contenuFihiest", "contenuFamilyachorie", "contenuVchie", "contenuFochiere", "contenuFiveraire", "contenuVchier", "contenuFithie", "contenuFchIER", "contenuFichire", "contenuFuffieri", "contenuFigniere", "contenuFachier", "contenuFochIER", "contenuFechire", "contenuMichaire", "contenuFileichiere", "contenuFichiere", "contenuFileichiers", "contenuFithiest", "contenuFileochiers", "contenuFsrenchaire", "contenuVechier", "contenuFachie", "contenuFichtIER", "contenuFignaire", "contenuFigner", "contenuFichie", "contenuFsichieri", "contenuVichyr", "contenuFchie", "contenuMicheaire", "contenuFamilyachie", "contenuFechiest", "contenuVchIER", "contenuFicheorie", "contenuFicheier", "contenuFchier", "contenuFsecher", "contenuFithier", "contenuFileochier", "contenuFichtier", "contenuFachiers", "contenuFechyr", "contenuVichIER", "contenuFsichire", "contenuVichiest", "contenuMichiere", "contenuFecher", "contenuVichie", "contenuFileichier", "contenuFsichaire", "contenuMicheer", "contenuFolfieri", "contenuMicheiere", "contenuFochier", "contenuFicheiers", "contenuFileochiere", "contenuFCher", "contenuVichiere", "contenuFiverire", "contenuFuffer", "contenuFrenchire", "contenuFolfier", "contenuFechiere", "contenuFichiers", "contenuFamilyichier", "contenuFsrenchier", "contenuFochiers", "contenuFileochie", "contenuFichtiere", "contenuFsechieri", "contenuFChaire"], "fichierElectronique": ["fichierTransferradorique", "fichierTransferradorius", "fichierTransferradorie", "fichierElectoniques", "fichierElectrontaire", "fichierElectronius", "fichierAdministroniques", "fichierelectrenic", "fichierCentronicy", "fichierCentronius", "fichierElectRONique", "fichierElectrenaire", "fichierElectrenic", "fichierElectronic", "fichierElectronipolar", "fichierElectroneique", "fichierElectchroniques", "fichierAdministroneiq", "fichierElectRONius", "fichierElectroneius", "fichierElectroneic", "fichierElectronsicity", "fichierElectronie", "fichierElectrontique", "fichierelectroniques", "fichierElectonique", "fichierElectRONaire", "fichierElectromie", "fichierCentRONius", "fichierSelectroneique", "fichierSelectroneiques", "fichierelectronique", "fichierElectonier", "fichierElectromique", "fichierElectronsie", "fichierElectradorique", "fichierElectchronicity", "fichierAdministroneiques", "fichierElectroneipolar", "fichierElectrenique", "fichierElectronsic", "fichierElectronicity", "fichierElectriciques", "fichierElectricique", "fichierElectchronaire", "fichierSelectronoch", "fichierTransferronie", "fichierElectrenier", "fichierAdministroneie", "fichierElectroneiques", "fichierElectromaire", "fichierCentRONique", "fichierElectroneoch", "fichierCentronique", "fichierElectroniq", "fichierElectrenius", "fichierAdministronique", "fichierElectronsoch", "fichierElectradorius", "fichierElectronoch", "fichierElectroneie", "fichierElectronsier", "fichierelectrenier", "fichierElectromipolar", "fichierElectricie", "fichierCentRONicy", "fichierElectroneaire", "fichierTransferradoric", "fichierSelectronique", "fichierElectromic", "fichierElectrontipolar", "fichierElectradoric", "fichierElectromius", "fichierElectronicy", "fichierSelectroniques", "fichierAdministronie", "fichierAdministroniq", "fichierElectroneiq", "fichierCentronaire", "fichierSelectronicity", "fichierElectronticity", "fichierElectroneicity", "fichierElectradorie", "fichierAdministroneique", "fichierElectronaire", "fichierElectronsiques", "fichierTransferronius", "fichierElectchronique", "fichierTransferronique", "fichierElectriciq", "fichierElectronier", "fichierelectrenique", "fichierelectronic", "fichierTransferronic", "fichierElectchronicy", "fichierElectchronius", "fichierelectronier", "fichierSelectroneicity", "fichierElectRONicy", "fichierElectchronoch", "fichierElectromicity", "fichierSelectroneoch", "fichierElectronsiq", "fichierElectronsique", "fichierElectrenicy", "fichierElectreniques", "fichierCentRONaire", "fichierElectonic", "fichierElectroniques", "fichierelectreniques"], "utilisateurCourant": ["utilisateursGoverniant", "utilisateursGovernants", "utilisateurGovernante", "utilisateurParticipants", "utilisateurParticipante", "utilisateurParticipant", "utilisateurGovernant", "utilisateursCourante", "utilisateurRepresentiant", "utilisateursGovernante", "utilisateurCourante", "utilisateurRepresentante", "utilisateurCouriant", "utilisateursGovernant", "utilisateursCourant", "utilisateurRepresentant", "utilisateurGoverniant", "utilisateurRepresentants", "utilisateurGovernants", "utilisateursCouriant", "utilisateursCourants", "utilisateurParticipiant", "utilisateurCourants"], "support": ["pport", "access", "null", "evidence", "use", " Support", "SUP", "know", "install", "system", "accept", "document", "language", "collection", "replace", "feature", "media", "please", "context", "cap", "force", "prototype", "trust", "supported", "port", "Support", "format", "allow", "service", "help", "library", "profile", "proof", "cover", "storage", "success", "supp", "see", "control", "history", "share"], "ficheDocument": ["foyerDoc", "FayeDocument", "fiqueDatabase", "hacheTransaction", "flicheMatrix", "fliciDatabase", "fliciDocument", "hacheJournal", "flicheDocument", "bicheDatabase", "bicheTree", "bicheDocument", "facheTree", "frenchDescription", "ficheDatabase", "hicheTransaction", "ficiMatrix", "bacheDocument", "fiqueDocument", "bacheDoc", "fitimeDescription", "fcheDocument", "facheDoc", "ficheJournal", "fruitJournal", "fayeDocuments", "fayeDocument", "frenchDatabase", "ficheTree", "fitimeDatabase", "foyerTree", "fruitDocument", "hachedocument", "frenchDocument", " frenchDocument", "bacheDatabase", "FicheDatabase", "FayeDoc", "FayeDocuments", "fcheTree", "bacheTree", " ficheDescription", "fiqueDescription", "fifaDocuments", "fcheDatabase", "facheJournal", "bicheDoc", "fliciTransaction", "ficiJournal", "frenchDoc", "FicheDocument", "hichedocument", "foyerDocument", "fichedocument", "fitimeMatrix", "fitimeTransaction", "ficheDocuments", "frenchDocuments", "ficheDoc", "fayeDatabase", "ficheDescription", "ficiDocument", "fifaDatabase", "hicheDocument", "fitimeDocument", "flicheTransaction", "fayeDoc", "fachedocument", "FayeDatabase", "ficidocument", "flicheDatabase", "fruitTransaction", "ficiDatabase", "ficiTransaction", "fruitdocument", "foyerDatabase", "frenchTransaction", " frenchDescription", "FicheDoc", "fliciMatrix", "FicheDocuments", "ficheTransaction", "facheDocument", "facheTransaction", "hicheJournal", "fifaDoc", "frenchMatrix", "fcheDoc", "ficheMatrix", " ficheDatabase", "hacheDocument", "facheDatabase", " frenchDatabase", "fifaDocument"], "nomFichier": ["nomFichanger", "nomFiverery", "nomFchiner", "nomFiliciller", "nomNichire", "nomFachire", "nomUFachire", "nomFachomer", "nomFericIER", "nomUFachier", "nomUFichery", "nomFchire", "nomFihire", "nomFicjer", "nomUFichIER", "nomFichoIER", "nomPFoilER", "nomPFoilier", "nomFichiere", "nomPacherer", "nomFichomer", "nomUFichier", "nomFicheire", "nomFolfie", "nomFichiner", "nomPFoililler", "nomPFichjer", "nomFachie", "nomFericanger", "nomFichER", "nomFolfire", "nomNolfie", "nomFichjer", "nomFicomer", "nomFilicER", "nomFicheiner", "nomFachIER", "nomFilicier", "nomPFichER", "nomFihIER", "nomFericancer", "nomFoiljer", "nomNichie", "nomFchier", "nomFichery", "nomFoililler", "nomFolfier", "nomFchiere", "nomFicheiere", "nomFicire", "nomPachire", "nomFihier", "nomFichiller", "nomPachomer", "nomFolfiere", "nomFichire", "nomFachiner", "nomFicER", "nomFichancer", "nomFicher", "nomFichoanger", "nomFihery", "nomFacherer", "nomFicheier", "nomFoilier", "nomFicier", "nomFericier", "nomFachancer", "nomNolfiere", "nomFachiere", "nomFchomer", "nomFiverire", "nomNichiere", "nomPFichier", "nomFcherer", "nomPichire", "nomPicherer", "nomFicheie", "nomFiverier", "nomFiverIER", "nomFichoancer", "nomFicheer", "nomFachier", "nomNichier", "nomFachery", "nomFilicjer", "nomNolfier", "nomPichier", "nomPachier", "nomFicerer", "nomNolfire", "nomFacher", "nomPichomer", "nomUFachIER", "nomFicherer", "nomUFichire", "nomFachanger", "nomPFoiljer", "nomFiciller", "nomFichoier", "nomUFachery", "nomFichie", "nomFcher", "nomFoilER", "nomPFichiller", "nomFichIER"], "extension": ["Extending", "expension", "protention", "strension", "strending", "expitude", "protractor", "extention", "expention", "extending", "extractor", "xtensions", "protitude", "Extension", "contitude", "expractor", "contension", "extensions", "strensions", "contention", "xtension", "extitude", "protension", "Extensions", "xtending", "contractor"], "fichierElectroniqueExistant": ["fichierElectronogramLocalistant", "fichierElectroniquePlusistant", "fichierElectronogueExistent", "fichierElectroniqueEXvant", "fichierElectroniqueEXistant", "fichierElectronogramLocalclusive", "fichierElectroniqueInert", "fichierElectroniqueInclusive", "fichierElectroniqueExvant", "fichierElectronicityInert", "fichierElectroniqueExiker", "fichierElectronogueExister", "fichierElectronicityInistant", "fichierElectroniquePresentiker", "fichierElectroniqueExplistance", "fichierElectroniquePresentistent", "fichierElectronogueExiker", "fichierElectroniqueEXistance", "fichierElectroniqueAssistance", "fichierElectroniqueInvant", "fichierElectronogueExistant", "fichierElectroniqueLocalclusive", "fichierElectronogramExistent", "fichierElectroniquePersistant", "fichierElectroniqueLocalistance", "fichierElectroniquePersistent", "fichierElectronicityInistance", "fichierElectroniquePersiker", "fichierElectroniqueLocalistent", "fichierElectroniqueExert", "fichierElectroniqueExistance", "fichierElectroniqueInistent", "fichierElectroniqueInistant", "fichierElectronoguePersiker", "fichierElectronicityExistant", "fichierElectronogramExclusive", "fichierElectroniqueExistent", "fichierElectronogramLocalistance", "fichierElectroniqueExplvant", "fichierElectronogramExistance", "fichierElectroniqueExclusive", "fichierElectroniqueLocalistant", "fichierElectroniquePlusistent", "fichierElectroniqueExplert", "fichierElectronicityInvant", "fichierElectronoguePersister", "fichierElectroniqueAssclusive", "fichierElectroniqueAssistent", "fichierElectronogramExistant", "fichierElectroniqueAssistant", "fichierElectronoguePersistant", "fichierElectroniqueExplistant", "fichierElectroniqueInistance", "fichierElectroniquePersister", "fichierElectroniquePlusister", "fichierElectronoguePersistent", "fichierElectroniqueEXert", "fichierElectroniquePresentistant", "fichierElectronicityExvant", "fichierElectroniquePresentister", "fichierElectronicityExert", "fichierElectronogramLocalistent", "fichierElectroniqueExister", "fichierElectroniquePlusiker", "fichierElectronicityExistance"], "idIgid": ["idImgid", "idIgdid", "idIvgid", "idIkgid", "idImglimit", "idIgcoid", "idIigmis", "idIgdoid", "idIgcido", "idIegdata", "idIgzid", "idAgaddress", "idIigmlimit", "idIkgaddress", "idAglimit", "idIIgido", "idIgzoid", "idIvgids", "idIgids", "idIvgkey", "idAmgaddress", "idImgis", "idIgcid", "idIigmid", "idAgis", "idImgids", "idAmgid", "idIIgoid", "idIgdata", "idIegkey", "idIIgzoid", "idIgkey", "idImgaddress", "idIgoid", "idIIgzido", "idIigmaddress", "idAmglimit", "idIIgid", "idIvgdata", "idIegid", "idIkgis", "idIglimit", "idIkglimit", "idIgdido", "idIgcida", "idIIgzida", "idIegids", "idImgdata", "idIgaddress", "idIgida", "idIgzido", "idIgis", "idImgkey", "idIIgzid", "idIgido", "idIgzida", "idIIgida", "idIgdida", "idAmgis", "idAgid"], "inputStream": ["InputSteam", "imageSteam", "inputstream", "imageLoop", "InputLoop", "helloStreamer", "outputStreamer", " inputThread", " inputStreamer", "helloSteam", "imageStream", " inputLoop", "InputStream", "inputThread", "outputSteam", "helloChannel", "inputStreamer", "inputChannel", "outputChannel", "outputThread", "inputLoop", "outputstream", "InputThread", " inputstream", " inputSteam", "helloStream", "Inputstream", "InputTime", "inputTime", " inputTime", " inputChannel", "imageTime", "inputSteam"], "outputStream": ["sequenceStream", "writeStream", "OutputStream", "OutputSteam", "outputStreamer", "OutputStyle", "webView", "outputSteam", "outputStyle", "outputView", " outputView", " outputSteam", "writeForm", " outputStreamer", "sequenceStreamer", "outputForm", "writeView", "writeSteam", "webStream", "webStreamer", "inputForm", " outputStyle", "sequenceSteam", "inputView", "sequenceStyle", "webSteam", "OutputStreamer", "OutputForm", "OutputView", "inputSteam"], "typeMime": ["typemime", "typeSmim", "Typemime", "typeSmme", "typeMim", "TypeMim", "typeRime", "typeMme", "TypeMme", "typeRim", "typeMIME", "typemme", "typeRme", "typeSmIME", "TypemIME", "typeSmime", "typemim", "TypeMIME", "Typemim", "typeRIME", "Typemme", "TypeMime", "typemIME"], "tailleFichier": [" tailleFicheies", " tailleFichie", " taillefichies", " tailleFuzzie", " tailleFixier", " tailleFixiers", " tailleFixies", " taillefichie", " tailleFicheier", " tailleFichies", " tailleficheie", " tailleFuzzier", " tailleFuzzies", " tailleFixie", " tailleficheier", " taillefichiers", " tailleFuzziers", " taillefichier", " tailleFichiers", " tailleFicheiers", " tailleficheiers", " tailleficheies", " tailleFicheie"]}}
{"id1": "15797402", "id2": "6840241", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"parse": ["ping", "scale", "print", "use", "create", "xml", "filter", "execute", "pe", "parser", "process", "transform", "split", "load", "shape", "render", "php", "build", "write", "save", "patch", "add", "format", "resource", "handle", "dump", "se", "map", "interpret", "read", "close", "tag", "slice", "apply", "p"], "stream": ["http", "in", "data", "chain", "test", "download", "input", "clean", "window", "instance", "reader", "response", "image", "sequence", "document", "open", "form", "cont", "sample", "upload", "stack", "sync", "iterator", "resource", "file", "handle", "url", "read", "console", "content", "event", "zip", "Stream", "output", "message", "channel", "length", "buffer", "archive", "ream", "source"], "handler": ["policy", "address", "server", "function", "h", "ctx", "controller", "processor", "hander", "parser", "reader", "shape", "wrapper", "writer", "password", "worker", "callback", "Handler", "connection", "application", "hand", "resource", "handle", "service", "loader", "storage", "management", "event", "host", "message", "pool"], "metadata": ["m", "adata", "md", "material", "detail", "policy", "header", "data", "xml", "parts", "ctx", "property", "MD", "memory", "image", "template", "dirty", "unknown", "java", "document", "tar", "hold", "meta", "details", "properties", "dd", "definition", "google", "still", "basic", "json", "met", "pdf", "mem", "common", "module", "info", "td", "mt", "manager", "managed", "iterator", "handle", "config", "content", "management", "message", "general"], "context": ["null", "command", "condition", "network", "usage", "dict", "chain", "ctx", "environment", "options", "system", "location", "response", "state", "template", "document", "sequence", "collection", "Context", "connection", "module", "stack", "ce", "resource", "local", "reason", "config", "set", "sc", "content", "component", "event", "translation", "cc", "frame", "instance", "current"], "name": ["n", "null", "time", "l", "named", "create", "Name", "key", "NAME", "data", "body", "filename", "no", "label", "pass", "system", "string", "term", "image", "base", "prefix", "description", "type", "len", "client", "alias", "channel", "common", "nl", "lower", "ame", "title", "comment", "none", "old", "version", "size", "names", "value", "resource", "url", "service", "local", "reason", "nm", "file", "part", "id", "all", "default", "on", "path", "family", "current", "source"], "out": ["o", "n", "v", "to", "print", "list", "null", "gen", "in", "oss", "ex", "it", "sum", "flush", "cos", "obj", "us", "user", "res", "OUT", "one", "up", "table", "ou", "Out", "external", "aos", "col", "cmd", "io", "writer", "outer", "sys", "co", "lay", "serv", "con", "url", "file", "auto", "all", "conf", "OU", "output", "outs", "po", "net", "cn", "conv"]}}
{"id1": "6966398", "id2": "14865947", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"reader": ["rl", "inner", "Reader", "cer", "ro", "ner", "input", "rar", "parser", "dr", " read", "rs", "rot", "older", "rx", "builder", "io", "wrapper", "handler", "writer", "rer", "row", "rc", "runner", "iter", "roller", "er", "ri", "stream", " readers", "file", "driver", "rr", "loader", "redo", "read", "mr", "query", "r", "ocr", "lr", "this", "sr", "buffer"], "ks": ["ans", "ds", "KS", "kies", "oss", "qs", "keys", "eks", "k", "obs", "kes", "kr", "ki", "cks", "icks", "ss", "hs", "ates", "sk", "vs", "km", "eps", "ces", "sky", "ms", "ls", "akes", "kk", "ys", "ols", "ars", "cs", "uds", "kb", "ke", "kas", "mk", "checks", "ips", "fs", "ses", "ups", "kens", "bs", "nets", "agles", "ck", "uk", "ros"], "key": ["entry", "ca", "link", "null", "Key", "ssh", "keys", "k", "ey", "hash", "root", "obj", "user", "cer", "ek", "base", "y", "tk", "password", "char", "sk", "client", "by", "type", "core", "KEY", "pair", "sky", "sign", "owner", "trust", "info", "er", "ke", "file", "service", "mk", "power", "object", "my", "x", "ox"], "chain": ["ca", "cache", "batch", "code", "list", "sche", "data", "bank", "test", "hash", "root", "string", "base", "group", "c", "table", "sequence", "type", "trace", "password", "form", "ver", "number", "channel", "pair", "box", "sign", "stack", "Chain", "block", "ce", "check", "stream", "file", "range", "piece", "result", "can", "chains", "binary", "component", "path", "pool", "family", "frame"], "os": ["o", "css", "ose", "pos", "js", "oss", "ops", "los", "oos", "cos", "us", "obs", "oses", "oS", "io", "is", "aos", "Os", "oso", "sys", "ms", "ot", "OS", "ios", "ols", "cs", "ys", "bos", "osi", "ts", "fs", "oids", "uts", "ps", "bs", "out", "ds", "oes", "ls", "ox"], "stamper": ["stamter", "strammer", " strampler", " stamPER", "important", "The", "stumpler", " stimpler", "stampler", "stAmper", "New", "Print", "stAmPER", "stramper", " stumper", "stimper", " stcampler", "stimPER", "strampler", " stimper", "stummer", "stimmer", " strammer", "valid", "stramPER", " stamter", " stramper", "stammer", " stcamper", " stummer", "stamPER", " stumter", "println", "font", "annot", " stampler", " stammer", "read", " stimter", "def", " stcammer", "stAmpler", "_", "good", " stumpler", " stimmer", "stAmmer", " stcamter", "this", "stumter", " stramPER", "stimpler", "stumper"], "appearance": ["displayreciation", "suppearance", "patternearances", "apearance", "appendix", "appearances", "ascears", "displaylies", " appeared", "appeared", "displayears", "attlies", "acclies", "Appearances", "displayearance", "Appeared", "accears", "suppeared", " appendix", "displayendix", "suppearances", "apeared", " appearing", "ascearing", "displayeared", "apears", "apreciation", "aceared", "ascearances", "patternendix", "appreciation", "atteared", "attearance", "Applies", "acearance", "Appearance", "patternearing", "displayearances", "accearance", " appearances", "attearances", "aplies", "apearances", "applies", "apearing", "appears", "patternearance", "acreciation", "appearing", "ascearance", "acearances", "accearances", "displayearing"]}}
{"id1": "21491791", "id2": "16851955", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "label": 1, "substitutes": {"run": ["su", "command", "use", "execute", "test", "call", "system", "process", "exec", "name", "cmd", "runs", "un", "running", "unit", "runner", "work", "par", "fun", "Run", "don", "eval", "pre", "exit", "apply"], "input": ["http", "partial", "parse", "print", "feed", "in", "back", "it", "background", "xml", "inner", "address", "data", "hub", "index", "system", "audio", "action", "image", "state", "table", "Input", "io", "form", "client", "json", "cont", "context", " inputs", "active", "upload", "request", "info", "iter", "stream", "file", "from", "local", "internal", "start", "read", "config", "initial", "hello", "view", "history", "before", "out", "text", "select", "readable", "source"], "output": ["o", "generated", "print", "web", "hidden", "command", "network", "header", "data", "four", "target", "filename", "memory", "directory", "response", "image", "admin", "table", "ou", "io", "latest", "oe", "external", "outer", "export", "connection", "write", "column", "put", "block", "port", "ilo", "stream", "format", "file", "log", "result", "config", "exit", "update", "success", "console", "binary", "Output", "net", "display", "out", "you", "text", "source"], "reader": ["entry", "rw", "in", "data", "inner", "Reader", "proc", "controller", "ro", "reading", "system", "parser", "window", "dr", "rar", "rx", "table", "builder", "wrapper", "handler", "client", "worker", "row", "usr", "context", "ter", "owner", "draw", "iter", "manager", "er", "stream", "iterator", "resource", "file", "driver", "loader", "read", "penter", "r", "readable"], "writer": ["rw", "wire", "network", "writing", "server", "adder", "target", "processor", "ser", "store", "window", "holder", "Writer", "builder", "wrapper", "handler", "client", "worker", "outer", "connection", "yard", "ter", "write", "writ", "caster", "draw", "pipe", "riter", "writers", "manager", "word", "println", "w", "iterator", "written", "file", "driver", "service", "handle", "loader", "widget", "creator", "close", "wrote", "storage", "variable", "penter", "player", "out"], "pump": ["pumps", "peump", " pong", " pumper", "pmp", "peumps", "Peter", "Pong", "prump", "Pump", " pamp", " pipe", "peter", " pUMP", " pumps", " pmp", " peter", "camp", "Podge", "deter", "Pmp", "Pamp", "PUMP", "damp", " podge", "podge", "cumper", "pipe", "dumper", "pemp", "Pumps", "psumper", "Pumper", "pamp", "psipe", "pUMP", "dump", "cump", "psamp", "prong", "psump", "cUMP", "pripe", "pumper", "pong", "prodge", "peumper", "Pipe"], "counter": ["timer", "code", "zero", "record", "key", "hash", "controller", "loop", "total", "term", "ounter", "collection", "random", "client", "average", "radius", "peer", "loader", "const", "page", "current", "continue", "time", "inner", "recorded", "amount", "second", "memory", "responsible", "index", "sequence", "description", "currency", "row", "common", "column", "console", "entry", "batch", "walker", "pointer", "unique", "system", "Counter", "clock", "cell", "context", "phrase", "vector", "buster", "encrypted", "message", "history", "parent", "condition", "book", "ctr", "thread", "processor", "card", "frequency", "outer", "number", "seen", "container", "count", "ter", "scope", "comment", "cookie", "created", "conv"], "buffer": ["b", "batch", "Buffer", "command", "header", "data", "key", "address", "uffer", "base", "table", "sequence", "document", "uf", "buf", "row", "queue", "context", "phrase", "buff", "bytes", "block", "vector", "size", "value", "result", "binary", "message", "length", "text", "source"], "off": ["ip", "att", "aff", "pos", "offs", "ap", "oa", "oct", "no", " OFF", "ff", "cmd", "after", "end", "offer", "un", "OFF", "offset", "Off", "hand", "origin", "ow", "now", "fun", "eff", " Off", "set", "def", "op", "of", " offset", "Offset", "before", "art", "shift"], "len": ["pos", "val", "l", "ld", "ll", "elt", "body", "rel", "cond", "lon", "line", "end", "fin", "buf", "enc", "lvl", "offset", "vol", "lp", "compl", "nl", "mem", "bf", "alt", "lan", "bytes", "ln", "vec", "size", "fun", "le", "coll", "eff", "written", "mat", "pent", "wl", "lf", "del", "kl", "Len", "fl", "en", "all", "cl", "lib", "length", "mult", "ls"], "rd": ["d", "rw", "RD", "ld", "cd", "md", "rn", "rt", "rl", "bd", "rh", "adr", "dr", "ind", "rs", "rand", "rb", "rod", "dd", "red", "rc", "cr", "nd", "udd", "dig", "dra", "ptr", "rez", "ri", "mn", "rid", "rr", "ard", "mr", "sd", "ird", "xd", "hr", "R", "r", "lr", "sr"]}}
{"id1": "14773780", "id2": "14785308", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"testImageInfo": [" testPhotoData", "checkImageInfo", " testImagesInfo", " testImageFile", " testPhotoFile", "checkPhotoData", " testImagesList", "checkPhotoList", "checkImageFile", " testImageData", " testImagesFile", " testImagesData", " testPhotoInfo", " testImageList", " testPhotoList", "checkPhotoFile", "checkPhotoInfo", "checkImageList", "checkImageData"], "IOException": ["APIProblem", "IOEx", "AudioException", "AudioEx", "APIEx", " IOEx", "AudioProblem", "IOProblem", " IOProblem", "APIException"], "start": ["parse", "rest", "print", "time", "it", "step", "starting", "create", "reset", "wind", "seed", "Start", "base", "open", "birth", "begin", "end", " Start", "trans", "offset", "first", "send", "init", "st", "size", "check", "now", "wait", "t", "from", "read", "set", "id", " started", "started", "enable", "get", "before", "art"], "i": ["m", "multi", "b", "to", "ci", "ui", "batch", "yi", "n", "in", "it", "ex", "gi", "key", "q", "phi", "us", "major", "index", "ind", "im", "name", "y", "si", "iq", "li", "is", "gu", "f", "bi", "pi", "u", "j", "conv", "x", "me", "init", "o", "info", "go", "ai", "sim", "s", "mi", "ti", "ix", "id", "g", "di", "my", "ic", "out", "I", "xi", "qi", "p", "uu"], "url": ["http", "link", "null", "web", "l", "ll", "xml", "key", "q", "rel", "el", "res", "string", "location", "base", "external", "str", "ul", "gif", "mail", "dl", "u", "ref", "ur", "nl", "mount", "URL", "gl", "resource", "pattern", "log", "Url", "id", "host", "r", "lr", "path", "ls", "uri"], "istream": ["aststream", "intream", "istiver", "istable", "iptream", "ISTroy", "astorage", "istrace", "iptroy", "intable", "iststream", "ositrace", "itrace", "astream", "astroy", "ositiver", "itream", "istroy", "itable", "ositream", "ositable", "intrace", "itiver", "intiver", "istorage", "iptstream", "ISTorage", "ISTstream", "iptorage", "ISTream"], "ii": ["yi", "ij", "sci", "ci", "cci", "ji", "ei", "gi", "ami", "iri", "cgi", "vi", "nai", "imi", "oci", "II", "ki", "ini", "iu", "li", "fi", "jj", "ati", "obi", "pi", "iso", "chi", "cli", "irm", "ri", "iov", "ai", "ia", "mi", "ni", "hi", "ice", "iti", "iii", "di", "iy", "ista", "ushi", "ti", "si", "xi", "qi", "zi"], "width": ["scale", "dim", "cale", "step", "tall", "px", "data", "fw", "body", "window", "Width", "foo", "idth", "shape", "min", "area", "layout", "wid", "dx", "cut", "wa", "write", "wy", "weight", "draw", "position", "size", "w", "format", "value", "crop", "widget", "const", "length", "left", "path", "x", "frame", "text", "wn", "len"], "height": ["kw", "capacity", "resolution", "amount", "h", "alpha", "angle", "grow", "window", "padding", "Height", "volume", "above", "rank", "stroke", "shape", "chip", "gravity", "rise", "density", "style", "hang", "acity", "sky", "cue", "div", "radius", "size", "depth", "dimension", "def", "green", "frame", "history", "family", "length", "buffer"], "stop": ["rest", "null", "quit", "it", "step", "ops", "duration", "skip", "peak", " STOP", "hop", "obj", "loop", "no", "term", " Stop", "period", "shape", "delay", "end", "fin", "jump", "est", "pause", "st", "wake", "wait", "counter", "next", "Stop", "gc", "pop", "result", "close", "set", "trip", "success", "id", "enable", "disable", "delete", "termination"]}}
{"id1": "8665321", "id2": "12883117", "code1": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 1, "substitutes": {"getNetworkServersIPs": ["getNetworkServersipAddress", "getNetworkSeratorsips", "getNetworkServersIPes", "getNetworkServersips", "getNetworkServersHostAddress", "getNetworkServersHostls", "getNetworkServersListAddress", "getNetworkServersHostes", "getNetworkSeratorsIPs", "getNetworkServersListls", "getNetworkServersipls", "getNetworkServersIPAddress", "getNetworkServersipes", "getNetworkSeratorsipAddress", "getNetworkSeratorsipes", "getNetworkSeratorsIPAddress", "getNetworkServersIPls", "getNetworkSeratorsIPes", "getNetworkSeratorsIPls", "getNetworkServersListes", "getNetworkServersHosts", "getNetworkSeratorsipls", "getNetworkServersLists"], "netaddress": ["Network", "network", " netAddress", "netAddress", "etname", "etaddress", "networkAddress", "networkwork", "networkaddress", "Netaddress", "netaddr", "Netaddr", "NetAddress", "Netname", " netname", " netaddr", "networkaddr", "etAddress", "etaddr", "netname", " network"], "result": ["front", "report", "menu", "goal", "collect", "list", "print", "cache", "csv", "create", "Result", "data", "dict", "memory", "found", "res", "date", "folder", "total", "term", "response", "answer", "table", "expected", "sequence", "collection", "trace", "remove", "currency", "ret", "valid", "block", "vector", "results", "cur", "primary", "search", "complete", "local", "created", "make", "set", "success", "match", "relation", "order", "output", "this", "message", "done", "buffer", "join", "current", "bridge"], "line": ["entry", " lineage", "link", "print", "code", "l", " file", "record", "detail", "lin", "eline", " lane", " rule", "chain", "label", "store", "no", "string", " inline", "lo", "base", "cmd", "trace", "char", "style", "cell", "row", " chunk", "ine", "Line", " row", "inline", "channel", "sql", "nl", "note", "e", "sample", "liner", "comment", " frame", "lex", "column", " lineup", "ln", "block", "word", "iter", " linen", "stream", "le", "next", "LINE", "normal", "lane", "handle", "log", "part", "ice", "point", "section", "lined", "lock", "LIN", "page", " block", "frame"], "splitline": ["SplitLINE", "Splitline", " splitnode", "splitnode", "splnode", "startnode", "joinlink", "splitLINE", "spleline", "joinLine", " splitcell", " spliteline", " splitLine", "starteline", "spliteline", "splcell", "joinline", "SplitLine", "splLINE", " splitLINE", " splitlink", "splLine", "splitLine", "startLine", "joincell", "splitcell", "startline", "spllink", "splline", "splitlink"], "url": ["browser", "http", "b", "link", "conn", "web", "l", "socket", "ll", "address", "server", "rel", "hl", "base", "loc", "open", "cert", "google", "client", "www", "f", "str", "ul", "mail", "ssl", "build", "ur", "nl", "bel", "mount", "https", "URL", "file", "service", "Url", "job", "sl", "r", "net", "ls", "uri"], "connection": ["entry", "link", "conn", "command", "socket", "generation", "network", "data", "session", "connected", "database", "directory", "response", "Connection", "c", "still", "open", "io", "writer", "client", "nc", "context", "application", "character", "con", "position", "established", "connect", "stream", "resource", "opening", "relation", "message", "channel", "communication", "online", "current"], "reader": ["rl", "inner", "Reader", "ner", "ro", "input", "parser", "rar", "reading", "upper", "older", "rx", "builder", "still", "io", "handler", "writer", "client", "river", "row", "runner", "liner", "iter", "er", "cur", "stream", "iterator", "resource", "file", "loader", "read", "r", "buffer", "readable"], "serverline": [" serverlined", "enterserver", "erveronly", "verLine", "serveronly", "erverline", "differentine", "differentlined", "erverine", "verlink", "erverLine", "servingline", "verstyle", "servinglined", "servingstyle", "consoleine", "erverloop", "differentline", "enterlines", "serverloop", "consolelayer", "serverlayer", "erverstyle", "servingine", " serverserver", "erverlined", "enterline", "servingloop", "servingflag", "verline", "servinglayer", "serverserver", "serverstyle", " serverLine", "servingonly", "enterlined", "erverflag", "servinglink", " serverlines", " serverlink", "serverlined", "consoleline", "serverlines", "differentlayer", " serverflag", "veronly", "erverlines", "consolelined", "serverine", "erverserver", "serverLine", "erverlink", " serverloop", "verflag", " serverine", "serverflag", "serverlink"]}}
{"id1": "1097146", "id2": "7044685", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getMessageDecester", "getContentDigests", "getMessageDecests", "getMessageDigester", "getMessagedigest", "getContentdigests", "getContentDigested", "getContentdigester", "getMessagedigests", "getMessageDigested", "getContentdigested", "getContentdigest", "getMessageDecested", "getContentDigest", "getMessagedigested", "getMessageDecest", "getMessageDigests", "getContentDigester", "getMessagedigester"], "input": ["human", "raw", "null", "in", "it", "data", "address", "xml", "q", "missing", "string", "image", "msg", "state", "unknown", "name", "quick", "up", "Input", "cmd", "password", "form", "char", "any", "act", "valid", "qa", "sample", "active", "uu", "request", "required", "cur", "check", "url", "value", "format", "file", "from", "pattern", "config", "initial", "get", "hello", "output", "empty", "focus", "this", "out", "buffer", "text", "qi", "p", "source"], "md": ["d", "m", "comp", "mg", "ad", "cd", "ld", " Md", "mand", "bd", "pd", "hd", "grad", "MD", "mm", "det", "od", "dr", "mu", "pm", "med", "mod", "cmd", "dd", "der", "df", "pdf", "sam", "ms", "dh", "mt", "mc", "mn", "managed", "mp", "mk", "sm", "sd", "def", "dm", "cm", "di", "mb", "ds", "nt"], "bytes": ["b", "strings", "objects", "clips", "forms", "reports", "words", "classes", "blocks", "qs", "keys", "parts", "users", "bags", "lines", "seconds", "pieces", "bles", "bps", "latest", "ms", "files", "bits", "ls", "steps", "videos", "windows", "tes", "s", "versions", "ings", "es", "groups", "binary", "outs", "rings", "values", "bs", "pages", "nets", "units", "Bytes", "terms"]}}
{"id1": "17874479", "id2": "23452437", "code1": "    public static final void main(String[] args) throws Exception {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(\"http://www.apache.org/\");\n        System.out.println(\"executing request \" + httpget.getURI());\n        HttpResponse response = httpclient.execute(httpget);\n        HttpEntity entity = response.getEntity();\n        System.out.println(\"----------------------------------------\");\n        System.out.println(response.getStatusLine());\n        if (entity != null) {\n            System.out.println(\"Response content length: \" + entity.getContentLength());\n        }\n        System.out.println(\"----------------------------------------\");\n        httpget.abort();\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 0, "substitutes": {"httpclient": ["httpsrequest", "hClient", "urlserver", "hconnection", "urlglass", "httpserver", "httpsconnection", "hrequest", " httpglass", " httpcache", "httpClient", "hubclient", "hubserver", "hubglass", "httpglass", "httpcache", "hclient", "httpsClient", "urlclient", " httpconnection", "httpsclient", "hubcache", " httpserver", "urlcache", " httpClient", "httprequest", " httprequest", "httpconnection"], "httpget": ["httpcheck", " httpfind", "ttppost", "httpsget", "httpput", "httpcall", " httppost", "Httpdel", "ttpcall", "webget", "ttpget", "htmlget", "webdel", "htmldo", "httpfind", " httpGet", "httpdel", "ttpGet", "httpdo", "htmlpost", "Httpget", " httpput", "hGet", "httpscheck", "ttpput", "httpsGet", "ttpdo", "HttpGet", "ttpcheck", "Httpfind", "webGet", "httppost", "hget", "webfind", " httpdel", " httppull", "hdo", "htmlcall", " httpcall", "httpGet", "httpspull", "httppull", "hput", " httpdo", "ttppull", " httpcheck"], "response": ["http", "report", "entry", "pos", "data", "xml", "resp", "server", "respond", "hash", "res", "user", "onse", "status", "one", "that", "answer", "document", "still", "sequence", "description", "client", "json", "connection", "application", "reply", "example", "request", "info", "version", "block", "ve", "zone", "next", "value", "service", "respons", "result", "Response", "successful", "success", "relation", "object", "view", "output", "message", "given", "page", "channel", "frame", "tree", "line"], "entity": ["entry", "security", "code", "eric", "null", "detail", "data", "xml", "body", "obj", "pe", "el", "eme", "user", "Entity", "activity", "image", "status", "one", "token", "document", "person", "error", "details", "secure", "email", "form", "line", "ity", "json", "echo", "phrase", "cue", "e", "note", "comment", "put", "peer", "ce", "resource", "existent", "result", "ent", "qualified", "encrypted", "content", "quote", "object", "component", "event", "output", "message", "translation", "ell"]}}
{"id1": "20855053", "id2": "614099", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"init": [" Init", "launch", "Init", " login", " abort", "execute", "initialized", " authorize", "register", " service", " dispatch", "activate", " reset", " bind", " initialization", " refresh", " deploy", "construct", " initiation", "start", " restart", "config", "run", " initiate", " prepare", "action", " construct", " initialized"], "context": ["null", "web", "ex", "h", "chain", "ctx", "res", "self", "state", "c", "exc", "Context", "application", " contexts", "w", "config", "tx", "sc", "bc", "component", "event", "X", "this", "x", "txt"], "classLoader": ["urlloader", "classParser", " classBuilder", "classReader", "classManager", "taskBuilder", "taskElf", " classReader", "ClassPath", "fileParser", "classElf", "urlReader", "ClassLess", "urlLoader", "fileLoader", " classloader", "fileManager", "classBuilder", " classPath", "ClassReader", "fileReader", "ClassParser", " classManager", "urlPath", " classLess", "classloader", "taskLoader", "classLess", "ClassManager", "ClassBuilder", "ClassElf", " classParser", "ClassLoader", "classPath", "taskLess", " classElf", "Classloader"], "urls": [" urlms", "limgs", "urlms", "norms", "longports", "longies", "lps", "lls", "slies", "normports", "urxs", "urllets", "urs", "urlports", "lxs", "normists", "URLs", "urlls", "limms", "limlets", "limls", "ls", "limxs", "urlps", "sls", " urllets", "limps", "slists", "urlxs", "urps", " urlgs", "URLgs", "lims", "urlies", "slports", "normies", "longists", "URLlets", "URLms", "urlgs", "urlists", "longs"], "url": ["browser", "http", "entry", "b", "link", "web", "l", "ll", "rl", "address", "rel", "el", "res", "user", "re", "location", "req", "base", "name", "loc", "li", "email", "char", "f", "str", "ul", "mail", "row", "ssl", "org", "dl", "ref", "ret", "ur", "nl", "bel", "mount", "URL", "resource", "file", "log", "Url", "job", "sl", "r", "lr", "path", "page", "util", "channel", "ob", "ls", "uri", "uu"], "reader": ["iper", "entry", "rl", "inner", "Reader", "ro", "input", "reading", "parser", "rar", "ner", "rot", "older", "rx", "handler", "writer", "rer", "dd", "layer", "row", "runner", "iter", "roller", "er", "peer", " Reader", "stream", "iterator", "resource", "driver", "file", "range", "loader", "rr", "read", "per", "r", "buffer"], "className": ["classRel", " classToken", "titleNot", "cellRel", " classNames", "ClassName", "cellToken", "classString", "ClassPath", "stringType", "moduleName", "CLASSFull", "cellString", "packageName", "titleLine", "logname", "packageData", "moduleType", "classNAME", " classBody", "ClassRel", "classNames", " classTitle", "clNo", "moduleStart", "ClassData", "classLine", "partName", " classType", " classValue", "stringName", "partname", "completeRel", " classNAME", " classString", " classLine", "clPath", " classPath", "clBody", "packagePath", "stringStart", " ClassName", "moduleString", "Classname", "classNot", " classData", "titleString", "playName", "packagename", "stringString", "playString", "ClassNot", " classRel", " ClassFull", " classFull", "logValue", "classTitle", " classNo", "classData", "CLASSTitle", "playBody", "clName", "classBody", "classNo", "classFull", "playNo", "clString", "ClassToken", "completePath", "CLASSNames", "partNAME", "classToken", "classValue", "logName", "classType", " classname", "partValue", " classNot", "logNAME", "ClassLine", " ClassNames", " ClassTitle", "titleName", "CLASSName", " classStart", "ClassString", "cellName", "classname", "clRel", "completeName", "classStart", "classPath"], "clazz": ["glaz", "clclass", "classclass", "classazz", "lass", "glazz", "gluster", "shade", "clade", "glclass", "claz", "class", "glace", "shazz", "shuster", " clade", "glade", "shace", " cluster", "cluster", "classaz", "clace", "classass", "laz", "lclass", "glass", " clace", "lazz"]}}
{"id1": "11716816", "id2": "2324868", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"updateFile": ["updateSourceFile", "UpdateContent", "updatePage", "UpdatePage", "archiveSourceFile", "downloadFile", "updateContent", "archiveContent", "archivePage", "downloadSourceFile", "UpdateFile", "downloadContent", "UpdateSourceFile", "archiveFile", "downloadPage"], "file": ["entry", "report", "rule", "link", "null", "use", "source", "data", "full", "h", "filename", "input", "issue", "image", "base", "name", "table", "document", "io", "type", "attribute", "f", "ile", "channel", "fp", "e", "title", "info", "port", "le", "url", "resource", "t", "File", "format", "local", "handle", "log", "content", "get", "output", "db", "path", "message", "page", "FILE", "p", "line"], "IOException": ["OperationProblem", "SecurityError", " IOProblem", "OperationException", "SecurityProblem", " IOError", "SecurityException", "IOProblem", "OperationError", "IOError"], "destFile": ["DestPlace", " destEmail", " destinationDir", " destinationDo", "sourceFile", "DestPath", "DestFile", " destPlace", "destPath", " destPage", " destFolder", "declFile", "destile", " destile", "Destile", "sourcePath", "targetDir", "tempfile", "tempFile", " DestDir", " destinationFile", "destPlace", " destPath", "Destfile", " DestEmail", "destPage", "optFolder", "sourceDir", " destSourceFile", "declSourceFile", "DestFolder", "declFolder", "targetFile", "DestDir", "DestSourceFile", "destDir", "destSourceFile", "targetPath", "DestPage", "destFolder", "tempPath", "declile", "optPage", "optPlace", "tempDir", " destfile", "targetFolder", " DestFile", " DestDo", "sourceFolder", "optFile", "destDo", " destDir", "destfile", " destinationEmail", " destDo", "destEmail"], "in": ["inf", "m", "n", "raw", "ne", "oin", "IN", "l", "it", "inc", " IN", "al", "inner", "cin", "ins", "input", "mm", "re", "pass", "ind", "rin", "bin", "im", "up", "In", "inside", "io", "is", "ini", "f", "act", "isin", "init", "con", "info", "ln", "iter", "ai", "edIn", "gin", "s", "from", "local", "mi", "read", "all", "en", "ain", "inn", "r", "on", "sin", "ic", "net", "din", "i", "ie", " din"], "out": ["o", "b", "v", "n", "to", "null", "conn", "cache", "oss", "it", "ex", "flush", "chain", "cos", "obj", "no", "OUT", "at", "one", "msg", "os", "up", "jp", "Out", "io", "ou", "oe", "aos", "cmd", "client", "again", "fn", "or", "outer", "channel", "sys", "conv", "ch", "co", "write", "note", "ot", "con", "ion", "t", "s", "result", "log", "gt", "can", "en", " OUT", "g", "OU", "output", "outs", "net", "cn", "ne", "nt"]}}
{"id1": "20181656", "id2": "8667872", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"sortRows": [" sortRues", " sortLrows", "sortDrows", " sortLords", "sortRrows", "sortRecows", " sortLows", "sortDows", "sortDords", "sortRords", " sortRrows", "sortRues", "sortRecues", "sortLords", " sortRords", "sortLows", "sortLrows", "sortRecords", "sortDues", "sortLues", "sortRecrows", " sortLues"], "rows": ["ries", "list", "cases", "data", "roots", "ins", "views", "cells", "months", "issues", "abs", "rules", "resources", "uds", "ues", "heads", "checks", "fields", "ges", "bs", "terms", "frames", "orts", "images", "types", "ris", "raw", "orders", "keys", "ows", "row", "rates", "relations", "packages", "projects", "ports", "ards", "forms", "lines", "links", "arr", "rooms", "sheets", "runs", "tests", "vs", "ms", "files", "ints", "headers", "results", "xs", "items", "models", "docs", "outs", "pages", "history", "maps", "ls", "ros", "reports", "errors", "dates", "blocks", "members", "users", "res", "posts", "rs", "ids", "ods", "rown", "rices", "names", "events", "changes", "series", "groups", "workers", "modules", "tracks", "stats", "values"], "i": ["m", "v", "ip", "ci", "ui", "in", "it", "ei", "gi", "q", "phi", "us", "p", "ori", "ki", "ini", "ii", "li", "is", "io", "xi", "iu", "ie", "ar", "bi", "pi", "u", "e", "init", "ri", "ai", "ia", "mi", "hi", "ix", "id", "g", "di", "ic", "out", "ti", "si", "ji", "zi"], "j": ["ij", "b", "m", "o", "bj", "v", "pr", "l", "js", "err", "it", "ja", "jo", "q", "k", "obj", "rel", "uni", "user", "req", "bot", "state", "im", "y", "rem", "si", "jp", "kj", "by", "adj", "jj", "jac", "json", "jump", "jit", "other", "u", "ret", "note", "e", "br", "og", "aj", "er", "next", "je", "sim", "s", "last", "uj", "jl", "dj", "jet", "ix", "job", "jc", "fr", "son", "g", "di", "J", "kid", "my", "out", "x", "oj", "ji", "z"], "temp": ["kw", "Temp", "null", "fake", "tr", "dat", "test", "perm", "clean", "vt", "term", "status", "template", "base", "tem", "mod", "cell", "porary", "EMP", "mem", "alt", "tim", "fac", "cum", "mint", "level", "t", "local", "mp", "result", "pre", "tt", "const", " tmp", "emp", "current", "variable", "tmp", "buffer", "tc", "txt", "orig"]}}
{"id1": "6988216", "id2": "4895903", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "label": 0, "substitutes": {"testSimpleQuery": [" testSimpleQuestion", " executeBasicQ", " executeSimpleContent", " testRawQuestion", " testQueryQuestion", " testRawQ", " testSimpleContent", " executeBasicQuery", " executeSimpleQ", " testRawContent", " testQueryQuery", " executeSimpleQuestion", " testQueryContent", " testBasicContent", " testQueryQ", " testRawQuery", " testBasicQuestion", " executeBasicContent", " testSimpleQ", " testBasicQ", " executeSimpleQuery", " testBasicQuery", " executeBasicQuestion"], "dummySource": ["daatumSource", "dumpStore", "datalFile", "determinedParent", "dummyStore", "determinedFile", " duffyInput", "dumpSource", "duffyContent", "datumSource", "dancySource", "daummyInput", "dummyInput", "datalParent", " duffySourceFile", "dumpResource", "daatumInput", "dummSource", "dummyResource", "udummySource", "dancyContent", " dummySourceFile", "duffySourceFile", "dancyFile", "udummyContent", "determinedContent", "datalSource", "dummySourceFile", "dummiesStore", "dancyParent", "udeterminedContent", "udeterminedSource", "dummyParent", "udeterminedFile", "determinedSource", "dumpInput", " duffySource", "datalContent", " dummyInput", "dummiesSource", "udummyParent", "dummContent", "dummSourceFile", "daummyStore", "udummyFile", "daatumResource", "datumResource", "udeterminedParent", "datumInput", "daummyResource", "dancyInput", "duffyInput", "dancySourceFile", "daatumStore", "dummiesInput", "datumStore", "duffySource", "dummInput", "dummyFile", " duffyContent", "daummySource", "dummiesResource"], "os": ["o", "css", "ose", "dis", "ui", "pos", "conn", "js", "oss", "socket", "ops", "los", "oa", "oos", "cos", "oses", "obs", "oS", "ori", "des", "io", "is", "aos", "Os", "ens", "ows", "or", "sys", "et", "asis", "ants", "ms", "dos", "ot", "ols", "ios", "OS", "ys", "windows", "s", "bos", "osi", "ts", "om", "fs", "ost", "ats", "es", "ors", "oids", "ims", "uts", "bs", "out", "ds", "si", "oes", "ox", "mos", "ros"], "dummyContent": ["dumpingContent", "dummiesTemplate", "deltaInt", "DumpText", "dummyContents", "dynamicContents", " dummiesContents", "dummyText", "DummyInt", "dumpMedia", "DumpContent", " dummiesTemplate", "dumpingTemplate", "determinedMedia", "DumpInt", "DummyContent", "dummyInt", "determinedContent", "dummyMedia", "determinedText", "dummyCode", "dumpInt", " dummyContents", "DummyText", "determinedInt", "dynamicTemplate", "dumpingCode", "dynamicContent", "dumpingContents", "dumpContent", "deltaContent", "dummyTemplate", "dummiesContents", " dummyCode", "dummiesContent", " dummiesContent", " dummyTemplate", "deltaMedia", "dummiesCode", "DummyMedia", " dummiesCode", "dumpText", "dynamicCode", "DumpMedia", "deltaText"], "source": ["in", "use", "space", "inner", "server", "SOURCE", "site", "user", "ser", "instance", "store", "seed", "image", "status", "template", "table", "google", "ie", "core", "sys", "sql", "src", "scope", "sample", "sp", "ource", "ace", "Source", "sf", "proxy", "search", "resource", "from", "series", "service", "se", "s", "result", "relation", "spec", "sin", "pse", "sr", "join", "uri"], "content": ["summary", "cache", "code", "command", "html", "header", "node", "data", "xml", "key", "body", "ext", "expression", "response", "activity", "status", "template", "editor", "document", "layout", "quest", "sequence", "license", "description", "Content", "cont", "json", " contents", "context", "application", "script", "title", "section", "comment", "example", "version", "txt", "value", "format", "ontent", "resource", "result", "config", "tx", "article", "output", "message", "path", "action", "text", "current", "tree"], "qResult": ["queryResult", "queryReport", "qReport", "QRes", "qresult", "queryResponse", "dqRes", "iqResult", "dqResult", "dqView", " qResults", "iqResponse", "qResponse", "queryRes", "iqResults", " qresult", "iqReport", "dqresult", "qResults", "qRes", "iqRes", "queryResults", "Qresult", " qRes", " qResponse", " qReport", "QResult", "QView", " qView", "qView"], "results": ["reports", "ults", "objects", "forms", "ries", "orders", "settings", "blocks", "members", "times", "data", "missions", "users", "ULTS", "res", "views", "posts", "features", "roads", "assets", "details", " Results", "xes", "lections", "its", "runs", "tests", "RESULTS", "photos", "Contents", "actions", "thumbnails", "terms", "ms", "resources", "events", "Results", "s", "versions", "relations", "result", "items", "ands", "hips", "chains", "olds", "archives", "values", "pages", "children", "rows", "products"], "it": ["m", "ip", "v", "ci", "in", "MIT", "rit", "hit", "h", "IT", "pit", "at", "It", "exec", "is", "li", "its", "ul", "iz", "stat", "init", "st", "info", "he", "iter", "ite", "t", "mit", "read", "id", "lit", "op", "they", "ait", "ic", "out", "i", "et", "p"], "rSrc": [" rSsrc", "rSlrc", "rSRC", "rDesRC", "rSlrs", "rSyssrc", "rSourcerc", "crDesrs", "rSysRC", "crDessrc", "crSrc", "crDesRC", "rSeRC", "rSlcs", " rSource", "rSecs", "rSrs", "rSource", " rScs", "crDesrc", "rSlRC", " rSRC", "rSerc", "rDesrc", "rSysource", "rSourcers", "crSsrc", "rSysrc", "crSRC", "crSrs", "rSourcesrc", "rDesrs", "rScs", "rDessrc", "rSsrc", "rSers", " rSrs", "rSourceRC"], "rSrcIn": ["rSncCon", "rSetsrcin", "rSrsIn", "rSetrcIN", "rSRCCon", "rSrsIN", "rSrcCon", "rSetrcIn", "rSrcOut", "rSncIn", "rSncin", "rSldIn", "rSldOut", "rSldin", "rSldIN", "rSetrcOut", "rSrsInput", "rSetrcin", "rSsrcin", "rSetsrcIn", "rSetsrcIN", "rSRCIN", "rSRCOut", "rSsrcOut", "rSRCIn", "rSldInput", "rSsrcIn", "rSsrcIN", "rSrcIN", "rSRCin", "rSrcin", "rSetsrcOut", "rSsrcInput", "rSncOut", "rSldCon", "rSrcInput", "rSrsOut"], "actualOut": ["realOut", "finalOut", "UALOut", "ualEnd", "actualCopy", "realIn", "actualIs", " actualCopy", "finalout", "actualIn", " actualIn", "actualBytes", "ualBytes", " actualBytes", " actualEnd", "virtualOut", "actuallyCopy", "realCopy", "UALIn", "actuallyOut", "actuallyIn", "UALEnd", " actualout", "actuallyIs", "realIs", "ualout", " actualIs", "virtualIn", "actualout", "ualOut", "ualIn", "UALBytes", "actualEnd", "finalIn"]}}
{"id1": "5061606", "id2": "6966398", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecessesed", "createSettingsIfNacessible", "createSettingsIfNacessesary", "createSettingsIfNacessesar", "createSettingsIfNecessed", "createSettingsIfNeccesary", "createSettingsIfNeccessible", "createSettingsIfNacessary", "createSettingsIfNeccessary", "createSettingsIfNecessar", "createSettingsIfNacessar", "createSettingsIfNeccesible", "createSettingsIfNeccesar", "createSettingsIfNeccesed", "createSettingsIfNecessible", "createSettingsIfNecessesible", "createSettingsIfNacessesed", "createSettingsIfNacessed", "createSettingsIfNeccessar", "createSettingsIfNecessesar", "createSettingsIfNeccessed", "createSettingsIfNecessesary", "createSettingsIfNacessesible"], "out": ["o", "report", "n", "to", "print", "conn", "null", "list", "it", "oss", "ex", "err", "server", "flush", "cos", "obj", "inv", "res", "OUT", "timeout", "that", "one", "yes", "cho", "os", "up", "Out", "ou", "io", "oe", "aos", "writer", "client", "again", "f", "end", "or", "outer", "bo", "sys", "conv", "ch", "co", "write", "note", "init", "ot", "comment", "con", "off", "ion", "w", "go", "t", "file", "gc", "log", "max", "ent", "exit", "can", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "fSettings": ["sfChanges", "bfChanges", " fsettings", "finalOptions", "fSetting", "fsettings", "cfSetting", "eSetting", "sfSetting", "fOptions", "fSetup", "cfSetup", "hSetting", "hsettings", "finalSettings", " fOptions", "sfOptions", " fSetting", "bfsettings", "bfSettings", "finalsettings", " fSetup", "sfsettings", "fChanges", "eSettings", "bfSetting", "sfSetup", "cfSettings", " fChanges", "finalSetting", "esettings", "hSettings", "sfSettings", "cfsettings"], "src": ["syn", "pkg", "rt", "rl", "filename", "root", "rel", "desc", "ser", "attr", "th", "rs", "loc", "rx", "fn", "cont", "img", "sys", "rc", "ur", "ls", "dir", "upload", "cur", "sf", "url", "resource", "sit", "config", "sc", "spec", "view", "sb", "tmp", "dest", "sr", "txt", "sq", "source"], "in": ["inf", "n", "IN", "l", "ad", "inner", "cin", "ins", "input", "vin", "rin", "bin", "In", "inside", "is", "isin", "init", "and", "info", "ln", "iter", "gin", "from", "id", "en", "inn", "sin", "r", "din", "i", " din", "source"]}}
{"id1": "4686922", "id2": "530882", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceFromStream", "extractResource2file", "extractResources2Files", "extractResources2file", "extractResourceFromFile", "extractResourceFromFiles", "extractResourcesToFile", "extractResourceTofile", "extractResourceFromfile", "extractResourcesToFiles", "extractResource2File", "extractResourceAsFiles", "extractResourceAsfile", "extractResourceToFiles", "extractResources2File", "extractResourceAsStream", "extractResourceAsFile", "extractResource2Files", "extractResourceToStream", "extractResourcesToStream", "extractResource2Stream", "extractResourcesTofile", "extractResources2Stream"], "resourcePath": ["ResourceUrl", "uriUrl", " resourcepath", "ResourceLocation", "attributePath", "ResourceName", "templatePath", "templateIn", " resourceName", "uriLocation", "templateName", "resourceName", "resourceLocation", "templatepath", "attributeName", "attributeUrl", "attributeLocation", "uriPath", "uriName", "Resourcepath", "resourceIn", "resourcepath", "ResourceIn", "resourceUrl", "ResourcePath", " resourceIn"], "dest": ["to", "rest", "null", "comb", "prop", "cat", "dat", "target", "desc", "dist", "self", "des", "loc", "decl", "Dest", "end", "nom", "cont", "img", "trans", "mem", "src", "sp", "dir", "origin", "w", "opt", "gov", "result", "home", "etc", "coord", "lit", "good", "output", "tmp", "this", "temp", "orig", "parent", "source"], "in": ["inf", "m", "ne", "raw", "IN", "l", "it", "inc", "al", "inner", "cin", "ins", "no", "input", "re", "ind", "rin", "bin", "up", "In", "ini", "is", "inside", "f", "or", "isin", "init", "none", "con", "iter", "ln", "mc", "resource", "file", "gin", "from", "local", "mi", "id", "all", "conf", "inn", "r", "on", "sin", "din", "i", " din", "source"], "out": ["o", "b", "v", "to", "n", "ne", "print", "null", "cache", "oss", "it", "inner", "cos", "obj", "res", "no", "OUT", "na", "at", "os", "Out", "ou", "io", "aos", "col", "writer", "client", "again", "f", "outer", "sys", "ch", "co", "note", "write", "ot", "con", "w", "t", " Out", "can", "exit", "en", "output", "outs", "tmp", "stable", "on", "pool", "net", "i", "cn", "conv", "nt"]}}
{"id1": "12039034", "id2": "13886238", "code1": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 0, "substitutes": {"importRoles": ["importResles", "importRles", "importPules", "importResoles", "importPole", "importPles", " importRole", "importResole", "importResules", "importRole", "importPoles", " importRles", "importRules", " importRules"], "urlString": ["urlRest", "urlList", " urlList", "UrlSource", "uriSource", " curlList", "uristring", "urlStr", " URLRest", "UrlStr", " URLList", "UrlString", " curlRest", " urlSource", " curlString", " urlRest", " urlstring", " urlStr", " URLStr", "Urlstring", " curlStr", "uriString", " URLString", "urlstring", "urlSource", "uriStr"], "results": ["reports", "ults", "objects", "forms", "images", "sets", "csv", "settings", "tops", "blocks", "times", "parts", "roots", "users", "helps", "uploads", "res", "options", "posts", "features", "pieces", "parents", " Results", "details", "places", "properties", "runs", "tests", "its", "RESULTS", "photos", "ces", "artifacts", "works", "changes", "rates", "Results", "s", "games", "relations", "result", "items", "es", "modules", "ands", "finals", "successful", "chains", "olds", "outs", "rings", "values", "abilities", "maps", "locks", "reads", "rows", "vals", "prints", "products"], "url": ["browser", "http", "b", "pl", "link", "web", "l", "ll", "q", "rel", "el", "p", "re", "lb", "base", "loc", "open", "char", "f", "str", "ul", "mail", "ssl", "dl", "u", "ret", "ur", "nl", "mount", "URL", "resource", "file", "gl", "Url", "sl", "get", "r", "uri"], "in": ["inf", "m", "IN", "l", "inc", "ill", "inner", "cin", "sum", "body", "ins", "el", "input", "buffer", "doc", "reader", "ind", "rin", "bin", "In", "is", "io", "by", "f", "serv", "con", "and", "iter", "file", "from", "fs", "get", "conf", "inn", "on", "i", "out", "din"], "buff": ["pb", "comp", "b", "Buffer", "tab", "grow", "tf", "rend", "bind", "cond", "aux", "builder", "zz", "uf", "alph", "cmd", "ob", "ff", "form", "col", "hold", "buf", "bed", "tm", "row", "bo", "pdf", "build", "mem", "conv", "bg", "raf", "nd", "cb", "off", "fb", "urg", "printf", "prof", "qq", "bb", "fr", "bm", "bound", "uff", "zip", "roc", "sb", "tmp", "mb", "supp", "Buff", "bs", "ack", "ck", "buffer", "butt", "txt", "quit"], "line": ["entry", "n", "code", "link", "command", "l", "record", "lin", "eline", "header", "node", "body", "chain", "pe", "no", "label", "string", "lines", "msg", "lo", "stroke", "cmd", "email", "str", "cell", "row", "Line", "ine", "inline", "channel", "nl", "note", "e", "sample", "liner", "comment", "ln", "block", "iter", "word", "le", "LINE", "file", "lane", "range", "log", "lf", "ice", "point", "page", "out", "buffer", "frame", "text", "len"], "name": ["n", "ename", "named", "num", "node", "Name", "NAME", "key", "nam", "system", "string", "group", "sequence", " Name", "prefix", "person", "spe", "qual", "alias", "number", " names", "mem", "common", "ame", "cap", "title", "zone", "names", "value", " NAME", "profile", "nm", "ni", "part", "member", "id", "ident", "role", "ns", "cn", "instance"]}}
{"id1": "17786231", "id2": "5759961", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": ["loadFile", "transferFile", "getContent", "loadfile", "transferContent", "getResource", "downloadResource", "loadContent", "downloadfile", "downloadContent", "transferResource", "transferfile", "loadResource", "getFile", "getfile"], "downloadUrl": ["reportUrl", "installLink", "downloadLink", "installUrl", "DownloadURL", " downloadUr", "DownloadWar", " downloadURL", "linkUr", "reportWar", "transferWar", "reportURL", "linkURL", "transferUrl", " downloadLink", "linkUrl", "installUr", "installURL", "reportUr", "transferURL", "downloadWar", "downloadUr", "DownloadUr", "DownloadUrl", "linkLink", "downloadURL", "transferUr"], "destinationFile": ["coordacementName", " destinationDir", "destacementFolder", "destiningSourceFile", "destificationDir", "destarationFile", " destinationPath", "coordinationFolder", "destacementName", " destificationSourceFile", "destarationFolder", "coordinationfile", "destinatedFolder", "destacementFile", " destificationFile", "destinationfile", "destificationFile", "destinatedFile", "destarationName", "destarationSourceFile", "destinationFolder", "coordinationName", "destinationSourceFile", "coordacementFolder", "destinationPath", " destificationDir", "destificationPath", " destinationSourceFile", "destiningDir", "coordinationFile", "destinationDir", "destarationfile", "destinatedfile", "destinationName", "destificationSourceFile", "destarationDir", "destacementfile", "destinatedName", "destarationPath", "coordacementfile", "coordacementFile", "destiningPath", " destificationPath", "destiningFile"], "client": ["http", "cache", "ci", "conn", "phone", "network", "key", "server", "city", "call", "system", "Client", "template", "io", "wrapper", "collection", "google", "channel", "api", "connection", "context", "co", "contact", "force", "request", "cli", "https", "url", "resource", "service", "query", "cl", "console", "cm", "pool", "net", "remote", "tc", "uri"], "httpGet": [" httpGET", "ttpPut", "ttpget", "httpGET", " httpPut", "utilPut", "ttpGet", "hPut", "HttpQuery", "httpQuery", "utilQuery", "httpPut", "utilGet", "Httpget", "HttpPut", "hGet", "utilGET", "HttpGet", " httpQuery", "hget", "httpget", "HttpGET"], "outputFile": ["outputPoint", "OutputStream", "tempFile", "outputPlace", "outPoint", "tempStream", "newPlace", "betaFILE", " outputFILE", "newFile", "seeFile", "outPlace", "regionStream", "outputFILE", "OutputFile", "newPoint", "regionFile", "betaFile", "regionFILE", "tempFILE", "outStream", "OutputPlace", "newStream", "outFile", "seeFILE", "OutputPoint"], "outputStream": ["printSteam", "inputstream", "printStream", "OutputStream", "OutputSteam", "responseStream", "outputStreamer", "putStyle", "OutputStyle", " outputForm", "inputStreamer", "putStreamer", "outputSteam", "outputStyle", "outputView", " outputView", "inputFile", " outputSteam", "putStream", "responseStreamer", " outputstream", " outputStreamer", "coinStyle", "responseSteam", "outputstream", "outputForm", "inputStyle", "coinSteam", "putSteam", "inputForm", "Outputstream", " outputStyle", "inputView", "responseStyle", "printForm", "OutputView", "inputSteam", "printFile", "coinStream", "coinStreamer"], "response": ["http", "entry", "data", "resp", "body", "server", "post", "onse", "image", "status", "yes", "answer", "document", "still", "description", "details", "attribute", "json", "connection", "application", "reply", "example", "request", "version", "block", "resource", "service", "result", "Response", "content", "initial", "output", "message", "given", "page", "remote"], "entity": ["entry", "security", "cache", "detail", "data", "xml", "body", "obj", "pe", "el", "unique", "total", "Entity", "activity", "status", "image", "group", "name", "document", "person", "error", "details", "type", "attribute", "secure", "email", "properties", "ity", "json", "associated", "enc", "valid", "iso", "note", "e", "comment", "info", "peer", "ilo", "metadata", "resource", "local", "profile", "existent", "account", "result", "existing", "ent", "member", "encrypted", "content", "quote", "object", "component", "event", "message", "translation", "buffer", "instance", "line"], "inputStream": ["InputSteam", "imageSteam", "evalStreamer", "inputstream", "readSteam", "upForm", "readStream", " inputStreamer", "sourceView", "thisStream", "sourcestream", "thisSteam", "inputStreamer", "imageStream", "InputStream", "outputSteam", "outputStyle", "outputView", "InputForm", " inputForm", "outputstream", "upStream", "outputForm", "activeStreamer", "evalStream", "thisForm", "inputStyle", " inputstream", " inputSteam", "Inputstream", "activeSteam", "upstream", "InputStyle", "inputForm", "activeView", "readstream", "upSteam", "activeStream", "inputView", "evalView", "readForm", "evalSteam", "imagestream", "thisStyle", "imageView", "sourceSteam", "inputSteam", "sourceStream", " inputView"], "callback": ["browser", "continue", "back", "consumer", "background", "policy", "function", "filter", "call", "processor", "parser", "window", "lambda", "token", "facebook", "builder", "wrapper", "actor", "handler", "alias", "cell", "closure", "CB", "hook", "func", "cb", "finder", "manager", "sound", "Callback", "binding", "gc", "loader", "library", "pattern", "job", "creator", "cc", "update", "backs", "message", "display", "soon"], "copiedLength": ["copIEDLength", "copedLength", "copedDuration", "copIEDNumber", "copiedNumber", "copedSize", "copyLen", "copifiedLen", "copifiedLength", "copifiedDuration", "copifiedNumber", "copyLength", "copedNumber", "copIEDDuration", "CopedSize", "CopedNumber", "copySize", "CopiedDuration", "CopedDuration", "copiedLen", "CopedLength", "CopedLen", "copiedDuration", "CopiedLength", "copifiedSize", "copyDuration", "CopiedSize", "CopiedLen", "CopiedNumber", "copiedSize", "copedLen"], "percentage": ["Percentage", "Percentages", "CENTage", "percentale", " percentages", "capale", "Percenture", " percentale", "capages", "capage", "CENTages", "capaging", "Percentale", "CENTure", "percentages", "percenture", "Percentaging", " percenture", "percentaging", " percentaging"]}}
{"id1": "3558512", "id2": "3053403", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "label": 1, "substitutes": {"serialize": ["finalize", "serializer", "initialization", "initialize", "erialize", "serialization", " serialate", "Serialized", "initialized", "finalization", " serialized", "Serialze", "finalized", "erialate", "serialized", "serialate", " serializer", "initialze", "serialze", "Serialate", "Serializer", "Serialize", "Serialization", "finalze", "erializer", "erialized"], "out": ["d", "o", "b", "v", "report", "n", "to", "err", "it", "sum", "res", "OUT", "c", "os", "up", "Out", "ou", "io", "aos", "f", "ch", "serv", "stream", "w", "t", "file", "log", "result", "sw", " OUT", "OU", "output", "outs", "pool", "a", "i", "p"], "parser": ["tree", "parse", "aser", "plan", "walker", "command", "Parser", "policy", "magic", "pkg", "xml", "inner", "bank", "proc", "util", "processor", "p", "reader", "token", "base", "builder", "tar", "language", "writer", "password", "handler", "asser", "rer", "worker", "layer", "style", "tp", "lp", "ger", "manager", "er", "peer", "now", "format", "file", "loader", "ler", "job", "part", "arser", "per", "jack", "instance", "ker"], "on_disk": [" on_dis", " on_disc", "on_download", "on_volume", "on_disc", "on2file", "on_file", "On_link", " on_Disk", " on_volume", "On2Disk", "on_cloud", "On2file", "On_cloud", "On2link", "On_disk", " on_file", "On_Disk", "on_Disk", "on_dis", "On_file", "on2link", "on_link", "On2disk", "on2Disk", "on2disk", " on_download"], "in": ["inf", "IN", "ad", "inc", "it", " IN", "inner", "cin", "body", "ins", "input", "ind", "vin", "rin", "bin", "min", "In", "inside", "io", "is", "isin", "and", "gin", "from", "mi", "id", "en", "ain", "inn", "sin", "on", "r", "i", "din", " din"]}}
{"id1": "6421904", "id2": "2199604", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"addRecord": ["addrecord", "writerecord", "newDocument", "AddFile", "writeDocument", "writeFile", "AddRecord", "AddDocument", "Addrecord", "addDocument", "newrecord", "newRecord", "addFile", "writeRecord", "newFile"], "input": ["m", "in", "it", "data", "address", "q", "reader", "image", "base", "up", "Input", "error", "open", "io", "table", "is", "media", "context", "upload", "request", "stream", "w", "add", "format", "from", "start", "config", "content", "initial", "get", "this", "out", "current", "p", "source"], "temporary": ["typoral", "comperature", "tempor", "typor", "temarily", "theporal", "semperature", "Temporal", "timmanent", "temcreated", "tymediate", "memporary", "temmediate", "temppty", "Temutable", "rempty", "tememp", "tempient", "transporal", "stemporary", "semporal", "stporal", "Temporary", "timporal", "temporal", "timmediate", "timperature", "remporal", "transporary", "tmporary", "timtemp", "tmutable", "comarily", "temmanent", "stporary", "tempporary", "memutable", "tempperature", "timutable", "tytemp", "temptemp", "tyient", " temporal", "transmanent", "tmient", "timarily", "transperature", "tempcreated", "timporary", "stemporal", "tmporal", "temutable", "comporary", "tmperature", "memperature", "remporary", "stemperature", "temtemp", "comporal", "temperature", "stemp", " tempty", "tenperature", "typerature", "tempty", "temputable", "remcreated", "Temperature", " temcreated", "semporary", "tmemp", "temient", "stemmanent", "theperature", "stperature", "tenporal", "temppor", "tenporary", "tempporal", "memporal", "tmpor", "themediate", "tenarily", "typorary", "tyutable", "theporary", "sememp"], "tempId": ["tempID", "fakeId", "tempUrl", "tempK", "templateK", "tempPart", "templateId", "templateRef", "fakePart", "templateIs", "TempId", "TempUrl", "currentK", "fakeID", "TempID", "stemId", "poraryRef", "fakeRef", "poraryPart", "tempRef", "templateID", "templateUrl", "tempIs", "poraryID", "stemID", "poraryUrl", "currentIs", "templatePart", "uniqueUrl", "currentId", "uniqueIs", "uniqueId", "currentUrl", "poraryId", "stemUrl", "uniqueK"], "length": ["n", "capacity", "code", "time", "l", "ength", "duration", "data", "amount", "full", "L", "filename", "total", "string", "location", "padding", "volume", "limit", "available", "loaded", "load", "name", "shape", "sequence", "description", "type", "width", "end", "number", "json", "SIZE", "count", "offset", "Length", "bytes", "version", "position", "size", "supported", "ENGTH", "value", "present", "read", "all", "maximum", "content", "default", "message", "path", "buffer", "height", "text", "readable", "len"], "digest": ["mdested", "Digested", "fingerest", "modested", " digist", "Digest", " digested", " digEST", " digester", "Digist", "signester", "fingerested", "diger", "identest", "identested", "DigEST", "mdest", " diger", "digested", "identig", "identester", "modEST", "mdester", "fingerEST", "mdig", "modest", "moder", "fingerester", "signest", "digig", "digEST", "Diger", "digester", "signested", "signist", "digist", "Digester", "Digig"], "output": ["o", "to", "web", "hidden", "generation", "network", "data", "four", "body", "unsigned", "no", "response", "image", "that", "open", "io", "ou", "client", "outer", "channel", "cut", "icon", "other", "connection", "write", "application", "none", "put", "ilo", "stream", "next", "result", "auto", "exit", "console", "object", "see", "Output", "message", "net", "display", "out", "page", "buffer", "you", "current", "source"], "file": ["print", "null", "in", "record", "data", "full", "user", "child", "io", "type", "dir", "upload", "le", "url", "File", "local", "binary", "get", "place", "page", "channel", "FILE", "source", "report", "to", "link", "al", "h", "base", "ile", "fp", "common", "stat", "module", "word", "resource", "value", "handle", "library", "result", "id", "run", "buffer", "entry", "rule", "body", "filename", "entity", "image", "document", "f", "il", "class", "valid", " File", "files", "work", "real", "info", "port", "same", "format", "db", "message", "temp", "out", "remote", "action", "tree", "line", "http", "create", "chain", "target", "name", "table", "error", "form", "e", "comment", "old", "block", "single", "log", "relation", "this", "path"], "parent": ["man", "m", "tree", "to", "rule", "ip", "null", "root", "folder", "child", "holder", "base", "name", "parents", "shape", "wrapper", "line", "global", "ger", "sp", "owner", "dir", "ma", "block", "port", "mother", "from", "master", "part", "op", "relation", "g", "per", "tmp", "this", "path", "pool", "Parent", "out", "p", "source"], "now": ["then", "zero", "null", "time", "since", "Now", "full", "sum", "NOW", "post", "date", "mm", "system", "aw", "yes", "amp", "omp", "loc", "after", "dd", "ct", "recent", "when", "st", "draw", "cmp", "off", "ow", "aj", "tim", "size", "wait", "from", "gov", "present", "always", "diff", "here", "exp", "sw", "set", "day", "onew", "mb", "ord", "before", "fx", "done", "ready", "current"]}}
{"id1": "2511579", "id2": "13783549", "code1": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"extractZipFile": ["extractJarfile", "extractPackagefile", "extractZipDir", "extractPackageFile", "extactLogFile", "extactZipFile", "extactZipDir", "extractJarDir", "extractPackageFilename", "extactLogDir", "extactLogFilename", "extractLogfile", "extractLogFilename", "extractLogDir", "extactZipfile", "extractLogFile", "extractJarFile", "extactZipFilename", "extractZipFilename", "extractZipfile", "extractPackageDir", "extractJarFilename", "extactLogfile"], "filename": ["ename", "root", "folder", "location", "directory", "username", "base", "name", "prefix", "FILE", "description", "fn", "latest", "fil", "f", "SourceFile", "Filename", "fp", "subject", "sql", "src", "title", "origin", "ln", "url", "file", "original", "nm", "kl", "output", "path", "message", "txt", "uri", "source"], "progressText": ["gradeLog", "progressLog", " ProgressInfo", "gradeCheck", "progresstext", "progressCheck", "progressLabel", "progressInd", "formText", "progressMath", "progressCode", " progressiveRect", "formPrint", "memoryLabel", "ProgressCode", " progressCheck", "progressRect", "debugtext", " progressMath", "formTEXT", "debugTEXT", "priorityMsg", " progressiveLog", "gradeFont", "memoryMsg", " progressFont", " progressLog", " progressiveText", " ProgressLog", "gradeText", "memoryText", "priorityInd", "priorityMath", "priorityFont", "memoryInd", " progressLabel", " progresstext", " progressTEXT", "progressFont", " progressPrint", "progressInfo", "ProgressText", "debugText", "priorityLog", " progressiveInfo", "ProgressLog", "priorityText", "progressTEXT", "progressMsg", " ProgressText", "debugPrint", "priorityLabel", "ProgressCheck", " progressInfo", "gradeCode", "formtext", " progressMsg", " progressInd", " progressCode", "gradeMath", "progressPrint", " ProgressRect", " progressRect"], "destinationname": [" destificationname", " destificationnames", "destinationsecret", "destositorysecret", "destositoryfrom", " destinationnames", "destinedno", "destorationno", "destensionsecret", "destificationnames", "destositoryName", "Destinationname", "destensionroot", "destinationnm", "destinednam", "destmentationname", " destificationsecret", "destensionname", "destorationadmin", "restinationname", "destmentationno", "destositoryroot", "DestinationName", "restinationno", "destmentationnam", "destificationroot", "destositorynm", "restorationno", "destensionnames", "destinedName", "restorationadmin", "destmentationadmin", " destinationroot", "destorationnam", "destinationnames", " destificationroot", "destinationno", "destositoryname", "destinednm", "destinationfrom", "destinationName", "restorationnam", "destositorynames", "destinationnam", "Destinationnm", "destinedadmin", "Destinationfrom", "destinationadmin", "restinationadmin", "destificationname", "restinationnam", "destorationname", " destinationsecret", "destinedfrom", "destificationsecret", "restorationname", "destinedname", "destinationroot"], "buf": ["b", "batch", "raw", "comb", "Buffer", "prop", "tr", "pkg", "data", "buffer", "paste", "mu", "seq", "msg", "bt", "arr", "uf", "alph", "cmd", "rb", "pack", "bag", "queue", "img", "str", "bn", "boxes", "fp", "cont", "mem", "br", "buff", "cap", "cb", "bytes", "vec", "block", "fb", "cur", "cv", "norm", "wb", "fr", "db", "hz", "Buff", "conv", "text"], "zipinputstream": ["zipinputscope", " zipinputmount", "zipinputStream", "zipinitstream", "zipinitialStream", "zipupstream", "zipInputcontext", "zipjoinstream", "zoutputform", "zinputline", "zipInputservice", "zipfeedStream", "zoutputline", "zipInputline", "zipInputmount", "zipactivestream", "zipInputscope", " zipfeedstream", " zipfeediterator", "zipinputview", "zipupiterator", "zipupStream", "zipopenStream", "ZipinputStream", " zipinitview", "zipopencontext", " zipinitmount", "Zipinputstream", "ziparchivestream", "ZipInputservice", "zipinitview", "zipInputiterator", "zipinputservice", "zipupcontext", "ZipInputiterator", " zipinitStream", "zipopenstream", "zinputform", " zipinputcontext", "zipinitialservice", "zipjoiniterator", " zipinputview", "zipinputform", "zipoutputstream", " zipinputiterator", "zipsearchiterator", "ZipInputStream", " zipopeniterator", "ZipInputscope", "zipfeedstream", "zipoutputform", "zipoutputStream", "zipinputiterator", " zipopencontext", " zipopenStream", "zipoutputiterator", "zipfeediterator", "Zipinputservice", "ZipInputsteam", "zipjoinStream", "zipactiveline", "zoutputstream", "zipinitmount", "zinputstream", "zipinputline", " zipfeedStream", "zipinitialscope", "zipinitialstream", "zipinputsteam", "zipsearchsteam", "zipoutputsteam", "Zipinputsteam", "ZipInputstream", " zipinitstream", "zipopeniterator", "zipactiveservice", "zipInputview", " zipopenstream", "zipinitStream", "zipsearchstream", "ziparchivemount", "zipinputmount", "zipoutputline", "zipInputStream", " zipinputStream", "zipinputcontext", "zipsearchStream", "ziparchiveStream", "zipactiveStream", "zipInputstream", "zipactiveform", "zipactivescope", "Zipinputscope", "zipInputsteam", "ziparchiveview", "zinputStream", "Zipinputiterator", "zipInputform", "zoutputStream"], "zipentry": ["zcard", "zipfile", "testenter", "packageentry", " zipEntry", "packageconnection", "Zipfield", "Zipfile", "zipcard", " zipfile", "archivecell", "zonefile", "zEntry", "zoneentry", " zipfield", "Zipenter", "Zipjob", "zipcell", "zenter", "Zipinfo", " zipinfo", "zipEntry", "testEntry", "zipenter", "Zipentry", "zipjob", "zfield", "archiveentry", "testjob", "zentry", "zjob", "zcell", "zoneEntry", "archiveconnection", "packagecard", "zinfo", "zipfield", "archivecard", "zipconnection", "zconnection", "packagecell", "ZipEntry", "zipinfo", "testentry"], "entryName": ["entrySpec", "cellKey", " entryCase", "existentNAME", " entrySpec", " entryTitle", "EntryName", "attributeCase", "sectionCase", "attributeSpec", "seaTitle", "elementName", " entryKey", "sectionSpec", "seaKey", "elementKey", "entryKey", "entryType", "EntryKey", " entryType", "entryNot", "cellNAME", "entryTitle", "attributeKey", "existentName", " entryPath", "elementTitle", "seaName", "cellname", "cellPath", "sectionName", "entryPath", "cellName", " entryNot", "cellType", "attributeName", "sectionKey", "entryNAME", "seaNot", "elementNot", "existentType", "existentname", "EntryPath", "entryname", "entryCase", "Entryname", " entryname", " entryNAME"], "n": ["d", "m", "b", "v", "cn", "l", "ll", "yn", "num", "nan", " l", "k", "no", "na", "c", "name", "y", "fn", "len", "number", "ng", "gn", "count", "j", "nc", " m", "nl", "nd", "N", "nn", "ln", "sn", "w", " len", "t", "s", "nu", "nor", "nm", "en", "g", "ren", "r", "i", "ns", "x", "ne", " N", "z", "p", "nt"], "fileoutputstream": [" fileputStream", "fileoutputsteam", "filesystemstream", "FileOutputform", "fileoutputfield", "fileputsteam", "filesystemconsole", "filecurrentstream", "fileOutputstream", " filewritewindow", "binarycurrentstream", " filewritepipe", "fileoutputform", "filecurrentlink", "fileresponsewindow", "binaryoutputlink", "fileinputform", "filecolumnform", "FileOutputstream", "filewritewindow", "fileputview", "fileresponsestream", "FileoutputStream", "fileoutstream", "binarycurrentfield", "fileoutputconsole", "fileOutputconsole", "filesystemStream", "fileinputStream", "fileOutputform", "binarycurrentview", "fileputconsole", " fileoutputsteam", "fileresponsepipe", "fileoutputview", "filewriteStream", "fileresponseStream", "fileoutlink", "fileinputstream", "filewritestream", " fileputstream", "fileOutputStream", "binarycurrentlink", "fileputlink", "filecolumnstyle", "fileoutputpipe", "FileOutputstyle", "binaryoutputview", "filewritepipe", "fileoutview", "fileputfield", "Fileoutputstyle", "filecurrentview", "Fileoutputstream", " fileputconsole", " filewritestream", " fileoutputStream", "fileOutputwindow", "Fileoutputform", " filewriteStream", "FileOutputStream", " fileoutputconsole", "binaryoutputfield", "filecolumnStream", "fileputstream", "binaryoutputstream", "fileoutputstyle", "fileOutputsteam", "filecolumnstream", "fileputStream", "fileoutputlink", " fileoutputpipe", "fileoutputStream", "filecurrentfield", "fileOutputpipe", "fileoutputwindow", "fileinputstyle", " fileoutputwindow", "fileoutfield", " fileputsteam", "filesystemsteam", "fileOutputstyle"]}}
{"id1": "13563706", "id2": "8788371", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "doPut", " doget", "DoGet", "DoGET", "Doget", " doGET", "doGET", " doPut", "handleget", "handlePut", "doget", "handleGET", "DoPut"], "request": ["http", "report", "command", "project", "use", "socket", "create", "xml", "address", "reset", "call", "user", "input", "re", "directory", "transform", "document", "attribute", "subject", "first", "connection", "context", "application", "setup", "version", "position", "each", "search", "url", "resource", "Request", "complete", "QUEST", "query", "route", "initial", "forward", "get", "hello", "order", "view", "event", "reference", "message", "path", "frame", "current", "parent"], "response": ["http", "report", "summary", "zero", "print", "continue", "security", "condition", "network", "header", "resp", "server", "respond", "hash", "res", "image", "status", "answer", "document", "sequence", "description", "collection", "render", "json", "connection", "application", "write", "foundation", "reply", "example", "version", "position", "ce", "ve", "block", "next", "search", "format", "service", "Response", "result", "exit", "success", "console", "relation", "view", "see", "output", "default", "fire", "message", "display", "frame", "tree"], "selectedPage": ["selectFile", "matchedFrame", "verifiedpage", "selectionPage", "lectedItem", "electionDocument", "namedPage", "namedToken", "singlePort", "namedKey", " selectedPort", " selectedPath", "selectedItem", "lectedRow", "singlePage", "electedPort", "electionPage", "specifiedDocument", "specifiedPort", "singleFrame", "selectionPort", "namedpage", "lectedPort", "selectLine", "selectionToken", "selectedPath", "selectedpage", "lectedFrame", " selectedLine", "matchedPort", "selectionLine", "selectedKey", "lectedpage", " selectedFile", " selectedFrame", "namedLine", "selectedRow", "electedpage", "selectedPort", "selectionItem", "lectedKey", "selectedFrame", "selectPage", "lectedPage", "selectedLine", "electedFrame", " selectedpage", "lectedDocument", "selectedToken", " selectedRow", "electedPage", "electionPort", "specifiedPage", " selectedKey", "lectedPath", "matchedPage", "verifiedFile", "lectedToken", "selectedDocument", "electionFrame", "matchedpage", "verifiedPage", "specifiedFrame", "namedPort", "lectedLine", "singlepage", "selectPort", "selectedFile", "selectionFile", "selectPath", "namedFrame", "lectedFile", "verifiedRow", "selectItem"], "page": ["age", "cache", "project", "record", "user", "layout", "collection", "client", "Page", "associated", "me", "force", " Page", "peer", "proxy", "url", "pp", "office", "channel", "current", "to", "menu", "network", "address", "self", "language", "row", "version", "position", "next", "resource", "profile", "result", "object", "output", "pool", "p", "rule", "pointer", "phone", "node", "server", "image", "document", "phrase", "application", "be", "port", "complete", "successful", "message", "pages", "frame", "parent", "line", "policy", "filter", "site", "chain", "window", "group", "table", "form", "number", "block", "log", "created", "point", "view", "display", "instance"], "portalRequest": ["portualEvent", "PortaleQuery", "portpalThread", "terminalRequest", "portpalContext", "portaleAccess", "terminalResponse", "terminalidRequest", "portortalEvent", "portortalThread", "portalerequest", " portalAccess", "portsortalResponse", "portsalrequest", "portortalQuery", " portalCall", "portalityRequest", "portalingAccess", "portpalResponse", "portalidQuery", "portalAccess", " portaleAccess", "portaleApply", "portalQuery", "portortalContext", "PortalContext", "portortalResponse", "portaleContext", "portalidSession", "terminalQuery", " portaleCall", "portralResponse", "portalityFrame", "portaleFrame", " portaleRequest", "portsortalEvent", "portalrequest", "portalingApply", "terminalidSession", "portalSession", " portaleApply", "portualResponse", "portalidResponse", "portralRequest", "terminalSession", "portalaRequest", "portsalRequest", "portortalRequest", "portalEvent", "portpalRequest", "PortalRequest", "portortalrequest", "PortalFrame", "portalResponse", "PortaleRequest", "portsalEvent", "portaleEvent", "portaleThread", "portralSession", "portalThread", "PortaleResponse", "portalCall", "portaleRequest", "PortalThread", "portsortalRequest", "portalityResponse", "portalaApply", "PortaleFrame", "portalingCall", "portalFrame", "PortalResponse", "portaleSession", "portalContext", "portaleResponse", "portaleQuery", "PortaleThread", "portalaAccess", "portralQuery", " portalApply", "portalidFrame", "portalityContext", "PortaleContext", "portaleCall", "portralContext", "portalApply", "portsortalrequest", "portsalResponse", "portalidRequest", "portalingRequest", "portalidContext", "portualrequest", "terminalidQuery", "portualRequest", "terminalidResponse", "PortalQuery", "portalaCall"], "pageProp": ["agePr", "pagePr", "poolProp", "sectionProp", "pageProperty", " pagePr", "pagePred", " pagePro", "sectionZip", "keyProp", "ageProp", "propertyPriv", "pageZip", "pagePro", "propertyDef", "keyComp", "agePred", "propertyProp", " pagePred", "agePro", "profileZip", "propertyPack", "officeProp", " pageDef", "poolPro", "phrasePr", "officePack", "sectionPro", "phraseProperty", "imagePr", "imageProp", "officePriv", "profilePro", " pageProperty", "officeDef", " pageComp", "keyProperty", " pagePriv", "poolZip", "keyPr", "pageComp", "phraseProp", "pageDef", "profileProp", " pagePack", "pagePack", "imagePro", "phraseComp", "profilePred", "imagePred", "poolPred", "pagePriv", "sectionPred"], "possiblePage": [" packedCollection", "possiblyTag", "PossibleUser", "pablePage", "possiblepage", " possibleLine", "pspecifiedPage", "pableTag", "pibleUser", "possiblyPage", "PossiblePage", "possibleUser", "PossiblyChild", "pbableCollection", "packedLine", "pspecifiedpage", "Possiblepage", "pbablePage", "PossibleCollection", "pentialPages", "possibleLine", "packedTag", "possibleTag", "pspecifiedPages", "PossiblyPage", "pableLine", "possibleChild", "possiblyChild", " packedLine", "possiblyUser", "pableCollection", "possiblyCollection", "PossiblyCollection", "pibleCollection", "possiblePages", "PossiblyUser", "PossiblePages", " possibleCollection", "packedCollection", "pibleChild", "pspecifiedTag", " possibleTag", "pbableChild", "piblePage", "pbableUser", "pentialTag", "pentialPage", " packedPage", "packedPage", "pentialpage", "PossibleTag", "PossibleChild", "possibleCollection", " packedTag", "possiblyLine"], "property": ["rue", "rule", "command", "prop", "policy", "header", "operator", "key", "function", "address", "second", "string", "location", "expression", "name", "field", "description", "attribute", "type", "properties", "feature", "definition", "behavior", "trace", "class", "phrase", "owner", "title", "domain", "position", "Property", "metadata", "value", "resource", "service", "integer", "config", "variable", "relation", "object", "message", "frame", "p"], "referer": ["relerer", "defered", "reered", "retered", "relrer", "reeree", "reportrer", "rangeender", "refering", "reerer", "rangeener", "redrer", "Referer", "rangerer", "refered", "referee", "verrer", "rangeerer", "Refrer", "reterer", "refarer", "rerer", "refrer", "rearer", "relering", "reonder", "verrier", "reporterer", "defrer", "refonder", "ferer", "reere", "refrier", "printrier", "frer", "rorrer", "reender", "deferer", "Refere", "printerer", "refere", "rorered", "refener", "requrer", "refender", "diffonder", " refrer", "aferer", "referential", "fering", "reportarer", "printerential", "vererential", "diffrer", " refered", "redere", "differing", "relender", "requonder", "rederer", "reportered", "rederee", "afrer", "relerential", "retarer", "refirect", "reener", "defirect", "requerer", "rorirect", "vererer", "printrer", " refirect", "differer", "afener", "relener", "reerential", "reering", "Referee", "rerier", "requering", "rorerer", "fener", "aferential", "retrer"], "e": ["o", "m", "n", "err", "ception", "h", "eeee", "ee", "error", "oe", "f", "echo", "ge", "me", "eu", "er", "t", "te", "se", "es", "E", "eg", "ae", "g", "event", "r", "de", "a", "x", "eur", "ie", "p"]}}
{"id1": "21092340", "id2": "5436973", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "label": 0, "substitutes": {"addToArchive": ["addToZipZip", "addInArchFile", "addInArchiver", "addToZipiver", "addToHarZip", "addToArchiver", "addInArchive", "addToExZip", "addToArchZip", "addInHarZip", "addToHariver", "addToHarive", "addInArchZip", "addToArchFile", "addToZipive", "addToExiver", "addInHarFile", "addInHarive", "addInHariver", "addToHarFile", "addToExFile", "addToExive", "addToZipFile"], "pod": ["report", "disk", "ad", "project", "policy", "pkg", "cp", "body", "wp", "proc", "post", "od", "volume", "pick", "table", "ods", "pack", "pad", "device", "top", "module", "pc", "Pod", "task", "check", "zone", "start", "job", "point", "spec", "op", "component", "ack", "poll", "message", "archive", "p"], "podArchiveOutputStream": ["podArchiverInputStream", "podArchiveInputSteam", "podArchiveOutputSync", "podArchiveStreamSync", "podArchiveInputForm", "podArchiverInputSync", "podArchiveInputMap", "podArchiveInputStreamer", "podArchiveEntryPoint", "podArchiveOutputstream", "podArchiveResourcestream", "podArchiveResourceContext", "podArchiveInputContext", "podArchiveOutputContext", "podArchiveoutputStream", "podArchiveOUStream", "podArchiveInputstream", "podArchiveMainStream", "podArchiveResourceSteam", "podArchiveMainSteam", "podArchiveMainForm", "podArchiveOutstream", "podArchiveOUForm", "podArchiveStreamForm", "podArchiverOutputstream", "podArchiverInputMap", "podArchiveStreamStream", "podArchiverInputPoint", "podArchiveResourceStream", "podArchiveoutputForm", "podArchiveStreamMap", "podArchiverOutputStreamer", "podArchiveOutContext", "podArchiveOUSync", "podArchiverOutputForm", "podArchiveOutputSteam", "podArchiverOutputContext", "podArchiverOutputSteam", "podArchiveInputStream", "podArchiveOUMap", "podArchiverInputSteam", "podArchiveEntryStream", "podArchiverOutputPoint", "podArchiveOutputForm", "podArchiveoutputSteam", "podArchiveOutputStreamer", "podArchiverOutputStream", "podArchiverInputstream", "podArchiverInputContext", "podArchiveOutputMap", "podArchiverOutputMap", "podArchiveInputPoint", "podArchiveInputSync", "podArchiverInputStreamer", "podArchiveOutputPoint", "podArchiveMainStreamer", "podArchiveOutPoint", "podArchiverInputForm", "podArchiverOutputSync", "podArchiveOutStream", "podArchiveoutputStreamer", "podArchiveOutSteam", "podArchiveEntrySteam"], "filename": ["ename", "key", "NAME", "folder", "string", "location", "directory", "username", "p", "name", "prefix", "FILE", "description", "fn", "latest", "fil", "Filename", "fp", "subject", "ame", "title", "jpg", "upload", "version", "println", "url", "names", "file", "resource", "original", "nm", "nil", "kl", "release", "FN", "binary", "output", "png", "path", "message", "stem", "family", "archive", "txt", "uri"], "source": ["use", "inner", "SOURCE", "body", "proc", "address", "ser", "store", "input", "seed", "image", "template", "sequence", "password", "style", "sql", "context", "src", "sample", "force", "ource", "copy", "info", "Source", "stream", "iterator", "resource", "file", "from", "service", "series", "loader", "start", "spec", "get", "supp", "component", "view", "shell", "select"], "entry": ["link", "record", "book", "data", "key", "obj", "system", "quick", "attribute", "card", "char", "line", "sheet", "row", "cell", "connection", "ment", "cue", "comment", "element", "ace", "enter", "ce", "task", "word", "resource", "file", "se", "log", "ent", "job", "set", "query", "component", "good", "zip", "tmp", "Entry", "channel", "or", "archive", "ie", "ry", "nt"]}}
{"id1": "3024987", "id2": "6457199", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStream_Encoded"], "in": ["inf", "m", "n", "ac", "IN", "l", "it", "inc", " IN", "data", "inner", "cin", "ins", "input", "mm", "ind", "rin", "bin", "up", "In", "ini", "is", "inside", "Input", "cont", "act", "isin", "init", "con", "info", "copy", "iter", "mc", "from", "gin", "local", "mi", "read", "as", "inn", "sin", "r", "din", "i", "p", "source"], "reader": ["ocker", "rl", "data", "inner", "Reader", "ro", "input", "ner", "rar", "parser", "reading", "dr", "req", "rot", "rx", "io", "handler", "writer", "oe", "rise", "red", "row", "phrase", "iter", "er", "iterator", "file", "rr", "driver", "loader", "read", "mr", "query", "Larry", "r", "per", "buffer"], "baout": ["boos", " baot", "yaot", "yaout", "beanOut", "haOut", " bain", "cain", "caOut", "beanout", "baot", "BAout", "haout", "baOut", "BAot", " bares", "yares", "baos", "caout", "BAin", "beanouts", "BAres", "caos", "oaOut", "oaos", "oain", "bain", "beanin", "baouts", "haouts", "boOut", "hain", "bares", "caouts", "oaout", "yain", "boin", "boout"], "out": ["o", "b", "n", "to", "batch", "null", "oss", "ex", "cos", "res", "OUT", "os", "Out", "ou", "io", "cmd", " os", "client", "outer", "sys", "bo", " bout", "conv", "con", "copy", "ao", "t", " output", " Out", "auto", "gt", "update", "all", " outs", " OUT", "OU", "output", "outs", "stable", "net", "cn", "ne"], "bytes": ["reports", "strings", "frames", "objects", "raw", "words", "classes", "blocks", "services", "data", "parts", "users", "seconds", "lines", "pieces", "gets", "des", "bps", "latest", "cells", "les", "its", "issues", "pdf", "files", "bits", "resources", "ites", "videos", "letters", "results", "tes", "names", "comments", "ings", "versions", "ips", "es", "groups", "binary", "faces", "outs", "ies", "values", "bs", "pages", "unks", "units", "Bytes", "gs", "reads", "terms", "vals", "ones"]}}
{"id1": "8062076", "id2": "1371265", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 1, "substitutes": {"updateUser": ["UPDATEAccount", "UPDATEPerson", "UpdateUser", "UpdatePerson", " updateUsers", "updatePerson", "UPDATEUser", "updateAccount", "updateUsers", "UPDATEUsers", "UpdateAccount", "UpdateUsers", " updateAccount", " updatePerson"], "portalUserBean": ["portalPersonBeann", "portalOwnerBelun", "portalUserSoun", "portalUserSoann", "portalUserDean", "portalUserProAN", "portalClientBeon", "portalClientRoans", "portaluserBebean", "portalUserBein", "portalClientRoAN", "portalPersonBean", "portalFileBelan", "portalUserBebean", "portalClientBebean", "portalClientRoon", "portalOwnerBelann", "portalUserBroann", "portalUserBoann", "portalClientBeAN", "portalPersonPeale", "portaluserPean", "portalClientBean", "portalUserBeon", "portalUserbeane", "portalUserRobean", "portalUserBelann", "portalUserBEann", "portalUserProen", "portalUserBroan", "portalOwnerBean", "portalPersonProAN", "portalFileBebean", "portalPersonPeoon", "portalFileBelbean", "portalUserBeoon", "portalUserBEin", "portalClientBAN", "portalUserProann", "portalUserBEans", "portalPersonPean", "portalUserBelbean", "portalUserObjectAN", "portalUserbean", "portalUserBun", "portalUserPeann", "portaluserBeAN", "portalUserBeale", "portalOwnerBeann", "portalUserBan", "portaluserPeAN", "portalFileBean", "portalUserBeen", "portalUserRoAN", "portalFileBeann", "portalUserPean", "portalUserBEon", "portalClientBeans", "portalUserBbean", "portalClientBann", "portalUserBeane", "portalUserBeAN", "portalPersonBeen", "portalClientBeann", "portalOwnerBeun", "portalClientBan", "portalUserBEAN", "portalUserProale", "portalUserbebean", "portalUserBelun", "portalClientRoan", "portalUserProbean", "portalUserBoan", "portalUserBans", "portalUserBoen", "portalUserObjectale", "portalUserPebean", "portalPersonBeoon", "portaluserBean", "portalUserRoane", "portalUserDebean", "portalUserBeann", "portalUserBelan", "portalUserPeoon", "portalUserBAN", "portalPersonProen", "portalUserDeAN", "portalUserPeAN", "portalOwnerBelan", "portalUserbeann", "portalClientBbean", "portalPersonPeann", "portalUserBon", "portalUserProan", "portalPersonBeale", "portalUserDeann", "portalFileBeane", "portalFileBelann", "portalFileBelane", "portalUserBeun", "portalUserBann", "portalPersonPein", "portalUserObjectan", "portalUserRoon", "portalUserBEoon", "portalUserPeen", "portaluserPebean", "portalPersonBeAN", "portalUserPeale", "portalUserRoan", "portalPersonProann", "portalUserRoann", "portalUserBoAN", "portalPersonPeAN", "portalUserPein", "portalUserBEan", "portalUserBeans", "portalUserBelane", "portalUserSoan", "portalPersonProan", "portalUserBroin", "portalUserBrooon", "portalPersonBein", "portalUserRoans"], "authSession": ["selectSite", "authsession", "selectSession", "authorState", "aptSite", "authUser", "authorSite", "authClient", "authorSession", "selectClient", "AuthSession", "authorClient", "uthUser", "aptSession", "authSite", "aptClient", " authUser", "uthSession", "AuthUser", "uthsession", "Authsession", "selectState", "authState", "aptState", " authsession"], "dbDyn": ["dbBindyn", " dbDys", "webDsyl", "webDyn", " dbDync", "DbDoyn", "dbDeyn", " dbDsyn", "dbDoyp", "dbGyp", "dbDbyn", "dbDsynam", " dbDyp", "dbDoont", "dbSynam", "datCYN", "webDyl", "DbDYN", "DbDoyd", "webDynam", "dlCreateyn", "dbDuys", " dbDoys", "dbDuont", "dbNys", " dbDont", "dbDyd", "dbCYN", "DbDoy", "dlDynam", "datCys", "dbDync", "dbDys", "dbDoy", "datCyn", "dbCont", "dbFyn", "dbSyd", "datDyn", "dbDoyd", "dbdys", "dbBindily", "dbDsyn", "dbFYN", "dbNy", "datDyp", " dbDoont", "datDYN", "dbDoyl", "dbDesyn", "dbDuyn", "dbFy", "dbCys", "DbDyn", "dbDynam", "dbSYN", "dbDoynam", "DbDyd", "webDsynam", "datCyp", "dbDyl", "dbNync", "dlDyn", "webDsyn", "dbDoys", "dbCyp", "dbdy", "dbDoily", "dbDeYN", "dlCreateily", "dbDy", "dbDsyl", "dbdync", "dbDYN", "dbDsys", "dbDoYN", "dbSyl", "DbDoYN", "dbCreateynam", "datDys", "dbFyd", "dbDont", "dbGYN", "dbFys", " dbDoyn", "dbDoyn", "dbBindynam", "DbDy", "dbDbyp", "dbDily", "dbDyp", "dbNyn", "dbFyp", " dbDoYN", "dlDily", "dbDbys", "dbSy", "dbSyn", "dbDuYN", "webDsys", "webDys", " dbDYN", "dbDbYN", "dbCyn", " dbDy", "dlCreateynam", "dbCreateily", "dbGyn", "dbGys", "dbSys", "dbSsyn", "dbCreateyn", "dbdyn"], "ps": ["css", "pl", "ip", "ks", "pr", "pos", "pt", "js", "ws", "ops", "qs", "pd", "pes", "wp", "points", "pe", "pa", "res", "PS", "ress", "posts", "als", "itions", "rs", "jp", "fps", "ples", "its", "vs", "tp", "eps", "fp", "sp", "ys", "cs", "ptr", "pers", "s", "mp", "aps", "ips", "pres", "ats", "fs", "pp", "sts", "ts", "ups", "gres", "params", "op", "sol", "Ps", "amps", "stats", "ims", "pps", "ies", "ports", "ils", "bs", "pse", "ds", "gs", "p"], "sql": ["print", "plan", "pr", "csv", "socket", "serial", "js", "ll", "ws", "xml", "qs", "pel", "rel", "spr", "inv", "statement", "string", "sal", "seed", "ql", "expression", "status", "template", "prefix", "ss", "details", "fn", "ssl", "dl", "sv", "eps", "nl", "sys", "sp", "wal", "ls", "ln", "sn", "url", "s", "series", "log", "sl", "SQL", "query", "spec", "sol", "scl", "repl", "stats", "sb", "shell", "join", "sq"], "idList": [" idlist", "idL", "idslist", "IdLIST", "infoList", "uidLIST", "infolist", " idLIST", "infoL", "infoLIST", "Idlist", "idLIST", " idL", "idsLIST", "uidList", "uidlist", "idsList", "idlist", "idsL", "IdList"], "num": ["multi", "dim", "zero", "mon", "np", "dat", "node", "sum", "proc", "nam", "desc", "no", "umber", "index", "NUM", "alph", "begin", "non", "nom", "number", "un", "ret", "snap", "um", "mem", "unit", "conv", "note", "den", "nn", "draw", "con", "tim", "fac", "dec", "gre", "cu", "mn", "nu", "mat", "prim", "nm", "coord", "tu", "hum", "cal", "Num", "nb", "done", "mult", "orig", "eng", "hom"], "i1": ["I1", "li61", "I61", "I2", "i61", "li2", "li0", "li1", "i2", " i2", "i0", " i61", " i0", "pi1", "I0", "pi0", "pi61", "pi2"]}}
{"id1": "18962382", "id2": "10795866", "code1": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 0, "substitutes": {"connect": ["submit", "ping", "link", "conn", "use", "ssh", "create", "dial", "respond", "fit", "connected", "process", "login", "Connect", "open", "connection", "build", "write", "init", "setup", "con", "request", "sync", "add", "construct", "establish", "log", "start", "ready", "config", "read", "close", "set", "run", "pen", "bind", "join", "select"], "IOException": ["IOStatus", "ioException", "NetworkException", "ioError", " IOError", "ioStatus", "NetworkError", " IOStatus", "NetworkStatus", "IOError"], "LoginFailException": ["LoginFailError", " LoginFailInstance", " LoginfailError", " LoginfailEx", " LoginFailError", "LoginPassInstance", "LoginfailError", "LoginPassError", " LoginfailException", "LoginPassException", "LoginfailInstance", "LoginFailInstance", "LoginFailEx", " LoginFailEx", "LoginfailException", "LoginPassEx", "LoginfailEx"], "client": ["http", "ci", "conn", "list", "command", "socket", "phone", "node", "session", "server", "key", "obj", "controller", "call", "store", "user", "window", "Client", "response", "c", "secure", "bolt", "cell", "channel", "bo", "connection", "co", "application", "het", "contact", "force", "con", "and", "cli", "proxy", "url", "resource", "local", "config", "qualified", "close", "cl", "console", "control", "util", "remote"]}}
{"id1": "7872659", "id2": "19810820", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndVideoindexfile", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndVideoindexTable", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndVideoIndexFiles"], "completePath": [" completeDirectory", "totalPod", "pleteRoot", "pletionDir", "pleteScript", "fullPod", "completeLocation", "pletionProject", "completeDirectory", "pletionNow", "completeNow", "CompleteDir", "totalPath", "CompletePath", "CompleteProject", "COMPLELog", "pleteDir", "completeDir", "completeProject", "pletePod", "pleteProject", "pletionPath", "COMPLEPath", "COMPLEDir", "completeScript", "fullLocation", "CompleteLocation", " completesPath", " completesDirectory", "completeRoot", " completesDir", "CompleteScript", "pleteLog", "totalLocation", " completeDir", "CompleteNow", "totalRoot", "completePod", "CompleteDirectory", "fullPath", "pleteNow", "pleteLocation", "fullRoot", "COMPLEScript", " completeLocation", " completesLocation", "completeLog", "CompleteLog", "pletePath"], "masterFile": ["completefile", "completeFile", "managerFile", "MasterFilename", "masterPath", "currentName", "currentFile", "managerPath", " masterPath", "MasterName", " masterFilename", "currentfile", "managerfile", "MasterPath", "masterfile", "managerFilename", "completeName", "MasterFile", "Masterfile", "masterFilename", " masterfile", "currentPath", "masterName"], "CustRatingFileName": ["CustRatedfileSet", "CustRankFileName", "CustRatingTableNames", "CustRatingFilenameSet", "CustRatedFileSet", "CustRankFilesName", "CustRatedFileNames", "CustRatingFieldInfo", "CustRatedFileName", "CustRatingFileType", "CustRankFileInfo", "CustRatedfileName", "CustRatingFilenameType", "CustRatingFilesType", "CustRankFilesType", "CustRatingFileSet", "CustRatingfileType", "CustRatingFilesname", "CustRatingTableType", "CustRankFilename", "CustRankFilesInfo", "CustRatedfileType", "CustRatingFilenameName", "CustRatingTableSet", "CustRatingFilename", "CustRatingFieldType", "CustRatingfileNames", "CustRatingFieldname", "CustRatingFileInfo", "CustRatedfileNames", "CustRatingFieldName", "CustRatingFilesInfo", "CustRatingFileNames", "CustRatedFileType", "CustRatingTablename", "CustRankFilesname", "CustRatingTableName", "CustRankFileType", "CustRatingfileSet", "CustRatingFilesName", "CustRatingFilenameNames", "CustRatingTableInfo", "CustRatingfileName"], "MovieIndexFileName": ["MovieIndexfileName", "MovieIndexFieldType", "MovieindexfileName", "MovieIndexfileNumber", "MovieIndexFileNumber", "MovieIndexFileKey", "MovieindexFileKey", "MovieIndexTableNames", "MovieindexfileType", "MovieIndexTableKey", "MovieindexfileNames", "MovieIndexFileType", "MovieIndexfileKey", "MovieindexfileKey", "MovieIndexFieldName", "MovieIndexFILEType", "MovieIndexfileType", "MovieIndexfileNames", "MovieindexFileType", "MovieindexfileNumber", "MovieIndexFILENumber", "MovieindexFileNumber", "MovieIndexFILEName", "MovieindexFileName", "MovieIndexFileNames", "MovieIndexTableType", "MovieIndexFieldKey", "MovieIndexTableName", "MovieindexFileNames", "MovieIndexFieldNames", "MovieIndexFILENames"], "inFile": ["infile", "INC", "inF", "localC", "localFile", "outfile", "localfile", "INFile", "inFILE", "outC", "INfile", " infile", "localFILE", " inF", "INF", "outF", " inFILE", "outFile", "INFILE"], "inC": ["inCS", "inF", "inL", " inG", "outG", "iC", "inputF", " outCL", "iR", "inputFile", " outF", "intCI", "iCS", " inCI", "outCL", "intCS", "inCL", "outC", "outL", "iCI", " outL", " inF", "intC", "inputC", "outF", "inCI", "intR", "inR", " outC", " inCL", "inG", "outFile", "inputG", " inR", " inL", " inCS"], "outFile1": ["outChannel9", "outputFile1", "outFILE6", "outFile6", "outPageOnce", "outFileOne", "outfile0", "outPage1", "outfile1", "outPage9", "outFILE1", "outFILE0", "outChannel1", " outfile1", "outputPageOne", "outChannelOne", " outfile6", "outputFileOne", "outFileOnce", "outFILE2", " outFile0", "outPageOne", "outFile0", "outputFile9", "outputPageOnce", "outfile2", "outputFileOnce", " outfile0", "outputPage1", " outfile2", "outFile9", "outChannelOnce", "outPage2", "outPage6", " outFile6", "outputPage9", "outfile6", "outPage0"], "outC1": ["inFile2", "outR2", "outCB3", "outFileOne", "outFile3", "outP3", "outCB0", "inC3", "inC0", "outc2", "outR3", "outC3", "outC0", "outROne", "outP2", "inCOne", "inC1", "outCB1", "inC2", "outP1", "outPOne", "outc3", "outc1", "outR1", "outCB2", "inFile1", "outc0", "outCOne", "inFileOne", "inFile3"], "outFile2": ["outFile02", "outTable3", "exChannel2", "outTable02", "outF1", "outFile3", "outfile0", "outfile1", "outChannel0", "outfile02", "outTable2", "outChannel1", "exChannel0", "outFileTwo", "outF2", " outFileTwo", "exChannel1", "outF3", "outFile0", "exChannel3", "outfile2", " outFile02", "exFile3", "outChannel2", "exFile1", "exFile2", "outChannel3", "exFile0", " outFile3", "outTableTwo", "outfile3", "outfileTwo", "outF0"], "outC2": ["outR2", "allB2", "outSTwo", "allC3", "OutC1", "outE1", "outMTwo", "outE2", "outR4", "outR3", "outC3", "outM22", "outM3", "outE4", "OutR3", "allB22", "OutC3", "OutC4", "outCTwo", "OutR2", "outS3", "outB2", "outE3", "allC2", "outBTwo", "OutC2", "outM2", "outS22", "OutR1", "outB22", "OutR4", "outS2", "outC4", "allCTwo", "allBTwo", "outR1", "outB3", "allB3", "outC22", "allC22"], "fileSize": [" fileCount", "FileSIZE", "fileSIZE", "byteSize", "baseName", "FileLength", "fileLength", "issueLength", " fileSIZE", " fileLength", "fileCount", "byteName", "FileCount", "FileSize", "issueName", " fileName", "FileName", "baseCount", "baseSIZE", "byteLength", "baseSize", "issueSize", "issueSIZE", "byteSIZE", "fileName"], "totalNoDataRows": ["totalNodataRoles", "totalNoDataSlows", "totalNodataRecoles", "totalNoDataBoles", "totalNoDataRecoles", "totalNodataRocks", "totalNoDataBows", "totalNoDataRoles", "totalNodataRues", "totalNoDataRues", "totalNoDataBocks", "totalNoDataSloles", "totalNoDataRecocks", "totalNoDataRocks", "totalNoDataSlocks", "totalNodataRecows", "totalNoDataRecows", "totalNodataRecocks", "totalNodataRows", "totalNoDataRecues", "totalNoDataBues", "totalNodataRecues", "totalNoDataSlues"], "mappedBuffer": ["mapperbuffer", "MappedData", "matchedBuffer", "mapedFB", "mapedCallback", "mmappedbuffer", "mappedCounter", " mappedBuff", " mapedBuff", "mapperBB", "matchedQueue", "MapperBuff", "mappingQueue", "mmappingBuffer", "mattedBB", "mappedQueue", " mappedCounter", " mappedCallback", "mapperCounter", " mapedFB", "MapperBB", "mmappingQueue", "mressedBuff", "mressedFB", "matchedCounter", "mapperBuff", "mappedbuffer", "mmappingBuff", "mattedBuffer", "mappingbuffer", "mappedFB", "mmappedBuffer", "MapedBuffer", " mapperBuff", "maphCallback", "MappedBuffer", "mapedBuffer", " mapperQueue", "maphBuff", "mapperQueue", " mapedCallback", "mappingBuffer", "mapperBuffer", "mapedBB", "MappedBuff", "mapBuff", "mappingData", "mappingBuff", "mapedbuffer", "mmappedBuff", "MappedBB", "mappedData", "mapedBuff", "mmappedQueue", "MapperBuffer", "mressedCallback", "mmappingbuffer", "mappedBB", "mapBuffer", "mappedBuff", "mappingBB", "MapedBB", "MapedBuff", "mressedBuffer", "mapedData", " mapperBuffer", "maphBuffer", "maphFB", "mapedQueue", "mattedData", " mapedBuffer", " mappedQueue", " mappedFB", " mapperCounter", "mapBB", "mappedCallback", "MapedData", "matchedBuff", "mattedBuff", "mappingCounter"], "startIndex": ["StartIndex", "firstPosition", "initPosition", "startInd", "currentPos", "endPage", "StartInd", "currentIndex", "firstInd", "StartIter", " startPage", " startPosition", "startPosition", " startIter", "firstindex", " startInd", "endIndex", "StartPosition", "initindex", "StartPoint", "StartPage", "Startindex", " startPos", "startPos", "initIndex", " startindex", "firstIndex", "currentPoint", " startPoint", "startIter", "StartPos", "currentPosition", "startPage", "startPoint", "startindex", "endIter", "endPosition"], "count": ["n", "cast", "batch", "code", "list", "continue", "ctr", "num", "more", "amount", "sum", "found", "call", "user", "index", "total", "process", "ind", "limit", "state", "status", "c", "name", "type", "core", "number", "act", "first", "force", "mount", "con", "Count", "info", "size", "counter", "check", "next", "add", "coll", "depth", "last", "category", "now", "start", "result", "max", "cloud", "created", "ount", "id", "find", "order", "conf", "page", "length", "i", "current"], "currentMovie": [" currentMusic", "activeMovie", "currentPlayer", "reportedMusic", "activePlayer", "reportedImage", "firstDate", "firstMovie", "firstMouse", "currentlyMovie", "reportedMouse", " currentMedia", "currentMouse", "currentImage", "currentMusic", "presentHero", "reportedHero", "firstMonster", "currentMonster", "firstVideo", "primaryHero", " currentHero", "currentlyHero", "primaryDate", "currentlyDate", "reportedMedia", "firstHero", " currentVideo", "currentSpider", "currentlySpider", "currentHero", "currentVideo", "presentMovie", "reportedMovie", "primaryVideo", "currentlyMonster", "firstMedia", "currentlyPlayer", " currentSpider", "primaryMovie", "currentDate", "currentMedia", " currentPlayer", " currentMonster", "presentImage", "activeVideo", "currentlyVideo", "presentMusic", " currentImage", " currentMouse", "activeSpider"], "movieName": ["MovieName", "movieGroup", " movieNAME", "MovieType", "ovieNAME", "oviename", "ovieGroup", "movieNAME", "mpegname", "mpegName", "filmType", "filmTitle", "filmName", "httpName", "monsterNAME", "ovieName", "Moviename", "httpNAME", " movieTitle", "mpegGroup", " movieType", "monstername", "movieTitle", "httpname", "moviename", "mpegNAME", "filmNAME", "movieType", "monsterName", "filmGroup", "MovieTitle", " moviename", "filmname"], "customer": ["customizer", "customorder", "stickity", "stickER", "Customity", "CustomER", "Customer", "ustomorder", "Customizer", "stickizer", "ustomer", "ustomER", "developer", " customER", " customorder", "customER", "customator", "developator", "sticker", "ustomator", "developity", " customator", "customity", "developizer", "developER", "developorder"], "rating": ["ping", "setting", "scale", "playing", "scoring", "reporting", "ating", "user", "reading", "term", "boarding", " Rating", "error", "ranking", "attribute", "type", "card", "strength", "core", "rate", "average", "rage", "rated", "rat", "weight", "review", "score", "saving", "format", "Rating", "heading", "testing", "option", "credit", "translation", "tag", "rank", "having"], "outBuf1": ["outDuf1", "outBuf18", "outBuc5", "outBBuff11", "outDbuf11", "outRuf1", "outBfx1", "outBuffy1", "outBuf3", "outRuf18", "outBool1", "outBufOnce", "outBbufl", "outBbuf5", "outBulp1", "outBuf5", "outBuff0", "outBbuf18", "outBdf3", "outBool3", "outBbuf3", "outRbuf1", "outDuf0", "outBbufone", "outBooll", "outBufOne", "outRufOne", "outBlf3", "outBBuff3", "outDuf3", "outBuffy0", "outBuffyl", "outRuf3", "outBlf1", "outBlf0", "outBfx3", "outBfx0", "outBlf2", "outBurg1", "outBuf11", "outBbuf0", "outBbufOne", "outBufl", "outBbufOnce", "outBdf1", "outBulp64", "outBfx11", "outBuff3", "outBbuf64", "outDuf11", "outBuf64", "outBdfOnce", "outBbuf11", "outBurg18", "outBuff2", "outBBuff0", "outBucOne", "outBuc1", "outRbuf18", "outBuffyone", "outBoolone", "outBulpOnce", "outRbuf3", "outRbuf0", "outBuff1", "outRbuf5", "outRuf0", "outBdf64", "outDbuf1", "outRbufOne", "outRuf5", "outBBuff1", "outBufone", "outDbuf0", "outBuf0", "outBuffy18", "outBurg3", "outBbuf1", "outDbuf3", "outBulp3", "outBuc0", "outBuffy3", "outBurg0"], "outBuf2": ["outBuffyTwo", "outFbuf02", "outBbuf42", "outMbuf1", "outBfgTwo", "outBfx1", "outBbuff1", "outMuf3", "outBbuf15", "outMbuf15", "outBuff4", "outBuf3", "outBbuff2", "outMuf15", "outBuff2", "outBuffy4", "outFuf4", "outBfx3", "outFuf2", "outBfg2", "outBuf4", "outMbuf3", "outMbuf2", "outFbuf2", "outFuf02", "outBfx2", "outBfg4", "outBbuf1", "outBuf42", "outBbuff4", "outFufTwo", "outBuf15", "outBuffy02", "outBbuff15", "outBufTwo", "outBbufj", "outBfx15", "outBbuff3", "outMuf1", "outBbuf4", "outFbufTwo", "outBuffTwo", "outBfg02", "outBuf02", "outBbuff42", "outBbuf3", "outBuffy3", "outBuffy2", "outBufj", "outBbuf02", "outBbuffj", "outBuffj", "outBbufTwo", "outFbuf4", "outBuff42", "outBuff1", "outMuf2", "outBbuf2", "outBuff3"], "endOfIndexFile": ["endOFindexLine", "endOfErrorF", "endofindexFiles", "endOfPositionTable", "EndFile", "endOfindexfile", "endofindexFile", "endofindexTable", "endOfPositionFiles", "endOfIndFile", "endOfErrorfile", "endOfIndfile", "endOfPositionfile", "endofindexfile", "endOfindexFiles", "endOfIndexFiles", "endFile", "endofIndexFile", "endOfindexF", "endofIndexFiles", "endOfIndLine", "endOFindexfile", "endofIndexTable", "endOfindexTable", "endOfErrorFiles", "endOfIndexTable", "endedFile", "endOFIndexLine", "endOfPositionFile", "endofIndexF", "endOfIndexLine", "endofindexF", "endOFindexFile", "endOFIndexfile", "endOFIndexFile", "endofIndexfile", "endOfindexFile", "endOfIndexF", " endFile", "endOfErrorFile", "endOfIndexfile", "endOfindexLine"]}}
{"id1": "9550506", "id2": "16572931", "code1": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 0, "substitutes": {"cookieString": [" challengeBytes", " cookieBytes", " cryptHash", " challengeHash", " challengeStr", " cryptStr", " challengeByte", " cryptByte", "cookieStr", " cookieStr", "cookieHash", "cookieBytes", "cookieByte", " cookieHash", " cookieByte", " cryptBytes"], "url": ["browser", "http", "web", "l", "ll", "address", "el", "hl", "loc", "www", "ul", "mail", "ssl", "dl", "api", "ur", "domain", "mount", "https", "URL", "gl", "file", "log", "home", "Url", "sl", "get", "host", "lr", "addr", "path", "util", "remote", "ls", "uri"], "ip": ["http", "arp", "pkg", "cp", "skip", "address", "p", "mac", "IP", "tip", "name", "loc", "iv", "chip", "secure", "prefix", "password", "email", "client", "api", "sp", "domain", "origin", "port", "ips", "id", "host", "zip", "addr", "app", "path", "ep", "net", "i", "et", "uri"], "md": ["d", "m", " mt", " ms", "mg", " cmd", "ld", " sd", "cd", " Md", "bd", "pd", "hd", "grad", "MD", " mm", "mm", "det", "od", "dr", "ind", "pm", " mc", "cmd", "dd", " MD", "red", " ma", "der", "df", "ng", " sm", "met", "mem", " dd", " m", "ms", "nd", "dh", "td", "mc", "mt", "ma", "mn", "managed", "metadata", "ke", "mp", "mk", "sm", "del", "sd", "def", "hm", "dm", " mo", "sha", " del", "nt"], "hash": ["uh", "cache", "amd", "sh", "shadow", "bh", "hed", "ash", "her", "magic", "html", "ho", "sum", "h", "hd", "has", "key", "kernel", "rh", "index", "total", "mac", "checked", "Hash", "password", "ref", "sam", "sample", "check", "mask", "this", "tag", "message", "sha", "sq"]}}
{"id1": "18374478", "id2": "23402240", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"updateUser": ["updateuser", " updateuser", "uploaduser", " updateCommon", "setUse", "updateByte", "uploadUse", "insertUsers", "setUser", "updateUse", "insertAccount", " updatePer", "putUsers", " updateUSER", "uploadUsers", " updateMe", "uploadUSER", "geuser", "makeUser", " updateAccount", "updateUSER", "putCommon", "putuser", "updateCommon", "putByte", "makeOne", " updateUsers", "makeByte", "uploadMe", "updateMe", "makeUsers", "updateOne", "gePer", "putUser", "putUse", "updateAccount", "UpdateAccount", "UpdateUsers", "updateGroup", "UpdateGroup", " updateUse", "updatePer", "geUse", "putMe", "geUser", " updateByte", "putUSER", "uploadCommon", "insertGroup", "uploadUser", "UpdateUser", " updateGroup", "putOne", "setPer", "insertUser", "updateUsers", " updateOne", "setuser"], "user": ["report", "v", "rule", "use", "record", "usage", "data", "key", "User", "sum", "users", "post", "re", "username", "plugin", "token", "base", "name", "used", "admin", "up", "table", "usa", "password", "char", "form", "author", "by", "client", "ver", "USER", "row", "device", "uid", "other", "usr", "u", "valid", "connection", "me", "owner", "ud", "module", "version", "info", "word", "add", "resource", "file", "profile", "account", "result", "job", "part", "config", "update", "content", "object", "get", "host", "order", "per", "this", "message", "display", "util", "instance", "item"], "conn": ["pg", "pkg", "rel", "Conn", "req", "Connection", "c", "jp", "cf", "client", "bo", "org", "act", "wd", "nc", "iw", "con", "pas", "connect", "com", " con", "t", "cm", "dt", "n", "link", "pt", "priv", "cp", "ctx", "wr", "exec", "open", "cert", "cmd", "die", "comm", "pub", "cb", "coll", "handle", "typ", "addr", "pool", "nt", "socket", "gate", "oss", "err", "yn", "cat", "oc", "ann", "resp", "cons", "ct", "cont", "enc", "ssl", "ch", "info", "cur", "port", "close", "conf", "db", "ns", "out", "bind", "apt", "gen", "ctr", "lang", "wp", "obj", "res", "dc", "col", "tp", "connection", "co", "mc", "ce", "mt", "gc", "log", "quote", "cfg", "net", "cc", "cn", "conv", "Con", "wn"], "autoCommit": [" autoComme", "autoCompmit", "autoQue", " autoCommend", "AutoCommit", "autoCollmit", "autoQumit", "autoCollcommit", "AutoDebort", "autoComort", " autoCompit", "autoCommcommit", "autoCollit", "anoCommit", "autoComcommit", "autoCommlate", "autoActivlate", "autoRemit", "anoCommlate", "autoDebcommit", "autoQuend", "autoActivort", "AutoDebcommit", " autoCompend", "autoRemend", "anoCommort", "autoCompend", "AutoCommort", "autoActivmit", "autoCommort", "autoComlate", "autoCommend", "autoComme", "autoCompe", "anoActivort", "autoComit", "autoDebmit", "autoQuit", "AutoDebmit", "autoDebort", "autoActivit", "AutoCommcommit", " autoCompmit", "AutoCommmit", "autoCollort", "anoCommmit", "AutoDebit", "autoCommmit", "anoActivit", "autoRemmit", "anoActivmit", "autoDeblate", " autoCompe", "autoCompit", "autoReme", "autoDebit", " autoCommmit", "anoActivlate"], "deleteRoles": ["deleteRules", "detailRanguages", " deleteResols", "deleteResles", "deleteGols", "detailCorroups", "deleteNroups", "deleteToles", " deleteResroups", "detailRoles", " deleteRroups", "deleteRanguages", "deleteGroups", "deleteCorules", " deleteRols", "deleteRols", "deleteNoles", "deleteRles", "deleteranguages", "deleteRoids", "deleteNles", " deleteResoles", "deleteGoles", "deleteCoroles", "deleteRadols", "deleteCorroups", "deleterroups", "detailCoranguages", "deleteRadoles", " deleteRles", "detailCorules", "deleteResoles", " deleteRoids", "deleteroles", "deleteCoranguages", "detailRules", "deleteRadoids", "deleteResroups", "deleteEroles", "deleteErles", "deleteEroids", "deleteRadles", "deleteGles", " deleteResles", "deleteTanguages", "detailCoroles", "deleteTules", "detailRroups", "deleteResoids", "deleteNols", "deleteErols", "deleterules", "deleteResols", "deleteTroups", "deleteRroups", " deleteResoids"], "insertRoles": ["insertReploles", "insertRows", "insertRobles", "stepRodes", "insertPodes", "insertGoles", "insertCodes", "insertLodes", "insertRodes", "stepRiders", "deleteRodes", "InsertRhips", "insertGroups", "insertLoles", "insertRepliders", "stepRoles", "stepReplodes", "deletePoles", "insertResodes", "insertRroups", "insertRsrots", "insertRights", "insertReplroups", "sequenceRles", "deleteRights", "sequenceRels", "insertResoles", "insertRsles", "insertLiders", "insertRobels", "insertNoles", "stepRroups", "insertGodes", "insertRhips", "insertRels", "deletePodes", "stepReplroups", "insertResles", "insertPoles", "sequenceRrots", "insertReplodes", "sequenceRobles", "insertPows", "insertColes", "insertRsels", "insertRobrots", "sequenceRobels", "insertRoboles", "deleteRows", "deletePows", "insertReships", "insertLroups", "stepRepliders", "insertPights", "sequenceRoles", "sequenceRoboles", "insertRsoles", "InsertRles", "deletePights", "sequenceRobrots", "InsertRoles", "insertCows", "insertNodes", "insertRrots", "insertNles", "insertNhips", "insertRles", "insertRiders", "insertCights", "InsertRodes", "insertGiders", "stepReploles"], "role": ["entry", "rule", "tro", "ule", "rl", "node", "rel", "pe", "ro", "label", "oval", "family", "aco", "hero", "type", "password", "char", "col", "feature", "cell", "row", "country", "rice", "block", "peer", "ce", "hole", "zone", "le", "word", "resource", "te", "slave", "profile", "range", "office", "part", "ole", "def", "Role", "relation", "right", "r", "tag", "rol"]}}
{"id1": "22752444", "id2": "3536332", "code1": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"encrypt": [" encode", " encryption", "Encode", "decryption", "encrypted", "encryption", "decrypted", "Encryption", "Encrypt", "Encrypted", "decrypt", "decode", " encrypted", "encode"], "plainText": ["messageTEXT", "ainTEXT", "ainEntity", "plainObject", "plainContent", " plainContent", "plainEntity", "plainHTML", "ainText", "protectedHTML", "publicObject", " plaintext", "plainCode", "protectedText", "plaintext", " plainCode", "messagetext", "publicEntity", "ainObject", "publicTEXT", "ainCode", "publicContent", "messageContent", "protectedTEXT", " plainTEXT", "plainTEXT", " plainEntity", "protectedCode", "ainHTML", "publictext", "messageText", "publicText", " plainHTML", " plainObject"], "hash": ["report", "shadow", "sh", "cache", "ash", "html", "tr", "header", "data", "key", "sum", "h", "test", "filename", "has", "user", "input", "rh", "total", "response", "mac", "array", "chip", "cert", "Hash", "password", "flash", "json", "ah", "dig", "score", "title", "hex", "search", "handle", "map", "result", "log", "id", "proof", "alert", "message", "temp", "tag", "sha", "height", "text"], "md": ["d", "m", "amd", "mg", "ad", "cd", "ld", " Md", "mand", "bd", "h", "pd", "hd", "grad", "MD", "mm", "det", "od", "ind", "pm", "mac", "med", " mc", "mod", "cmd", "dd", "der", "df", "ng", " m", "sam", "ms", "nd", "dig", "dh", "mc", "mt", "mn", "metadata", "managed", "rm", "mp", "mk", "sm", "del", "sd", "mo", "dm", "di", "esm", "mb", " mo", "ds", "sha"], "raw": ["shared", "n", "partial", "rew", "sh", "data", "full", "known", "rendered", "custom", "unsigned", "input", "clean", "aw", "available", " Raw", "Raw", "array", "load", "c", "unknown", "random", "pack", "buf", "json", "row", "cooked", "valid", " RAW", "box", "bytes", "hex", "value", "original", "wrap", "read", "RAW", "all", "content", "message", "out", "text"]}}
{"id1": "7044153", "id2": "5836744", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 1, "substitutes": {"sendExceptionToServer": ["sendErrortoClient", "sendExceptionTOServer", "sendExceptionTOHost", "sendExceptiontoClient", "sendExceptionTOClient", "sendErrorToServer", "sendExceptionToClient", "sendErrortoServer", "sendExceptionToHost", "sendExceptiontoServer", "sendErrorToHost", "sendErrorToClient", "sendErrortoHost", "sendExceptiontoHost"], "server": ["v", "code", "null", "address", "test", "site", "ser", "store", "string", "base", "env", "description", "password", "email", "client", "localhost", "ver", "channel", "Server", "serv", "version", "port", "value", "service", "erver", "host", "remote"], "ex": ["nex", "except", "rex", "err", "it", "ception", "Ex", "test", "obj", "el", "wx", "re", "ext", "pex", "one", "ry", "rx", "exc", "xc", "error", "expl", "aux", "eas", "or", "any", "e", "lex", "none", "example", "hex", "com", "Exc", "exp", "tx", "ix", "exit", "an", "exe", "event", "exclusive", "ic", "fail", "x", "EX", "ox", "Exception"], "config": ["cache", "debug", "settings", "figure", "Configuration", "input", "param", "env", "c", "cert", "password", "form", "Config", "ct", "context", "auth", "rc", "fig", "service", "log", "params", "content", "cfg", "conf", "control", "channel", "text"], "prob": ["prbj", "Probe", "probj", "Prob", "probes", " prb", "prbe", " prbes", "Probes", " prbe", "Probj", "probe", "prb", " prbj", "prbes"], "dataSB": ["debugSF", "defSB", "windowSN", "relBB", " dataQB", "joinSF", "dataSW", "ataSN", "ataNB", " dataBP", "cacheBS", "dataSF", "divBS", "contentSN", "relationBS", "valueBB", "imageSN", "ataSL", "imageBP", "jsonSF", "windowSF", " dataSW", "keySL", " dataSN", " dataBW", "ataSR", "dataBW", "dataQB", "cacheBW", "datMB", "mapSB", "defGB", "dataSw", "divNB", "partialSB", "dataHB", "jsonSw", "dataMB", "ataSA", "imageSL", "imageSw", "divBW", "ataSW", " dataRB", "mapBS", "partialGB", "reasonSF", "relationSF", "DATASW", "imageBS", "dataBP", "nextBB", " dataNB", "cachesb", "relationMB", " dataSA", "dateBu", "ataBu", " dataGB", "ataBP", "relBS", " dataHB", "imageSR", "listsb", "dataGB", "keyBS", "contentBS", "DATASB", "contentSR", "joinSB", "dateQB", "relationSB", "joinsb", "windowBS", "keySB", "reasonSB", "nextSB", "listBB", "cacheBB", "cacheSB", "nextBS", "mapSL", "debugRB", "cacheSM", "mapSN", " dataSL", " dataSF", "relSB", "datWB", "reasonSW", "debugBB", " dataSM", "imagesb", "listSF", "relationQB", "datSB", "ataWB", "divSquare", "mapSF", "relationSL", "relationSN", "ataBS", "ataBB", "listSI", "resourcesb", "partialSL", "ataSF", "joinWB", "partialBB", "dataSR", "listMB", "imageSB", "listSB", "relationBB", "DATASF", "debugSB", "dataSM", "divSB", "divSN", "windowSL", " dataBS", "dataWB", "nextSF", " dataSw", "ataSB", "jsonSB", "cacheSF", "resourceSI", "dataBS", "mapGB", "mapHB", "dataSI", " dataSquare", "divSF", "keyBB", "windowSB", "dataSL", "relationNB", "joinSL", " dataSI", "imageSF", "resourceSF", "imageBB", "divBB", "ataEB", " dataEB", "atasb", "contentNB", "valueSB", "ataQB", "datasb", "dataBB", "dataSA", "reasonBS", "dataSN", "jsonsb", "nextQB", "dataSquare", "relationRB", "imageQB", "defQB", "datSL", "cacheSA", "imageSM", " dataBB", "defBB", "dataEB", "contentSB", "imageNB", "dataBu", "resourceSB", "dataNB", "relationBu", "relSW", "DATABS", "relationSquare", "dateBS", "valueSW", " datasb", " dataMB", "imageHB", "ataMB", "dataRB", "listEB", "windowBB", "valueBS", "mapBB", "dateSB", "joinMB", "contentSF", "nextGB"], "trace": ["report", "debug", "batch", "list", "fake", "time", "detail", "tr", "network", "span", "create", "data", "address", "thread", "body", "tty", "test", "chain", "store", "th", "transform", "track", "table", "sequence", "feature", " Trace", "style", "tm", "tile", "sample", "comment", "stack", "ace", "true", "mt", "be", "stream", "te", "profile", "range", "dump", "se", "log", "race", "stable", "role", "message", "history", "temp", "buffer", "frame"]}}
{"id1": "5551393", "id2": "5441579", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getmd2", "getmd4", "getSHA4", "getmd3", "getMD2", "getMD3", "getmd5", "getMD4", "getSHA5", " getMD4", "getSHA2", " getMD2", "getSHA3", " getMD3"], "source": ["space", "data", "SOURCE", "body", "site", "filename", "target", "input", "string", "seed", "image", "base", "template", "name", "sequence", "style", "subject", "context", "src", "sample", "force", "ource", "Source", "now", "url", "value", "file", "from", "s", "resource", "reason", "start", "config", "content", "spec", "object", "output", "message", "text"], "tmp": ["m", "Temp", "mobi", "cache", "np", "aaa", "cp", "pkg", "data", "resp", "test", "perm", "obj", "found", "input", "attr", "lambda", "bt", "msg", "tar", "jp", "MP", "bag", "buf", "cont", "img", "snap", "src", "nd", " mp", "buff", "sp", "cmp", "cb", "managed", "cv", "t", "mp", "mk", "result", "etc", "pp", "tt", "qq", "tn", "gb", "bb", "output", "rup", "db", "po", "temp", "out", "foo", "txt", "p", "nt"], "md": ["d", "m", "amd", "ad", "cd", "ld", " Md", "mand", "bd", "pd", "hd", "MD", "desc", "mm", "det", "od", "dr", "ind", "pm", "mac", "mod", "cmd", "dd", " MD", "red", "der", "df", "wd", "pdf", "sam", "ms", "nd", "and", "dh", "td", "mt", "mn", "rm", "mp", "mk", "sm", "sd", "dm", "di", "mb", "de", "nt"]}}
{"id1": "13657103", "id2": "7908169", "code1": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"forBundle": [" processRebasket", " processEmbasket", " manageRebranch", " manageRebasket", " manageBundle", " processPasket", " manageBunch", " processBasket", " processRebranch", " processEmbunch", " manageBasket", " processBranch", " manageRebundle", " processPundle", " processRebundle", " processEmbranch", " processPunch", " processRebunch", " manageRebunch", " processPranch", " processEmbundle", " processBundle", " manageBranch", " processBunch"], "manip": ["managerup", "Manips", "maniper", " Manips", "emanop", "manop", "MANIP", "MANips", "damip", " manap", "manips", "damipper", "Manop", "damap", "MANap", "damiper", "emanip", "manup", "Manup", "ManIP", "managerIP", "emanup", " Manap", "managerop", "managerip", "Manip", " maniper", "emanIP", "emanipper", " Manip", "manIP", "Manap", "emanap", "MANip", " ManIP", " manipper", "emaniper", "manipper", "manap"], "bout": ["bbOut", "bouts", "bpool", "bbpool", "bio", "wou", "wout", "bOUT", "Bin", "zin", " bOUT", "zOUT", " bouts", " bOut", " boff", "bin", " bpool", "zOut", "boff", "bbouts", "Boff", "wop", "wpool", " bou", "zoff", "bbio", "bop", "zouts", "zio", "bbout", "bbop", "bou", "Bout", "bOut", "BOUT", " bop", "zou", " bin", "wOut", " bio"], "zout": ["zerouts", "zoent", " zent", "zoneaos", " zaos", " zouts", "ezos", "ezou", " zpool", "zenet", "ozoss", " zOUT", " zoss", "tzout", "zerent", "wout", "ozout", "zin", "azout", "zOUT", "azin", "zoneouts", "zOut", "zend", "zpool", "zoneout", "azOut", "zeOut", "zoneOut", " zou", "zoss", " zend", "zent", "wpool", " zos", "zerend", "tzOUT", "zipout", "ozOUT", "zaos", "zein", "zouts", "tzall", "zipin", "ozos", "zerout", "win", " zall", "zipOut", "zipaos", "azouts", "zall", "zoouts", "zippool", "znet", "zoend", "tzoss", "zou", "ezout", "zeout", "ozou", "zipnet", "zipouts", "wOut", " znet", " zOut", "zos", "ezOUT", "ozall", "zoout", "wouts", " zin"], "bundle": ["sbasket", "rbkg", "rbulk", " bulk", "boigration", "basket", "lasket", "sbound", "mbasket", "pbundle", "sbundle", "pbulk", " basket", "abulk", "masket", "rbasket", "brulk", "mond", "abigration", "mbond", "abasket", "abundle", "boasket", "brasket", "pbkg", "mbundle", " bond", " bund", "brundle", "sbund", "bund", "mundle", "rbundle", "lundle", "bigration", " bkg", "mbund", "mund", "bond", "boulk", "lound", "boundle", "bound", "bkg", "brigration", "lund", "bulk", " bound", "pbasket"], "files": ["reports", "objects", "types", "images", "forms", "classes", "sites", "times", "keys", "users", "roots", "ures", "plates", "obs", "features", "seconds", "lines", "iles", "links", "ids", "bees", "assets", "ails", "leases", "balls", "les", "facts", "lets", "runs", "issues", "photos", "fixes", "organisms", "actions", "rules", "Files", "resources", "headers", "bytes", "rows", "stores", "results", "names", "books", "file", "items", "fs", "groups", "ions", "chains", "fields", "styles", "faces", "values", "ports", "pages", "ds", "ls"], "url": ["browser", "http", "b", "entry", "m", "link", "web", "l", "ll", "html", "key", "rel", "el", "user", "re", "location", "loc", "li", "cert", "char", "f", "str", "mail", "dl", "ur", "nl", "sp", "bel", "mount", "URL", "resource", "file", "gl", "norm", "ml", "Url", "sl", "fl", "r", "sb", "mb", "path", "buffer", "ob", "ls", "uri"], "name": ["m", "n", "code", "named", "num", "node", "Name", "key", "NAME", "data", "full", "hash", "filename", "address", "no", "label", "string", "term", "one", "prefix", "type", "len", "f", "str", "alias", "common", "ame", "me", "title", "none", "comment", "info", "version", "word", "size", "normal", "names", "file", "local", "internal", "format", "nm", "part", "id", "all", "order", "event", "default", "run", "on", "path", "family", "length", "source"], "mf": ["manF", " Mfy", "Mfo", "MF", " Mf", "manf", "manfy", "mfy", " MF", "mfo", "mff", "Mif", " Mff", "mif", " mF", "mnif", "Mfy", "Mf", " mif", "mnfo", " mfo", "mF", "mnF", "mnf", "Mff", "manff"], "tmpFile": ["TempDir", "potPlace", " tmpPlace", "tmpName", "mpDir", "tempFile", "tempfile", "tmpCheck", "potfile", " tmpfile", "tempF", "tmpFiles", "tarFile", "tmpPlace", "tempCheck", "tarName", "tempFiles", "TempCheck", "TempF", "Tempfile", "tmpfile", "mpfile", "mpF", "tempDir", " tmpFiles", "TempName", "tempPlace", "tempName", "tmpF", "tmpDir", "mpFile", "potFile", "tarfile", "TempFile", "potFiles", "tarCheck"], "ref": [" href", "Ref", "link", " pref", "prop", "tab", "pkg", " references", "rev", " reg", "href", "resp", "rel", "pid", "re", "req", "rep", " referred", "rem", "pro", " re", "prefix", "nav", "f", " ret", "ret", "rc", "mem", "br", " refer", "af", "port", "REF", "rm", "service", "range", " req", " val", "id", "def", "eb", "conf", "r", " id", "reference", "Reference"]}}
{"id1": "6558022", "id2": "21489105", "code1": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"CheckUrl": ["checkURL", "CheckStr", " validateurl", "checkStr", "CheckURL", " checkURL", " validateURL", " validateStr", "Checkurl", " validateUrl", " checkUrl", "checkurl", " checkStr", " checkurl", "checkUrl"], "urlvalue": ["nullname", "UrlValue", " urlval", "Urlname", "nullstring", " urlformat", "Urlval", "URLformat", "Urlformat", "stringstring", "nullValue", "URLstring", "URLvalue", "stringname", "nullvalue", " urlstring", "stringvalue", "URLval", "urlname", "stringValue", "Urlstring", "urlformat", "urlValue", "urlval", "urlstring", "Urlvalue"], "inputLine": ["serviceRow", " inputString", "serviceLine", "inputline", "outputString", "selectLINE", "feedString", "serviceLINE", "selectLine", "outputLINE", " inputValue", "selectValue", "outputChain", " inputline", "outputRow", "serviceString", "inputRow", "outputLine", "inputValue", "inputChain", "outputline", "selectline", "outputValue", "feedLine", " inputLINE", "inputString", "feedChain", "inputLINE", "feedLINE", " inputRow", " inputChain"], "url": ["http", "b", "pl", "link", "null", "web", "l", "ll", "arl", "rl", "q", "rel", "el", "hl", "base", "atl", "name", "open", "char", "www", "f", "str", "ul", "ssl", "dl", "org", "ref", "build", "ur", "nl", "bel", "mount", "https", "URL", "file", "impl", "log", "Url", "job", "sl", "get", "r", "ls"], "urlConnection": ["URLConnect", "urlLink", "fileconnection", " urlConnect", "httpConnection", "fileConn", "urlconnection", "httpConnect", "fileConnection", "URLLink", "URLDescription", "fileConnect", "httpDescription", "httpLink", "webconnection", " urlDescription", "urlConn", "httpConn", " urlLink", "webConnect", "URLConnection", "urlConnect", "urlDescription", "webConn", "webConnection", "httpconnection"], "in": ["m", "b", "n", "IN", "thin", "inc", "l", "xml", "inner", "cin", "sum", "body", "ins", "doc", "input", "reader", "rin", "bin", "In", "is", "by", "f", "mn", "file", "gin", "from", "log", "read", "all", "get", "conf", "inn", "r", "on", "out", "din", "txt", " din", "source"]}}
{"id1": "1698200", "id2": "13595251", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginByteshare", "loginByteShare", " loginbitShare", " loginBitshare", "loginBitshare", "loginByteStock", "loginbitShare", "loginbitshare", " loginbitStock", " loginBitStock", " loginbitshare", "loginBitStock", "loginbitStock"], "params": ["http", "types", "settings", "tags", "cp", "services", "members", "pins", "keys", "parts", "requires", "points", "hash", "options", "mm", "parser", "posts", "cms", "param", "rs", "caps", "details", "properties", "ams", "json", "photos", "Parameters", "pi", "Par", "auth", "headers", "pas", "metadata", "acl", "changes", "names", "pres", "config", "chains", "stats", "pps", "ps", "ports", "pretty", "comments", "gs", "terms", "p"], "httpclient": ["httpsrequest", "ttpco", "http2", "httpcli", "hyperconnection", "Httpclient", " http2", "hyperclient", "httpsconnection", "Httprequest", "https2", "httpClient", "httpscli", "httco", "httcontroller", "ttpcontroller", "Httpconnection", " httpcli", "httpsco", "httclient", "httpsClient", "ttpClient", " httpconnection", "ttpclient", "httpsclient", "httpscontroller", "hyper2", "httpcontroller", "httpco", " httpClient", "httprequest", "hypercli", "HttpClient", "httClient", " httprequest", "httpconnection"], "httppost": [" httpost", " httpom", " httpppost", "httploint", " httppop", "httposter", "httplpost", "httpom", "httpost", "httppoint", "httpoint", "httppart", "httphpost", "httpplop", " httpop", "httpploint", "httpposter", "httppom", "httmpost", "httpppart", "httppop", "httploster", "httpploster", "httpperop", "httpplpost", "httpart", "httplart", "httpperpost", " httppom", "httpppop", "httphost", "httplost", "httpperom", "httpperost", "httpop", "httpppoint", "httmpart", "httpplost", "httppposter", "httmppost", "httphoint", "httplop", "httplom", "httppppost", "httpppost", "httmpop", "httphoster", "httpplart"], "formparams": ["formerrors", "functionproperties", "formednames", "formauthors", " formParameters", "functionmembers", "condsettings", "inputparams", "formchanges", "formdetails", "formmembers", "foremembers", "foreparams", "functionargs", "formedtags", "forechanges", "formsettings", " formchanges", "condnames", "inputerrors", "batchnames", "formederrors", "feedParameters", "batchparams", "condparams", "batchtags", "formtags", " formnames", "batcherrors", "inputdetails", " formdetails", "foreproperties", "foreargs", "forenames", "formargs", "formnames", "foresettings", "foreauthors", "inputnames", " formparam", "formParameters", "functionparams", " formargs", "foredetails", "inputtags", "inputparam", "formparam", "inputParameters", " formauthors", "condproperties", "feedparam", "feeddetails", " formmembers", "formproperties", "functionchanges", " formproperties", "functiondetails", " formsettings", "formedparams", "feedparams", "functionauthors"], "entity": ["orm", "entry", "security", "ENT", "html", "create", "xml", "data", "body", "el", "eme", "inv", "user", "Entity", "ew", "activity", "ee", "template", "ITY", "document", "person", "form", "line", "ity", "json", "enc", "note", "em", "fee", "comment", "ce", "metadata", "profile", "ent", "quote", "content", "object", "component", "event", "empty", "out", "buffer", "ell"], "httpresponse": ["httpresp", "HTTPconnection", "ttpconnection", "httpresult", "procresult", "HTTPreply", "procresponse", " httpresp", "httpconnection", " httpResponse", "ttpresponse", "HTTPresponse", "httpreply", "procreply", "HTTPresp", "ttpResponse", " httpreply", "HTTPresult", " httpconnection", "ttpresp", "procResponse", "httpResponse", "HTTPResponse", " httpresult"], "it": ["ed", "v", "ip", "l", "ex", "MIT", "al", "rit", "el", "you", "IT", "ind", "at", "It", "im", "ate", "ert", "ect", "li", "is", "its", "il", "itter", "ul", "iz", "act", "est", "init", "ut", "st", "ot", "he", "iter", "itted", "ite", "t", "mit", "ent", "sit", "lit", "ist", "ic", "i", "et"], "escookie": ["esctrl", "isecookie", "eyancel", "desccookie", "eycookie", "iseccookie", "descookie", "eccake", "esccookie", "ecookie", "espcookie", "escace", "ectrl", "eyace", "desctrl", "httpscookie", "ecoder", "ecace", "ecog", "ecue", "Esccookie", "occcake", "escue", "espookie", "escotton", "iseccake", "occcookie", "eccookie", "occookie", "escancel", "espancel", "descue", "Escue", "httpsookie", "httpsotton", "ecancel", "occog", "isecoder", "escoder", "Esctrl", "occoder", "espace", "escog", "ecotton", "occotton", "Escookie", "esccake", "eyookie", "httpsog"]}}
{"id1": "11562173", "id2": "12306305", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["assertInputstream", "assertInputFile", "checkAudioChannel", "assertInputStream", "checkContentChannel", "checkInputstream", "checkAudioFile", "checkContentStream", "checkAudioStream", "checkAudiostream", "assertInputChannel", "assertOutputChannel", "assertOutputStream", "checkInputChannel", "assertOutputstream", "checkContentFile", "checkOutputstream", "assertOutputFile", "checkOutputChannel", "checkOutputFile", "checkContentstream", "checkInputFile", "checkOutputStream"], "in": ["o", "b", "n", "raw", "IN", "l", "inc", "it", "ex", "al", "inner", "cin", "ins", "doc", "input", "mm", "ind", "c", "up", "In", "io", "is", "or", "cont", "st", "con", "old", "mc", "file", "gin", "from", "s", "en", "get", "inn", "on", "din", "source"], "cmp": ["comp", "csv", "cd", "cp", "pkg", "resp", "equal", "dict", "rel", "ctx", "desc", "msg", "cond", "c", "omp", "cmd", "comm", "qual", "conv", "compl", "co", "ch", "cb", "cs", "par", "mc", "cv", "com", "same", "coll", "mp", "Comp", "diff", "result", "pres", "vp", "ctrl", "cod", "match", "ck", "eq", "good", "tmp", "cc", "different", "cu", "tc", "cn"], "all": ["m", "list", "null", " ALL", "l", "ll", "al", "full", "equal", "alpha", "test", "call", "total", "only", "both", "ALL", "alph", "also", "attribute", "any", "ssl", "other", "first", "valid", "All", "a", "active", "none", "and", "kill", "always", "bl", "default", "empty", "app", "oll", "each"], "stream": ["screen", "time", "socket", "network", "input", "clean", "window", "system", "store", "ST", "shape", "collection", "dd", "form", "our", "engine", "row", "channel", "context", "sample", "sign", "st", "draw", "pipe", "stack", "sync", "REAM", "mount", "upload", "port", "each", "sudo", "service", "local", "Steam", "se", "ost", "sw", "console", "view", "event", "zip", "output", "Stream", "tmp", "host", "buffer", "ream", "parent"], "out": ["o", "b", "v", "batch", "n", "list", "to", "ne", "raw", "ex", "it", "pkg", "data", "obj", "res", "clean", "OUT", "at", "array", "des", "up", "external", "Out", "io", "aos", "outer", "str", "sys", "ot", "serv", "con", "check", "t", "help", "log", "exp", "ent", "good", "output", "outs", "tmp", "net", "cn", "conv", "not", "p"], "i": ["m", "multi", "v", "n", "ci", "ui", "batch", "ij", "it", "ji", "ei", "gi", "span", "key", "I", "q", "chain", "phi", "us", "perm", "uri", "vi", "index", "ind", "\u0438", "y", "ki", "ini", "li", "is", "ii", "gu", "iu", "xi", "client", "bi", "json", "pi", "u", "j", "ms", "me", "init", "info", "iter", "cli", "ri", "ai", "sim", "z", "mi", "ti", "ix", "id", "point", "sym", "di", "ims", "ic", "x", "si", "hi", "qi", "zi"]}}
{"id1": "16378239", "id2": "11952735", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"byReference": ["forReference", "byreference", "Byreference", " byRef", "forRef", "forResource", "ByResource", "forreference", "byRef", " byResource", " byreference", "byResource", "ByReference", "ByRef"], "inputStream": ["InputReader", "InputSteam", "inputstream", " inputFile", "instream", "readableSteam", "InputStream", "InputFile", "inStream", "inputFile", " inputReader", "inSteam", "inputReader", " inputstream", " inputSteam", "Inputstream", "readableStream", "inFile", "readablestream", "inputSteam", "readableReader"], "tempFile": ["TempDir", "tempUrl", "TempFiles", "tmpName", " tempChain", "tempfile", "TempUrl", " temporaryFile", " tempDir", "empName", "tmpPath", "TempDirectory", "tmpDirectory", "empfile", "tmpPlace", " tempFiles", "empFile", "poraryFile", "tempFiles", " temporaryChain", " temporaryfile", " tempfile", "TempChain", "Tempfile", "tmpfile", "poraryUrl", "tempPath", "tempChain", "TempPath", "tempDirectory", "empDirectory", "poraryfile", "poraryDir", "tempDir", " temporaryFiles", " tempUrl", "tempPlace", "tempName", "tmpFile", "empPath", "empPlace", "poraryName", "TempFile", "poraryPlace"], "out": ["o", "v", "to", "n", "dis", "null", "l", "in", "ex", "oss", "sum", "cos", "us", "ins", "user", "OUT", "one", "msg", "os", "up", "ou", "Out", "io", "writer", "aos", "again", "sys", "co", "lay", "serv", "con", "ao", "t", "file", "s", "auto", "ent", "all", "as", "OU", "output", "outs", "gr", "net", "conv", "source"]}}
{"id1": "4593012", "id2": "9687813", "code1": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"upgradeSchema": ["upgradeSme", "upchangeSchemas", "upgradeShema", "upgradeSmas", "upchangeScheme", "upgradeschemas", "upgradescheme", "upgradeSchemas", "upchangeSchema", "upgradeSma", "upchangeschema", "upchangescheme", "upgradeschema", "upgradeSheme", "upgradeShemas", "upgradeScheme", "upchangeschemas"], "stmt": [" stmm", "sttx", " superstmt", "semt", " superstmk", " Stm", " stmb", " superstm", " supersttx", "Stmp", "Stmk", "restmp", "stm", "StMT", " Stmb", "restmm", "STm", " stmp", " Stmt", "semp", "stmp", "STmm", "stmb", " stm", " superstMT", "STMT", "Stmt", "Stnt", " sttx", "sent", "stmk", "sem", "STmk", "stmm", "stnt", "stMT", " stnt", " stMT", "Stm", " superstmb", " Sttx", "restmt", "STmt", "restm", "STmp"], "i": ["yi", "multi", "ip", "n", "ci", "ui", "dim", "mys", "ij", "l", "v", "it", "ei", "gi", "ami", "h", "iri", "phi", "index", "im", "y", "oi", "ki", "ini", "ii", "li", "io", "is", "xi", "iu", "php", "fi", "bi", "pi", "j", "x", "me", "info", "iter", "cli", "iat", "zi", "ri", "ai", "sim", "ti", "mi", "ix", "exp", "id", "di", "ims", "asi", "ic", "I", "si", "hi", "qi", "uri"], "qry": ["sqri", "sqrys", " qtry", " qri", "qrys", "qurys", "quRY", "qary", "quried", "qury", " qary", "qutry", "qtry", " qRY", "questRY", " qrys", "quary", "sqry", "sqtry", "sqary", "questried", "questry", " qried", "qRY", "sqRY", "quri", "qri", "qried", "questtry"]}}
{"id1": "742465", "id2": "8166767", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["DoVersionCheck", "doDatecheck", "doDateUpdate", "doLicenseUpdate", "doLicenseCheck", "doLicenseFix", "doLicensecheck", "doDateFix", "doVersionsUpdate", "doVersionsCheck", "DoVersionUpdate", "doVersionUpdate", "DoDateCheck", "doVersionscheck", "doVersionFix", "doVersioncheck", "DoVersionFix", "DoDateFix", "DoDatecheck", "DoVersioncheck", "DoDateUpdate", "doDateCheck", "doVersionsFix"], "view": ["browser", "http", "report", "v", "print", "web", "html", "show", "blade", "server", "q", "call", "doc", "input", "views", "window", "index", "controller", "hl", "image", "self", "eye", "document", "layout", "iew", "open", "table", "wrapper", "form", "client", "View", "engine", "row", "cell", "subject", "context", "review", "manager", "block", "check", "cv", "file", "help", "widget", "query", "model", "update", "console", "VIEW", "get", "see", "host", "tv", "component", "this", "display", "util", "out", "page", "buffer", "tree"], "url": ["browser", "http", "pl", "b", "v", "link", "null", "web", "l", "socket", "ll", "html", "rl", "address", "rel", "date", "string", "location", "hl", "lb", "oul", "loc", "language", "char", "client", "f", "str", "ul", "json", "ssl", "dl", "org", "ur", "nl", "bel", "mount", "URL", "gl", "file", "log", "Url", "sl", "id", "github", "host", "lr", "r", "path", "ls", "uri"], "in": ["inf", "b", "n", "IN", "l", "inc", " IN", "inner", "cin", "body", "ins", "input", "reader", "vin", "rin", "In", "is", "f", "isin", "kin", "init", "info", "ln", "asin", "mn", "stream", "file", "gin", "mat", "ain", "inn", "sin", "out", "din", "i", " din", "source"], "bin": ["b", "cache", "conn", "thin", "mon", "ebin", "cin", "inner", "abin", "cos", "buffer", "spin", " bins", "reader", "obin", "rin", " Bin", "rb", "by", "bi", "bed", "bn", "mem", "sam", "bg", "buff", "con", "pipe", "ln", "win", "file", "gin", "ran", "local", "loader", "binary", "bl", "stock", "inn", "sin", "nb", "lib", "out", "din", "bur", " din", "len"], "line": ["entry", "link", "print", "code", "l", "err", "record", "cat", "lin", "eline", "body", "chain", "el", "no", "store", "string", "lines", "one", "lo", " Line", "base", "state", "load", "field", "cmd", "col", "char", "trace", "style", "cell", "row", "Line", "ine", "inline", "sample", "ls", "liner", "comment", "section", "column", "ide", "ln", "block", "iter", "level", "word", "port", "le", "LINE", "file", "lane", "range", "se", "log", "job", "part", "ice", "point", "path", "page", "channel", "frame", "text"], "version": ["browser", "v", "scale", "command", "project", "serial", "usage", "key", "Version", "test", "hash", "major", "VER", "virtual", "date", "index", "string", "software", "VERSION", "volume", "image", "status", "video", "name", "sequence", "description", "latest", "type", "license", "feature", "river", "form", "client", "vers", "ver", "number", "language", "iso", "title", "info", "position", "ion", "vision", "value", "resource", "format", "versions", "release", "update", "match", "spec", "tag", "translation", "python"], "build": ["dev", "b", "building", "print", "link", "project", "struct", "use", "install", "full", "test", "hash", "develop", "date", "dist", "th", "ble", "ward", "load", "ship", "builder", "boost", "hold", "uild", "built", "latest", "ver", "style", "other", "unit", "Build", "work", "where", "old", "be", "add", "last", "bor", "log", "make", "release", "update", "match", "binary", "round", "bug", "db", "arch", "lib", "tag", "fail", "util"]}}
{"id1": "7006052", "id2": "4398382", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "label": 0, "substitutes": {"copyFileTo": [" copyFileOver", "copyfileFrom", "copyFileFrom", "copyToOver", " copyFileThrough", "copyFilesTo", "copyFilesOver", "copyFilesThrough", "copyToTo", "copyfileThrough", "copyFileOver", " copyFilesThrough", "copyFilesFrom", "copyFileThrough", "copyfileOver", "copyToFrom", "copyfileTo", " copyFilesTo", "copyToThrough", " copyFileFrom", " copyFilesOver", " copyFilesFrom"], "src": ["http", "ctr", "pkg", "rl", "rt", "sec", "cos", "rel", "ins", "input", "ser", "obs", "req", "rs", "rx", "iv", "ipl", "cont", "sys", "usr", "rc", "init", "st", "Source", "cur", "sf", "inst", "url", "start", "config", "sit", "sc", "sb", "sin", "bs", "sr", "txt", "sq", "source"], "dest": ["d", "pl", "way", "rest", "them", " dst", "dat", "test", "target", "desc", "dist", "req", "des", "loc", "decl", "Dest", "www", "end", "cont", "trans", "usr", "pub", "est", "mem", "dir", "st", "origin", "port", "result", "home", "exp", "del", "good", "tmp", "nt", "de", "done", "orig", "source"], "destFile": ["srcfile", "sourceFile", "distDo", "DestFile", "sourceFiles", " destPage", "distfile", "newfile", "srcFile", "Destfile", "newPage", "sourceDir", "srcDir", "DestFiles", "newFile", "newDo", "DestDir", "sourcefile", "destDir", " destfile", "srcFiles", "destFiles", "destDo", "distFile", "destfile", "destPage", "distPage", " destDo"], "in": ["inf", "IN", "inc", "it", "al", "inner", "cin", "ins", "el", "input", "mm", "ind", "rin", "im", "bin", "up", "inside", "In", "io", "is", "ini", "ze", "act", "isin", "rc", "init", "con", "info", "iter", "ai", "from", "gin", "read", "en", "ain", "inn", "on", "per", "sin", "ic", "i", "din"], "out": ["o", "b", "v", "to", "n", "null", "it", "ex", "oss", "inner", "cos", "obj", "res", "OUT", "at", "os", "Out", "io", "ou", "writer", "aos", "client", "by", "outer", "sys", "we", "co", "write", "ot", "con", "and", "t", "auto", "gt", "can", "en", "g", "output", "outs", "on", "po", "net", "cn", "ne", "p", "nt"], "buf": ["b", "batch", "aka", "gen", "Buffer", "bh", "prop", "tab", "cat", "cp", "pkg", "data", "obj", "abet", "mu", "seq", "msg", "bin", "arr", "uf", "rb", "cmd", "alph", "bar", "cf", "pad", "bag", "str", "var", "img", "queue", "conv", "br", "buff", "cap", "cb", "box", "bytes", "vec", "cur", "block", "cam", "cv", "log", "tx", "bc", "good", "db", "Buff", "buffer", "bus"], "len": ["pl", "n", "v", "pos", "val", "l", "ld", "ll", "elt", "rel", "el", "no", "lic", "la", "seq", "wid", "lon", "end", "fin", "str", "il", "dl", "count", "compl", "e", "cap", "cmp", "lif", "lan", "ln", "vec", "size", "mun", "coll", "t", "le", "exp", "lf", "del", "Len", "en", "mid", "length", "ls", "z", "nt"]}}
{"id1": "1180878", "id2": "21656668", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrlFrame", "fetchGETFrame", "fectUrlFrame", "fetchUrlStream", "fectUrlStream", "fectURLStream", "fetchStringStream", "fetchUrlData", "fetchURLStream", "fetchURLFrame", "fetchStringData", "fectURLdata", "fetchStringFrame", "fetchStringdata", "fetchGETStream", "fectURLData", "fetchUrldata", "fectUrldata", "fectURLFrame", "fectUrlData", "fetchGETdata", "fetchURLdata", "fetchGETData"], "url": ["http", "b", "pl", "link", "print", "null", "web", "l", "html", "ll", "xml", "address", "full", "rel", "el", "string", "location", "base", "name", "loc", "ul", "mail", "ssl", "dl", "sql", "ref", "ur", "nl", "lim", "domain", "mount", "https", "URL", "gl", "file", "resource", "pattern", "log", "Url", "sl", "cl", "host", "default", "path", "ls", "uri"], "proxyHost": ["slaveUrl", "roxyHost", "roxyUrl", "slavehost", "ProxyName", "slaveOver", "proxyCheck", "proxyAddress", "roxyLabel", "ProxyUrl", "roxyOver", "ProxyLabel", "slaveHost", "roxyhost", "serverHost", "slaveLabel", "serverhost", "proxyUrl", "roxyCheck", " proxyOver", "proxyName", " proxyName", " proxyhost", "slaveCheck", " proxyAddress", "proxyOver", "proxyhost", "Proxyhost", "serverPort", "serverName", " proxyCheck", "proxyLabel", "roxyAddress", "slaveAddress", "ProxyPort", "ProxyHost"], "proxyPort": ["serverport", "serverAddress", "proxyAddress", "proxyPORT", "aliasPort", "ProxyPORT", "aliasAddress", "serverHost", "aliasport", "Proxyport", " proxyport", "serverPORT", " proxyPORT", " proxyAddress", "proxyport", "serverPort", "ProxyPort", "aliasHost", "ProxyHost"], "con": ["syn", "conn", "gate", "cat", "ex", "cp", "dial", "canon", "cos", "proc", "cgi", "call", "Conn", "rec", "cond", "pan", "c", "xc", "cons", "open", "cf", "col", "cmd", "client", "comm", "non", "fin", "un", "cone", "cont", "trans", "bo", "func", "fc", "connection", "nc", "act", "co", "ocon", "pc", "fac", "cs", "mc", "cur", "ln", "connect", "go", "don", "com", "CON", "ran", "ctrl", "const", "close", "can", "bc", "en", "cover", "mo", "ain", "conf", "cal", "sub", "po", "pen", "lock", "ver", "cc", "cn", "conv", "Con"], "is": ["ip", "dis", "ris", "isi", "in", "oss", "bis", "lis", "sis", "ists", "has", "us", "isa", "are", "was", "ins", "im", "ais", "gets", "rs", "os", "ois", "its", "IS", "abs", "sys", "Is", "mis", "eps", "isin", "iso", "isf", "ms", "bits", "init", "ys", "ios", "isp", "iter", "cs", "ri", "xs", "s", "iss", "ts", "es", "fs", "iris", "ist", "as", "isl", "ims", "ps", "bs", "i", "ains", "isc", "si"], "u": ["su", "o", "ui", "uv", "fu", "us", "uni", "pu", "user", "mu", "c", "up", "bu", "iu", "ou", "uf", "ue", "hu", "ul", "un", "uid", "yu", "lu", "ur", "ud", "ut", "eu", "au", "nu", " nu", "uj", "U", "tu", "g", "i", "ru", "cu", "uri", "uu"], "proxy": ["browser", "http", "ping", "ip", "xy", "cache", "shadow", "link", "null", "web", "project", "pointer", "policy", "pin", "phone", "cp", "socket", "address", "server", "pe", "via", "prime", "timeout", "token", "base", "gp", "aco", "pro", "jp", "friend", " proxies", "roxy", "client", "password", "alias", "cone", "echo", "bo", "pi", "cas", "connection", "ssl", "domain", "pipe", "version", "py", "PRO", "https", "go", "port", "slave", "profile", "map", "pre", "library", "embed", " prox", "host", "Proxy", "zip", "po", "pool", "translation", "pse", "x", "XY"], "baos": ["naows", "BAOs", "baOS", "vaOS", "poos", "BAoss", " baose", "poose", "nao", "aooS", "aoos", "aoOS", "vais", " baOs", "poo", " baoS", "bao", "baoss", "aois", " baOS", "BAo", "naoss", "bais", "vaoS", "BAose", "naos", " bao", "BAows", " baows", " bais", "baOs", "baose", "BAos", "baows", "baoS", " baoss", "vaos", "poOs"]}}
{"id1": "21363911", "id2": "4921631", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 1, "substitutes": {"testTransactions": [" testtransacts", "testtransitions", " testtransitions", "testtransaction", "testTransaction", "testTransacts", " testTransitions", "testTitions", "testTactions", "testTaction", "testTacts", "testTransitions", " testtransaction", " testTransaction", "testtransactions", " testTransacts", " testtransactions", "testtransacts"], "con": ["cache", "dial", "c", "cf", "client", "ens", "un", "bo", "act", "nc", "win", "com", "connect", "go", "don", "ran", "cm", "sur", "tc", "pl", "pt", "cp", "ctx", "open", "fn", "fc", "ln", "coll", "CON", "config", "console", "cal", "ren", "ic", "util", "conn", "ac", "gate", "re", "xc", "cons", "anc", "ct", "cont", "bn", "enc", "rc", "ch", "cur", "cv", "ctrl", "can", "fl", "bc", "en", "sc", "ain", "conf", "pen", "on", "po", "db", "gen", "res", "rec", "connection", "co", "pc", "mc", "dn", "gc", "cc", "cn", "conv", "Con"], "st": ["rest", "pt", "ld", "it", "ast", "step", "l", "rt", "h", "St", "sty", "ste", "obj", "statement", "th", "std", "irst", "bt", "stre", "ST", "wt", " superst", "stage", "ft", "ct", "stan", "str", "bo", "est", "co", "stat", "sp", "cr", "so", "nd", "ut", "ln", "mt", "sn", "must", "put", "inst", "t", "sts", "s", "sth", "ts", "sta", "start", "ost", "tt", "sw", "sl", "const", "cl", "sc", "ist", "fr", "sol", "sb", "ust", "art", "stra", "et", "stop", "nt"], "rs": ["ks", "cases", "rl", "rel", "ins", "rd", "ress", "ems", "hs", "abs", "sys", "rus", "arts", "ys", "ues", "rm", "Rs", "pres", "arms", "rss", "hr", "ps", "rings", "ges", "bs", "ds", "irms", "RS", "ris", "ws", "rt", "qs", "ubs", "dr", "ows", "ras", "ics", "rots", "ags", "rates", "ts", "rets", "gs", "js", "re", "vers", "vs", "usr", "rc", "ms", "ars", "cs", "xs", "s", "sts", "dds", "ats", "r", "ns", "sr", "ls", "ros", "acks", "times", "res", "rx", "icks", "ires", "ss", "its", "pc", "ri", "rr", "aps", "mr", "vr", "els", "rys", "stats", "ims", "rows"]}}
{"id1": "7166270", "id2": "732800", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"issueCommandToServer": [" sendCommandtoClient", " sendCommandFromRemote", " sendCommandTOserver", " sendCommandFromClient", " sendCmdToRemote", " sendCommandtoServer", " sendCmdtoServer", " sendCommandtoRemote", " sendCmdToClient", " sendCommandTORemote", " sendCmdtoRemote", " sendCommandToserver", " sendCommandToServer", " sendCmdtoserver", " sendCommandToClient", " sendCmdtoClient", " sendCommandTOServer", " sendCmdToserver", " sendCommandFromserver", " sendCommandTOClient", " sendCommandtoserver", " sendCommandFromServer", " sendCommandToRemote", " sendCmdToServer"], "command": ["menu", "code", "operation", "mode", "execute", "Command", "controller", "string", "directory", "template", "sequence", "document", "description", "attribute", "cmd", "password", "program", "form", "comm", "clear", "send", "connection", "application", "title", "request", "method", "help", "pattern", "requisite", "argument", "power", "direction", "query", "event", "message", "history", "channel", "action", "communication", "text", "uri"], "changeCapsule": ["changeClcapsULE", "changeCcapsale", "changeCapsale", "changeCapsULE", "changeCipherULE", "changeCpsules", "changeCcapsule", "changeCpsularity", "changeCipherue", "changeCapsue", "changeClapsULE", "changeClpsal", "changeCarsal", "changeCapsal", "changeCpsal", "changeClapsal", "changeClapsue", "changeCmsule", "changeClapsule", "changeCarsularity", "changeCcapsal", "changeCcapsules", "changeClapsularity", "changeClapsules", "changeCpsule", "changeClpsules", "changeCmsULE", "changeClcapsale", "changeCarsule", "changeCcapsULE", "changeCapsules", "changeCipherule", "changeClapsale", "changeCapsularity", "changeCarsules", "changeCcapsue", "changeClcapsue", "changeCmsale", "changeCmsue", "changeClcapsule", "changeCipherale", "changeCcapsularity", "changeClpsularity", "changeClpsule"], "urlConn": ["httpCon", "strConnection", "urlConnection", "logConnect", "urlconn", "UrlConnect", "httpCons", "strNum", " urlConnect", "httpConnection", "strConn", "urlCon", "urlNum", "fileConn", " urlCons", "dlconn", "logConnection", "retConn", "httpConnect", "retCons", "logconn", " urlCo", "dlConnect", "dlConn", " urlNum", "fileconn", "urlCo", "strCon", "strconn", "strConnect", "httpconn", "UrlConn", "httpConn", "retconn", "Urlconn", "strCo", "retConnect", "urlCons", "UrlNum", "httpCo", " urlconn", "urlConnect", "logConn", " urlCon", "fileConnect"], "wr": ["rew", "wk", "conn", "rw", "pr", "fw", "wp", "spr", "wx", "ew", "wo", "kr", "Writer", "wer", "wt", "writer", "wid", "nw", "wa", "we", "tw", "iw", "wy", "writ", "cr", "write", "writers", "vet", "w", "Wr", "RW", "wb", "wm", "mr", "sw", "tn", "vr", "vo", "hr", "fr", "WR", "wn"], "content": ["css", "code", "equ", "header", "data", "key", "address", "body", "label", "string", "ext", "expression", "template", "c", "load", "sequence", "document", "layout", "description", "Content", "core", "cont", "json", "media", "join", "context", "write", "application", "script", " Content", "section", "comment", "version", "txt", "ce", "search", "metadata", "value", "format", "resource", "ontent", "add", "reason", "config", "update", "output", "message", "text", "current", "source"], "input": ["submit", "http", "partial", "ip", "raw", "feed", "in", "inc", "background", "it", "xml", "inner", "alpha", "q", "data", "via", "reader", "image", "accept", "unknown", "Input", "inside", "open", " Input", "ahead", "form", "ssl", "init", "active", "upload", "info", "request", "enter", "iter", "ao", "acl", "iterator", "add", "internal", "local", "file", "pattern", "read", "query", "current", "update", "storage", "initial", "get", "output", "qi"], "response": ["report", "summary", "continue", "pos", "csv", "detail", "network", "resp", "reset", "dict", "respond", "server", "onse", "image", "verse", "related", "answer", "sequence", "still", "description", "collection", "trace", "application", "reply", "request", "version", "position", "vector", "block", "next", "value", "format", "service", "respons", "Response", "library", "result", "alert", "relation", "object", "view", "output", "message", "display", "buffer", "frame", "line"], "str": ["n", "print", "list", "err", "cat", "tr", "ctr", "dat", "data", "Str", "chain", "obj", "string", "re", "dr", "status", "msg", "exec", "name", "arr", "cert", "char", "line", "comm", "cont", "text", "j", "sp", "br", "st", "cs", "iter", "hex", "STR", "le", "t", "s", "piece", "exp", "del", "ent", "part", "set", "bc", "fr", "g", "expr", "r", "gr", "i", "txt", "p"]}}
{"id1": "12066447", "id2": "7908169", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"truncate": ["extvalidation", "trvalidize", "truncation", "extuncation", "trculation", "trculicate", "trvalidicate", "trculize", "trculate", "extvalidize", "trunation", "trunicate", "truncicate", "extuncize", "truncize", "extvalidicate", "trvalidation", "trunize", "extuncicate", "trunate", "trvalidate", "extvalidate", "extuncate"], "file": ["report", "to", "link", "null", "time", "use", "create", "data", "full", "filename", "user", "image", "base", "template", "name", "table", "io", "type", "attribute", "line", "f", "ile", "channel", "fp", "class", "parent", "e", "files", "dir", "work", "module", "info", "block", "word", "be", "port", "size", "le", "resource", "local", "File", "handle", "range", "format", "log", "from", "model", "spec", "get", "object", "event", "zip", "run", "lock", "frame", "message", "path", "page", "this", "out", "or", "foo", "FILE", "current", "tree", "source"], "backupRoot": ["BackupDir", "BackupidRoot", "backupsDir", "backupBox", "backflowDir", "backureroot", "workuproot", "backureRoot", " backupidBox", "workupDir", "backupidDir", "backflowFolder", "backumpDir", "backuproot", "BackupidDir", "backuperDir", "backupFolder", "workupidDir", "backureBoot", "workupBoot", "backupidFolder", "backupHome", "backmpRoot", " backupidRoot", "BackupRoot", "backumpRoot", "backflowRoot", "workupidHome", "workupRoot", "backuperHome", "backupidRoot", "BackupFolder", "backupBoot", "workupidBoot", "backupDir", "backupsroot", "backureHome", "backupidHome", "backmproot", "backureDir", " backupidroot", "backuperRoot", "backmpBoot", "backdownFolder", "backumpBox", "backupsRoot", " backupBox", "backdownRoot", "workupidRoot", "backmpDir", "backupidBoot", "backupidBox", "backumproot", "backdownDir", "backupsBox", " backupDir", "backupidroot", " backuproot", " backupidDir", "workupidroot", "BackupidFolder", "backuperroot", "workupHome"], "df": ["d", "DF", "dim", "md", "cd", "pd", "dp", "hd", "gd", "tf", "NF", "tif", "mm", "dr", " pdf", "dc", "deb", "uf", "cf", "dd", "f", "dx", "dl", "pdf", "bf", "raf", "Def", "du", "sf", "fun", "format", "dep", "fd", "lf", "sd", "def", "dm", "di", "db", "dt", "ds"], "date": ["age", "daily", "dated", "dates", "time", "duration", "dat", "create", "data", "sum", "string", " Date", "grade", "year", "ate", "name", "down", "standard", "number", "month", "when", "Date", "note", "late", "save", "module", "version", "zone", "now", "today", " day", "format", "resource", "value", "due", "future", "range", "start", "days", "update", "match", "day", "content", "get", "event", "default", "output", "run", "cal", "message", "dt", "tag", "frame"], "zipFile": ["zipfile", "zipPath", "logfile", "ZipFile", "Zipfile", "logPath", "zFile", "pdfStream", "pdfFile", "jsonFile", "zipFilename", "ZipPath", "zipStream", "zStore", "zfile", "jsonStore", "zFilename", "logFilename", "zipStore", "jsonfile", "pdfPath", "pdffile", "ZipStream", "logStream", "logStore", "jsonFilename", "logFile"], "zos": ["enos", "css", "enz", "bes", "shed", "stice", "js", "oss", "zar", "los", "ozo", "sbm", "sis", "ez", "cos", "sch", "asio", "oses", "zb", "hess", "zin", "webkit", "zik", "zag", "os", "asar", "south", "ss", "hs", "zers", "estro", "zer", "eros", "zzle", "ze", "cz", "za", "rez", "zen", "zon", "zes", " sands", "ones", "zo", "Sax", "ses", "jas", "nz", "zan", "sol", "zona", "hz", "esm", "bs", "tz", "z", "zi", "ros"], "fis": ["dfiss", "dfier", "dfIs", "ofib", "lia", "efisc", "lis", "fIs", "F\u00eds", "fiss", "fier", "sfier", "sfIs", "fisc", " fois", "cfis", "FIs", "foia", "dfis", "lIs", "ofis", "f\u00eds", "if\u00eds", "ifisc", "li", "cfiss", "fi", "ofois", "ofisc", "efis", " fiss", "Fisc", "ef\u00eds", "Fier", "ifIs", "fia", "sfits", "ifis", "Fiss", "cfisc", "Fis", "ofiss", " fib", "cfits", "foi", "fiois", "fits", "foIs", "efIs", "Fia", "ofits", "sfis", "fib", "fiis", "sfiss", "fois", "fiiss", "fiib", "Fi", "sfisc"], "entry": ["insert", "rance", "ary", "command", "tex", "record", "data", "xml", "key", "obj", "entity", "description", "attribute", "char", "sheet", "row", "cell", "connection", "ment", "cue", "e", "section", "comment", "and", "element", "ace", "ce", "word", "ion", "add", "escape", "resource", "search", "internal", "zo", "se", "office", "ent", "member", "set", "def", "object", "deep", "event", "zip", "delete", "Entry", "de", "option", "or", "ie", "ry"], "buffer": ["batch", "cache", "code", "zero", "command", "Buffer", "letter", "screen", "header", "memory", "paste", "window", "padding", "volume", "available", "template", "base", "button", "document", "table", "sequence", "bar", "attribute", "char", "queue", "buf", "phrase", "sample", "buff", "append", "comment", "stack", "iter", "block", "word", "category", "library", "variable", "binary", "view", "message", "temp", "page", "length", "frame"], "readed": ["READer", "READd", "Readd", "readared", "readied", "Reader", "reded", "READED", "reader", "redented", "Readed", "indexED", "redED", "readableED", "counted", "readableed", "readableared", " readeded", "Readied", "READed", "indexeded", "readableied", " readED", "counter", "readeded", "countED", "readented", " readented", "indexed", "indexented", "readED", "Readared", "readd", "ReadED", "findED", "countd", "findared", "finded", "rededed", "findied"]}}
{"id1": "12097948", "id2": "17557289", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 0, "substitutes": {"systemID": ["systemId", "SystemIDs", "sysIDs", "sysVD", " systemIDs", " systemId", "privateName", "sysName", " systemName", "privateVD", "privateId", "SystemId", "systemVD", "sysID", "sysId", "SystemID", "privateID", "systemIDs", " systemVD", "systemName", "SystemName"], "id": ["d", "ip", "link", "oid", "null", "wire", "md", "in", "sid", "it", "Id", "show", "data", "key", "create", "edit", "q", "hash", "pid", "post", "no", "test", "hd", "p", "bind", "gd", "res", "one", "base", "ids", "name", "shape", "layout", "description", "form", "end", "f", "str", "json", "aid", "uid", "ref", "hide", "init", "ide", "rid", "internal", "mask", "part", "iden", "def", "query", "bid", "mid", "ident", "kid", "message", "delete", "path", "ID", "db", "i", "uri", "source"], "loader": ["l", "pkg", "lc", "rl", "kernel", "user", "label", "system", "parser", "reader", "location", "hl", "loaded", "load", "older", "builder", "language", "framework", "handler", "layer", "container", "class", "cdn", "lp", "context", "nl", "owner", "module", "where", "finder", "manager", "er", "loads", "acl", "Loader", "library", "qualified", "cl", "lr", "loading", "pool"], "url": ["browser", "http", "link", "web", "l", "ll", "html", "rl", "xml", "address", "rel", "el", "user", "location", "lb", "load", "name", "loc", "builder", "f", "str", "il", "mail", "abs", "ret", "ssl", "org", "ref", "ul", "ur", "nl", "dl", "bel", "mount", "URL", "resource", "file", "impl", "norm", "ml", "Url", "job", "sl", "tool", "lr", "r", "mb", "path", "util", "or", "ls", "uri"], "inStream": ["innSteam", "intSteam", "inputstream", "instream", "onStream", " inSteam", "inBlock", "onView", "InSteam", "intBlock", "innStream", " instream", "INView", "inputFile", " inFile", "inSteam", "onSteam", "InFile", "innBlock", "intSocket", "Instream", " inSocket", "INstream", "inputStream", "inSocket", "innSocket", "InStream", "inFile", "inView", "INStream", "INSteam", " inBlock", " inView", "inputSteam", "intStream", "onstream"], "constraints": ["costrains", "costains", "costraint", "costaints", "conStraints", "constsains", "constrains", "costats", "constsats", "constrats", "conStrats", "constsaint", "conStraint", "costraints", "constraint", "costaint", "conStrains", "constaint", "constaints", "constains", "constats", "constsaints", "costrats"]}}
{"id1": "4056444", "id2": "8320469", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"hashPassword": [" hashUser", " hashpassword", "updateText", " hashText", "HashText", "HashPassword", "hashUser", "Hashpassword", "updatePassword", "updateUser", "HashUser", "hashpassword", "hashText", "updatepassword"], "password": ["Password", "report", "shadow", "secret", "command", "data", "address", "key", "reset", "user", "pass", "input", "string", "padding", "database", "username", "expression", "token", "sword", "name", "login", "prefix", "PASS", "description", "attribute", "random", "email", "wd", "phrase", "required", "word", "w", "value", "present", "account", "pattern", " Password", "hello", "default", "message", "text", "p"], "md": ["d", "m", "sh", "mg", "ad", "cd", "ld", "hed", "mand", " Md", "bd", "pd", "hd", "grad", "MD", "desc", "mm", "det", "od", "dr", "ind", "pm", "med", "mod", "cmd", "dd", "red", "der", "df", "sam", "ms", "dh", "mt", "mc", "mn", "add", "mk", "sm", "del", "sd", "mo", "dm", "cm", "di", "db", "mb", "sha"], "hash": ["sh", "print", "cache", "shadow", "bh", "ash", "hed", "html", "code", "secret", "key", "sum", "h", "test", "has", "full", "filter", "address", "user", "index", "string", "username", "mac", "token", "array", "state", "name", "mod", "Hash", "char", "row", "build", "auth", "dig", "score", "version", "hex", "block", "crypt", "check", "search", "value", "file", "mask", "handle", "format", "map", "id", "all", "message", " hashing", "sha"]}}
{"id1": "23620712", "id2": "4921631", "code1": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 1, "substitutes": {"insertService": ["insertServices", "submitServices", "createService", "saveService", "insertServer", "saveServer", "submitService", "insertservice", "saveservice", "createServer", "saveServices", "createServices", "createservice", "submitServer", "submitservice"], "table": ["to", "batch", "code", "list", "rule", "tab", "address", "server", "body", "chain", "key", "target", "able", "input", "index", "database", "entity", "template", "base", "collection", "col", "alias", "top", "connection", "note", "module", "domain", "comment", "column", "where", "title", "port", "Table", "value", "file", "t", "service", "resource", "account", "from", "query", "variable", "TABLE", "view", "db", "stable", "delete", "translation", "this", "pool", "family", "tree", "source"], "type": ["ping", "rule", "types", "code", "time", "key", " Type", "test", "pe", "index", "location", "status", "state", "ype", "Type", "y", "error", "TYPE", "style", "ver", "class", "unit", "version", "size", "now", "value", "t", "range", " TYPE", "id", "day", "relation", "typ", "kind", "event", "ty", "role", "family", "action"], "con": ["n", "ca", "conn", "gen", "gate", "lin", "cp", "dial", "cos", "Conn", "re", "c", "cons", "open", "fn", "cf", "col", "ct", "sur", "fin", "un", "trans", "fc", "connection", "common", "co", "ln", "mc", "cur", "connect", "com", "go", "coll", "CON", "ran", "ctrl", "const", "close", "can", "en", "ain", "cm", "conf", "ren", "po", "pen", "cal", "sin", "cc", "out", "cn", "conv", "Con"], "stmt": ["Stmt", "ostmt", "stsmp", "stsmt", "stsm", "ostmp", "Stm", "ostmm", "Stmp", "stmp", "Stmm", "ostm", "stsmm", "stm", "stmm"], "stmt2": ["stMT1", "Stm3", "stmt1", "stMT2", "sttx3", "Stm1", "Stm2", "stm1", "stm3", "stMT0", "Stmt1", "Stm0", "stmt3", "sttx1", "Stmt2", "sttx0", "stm0", "Stmt0", "stm2", "sttx2", "Stmt3", "stMT3", "stmt0"], "serviceUid": ["servUid", "servicePId", "serviceUniqueid", "serviceUniqueids", "serviceUd", "serviceOd", "servicePd", "serviceUids", "servUId", "servUd", "serviceUId", "serviceOid", "serviceUniqueId", "servicePids", "servicePid", "serviceUniqued", "servUniqueid", "servUniqued", "servUids", "servUniqueids", "servUniqueId", "serviceOId", "serviceOids"], "bo": ["pb", "o", "b", "goo", "obj", "ro", "Boo", "bool", "mu", "lo", "bt", "foo", "aco", "cho", "bol", "flo", "Ro", "fo", "pro", "bu", "io", "rown", "onet", "bone", "co", "so", "box", "module", "BO", "bro", "Bo", "ko", "cu", "og", "ao", "ht", "go", "ilo", "bean", "board", "bos", "boot", "soc", " boo", "vo", "bc", "obo", "mo", "oo", "po", "gro", "que", "ob"], "props": ["Probs", "pperties", "prmp", "progs", "proposes", "proprs", " procs", "ppped", "prgs", "comPS", "prets", "prrs", "prePS", "pcs", "loeps", "prps", "Props", "connect", " properties", "_", " proposes", "prs", " prots", "comperties", "Progs", "percs", "pts", "Promp", " promp", "probs", "perts", "promp", "perps", "propps", "loegs", "comps", "choPS", "call", "propped", "Propped", "properties", "Prors", "choperties", "prors", "pregs", "context", "propperties", "prots", "propts", "loeperties", "chops", "def", "perpped", "preps", "dat", "chobs", "preposes", "prepped", "obj", "proPS", "Prots", " propped", "perPS", "col", "loeposes", "procs", " prors", "connection", " progs", "preperties", "ProPS", "pps", "combs", "Properties"], "mainSql": [" mainRQL", "mainRpr", "MainSQL", "mainInsQL", "mainMps", "mainSSQL", "mainCmt", "mainUql", "mainSps", "mainRQL", "mainDesQL", "mainCsql", "mainInsql", "mainInspr", " mainSQL", "mainSmt", "MainSsql", " mainSSQL", "mainStringSQL", "mainCQL", "MainSpr", "mainInssql", " mainSsql", "mainCps", "mainStringsql", "mainMQL", "mainMql", "mainCpr", "mainUq", "MainCpr", " mainRpr", "mainCq", "mainSsql", "mainStringql", "mainStringQL", "mainSpr", "mainUsql", " mainStringq", "mainStringpr", "mainUSQL", "MainCmt", "MainSmt", "mainDespr", "mainRql", "mainDesql", "mainCSQL", " mainSps", " mainSpr", " mainSq", "mainRps", "MainCsql", "mainSQL", " mainStringsql", "MainCql", " mainRql", "mainDesmt", "mainCql", "mainMpr", " mainRps", "mainSq", "mainStringq", "MainSql", " mainStringSQL", "MainCQL", " mainStringql"], "name": ["list", "key", "location", "term", "mem", "zone", "t", "file", "local", "ix", "channel", "source", "n", "v", "time", "address", "label", "pass", "index", "base", "admin", "sequence", "description", "license", "password", "global", "common", "title", "version", "word", "value", "resource", "start", "part", "id", "run", "x", "NAME", "missing", "filename", "call", " Name", "ame", "info", "format", "internal", "from", "service", "message", "family", "out", "action", "parent", "Name", "chain", "root", "no", "group", "error", "wrapper", "alias", "sql", "domain", "comment", "none", "ma", "size", "primary", "names", "member", "event", "path", "net"], "l10n": ["l12N", " l18N", "l14l", "l33ns", "l45n", "l18ne", "l63n", "l8l", " l10l", " l12n", "L10N", "L10m", " l10N", "l10ne", "l17N", "L10ns", " l18ns", "l18ns", "l10m", "l10N", "l14N", "L10nes", "l14ns", "l63N", "l8n", "l33no", "l45ne", "L10ne", "l12ns", "l10nes", "l8ns", "l10l", " l18n", "l63np", "l17ns", "l18N", "L18nes", "l12n", "l8N", " l10no", "l14m", " l10ns", "L18ne", "l10no", "l10ns", "l14n", " l12ns", "l18n", " l12no", "l18m", "l17n", "l10np", " l12N", "l12no", "l63ns", "L18N", "l18np", "l33n", " l10np", "L18n", "l45N", "l14ne", "l12np", "L18ns", "l33N", "L10n", "l18nes", "l18l", "l45m", "l17nes", " l12np", "l12nes", "L18m", "l18no", " l18l"], "prefix": ["scale", " namespace", "zero", " pref", "pkg", "key", "NAME", "alpha", "reset", "hop", "major", "rap", "pa", "root", "index", "padding", "timeout", "req", "template", "base", "upper", "aux", "wrapper", "area", "fix", "password", "admin", "pad", "localhost", "alias", "fixes", "top", "offset", "ref", "FIX", "title", "setup", "pace", "origin", "radius", "hex", "mint", "patch", "format", "pattern", "pre", "master", "ix", "Pref", "point", "fixed", "quote", "tag", "path", "pretty", "fx", "p"], "serviceType": [" serviceState", "serviceTyp", "accessType", "entityTyp", "eventtype", "servicesType", "responseTYPE", " serviceId", "entityType", "serviceTYPE", "ServiceId", "serviceName", "serviceState", "ServiceState", "ServiceType", "responseId", "responseType", "entitytype", " serviceTyp", "ServiceTYPE", "ServiceStyle", "eventName", "servicestype", " serviceName", "entityTYPE", "switchId", "accessTyp", " serviceTYPE", "servicesName", "serviceStyle", " serviceStyle", "accessTYPE", "eventTYPE", "serviceId", "servicetype", "switchTYPE", "eventType", "servicesTYPE", "switchType", "responseState", "accesstype", "switchStyle", " servicetype"], "isNew": [" isForeign", "ISValid", "areForeign", "stateNEW", " isNEW", "actNEW", "isCreated", "areNew", "statenew", "eventNEW", "areNEW", "areValid", "stateNew", "ISCreated", " isnew", "actValid", "isValid", "actCreated", "commentNEW", "eventnew", " isValid", "isnew", " isCreated", "eventNew", "ISNew", "commentForeign", "ISNEW", "commentValid", "isNEW", "isForeign", "actNew", "commentNew"], "property": ["print", "key", "function", "term", "state", "associated", "pair", "peer", "file", "t", "office", "variable", "product", "component", "to", "complex", "address", "label", "description", "attribute", "style", "module", "column", "element", "position", "Property", "value", "resource", "profile", "library", "object", "translation", "method", "p", "rule", "command", "prop", "node", "properties", "behavior", "media", "class", "phrase", "prototype", "info", "from", "service", "argument", "empty", "option", "policy", "operator", "pe", "expression", "status", "param", "field", "feature", "domain", "comment", "primary", "metadata", "member", "relation", "event", "foo", "item"]}}
{"id1": "14093044", "id2": "11305840", "code1": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "code2": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "label": 1, "substitutes": {"insert": ["submit", "push", "create", "execute", "index", "database", "exec", "load", "login", "replace", "scan", "commit", "sql", "write", "append", "init", "save", "put", "check", "add", "query", "set", "update", "Insert", "delete", "select"], "consulta": ["consumptiona", "consumeable", "conserta", "consultar", "conultae", "consumptionas", "conultas", "consertae", "consulsas", "conscentable", "consultla", "consulsaria", "consultaria", "consumptionar", "consumera", "conscentae", "consaultana", "ConsumerA", "Conscentas", "consumela", "consultas", "concentae", "consaultae", "conultaria", "consaultaria", "conscentA", "consumptionae", "Conscenta", "consumptionable", "consultsa", "conultsas", "conultar", "conscentas", "consulsae", "Consultable", "consertar", "consumeras", "consaultas", "consultsae", "consumptionla", "consaultA", "concentar", "Consultas", "consumeas", "conultsaria", "conscentla", "Conscentable", "consultA", "consultable", "Consumera", "consumerana", "consumea", "conultsa", "Consultana", "Consumerana", "conulta", "conscentar", "Consultla", "consertas", "conscenta", "conscentana", "Consumeras", "consaulta", "Conscentla", "consultsas", "Consulta", "consultae", "consumerA", "ConsultA", "consultana", "concentas", "consultsaria", "consulsa", "concenta", "conultsae"], "autocommit": ["autOComits", "autoconommate", "autocondit", "autocommmit", "autoccelerulate", "autOComite", "autocumnbit", "autocondulate", "autocondite", "autocompit", "autocompulate", "autOCommulate", "autoconommmit", "autocondits", "autoconomit", "autocumnate", "autoconommit", "autocommort", "autocumnit", "autococomulate", "autoconombit", "autoccelermit", "autocommits", "autocomate", "autocomulate", "autocubmit", "autocommite", "autococomit", "autocomits", "autocondort", "autoccelerort", "autOComulate", "autocomit", "autOCommit", "autocommate", "autocomite", "autocompbit", "autococommit", "autOCommits", "autoconommbit", "autOComit", "autocubit", "autOCommmit", "autOCommate", "autocommbit", "autOCommite", "autocubits", "autOComort", "autococomate", "autocondmit", "autocompate", "autocomort", "autoconomate", "autocubite", "autocombit", "autocumnmit", "autoccelerit", "autOComate", "autOCommort", "autocommulate", "autocompmit"], "transactionIsolation": ["transceptionIolate", "transversionIsration", "transactionInterola", "transpointInterolated", "transactionIfola", "transactionISruption", "transversionIdavior", "transactionIsulation", "transactionIOL", "transpointIsolated", "transactionIsolate", "transactionStyleolation", "transactionInterolation", "transceptionIsOL", "transactionIdration", "transactionISOL", "transceptionIensitivity", "transpointInterola", "transpointInterolation", "transactionIilon", "transactionIolate", "transactionISavior", "transactionInterruption", "transactionIsilon", "transactionIsration", "transactionIfolation", "transactionIsruption", "transactionIsOL", "transactionAsolation", "transactionIsavior", "transactionIdavior", "transversionIsavior", "transactionStyleensitivity", "transactionAsularity", "transactionIularity", "transactionIfolated", "transceptionIsilon", "transpointInterruption", "transceptionIolation", "transactionStyleilon", "transceptionIularity", "transversionIsolate", "transpointIsruption", "transactionInOL", "transceptionIsularity", "transactionIsola", "transversionIdolation", "transactionISensitivity", "transactionIolated", "transactionInolated", "transactionISolate", "transactionInterolated", "transversionIdration", "transactionInterularity", "transactionInsration", "transceptionIsolate", "transceptionIsolation", "transceptionIsulation", "transactionStyleolate", "transactionIolation", "transceptionIsensitivity", "transactionIensitivity", "transactionISolated", "transceptionIsolated", "transceptionIulation", "transactionISolation", "transactionIdolation", "transactionInolate", "transceptionIolated", "transactionIsularity", "transpointIsola", "transactionInsavior", "transactionInterolate", "transactionIsensitivity", "transactionInolation", "transactionISola", "transactionIsolated", "transceptionIilon", "transpointIsolation", "transactionISration", "transversionIdolate", "transactionISilon", "transactionAsolate", "transactionAsolated", "transactionISulation", "transactionIulation", "transactionInsolate", "transceptionIOL", "transactionInterulation", "transversionIsolation", "transactionInsolation", "transactionIfruption", "transactionIdolate"], "cx": ["acxt", "acx", "ctx", "CX", "ncx", "Cx", " cxt", "cX", "Ctx", " ctx", "nctx", "ncxi", "cxi", "cxt", "ncX", "actx", "Cxi", "acX", " cxi", " cX", "Cxt"], "filasInsert": [" filasaAdd", "filasaInsert", "filinasEnter", "filasAdd", "filacsEnter", "filinasInsert", "filiasInsert", "filasRow", "folASRow", "filASImport", "filacsInsert", "filacsRow", "filiasDelete", "filASRow", "filasImport", "folasRow", "filinasRow", "filinasUpdate", "fundasImport", "filrasAdd", "filaInsert", " filasaUpdate", "filinasImport", "filaDelete", "filASInsert", "folasEnter", "filrasUpdate", "folASInsert", "folASImport", "filrasUpload", "fundasInsert", "filinasAdd", "filasEnter", "filasDelete", "filasaAdd", "filataImport", "filasUpload", "folasImport", "filASEnter", "filiasImport", "fundasDelete", "filasaUpdate", "filasaUpload", "filrasInsert", " filasAdd", "filataInsert", " filasUpload", "filacsImport", " filasUpdate", "filaImport", "fundaInsert", " filasaInsert", "filinasUpload", "folasInsert", "fundaImport", " filasaUpload", "filataDelete", "fundaDelete", "folASEnter", "filasUpdate"], "tipoConsulta": ["tipoConulta", "tipoConsumerA", "tipoConsultsa", "tipoconsultsada", "tipoCoulsada", "tipoConsulsada", "tipoCoulsao", "tipoCoulsa", "tipoConsultao", "tipoConsultara", "tipoCoulsar", "tipoConsulas", "tipoConsumptionara", "tipoconsultsA", "tipoConsumeras", "tipoConsulsao", "tipoConsultar", "tipoConistara", "tipoConsumera", "tipoconsultas", "tipoCoulta", "tipoConsultada", "tipoCoultada", "tipoConsistara", "tipoConsultas", "tipoConsulsar", "tipoConsista", "tipoConsula", "tipoConsresentao", "tipoConsresentada", "tipoConultao", "tipoConsulsA", "tipoConsresenta", "tipoconsultA", "tipoCoultar", "tipoConsumptiona", "tipoConsistao", "tipoConultas", "tipoconsultada", "tipoConsresentar", "tipoConsultsas", "tipoConsultsao", "tipoConsultsada", "tipoConsistas", "tipoConsulao", "tipoconsultsas", "tipoconsulta", "tipoConultara", "tipoConistas", "tipoConsultA", "tipoConsulara", "tipoConsumptionao", "tipoconsultsa", "tipoConsumerada", "tipoConsumptionas", "tipoConsultsA", "tipoConistao", "tipoConsultsar", "tipoConsulsas", "tipoConsulsa", "tipoConista", "tipoCoultao"], "execConsulta": ["execCoulta", "execConsultalpha", "execConsaultla", "execConultla", "execConsertarea", "execConsonsealpha", "execCoertai", "execCoultai", "execConulta", "execConsultarea", "execCoertalpha", "execConultar", "execCoultarea", "execConsertalpha", "execConultas", "execConsaulta", "execConsultar", "execConsortiuma", "execCoerta", "execConsumear", "execConsaultas", "execConsonseai", "execCoultalpha", "execCoertarea", "execConsonsea", "execConsultai", "execConsultas", "execConsumea", "execConsumeas", "execConserta", "execConsortiumai", "execConsaultar", "execConsonsearea", "execConsertai", "execConsultla", "execConsortiumarea", "execConsortiumalpha", "execConsumela"], "conexion": ["coneplexison", "caxression", "cakexpison", "coneexison", "cakexpion", "conexpION", "conexpone", "Colexpions", "coexible", "conexione", "conexpione", "coexinion", "conenexression", "conenexone", "conexision", "caxison", "coneuxion", "coexions", "conenexion", "conexpison", "conexION", "coeexion", "conexible", "coneexION", "conenexione", "caixression", "coneixion", "conenexison", "Colexpone", "conexpions", "cakexione", "coneplexion", "caixION", "coneixond", "coneuxinion", "coexond", "conextison", "coneixression", "conextion", "cakexion", "conextinion", "coneplexION", "conenexible", "coneexions", "coeuxION", "coeexison", "coneixione", "conextision", "caxION", "conenexinion", "conextression", "caixion", "coneXION", "coneaxison", "coeuxions", "coextision", "coneplexione", "cakexpION", "conexison", "coextione", "Colexpion", "caxion", "cakexpione", "coneXion", "conenexION", "coneexond", "cakexION", "coneaxion", "coneXible", "conexpion", "coneuxION", "Colexion", "conextION", "conexpond", "coeexION", "conextione", "conexond", "coneaxision", "conexinion", "coneuxions", "coexione", "coexision", "coextison", "coeexible", "coexION", "coneexone", "coneixison", "coneexione", "caixison", "conextions", "Colexpison", "coneXione", "conexression", "Colexison", "conenexions", "conexions", "coneexision", "coneexible", "cakexison", "coneexion", "coneaxione", "coeexione", "Colexone", "coexison", "coneixION", "coeuxion", "coexion", "Colexions", "coeuxinion", "conexone", "coeexond", "coextion"], "st": ["sle", "rest", "sh", "null", "pt", "it", "St", "sty", "ste", "pe", "obj", "statement", "std", "state", "ST", "stage", "ct", "end", "str", "est", "src", "stat", "sp", "nd", "ut", "mt", "sn", "put", "inst", "t", "sts", "sth", "se", "ts", "sm", "ost", "start", "tt", "sw", "sl", "set", "cl", "sc", "ist", "tmp", "stable", "ust", " ST", " est", "stop"], "MySQL": ["MYSQL", "mySQL", "MYQL", "myDB", "mysQL", "mysDB", "MYDB", "mysSQL", "myQL", "MyDB", "MyQL"]}}
{"id1": "62362", "id2": "16623181", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Conprocess", "compversion", "converting", "conversion", "Converting", "Converts", "ConVERT", "CONvert", "consVERT", "unprocess", "compvert", "compverts", "consverting", "consversion", "CONversion", "converts", "unfer", "unversion", "Converted", "Conversion", "unverts", "conVERT", "compprocess", "consvert", "CONverting", "Confer", "CONVERT", "converted", "unverted", "confer", "CONfer", "Convert", "conprocess", "CONverted", "unvert"], "src": ["http", "rest", "source", "pkg", "ebin", "SOURCE", "href", "filename", "rel", "ins", "ser", "input", "dist", "attr", "hl", "RC", "req", "rs", "scene", "rx", "loc", "iv", "ipl", "its", "str", "cont", "img", "scan", "sys", "usr", "orig", "func", "rc", "ur", "st", "upload", "ource", "Source", "cur", "stream", "inst", "url", "file", "from", "s", "buster", "start", "sit", "config", "sc", "host", "sin", "addr", "path", "cc", "sr", "txt", "sq", "uri", "SourceFile"], "dest": ["rest", "disk", " dst", " Dest", "dat", "test", "target", "tif", "dist", "table", "Dest", " destinations", "img", "est", "write", " Destination", "dir", "port", "gin", "mat", "result", " orig", "foreign", "temp", " destination", "txt", "orig", "source"], "in": ["inf", "d", "m", "b", "IN", "l", "ad", "inner", "cin", "ins", "el", "input", "res", "reader", "ind", "rin", "bin", "up", "In", "is", "io", "ar", "sql", "isin", "serv", "st", "stream", "file", "from", "en", "as", "inn", "r", "i", "din", "source"], "p": ["ping", "pb", "pl", "d", "parse", "m", "b", "pt", "l", "pg", "ap", "it", "cp", "pkg", "pd", "h", "wp", "post", "pe", "pa", "dp", "parser", "at", "pm", "rep", "c", "pro", "jp", "php", "f", "tp", "fp", "pi", "j", "lp", "sp", "pc", "py", "er", "pers", "t", "P", "pre", "vp", "pp", "ph", "part", "op", "g", "prot", "per", "ps", "r", "i"], "ds": ["ks", "pd", "hd", " os", "hs", "dl", "ys", "uds", " des", "iffs", " ads", "amps", "ps", "dt", "bs", "ils", "terms", "sets", "ws", "qs", "edes", "os", "cks", "dd", "ras", "eps", "ags", "loads", "ts", "ports", "gs", "mys", "js", "tags", "Ds", "points", "aws", "obs", "des", "tests", "df", "vs", "dh", "cs", "eds", " DS", "drivers", "xs", "s", "dds", "sts", "ats", "sd", "ands", "nas", "docs", "di", "db", "outs", "ns", "ls", "d", "dates", "DS", "dp", "gd", "posts", "rs", "yes", "ods", "ss", "ads", "its", "tp", " dd", "dos", "tes", " d", "scripts", "workers", "els", "lists"], "format": ["parse", "lat", "Format", "sche", "mode", "l", "policy", "it", "settings", "filter", "MAT", "at", "status", "template", " Format", "shape", "name", "table", "layout", "type", "cf", "form", "ct", "feature", "f", "style", "top", "fc", "unit", "act", "pi", "fm", "module", "title", "version", "mt", "size", "t", "file", "mat", "feat", "pattern", "ats", "set", "id", "spec", "output", "tag", "path", "pretty", "source"], "hasPixelData": ["hasixelDATA", "HaspixelData", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasPixelDATA", "hasixeldata", "HaspixelDATA", "haspixelDATA", "hasFrameData", "hasixelData", "hasFramedata", "HasPixelData", "Haspixeldata", "haspixelData", "HasPixelDATA", "HasPixeldata", "hasFrameDATA", "hasPixeldata"], "inflate": ["invalidATE", "Informat", "Inflat", " invalidocate", "Informocate", "inflat", "inFLocate", "inFlicate", "inflocate", " invalidate", " inflicate", "informocate", "Informate", " invalidicate", "inFlATE", "informated", "infolated", "invalidocate", "inflated", "infolat", "informate", "inflATE", " invalidATE", "inFLated", "infolate", "incelocate", " inflATE", "inflicate", "informat", "inFlocate", "incelicate", "inFlate", "incelate", "invalidicate", "Inflate", "invalidate", " inflocate", "inFLate", "infolocate", "inFLat", "Inflocate", "Informated", "Inflated", "incelATE"], "pxlen": ["xplen", "pixelfun", "mmlength", "pexlen", "pxden", "pxls", "packls", "pxlength", "pixellength", "packdec", "xpln", "xpden", "pixells", "mxlen", "tmplen", "xylin", "mxln", "mmln", "cplen", "phplength", "pxlin", "packlength", "pexden", "mxlength", "pexlength", "cplength", "pexfun", "mmlin", "xyln", "cpden", "pxln", "tmplength", "phpln", "packln", "xylen", "cpln", "phplen", "pexln", "mmlen", "pexls", "phpdec", "packfun", "xplength", "tmpln", "pxfun", "mxdec", "pxdec", "packlen", "pixellen", "tmplin", "xylength"], "out": ["print", "screen", "list", "conn", "ex", "err", "sum", "obj", "inv", "res", "store", "user", "OUT", "msg", "group", "name", "up", "prefix", "ou", "io", "Out", "writer", "aos", "cmd", "client", "outer", "sys", "init", "dir", "ln", "gov", "crit", "log", "inter", "cfg", "outs", "output", "gr", "temp", "net", "pretty"]}}
{"id1": "335223", "id2": "13886238", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewend", "readAndrewWrite", "readAndResend", "readAndrewrite", "readAndRepend", "readAndRewrites", "readAndResrites", "readAndRewWrite", "readAndRewend", "readAndRepWrite", "readAndResWrite", "readAndResrite", "readAndrewrites", "readAndReprites"], "inFile": ["infile", "InFilename", " inFilename", "docFilename", "inPlace", "outfile", "initFile", "INPlace", "iFILE", "inputFile", "inputPlace", "initFace", "inputFace", "iTime", "outFilename", "INFile", "Infile", "docTime", "InFile", "inFILE", "docFile", "initFilename", "iFilename", " infile", "inFace", "initPlace", "INFilename", "inTime", "inputFilename", "INTime", "inFilename", "iFile", "docFILE", "INFace", "INFILE"], "outFile": ["infile", "nameFILE", "checkFile", "outfile", "toFile", "checkFILE", "toFilename", "nameFilename", "checkfile", "toFILE", "checkFilename", "reportfile", "outFilename", " outFILE", "inFILE", "namefile", "reportFILE", "reportFilename", "tofile", " outfile", " outFilename", "outFILE", "reportFile", "nameFile", "inFilename"], "iis": ["diIs", "liis", "IIs", " iiss", "liris", "iIs", "iiss", " iIs", "iIS", "diis", "liisc", "diiss", "iiris", "eIs", "eIS", "Ii", "iiis", "ii", "liIs", " iIS", "eis", "dii", " iisc", " ii", "Iis", "aiis", "aiIs", "aiIS", "iiIs", " iris", "iiisc", "iris", "iisc", "Iiss"], "dcmParser": ["dcomParser", "dpmBuilder", " dpmPar", "dromParser", "dcommParser", "dfmBuilder", "dgrPar", "dcrparser", "DcmReader", "decmReader", "dmReader", " dpmAssistant", "deromReader", " dcmarser", "dcmStatement", "dcmReader", "dromReader", "dromparser", "dromListener", "dcmLoader", "dmmParser", "dpmLoader", "DpmPar", "dcommAssistant", "dmodulePrivate", "dmarser", "dmParser", "dcrParser", "DcmAdapter", "dcrBuilder", "DpmReader", "dcmPrivate", "dpmparser", " dpmReader", "DpmAdapter", "dmmmParser", "Dcmparser", "dpmStatement", "drumReader", " dpmPrivate", "dpcPrivate", " dpmBuilder", "dcmPar", "dfmLoader", "dgrStatement", "dcfStatement", "dmmmAdapter", " dcmLoader", "dpcParser", "DcmPar", "Dpmparser", "drumPar", "dcfReader", "dpmAdapter", " dpmListener", "dcomLoader", " dcmparser", "dgrReader", "DcmBuilder", "deromparser", "dpmAssistant", "deromParser", "drumParser", " dcmListener", "dpmarser", "decmParser", "drumBuilder", " dpmParser", "dmmarser", " dpmparser", "dcomReader", "dgrParser", "dcommReader", "dmoduleParser", " dpmStatement", "dpcReader", "deromarser", "dcmAssistant", " dcmPar", "dcommListener", "dpcAssistant", "dmoduleReader", "DpmBuilder", "dcmAdapter", "dcrReader", "dpmReader", "dfmReader", "dmmmReader", "decmarser", "dcomBuilder", "dpmPar", "dromAssistant", "dpmPrivate", " dcmBuilder", " dcmAssistant", "dpmParser", "dpmListener", "DcmParser", "dmmmparser", "dmoduleAssistant", "dcfPar", "dcmBuilder", " dcmPrivate", "decmparser", "dcmarser", "dmmparser", "dmparser", "dfmParser", " dcmStatement", "dromarser", "dcmListener", "DpmParser", " dpmarser", "dcmparser", " dcmReader", "dmmReader", " dpmLoader", "dcfParser", "dmmAdapter"], "ds": ["d", "ks", "sets", "js", "in", "ws", "DS", "services", "dat", "bd", "data", "pd", "Ds", "hd", "qs", "gd", "dq", "ins", "obs", "rs", "des", "os", "da", "ods", "ss", "hs", "details", "dd", "aos", "ads", "its", "der", "dx", "df", "vs", "sys", "dl", "eps", "sv", "dos", "ys", "dh", "cs", "uds", "eds", " DS", "drivers", "tes", "pers", "xs", "s", " des", "dds", "es", "fs", "sd", "as", "ims", "ps", "db", "outs", "dt", "bs", "ils", "ns", "gs", "ls"], "pdReader": ["tdReader", "ddLoader", "ddRunner", "xdLoader", "pedCar", "ddCar", "pedLoader", "tdParser", "pedReader", "hdWriter", "pdRead", "ddHelper", "pdCar", "pedRunner", "vdWriter", "pdParser", "vdLoader", "vdHelper", "dpLoader", "hdReader", "ddRead", "hdRead", "xdWriter", "ddReader", "vdReader", "dpRunner", "tdRead", "dpReader", "pdHelper", "pdLoader", "ddWriter", "dpCar", "ddParser", "hdParser", "tdWriter", "xdHelper", "pdRunner", "xdReader"], "out": ["cache", "list", "null", "in", "it", "data", "full", "ins", "desc", "msg", "c", "io", "client", "end", "sys", "we", "serv", "con", "go", "w", "t", "gr", "tmp", "o", "n", "to", "raw", "v", "pos", "ex", "inner", "flush", "at", "os", "over", "up", "Out", "cmd", "aos", " err", "cb", "ent", "sw", "id", "output", "pool", "p", "nt", "screen", "conn", "js", "oss", "err", "sum", "OUT", "one", "writer", "str", "ch", "nr", "opt", "s", "all", "en", "outs", "on", "gen", "obj", "inv", "res", "status", "name", "ou", "outer", "co", "log", "auto", "gt", "inter", "cfg", "net", "cn", "conv", "txt"], "dcmEncParam": ["dcmEscNum", "dcmencParam", "dmmencParam", "dcmDecCmd", "dcmEncPar", "dmmEncMsg", "dmmEncPar", "dcmencPar", "dcmencCmd", "dmmencNum", "dcmEncVal", "dmmEncParam", "dmmEncCmd", "dcmEscPar", "dcmEscVal", "dcmEnNum", "dmmEnPar", "dcmDecMsg", "dcmEncNum", "dcmEncCmd", "dmmEnNum", "dcmencMsg", "dmmencCmd", "dcmDecNum", "dcmEnVal", "dcmEnParam", "dcmEncMsg", "dmmencMsg", "dcmEscParam", "dcmencNum", "dmmEncNum", "dmmEnParam", "dmmEncVal", "dcmDecParam", "dcmEnPar"], "pdWriter": ["pdwriter", "dpWrite", "tdWriting", "pcWriting", "PDWriter", "pcwriter", "pidWriting", "pdWrite", "pdWriting", "PDReader", "PDWrite", "pdEditor", "tdWrite", "PDEditor", "tdwriter", "pidwriter", "pcWrite", "pidWriter", "pcWriter", "dpReader", "pidWrite", "dpEditor", "tdWriter", "tdReader", "tdEditor", "dpWriter"]}}
{"id1": "804637", "id2": "21348951", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewend", "readAndrewWrite", "readAndResend", "readAndrewrite", "readAndRepend", "readAndRewrites", "readAndResrites", "readAndRewWrite", "readAndRewend", "readAndRepWrite", "readAndResWrite", "readAndResrite", "readAndrewrites", "readAndReprites"], "inFile": ["infile", "InFilename", " inFilename", "docFilename", "inPlace", "outfile", "initFile", "INPlace", "iFILE", "inputFile", "inputPlace", "initFace", "inputFace", "iTime", "outFilename", "INFile", "Infile", "docTime", "InFile", "inFILE", "docFile", "initFilename", "iFilename", " infile", "inFace", "initPlace", "INFilename", "inTime", "inputFilename", "INTime", "inFilename", "iFile", "docFILE", "INFace", "INFILE"], "outFile": ["infile", "nameFILE", "checkFile", "outfile", "toFile", "checkFILE", "toFilename", "nameFilename", "checkfile", "toFILE", "checkFilename", "reportfile", "outFilename", " outFILE", "inFILE", "namefile", "reportFILE", "reportFilename", "tofile", " outfile", " outFilename", "outFILE", "reportFile", "nameFile", "inFilename"], "iis": ["diIs", "liis", "IIs", " iiss", "liris", "iIs", "iiss", " iIs", "iIS", "diis", "liisc", "diiss", "iiris", "eIs", "eIS", "Ii", "iiis", "ii", "liIs", " iIS", "eis", "dii", " iisc", " ii", "Iis", "aiis", "aiIs", "aiIS", "iiIs", " iris", "iiisc", "iris", "iisc", "Iiss"], "dcmParser": ["dcomParser", "dpmBuilder", " dpmPar", "dromParser", "dcommParser", "dfmBuilder", "dgrPar", "dcrparser", "DcmReader", "decmReader", "dmReader", " dpmAssistant", "deromReader", " dcmarser", "dcmStatement", "dcmReader", "dromReader", "dromparser", "dromListener", "dcmLoader", "dmmParser", "dpmLoader", "DpmPar", "dcommAssistant", "dmodulePrivate", "dmarser", "dmParser", "dcrParser", "DcmAdapter", "dcrBuilder", "DpmReader", "dcmPrivate", "dpmparser", " dpmReader", "DpmAdapter", "dmmmParser", "Dcmparser", "dpmStatement", "drumReader", " dpmPrivate", "dpcPrivate", " dpmBuilder", "dcmPar", "dfmLoader", "dgrStatement", "dcfStatement", "dmmmAdapter", " dcmLoader", "dpcParser", "DcmPar", "Dpmparser", "drumPar", "dcfReader", "dpmAdapter", " dpmListener", "dcomLoader", " dcmparser", "dgrReader", "DcmBuilder", "deromparser", "dpmAssistant", "deromParser", "drumParser", " dcmListener", "dpmarser", "decmParser", "drumBuilder", " dpmParser", "dmmarser", " dpmparser", "dcomReader", "dgrParser", "dcommReader", "dmoduleParser", " dpmStatement", "dpcReader", "deromarser", "dcmAssistant", " dcmPar", "dcommListener", "dpcAssistant", "dmoduleReader", "DpmBuilder", "dcmAdapter", "dcrReader", "dpmReader", "dfmReader", "dmmmReader", "decmarser", "dcomBuilder", "dpmPar", "dromAssistant", "dpmPrivate", " dcmBuilder", " dcmAssistant", "dpmParser", "dpmListener", "DcmParser", "dmmmparser", "dmoduleAssistant", "dcfPar", "dcmBuilder", " dcmPrivate", "decmparser", "dcmarser", "dmmparser", "dmparser", "dfmParser", " dcmStatement", "dromarser", "dcmListener", "DpmParser", " dpmarser", "dcmparser", " dcmReader", "dmmReader", " dpmLoader", "dcfParser", "dmmAdapter"], "ds": ["d", "ks", "sets", "js", "in", "ws", "DS", "services", "dat", "bd", "data", "pd", "Ds", "hd", "qs", "gd", "dq", "ins", "obs", "rs", "des", "os", "da", "ods", "ss", "hs", "details", "dd", "aos", "ads", "its", "der", "dx", "df", "vs", "sys", "dl", "eps", "sv", "dos", "ys", "dh", "cs", "uds", "eds", " DS", "drivers", "tes", "pers", "xs", "s", " des", "dds", "es", "fs", "sd", "as", "ims", "ps", "db", "outs", "dt", "bs", "ils", "ns", "gs", "ls"], "pdReader": ["tdReader", "ddLoader", "ddRunner", "xdLoader", "pedCar", "ddCar", "pedLoader", "tdParser", "pedReader", "hdWriter", "pdRead", "ddHelper", "pdCar", "pedRunner", "vdWriter", "pdParser", "vdLoader", "vdHelper", "dpLoader", "hdReader", "ddRead", "hdRead", "xdWriter", "ddReader", "vdReader", "dpRunner", "tdRead", "dpReader", "pdHelper", "pdLoader", "ddWriter", "dpCar", "ddParser", "hdParser", "tdWriter", "xdHelper", "pdRunner", "xdReader"], "out": ["cache", "list", "null", "in", "it", "data", "full", "ins", "desc", "msg", "c", "io", "client", "end", "sys", "we", "serv", "con", "go", "w", "t", "gr", "tmp", "o", "n", "to", "raw", "v", "pos", "ex", "inner", "flush", "at", "os", "over", "up", "Out", "cmd", "aos", " err", "cb", "ent", "sw", "id", "output", "pool", "p", "nt", "screen", "conn", "js", "oss", "err", "sum", "OUT", "one", "writer", "str", "ch", "nr", "opt", "s", "all", "en", "outs", "on", "gen", "obj", "inv", "res", "status", "name", "ou", "outer", "co", "log", "auto", "gt", "inter", "cfg", "net", "cn", "conv", "txt"], "dcmEncParam": ["dcmEscNum", "dcmencParam", "dmmencParam", "dcmDecCmd", "dcmEncPar", "dmmEncMsg", "dmmEncPar", "dcmencPar", "dcmencCmd", "dmmencNum", "dcmEncVal", "dmmEncParam", "dmmEncCmd", "dcmEscPar", "dcmEscVal", "dcmEnNum", "dmmEnPar", "dcmDecMsg", "dcmEncNum", "dcmEncCmd", "dmmEnNum", "dcmencMsg", "dmmencCmd", "dcmDecNum", "dcmEnVal", "dcmEnParam", "dcmEncMsg", "dmmencMsg", "dcmEscParam", "dcmencNum", "dmmEncNum", "dmmEnParam", "dmmEncVal", "dcmDecParam", "dcmEnPar"], "pdWriter": ["pdwriter", "dpWrite", "tdWriting", "pcWriting", "PDWriter", "pcwriter", "pidWriting", "pdWrite", "pdWriting", "PDReader", "PDWrite", "pdEditor", "tdWrite", "PDEditor", "tdwriter", "pidwriter", "pcWrite", "pidWriter", "pcWriter", "dpReader", "pidWrite", "dpEditor", "tdWriter", "tdReader", "tdEditor", "dpWriter"]}}
{"id1": "6009527", "id2": "23611770", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishShowAttachment", "doFinishLoadAttachention", "doFinishShowDetention", "doFinishLoadAttachached", "doFinishLoadAttachachment", "doFinishShowDetached", "doFinishShowDetachment", "doFinishLoadDetention", "doFinishLoadAssachment", "doFinishLoadDetachment", "doFinishLoadAttention", "doFinishLoadDetached", "doFinishLoadAttached", "doFinishShowAttention", "doFinishShowAttached", "doFinishLoadAssached", "doFinishLoadAssention"], "attachmentId": ["ATTachmentKey", "attociationKey", "atachmentID", "attachmentKey", "ATTociationKey", "atutationId", "attentionId", "ATTachmentById", "attgmentid", "ATTachmentId", "ATTociationById", "attachmentID", "attachedById", "atutationById", "attentionName", "attachmentName", "detachmentKey", "attociationid", "attachmentById", "attgmentId", "detachedid", "attentionById", "attachmentid", "attociationName", "attagramById", "attgmentKey", "atachmentName", "atachmentId", "detachmentid", "ATTociationId", "attutationID", "attachedId", "attociationID", "detachedKey", "attagramId", "attutationName", "attutationById", "attachedKey", "attentionID", "ATTociationid", "attachedid", "atutationName", "attutationId", "detachmentId", "attagramKey", "attociationById", "attagramid", "atutationID", "atachmentById", "detachedId", "ATTachmentid", "attociationId"], "attachment": ["attached", "contached", "attaching", "attention", "assaching", "assached", "assacher", "detment", " attment", "detached", "attachacher", "addaching", "contment", " attached", "association", "addociation", "assachment", "attachached", "attachaching", "detacher", "ATTachment", "ATTention", "detachment", "attment", "attociation", "assention", "attacher", "attachachment", "ATTached", " attacher", "attachociation", "ATTacher", "contacher", "addached", "attachention", "addachment", "contachment"], "attachmentUri": ["attentionUtri", "attachmentUtrid", "attachmentUpi", "attachmentOURI", "attachmentUtRI", "attachableOri", "attachmentuRI", "attachableOpi", "attachmentUrid", "attachableUri", "attachmentOri", "attachmenturi", "attentionUtpi", "attentionUpi", "attachmentTpi", "attachableUURI", "attachableOURI", "attachableUpi", "attachmentUnURI", "attachmentUnuri", "attentionURI", "attachmenturid", "attachableUuri", "attachmentOpi", "attachmentURI", "attentionUrid", "attachmentTURI", "attachmentupi", "attachmentOuri", "attachmentUnpi", "attachmentUnri", "attachmentUtri", "attachmentUuri", "attachmentUtpi", "attachableOuri", "attachmentTri", "attentionUri", "attachmentUURI", "attentionUtRI", "attachmentTuri", "attentionUtrid"], "contentUri": ["messageUuri", "contentUnri", "contentUsrid", "resourceURuri", "contentUuri", "contentURI", "contentUtiri", "resourceURI", "contentUsri", "ContentUris", "contentUtris", "resourceUri", "contentUsris", "contentUris", "contentUric", "messageUiri", "resourceURres", "contentuRI", "contentUnuri", "contentUtrid", "contentURri", "contentuuri", "contentUrri", "contentUtRI", "ContentUuri", "ContentUrid", "contentUrric", "contentURres", "contentUriri", "messageUtri", "contentUtres", "messageUturi", "messageUric", "contentSri", "contentUturi", "ContentUsris", "contentSiri", "contentUiri", "resourceURri", "contentURuri", "contentUres", "ContentUsri", "contentUsuri", "contenturi", "contentUrid", "contentURRI", "resourceUres", "contentures", "contentSuri", "resourceURRI", "resourceUuri", "contentUtric", "contentUnris", "contentUnrid", "contentSric", "messageUtiri", "contentUtri", "ContentUsuri", "contentUruri", "messageUri", "messageUtric", "ContentUsrid", "ContentUri"], "file": ["to", "ca", "link", "rule", "disk", "header", "create", "angle", "h", "filename", "play", "user", "folder", "entity", "image", "template", "base", "name", "table", "document", "type", "line", "f", "ile", "media", "il", "channel", "fp", "files", "init", "dir", "work", "save", "upload", "sf", "port", "le", "resource", "File", "local", "format", "from", "result", "content", "picture", "zip", "output", "db", "path", "pool", "page", "message", "buffer", "FILE", "tree", "source"], "in": ["inf", "IN", "l", "it", "inc", " IN", "al", "inner", "cin", "body", "ins", "play", "input", "ind", "rin", "bin", "up", "In", "inside", "is", "io", "ini", "ar", "sql", "isin", "con", "and", "gin", "from", "mi", "read", "en", "ain", "inn", "on", "ic", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "v", "print", "null", "screen", "ex", "it", "oss", "flush", "obj", "res", "OUT", "os", "ou", "Out", "io", "aos", "writer", "client", "outer", "sys", "co", "write", "serv", "con", "put", "ao", "check", "w", "auto", "can", "all", "g", "OU", "output", "outs", "stable", "net", "i", "conv", "nt"], "intent": ["man", "entry", "express", "continue", "condition", "xml", " Intent", "q", "inv", "displayText", "statement", "window", "term", "entity", "activity", "ence", "verbal", "activation", "device", "json", "venture", "act", "concept", "context", "ment", "prom", "intention", "activate", "init", "phrase", "Activity", "automatic", "asso", "spirit", "inst", "ant", "agent", "complete", "service", "ent", "widget", "wordpress", "query", "skill", "voice", "alert", "initial", "event", "animate", "ident", "ic", "ink", "method", "action", "communication", "text"]}}
{"id1": "14473711", "id2": "22366505", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"str2md5": ["str2sha5", "str_MD5", "str2mdest", "str2MDest", "str2dig7", "str2sha6", "str2digest", "str2md7", "str_mdest", "str2sha7", "str2MD5", "str2dig5", "str2shaest", "str2MD6", "str2dig6", "str_md5", "str2md6", "str_MD6", "str2MD7", "str_md6", "str_md7", "str_MDest", "str_MD7"], "str": ["b", "n", "v", "print", "in", "wcs", "tr", "ctr", "data", "Str", "oct", "obj", "wr", "res", "input", "string", "dr", "msg", "rs", "c", "name", "arr", "char", "f", "text", "cont", "enc", "vol", "ch", "cr", "sp", "br", "st", "hex", "cur", "STR", "url", "t", "s", "sts", "piece", "exp", "fr", "r", "out", "txt", "p"], "alga": ["agga", "balga", "balba", "algas", "aga", "agxa", " AlGa", " ala", "palba", " algas", "balxa", "palGa", "palha", "alGa", "balGa", "agba", "palga", "ala", " alba", " alha", " Alga", "balha", " calga", " calGa", " calgas", " alGa", " alxa", "bala", "alba", "alha", " Alba", " calba", " Algas", "alxa"], "digesta": [" digosi", "digosi", "divista", " digresso", "designested", " digested", "igresso", "igella", "divresso", "divesta", "igesta", "igista", "digested", "designeste", "divella", "digeste", "digella", "designesta", "digista", "diveste", " digella", " digista", "divosi", "digresso", "designosi", " digeste", "divested"]}}
{"id1": "364438", "id2": "19296519", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "        private long getSize(String url) throws ClientProtocolException, IOException {\n            url = normalizeUrl(url);\n            Log.i(LOG_TAG, \"Head \" + url);\n            HttpHead httpGet = new HttpHead(url);\n            HttpResponse response = mHttpClient.execute(httpGet);\n            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n                throw new IOException(\"Unexpected Http status code \" + response.getStatusLine().getStatusCode());\n            }\n            Header[] clHeaders = response.getHeaders(\"Content-Length\");\n            if (clHeaders.length > 0) {\n                Header header = clHeaders[0];\n                return Long.parseLong(header.getValue());\n            }\n            return -1;\n        }\n", "label": 0, "substitutes": {"convert": ["Conprocess", "compversion", "converting", "conversion", "Converting", "Converts", "ConVERT", "CONvert", "consVERT", "unprocess", "compvert", "compverts", "consverting", "consversion", "CONversion", "converts", "unfer", "unversion", "Converted", "Conversion", "unverts", "conVERT", "compprocess", "consvert", "CONverting", "Confer", "CONVERT", "converted", "unverted", "confer", "CONfer", "Convert", "conprocess", "CONverted", "unvert"], "src": ["http", "rest", "source", "pkg", "ebin", "SOURCE", "href", "filename", "rel", "ins", "ser", "input", "dist", "attr", "hl", "RC", "req", "rs", "scene", "rx", "loc", "iv", "ipl", "its", "str", "cont", "img", "scan", "sys", "usr", "orig", "func", "rc", "ur", "st", "upload", "ource", "Source", "cur", "stream", "inst", "url", "file", "from", "s", "buster", "start", "sit", "config", "sc", "host", "sin", "addr", "path", "cc", "sr", "txt", "sq", "uri", "SourceFile"], "dest": ["rest", "disk", " dst", " Dest", "dat", "test", "target", "tif", "dist", "table", "Dest", " destinations", "img", "est", "write", " Destination", "dir", "port", "gin", "mat", "result", " orig", "foreign", "temp", " destination", "txt", "orig", "source"], "in": ["inf", "d", "m", "b", "IN", "l", "ad", "inner", "cin", "ins", "el", "input", "res", "reader", "ind", "rin", "bin", "up", "In", "is", "io", "ar", "sql", "isin", "serv", "st", "stream", "file", "from", "en", "as", "inn", "r", "i", "din", "source"], "p": ["ping", "pb", "pl", "d", "parse", "m", "b", "pt", "l", "pg", "ap", "it", "cp", "pkg", "pd", "h", "wp", "post", "pe", "pa", "dp", "parser", "at", "pm", "rep", "c", "pro", "jp", "php", "f", "tp", "fp", "pi", "j", "lp", "sp", "pc", "py", "er", "pers", "t", "P", "pre", "vp", "pp", "ph", "part", "op", "g", "prot", "per", "ps", "r", "i"], "ds": ["ks", "pd", "hd", " os", "hs", "dl", "ys", "uds", " des", "iffs", " ads", "amps", "ps", "dt", "bs", "ils", "terms", "sets", "ws", "qs", "edes", "os", "cks", "dd", "ras", "eps", "ags", "loads", "ts", "ports", "gs", "mys", "js", "tags", "Ds", "points", "aws", "obs", "des", "tests", "df", "vs", "dh", "cs", "eds", " DS", "drivers", "xs", "s", "dds", "sts", "ats", "sd", "ands", "nas", "docs", "di", "db", "outs", "ns", "ls", "d", "dates", "DS", "dp", "gd", "posts", "rs", "yes", "ods", "ss", "ads", "its", "tp", " dd", "dos", "tes", " d", "scripts", "workers", "els", "lists"], "format": ["parse", "lat", "Format", "sche", "mode", "l", "policy", "it", "settings", "filter", "MAT", "at", "status", "template", " Format", "shape", "name", "table", "layout", "type", "cf", "form", "ct", "feature", "f", "style", "top", "fc", "unit", "act", "pi", "fm", "module", "title", "version", "mt", "size", "t", "file", "mat", "feat", "pattern", "ats", "set", "id", "spec", "output", "tag", "path", "pretty", "source"], "hasPixelData": ["hasixelDATA", "HaspixelData", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasPixelDATA", "hasixeldata", "HaspixelDATA", "haspixelDATA", "hasFrameData", "hasixelData", "hasFramedata", "HasPixelData", "Haspixeldata", "haspixelData", "HasPixelDATA", "HasPixeldata", "hasFrameDATA", "hasPixeldata"], "inflate": ["invalidATE", "Informat", "Inflat", " invalidocate", "Informocate", "inflat", "inFLocate", "inFlicate", "inflocate", " invalidate", " inflicate", "informocate", "Informate", " invalidicate", "inFlATE", "informated", "infolated", "invalidocate", "inflated", "infolat", "informate", "inflATE", " invalidATE", "inFLated", "infolate", "incelocate", " inflATE", "inflicate", "informat", "inFlocate", "incelicate", "inFlate", "incelate", "invalidicate", "Inflate", "invalidate", " inflocate", "inFLate", "infolocate", "inFLat", "Inflocate", "Informated", "Inflated", "incelATE"], "pxlen": ["xplen", "pixelfun", "mmlength", "pexlen", "pxden", "pxls", "packls", "pxlength", "pixellength", "packdec", "xpln", "xpden", "pixells", "mxlen", "tmplen", "xylin", "mxln", "mmln", "cplen", "phplength", "pxlin", "packlength", "pexden", "mxlength", "pexlength", "cplength", "pexfun", "mmlin", "xyln", "cpden", "pxln", "tmplength", "phpln", "packln", "xylen", "cpln", "phplen", "pexln", "mmlen", "pexls", "phpdec", "packfun", "xplength", "tmpln", "pxfun", "mxdec", "pxdec", "packlen", "pixellen", "tmplin", "xylength"], "out": ["print", "screen", "list", "conn", "ex", "err", "sum", "obj", "inv", "res", "store", "user", "OUT", "msg", "group", "name", "up", "prefix", "ou", "io", "Out", "writer", "aos", "cmd", "client", "outer", "sys", "init", "dir", "ln", "gov", "crit", "log", "inter", "cfg", "outs", "output", "gr", "temp", "net", "pretty"]}}
{"id1": "3330944", "id2": "8079516", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"extractImage": ["ExtprocessImage", "ExtractImages", "ExtprocessImages", "extprocessImages", "extlateFrame", "extractorFrame", "ExtractFrame", "extlateImage", "extlateImages", "Extractimage", "extlateimage", "extractimage", "extractorImage", "ExtprocessFrame", "Extprocessimage", "extractorimage", "extprocessimage", "extprocessFrame", "extprocessImage", "extractFrame", "extractorImages", "extractImages", "ExtractImage"], "input": ["ip", "partial", "raw", "null", "hidden", "it", "background", "xml", "address", "data", "q", "ins", "buffer", "index", "string", "audio", "uri", "seed", "image", "base", "accept", "Input", "prefix", "error", "str", "img", "rc", "qa", "context", "sample", "init", "upload", "txt", "request", "origin", "check", "url", "format", "file", "from", "local", "internal", "pattern", "start", "config", "query", "current", "initial", "hello", "empty", "tmp", "this", "path", "before", "out", "i", "text", "select", "p", "source"], "output": ["o", "generated", "to", "print", "hidden", "filename", "target", "OUT", "response", "image", "name", "prefix", "oe", "type", "icon", "write", "put", "port", "format", "file", "result", "success", "Output", "STDOUT", "OU", "path", "temp", "display", "out", "PUT", "pretty", "current", "source"], "params": ["m", "types", "images", "prop", "settings", "tags", "pkg", "members", "requires", "pins", "tools", "parts", "keys", "points", "proc", "ctx", "phi", "users", "options", "mm", "las", "devices", "param", "rs", "parents", "pro", "jp", "caps", "details", "fps", "properties", "ams", "photos", "json", "actions", "eps", "Parameters", "AMS", "Par", "phys", "pi", "ars", "par", "pas", "results", "names", "changes", "s", "packages", "modules", "config", "eters", "arms", "chains", "styles", "spec", "docs", "conf", "stats", "ims", "pps", "ps", "abilities", "ports", "pretty", "marks", "units", "gs", "terms", " parameters", "p"], "w": ["d", "m", "kw", "v", "n", "o", "rw", "ws", "h", "wp", "q", "wr", "wx", "window", "ew", "wo", "Writer", "wt", "writer", "nw", "f", "we", "wa", "wd", "write", "e", "wal", "word", "wl", "wb", "hw", "wh", "sw", "W", "Ws", "out", "p"], "in": ["inf", "raw", "null", "IN", "it", " IN", "al", "inner", "cin", "ins", "mm", "p", "vin", "one", "rin", "bin", "base", "name", "In", "ini", "is", "Input", "f", "ar", "sql", "isin", "phys", "e", "init", "con", "old", "copy", "ln", "mc", "ma", "win", "info", "edIn", "nin", "file", "gin", "from", "local", "include", "mi", "read", "id", "all", "en", "conf", "inn", "sin", "po", "path", "out", "din", "i", " din", "source"], "dest": ["to", "rest", "way", "comb", "csv", "prop", "cat", "ws", " dst", "dat", "data", "resp", "deg", "target", "desc", "tif", "dist", "des", "shape", "loc", "decl", "Dest", "oe", "end", "nom", "buf", "cont", "trans", "img", "usr", "mem", "src", "write", "save", "dir", "st", "alt", "pipe", "origin", "pas", "port", "opt", "result", "wb", "lit", "tmp", "path", "temp", "display", "out", " destination", "txt", "orig", "p", "source"], "bi": ["pb", "yi", "b", "isi", "bh", "bis", "gi", "bas", "rob", "bank", " nib", "iri", "phi", "ibe", "hog", "vi", "mu", "ble", "ali", "bin", "bone", "oi", "ki", "phy", "ini", "li", "bp", "fi", "obi", "bo", "pi", "ba", "beck", "bf", "BI", "abi", "buff", "bg", "bits", "ib", "bil", "be", "ai", "mi", "ni", "bie", "bra", "bb", "bc", "ibi", "umi", "obo", "bm", "Bi", "di", "jiang", "nb", "bs", "i", "ji", "qi", "zi"], "os": ["o", "css", "ks", "ose", "pos", "oid", "oss", "ops", "los", "oos", "cos", "us", "oses", "obs", "is", "io", "aos", "Os", "ows", "or", "sys", "mot", "ot", "OS", "ios", "ols", "cs", "ow", "ys", "acs", "s", "bos", "osi", "ts", "es", "fs", "oo", "ns", "bs", "oes", "ons", "ds", "et", "ls", "ox", "mos", "ros"]}}
{"id1": "10131427", "id2": "2511579", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", " copyStream", " CopyImage", " cpStream", "CopyStream", "CopyImage", " CopyStream", " cpFile", " cpImage", "Copyfile", "CopyFile", " copyImage", " CopyFile", " Copyfile", " copyfile"], "in": ["inf", "o", "b", "n", "IN", "l", "inc", "it", "cin", "ins", "el", "input", "mm", "ind", "vin", "rin", "up", "In", "is", "ar", "isin", "st", "old", "edIn", "gin", "from", "s", "en", "inn", "on", "r", "ic", "din", "i", "source"], "out": ["o", "b", "v", "n", "to", "l", "it", "ex", "oss", "err", "OUT", "os", "ou", "Out", "io", "str", "ch", "ot", "serv", "check", "w", "t", "file", "s", "help", "log", "gt", "output", "outs", "po", "net", "i", "ne", "nt"], "sourceChannel": ["inputConnection", "inputChan", " sourcechannel", "singleChuck", "ourceStream", " sourceStream", "matchButton", "matchChuck", "SourceConnection", "sourceChan", "srcchannel", "SourceStream", " sourceChain", "sourceButton", "matchChannel", "singleButton", "singleApplication", " sourceButton", "resourcechannel", "inputChannel", "seedChuck", "singleChannel", "ourceChan", " sourceConnection", "inputChain", "sourceChain", "ourceChannel", "ourceConnection", "seedApplication", "sourceConnection", "seedChannel", "sourceChuck", "Sourcechannel", "seedButton", "sourcechannel", "ourceButton", "resourceStream", "matchApplication", "resourceChannel", "ourcechannel", "srcChannel", "SourceChannel", " sourceChan", "sourceApplication", "sourceStream", "srcStream", "ourceChain", "resourceConnection", "srcButton"], "destinationChannel": ["destationChannel", "destinationsConnection", "DestationChan", "destinatoryCow", "destinationConnection", "DestensionClient", "destinatoryBlock", "destinationBlock", "DestensionChannel", "desticationBlock", "destinatedContext", "desticationChan", "destinationClient", "destinatoryChannel", "DestensionConnection", "desticationCow", "DestinationConnection", "DestationBlock", "destationCow", "destinationCow", "DestinationClient", "DestinationChannel", "destinationsChan", "destinatedChan", "destinatoryChan", "destroyChan", "DestinationCow", "destroyConnection", "desticationChannel", "destensionChannel", "DestinationContext", "destinationsContext", "destensionChan", "DestationCow", "destroyClient", "destroyChannel", "DestationChannel", "destinationContext", "destationBlock", "DestensionChan", "destationChan", "destinationChan", "DestinationBlock", "destinatedConnection", "DestinationChan", "destensionConnection", "DestationContext", "destationContext", "destinationsChannel", "destinatedChannel", "destationClient", "DestationConnection", "destensionClient", "destationConnection"]}}
{"id1": "8000624", "id2": "3495460", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"CopyTo": [" CopyInt", " copiesInt", "CopyInt", " copiesTo", " copyFrom", " copyInt", "CopyFrom", " CopyFrom", " copiesFrom", " copyTo"], "dest": ["d", "v", "rest", "null", "it", "cat", "them", "target", "filename", "th", "image", "name", "loc", "Dest", "fn", "nom", "cont", "img", "usr", "mem", "est", "src", "sp", "dir", "st", "pipe", "origin", "copy", "w", "opt", "result", "output", "tmp", "path", "temp", "txt", "orig", "p", "source"], "in": ["inf", "o", "m", "ac", "IN", "thin", "inc", "it", "l", "al", "inner", "cin", "ins", "input", "re", "reader", "ind", "image", "one", "rin", "bin", "ire", "ir", "login", "min", "In", "inside", "up", "is", "ini", "client", "by", "ar", "isin", "init", "con", "iter", "win", "ai", "nin", "t", "gin", "file", "from", "local", "mi", "internal", "read", " input", "en", "ain", "inn", "sin", "per", "r", "on", "net", "din", "i", " din", "source"], "out": ["o", "b", "v", "n", "to", "dis", "null", "list", "batch", "ex", "oss", "it", "inner", "full", "flush", "cos", "obj", "user", "res", "OUT", "na", "at", "one", "os", "up", "Out", "io", "oe", "writer", "ou", "aos", "client", "fn", "by", "end", "outer", "other", "conv", "co", "write", "e", "loss", "ot", "note", "con", "ln", "w", "t", "boot", "gt", "can", "all", "en", "op", "output", "outs", "ns", "net", "cn", "ne", "not", "nt"], "c": ["d", "v", "n", "code", "ac", "ca", "l", "cd", "cat", "cp", "lc", "k", "arc", "cf", "char", "ct", "uc", "f", "cont", "cut", "count", "u", "rc", "ch", "cr", "nc", "e", "cap", "cb", "con", "unc", "cs", "ce", "t", "z", "gc", "cod", "cl", "bc", "sc", "C", "g", "cm", "conf", "ec", "cc", "i", "character", "current"]}}
{"id1": "20519261", "id2": "11704429", "code1": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readReferenceText": ["getreferenceText", "readReftext", "getreferenceForm", "readRefMessage", "readRefForm", "getReferenceText", "readLinkMessage", "readreferencetext", "readRefText", "readreferenceText", "readreferenceMessage", "readReferenceForm", "getreferenceMessage", "readLinkText", "getreferencetext", "readReferencetext", "getReferencetext", "readReferenceMessage", "readLinkForm", "readreferenceForm", "readLinktext", "getReferenceForm", "getReferenceMessage"], "ident": ["filename", "instance", "via", "det", "location", "term", "string", "ind", "Ident", "unknown", " identifier", "mod", "loc", "urn", "person", "password", "imp", "row", "text", "sql", "context", "common", "tim", "hex", "word", "inst", "intent", "feat", "local", "prim", "log", "ent", "id", "coord", "match", "spec", "event", "addr", "IDENT", "util", " identify", "idents"], "name": ["n", "named", "Name", "NAME", "key", "data", "filename", "label", "string", "location", "base", "prefix", "type", "str", "alias", "mem", "ame", "me", "title", "comment", "version", "word", "search", "names", "file", "resource", "format", "nm", "id", "path", "family", "text", "source"], "url": ["browser", "http", "pl", "b", "link", "web", "l", "ll", "html", "rel", "location", "hl", "lb", "base", "loc", "li", "ul", "mail", "ssl", "dl", "ref", "ur", "nl", "bel", "mount", "URL", "gl", "file", "resource", "log", "Url", "sl", "r", "lr", "ls", "uri"], "in": ["inf", "n", "null", "IN", "l", "inc", "data", "inner", "cin", "body", "ins", "input", "reader", "ind", "dr", "rin", "bin", "In", "is", "f", "str", "info", "iter", "irm", "ri", "stream", "mn", "file", "from", "inn", "r", "on", "ic", "out", "din", "i", " din"], "isr": [" isrs", "ispr", "osr", " iser", "ISrc", "issr", "osrs", "ospr", "aisr", "aiser", "ISr", "isrc", " ispr", "isser", "isrs", "aisrs", "iser", " isrc", "aisrc", "ISer", "oser", "ISrs", "issrs", "isspr"], "br": ["browser", "b", "BR", "pr", "bh", "tr", "bd", "ber", "wr", "yr", "adr", "dr", "bt", "rb", "bp", "shr", "buf", "bi", "bf", "cr", "bro", "nr", "be", "mr", "vr", "bc", "fr", "hr", "bm", "bl", "r", "lr", "gr", "bs", "sr", "Br", "bridge"], "buffer": ["menu", "batch", "cache", "print", "null", "Buffer", "command", "screen", "black", "memory", "window", "total", "database", "template", "base", "bone", "button", "document", "sequence", "builder", "bar", "table", "collection", "trace", "buf", "row", "queue", "bo", "phrase", "append", "buff", "comment", "iter", "block", "escape", "profile", "library", "console", "binary", "quote", "bm", "output", "sb", "message", "pool", "temp", "channel", "length", "ob", "join", "bridge"], "line": ["entry", "code", "ne", "print", "link", "l", "detail", "lin", "source", "header", "eline", "body", "chain", "label", "no", "string", "lines", "stroke", "sequence", "len", "email", "char", "number", "row", "cell", "Line", "ine", "inline", "online", "stay", "nl", "sample", "liner", "comment", "where", "ln", "block", "position", "zone", "iter", "next", "le", "LINE", "range", "log", "member", "point", "lined", "lock", "message", "page", "length", "frame", "text"]}}
{"id1": "11477906", "id2": "16825994", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["readdefaultSettings", "loaddefaultsettings", "loaddefaultSettings", "loaddefaultSetting", "loadDefaultSetting", "loaddefaultValues", "loadDefaultValues", "loadFAULTSetting", "readDefaultValues", "readDefaultSettings", "loadFAULTSettings", "loadDefaultsettings", "readDefaultsettings", "readDefaultSetting", "loadFAULTValues", "readdefaultSetting", "readdefaultValues", "loadFAULTsettings", "readdefaultsettings"], "configFileName": ["configFilenamename", "configFileNames", "configFILEPath", "configFileLocation", "configStreamname", "configPagePath", "configFilenameName", "configFilenameLocation", "configStreamName", "configFilePath", "configFilenameNames", "configfilePath", "confFileNames", "configFILEName", "conffileNames", "confFilename", "configStreamLocation", "configFilenamePath", "conffilePath", "confFilenameName", "configPagename", "confFilePath", "confFileLocation", "configStreamPath", "confFilenamePath", "configfileNames", "configPageNames", "configfileName", "configFILELocation", "configFilename", "conffilename", "confFileName", "configPageName", "configFILEname", "conffileName", "confFilenamename", "confFilenameLocation", "configfilename"], "in": ["inf", "m", "o", "n", "IN", "l", "it", "ad", "al", "inner", "cin", "ins", "doc", "input", "user", "re", "ro", "ind", "rin", "bin", "im", "up", "In", "ini", "is", "ar", "or", "ze", "isin", "e", "init", "con", "info", "mc", "ma", "check", "ai", "t", "gin", "from", "mi", "id", "en", "ain", "run", "inn", "on", "i", "din", "ls", " din", "source"], "out": ["m", "cache", "null", "it", "ins", "user", "io", "client", "sys", "ge", "init", "ot", "con", "w", "t", "file", "ne", "o", "n", "to", "raw", "v", "ex", "store", "at", "os", "over", "up", "Out", "aos", "copy", "une", "handle", "read", "ent", "output", "de", "not", "nt", "oss", "server", "ing", "OUT", "ind", "des", "writer", "off", "check", "port", "can", "all", "en", "OU", "outs", "po", "or", "obj", "are", "res", "ou", "co", "ion", "gc", "log", "auto", "gt", "update", "net", "cn", "conv"]}}
{"id1": "17083703", "id2": "15351863", "code1": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"savaRolePerm": ["sDeleteRolePERm", "sDeleteRoleProm", "sDeleteResourcePerms", "sDeleteRolePerms", "sDeleteResourcePerM", "sDeleteRolePerm", "sDeleteRoleProms", "sDeleteRolePERms", "sDeleteResourcePerm", "sDeleteResourceProm", "sDeleteRoleProperm", "sDeleteRolePERperm", "sDeleteResourcePerperm", "sDeleteRolePerM", "sDeleteResourceProperm", "sDeleteRolePERM", "sDeleteResourceProms", "sDeleteResourceProM", "sDeleteRolePerperm", "sDeleteRoleProM"], "roleid": ["roleoid", "relationids", "rooid", "rolepid", " roleoid", "resourceId", "oleoid", "relationid", "resourceids", " roleId", "roleId", "roid", " rolepid", " roleids", "oleid", " rolename", "oleinfo", "olename", "roleinfo", "resourceid", "relationId", "rolename", "roinfo", "roname", "roleids", "relationpid", "resourcepid", " roleinfo"], "role_perm_collect": ["role_priv_collection", "role_compl_ct", "role_perm_draw", "role_priv2collection", "role_per_cont", "role_priv_Collect", "role_perm2collect", "role_per_coll", "role_perm_ct", "role_per_draw", "role_priv2coll", "role_perm_coll", "role_compl_coll", "role_perm_cont", "role_priv_coll", "role_perm_Collect", "role_perm2Collect", "role_permptdraw", "role_priv2collect", "role_perm2collection", "role_priv2Collect", "role_compl_collect", "role_permptcoll", "role_permptcont", "role_permptcollect", "role_perm_collection", "role_priv_collect", "role_perm2coll", "role_per_collect"], "cp": ["CP", "priv", "cd", "pkg", "cop", "lc", "px", "pd", "wp", "proc", "ctx", "Conn", "c", "jp", "cmd", "cf", "ct", "core", "fp", "tp", "rc", "cr", "ch", "cap", "cb", "cmp", "con", "pc", "cs", " CP", "mp", "mk", "vp", "pp", "ctrl", "cod", "cfg", "cm", "ec", "ps", "cc", "cn", "p"], "conn": ["pg", "pkg", "dial", "rel", "Conn", "req", "msg", "c", "jp", "cf", "client", "ont", "bo", "org", "wd", "act", "nc", "mem", "con", "pas", "connect", " con", "t", "local", " cur", "dt", "n", "ca", " ac", "link", "session", "ctx", "open", "cert", "cmd", "fn", "die", "comm", "gn", "j", "cb", "coll", "handle", " cx", "config", "addr", "pool", "p", "nt", "syn", "gate", "yn", "rn", "ann", "resp", "call", " cc", "ct", "enc", "ssl", "ch", "og", "trust", "cur", "mn", "close", "ain", "conf", "db", "on", "out", "ns", "bind", "ctr", "lang", "wp", "obj", "dc", "col", "tp", "connection", "sql", "co", "sync", "mt", "ce", "dn", "gc", "cfg", "g", "ait", "cc", "cn", "conv"], "rs": ["ds", "RS", "ris", " cs", "rt", "rl", "res", "ro", "re", "os", "rc", " rc", " res", "ls", "cs", " ss", "ri", "rm", "s", "Rs", "ts", "mr", "ps", " ra", "ns", " ls", " ps", "sr"], "pstmt": ["pstyms", "pStbl", "pstmk", "Pstmd", "pstcond", "pstatms", "pputmt", "apStbl", "postsql", "prestmn", " pswmb", "pstatemt", "apstbl", "pstdst", "postmn", " pstmd", " pstms", "pstrmg", "pstdbl", "pstatmt", "Pstat\t", "prestlt", " psttr", " pstatmt", "apStmt", "Pstatmd", "pstart\t", "pstmg", "psttr", " pStmt", "pStst", "pstbl", "pestms", "pst\t", "Pstatmk", "PstatMT", "Pstmt", "apStmb", "prestmt", "Pstsql", "postmd", " pStmb", "pctMT", "pstdmb", " prestmn", "postm", "Pstrs", "pstatlt", "Pstatlt", "Pstlt", " pstmb", "pstmsg", " pststat", "pstrmt", "pstmd", "Pstcond", "pstatrs", "pstlt", "pSTtr", "pstatem", "Pstatrs", "pstsql", "pconstmb", "Pstmg", " pstatm", "pstrm", "prestMT", " pstemb", "Pstatmg", "pstatstat", "pconstm", "prestm", " pstatmn", "pswemb", "Pstm", "pstmn", "pstyemb", "pctmt", "pputmk", "postmt", "Pstatmsg", " presttr", "postmsg", "pstremb", "pstymt", "pStm", "apstst", " pstatmd", "pconststat", "Pstmk", "apStst", "pstatst", "pstatecond", "ptrym", "pstymb", "pswmt", "Pstatmt", "pestmt", " pswemb", "pputm", "pctmd", "pstatmb", "pStmt", "pstst", "pstrmn", "apstmb", "Pst\t", " prestMT", "pststat", "pstmb", "Pstatcond", "pstrmb", "pstrmd", " pswmt", "pstatMT", "pStstat", "prest\t", "pstatmk", "pSTmn", "Pstms", "pputcond", "pestMT", " pstmn", "pstat\t", "pstm", "pstatmd", "pswmb", "pstatmsg", " pStm", "Pstatms", "pstrrs", "pstatsql", "pstartm", "pstartlt", "pstatemk", "pstMT", "pstms", "pSTMT", "pputrs", " prestmt", "pstemb", "pstartmt", "presttr", "pstrs", "pstatmn", "ptrymsg", "ptrysql", "pctms", "Pstatm", "pstrms", "pSTmt", "pstatcond", "pstdmt", "Pstatsql", " pstm", "Pstmsg", "PstMT", "pstatmg", "pStmb", "pestm", "pstatm", "pputmg", " pstMT", "pconstmt", "pstattr", "ptrymt", "pswms", " pswms", "pctm", "pstatbl", " pStstat", "apstmt"], "factory": [" foo", "cfictionary", "fictionary", "tade", " fFactory", "fFactory", "tFactory", "FFactory", "cfFactory", " fade", "tactory", "Fictionary", "cfactory", "fade", "Factory", "tacter", "Facter", "cfoo", "Foo", "facter", " facter", " fictionary", "Fade", "foo"], "op": ["o", " dop", "operation", " operate", "ops", " ep", "Operation", "OP", " cop", " opt", "Op", " act", "oe", " ov", " oper", " opp", " pop", " ip", " operator", " OP", "oper", " operational", " ops", " Operation", " Op", "iop", "p", " co"], "role_perm_ir": ["role_proc_et", "role_permrenet", "role_proc_i", "role_permmmi", "role_permobjyr", "role_permobjir", "role_permrenir", "role_perm_i", "role_permrenier", "role_proc_yr", "role_perm_ier", "role_proc_ir", "role_perm_et", "role_permmmyr", "role_priv_IR", "role_priv_iter", "role_permobjoi", "role_permmmoi", "role_perm_IR", "role_proc_ier", "role_perm_yr", "role_proc_iter", "role_permmmir", "role_permobji", "role_perm_iter", "role_proc_oi", "role_priv_i", "role_permreniter", "role_perm_oi", "role_priv_ir"], "rolePerm": ["olePerm", "olePERmission", "roleParp", "rolePersM", "rolePERmission", "rolePERmn", "olePerperm", "oleParperm", "rolePartm", " rolePerM", "rolePermn", "roleperM", " rolePerp", "rolePartperm", "rolePersl", "roleParg", "rolePERm", "rolePM", "rolePartr", "rolePp", "olePERg", "roleElem", "rolePERp", "oleParm", "roleParm", "rolePc", "roleParM", " roleParm", "roleEleM", "rolePerperm", "roleEleg", "rolePERc", " roleParM", "olePerl", "rolePermission", "roleParc", "rolePerg", "roleLikemn", "roleperl", "olePerg", "roleperm", "roleElemn", "roleLikeM", "rolePERperm", "rolePERM", "rolePerc", "olePERl", "rolePerM", " roleParp", "roleLikeg", "rolePersmission", "oleParg", "rolePerl", " rolePerc", "rolePERr", "olePERm", "olePERmn", "rolePersm", "roleParperm", "olePermission", "olePermn", "roleParr", " roleParc", "rolePERg", "olePERM", "rolePERl", "rolePerr", "oleParr", "rolePartg", "olePerM", "rolepermission", "olePerr", "rolePerp", "roleLikem", "rolePm"]}}
{"id1": "14773782", "id2": "2807585", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" decodeJPPGRasters", " decodeJPEGGrasters", " decodeJPEGRaster", " decodeJPEGPaster", " decodeJPEGraster", " decodeJPEGPater", " decodeJPPGrater", " decodeJPPGrotation", " decodeJPPGrasters", " decodeJPPGRaster", " decodeJPEGrotation", " decodeJPPGRotation", " decodeJPEGRater", " decodeJPEGrater", " decodeJPEGGrotation", " decodeJPEGPotation", " decodeJPEGrasters", " decodeJPEGGraster", " decodeJPPGRater", " decodeJPEGRotation", " decodeJPEGRasters", " decodeJPEGGrater", " decodeJPPGraster", " decodeJPEGPasters"], "IOException": ["ConnectionException", " IOFailure", "ConnectionFailure", "IOFailure", "URIFailure", "IOProblem", "URIProblem", " IOProblem", "URIException", "ConnectionProblem"], "start": ["insert", "rest", "print", "time", "it", "step", "starting", "create", "reset", "wind", "seed", "Start", "base", "open", "birth", "begin", "delay", "end", "trans", "top", "send", "first", "offset", "init", "st", "wait", "t", "from", "read", "set", " started", "started", "initial", "get", "before", "art"], "i": ["m", "multi", "b", "ij", "ci", "ui", "batch", "in", "ex", "it", "gi", "key", "q", "phi", "us", "major", "index", "ind", "im", "c", "name", "ki", "sequence", "ini", "li", "is", "iq", "ski", "gu", "ii", "si", "client", "f", "xi", "bi", "pi", "j", "u", "conv", "x", "me", "init", "info", "request", "counter", "go", "ai", "sim", "s", "mi", "ti", "ix", "exp", "id", "g", "di", "my", "ic", "out", "I", "ie", "qi", "p", "uu"], "url": ["browser", "http", "link", "web", "l", "ll", "xml", "key", "q", "hub", "rel", "el", "res", "string", "location", "external", "char", "ul", "gif", "mail", "row", "dl", "ref", "ur", "nl", "domain", "mount", "URL", "gl", "resource", "pattern", "log", "Url", "job", "id", "host", "r", "lr", "path", "ls", "uri"], "istream": ["iftank", "aststream", "istStream", "iftriver", "ISTram", "ISTub", "isriver", "stStream", "isub", "ISTank", "istsream", "istub", "iftub", "astram", "istabel", "astStream", "iststream", "ISTroll", "istsstream", "astream", "itram", "iftream", "astabel", "ststream", "istsStream", "isream", "itream", "ISTriver", "stabel", "stream", "itroll", "istsabel", "itstream", "ISTstream", "ISTream", "istroll", "istriver", "isank", "istram", "istank", "astroll"], "dec": ["dev", "dis", " enc", "bd", "oct", "deg", "Dec", "desc", "det", "rec", " DEC", "exec", "bec", " Dec", "c", "dc", "des", "da", "decl", "ra", "der", "agg", "enc", "valid", "DEC", "dem", "dig", "disc", "dra", "div", "ko", "draw", "cam", "De", "coll", "dep", "del", "def", "ec", "de", "cor"], "raster": ["braster", " rraphic", "matter", "replreement", "Rraphic", " rasters", "rreement", "Rreement", "ratter", "Raster", "remasters", "rmap", " rastered", " rmap", "rastered", " rast", "bratter", "remraphic", "Ratter", "brastered", "replasters", "mastered", "brast", "Rasters", "mast", "rraphic", "rast", "remaster", " ratter", "rasters", "master", " rreement", "remmap", "Rmap", "replatter", "replaster"], "width": ["ose", "issa", "dim", "orth", "ength", "cale", "step", "tall", "resolution", "fw", "body", "displayText", "window", "padding", "term", "Width", "idth", "shape", "layout", "wid", "strength", "cut", "wa", "write", "weight", "position", "size", "w", "axy", "widget", "const", "sw", "success", "frame", "path", "left", "length", "change", "text", "len"], "height": ["kw", "capacity", "resolution", "alpha", "h", "angle", "grow", "window", "padding", "Height", "volume", "th", "rank", "stroke", "shape", "gravity", "holes", "density", "confidence", "style", "hang", "count", "acity", "inches", "radius", "size", "depth", "power", "dimension", "cision", "frame", "ty", "history", "length", "buffer"], "stop": ["rest", "null", "quit", "it", "step", "ops", "skip", "post", "root", "obj", "no", "term", "status", " Stop", "timeout", "period", "end", "fin", "jump", "ab", "cut", "commit", "est", "pause", "st", "wake", "wait", "counter", "next", "Stop", "gc", "pop", "max", "result", "close", "set", "trip", "success", "update", "enable", "op", "disable", "delete", "termination"]}}
{"id1": "23532405", "id2": "3801655", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"persist": ["remain", "insiste", "remister", "Persiste", "remiste", "Persister", "persiste", "insist", "persain", "remist", "insister", "persister", "insain", "Persist", "Persain"], "ffConfigurable": ["efconfigural", "effConfigurated", "ffRequestorable", "efConfiguring", "ffCerturated", "efConfigural", "ffconfiguer", "ffConfigurationURA", "ffConfurer", "ffConfigurated", "ffConfigorable", "ffLogurable", "ffconfigured", "ffConfigured", "ffRequesturing", "ffConfigutable", "uffconfiguer", "effPortutable", "ffCerturable", "uffconfigurable", "ffCerturate", "ffconfiguring", "ffSpecurate", "ffConfiguring", "ffPortutable", "ffRequestuer", "ffCertural", "efConfigurate", "efconfiguring", "effPorturer", "effConfigurable", "ffConfuer", "effConfigURA", "ffConfutable", "effCerturable", "ffPorturated", "ffSpecuring", "ffConfigurate", "effConfigured", "ffconfigurated", "uffConfigurable", "effPorturated", "uffConfiguer", "ffPorturer", "ffCertURA", "ffSpecural", "ffPorturable", "ffConfigurationurable", "ffCertured", "ffLogurated", "ffconfigorable", "ffconfigurable", "ffRequesturable", "ffConfigurationured", "ffconfigural", "ffCerturing", "ffconfigURA", "efConfigurable", "ffConfigurer", "effCerturated", "ffConfigURA", "effConfigurer", "efconfigurate", "effCertured", "ffconfigurate", "ffSpecurable", "ffConforable", "ffConfuring", "uffconfigorable", "effPorturable", "ffConfigural", "ffConfigurationurated", "uffConfiguring", "ffLogurer", "efconfigurable", "ffLogutable", "effCertURA", "ffConfurable", "uffConfigorable", "ffConfiguer", "effConfigutable", "uffconfiguring", "ffConfurated"], "relativePath": [" relativeFile", "absoluteUrl", "relDir", "relativeUrl", "absoluteDir", "relPath", "relUrl", "relativeRoot", " relativeName", "qualifiedName", "relativeFile", "absolutePath", "relativeDir", "qualifiedPath", "qualifiedDir", " relativeRoot", "qualifiedFile", " relativeUrl", "relRoot", "absoluteName", " relativeDir", "relativeName", "absoluteRoot", "absoluteFile"], "file": ["entry", "rule", "to", "link", "list", "command", "project", "use", "al", "header", "create", "full", "filename", "memory", "play", "user", "store", "string", "issue", "folder", "image", "base", "template", "name", "table", "document", "fil", "f", "ile", "queue", "fp", "class", " File", "e", "work", "dir", "force", "word", "port", "stream", "le", "resource", "File", "local", "handle", "format", "url", "log", "auto", "set", "spec", "view", "output", "db", "lock", "path", "message", "page", "pool", "out", "buffer", "frame", "FILE"], "is": ["ip", "ris", "isi", "in", "js", "bis", "lis", "sis", "ists", "us", "are", "ins", "isa", "im", "ais", "ir", "ires", "its", "IS", "Is", "isin", "iso", "ms", "bits", "ib", "ios", "nis", "xs", "s", "iss", "es", "fs", "iris", "ist", " Is", "isl", "bs", "ic", "isc", "i", "ls"], "os": ["o", "ose", "ui", "pos", "oss", "ops", "los", "oa", "oos", "cos", "us", "oses", "obs", "oS", "des", "io", "Os", "sys", "iso", "ms", "mot", "ot", "OS", "ios", "ols", "ys", "bos", "osi", " Os", "oz", "es", "fs", "bs", "i", "ds", "si", "ls", "ox"]}}
{"id1": "13499897", "id2": "23370621", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"CopyFile": [" CopyDir", " CopyPath", "DownloadPath", "TransferFile", "Downloadfile", "DownloadDir", "TransferPath", "CopyPath", "DownloadFile", "Copyfile", "Transferfile", "TransferDir", "CopyDir", " Copyfile"], "sourcefile": ["srcfile", "sourceFile", "styleFile", "Sourcefile", "srckey", "Sourcepath", "sourceattribute", "ourcekey", "srcFile", "ourceFile", "startpath", "Sourceurl", " sourceFile", " sourceurl", "srcattribute", "startFile", "sourcepath", "ourcefile", " sourcepath", "sourceurl", "startfile", "starturl", "ourceattribute", "sourcekey", "stylekey", "styleattribute", "stylefile", "SourceFile"], "destfile": ["destfilename", "srcfile", "masterpath", "Desturl", "resultpath", "sourceFile", "DestFile", "sourcefilename", "desturl", "destile", "tempFile", "tempfile", " destile", "Destile", "srcFile", "resultfile", "Destfile", "destFile", "resultfilename", "destport", "resultFile", "sourcename", "sourceile", "destpath", " destfilename", "masterFILE", "Destname", "sourceport", " destFile", "sourcepath", " destFILE", " destpath", "tempfilename", "masterfile", "temppath", "Destpath", "sourceurl", "Destfilename", "tempFILE", "masterFile", "destFILE", " destname", " destport", "destname", "srcport", "srcpath", " desturl"], "last": ["Last", "rest", "shadow", "ast", "since", "show", "most", "based", "full", "index", "total", "dist", "lot", "base", "prev", "reverse", "latest", "after", "bottom", "end", "any", "top", "count", "first", "est", "nd", "st", "and", "old", "strip", "size", "master", "pop", "max", "start", "region", "good", "default", "right", "get", "this", "left", "recent", "length"], "parent": ["m", "ip", "prop", "key", "server", "full", "chain", "missing", "pid", "root", "pa", "test", "folder", "p", "child", "padding", "holder", "tip", "older", "parents", "shape", "up", "prefix", "tar", "wrapper", "global", "snap", "unit", "sp", "owner", "dir", "where", "and", "request", "ma", "fat", "mother", "paren", "master", "home", "exp", "part", "point", "def", "params", "fr", "spec", "per", "tmp", "path", "pool", "page", "Parent", "family", "temp", "instance", "tree"], "f": ["m", "v", "b", "l", "alf", "fe", "fw", "h", "tf", "fab", "F", "elf", "c", "fo", "fi", "cf", "rf", "ft", "df", "fp", "fc", "fed", "bf", "fm", "e", "fac", "sf", "af", "w", "file", "local", "fd", "fs", "lf", "part", "fl", "fr", "g", "of", "p"], "srcChannel": ["subChannel", "subchannel", "sqchannel", "curConnection", "instchannel", " srcchannel", "srcConnection", "curChan", "ctrChain", "sourceChan", "srcchannel", "sourceButton", " srcChain", "instButton", "srcChan", "ctrChannel", " srcButton", "curchannel", " srcChan", "curChannel", "instChan", "srcCase", "rcChannel", "subPanel", "ctrChan", "instChannel", " srcCase", " srcPanel", "sqCase", "rcButton", " srcConnection", "rcConnection", "ctrButton", "sourceChannel", "sourcechannel", "srcPanel", "subCase", "rcChain", "sqPanel", "sqChannel", "rcChan", "srcChain", "rcchannel", "srcButton"], "dstChannel": [" dotConnection", "dbrChan", "deltChannel", "cdistChannel", "destChan", "dotChannel", "dndCh", "dblCh", "dbrchannel", "drtChannel", "deltButton", "cdstChannel", "dotConnection", " dotchannel", " dstchannel", "dndChan", "dltChan", "deltChan", "distCategory", "drtCh", "ddrChan", " dotChannel", "ddrChannel", "dndCategory", "dltChannel", "ddrchannel", "cdstCategory", "distButton", "cdstCh", "dstCh", "cdistButton", " dstConnection", "dblButton", "destCh", "destChannel", "distCh", "dblChannel", "ddrConnection", " dstChan", "cdstButton", "cdistCategory", "dndButton", "dblChan", "dltButton", "destButton", "dotChan", "dstchannel", " dotChan", "dbrConnection", "dotchannel", "dstConnection", "deltCh", "drtButton", "dstButton", "dltCh", "distChannel", "dstCategory", "dstChan", "drtCategory", "dndChannel", "dbrChannel", "cdistCh"]}}
{"id1": "14688886", "id2": "807346", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "label": 1, "substitutes": {"populateResources": ["populatesResource", "populatesFiles", "populatedReferences", "PopureResources", "popureResource", "populateFiles", "populateReferences", "popureReferences", "popureFiles", "PopulateFiles", "populatedResources", "populatedFiles", "PopulateResources", "populatedResource", "popureResources", "PopureReferences", "PopureResource", "PopulateResource", "populateResource", "populatesResources", "PopureFiles", "PopulateReferences", "populatesReferences"], "templates": ["sequplates", "sequporary", "filmen", "tenplates", "teniles", "filples", "Temports", "sequeters", "tctions", "memples", "teters", "memeters", "temples", "timplates", "Templates", "temiles", " temctions", "Temples", " temables", " temiles", "filports", "tenctions", "tmples", "typlates", "tmplates", "tenables", "temables", "temports", "tmports", "memplates", "Temmen", "sequples", "tiles", "temporary", "tyables", "typles", "temctions", "timples", "tples", "temmen", "timeters", "tplates", "tmeters", "filplates", "temeters", "memables", "tmporary", "tables", "tyeters", "timporary", "tmmen"], "url": ["browser", "http", "b", "n", "entry", "m", "link", "rect", "pl", "web", "l", "ll", "html", "rl", "address", "key", "rel", "res", "string", "location", "term", "p", "base", "name", "li", "char", "item", "f", "row", "mail", "ssl", "dl", "u", "ref", "ur", "nl", "e", "mount", "URL", "resource", "file", "gl", "handle", "pattern", "ml", "Url", "sl", "get", "r", "mb", "path", "a", "uri"], "fileName": ["fname", "fileTime", "templateString", "nameParent", "FileBody", "fileLoad", "moduleName", "FILEname", "FilePart", "urlPath", "urlKey", "fBody", "ileName", " filename", "fileKey", "moduleType", "fileLine", "templatename", "ilePath", "ileFull", "moduleTitle", "templatePath", "resourceKey", "tileLine", "blockTime", " fileLoad", "Filename", "filenameName", "FileName", "resourceName", "familyname", " fileFull", "ilePart", "resourceTitle", "FileFull", "FileFamily", "urlFamily", "fName", "moduleKey", "filename", "fileFull", " fileKey", "ileLine", "fileParent", "fileString", "tileCopy", "tileName", "FILEName", " fileTime", "namePart", "namename", "nameName", "FilePath", "fileType", "familyName", " fileParent", "FileString", " fileType", "FileKey", "filePath", "familyLoad", "fileFamily", "fPath", "FILELine", "familyTime", "filenamePart", "tilename", " filePath", "fileTitle", " filePart", "urlName", "blockName", "filenamename", "filePart", "resourceType", " fileString", "fileBody", "templateName", "blockLoad", "fileCopy", "ilename", " fileBody", "FILECopy", "blockname", "filenameParent", "ileCopy", " fileFamily", " fileTitle"], "templateResource": ["templateReference", " templateEntry", " templateProperty", "TemplateEntry", "TemplateReference", "templateProperty", "componentResources", "documentResource", "TemplateResource", "templateEntry", "componentReference", " templateReference", "resourceRole", "templateRole", "componentResource", " templateRes", "templateResources", "resourceEntry", "resourceRes", "documentRole", "TemplateResources", " templateResources", "resourceProperty", "TemplateRes", "resourceResource", "TemplateProperty", "componentRes", " templateRole", "templateRes", "documentRes"], "is": ["ris", "isi", "in", "bis", "lis", "sis", "isa", "us", "ins", "are", "ir", "rs", "ais", "im", "os", "sels", "its", "IS", "sys", "Is", "isf", "iso", "\u00eds", "ios", "nis", "ri", "iss", "es", "fs", "iris", "as", "fr", "isl", "rys", "bs", "ic", "isc"], "strBuff": ["StrBuffer", " strbuff", "brBuffer", "arrComb", "brBu", "arrFac", "arrBuffer", "strBas", "arrBuff", "strFac", "stringBuff", "strBuffer", " strFac", " strBuffer", "stringBuffer", "StrFac", "brBuff", "drBu", "StrBuff", " strComb", "arrBas", "arrbuff", "brComp", "drBuffer", "stringComb", "stringBas", "strComb", "strBu", " strComp", " strBas", "strbuff", "drBuff", " strBu", "drComp", "Strbuff", "strComp"], "br": ["b", "BR", "pr", "bh", "tr", "ctr", "bd", "ber", "wr", "yr", "dr", "bt", "kr", "rb", "bp", "shr", "bi", "buf", "bn", "ch", "cr", "bf", "bg", "bro", "er", "next", "mr", "vr", "bc", "fr", "hr", "bm", "bl", "r", "lr", "gr", "bs", "sr", "Br"], "str": ["n", "print", "pr", "list", "pt", "err", "ctr", "tr", "Str", "St", "chain", "obj", "res", "string", "dr", "msg", "seq", "name", "arr", "cert", "text", "cont", "cr", "sp", "st", "draw", "cs", "STR", "coll", "t", "sts", "s", "del", "sl", "set", "fr", "spec", "bl", "g", "r", "ocr", "gr", "stable", "ust", "txt", "p"], "images": [" pictures", "reports", "frames", " Images", "types", "Textures", "apps", "blocks", "times", "pins", "uploads", "ins", "views", "image", "ids", "assets", "rooms", "ages", "media", "photos", "vs", "eps", "thumbnails", "boxes", "actions", "ms", "files", "resources", "atts", "Images", "videos", "eds", "scripts", "xs", "names", " photos", "versions", "games", "items", "modules", "ups", "arms", "styles", "faces", "amps", "ims", "raphics", "pages"], "i": ["m", "ip", "it", "ei", "key", "y", "ini", "io", "bi", "pi", "me", "mi", "ix", "_", "get", "hi", "v", "n", "index", "im", "ki", "ii", "gu", "u", "j", "id", "x", "I", "xi", "p", "Exception", "ci", "ui", "info", "ai", "sim", "def", "di", "si", "ie", "ij", "multi", "http", "gi", "ami", "phi", "us", "mu", "status", "name", "li", "cli", "this", "my", "ti", "qi"], "img": ["m", "ij", "att", "mg", "md", "pg", "html", "pkg", "ami", "obj", "iam", "gd", "av", "medium", "image", "im", "amp", "li", "f", "Image", "gm", "gif", "aug", "buf", "j", "small", "src", "fm", "bg", "jpg", "div", "anim", "fig", "file", "mp", "mk", "pic", "bl", "g", "r", "png", "tmp", "a", "imp", "p"], "imgProperty": [" imgProp", " tmpProp", "imageProp", "imageProperty", " imgImage", "imgPro", "imagePro", " tmpImage", " tmpPro", " tmpProperty", "imgImage", " imgPro", "imgProp", "imageImage"]}}
{"id1": "5237257", "id2": "13891080", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"download": [" downloads", "Download", "paste", " restore", " retrieve", "load", " drop", "open", " browse", " seek", " zip", "export", " upload", " recover", "write", "init", "save", "upload", "copy", "file", "dump", " downloaded", " checkpoint", " Download", "get", " downloading", " dump", "delete"], "fileName": ["imagePath", "FileTime", "filename", "fileTime", "projectPath", "FILEFilename", "resourceType", "resourceTime", "fileFilename", "FILEName", " fileTime", "FileName", "resourceName", " fileFilename", "FILEPath", "resourcePath", "FILEname", "projectName", "FilePath", "fileType", " fileType", "projectFilename", " filename", "projectname", "imageName", "FileType"], "filePath": ["ilePath", "FileP", "fileUrl", "FILEStart", "languageId", "fileId", " fileId", " filepath", "FILEName", "fileStart", "resourceName", "FileName", "ileStart", "FILEUrl", "resourcePath", "FILEPath", "languagePath", "FilePath", "FileId", "fileP", "ileName", "filepath", "resourcepath", "languageName", "FILEP", "FILEpath", "resourceUrl", "ileP", "FileStart", " fileUrl"], "in": ["inf", "o", "m", "n", "IN", "l", "it", "inc", "al", "inner", "cin", "ins", "el", "input", "re", "ind", "one", "rin", "bin", "im", "login", "up", "inside", "ini", "is", "In", "io", "f", "ar", "or", "pi", "isin", "co", "init", "st", "con", "iter", "ln", "win", "ai", "gin", "from", "local", "mi", "read", "id", "en", "ain", "inn", "on", "r", "sin", "net", "din", "i", "ie", "nin"], "out": ["o", "n", "to", "v", "conn", "null", "oss", "ex", "it", "inner", "cos", "obj", "user", "no", "OUT", "na", "at", "os", "name", "up", "Out", "io", "ou", "aos", "client", "end", "or", "outer", "sys", "we", "conv", "ch", "co", "write", "note", "con", "ion", "w", "nin", "t", "file", "boot", "ent", "gt", "can", "op", "OU", "output", "po", "outs", "on", "ns", "net", "i", "cn", "ne", "not", "p", "nt"]}}
{"id1": "4973095", "id2": "14773780", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "label": 0, "substitutes": {"url": ["browser", "http", "pl", "print", "link", "null", "web", "l", "ld", "conn", "ll", "html", "cp", "rl", "xml", "address", "bad", "hub", "el", " URL", "ado", "string", "location", "parser", "hl", "lb", "base", "loc", "open", "io", "email", "www", "str", "mail", "ssl", "dl", "org", "u", "build", "ur", "nl", "lim", "connection", "mount", "con", "https", "URL", "au", "gl", "file", "impl", "iol", "log", "Url", "job", "sl", "cl", "lr", "r", "ol", "util", "out", "ob", "ls", "uri"], "f": ["d", "b", "n", "v", "fa", "o", "l", "full", "h", "tf", "tif", "F", "c", "y", "fo", "ff", "fn", "fi", "cf", "form", "df", "fp", "fc", "j", "bf", "fort", "fac", "fb", "sf", "stream", "w", "file", "t", "s", "fd", "log", "fs", "lf", "fl", "fr", "out", "i", "p"], "by": ["browser", "b", "report", "then", "it", "BY", "bad", "via", "re", "bin", "y", "reg", "io", "ly", "fully", "sys", "buff", "serv", "por", "where", "how", "with", "By", "each", "from", "using", "ody", "as", "g", "of", "out", "you"], "uc": ["uh", "usc", "uci", "ac", "lc", "oc", "UC", "uch", "ub", "c", "chu", "loc", "asc", "anc", "cus", "stud", "ul", "fc", "u", "nc", "rc", "cas", "ud", "eu", "cmp", "con", "pc", "unc", "mc", "cur", "ux", "nic", "userc", "auc", "gc", "soc", "cl", "bc", "sc", "roc", "ec", "ucc", "ocr", "uca", "cc", "cu", "tc", "uu"]}}
{"id1": "13122204", "id2": "23088292", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unzipModel": ["unarchiveImage", "UnarchiveModel", "unlateModel", "Unzipmodel", "unarchiveModel", "uncodeModule", "unlateImage", "uncodeImage", "UnzipImage", "unlatemodel", "unlateModule", "unarchiveModule", "UnzipModel", "unarchivemodel", "uncodemodel", "unzipImage", "uncodeModel", "Unarchivemodel", "UnarchiveImage", "unzipModule", "unzipmodel", "UnzipModule", "UnarchiveModule"], "filename": ["n", "FIL", "ename", "source", "til", "download", "location", "directory", "journal", "username", "name", "mson", "fn", "fil", "river", "Filename", "fp", "subject", "sql", "nl", "title", "jpg", "dra", "txt", "origin", "ln", "println", "file", "original", "nm", "nil", "wl", "kl", "fle", "FN", "ivo", "output", "path", "stem", "FILE", "SourceFile"], "tempdir": ["TempDir", "tempDIR", "temdirectory", "tmpDIR", "testfolder", "tempfile", "temDir", "tmpdir", " tempDir", "temDIR", "tempdirectory", "Tempdir", "temfolder", "tmppath", "Tempdirectory", " tempfile", "Tempfile", "tempath", "tmpfile", " tempdirectory", "tempfolder", "testdir", "tempDir", "temdir", "temppath", "testDir", " tempDIR", "tmpDir", "tmpdirectory", "tmpfolder", "testpath"], "dest": ["dev", "generated", "rest", "pos", "comb", "null", "tr", "ctr", "dat", "sum", "test", "target", "obj", "inv", "desc", "store", "dist", "bin", "des", "dc", "loc", "table", "document", "decl", "Dest", "writer", "nom", "cont", "trans", "send", "usr", "est", "src", "write", "st", "pipe", "origin", "ptr", "peer", "port", "stream", "slave", "master", "result", "del", "coord", "foreign", "tail", "deep", "default", "output", "tmp", "nt", "temp", "display", "out", "buffer", "parent", "source"], "fis": ["los", "lis", "fjs", "ifos", "flis", "ifatis", "li", "zatis", "fi", "fatis", "fli", "zjs", "ifis", "fljs", "ljs", "flos", "flatis", "ifi", "zos", "zi"], "BUFFER": ["BLOUNT", "MAXBuffer", "MAXOUNT", "BufferBuffer", "BLBER", "MAXBER", " BUFR", "CUBuffer", "BUFR", "LOCKBER", " BUOUNT", "CUFR", "BFFER", "MAXFFER", " BUULT", "BABER", "LOCKBuffer", "BLBuffer", "LOCKFFER", "BUOUNT", "BufferBER", "FFERBuffer", "BUBER", "BAOUNT", " BUBuffer", " BUBER", "BufferFFER", "BAULT", "BUBuffer", "FFERFFER", "BAFFER", "BOUNT", "BufferMT", "BBER", "CUFFER", "BUULT", "FFERBER", "BULT", "LOCKFR", "FFERMT", "BUMT", "BLFFER", " BUMT", "CUBER"], "zis": ["zris", "ozis", " zi", "ozi", "zees", "ziis", "fiss", "zoneits", " zris", " zes", "Zos", "xis", "zoneiss", "ziIS", "zeits", "zoneris", "fi", " zits", "oziss", " zip", "xiss", "xos", " zos", "zios", "zeIS", "ziss", "zoneis", "zIS", "zits", "zeiss", "Zis", "Zi", "zes", "Ziss", " ziss", "zeris", "zies", "fip", "zip", "zeis", "zos", " zIS", "ozip", "zeos", "xi", "zi"], "entry": ["jar", "link", "record", "source", "header", "key", "jo", "chain", "pe", "index", "system", "image", "name", "table", "card", "char", "cell", "row", "ze", "connection", "e", "comment", "element", "enter", "ce", "word", "je", "escape", "file", "existent", "se", "zo", "result", "log", "piece", "ent", "part", "member", "def", "match", "inter", "zip", "Entry", "way", "or", "ie", "ry", "item", "nt"], "count": ["n", "acc", "cache", "code", "batch", "ctr", "OUNT", "num", "amount", "sum", "found", "call", "index", "total", "child", "base", "cond", "c", "ct", "f", "core", "number", "cell", "cont", "common", "force", "comment", "Count", "size", "counter", "check", "ce", "add", "start", "max", "read", "cloud", "part", "ount", "current", "all", "match", "nb", "nt", "page", "cc", "length", "buffer", "z", "len"], "data": ["d", "n", "batch", "raw", "cache", "zero", "step", "dat", " DATA", "rel", "window", "image", "accept", "area", "table", "str", "DATA", "ATA", "dl", "valid", "ata", "sample", "bytes", "dec", "size", "results", "next", "format", "value", "mat", "result", "part", "all", "content", "output", "message", "out", "done", "buffer", "text", "p"], "fos": [" foes", "los", "foes", "fOS", "Foss", "Fios", " fios", "vos", "Foes", "voss", "fios", "Fos", " foss", "lOS", "loss", "foss", "FOS", "lios", "voses", "Foses", " fOS", " foses", "foses", "voes"]}}
{"id1": "21491791", "id2": "12004824", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) {\n        HttpResponse response = null;\n        try {\n            HttpParams httpParams = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParams, maxTime);\n            HttpConnectionParams.setSoTimeout(httpParams, maxTime);\n            httpclient = new DefaultHttpClient(httpParams);\n            response = httpclient.execute(httpRequest);\n            maxTime = 15000;\n        } catch (Exception e) {\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"run": ["su", "command", "use", "execute", "test", "call", "system", "process", "exec", "name", "cmd", "runs", "un", "running", "unit", "runner", "work", "par", "fun", "Run", "don", "eval", "pre", "exit", "apply"], "input": ["http", "partial", "parse", "print", "feed", "in", "back", "it", "background", "xml", "inner", "address", "data", "hub", "index", "system", "audio", "action", "image", "state", "table", "Input", "io", "form", "client", "json", "cont", "context", " inputs", "active", "upload", "request", "info", "iter", "stream", "file", "from", "local", "internal", "start", "read", "config", "initial", "hello", "view", "history", "before", "out", "text", "select", "readable", "source"], "output": ["o", "generated", "print", "web", "hidden", "command", "network", "header", "data", "four", "target", "filename", "memory", "directory", "response", "image", "admin", "table", "ou", "io", "latest", "oe", "external", "outer", "export", "connection", "write", "column", "put", "block", "port", "ilo", "stream", "format", "file", "log", "result", "config", "exit", "update", "success", "console", "binary", "Output", "net", "display", "out", "you", "text", "source"], "reader": ["entry", "rw", "in", "data", "inner", "Reader", "proc", "controller", "ro", "reading", "system", "parser", "window", "dr", "rar", "rx", "table", "builder", "wrapper", "handler", "client", "worker", "row", "usr", "context", "ter", "owner", "draw", "iter", "manager", "er", "stream", "iterator", "resource", "file", "driver", "loader", "read", "penter", "r", "readable"], "writer": ["rw", "wire", "network", "writing", "server", "adder", "target", "processor", "ser", "store", "window", "holder", "Writer", "builder", "wrapper", "handler", "client", "worker", "outer", "connection", "yard", "ter", "write", "writ", "caster", "draw", "pipe", "riter", "writers", "manager", "word", "println", "w", "iterator", "written", "file", "driver", "service", "handle", "loader", "widget", "creator", "close", "wrote", "storage", "variable", "penter", "player", "out"], "pump": ["pumps", "peump", " pong", " pumper", "pmp", "peumps", "Peter", "Pong", "prump", "Pump", " pamp", " pipe", "peter", " pUMP", " pumps", " pmp", " peter", "camp", "Podge", "deter", "Pmp", "Pamp", "PUMP", "damp", " podge", "podge", "cumper", "pipe", "dumper", "pemp", "Pumps", "psumper", "Pumper", "pamp", "psipe", "pUMP", "dump", "cump", "psamp", "prong", "psump", "cUMP", "pripe", "pumper", "pong", "prodge", "peumper", "Pipe"], "counter": ["timer", "code", "zero", "record", "key", "hash", "controller", "loop", "total", "term", "ounter", "collection", "random", "client", "average", "radius", "peer", "loader", "const", "page", "current", "continue", "time", "inner", "recorded", "amount", "second", "memory", "responsible", "index", "sequence", "description", "currency", "row", "common", "column", "console", "entry", "batch", "walker", "pointer", "unique", "system", "Counter", "clock", "cell", "context", "phrase", "vector", "buster", "encrypted", "message", "history", "parent", "condition", "book", "ctr", "thread", "processor", "card", "frequency", "outer", "number", "seen", "container", "count", "ter", "scope", "comment", "cookie", "created", "conv"], "buffer": ["b", "batch", "Buffer", "command", "header", "data", "key", "address", "uffer", "base", "table", "sequence", "document", "uf", "buf", "row", "queue", "context", "phrase", "buff", "bytes", "block", "vector", "size", "value", "result", "binary", "message", "length", "text", "source"], "off": ["ip", "att", "aff", "pos", "offs", "ap", "oa", "oct", "no", " OFF", "ff", "cmd", "after", "end", "offer", "un", "OFF", "offset", "Off", "hand", "origin", "ow", "now", "fun", "eff", " Off", "set", "def", "op", "of", " offset", "Offset", "before", "art", "shift"], "len": ["pos", "val", "l", "ld", "ll", "elt", "body", "rel", "cond", "lon", "line", "end", "fin", "buf", "enc", "lvl", "offset", "vol", "lp", "compl", "nl", "mem", "bf", "alt", "lan", "bytes", "ln", "vec", "size", "fun", "le", "coll", "eff", "written", "mat", "pent", "wl", "lf", "del", "kl", "Len", "fl", "en", "all", "cl", "lib", "length", "mult", "ls"], "rd": ["d", "rw", "RD", "ld", "cd", "md", "rn", "rt", "rl", "bd", "rh", "adr", "dr", "ind", "rs", "rand", "rb", "rod", "dd", "red", "rc", "cr", "nd", "udd", "dig", "dra", "ptr", "rez", "ri", "mn", "rid", "rr", "ard", "mr", "sd", "ird", "xd", "hr", "R", "r", "lr", "sr"]}}
{"id1": "19849797", "id2": "21092340", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", " cpfile", "copyfile", " cpFiles", " copyFiles", "transferStream", "copyFiles", "copyStream", " cpStream", " cpFile", "transferFiles", "transferfile", " copyStream", " copyfile"], "sourceFile": ["srcfile", " sourcePage", "sourcePath", "ourcePath", "srcFile", " sourcefile", "ourceFile", "srcPage", "sourcePage", " sourcePath", " sourceLine", "ourceLine", " sourceField", " sourceTable", "sourcefile", "srcLine", "srcPath", "srcTable", "sourceTable", "ourcefile", "ourceTable", "sourceField", "ourceField", "srcField", "ourcePage", "sourceLine"], "destFile": [" destFiles", "datFile", "srcFolder", "DestPath", "DestFile", " destPlace", "destPath", "datPlace", "declFile", "DestFilename", "srcFile", "datFiles", "destPlace", " destPath", "declEntity", "declDir", "restFiles", "optFolder", "optFilename", "restPlace", "srcDir", " destFilename", "DestFiles", "declFolder", "datFilename", "DestDir", "destDir", "optEntity", "srcPath", "restFile", "destFolder", "srcEntity", "srcFiles", "destFiles", "destEntity", "restFilename", "destFilename", "optFile", " destDir", "optPath", "optDir"], "source": ["parse", "scale", "in", "back", "use", "create", "cause", "inner", "SOURCE", "body", "show", "missing", "target", "input", "store", "index", "reader", "image", "load", "table", "sequence", "force", "attribute", "standard", "char", "check", "style", "OURCE", "subject", "send", "owner", "src", "scope", "sample", "init", "score", "comment", "none", "ource", "origin", "iter", "copy", "Source", "ce", "proxy", "stream", "search", "resource", "slave", "from", "service", "iterator", "se", "series", "start", "result", "note", "local", "query", "update", "match", "console", "spec", "component", "pose", "shell", "before", "channel", "ie", "parent"], "destination": [" destificate", "restination", "destation", "descation", "decinated", "Destificate", "separation", " destment", "descinator", "Destination", "Destation", "veration", "descination", "destinate", "separination", " destined", "decined", "restinate", "Destinated", "destinator", "verination", "destined", " destation", "Destment", " destinate", "terminination", "termininated", "restinator", "destinated", "decination", "destificate", "verificate", " destinator", "verinated", "separment", "restinated", "terminined", "Destinator", "separinated", "descinate", "decinate", "noninate", "destment", " destinated", "termininate", "noninated", "noninator", "Destinate", "nonination"]}}
{"id1": "693636", "id2": "20414923", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "label": 1, "substitutes": {"createEmptyCart": ["createZeroCart", " createNewOrder", "createZeroProduct", "createZeroOrder", "createThisProduct", " createNewTransaction", "createEmptyOrder", "createNewCart", "createThisCart", "createNewTransaction", "createZeroTransaction", "createEmptyTransaction", "createThisOrder", "createThisTransaction", " createNewCart", "createNewProduct", " createEmptyTransaction", " createEmptyProduct", "createEmptyProduct", " createEmptyOrder", "createNewOrder", " createNewProduct"], "SHOPPING_ID": ["SHOPPINGIdNAME", "SHOPPINGIdVID", "SHOPPINGITNUM", "SHOPPINGINGNUM", "SHOPPING_VID", "SHOPPAP_IDS", "SHOPPING_NUM", "SHOPPINGITID", "SHOPPOT_ID", "SHOPPINGINGId", "SHOPPOT_IDs", "SHOPPINGINGID", "SHOPPAP_Id", "SHOPPTING_NAME", "SHOPPING_IDS", "SHOPPAP_UID", "SHOPPTING_VID", "SHOPPINGPID", "SHOPPOT_NUM", "SHOPPINGIDURL", "SHOPPINGITIDs", "SHOPPTINGIDVID", "SHOPPINGPNUM", "SHOPPTINGIDNAME", "SHOPPTINGIDURL", "SHOPPINGPUID", "SHOPPTING_ID", "SHOPPOT_UID", "SHOPPINGVALid", "SHOPPIP_ID", "SHOPPTING_URL", "SHOPPINGITUID", "SHOPPINGIDNAME", "SHOPPINGPIDs", "SHOPPINGINGIDs", "SHOPPOTINGIDs", "SHOPPING_UID", "SHOPPINGIDVID", "SHOPPINGINGIDS", "SHOPPINGIDId", "SHOPPAP_ID", "SHOPPOTINGUID", "SHOPPING_Id", "SHOPPING_URL", "SHOPPINGVALID", "SHOPPINGIdURL", "SHOPPINGVALUID", "SHOPPOTINGNUM", "SHOPPING_IDs", "SHOPPING_id", "SHOPPIP_UID", "SHOPPINGINGUID", "SHOPPINGIDIDS", "SHOPPOTINGID", "SHOPPING_NAME", "SHOPPINGIDID", "SHOPPIP_id", "SHOPPINGIdID", "SHOPPINGIDUID", "SHOPPTINGIDID"], "con": ["ca", "conn", "ex", "cat", "pg", "cp", "dial", "cos", "ctx", "Conn", "re", "c", "xc", "cons", "open", "cf", "col", "ct", "client", "un", "cont", "bo", "fc", "connection", "bon", "ch", "co", "nc", "rc", " conn", "pc", "ln", "mc", "cur", "win", "com", "connect", "coll", "CON", "ran", "gc", "soc", "ctrl", "const", "can", "cover", "en", "ain", "conf", "cal", "ren", "po", "pen", "db", "pool", "cc", "cn", "conv", "Con"], "insert_cart": ["entry_progress", " insert_cod", "insertPcontroller", " insert2pt", "insertingstart", " insert2quant", "insert_article", "insert2pt", "insertPTcart", "insertMemart", "insert_progress", "entryMemart", "insertMemarticle", " insert_art", "entryMemarticle", "insert___controller", "import_pt", "insert_pot", "insert2pot", "insert2cart", "insertMemcart", "insert2article", "insertptcart", "insert2art", "insertingcart", "insertptquant", " insert_pt", "insertMemprogress", "insert2start", "insertPpt", " insert_start", "insertTheprogress", "insertingpt", "insertThearticle", "insertPcart", " insert2start", "insert_controller", " insert2art", "insertPTart", "entry_art", "insert_quant", "import_pot", "import_controller", "insert_start", "insertPTcod", "insertTheart", "insert___cart", "entry_article", "entryMemprogress", "insertptcod", "import___controller", " insert2cod", "insertPTquant", "import___pt", "insert_pt", "insert2controller", " insert_quant", "import___cart", "insert2cod", "insertThecart", "insert___art", "import_Cart", "insert___pt", "import_cart", "insert2quant", "insertingart", " insert2cart", "insertptart", "insert2progress", "insertPart", "insert_Cart", "import_art", "insert_cod", "entry_cart", "insert_art", "import___art", "insert2Cart", "entryMemcart"]}}
{"id1": "5035872", "id2": "21608109", "code1": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"copyFile": ["deleteFrame", "copyfile", " cpfile", " duplicateFrame", "deleteDirectory", " duplicatefile", " duplicateFile", " duplicateDirectory", " cpFrame", " cpFile", "copyDirectory", " cpDirectory", "deletefile", "copyFrame", "deleteFile"], "src": ["http", "usc", "in", "ctr", "rt", "rl", "sec", "rel", "ins", "input", "ser", "via", "req", "rs", "rx", "loc", "iv", "ipl", "str", "img", "sys", "usr", "sv", "sel", "rc", "init", "st", "cur", "sf", "inst", "from", "start", "sit", "sc", "sb", "bs", "sur", "sr", "txt", "sq", "source"], "dst": [" dest", "Ddest", " dost", "dnd", "bst", "Dest", "ldest", "lnd", " ddest", "dost", "ddest", "bnd", "bdest", "Dst", "lst", "Dost", "Dnd", "bost", " dnd", "dest", "lest"], "inChannel": ["inputConnection", "inputChan", "cinClient", "oinScope", "cinListener", "inputColumn", "InChan", " inConnection", " inchannel", "INConnection", "incCh", "incChannel", "incColumn", "INchannel", "InChannel", "inputClient", "inchannel", "oinCommand", "inMonitor", " inScope", "oinSlot", "insideListener", "innerMonitor", " inStream", "insideChannel", "INChan", "inConnection", "INChannel", "inputchannel", "innerChannel", "inStream", "inChan", "inCh", "cinChan", " inCh", "outChan", "inCommand", "inScope", "inputChannel", "inAddress", "Inchannel", " inAddress", "outchannel", "cinChannel", " inChan", "innerCh", "inSlot", "incChan", "cinColumn", "inColumn", "incMonitor", " inCommand", " inSlot", "oinChannel", "inClient", "InConnection", "outStream", "inListener", " inListener", "insideAddress", "INStream", "incClient", "cinAddress", " inMonitor", "insideChan"], "outChannel": ["cosMachine", "clientchannel", " outCh", "canchannel", "newCh", "netChannel", "inchannel", "netchannel", "cosChan", "canCategory", "exChan", "netChan", " outConnection", "inConnection", "outputchannel", "inMachine", "Outchannel", "inChan", "inCh", "outCh", "outChan", "newChannel", "inCategory", "outConnection", "exChannel", "outchannel", "cnChan", "OutConnection", " outchannel", "outputChannel", "canChan", "OutChan", "outputConnection", "coschannel", "clientChannel", "outCategory", "clientChan", " outChan", "newConnection", "OutChannel", "exMachine", "cnCh", "outMachine", "outputChan", "netConnection", "outputCh", "cosChannel", " outCategory", "cnChannel", "canChannel", "exchannel", "cnCategory", "clientCategory", "newChan"], "result": ["su", "report", "rance", "goal", "zero", "continue", "duration", "know", "Result", "perm", "found", "res", "bool", "date", "flag", "journal", "status", "response", "answer", "table", "description", "cert", "details", "die", "feature", "cont", "exist", "ret", "valid", "first", "runner", "comment", "true", "results", "same", "value", "complete", "integer", "profile", "false", "reason", "successful", "success", "there", "match", "params", "relation", "product", "event", "region", " Result", "out", "done"]}}
{"id1": "8747840", "id2": "11377441", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" Copy", "link", "csv", "cat", "cp", "create", "download", "paste", "Copy", " replicate", "clip", "transfer", "load", " cp", "write", "save", "upload", "move", "clone", "sync", "add", "gc", "map", "read", " copying", "delete", "slice", " mirror"], "src": ["syn", "ctr", "pkg", "sec", "rel", "ins", "input", "via", "ser", "obs", "req", "rs", "rx", "iv", "ipl", "cont", "img", "sys", "usr", "rc", "init", "st", "Source", "sf", "inst", "cur", "urg", "from", "start", "sit", "sc", "sb", "sin", "bs", "sur", "sr", "txt", "sq", "source"], "dest": ["d", "way", "rest", "null", "test", "deg", "target", "dist", "mm", "th", "req", "self", "des", "loc", "decl", "Dest", "nw", "end", "nom", "cont", "trans", "usr", "pub", "est", "st", "origin", "pas", "https", "opt", "mk", "master", "del", "sit", "gt", "spec", "good", "tmp", "nt", "temp", "orig", "source"], "in": ["inf", "IN", "inc", "it", "al", "inner", "cin", "ins", "input", "mm", "ind", "rin", "im", "bin", "up", "inside", "In", "ar", "ze", "isin", "rc", "init", "con", "info", "old", "ln", "iter", "ai", "from", "impl", "gin", "id", "en", "ain", "inn", "on", "ic", "i", "din", "source"], "out": ["o", "n", "to", "dis", "conn", "oss", "ex", "it", "err", "inner", "sum", "obj", "res", "OUT", "at", "bin", "os", "over", "ou", "io", "Out", "aos", "writer", "client", "by", "end", "outer", "sys", "conv", "ch", "write", "co", "ot", "con", "t", "auto", "gt", "can", "en", "g", "output", "outs", "on", "net", "ne", "not", "p", "nt"], "buf": ["b", "batch", "aka", "gen", "bh", "Buffer", "prop", "tab", "cat", "pkg", "data", "mu", "seq", "msg", "stab", "arr", "used", "uf", "rb", "cmd", "bar", "col", "bag", "str", "bed", "queue", "conv", "ref", "fg", "br", "buff", "cap", "cb", "box", "bytes", "vec", "block", "fb", "cam", "cv", "log", "bl", "good", "db", "mb", "Buff", "bs", "temp", "buffer", "bus"], "c": ["d", "m", "b", "n", "ca", "ci", "cache", "ac", "code", "l", "cd", "cp", "lc", "k", " C", "cos", "call", "dc", "cf", "ct", "uc", "cont", "count", "fc", "nc", "rc", "cr", "co", "ch", "cb", "unc", "cu", "cs", "mc", "ce", "dec", "t", "gc", "cc", "jc", "cod", "bc", "C", "cm", "conf", "ec", "a", "i", "z"]}}
{"id1": "19738435", "id2": "3375724", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["link", "create", "xml", "proc", "arse", "parser", "process", "transform", "load", "shape", "document", "replace", "layer", "json", "pair", "build", "request", "format", "resource", "handle", "file", "construct", "se", "service", "read", "match", "slice"], "url": ["browser", "http", "link", "conn", "web", "l", "ll", "xml", "address", "q", "el", "input", "string", "location", "term", "parser", "base", "name", "loc", "document", "open", "char", "client", "localhost", "str", "abs", "ssl", "dl", "u", "ref", "build", "ur", "nl", "sql", "mount", "https", "URL", "resource", "file", "gl", "impl", "Url", "sl", "id", "github", "host", "path", "page", "util", "ls", "uri"], "target": ["tree", "report", "to", "project", "graph", "record", "node", "root", "term", "template", "group", "name", "table", "layout", "type", "collection", "container", "top", "other", "context", "scope", "owner", "arget", "metadata", "resource", "t", "local", "Target", "pattern", "result", "model", "object", "component", "output", "nt", "path", "instance", "parent", "source"], "parseURL": [" parsePage", "arseSR", "buildPage", " parseSR", "buildUrl", "arsePage", "parseSR", "parsePage", "arseUrl", "buildSR", "parseUrl", "buildURL", " parseUrl", "arseURL"], "connection": ["entry", "link", "conn", "command", "condition", "socket", "generation", "network", "session", "connected", "database", "directory", "response", "Connection", "c", "document", "still", "open", "description", "writer", "client", "cone", "nc", "context", "application", "con", "position", "established", "connect", "ion", "resource", "result", "created", "creator", "relation", "channel", "communication", "character", "uri"], "charset": ["chatset", "chararset", "chagnET", "chactersect", "chereset", "CHarset", "charaset", "charsect", "chARSets", "cheresets", "charsetter", "chatsets", "CHARSet", "cheresset", "charsat", "chagnset", "chresets", "CHARSets", "charasset", "chaset", "chararsset", "charsET", "cheresect", "CHARSetter", "CHarsets", "charsheet", "CHarsetter", "charasheet", "chactersat", "chagnet", "chactersetter", "chactersset", "charsset", "chacterset", "chatsset", "chararsheet", "chearsset", "chresect", "chearset", "chactersets", "chatsect", "chearsets", "chARSet", "CHarsat", "chasET", "chARSetter", "chararsET", "charsets", "charasET", "CHARSat", "chactersET", "chasset", "chreset", "chagnheet", "chasheet", "chARSat", "chresset", "chearsect", "chactersheet"], "reader": ["entry", "data", "inner", "Reader", "ner", "input", "processor", "parser", "reading", "rar", "uri", "upper", "document", "builder", "io", "handler", "writer", "client", "red", "layer", "row", "context", "runner", "iter", "stream", "iterator", "resource", "file", "driver", "loader", "read", "event", "r", "message", "buffer", "readable", "source"]}}
{"id1": "2807585", "id2": "6756635", "code1": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"encodeMd5": ["encodeMnd4", "encodeMd7", "encodeCd5", "encodeMmd4", "encodeCdKey", "encodeCmd5", "encodeMnd5", "encodeCmdKey", "encodeCd7", "encodeCd4", "encodeCmd4", "encodeMndKey", "encodeCmd7", "encodeMm5", "encodeMmd7", "encodeMmKey", "encodeMdKey", "encodeMnd7", "encodeMmd5", "encodeMm7", "encodeMmdKey", "encodeMd4", "encodeMm4"], "key": ["code", "ac", "secret", "Key", "data", "keys", "sum", "k", "hash", "sec", "p", "prime", "mac", "token", "msg", "base", "abc", "name", "y", "iv", "prefix", "type", "cert", "password", "char", "client", "sk", "json", "KEY", "txt", "info", "value", "id", "conf", "this", "message", "my", "text", "item"], "md": ["d", "m", "amd", "mg", "ad", "ld", "cd", "pt", "mand", "bd", "pd", "hd", "grad", "MD", "desc", "mm", "det", "od", "ind", "dr", "pm", "cond", "mod", "cmd", "dd", "red", "der", "df", "pdf", "bf", "ms", "me", "nd", "dig", "and", "dh", "td", "mc", "mt", "mn", "add", "rm", "mk", "sm", "sd", "def", "mo", "dm", "di", "db", "mb", "de", "ds"], "bytes": ["b", "strings", "objects", "raw", "words", "classes", "js", "blocks", "data", "parts", "lines", "seconds", "pieces", "bles", "gets", "gs", "bps", "its", "ms", "files", "bits", "steps", "hex", "results", "tes", "s", "ings", "es", "groups", "gb", "binary", "outs", "tmp", "values", "rings", "bs", "pages", "unks", "units", "Bytes", "buffer"], "result": ["su", "report", "continue", "Result", "root", "meg", "res", "response", "status", "transform", "group", "answer", "table", "description", "cert", "cup", "replace", "currency", "RESULTS", "ret", "pair", "comment", "request", "vector", "results", "next", "complete", "value", "mask", "profile", "reason", "successful", "success", "product", "output", "r", "this", "message", "join"]}}
{"id1": "13086936", "id2": "10690321", "code1": "            public void run() {\n                waiting(200);\n                txtinfo.post(new Runnable() {\n\n                    public void run() {\n                        txtinfo.setText(\"Searching\");\n                    }\n                });\n                try {\n                    URL url = new URL(urlAddress);\n                    SAXParserFactory spf = SAXParserFactory.newInstance();\n                    SAXParser sp = spf.newSAXParser();\n                    XMLReader xr = sp.getXMLReader();\n                    XMLHandlerReviews myXMLHandler = new XMLHandlerReviews();\n                    xr.setContentHandler(myXMLHandler);\n                    xr.parse(new InputSource(url.openStream()));\n                    if (statuscode != 200 && statuscode != 206) {\n                        throw new Exception();\n                    }\n                    nReviewsOnPage = myXMLHandler.nItems;\n                    statuscode = myXMLHandler.statuscode;\n                    if (nReviewsOnPage > 0) {\n                        authors = new String[nReviewsOnPage];\n                        reviews = new String[nReviewsOnPage];\n                        ratings = new String[nReviewsOnPage];\n                        titles = new String[nReviewsOnPage];\n                        listtext = new String[nReviewsOnPage];\n                        for (int i = 0; i < nReviewsOnPage; i++) {\n                            reviews[i] = myXMLHandler.reviews[i];\n                            authors[i] = myXMLHandler.authors[i];\n                            titles[i] = myXMLHandler.titles[i];\n                            ratings[i] = myXMLHandler.ratings[i];\n                            if (authors[i] == null || authors[i] == \"\") {\n                                authors[i] = \"Anonymous\";\n                            }\n                            if (ratings[i] == null || ratings[i] == \"\") {\n                                listtext[i] = titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            } else {\n                                listtext[i] = \"Score: \" + ratings[i] + \" - \" + titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            }\n                        }\n                        nTotalReviews = myXMLHandler.nTotalItems;\n                        final int fnmin = iFirstReviewOnPage;\n                        final int fnmax = iFirstReviewOnPage + nReviewsOnPage - 1;\n                        final int fntotalitems = nTotalReviews;\n                        if (nTotalReviews > fnmax) {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(0);\n                                }\n                            });\n                        } else {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(8);\n                                }\n                            });\n                        }\n                        if (iFirstReviewOnPage > 1) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(0);\n                                }\n                            });\n                        } else if (nTotalReviews > fnmax) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(8);\n                                }\n                            });\n                        } else {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(4);\n                                }\n                            });\n                        }\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                if (title != null && title != \"\") {\n                                    txtinfo.setText(title + \"\\n\" + getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                } else {\n                                    txtinfo.setText(getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                }\n                            }\n                        });\n                        handlerSetList.sendEmptyMessage(0);\n                    } else {\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                txtinfo.setText(title + getString(R.string.no_reviews_for_this_album));\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    final Exception ef = e;\n                    txtinfo.post(new Runnable() {\n\n                        public void run() {\n                            txtinfo.setText(R.string.search_failed);\n                        }\n                    });\n                }\n                dialog.dismiss();\n                handlerDoneLoading.sendEmptyMessage(0);\n            }\n", "code2": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "label": 0, "substitutes": {"run": ["print", "val", "show", "function", "thread", "execute", "test", "call", "loop", "pass", "play", "process", "exec", "name", "fn", "render", "runs", "un", "func", "running", "runner", "work", "fun", "Run", "ran", "start", "pre", "job", "exit", "update", "def", "get", "invoke", "r", "apply", "method"], "url": ["browser", "http", "pl", "b", "link", "web", "l", "ll", "html", "rl", "xml", "address", "rel", "location", "base", "loc", "open", "www", "f", "str", "abs", "mail", "ssl", "dl", "org", "ref", "ret", "ur", "nl", "bel", "https", "URL", "gl", "Url", "sl", "r", "sb", "ls", "p"], "spf": ["lpf", "spv", "ppfr", " spcf", "prfr", "lpv", "Sph", "prf", "ppf", "Spv", " sph", "lpcf", "prcf", " spc", "Spcf", "spc", "lph", "spcf", "sph", " spv", "Spf", "ppc", "ppcf", "spfr", " spfr", "prc"], "sp": ["pl", "parse", "pr", "pt", "esp", "space", "xml", "SP", "spr", "asp", "jp", "bp", "spe", "sk", "tp", "Sp", "sv", "lp", "so", "serv", "st", "isp", "par", "sf", "spl", "service", "se", "bsp", "pp", "ph", "sw", "sc", "op", "sol", "prep", "ps", "sb", "pse", "si", "p"], "xr": ["xrs", "wxer", "axr", "xR", "ixer", "Xrb", " xrs", "wxrb", "xmlrs", "xxer", "XR", "ixrd", "xer", "xrd", "Xer", "xxrs", "wxr", "xxr", "Xr", "xmlrd", "axrd", "xmlr", "axer", "wxR", "xxrd", " xrd", "axrs", "ixr", "xrb", " xR", "xmler", "ixrs", " xer", " xrb"], "myXMLHandler": ["myYSLHandler", "myXLILHandler", "myXCLHandler", "myXULLHandle", "myXILObj", "myXMmlReader", "myXmlReader", "myXPLParser", "myXCLParser", "myXXSLParser", "myLMLRunner", "myYSLFilter", "myXLMLHandler", "myXXMLFilter", "myXMLFilter", "myLMLParser", "myXLILHandle", "myXILHandler", "myXXMLHandle", "myXmlDef", "myYSLReader", "myXULLHandler", "myXmlRunner", "myXMXFilter", "myXSLParser", "myLmlRunner", "myXMMLFilter", "myXHTMLParser", "myXMLRunner", "myXMXHandler", "myXENTHandle", "myXSLStore", "myXILFilter", "myXmlObj", "myXDFHandler", "myXMLHand", "myXMMLDef", "myXDFStore", "myXMLParser", "myXXILParser", "myXMmlDef", "myXMLObj", "myXmlHand", "myXILReader", "myXMMLReader", "myXmlParser", "myXMMLHandler", "myYMLReader", "myXMmlParser", "myXXMLHandler", "myXSLHandler", "myXSLFilter", "myXMLReader", "myXHTMLHandler", "myXMmlHandler", "myXSLHand", "myXCLFilter", "myXILDef", "myXXSLHandle", "myXPLHandler", "myXMSLHandler", "myXCLStore", "myYMLFilter", "myXSLHandle", "myXHTMLReader", "myXXILHandler", "myXmlHandler", "myXMMLStore", "myXLMLObj", "myXENTHandler", "myXXSLHandler", "myLMLHandler", "myXXILFilter", "myXMLStore", "myXMXParser", "myXMLHandle", "myXMSLStore", "myXLMLHandle", "myXMSLHandle", "myXXSLFilter", "myXILHand", "myXSLReader", "myXCLHandle", "myXPLRunner", "myXENTObj", "myLmlParser", "myXULLDef", "myXLILObj", "myXMmlHandle", "myXmlHandle", "myLmlHandler", "myXMMLHandle", "myXXMLParser", "myXDFHandle", "myXMmlFilter", "myYSLHand", "myXILHandle", "myXILParser", "myYMLHandler", "myXMLDef", "myXMXHandle", "myYMLHand", "myXmlFilter", "myXMMLParser"], "nReviewsOnPage": ["nReviewsMinLine", "nReviewsONpage", "nReviewsOnLink", "nReviewsONFrame", "nReviewsONPage", "nReviewItemsOnpage", "nReviewsAllLine", "nReviewedsOffPage", "nReviewsMaxPage", "nReviewsEnColumn", "nReviewsOnlinePage", "nReviewedsOnBand", "nReviewItemsOnPage", "nReviewsAllChild", "nReviewsOffBand", "nReviewsInLink", "nReviewsOnFrame", "nReviewmentsOnPages", "nReviewsInLine", "nReviewmentsInPage", "nReviewSOnPage", "nReviewedsOnPage", "nReviewsInPage", "nReviewsOffPage", "nReviewsSetBand", "nReviewsOnBand", "nReviewmentsInLine", "nReviewsSetpage", "nReviewSOnLine", "nReviewsFromLine", "nReviewsOnDisk", "nReviewsONDisk", "nReviewsAllLink", "nReviewsInChild", "nReviewsonLine", "nReviewsOnLine", "nReviewsOnColumn", "nReviewsInBand", "nReviewItemsONpage", "nReviewsSetPage", "nReviewsInpage", "nReviewsFrompage", "nReviewmentsOnFrame", "nReviewmentsOnLine", "nReviewsMaxLine", "nReviewsFromPage", "nReviewItemsONPage", "nReviewItemsOnLine", "nReviewsOnlineDisk", "nReviewSOnPages", "nReviewsAllPage", "nReviewsMaxLink", "nReviewsOnPages", "nReviewsOnlineFrame", "nReviewsOnChild", "nReviewsMaxChild", "nReviewedsOffBand", "nReviewsonpage", "nReviewsOffpage", "nReviewmentsOnLink", "nReviewsOnpage", "nReviewsMinPage", "nReviewsInColumn", "nReviewsMinPages", "nReviewsonPages", "nReviewsonPage", "nReviewedsOnpage", "nReviewsEnLine", "nReviewItemsONLine", "nReviewsONLine", "nReviewmentsOnChild", "nReviewsonFrame", "nReviewmentsInChild", "nReviewsOffLine", "nReviewsEnPage", "nReviewedsOffpage", "nReviewmentsInLink", "nReviewmentsOnPage"], "statuscode": ["atuscode", "statusclose", "statuscache", "versiontext", "scoretag", "compliancecoe", "atuscoe", "versionclose", "versioncode", "reasonkey", "reasoncase", "versionsign", "statusmessage", "versioncount", "statustext", "doctag", "compliancecode", "scalecode", "responseme", "doctext", "statuscase", " statuscount", "reasonme", " statuscache", "versionmessage", "compliancecache", "scoretext", "atuscount", "atuscache", "statustag", "responsekey", "scalekey", " statusclose", " statuscoe", "scaleme", "statuscount", "responsecase", "doccode", "scorecode", "scoremessage", "statussign", "statuskey", "responsecode", "statusme", "atusclose", " statussign", "atussign", "versiontag", "reasoncode", "docmessage", "scalecase", "statuscoe"], "authors": ["mates", "agents", "reports", "casters", "types", "phones", "offs", "orders", "approved", "pins", "users", "chairs", "uploads", "ins", "rights", "papers", "ores", "owners", "inals", "leaders", "acers", "Users", "Investigators", "articles", "people", "sers", "author", "runners", "vers", "ctors", "weights", "issues", "reads", "rers", "makers", "testers", "achers", "headers", "mods", "letters", "atts", "writers", "artifacts", "drivers", "names", "books", "scripts", "versions", "iers", "relations", "ippers", "checks", "cars", "icators", "workers", "players", "eers", "creator", "ians", "codes", "notes", "ors", "ers", "masters", "builders", "archives", "lights", "keepers", "abilities", "history", "units", "rals", "terms"], "reviews": ["reviewings", "robments", "defaulteds", "rolls", "rollses", "servings", "returnses", "revieweds", "reviewments", "finds", "reviewers", "calles", "callings", "reviewjs", "Reviews", "Reviewes", "feedses", "robings", "serveds", "reviewes", "advses", "feeds", "replers", "advings", "findes", "respondjs", "responds", "Revieweds", "robeds", "Reviewments", "findings", "defaulters", "repls", "feedjs", "Reviewings", "returnings", "servs", "Reviewers", "respondses", "Reviewses", "servments", "calls", "defaults", "robs", "reviewses", "rolljs", "repleds", "returns", "advs"], "ratings": ["reviewings", "Ratains", "rankrings", "rankings", "rankables", "Ratings", "statments", " ratrors", "writios", " ratests", "statuments", "requings", "requiffs", "statings", "rotiffs", "writing", "ratables", "rotaries", "ratsies", "replrors", "ratests", "reviewios", "rubings", " ratables", "Ratuments", "ratrings", "ratments", "rats", "ratains", " ratiffs", "statests", "requing", "rating", "replains", " ratrings", "replions", "ratsables", "raties", "statrors", "writings", "rataries", "Ratments", "ratios", "ratiffs", "rubions", "staties", "stations", "repls", "rankies", " raties", "rations", "reviewing", "ratsrings", "ratsings", " rating", "Rating", "replests", "Ratios", "ratuments", " rataries", "writs", "rubuments", "rotings", "ratrors", "stats", "requaries", "Rats", "replies", "Rations", "replings", "rubments", "roting", "statains"], "titles": ["ititles", "Tems", "Titled", " tributes", "tires", "tyredits", "Tails", "ttires", " tredits", " tires", "stitles", "otiles", "Titles", "atitles", "Tiles", "stiles", "stires", "itables", "ttredits", "atiles", "atributes", " tickets", "tredits", "turers", "ttls", "itributes", " tables", "titled", "atales", " tails", "otems", " turers", " tls", " tiles", "tems", "itiles", " tales", "tturers", "Tales", "atails", "tls", "tales", "Tickets", "atickets", "piles", "pitled", "tributes", "otitled", "ttales", "otitles", "tyales", "tyitles", "pems", "atables", "tickets", "ttiles", "ttitles", "sturers", "pitles", "tails", "tiles", "tables", "tyls"], "listtext": ["Listbutton", "listbutton", "Listpage", "listText", " listoutput", "printtext", "printinfo", "Listtext", "searchpage", " listpage", "Listinfo", " listText", "listoutput", "Listmessage", "sharetext", "listinfo", " listmessage", "printText", "sharemessage", "ListText", "shareoutput", " listbutton", "printcontent", "searchbutton", "Listext", "searchtext", "Listoutput", " listext", "listcontent", "searchText", "shareext", "listpage", "listmessage", " listinfo", "listext", " listcontent", "Listcontent"], "i": ["m", "b", "ip", "in", "it", "ei", "key", "q", "iri", "loop", "y", "ini", "is", "io", "fi", "bi", "pi", "me", "init", "go", "t", "mi", "ix", "hi", "o", "v", "menu", "h", "index", "oi", "ki", "ii", "u", "j", "id", "ic", "I", "x", "xi", "z", "ci", "ui", "batch", "l", "err", "\u0438", "iq", "iu", "f", "info", "ai", "s", "di", "history", "si", "ie", "zi", "ij", "multi", "gi", "ami", "chain", "phi", "cgi", "li", "json", "cli", "ri", "point", "g", "this", "ti", "ji", "qi"], "nTotalReviews": ["nTotalReviewings", "nMaxViewItems", "nTotalObjectings", "nTotalReaders", "nMaxReviewItems", "nTotalReviewItems", "nMaxReviewings", "nMaxViewings", "nTotalViewItems", "nTotalViewings", "nTotalViews", "nMaxReviewers", "nTotalReadings", "nMaxViews", "nTotalObjecters", "nTotalObjects", "nTotalReviewers", "nMaxReviews", "nTotalObjectItems", "nTotalReads", "nTotalViewers", "nMaxViewers", "nTotalReadItems"], "fnmin": [" fnpos", "fcount", "finpos", "finMin", "finmin", "fMin", " fnMin", "fmin", "fincount", "fpos", " fncount"]}}
{"id1": "9727056", "id2": "6756635", "code1": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"loadModel": ["readJSON", "getModule", " loadModule", "readModel", "getData", " loadEL", "getJSON", "parseModel", "loadFile", "parseJSON", "LoadModel", "readModule", "LoadModule", "loadModule", "openModule", "openEL", "readData", "LoadEL", "parseModule", "LoadFile", " loadFile", "parseData", "loadEL", "loadJSON", "openFile", "getModel", "loadData", "openModel"], "url": ["browser", "http", "b", "mol", "pl", "rect", "link", "web", "l", "html", "ll", "address", "q", "rel", "el", "string", "location", "base", "name", "loc", "document", "str", "abs", "mail", "ssl", "dl", "ref", "build", "ur", "nl", "mount", "URL", "resource", "file", "gl", "impl", "log", "Url", "config", "job", "sl", "cl", "id", "host", "path", "page", "util", "ls", "uri"], "skin": ["thin", "socket", "theme", "sid", "span", "sis", "lang", "site", "suit", "fit", "silver", "spin", "string", "kit", "plugin", "gender", "template", "bin", "species", "name", "starter", "license", "type", "side", "style", "sheet", "scope", "version", "Skin", "format", "knit", "tin", "config", "spec", "kind", "png", "kin", "source"], "ParsingErrorException": ["ParsingErrorEx", "ParsesErrorException", "ParsingInputException", "ParsingFormatError", "ParsingFormatExit", "ParsingInputError", "ParsesErrorEx", "ParsingConfigExit", "ParsingConfigError", "ParsesErrorExit", "ParsingConfigEx", "ParsingFormatException", "ParsesFormatException", "ParsingInputEx", "ParsingInputExit", "ParsesFormatError", "ParsingErrorError", "ParsesFormatEx", "ParsesErrorError", "ParsingFormatEx", "ParsingConfigException", "ParsingErrorExit", "ParsesFormatExit"], "baseURLWasNull": ["baseURLHadNull", "baseUrlwasnull", "baseURLwasMissing", "baseURLWasMissing", "baseURLWerenull", "baseUrlwasFound", "baseURLWasnull", "baseURLHadNULL", "baseURLwasNULL", "baseUrlWasnull", "baseURLWereMissing", "baseURLEvernull", "baseUrlWasNULL", "baseURLHadFound", "baseURLWasFound", "baseURLwasnull", "baseURLWereNULL", "baseURLWereNull", "baseURLHadMissing", "baseURLwasFound", "baseUrlwasMissing", "baseURLEverNull", "baseUrlwasNull", "baseUrlWasMissing", "baseURLWereFound", "baseURLEverNULL", "baseURLwasNull", "baseURLWasNULL", "baseUrlwasNULL", "baseUrlWasNull", "baseUrlWasFound"], "model": ["m", "human", "report", "batch", "link", "serial", "ll", "data", "xml", "body", "jo", "fit", "obj", "el", "entity", "base", "transform", "mod", "document", "json", "row", "cell", "sample", "me", "module", "Model", "sim", "resource", "map", "result", "mi", "job", "models", "successful", "mor", "object", "view", "my", "message", "buffer", "instance", "morph", "tree"]}}
{"id1": "1769771", "id2": "2009072", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", "copyLine", " copyFiles", "copyFiles", " CopyLine", " copyStream", " CopyFiles", "copyStream", "CopyStream", " CopyStream", "CopyLine", " copyLine", "CopyFile", " CopyFile"], "in": ["inf", "b", "IN", "l", "inc", "inner", "cin", "ins", "el", "input", "mm", "ind", "rin", "bin", "up", "In", "ini", "io", "is", "isin", "init", "old", "gin", "from", " input", "en", "inn", "r", "on", "i", "ic", "din", "source"], "out": ["o", "b", "n", "v", "to", "l", "it", "ex", "err", "res", "OUT", "at", "msg", "c", "os", "up", "ou", "Out", "io", "serv", "ot", "w", "t", "file", "s", "help", "log", "gt", "update", "op", "output", "outs", "po", "net", "p", "nt"], "inChannel": ["ainClient", "sinButton", "dinChan", " inCategory", "InChan", " inConnection", " inchannel", " inCommand", "dinConnection", "InChannel", "insideCategory", "inchannel", " inScope", "intChan", "inCase", "sinChannel", "insideChannel", "ainCategory", "intCommand", "inConnection", "ainScope", "dinchannel", "dinChannel", "inChan", "inCommand", "outChan", "innCase", "inCategory", "inScope", " inClient", "innButton", "Inchannel", "outConnection", "outchannel", "inButton", "sinCommand", " inChan", "cinChannel", "sinClient", "ainChannel", "sinRoom", "InCommand", "sinCase", " inRoom", "insideClient", "inRoom", "innClient", "inClient", "insideScope", " inButton", "innChannel", "cinRoom", "cinCommand", "intchannel", "intChannel", " inCase"], "outChannel": ["aosChannel", " outCh", "blockGate", "blockChannel", "inSection", " outManager", "parentChannel", "inchannel", "aosMember", "outGate", "neChan", "outputchannel", "blockChan", "inChan", "inCh", "outCh", "outChan", "inMember", "neChannel", "outchannel", "cnChan", " outchannel", "outputChannel", "outSection", "parentGate", " outChan", "aosChan", "blockMany", "neSection", "aosSection", "parentChan", "parentMany", "outManager", " outMany", "outputChan", "outputCh", "cnChannel", "cnManager", "outputManager", "neMember", "outMember", " outGate", "outMany"]}}
{"id1": "20091126", "id2": "1188100", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" Copy", "to", "cat", "cp", "create", "call", "download", "store", "Copy", "paste", "system", "transfer", "load", "y", "Transfer", "io", "open", "write", "save", "upload", "move", "sync", "clone", "file", "map", "get", "delete", "Cop"], "in": ["inf", "b", "n", "IN", "l", "inc", "inner", "cin", "ins", "el", "input", "mm", "ind", "rin", "up", "In", "ini", "io", "isin", "init", "old", "info", "file", "gin", "from", " input", "id", "en", "ck", "ain", "r", "inn", "din", "i", " din", "source"], "out": ["o", "b", "n", "v", "to", "null", "l", "ex", "it", "err", "res", "OUT", "at", "one", "msg", "self", "c", "os", "y", "io", "Out", "ou", " os", "end", "or", "channel", "ch", "co", "write", "e", "ot", "bytes", "w", "t", "file", "s", " output", "result", "log", "gt", "as", "_", "output", "outs", "tmp", " it", "net", "x", "p", "nt"], "inChannel": ["conListener", "cinBlock", "conChannel", "conChan", "InChan", " inConnection", " inchannel", " inCommand", "INConnection", "incChannel", "inSection", "innConnection", "ginChuck", "InChannel", "inPanel", "binChannel", "inchannel", "outCommand", "binCommand", "outBlock", "inBlock", "insideChannel", "INChan", "innchannel", "incChain", "inConnection", "INChannel", "inChan", "ginPanel", "inCommand", "binChain", "inChain", "Inchannel", "outchannel", "conConnection", "incPanel", "incChuck", "cinChannel", " inChan", "binChuck", " inRow", "binRow", "binPanel", "insideSection", "inChuck", "ginChain", "cinchannel", " inSection", "InConnection", "insideRow", "ginChannel", "innChannel", "inListener", " inListener", "inRow", "binSection", " inBlock", "cinCommand", "insideCommand", "INListener", "innChan"], "outChannel": [" outCh", "cmdChan", "OUTSlot", "skyGate", "cmdGate", "skyMany", " outManager", " outPassword", "OUTChan", "inchannel", "outPassword", "cosChan", "outGate", "inUser", "Outchannel", "inChan", "inCh", "outCh", "outChan", "skyChan", "moduleChannel", "outchannel", "OUTUser", "outSlot", "cmdMany", " outchannel", "outputChannel", "moduleManager", "cmdChannel", "OutChan", "inSlot", "OUTChannel", "cosUser", " outChan", "cosSlot", "outUser", "OutChannel", "OutCh", "outManager", " outMany", "outputChan", "outputPassword", "cosChannel", "modulePassword", "skyChannel", "outputManager", "moduleChan", " outGate", "outMany"]}}
{"id1": "5977352", "id2": "5808579", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpfile", "copyfile", " cpFiles", " copyFolder", " copyFiles", "copyFiles", "cpFile", "cpfile", " cpFile", "cpFiles", " cpFolder", "cpFolder", "copyFolder", " copyfile"], "src": ["rest", "ctr", "pkg", "rl", "SOURCE", "sec", "rel", "ins", "input", "via", "ser", "req", "rs", "loc", "ipl", "cont", "img", "sys", "usr", "orig", "rc", "init", "st", "Source", "sf", "cur", "inst", "from", "start", "sit", "sc", "sb", "sr", "sq", "source"], "dest": ["comp", "rest", "null", "comb", "cat", "them", "source", "dat", " dst", "cp", "test", "target", "desc", "tif", "dist", "th", "self", "name", "loc", "decl", "Dest", "nw", "end", "nom", "cont", "trans", "usr", "est", "sp", "dir", "st", "none", "origin", "copy", "port", "opt", "mk", "result", "master", "etc", "del", "sit", "gt", "coord", "lit", "foreign", "spec", "good", "tmp", "tom", "de", "temp", "txt", "orig", "parent", "nt"], "bufSize": ["bcLen", "ufSIZE", "ufNum", " bufLen", " bufSIZE", "bcSIZE", "fontNum", "bufNum", "bcSize", "bufLen", "bufSIZE", "ufLen", " bufNum", "fontSIZE", "ufSize", " bufferSIZE", "bcNum", "fontSize", " bufferSize", " bufferNum"], "force": ["stall", "forced", "rule", "print", "command", "forcing", "use", "reset", "flag", "fill", "only", "raise", "base", "error", "fast", "cmd", "replace", "form", "f", "send", "Force", "co", "write", "safe", "draw", "forge", "check", " Force", "ce", "allow", "kill", "always", "auto", "require", "close", "quote", "enable", "default", "forces", "apply", "remote", "frame"], "buffer": ["batch", "cache", "print", "command", "Buffer", "memory", "paste", "window", "total", "limit", "template", "base", "shape", "table", "document", "sequence", "attribute", "queue", "buf", "number", "row", "device", "mem", "phrase", "sample", "buff", "comment", "stack", "block", "word", "library", "variable", "binary", "quote", "view", "message", "temp", "display", "history", "length", "frame", "text", "tree"], "read": ["parse", "raw", "print", " Read", "feed", "give", "need", "push", "record", "q", "pe", "input", "reading", "bind", "index", "reader", "fill", "ind", "req", "pass", "im", "load", "shape", "hold", "open", "end", "scan", "str", "row", "word", "reads", "count", "send", "valid", "write", "through", "request", "iter", "size", "check", "wait", "stream", "add", "w", "t", "next", "allow", "range", "connect", "start", "READ", "query", "set", "find", "get", "hello", "run", "r", "i", "before", "length", "Read", "height", "text", "readable", "len"], "in": ["inf", "o", "m", "n", "IN", "l", "inc", "it", "al", "inner", "cin", "ins", "doc", "input", "mm", "ind", "rin", "bin", "im", "up", "inside", "ini", "is", "In", "ar", "or", "isin", "co", "init", "con", "info", "iter", "ma", "irm", "check", "ln", "t", "gin", "from", "local", "include", "mi", "internal", "all", "en", "ain", "get", "inn", "per", "on", "sin", "ic", "din", "i", "ie", "cn", "source"], "out": ["o", "b", "n", "to", "v", "list", "conn", "cache", "l", "oss", "it", "ex", "inner", "sum", "flush", "cos", "obj", "OUT", "at", "one", "os", "up", "Out", "io", "ou", "oe", "aos", "writer", "client", "again", "end", "or", "cmd", "outer", "sys", "conv", "ch", "co", "write", "br", "ot", "con", "ln", "t", "mit", "file", "om", "ent", "gt", "can", "all", "op", "g", "output", "outs", "on", "ns", "net", "cn", "ne", "not", "nt"]}}
{"id1": "5620792", "id2": "10547671", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 0, "substitutes": {"SHA1": ["HS2", " SHAOne", "sha1", "SHA2", " SHA2", "HS256", " SHA256", "HSOne", "SHAOne", "shaOne", "sha2", "sha256", "SHA256", "HS1"], "text": ["code", "print", "pt", "data", "key", "test", "q", "input", "string", "term", "ext", "msg", "template", "name", "document", "prefix", "TEXT", "password", "form", "ct", "str", "cont", "subject", "act", "comment", "word", "url", "value", "t", "pattern", "read", "config", "tx", "current", "content", "event", "output", "nt", "message", "path", "translation", "out", "Text", "txt", "select", "source"], "HASH_VALUE_SIZE": ["HASH_VALUE_TYPE", "HASH_value_DIR", "HASH_VALUE_Size", "HASH_value_SIZE", "HASH_VAL_NAME", "HASH_VAL_Size", "HASH_VALUE_NAME", "HASH_VALUE_NO", "HASH_value_TYPE", "HASH_VAL_SIZE", "HASH_VALUE_DIR", "HASH_VALUE_SOURCE", "HASH_value_SOURCE", "HASH_VAL_NO"], "md": ["d", "m", " ms", "mg", " cmd", "ad", "cd", " sd", " Md", "mand", "ld", "js", "bd", "ctr", "h", "pd", "hd", "grad", "MD", " mm", "mm", "det", " man", "od", "ind", "cond", " mc", "mod", "cmd", "dd", "mond", " ma", "der", "df", " del", " dd", "ms", "nd", "dig", "dir", "and", "dh", "td", "mc", " rm", "mt", "mn", "add", "metadata", "rm", "mp", "mk", "sm", "sd", "mode", "hm", "dm", "mb", " mo", "ds", " cd"], "sha1hash": ["sha1str", "sha1result", "sha31hash", " SHA1sum", " SHA1have", "SHA1Hash", "SHA1hash", "shaonesum", "sha3hash", "sha5value", "sha1sum", "SHA2hex", "sha1Hash", "ha2Hash", "ha1hash", "ha2hash", "SHA2Hash", "SHA1hex", "sha2Hash", "sha5hash", "sha1hex", "sha2have", "sha2hash", "sha31have", "shaoneresult", " SHA31sum", "sha2value", "SHA2str", "sha31value", "ha1result", "sha5sum", "shaoneHash", "sha7hash", "sha3str", " SHA31have", "sha2result", "sha7hex", "ha1Hash", "sha2str", "sha7str", " SHA1value", "sha1value", "SHA2hash", "ha2sum", "sha5have", "sha3hex", " SHA1hash", "sha3Hash", "sha7Hash", "sha2hex", " SHA31hash", " SHA31value", "sha2sum", "sha31sum", "shaonehash", "ha1sum", "SHA1str", "sha1have", "ha2result"]}}
{"id1": "7143591", "id2": "13152325", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"getWebByUrl": ["getWebFromURL", "getWebbyurl", "getUrlbyURL", "getWebByurl", "getWebFromString", "getUrlByURL", "getUrlByString", "getUrlbyUrl", "getUrlByurl", "getUrlByUrl", "getUrlbyString", "getWebbyURL", "getWebbyString", "getWebFromurl", "getUrlbyurl", "getWebByURL", "getWebFromUrl", "getWebbyUrl", "getWebByString"], "strUrl": ["txtURL", "volStr", " strurl", "stringUrl", "STRStr", "strDb", "strGl", "StrURL", "StrUrl", "StrStr", "strUr", "insturl", "strURL", "volUrl", "drURL", "nameURL", "stUrl", "strStr", "txtUrl", "nameEmail", "stringURL", "txtGl", "strurl", "arrStr", "STRURL", "StrUr", " strStr", "arrURL", " strUr", " strGl", "arrEmail", "drUrl", "drurl", " strDb", "arrUrl", "stUr", "instUrl", "volURL", "nameDb", "arrUr", "Strurl", "nameUrl", "instUr", "StrGl", "volUr", "nameStr", "STRUr", "nameUr", "stringDb", " strURL", "sturl", "nameurl", "txtStr", "stringUr", "drUr", "STRUrl", "stDb", "drDb", "stURL", "strEmail", "instURL", "STREmail", "arrurl"], "charset": ["ChARSec", "Charsets", "chorset", "chARSET", "chARSets", "ChARSets", "chorsec", "charsET", "chorsets", "ChARSET", "Charsec", "chARSet", "chorsET", "ChARSet", "charsets", "charsec", "chARSec", "Charset", "CharsET"], "fileIndex": ["byteNum", "stringPos", "stringindex", " fileNum", "fileInd", "fileindex", "ileInd", "ileindex", " fileindex", "byteIndex", " fileInd", "fileNum", "ileIndex", " filePos", "bytePos", "stringPath", "byteInd", "byteindex", "filePos", "stringIndex", "bytePath", "ileNum"], "url": ["browser", "http", "link", "web", "l", "socket", "ll", "cp", "rl", "rel", "obj", "hl", "name", "open", "cert", "cmd", "client", "www", "f", "str", "il", "ul", "ssl", "dl", "ret", "connection", "build", "ur", "nl", "bel", "con", "https", "URL", "gl", "resource", "Url", "sl", "get", "g", "bl", "r", "net", "ls", "uri"], "conn": ["ca", "access", "l", "socket", "pg", "ws", "oss", "cp", "ctr", "ctx", "obj", "Conn", "Connection", "c", "open", "cmd", "nw", "ens", "comm", "enc", "sys", "connection", "act", "nc", "ch", "iw", "cb", "con", "ln", "nec", "pas", "connect", "handle", "en", "addr", "net", "cn", "conv", "Con", "nt"], "is": ["http", "ip", "ris", "isi", "in", "js", "bis", "ws", "it", "lis", "ists", "has", "isa", "was", "us", "res", "ins", "are", "ir", "im", "ais", "rs", "os", "si", "its", "IS", "Is", "sys", "isf", "iso", "ms", "bits", "serv", "ib", "info", "ios", "iter", "nis", "ri", "isc", "s", "iss", "es", "fs", "id", "iris", "ist", "as", "isl", "bs", "out", "or", "i", "ls"], "filePath": [" fileSystem", "ioPath", "fName", "filePATH", "familyPath", "ioName", "fFile", "ioFile", "Filepath", " filepath", "FileSystem", "fileSystem", "familySystem", "FileName", "fSystem", "ioSystem", "FilePath", "familyPATH", "filepath", " filePATH", "FileFile", "fileFile", "FilePATH", "fPath", "familypath", "fileName"], "pw": ["npv", " pwh", "pwe", "jwd", "fwd", "Pwb", "fw", "pwr", "pwb", " pwr", "Pwd", "jW", "fws", "pwh", " pwt", "wpwt", "cpwp", "cpw", " pwb", " pws", " pwd", " pwp", "mw", "cpwd", "apw", "PW", "pv", "jw", "npwp", "fW", "npwr", "npwe", "pws", "wpv", "npw", "pwd", "pW", "mwb", " pwe", " pv", "pwp", "npwd", "wpwe", "Pw", "cpwr", "mwh", "apwd", "Pws", " pW", "mwd", "apwb", "apwh", "wpw", "pwt", "npwt", "jwb"], "fos": ["eOS", "fOS", "boses", "floses", " fOs", "wOs", "flo", "fo", "eOs", "woss", "bo", "wos", " foss", "eos", "foss", "bOs", "fOs", "eoss", "flos", "bos", "wOS", " fOS", " foses", "flOs", "foses", " fo"], "writer": ["rew", "walker", "rw", "writing", "fw", "wp", "wright", "wr", "ser", "window", "desc", "reader", "editor", "Writer", "builder", "handler", "nw", "author", "worker", "width", "aster", "ter", "write", "writ", "liner", "riter", "println", "w", "written", "master", "wb", "widget", "member", "wrote", "console", "output", "usher", "woman", "aver", "out", "player", "buffer", "wn", "nt"], "bReader": ["bcBuffer", "aRead", "aWriter", "bBuffer", "bR", "bhClient", "rbR", "bClient", " bR", "bhBuffer", " bWriter", " bClient", "rbWriter", "rbReader", "aReader", "bRead", " bBuffer", "bWriter", "rbRead", "bhReader", " bRead", "bcClient", "bcReader", "aR"], "sb": ["pb", "b", "bj", "bh", "bis", "bd", "rob", "zb", "lb", "bt", "stab", "rb", "CB", "sa", "ssl", "sv", "lp", "bf", "sp", "bg", "cb", "ib", "sf", "kb", "sth", "bsp", "wb", "sw", "gb", "bb", "eb", "nb", "mb", "bs", "sg", "erb", "SB", "sq"], "rLine": [" rLe", " rFrame", " rLink", "bline", " rline", "rrLe", "lLink", "srChan", "rrChan", "rChan", "rLink", "bLink", "rEl", "lline", "brL", "bRow", "bLine", "lLine", "srLine", "brFrame", "srLe", "srL", " rRow", "rFrame", "rrLine", "rLe", "rL", "brRow", "srRow", "srEl", "rline", "rRow", "rrEl", "lRow", " rL", "brLine", " rChan", " rEl", "srFrame"], "tmp_rLine": ["tmp_Rline", "tmp_rgLine", "tmp_cRow", "tmp_eline", "tmp_pBlock", "tmp_rRule", "tmp_drline", "tmp_drRow", "tmp_eLine", "tmp_drLin", "tmp_RRecord", "tmp_bLine", "tmp_nrVal", "tmp_rnLin", "tmp_rRow", "tmp_nSet", "tmp_rnRule", "tmp_cLine", "tmp_nLine", "tmp_rgOrig", "tmp_bRow", "tmp_bline", "tmp_hLin", "tmp_drLine", "tmp_hLine", "tmp_hRule", "tmp_lObj", "tmp_cline", "tmp_lline", "tmp_lChain", "tmp_rObj", "tmp_nL", "tmp_lVal", "tmp_rline", "tmp_nrChain", "tmp_rChain", "tmp_RVal", "tmp_bLin", "tmp_lLine", "tmp_RL", "tmp_pRow", "tmp_RRow", "tmp_RSet", "tmp_pL", "tmp_rRecord", "tmp_eRow", "tmp_hOrig", "tmp_eRecord", "tmp_eObj", "tmp_rLin", "tmp_nBlock", "tmp_pline", "tmp_lRow", "tmp_rnOrig", "tmp_pLine", "tmp_rSet", "tmp_rL", "tmp_RBlock", "tmp_RLine", "tmp_rgLin", "tmp_lRecord", "tmp_rnLine", "tmp_cObj", "tmp_rVal", "tmp_rgRule", "tmp_nrLine", "tmp_pLin", "tmp_nrRow", "tmp_rBlock", "tmp_rOrig", "tmp_pSet", "tmp_RChain"], "str_len": ["str__Len", "str2Len", "str2ls", "str__ls", "string_ls", " str2len", "string3len", "str_Len", "str3len", "str__ll", "str2ll", "string_len", " str2ls", "string3ls", " str2Len", "str_ls", " str_Len", "str2len", "str3vec", "string3length", "str_ll", "str_length", "str__len", "str3ls", "str_vec", "string_length", " str_ll", " str_ls", "string_vec", "string3vec", " str2ll", "str3length"]}}
{"id1": "22135199", "id2": "14590676", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"testCodingEmptyFile": [" testCodingFullFiles", " testCodingemptyfile", " testCodingEmptyStream", " testCodingemptyFiles", " testCodingEmptyfile", " testCachingEmptyfile", " testCodingFullfile", " testCodingemptyFile", " testCodingSizeFiles", " testCachingEmptyFile", " testCodingSizefile", " testCachingEmptyFiles", " testCodingFullStream", " testCodingEmptyFiles", " testCachingemptyFiles", " testCachingemptyFile", " testCodingemptyStream", " testCachingemptyStream", " testCodingSizeStream", " testCodingFullFile", " testCachingemptyfile", " testCodingSizeFile", " testCachingEmptyStream"], "baos": ["boo", "Bao", "baOS", "taos", "caOs", "boos", "aoos", "aoOS", " baOs", "aoOs", "taoS", " baoS", "bao", "BaOs", "baoss", " baOS", "Baos", "aoo", "caoS", "tao", "boOs", "cao", "Baoss", "caos", " bao", "booss", "boOS", "baOs", "taOs", "baoS", " baoss"], "channel": ["batch", "cache", "Channel", "command", "socket", "network", "session", "server", "chain", "controller", "input", "window", "system", "room", "c", "io", "handler", "password", "client", "container", "queue", "connection", "context", "ch", "application", "caster", "con", "block", "stream", "resource", "file", "service", "chan", "can", "console", "component", "cm", "message", "out", "buffer"], "params": ["types", "settings", "tags", "ops", "services", "pins", "data", "parts", "proc", "limits", "ctx", "options", "mm", "cms", "param", "rs", "name", "caps", "details", "fps", "properties", "password", "ams", "json", "sys", "Parameters", "pi", "phys", "Par", "AMS", "headers", "cmp", "radius", "par", "names", "config", "spec", "conf", "pps", "ps", "pool", "pretty", "units", " parameters", "p"], "outbuf": ["outputrb", "inBuffer", "inbuf", " outbuff", "inrb", "inbuff", "outputbuf", "inbuffer", "outbuff", " outBuffer", " outbuffer", "outputbuff", "outBuffer", "Outbuff", "outputbuffer", "Outbuf", "outrb", "OutBuffer", " outrb", "outbuffer", "Outbuffer"], "metrics": ["monrix", "mutths", " metcs", "Metrors", "metrix", "mtrices", "Metric", "monric", "mtrics", "mtcs", "metths", "mutrics", " metths", "Metrics", "matrors", "monrics", "mtths", "Metrix", "mutrices", "metric", "matrix", "monrors", "metrices", "metcs", "matric", "matrics", "metrors", "mutcs", " metrices"], "encoder": [" encrier", "Enciever", "encuter", "enrier", "encressor", " encressor", "enoding", "Encrier", "encramer", "ecoded", "ecoding", "enoder", "eniever", "ecoder", "enciever", "encrier", "enoded", "ecressor", "encoding", "enressor", "ecrier", " encramer", "ecramer", "Encuter", "Encramer", "Encoding", "enramer", " encoding", " encoded", "execrier", "eciever", "execoding", "execoder", " encuter", "encoded", "executer", "Encoder"], "tmpFile": [" tmpKey", "testFilename", "tmpName", "fakeFiles", "txtfile", "tempFile", "tempfile", " tmpfile", "tempFilename", "mpFilename", " tmpPath", "testfile", "tmpPath", "tmpFiles", "testFile", " tmpFilename", "tempFiles", "fakeFile", "tempKey", "tmpKey", "fakefile", "tmpFilename", "tmpfile", "tempPath", "txtPath", "mpfile", " tmpFILE", "txtFile", " tmpFiles", "imgFILE", "tempFILE", "fakeFilename", "mpFile", "imgfile", " tmpName", "imgKey", "mpName", "testName", "tmpFILE", "imgFile"], "fout": ["fullOUT", "fouts", "sfOut", "sfout", "lbal", "wout", "fOUT", "fullout", "dfoutput", "fOut", "wao", "lOUT", "fulloutput", "vOut", "sfao", "sfouts", "loutput", "foutput", "dfout", "vout", "fullbal", "fbal", "vouts", "wOut", "vao", "dfOUT", "dfbal", "fao", "wouts", "lout"], "wrtout": ["wrdwriter", "wrdio", "wRTn", "Wrdn", "wRTout", "ewrtwriter", "wttwriter", "wrcwriter", "ewltout", "Wrtn", "wrdout", "wttn", "Wrtwriter", "wrcex", "wrtn", "wrcw", "hwrcwriter", "hwrcw", "wgtw", "wdrgen", "wrtgen", "ewltwriter", "wrdgen", "hwrtout", "wwtout", "Wrdwriter", "wltin", "ewltin", "wdrwriter", "wrdin", "wltout", "wdrout", "wgtex", "wttout", "hwrtex", "wrtex", "wRTwriter", "Wrdout", "wwtwriter", "hwrtwriter", "Wrtout", "wgtout", "wwtw", "wwtex", "hwrtw", "ewrtin", "wdrin", "ewrtgen", "Wrdio", "wrtwriter", "wRTio", "wrtin", "ewrtout", "Wrtio", "wltwriter", "wrcout", "wttio", "ewltgen", "wgtwriter", "wrtio", "hwrcex", "hwrcout", "wrdn", "wltgen", "wrtw"], "fchannel": [" fnet", " fChannel", "fconnection", " fconsole", "wchannel", "Fconsole", "flChannel", "fcchannel", "wconnection", "fccontroller", " fconnection", "fconsole", "flnet", "fcconnection", "fcchan", "fnet", "Fnet", "wchan", "fcontroller", " fcontroller", "FChannel", " fchan", "Fchannel", "fchan", "wcontroller", "flchannel", "flconsole", "fChannel"], "s": ["m", "b", "v", "n", "csv", "js", "ws", "qs", "h", "string", "rs", "gets", "c", "gs", "S", "is", "ss", "f", "str", "sv", "j", "e", "w", "t", "ts", "g", "r", "sg", "a", "ns", "ds", "i", "ls", "sq", "p"]}}
{"id1": "6403868", "id2": "18782385", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUninstallItems", "extractUnInstallFiles", "extractuninstallItems", "extractUnInstallItems", "extractuninstallFile", "extractUnpackFiles", "extractUnInstallFile", "extractUnpackFile", "extractuninstallFiles", "extractunInstallFile", "extractUninstallFile", "extractunInstallItems", "extractUnpackItems", "extractunInstallFiles"], "_destPath": ["_privDir", "_srcDir", "_destTh", "_destPoint", "_srcPath", "_DestDir", "_sourcePath", "_tempPoint", "_DestPath", "_privTh", "_restDir", "_tempDir", "_combFormat", "_tempPath", "_DestKey", "_tempFormat", "_sourceDir", "_srcPoint", "_DestTh", "_restKey", "_privPoint", "_sourceFormat", "_combDir", "_tempTh", "_restPoint", "_destFormat", "_destKey", "_destDir", "_combPath", "_srcKey", "_restPath", "_DestPoint", "_privPath"], "upgrade": ["upcheck", "exgrade", "downchange", "upcp", "exchange", "equgrade", "unate", "downgrades", "uncp", " upchange", "equgrad", "excheck", "equcp", "downgrade", "equate", "upate", " upcheck", "upgrad", " upgrades", "ungrad", " upcp", " upgrad", "upgrades", " upate", "downcheck", "upchange", "exgrades", "ungrade"], "lastVer": ["LastVer", " lastVersion", "oldVers", "nextRes", "Lastver", "latestRes", "nextServ", "lastVers", "oldver", "nextVer", "LastVers", " lastVers", " lastver", "oldVer", " lastRes", "lastver", "oldVersion", "latestVer", "nextVers", "LastVersion", "latestVers", "lastRes", " lastServ", "lastServ", "lastVersion", "latestServ"], "oldlog": [" oldLog", "oldLog", " olderr", "olderlog", "Oldog", "olderog", "OLDpath", "olderLog", "Oldpath", "oldpath", "OLDerr", "OldLog", "OLDLog", " oldog", "OLDlog", "olderpath", "Oldlog", " oldpath", "oldererr", "oldog", "olderr", "OLDog"], "destPath": ["locTime", "originPort", "DestPath", "restDir", "srcPort", "privPath", "identPoint", "destFile", "declDir", "potDir", "destRoot", " destHost", "originTh", "destPort", "srcDir", "destRef", "DestPos", "destPos", "destName", "DestParent", "altParent", "DestDir", "DestRef", "srcPath", "restFile", "sortFont", "originPath", " destDirectory", "destFont", "descNet", "foreignStream", "declFull", "DestPoint", "identPath", "DestFile", "gestHost", "descKey", "gestNode", "estRef", "sortDir", "srcLog", " destPos", "restPoint", "destNode", " destNode", "altPath", "descPath", "estKey", "destStream", "gestDisk", "destDirectory", "estName", " destRoot", "DestDirectory", "destTh", "DestFull", " destDir", "gestPath", " destTh", "estDir", "DestStream", "privPos", "destDisk", "gestNet", "sortPath", "destFull", "privDir", "locDisk", "potStream", "descTime", "altDir", "destTime", "destParent", "destPoint", "destDir", "DestPort", "sortFull", " destFile", "destNet", "srcDirectory", " destRef", "destHost", "destKey", "destLog", "DestPod", "estPos", "DestFont", "descName", "DestRoot", "DestLog", "privRoot", "locPath", "srcFile", "potPod", "gestName", "descDisk", " destLog", "foreignDir", "declPath", " destKey", "restPath", "DestName", " destParent", " destName", "descPos", "locNet", "declFont", "altPoint", "identPort", "gestTime", "destPod", "estPath", "altNode", "altName", " destPort", "identTh", "altHost", "foreignPod", "originPoint", "foreignPath", " destPoint", "potPath"], "lastVerPath": ["highestVerPath", " lastVersLog", "lastVersionCh", "lastverpath", "highestVERPath", "lastverForm", "lastVerLog", "lastVersPath", "lastVERpath", "lastVersCh", "lastVersionpath", "lastverName", "lastVersName", " lastVersFile", "lastverLog", "lastVerName", "lastVerDir", "lastverDir", "highestVerpath", "lastResDir", "highestVerFile", "highestVERVal", "lastVerForm", " lastVersCh", " lastVersPath", "highestVERpath", "lastResPath", " lastVerForm", " lastVerDir", " lastverForm", "lastverFile", "lastVERFile", "lastVerspath", "lastVERForm", "lastResForm", "lastVERVal", "highestVerVal", "lastverCh", " lastverDir", "lastVersFile", " lastVerName", " lastverPath", "lastVerVal", "lastVersionFile", " lastverpath", "lastVersionPath", " lastVerLog", "lastVersVal", "lastVERPath", "highestVERFile", "lastverPath", " lastVerpath", "lastVerCh", " lastVerFile", "lastVersLog", " lastVerCh", "lastverVal", "lastRespath", "lastVerFile", "lastVerpath", "lastVERDir"], "bkdir": ["blkgroup", "bakdi", "bqdi", "BkDir", "Bkpath", "bckdi", "blkfd", "bkpath", "bkkDIR", "bkkDir", "bkDir", "bkkfolder", "bukgroup", "bakDir", " bakdir", "bkrel", "bkkpath", "bukDIR", "bkfolder", "bckpath", " bkkDir", "bkgfolder", "blkjgroup", " bkDir", "bkdi", "bkjgroup", "bkjdi", "Bckdir", "bukdir", "blkjdir", "blkjfd", " bakfolder", "bkDIR", "bakfolder", " bkdi", "bckDIR", "bckDir", " bkfolder", "bkkdi", "blkdi", "bukpath", "bakrel", "Bkdir", "BckDIR", "bkkdir", "bkfd", " bkkrel", " bkrel", "bukfd", "blkdir", "bkgrel", "bqfd", "BkDIR", "Bckpath", " bkkfolder", "blkjdi", " bakDir", "bkjfd", "BckDir", "bukDir", "bckfolder", "bqgroup", "bukdi", " bkkdir", "bkjdir", "bkgroup", "bakdir", "bkkrel", "bqdir", "bkgDir", " bakdi", "bckdir", "bkgdir"], "oldClassCopied": ["oldclassCopie", "oldDirReplried", "oldClasscopied", "oldclassCopied", "oldDirReplies", "oldClassReplified", "oldClassCopyied", "oldClasscopified", "oldDirCopies", "oldDirRepliated", "oldclassCopaced", "oldClassCopyies", "oldClasscopie", "oldClassCopiated", "oldclasscopified", "oldDirCopiated", "oldClasscopies", "oldclasscopie", "oldClassReplied", "oldClassReplried", "oldClassCopyie", "oldDirCopied", "oldClassColies", "oldClassColied", "oldClassChiated", "oldClassChried", "oldClassCopified", "oldClassCopyified", "oldClasscopried", "oldClassCopie", "oldClassChies", "oldClassCopaced", "oldclasscopies", "oldClassCopies", "oldClassColaced", "oldClassReplies", "oldClassCopried", "oldClassColified", "oldclassCopies", "oldclasscopied", "oldDirCopried", "oldDirReplied", "oldClassRepliated", "oldClassChied", "oldclassCopified", "oldClassReplaced", "oldClasscopiated"], "ls": ["LS", "ks", "irs", "lt", "l", "ws", "less", "los", "lis", "lc", "rl", "ists", "qs", "lines", "la", "rs", "lbs", "sels", "les", "its", "acts", "abs", "vs", "dl", "lv", "ms", "ics", "ols", "ars", "cs", "ln", "tl", "xs", "ts", "ats", "fs", "es", "lf", "els", "lists", "ps", "ns", "bs", "ils", "las", "ds", "gs"], "i": ["m", "multi", "ip", "b", "ci", "ui", "batch", "ij", "l", "ji", "it", "ei", "gi", "key", "ami", "I", "chain", "phi", "us", "index", "im", "y", "oi", "ki", "ini", "li", "io", "is", "gu", "ii", "iq", "ski", "bi", "pi", "j", "u", "a", "me", "init", "eu", "cli", "ri", "sim", "mi", "ti", "hi", "ix", "id", "di", "ims", "fire", "ic", "x", "si", "xi", "qi", "zi"]}}
{"id1": "11334468", "id2": "11005804", "code1": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"wordFrequency": ["wordSamplerequency", "wordfRate", "wordfence", "wordfrequency", "documentFullRate", "wordSampleRank", "documentFRate", "wordFullence", "documentFrequency", "documentFence", "wordFullrequency", "wordFullRank", "documentFRank", "wordFRank", "wordFence", "documentFullrequency", "wordFullRate", "wordSampleRate", "wordSampleence", "documentFullRank", "wordfRank", "wordFRate", "documentFullence"], "word": ["kw", "words", "letter", "command", "key", "wp", "question", "user", "doc", "string", "term", "token", "sword", "name", "field", "prefix", "language", "password", "char", "wd", "phrase", "title", "comment", "w", "search", "value", "piece", "part", "query", "W", "article", "Word", "message", "page", "text"], "replWebQuery": ["replwebForm", "ReplwebForm", "Replwebquery", "ReplWebquery", "replNetString", "replwebquery", "ReplWebQuery", "ReplwebString", "replNetQuery", "ReplWebForm", "replWebString", "replNetquery", "replWebForm", "replLivequery", "ReplwebQuery", "replNetForm", "replwebString", "replwebQuery", "replWebquery", "replLiveQuery", "ReplWebString"], "url": ["browser", "http", "pl", "link", "conn", "web", "l", "ld", "ll", "html", "rl", "address", "rel", "string", "location", "hl", "base", "loc", "open", "io", "client", "str", "il", "ssl", "dl", "u", "ur", "nl", "bel", "mount", "con", "URL", "gl", "resource", "file", "handle", "result", "log", "Url", "sl", "lr", "r", "page", "out", "buffer", "ls", "uri"], "content": ["code", "l", "lc", "data", "xml", "c", "document", "description", "Content", "f", "cont", "Contents", " contents", " text", "nl", "comment", " source", "txt", " data", "stream", "resource", "file", "article", "message", "x", "Text", "text", "source"], "in": ["inf", "m", "b", "n", "IN", "l", "inc", "xml", "inner", "cin", "sum", "body", "ins", "el", "input", "doc", "p", "reader", "rin", "bin", "In", "io", "is", "f", "isin", "and", "info", "file", "from", "conf", "inn", "r", "on", "ic", "out", "din", " din", "source"], "inputLine": ["resourceRecord", "textLINE", "textRow", "rawline", "formRow", "rawRow", "inputL", " inputFile", "inputline", "outputL", "activeL", "InputRecord", "textLine", "resourceline", "inputFile", "resourceLINE", "resourceLine", "outputRow", " inputline", "inline", "activeLine", "textline", "inputRow", "textFile", "formLINE", "outputLine", "Inputline", " inputL", "outputline", "inputPage", " inputLINE", " inputPage", "inputRecord", "InputLINE", "rawPage", "rawLine", "inRecord", "inLINE", "inLine", "inputLINE", "formLine", " inputRow", "InputLine", "formFile", "textPage", "activeRow", "activeline"], "fr": ["n", "pr", "ld", "fe", "tr", "ll", "rt", "elt", "frac", "rel", "tf", "rd", "adr", "dr", "rep", "jp", "fps", "fn", "f", "fin", "ver", "fp", "fc", "cr", "fm", "br", "fort", "nr", "Fr", "sim", "rid", "rr", "fd", "result", "mr", "fl", "pol", "FR", "hr", "fre", "mor", "cm", "repl", "lr", "r", "fire", "sr", "fy"]}}
{"id1": "9996334", "id2": "4716110", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"generateToken": ["generatorKey", "generatorToken", "generateKey", "generatorString", "generatesString", " GeneratesToken", " GeneratesString", " GeneratesKey", " GenerateString", " GeneratesCode", " GenerateToken", "generateCode", " GenerateCode", "generateString", "generatorCode", "generatesToken", "generatesKey", " GenerateKey", "generatesCode"], "code": ["command", "html", "data", "function", "address", "test", "hash", "Code", "string", "response", "token", "state", "template", "c", "name", "sequence", "error", "password", "char", "str", "e", "rice", "ce", "value", "reason", "close", "codes", "content", "ode", "hello", "component", "message", "x", "buffer", "text", "source"], "md": ["d", "m", "amd", "mg", "cd", "ld", "mand", "bd", "pd", "hd", "MD", "desc", "mm", "det", "od", "dr", "ind", "pm", "msg", "med", "mod", "cmd", "dd", "red", "der", "df", "pdf", "ms", "nd", "dh", "mt", "mc", "mn", "add", "rm", "mp", "mat", "mk", "sm", "sd", "mo", "dm", "di", "mb", "de", "ds"], "bytes": ["ds", "b", "strings", "objects", "raw", "words", "ents", "classes", "blocks", "keys", "parts", "users", "lines", "seconds", "pieces", "gets", "bps", "latest", "its", "pdf", "ms", "files", "bits", "steps", "hex", "results", "tes", "s", "versions", "es", "groups", "gb", "binary", "outs", "values", "bs", "pages", "unks", "Bytes", "gs", "terms", "vals"]}}
{"id1": "18005010", "id2": "19608872", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"setProfile": [" setProperty", " setDefault", "setProperty", "storeDefault", "storeProperty", " setProf", "SETProperty", "SETProf", "setProf", "storeProfile", "setDefault", "SETDefault", "storeProf", "SETProfile"], "loginName": ["loginNames", " loginKey", "fileKey", "displayKey", "fileNames", "displayNames", "loginKey", " loginNames", "displayname", " loginname", "filename", "loginname", "displayName", "fileName"], "profile": ["report", "summary", "project", "Profile", "settings", "usage", "phone", "policy", "header", "data", "hash", "property", "memory", "user", "p", "username", "template", "base", "plot", "table", "document", "details", "properties", "password", "client", "feature", "style", "panel", "json", "context", "mem", "note", "sample", "title", "position", "port", "account", "result", "log", "config", "update", "picture", "relation", "photo", "output", "face", "option", "role", "pool", "history", "prof", "pse", "buffer", "frame", "FILE", "pty", "line"], "outStream": ["offWriter", "aosPoint", "servstream", " outstream", "exPoint", " outPoint", "servSteam", "offStream", "outPoint", "OutFile", "Outstream", "outputSteam", "outputView", "outputStream", "outWriter", "outstream", "OutStream", "outputstream", "OutWriter", "offstream", "offSteam", "exWriter", "OutSteam", "exSteam", "exStream", "servView", "servStream", "OutView", " outView", "outSteam", "aosStream", "aosSteam", "outFile", "aosWriter", " outFile", "outView", "outputFile", " outWriter", " outSteam"], "url": ["browser", "http", "pl", "parse", "link", "web", "l", "html", "ll", "xml", "address", "q", "rel", "re", "location", "string", "base", "loc", "li", "open", "cert", "char", "client", "email", "f", "str", "abs", "mail", "ssl", "dl", "org", "build", "ur", "nl", "bel", "mount", "https", "URL", "resource", "service", "impl", "Url", "get", "host", "r", "path", "ls", "uri"], "file": ["report", "entry", "print", "link", "null", "web", "body", "filename", "download", "image", "template", "base", "name", "table", "document", "email", "f", "ile", "fp", " File", "info", "port", "le", "resource", "File", "local", "format", "library", "result", "lf", "binary", "output", "db", "path", "pool", "page", "out", "FILE", "tree"], "connection": ["to", "link", "conn", "command", "web", "condition", "pointer", "socket", "network", "generation", "session", "dial", "computer", "city", "no", "statement", "connected", "system", "database", "directory", "response", "Connection", "c", "still", "open", "client", "number", "closure", "cone", "bo", "sql", "nc", "character", "application", "con", "position", "established", "connect", "ion", "resource", "created", "close", "console", "relation", "net", "channel", "communication", "online"], "writer": ["entry", "walker", "rw", "ws", "network", "operator", "node", "inner", "writing", "function", "flush", "wright", "ner", "processor", "window", "reader", "journal", "editor", "maker", "Writer", "wt", "document", "builder", "wrapper", "external", "handler", "fn", "client", "worker", "outer", "commit", "wa", "caster", "write", "writ", "runner", "owner", "liner", "comment", "draw", "riter", "writers", "er", "word", "println", "counter", "w", "written", "iterator", "format", "driver", "loader", "widget", "creator", "wrote", "storage", "variable", "event", "usher", "WR", "buffer"], "myEnum": ["myenumb", "myENUM", "myEnUM", "myEnet", "myEncum", "someENums", "myEnom", "myENumb", " myAnet", "someEnums", "myEnums", "myAnums", "myenum", " myAnum", "myAnet", "myAcums", "myEncom", "someENumb", "myenom", "someEnumb", " myAnom", " myEnums", "myENum", "myEncumb", "myENom", "myEnumb", "myAnumb", " myEnet", "myAnUM", "myAcum", " myEnom", "myAnum", "someEnUM", "someENum", " myENumb", " myAnums", "myENet", " myEnumb", " myENom", " myENum", "myAcom", "someENUM", "myEncums", "myAnom", "myEncUM", "myAcet", "myENums", "someEnum"], "key": ["m", "entry", "n", "v", "val", "ex", "it", "step", "Key", "node", "keys", "k", "chain", "air", "pe", "test", "label", "no", "index", "string", "child", "hash", "ek", "one", "mac", "base", "cond", "token", "name", "field", "prefix", "type", "attribute", "col", "char", "str", "cell", "row", "var", "KEY", "bo", "pair", "parent", "note", "owner", "title", "column", "info", "ace", "element", "word", "primary", "value", "part", "member", "ice", "id", "variable", "host", "a", "i", "text", "item"]}}
{"id1": "7396682", "id2": "23088292", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["link", "cat", "cp", "cop", "create", "fit", "download", "Copy", "pixel", "clip", "transfer", "split", "load", "replace", "php", "core", "write", "cross", "upload", "move", "clone", "sync", "py", "proxy", "repeat", "crop", "gc", "map", "read", "opy", "zip", "delete", "Cop", "slice", "share", "archive"], "srcFS": ["rcFS", "sysFS", "srcOS", "srcFs", "rcFs", "sourceOS", "sysOS", "srMS", "sourceFs", " srcCS", "sysFs", "rcSF", "rcOS", "sourceVS", "sourceFS", "srcMS", "srcCS", "rcMS", "sourceSF", " srcMS", "sourceCS", "sourcefs", " srcFs", "sysVS", "srfs", "srcSF", "rcCS", "srFS", "srFs", " srcfs", "srcfs", "rcfs", " srcVS", "rcVS", "srcVS", " srcOS", " srcSF"], "src": ["syn", "http", "comp", "sci", "ctr", "pkg", "node", "SOURCE", "sec", "proc", "filename", "rel", "obj", "desc", "input", "via", "ser", "target", "obs", "th", "lb", "RC", "req", "rs", "selected", "loc", "rx", "iv", "secure", "str", "cont", "img", "sys", "usr", "subject", "rc", "init", "dir", "st", "pri", "sync", "sn", "Source", "cur", "inst", "https", "check", "url", "resource", "from", "boot", "start", "nil", "sit", "sc", "spec", "sub", "supp", "sb", "tmp", "addr", "path", "sin", "dest", "sr", "txt", "sq", "uri", "source"], "dst": [" dest", "lgt", "dsnd", " dlt", "Ddest", "degt", "dsgt", "ddst", "dnd", "DST", "dddest", "dsST", "dsst", "Dlt", "dslt", "dhst", "ddnd", "desst", "desdest", "dST", "Dest", "lest", "dedest", "ldest", "dDest", " ddest", "dhlt", "deest", "ddest", "deslt", "dgt", "Dst", "lst", " dST", "dsdest", "desnd", "dlt", "ddlt", "dsest", "dhdest", " dDest", "dest", "dhDest", "DDest"], "deleteSource": ["removeDest", "updateSOURCE", "destroySources", "delSOURCE", "deleteTarget", "updateSourceFile", "deleteSite", "deleteSourceFile", "removeSource", "updateSource", "leteParent", "deleteDest", "DeleteSOURCE", "closeSite", "leteSources", "closeSource", "leteTarget", "destroyResult", "leteSource", "delDest", "DeleteSite", " deleteSources", "delParent", "DeleteSource", "deleteSources", "delSource", "deleteSOURCE", "deleteResult", " deleteResult", "removeParent", " deleteTarget", "leteSOURCE", "closeSourceFile", "updateSite", "removeSOURCE", "destroyTarget", "deleteParent", "closeSOURCE", "leteResult", "destroySource", "DeleteSourceFile", "leteDest"], "conf": ["m", "css", "acc", "ca", "cache", "plan", "conn", "report", "prop", "q", "hash", "ctx", "mm", "cms", "req", "param", "cf", "comm", "f", "scan", "Conf", "ref", "ch", "co", "comment", "cb", "con", "info", "ban", "ln", "irm", "check", "com", "map", "log", "fs", "config", "job", "def", "params", "cfg", "cm", "lib", "pool", "cc", "cn", "conv"], "contents": ["contends", "Contterms", "CONTodes", "CONTENT", "contodes", "CONTents", "CONTresses", "CONTants", " content", "CONTent", "CONTENTS", "Contodes", " contterms", "Content", "contENTS", "Contents", " contants", "contresses", "constents", "constends", " Content", " contENTS", "contaves", " ContENTS", " contresses", "constENTS", " Contresses", " contaves", "ContENT", "content", "contants", "CONTaves", " Contents", "contterms", "CONTends", " contends", "contENT", "Contants", "constaves", " contodes", "CONTterms", " contENT"], "i": ["m", "multi", "ip", "n", "ci", "ui", "ij", "o", "it", "ji", "ei", "gi", "span", "key", "ami", "I", "q", "chain", "phi", "us", "inner", "index", "ind", "im", "ori", "\u0438", "y", "oi", "ki", "si", "iq", "li", "is", "ii", "ski", "ini", "xi", "client", "docker", "ie", "bi", "json", "u", "pi", "j", "ms", "me", "init", "iter", "cli", "ai", "sim", "mi", "ti", "ix", "id", "ims", "di", "my", "ic", "x", "hi", "qi"], "in": ["inf", "raw", "IN", "inc", "xml", "inner", "cin", "body", "ins", "doc", "input", "re", "reader", "ind", "bin", "In", "ini", "is", "char", "by", "ze", "sql", "isin", "sample", "con", "and", "mc", "check", "add", "from", "read", "en", "inn", "r", "out", "din", " din", "source"]}}
{"id1": "13152325", "id2": "20210699", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"loadExistingAntlibs": ["loadExistingAntlibFiles", "loadExistingantlibFiles", "loadExistingantLibd", "loadExistingAntibz", "loadExistingAntibs", "loadExistingantlibd", "loadExistingAntLibFiles", "loadExistingAntLibz", "loadExistingAntribFiles", "loadExistingantLibFiles", "loadExistingantLibz", "loadExistingantLibs", "loadExistingAntribs", "loadExistingantlibz", "loadExistingAntribd", "loadExistingAntLibs", "loadExistingAntlibd", "loadExistingAntibFiles", "loadExistingAntLibd", "loadExistingAntribz", "loadExistingantlibs", "loadExistingAntibd", "loadExistingAntlibz"], "classLoader": [" ClassReader", "classReader", " classReader", "ClassPath", " classLoad", " ClassLoader", " classloader", " classPath", "ClassReader", " ClassPath", " Classloader", "classloader", "ClassLoad", "classLoad", "ClassLoader", "classPath", " ClassLoad", "Classloader"], "antlibUrl": ["antsLibStr", "antlibraryRel", "antsLibUr", "antslibUrl", "antdburl", "antLibURL", "AntlibURL", "AntLibURL", "antlabUrl", "AntlibUr", "antLibRel", "antdbURL", "antLibUr", "antsLibUrl", "antribUrl", "antlibraryStr", "Antliburl", "AntLibUrl", "antslibUr", "antlaburl", "antdbUrl", "antlabStr", "antsLibURL", "antlibStr", "antLibStr", "antappUrl", "antsLibRel", "antslibRel", "antsLiburl", "antribURL", "antlibraryUrl", "antlibraryurl", "antlibraryURL", "antlibraryUr", "antappURL", "AntLiburl", "antriburl", "antappRel", "antappUr", "antslibStr", "antslibURL", "antlabUr", "antlibRel", "antsliburl", "antlibUr", "antLiburl", "antlibURL", "antribUr", "AntlibUrl", "AntLibUr", "antliburl", "antLibUrl", "antdbUr"], "antlibUri": ["antlibIris", "antlibUtri", "antLibIURI", "antlibGeris", "antlibIr", "antlibUtpi", "antlibEUris", "antlibIri", "antlibraryUsmi", "antLibUis", "antlibraryUne", "antlibUsris", "antlibUis", "antLibUtpi", "antlibEis", "antlibOr", "antlibUrid", "antlibraryUsris", "antlibUURI", "antlibUpi", "antlibUr", "antlibOne", "antlibIRI", "antlibIne", "antLibUrid", "antlibGeri", "antlibEURI", "antlibraryUris", "antlibURRI", "antlibUtrid", "antlibIpi", "antlibraryUsr", "antlibUtmi", "antLibIrid", "antlibraryURI", "antlibraryUmi", "antlibUsis", "antlibraryUsne", "antlibUsr", "antlibIrid", "antLibUtris", "antlibraryUsri", "antLibURI", "antlibUne", "antlibURmi", "antlibOri", "antlibUsURI", "antlibUsmi", "antLibUpi", "antlibEUpi", "antLibUris", "antlibEri", "antlibEris", "antlibraryUr", "antlibraryUri", "antlibIis", "antLibUtri", "antlibEUri", "antlibURI", "antlibURri", "antLibUURI", "antlibUtRI", "antLibIis", "antlibGerid", "antlibUsRI", "antLibIris", "antlibGeRI", "antlibUsne", "antlibOris", "antLibUri", "antlibUris", "antLibIRI", "antlibURris", "antlibIURI", "antLibIri", "antlibUtris", "antlibUmi", "antlibUsri", "antlibraryUsRI"], "resources": ["reports", "ries", "objects", "types", "images", "dates", "classes", "services", "keys", "users", "roots", "res", "seconds", "rs", "links", "parents", "ples", "issues", "actions", "files", "headers", "bytes", "stores", "writers", "ues", "works", "names", "books", "events", "iers", "relations", "packages", "checks", "modules", "groups", "workers", "models", "these", "ions", "years", "states", "builders", "archives", "values", "pages", "maps", "Resources", "ports"], "url": ["browser", "http", "entry", "link", "web", "l", "ll", "source", "rl", "xml", "address", "key", "server", "rel", "el", "date", "string", "location", "lb", "base", "name", "loc", "li", "char", "f", "str", "abs", "ssl", "dl", "ref", "ur", "nl", "bel", "mount", "request", "URL", "add", "resource", "gl", "file", "service", "format", "Url", "sl", "github", "get", "host", "r", "lr", "addr", "path", "util", "remote", "ls"], "stream": ["feed", "socket", "data", "inner", "body", "user", "input", "store", "window", "system", "response", "io", "open", "standard", "client", "row", "context", "sample", "stack", "pipe", "out", "iterator", "file", "resource", "loader", "read", "sl", "sw", "progress", "console", "content", "view", "zip", "Stream", "path", "message", "history", "channel", "buffer", "ream", "source"], "reader": ["entry", "socket", "rl", "inner", "server", "Reader", "ro", "ner", "reading", "parser", "rar", "via", "volume", "input", "older", "upper", "rx", "handler", "writer", "rer", "dd", "client", "collection", "layer", "row", "review", "runner", "liner", "sample", "iter", "roller", "er", "ri", "reviewed", "iterator", "resource", "rr", "driver", "range", "loader", "file", "read", "READ", "query", "console", "per", "r", "length", "buffer", "reads", "instance", "readable"], "line": ["entry", "n", "link", "print", "pos", "l", "lin", "eline", "header", "body", "pe", "label", "string", "lines", "lo", "msg", "li", "len", "str", "inline", "row", "Line", "ine", "cell", "text", "stay", "sql", "nl", "sample", "ls", "liner", "comment", "column", "ln", "block", "iter", "word", "port", "next", "le", "LINE", "file", "handle", "profile", "range", "log", "lf", "sl", "point", "message", "page", "buffer", "frame", "online"], "pkg": ["entry", "jar", "ip", "pt", "ppa", "pg", "cp", "lang", "key", "perm", "pid", "ctx", "root", "fx", "req", "plugin", "msg", "gp", "name", "mod", "kg", "rpm", "prefix", "deb", "Package", "pack", "password", "pod", "col", "alias", "var", "dl", "wd", "pair", "init", "module", "dir", "cmp", "patch", "port", "mask", "packages", "pp", "part", "quote", "zip", "lib", "path", "kid", "family", "imp", "p"], "uri": ["http", "ip", "ui", "link", " URI", "address", "iri", "folder", "system", "location", "directory", "term", "base", "io", "handler", "uid", "api", "pi", "connection", "ur", "domain", "uu", "cli", "URI", "ri", "proxy", "resource", "file", "local", "profile", "library", "mi", "id", "reference", "util", "i", "source"], "resource2antlib": ["resource1agentib", "resource2boltib", "resourcetoantloc", "resource2agentLib", "resource2boltlib", "resource2AntLib", "resource2antlibrary", "resource2etLib", "resource1agentlib", "resource2Antlibrary", "resource2ANTconfig", "resource2ntLib", "resourcetoantconfig", "resource2etli", "resource2antib", "resourcetoantlib", "resource2boltloc", "resource2ntib", "resource1agentLib", "resource2etlib", "resource2antli", "resource2Antli", "resource1antLib", "resource1agentlibrary", "resource2antsconfig", "resource1antlib", "resource2agentlib", "resource2agentib", "resource1antib", "resource1antlibrary", "resource2antconfig", "resourcetoANTib", "resource2ANTlib", "resource2etlibrary", "resource2antsloc", "resource2Antlib", "resource2antloc", "resource2ANTib", "resourcetoANTloc", "resourcetoANTlib", "resource2ntlib", "resourcetoantib", "resource2ntlibrary", "resource2Antib", "resource2agentlibrary", "resource2boltconfig", "resource2antslib", "resource2antLib", "resourcetoANTconfig", "resource2ntli", "resource2antsib", "resource2ANTloc"]}}
{"id1": "20275821", "id2": "19378010", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "label": 0, "substitutes": {"getAttribute": ["GetAttribute", "Getattribute", "GetAtt", "fileAttribute", "readAttribute", "fileattribute", "readAtt", "GetDirectory", " getAtt", "readattribute", "fileAtt", "getDirectory", "fileAttributes", " getattribute", "readAttributes", " getAttributes", "getattribute", "readDirectory", "getAttributes", "getAtt", " getDirectory"], "url": ["http", "b", "pl", "link", "conn", "null", "web", "l", "ll", "rl", "address", "server", "q", "el", "call", "user", "string", "base", "name", "loc", "document", "char", "str", "ul", "abs", "il", "ssl", "dl", "u", "ref", "connection", "ur", "nl", "sql", "https", "URL", "gl", "file", "resource", "log", "Url", "job", "sl", "cl", "host", "r", "path", "page", "conv", "ls", "uri"], "con": ["conn", "pos", "cp", "num", "dial", "proc", "canon", "Conn", "clean", "re", "free", "c", "cons", "open", "cf", "col", "ct", "client", "comm", "fin", "un", "ver", "cone", "cont", "trans", "connection", "fc", "nc", "co", "pc", "ln", "mc", "cur", "com", "connect", "don", "go", "CON", "ran", "soc", "bean", "ctrl", "const", "cc", "close", "can", "fl", "bc", "en", "ain", "conf", "cm", "cal", "pen", "on", "po", "bon", "cn", "conv", "Con"], "response": ["http", "entry", "zero", "code", "pos", "usage", "network", "esp", "amount", "resp", "reset", "server", "body", "res", "index", "total", "onse", "status", "state", "yes", "roads", "des", "os", "sequence", "error", "description", "trace", "compliance", "client", "number", "json", "when", "connection", "application", "e", "country", "none", "version", "request", "position", "next", "se", "respons", "Response", "result", "es", "success", "def", "esi", "message", "net", "relative"], "redirect": ["predir", " redir", "rewirect", "rewind", "rewrict", " Redind", "Redir", "redirection", " redirection", " redind", "redir", " Redrict", " reditional", "redrict", "Redirection", "predirect", "reditional", "predirection", " redrict", "preditional", "Redirect", " Redirect", "redind", " Redirection", "rewirection", "Reditional"], "location": ["link", "Location", "command", "slot", "operation", "pointer", "usage", "address", "filename", "system", "directory", "holder", "template", "loc", "area", "document", "layout", "ocation", "language", "details", "LOC", "hold", "behavior", "phrase", "sample", "comment", "where", "origin", "position", "zone", "resource", "local", "direction", "relation", "region", "reference", "path", "translation", "history", "relative", "remote", "uri"]}}
{"id1": "7757297", "id2": "18613870", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"submit": ["report", "print", "launch", "edit", "create", "execute", "post", "download", "input", "process", "accept", "login", " submission", "open", "form", "send", "save", "upload", "Submit", "request", "format", "close", "update", "sub", "run", "display", "apply"], "uri": ["http", "report", "wiki", "ui", "link", " URI", "campus", "address", "href", "iri", "filename", "location", "directory", "term", "msg", "name", "prefix", "description", "password", "subject", "pi", "ur", "title", "du", "info", "origin", "URL", "URI", "ri", "doi", "file", "resource", "range", "course", "id", "path", "message", "i", "source"], "Exception": ["Throw", "null", "ception", "Result", "Failure", "Message", "Document", "Default", "Connection", "Class", "T", "Error", "API", "Exit", "Status", "Application", "Warning", "Response", "E", "X", "Event", "EX"], "encodedrdf": ["encuredrp", "encodedrsl", "encodingrdf", "encuredrl", "encodedrdp", "encodedrsfs", "encodedwsfx", "encodingrsl", "encodeddrfc", "encuredrfc", "encodedrdfc", "encodedwsl", "encuredrdf", "encuredrdfc", "encodedrp", "encodedrsf", "encodingrsfs", "encodedrdl", "encodingrdfs", "encodedrtfx", "encodedrdfx", "encodingrdl", "encodedwsfs", "encodedwsf", "encodeddrl", "encuredrdl", "encodingrsf", "encodedridfc", "encuredrdp", "encodeddrf", "encodedrtf", "encodedrtfs", "encodedrsfx", "encodedrtl", "encodeddrp", "encodedrfc", "encodedrf", "encodingrdfx", "encodedridf", "encodedrdfs", "encodingrsfx", "encuredrf", "encodedridp", "encodedrl", "encodedridl"], "url": ["browser", "http", "b", "m", "link", "conn", "web", "l", "socket", "ll", "address", "p", "location", "base", "name", "loc", "li", "open", "cert", "client", "str", "ul", "ssl", "build", "ur", "nl", "mount", "con", "https", "URL", "resource", "file", "service", "log", "Url", "sl", "r", "sb", "ls"], "connection": ["entry", "n", "ticket", "link", "conn", "command", "l", "socket", "in", "web", "network", "generation", "condition", "session", "server", "function", "statement", "connected", "index", "database", "response", "Connection", "c", "document", "still", "open", "description", "io", "writer", "handler", "client", "number", "channel", "context", "application", "con", "position", "https", "established", "connect", "ion", "resource", "using", "result", "creator", "relation", "output", "message", "communication"], "lastUser": ["LastDate", "LastAuthor", " lastDate", "latestCategory", " lastCategory", "lastAuthor", " lastAuthor", "lastDate", "latestAuthor", "latestDate", "LastCategory", "lastCategory", "latestUser", "LastUser"], "out": ["o", "report", "to", "raw", "n", "print", "v", "screen", "list", "in", "ex", "it", "err", "null", "conn", "inner", "server", "chain", "obj", "inv", "res", "window", "OUT", "at", "timeout", "rem", "table", "up", "Out", "io", "ou", "writer", "cmd", "aos", "client", "line", "json", "cont", "sys", "ch", "co", "write", "init", "serv", "con", "check", "format", "cache", "help", "log", "ent", "set", "query", "all", "conf", "outs", "output", "gr", "pool", "net", "pretty", "conv", "txt", "p", "nt"]}}
{"id1": "19849797", "id2": "6159896", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFile", " cpfile", "copyfile", " cpFiles", " copyFiles", "transferStream", "copyFiles", "copyStream", " cpStream", " cpFile", "transferFiles", "transferfile", " copyStream", " copyfile"], "sourceFile": ["srcfile", " sourcePage", "sourcePath", "ourcePath", "srcFile", " sourcefile", "ourceFile", "srcPage", "sourcePage", " sourcePath", " sourceLine", "ourceLine", " sourceField", " sourceTable", "sourcefile", "srcLine", "srcPath", "srcTable", "sourceTable", "ourcefile", "ourceTable", "sourceField", "ourceField", "srcField", "ourcePage", "sourceLine"], "destFile": [" destFiles", "datFile", "srcFolder", "DestPath", "DestFile", " destPlace", "destPath", "datPlace", "declFile", "DestFilename", "srcFile", "datFiles", "destPlace", " destPath", "declEntity", "declDir", "restFiles", "optFolder", "optFilename", "restPlace", "srcDir", " destFilename", "DestFiles", "declFolder", "datFilename", "DestDir", "destDir", "optEntity", "srcPath", "restFile", "destFolder", "srcEntity", "srcFiles", "destFiles", "destEntity", "restFilename", "destFilename", "optFile", " destDir", "optPath", "optDir"], "source": ["parse", "scale", "in", "back", "use", "create", "cause", "inner", "SOURCE", "body", "show", "missing", "target", "input", "store", "index", "reader", "image", "load", "table", "sequence", "force", "attribute", "standard", "char", "check", "style", "OURCE", "subject", "send", "owner", "src", "scope", "sample", "init", "score", "comment", "none", "ource", "origin", "iter", "copy", "Source", "ce", "proxy", "stream", "search", "resource", "slave", "from", "service", "iterator", "se", "series", "start", "result", "note", "local", "query", "update", "match", "console", "spec", "component", "pose", "shell", "before", "channel", "ie", "parent"], "destination": [" destificate", "restination", "destation", "descation", "decinated", "Destificate", "separation", " destment", "descinator", "Destination", "Destation", "veration", "descination", "destinate", "separination", " destined", "decined", "restinate", "Destinated", "destinator", "verination", "destined", " destation", "Destment", " destinate", "terminination", "termininated", "restinator", "destinated", "decination", "destificate", "verificate", " destinator", "verinated", "separment", "restinated", "terminined", "Destinator", "separinated", "descinate", "decinate", "noninate", "destment", " destinated", "termininate", "noninated", "noninator", "Destinate", "nonination"]}}
{"id1": "11032546", "id2": "6501291", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": [" testCopyUnknownShape", " testCopyunknownLength", " testCopyunknownsize", " testcopyUnknownsize", " testcopyUnknownLength", " testCopyDifferentsize", " testCopyKnownShape", " testCopyKnownLength", " testCopyUnknownLength", " testcopyKnownShape", " testCopyunknownShape", " testCopyDifferentSize", " testcopyUnknownShape", " testCopyDifferentLength", " testCopyUnknownsize", " testCopyDifferentShape", " testcopyKnownSize", " testcopyKnownLength", " testCopyunknownSize", " testCopyKnownsize", " testCopyKnownSize", " testcopyKnownsize", " testcopyUnknownSize"], "in": ["inf", "null", "IN", "l", "it", "al", "data", "inner", "cin", "inv", "ins", "input", "mm", "ind", "rin", "bin", "up", "inside", "In", "is", "isin", "con", "copy", "file", "gin", "from", "log", "en", "ain", "inn", "sin", "r", "on", "i", "din", "source"], "out": ["o", "b", "to", "n", "list", "null", "it", "err", "ex", "data", "sum", "obj", "inv", "user", "res", "OUT", "at", "one", "os", "up", "Out", "ou", "io", "aos", "cmd", "client", "by", "end", "co", "con", "check", "t", "log", "auto", " Out", "result", "gt", "all", " OUT", "OU", "output", "outs", "on", "gr", "net", "a", "or"], "cpySize": ["cpysize", "cpeLength", "cplySize", " cpyLength", "CpyCount", "CplyLength", "cdyCount", " cpysize", "cdySize", "cfisize", "cpyLength", "cpyCount", "CpySize", " cplySize", "cdysize", "cplyCount", "Cpysize", "Cplysize", "cplysize", " cpyCount", "CplyCount", "cdyLength", "cpeSize", " cplyCount", "CplySize", " cplysize", "CpyLength", "cpeCount", "cplyLength", "cfiSize", "cpesize", "cfiCount", "cfiLength", " cplyLength"], "outArray": ["listArea", "outImpl", "inString", "outArea", "outString", "inArea", " outImpl", "neArray", "listArray", " outObject", "neObject", "outObject", "OUTarray", " outString", " outArea", "listImpl", "OUTObject", "outarray", " outarray", "outStream", "neStream", "OUTStream", "inArray", "nearray", "OUTArray", "inImpl", "listString", " outStream"]}}
{"id1": "21308543", "id2": "22536033", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "copyfile", "copyFiles", "cpDirectory", "cpFile", "cpfile", "CopyDirectory", "cloneFile", "cpFiles", "Copyfile", "copyDirectory", "CopyFile", "cloneDirectory", "clonefile", "cloneFiles"], "src": ["usc", "js", "ctr", "pkg", "rl", "rt", "sec", "rel", "ins", "ser", "obs", "req", "rs", "rx", "loc", "iv", "ipl", "cont", "sys", "usr", "subject", "rc", "ur", "init", "st", "Source", "cur", "inst", "start", "ix", "sit", "sc", "sb", "ripp", "sur", "fx", "sr", "sq", "source"], "target": ["to", "goal", "link", "test", "rel", "term", "that", "mac", "template", "base", "jp", "bolt", "replace", "touch", "top", "eth", "arg", "parent", "other", "arget", "patch", "next", "t", "file", "Target", "mk", "start", "result", "ARGET", "tt", "gt", "set", "match", "output", "delete", "nt", "dest", "the", "stop", "source"], "ic": ["tic", "mic", "ci", "ip", "eric", "ac", "it", "wic", "lc", "cin", "ik", "arc", "icing", "iq", "ican", "anc", "iu", "IC", "cit", "fc", "rc", "ric", "ics", "sic", "ib", "pc", "irc", "cli", "icc", "ico", "ia", "pic", "ix", "ice", "bc", "aic", "vc", "i", "isc", "iac", "cu", "nic"], "oc": ["osc", "o", "mic", "ci", "ac", "toc", "oss", "oct", "cos", "arc", "od", "oci", "c", "voc", "cus", "OC", "anc", "yo", "nc", "rc", "co", "ocon", "mot", "ot", "oco", "ko", "pc", "og", "unc", "irc", "mc", "ico", "gc", "soc", "pic", "bc", "aic", "roc", "ec", "ocr", "cc", "isc", "cu", "ob", "ox", "nic"]}}
{"id1": "3409084", "id2": "8385785", "code1": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"getRequestContent": ["postResponseContent", "getQueryEntity", "getRequestEntity", "postResponseEntity", "getResponseData", "postRequestBody", "getRequestData", "postResponseBody", "postResponseData", "getStringBody", "getStringContent", "postRequestData", "getQueryContent", "getQueryData", "getStringData", "getQueryBody", "getStringEntity", "getResponseBody", "getRequestBody", "getResponseContent", "getResponseEntity", "postRequestEntity", "postRequestContent"], "urlText": ["UrlName", "urlName", "uriCh", "textName", "texttext", "urltext", " urlName", "uritext", "urlString", "UrlString", "urlCh", "stringText", "stringCh", "uriText", " urlString", "Urltext", "textText", "stringtext", "UrlText", " urltext", " urlCh", "textString"], "url": ["browser", "http", "web", "l", "ll", "pkg", "rl", "el", "re", "hl", "lb", "base", "atl", "oul", "loc", "char", "email", "www", "f", "google", "str", "ul", "il", "abs", "ssl", "dl", "org", "ref", "build", "ur", "nl", "bel", "mount", "URL", "gl", "auto", "Url", "sl", "github", "r", "ls", "uri", "uu"], "urlcon": ["httpCon", "urlres", "urlcom", "urlconn", "Urlcon", "dllconst", " urlres", "urlCon", " urlconnect", "dllconn", "httpres", "dllcon", "URLconn", " urlconv", "URLcon", "sslconv", "orgCon", "sslCon", "urlconv", "urlfun", "orgconnect", "urlconst", "urlconnect", " urlcom", "httpconn", "orgcon", "httpconv", "httpconst", "orgres", "Urlconn", "Urlcom", "UrlCon", " urlconn", "httpfun", " urlfun", "URLcom", "Urlconst", "sslfun", " urlCon", "httpcon", "sslcon", "httpconnect", "dllCon"], "reader": ["radio", "operator", "rl", "data", "inner", "Reader", "test", "ro", "ner", "reading", "parser", "rar", "rd", "dr", "image", "holder", "upper", "older", "rx", "wrapper", "handler", "writer", "dd", "red", "worker", "row", "draft", "rc", "review", "runner", "comment", "info", "iter", "roller", "er", "stream", "iterator", "loader", "master", "read", "READ", "ader", "view", "per", "r", "buffer", "reads", "instance", "readable", "source"], "line": ["entry", "link", "continue", "print", "command", "l", "list", "detail", "lin", "eline", "lc", "header", "chain", "pe", "string", "lines", "response", "name", "sequence", "trace", "char", "str", "cell", "row", "inline", "Line", "ine", "channel", "nl", "sample", "comment", "column", "request", "ln", "block", "LINE", "file", "piece", "log", "result", "content", "message", "page", "out", "frame", "text"]}}
{"id1": "9954926", "id2": "9857412", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"simulate": ["simure", " simulation", "smulation", "modulates", "smulates", "modure", "simulates", " simulates", "simulation", " simure", "modulate", "modulation", "smure", "smulate"], "out": ["b", "cache", "print", "list", "null", "in", "it", "hit", "ins", "state", "c", "io", "client", "sys", "ger", "init", "con", "manager", "go", "w", "t", "exp", "gr", "o", "report", "n", "to", "raw", "v", "ex", "inner", "flush", "store", "at", "base", "os", "up", "Out", "aos", "cmd", "copy", "handle", "gov", "help", "ent", "set", "content", "output", "pool", "buffer", "p", "nt", "batch", "screen", "conn", "err", "sum", "OUT", "writer", "f", "write", "put", "nr", "last", "can", "all", "conf", "OU", "outs", "on", "pretty", "tree", "gen", "obj", "inv", "res", "group", "name", "error", "ou", "outer", "co", "e", "gc", "log", "cfg", "net", "cn", "conv"], "file": ["b", "report", "l", "data", "filename", "play", "input", "base", "template", "name", "table", "document", "io", "type", "f", "ile", "channel", "fp", "connection", "e", "port", "le", "format", "t", "resource", "File", "handle", "library", "result", "log", "set", "model", "console", "output", "db", "lock", "path", "message", "pool", "buffer", "FILE", "source"], "obtainUserReputationRequest": ["obtainUserRepetitionRequest", "obtainUserRepositoryQuery", "obtainUserRepresentationError", "obtainUserReputationTarget", "obtainUserRepresentationResponse", "obtainUserRepresentutationError", "obtainUserReputationsTask", "obtainUserRelutationTask", "obtainUserReputationrequest", "obtainUserRepetitionResponse", "obtainUserReputationsResponse", "obtainUserReporationQuery", "obtainUserRepationTarget", "obtainUserReplutationRequest", "obtainUserRelutationResponse", "obtainUserReputationsQuery", "obtainUserRepresentutationRequest", "obtainUserReplutationTarget", "obtainUserReporationError", "obtainUserRelutationsResponse", "obtainUserRelutationQuery", "obtainUserRelutationRequest", "obtainUserRepresentutationTarget", "obtainUserRepationrequest", "obtainUserReplutationResponse", "obtainUserReputionResponse", "obtainUserReputationQuery", "obtainUserReporationRequest", "obtainUserReputationsRequest", "obtainUserRepationError", "obtainUserRepresentationrequest", "obtainUserRepationResponse", "obtainUserReputionrequest", "obtainUserRepationRequest", "obtainUserRepationQuery", "obtainUserRepresentutationrequest", "obtainUserReputationsrequest", "obtainUserReputionTarget", "obtainUserRelutationsQuery", "obtainUserReputationError", "obtainUserRelutationsRequest", "obtainUserRelutationsTask", "obtainUserRepresentationQuery", "obtainUserRepresentationTarget", "obtainUserRepositoryTask", "obtainUserRepresentutationResponse", "obtainUserReputationsError", "obtainUserReporationResponse", "obtainUserRepresentationRequest", "obtainUserReputionTask", "obtainUserRepositoryResponse", "obtainUserRepetitionTarget", "obtainUserRepresentutationQuery", "obtainUserReputionQuery", "obtainUserReputationTask", "obtainUserRepositoryRequest", "obtainUserReputionRequest", "obtainUserReputationsTarget"], "obtainUserReputationResponse": ["obtainUserRepulationService", "obtainUserRepulationResponse", "obtainUserRepositoryAnswer", "obtainUserReportositoryAnswer", "obtainUserReputationsResp", "obtainUserRepositoryService", "obtainUserReportositoryResponse", "obtainUserReputationsResponse", "obtainUserReputationService", "obtainUserReportositoryResp", "obtainUserRepulationResp", "obtainUserReputationResp", "obtainUserReportositoryService", "obtainUserReportutationAnswer", "obtainUserReputationAnswer", "obtainUserRepositoryResp", "obtainUserReportutationResp", "obtainUserReportutationResponse", "obtainUserReputationsAnswer", "obtainUserReportutationService", "obtainUserRepositoryResponse", "obtainUserReputationsService", "obtainUserRepulationAnswer"], "rateUserRequest": ["RateUserResponse", "rateJobRequest", "rateOwnerRecord", "createUserCommand", "rateTimeRequest", "rateRowResponse", "createUserRequest", "raceUserrequest", "rateOwnerResponse", "rateOwnerRequest", "rateLineResponse", "RateUserRequest", "createuserRequest", "rateUserChange", "scaleOwnerResponse", "RateLineQuery", "rateUsersRequest", "rateJobResponse", "raceRowRecord", "rateSampleCommand", "rateClientrequest", "rateSampleRequest", "rateOwnerrequest", "rateUserQUEST", "RateClientResponse", "createUserRequ", "rateJobChange", "scaleOwnerRequest", "RateClientGrant", "RateLineResponse", "rateUserJob", "rateLineGrant", "rateUserGrant", "rateOwnerAccess", "scaleUserRequest", "rateClientGrant", "rateLineRequ", "rateDateGrant", "RateUsersRequest", "raceUserRequest", "rateLineQuery", "RateClientRequest", "rateSamplerequest", "rateUserAccess", "rateLinerequest", "rateProxyResponse", "raceUserRecord", " rateUserJob", "rateUserQuery", "RateUsersQuery", "rateUserRequ", "rateuserCommand", " rateUserrequest", "rateuserQUEST", "rateUsersAccess", "rateuserResponse", "rateSampleRequ", "scaleUserAccess", "rateClientRequest", "rateUsersQuery", "rateUserCommand", "rateRowRecord", "rateRowrequest", " rateUserQuery", "rateTimeResponse", "rateRowJob", "rateProxyRequest", "createuserrequest", "rateUsersQUEST", "rateRowRequest", "rateUsersrequest", "createuserCommand", "rateUsersResponse", "rateTimerequest", "raceRowRequest", "RateUsersQUEST", "rateProxyQuery", "rateuserQuery", "RateUserQuery", "rateDateRequest", "rateClientResponse", "rateUsersChange", "rateUserRecord", "rateuserRequ", "RateUserChange", "RateUserrequest", "scaleUserResponse", "rateDateResponse", "createUserrequest", "RateUsersrequest", "rateuserrequest", "rateProxyQUEST", "RateUsersResponse", "RateUserQUEST", "createuserRequ", "RateLineRequest", "rateLineRequest", "RateUserGrant", "rateuserRequest", "rateuserAccess", "RateLinerequest", "rateLineCommand", "RateUsersChange", "rateClientJob", "rateUserrequest", "scaleOwnerAccess", "raceRowrequest"], "rateUserResponse": ["RateUserResponse", "ratesUserMessage", "rateClientReturn", "rateControllerRequest", "rateTimeRequest", "rateControllerMessage", "rateUsersReply", "rateMethodVersion", "rateUserReply", "rateTimeAnswer", "RateUserRequest", "ratesClientResp", "rateUserResp", "rateFileresponse", "rateUsersRequest", "rateWordRequest", "rateFileRequest", "rateWordReturn", "ratesUserResponse", "rateMemberResponse", "rateUserReturn", "ratesClientMessage", " rateClientResponse", " rateClientRequest", "rateMethodRequest", "rateMethodResponse", "RateUsersRequest", "rateUserVersion", "RateUserVersion", "RateUsersReply", "rateuserresponse", "rateMemberReply", "RateUsersresponse", "rateUserMessage", "rateManagerMessage", "rateUserresponse", "ratesUserRequest", "rateWordresponse", "rateFileResponse", "rateMemberresponse", "rateuserResponse", "rateUserAnswer", "rateDateVersion", "rateMemberRequest", "RateUserresponse", "RateUserReply", "rateDateData", "rateMethodData", "rateClientRequest", "rateTimeResponse", " rateUserStatus", " rateUserAnswer", "rateManagerRequest", " rateUserReturn", " rateUserresponse", "rateUsersStatus", "rateUserStatus", "rateUsersResponse", "rateControllerResponse", "rateControllerResp", "rateManagerResponse", "rateUserData", " rateClientresponse", "ratesClientResponse", "ratesUserResp", "rateDateRequest", "rateClientResponse", "RateUserData", " rateClientReturn", "rateClientResp", "rateWordResponse", "rateClientresponse", "rateuserReply", "rateTimeStatus", "rateDateResponse", "rateUsersresponse", "rateClientMessage", "RateUsersResponse", "rateManagerResp", "rateuserRequest", "rateUsersAnswer", "ratesClientRequest", "rateFileReturn"], "fis": [" fisa", "bis", "liss", "lis", "bisa", "fiss", "fIs", "sfIs", "fisa", "FIs", "flis", "lIs", "fi", "bi", "fli", "Fiss", "fIS", "sfIS", "Fis", "flisa", " fi", "sfis", "sfiss", "FIS", "lIS"], "br": ["browser", "BR", "pr", "bh", "tr", "ctr", "bd", "ber", "wr", "adr", "dr", "bt", "kr", "bp", "shr", "str", "bi", "buf", "bn", "ch", "cr", "bf", "ger", "bro", "div", "nr", "be", "mr", "vr", "gb", "hr", "fr", "bm", "bl", "lr", "gr", "sr", "Br", "bridge"], "call": ["Call", "report", "n", "code", "list", "continue", "command", "use", "function", "cin", "dial", "test", "execute", "play", "inv", "label", "ell", "status", "c", "name", "trace", "char", "callback", "str", "cell", "send", "contact", "comment", "draw", "request", "info", "block", "word", "check", "add", "url", "called", "result", "log", "query", "update", "all", "cal", "message", "action", "frame", "bridge", "line"]}}
{"id1": "9826240", "id2": "17161805", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"checkHashBack": [" checkhashDown", " checkhashUp", "checkLockback", "checkHashUp", "checkClearback", "checkHashback", "checkLockUp", "checkClearDown", "checkhashDown", "checkHashDown", " checkHashDown", "checkLockBack", "checkLockDown", " checkhashBack", "checkClearBack", "checkhashUp", " checkhashback", " checkHashUp", "checkhashback", "checkClearUp", "checkhashBack", " checkHashback"], "facade": ["servaded", "famificate", "latace", "latade", "Facader", "Facage", "famade", "funcace", "latader", "facades", "facace", "funclegate", "facaded", "Facades", "facage", "formificate", "faclegate", "Facade", "servades", "facader", "latlegate", "glader", "formade", " facage", "glage", "facificate", "facacet", "glace", "funcader", "Facificate", " facades", "Facacet", "glade", "servade", "funcage", "formace", "Faclegate", "famacet", "Facaded", "funcade", "servage", "formacet", "Facace", "famace", " facaded"], "req": ["http", "forced", "err", "wcs", "ctr", "pkg", "qs", "data", "resp", "body", "q", "proc", "ctx", "obj", "res", "desc", "rh", "attr", "wx", "rec", "msg", "reg", "rpm", "aux", "quest", "jp", "requ", "rb", "cmd", "queue", "org", "compl", "e", "work", "request", "required", "qt", "cur", "urg", "out", "forge", "Request", "uj", "Resp", "mr", "require", "tx", "qq", "needed", "etc", "params", "good", "r", "gr", "Requ", "sq", "p"], "txtTransactionID": ["txtTransactionName", "txtTXName", "xtTransactionId", "textTransactionName", "txtTxKey", "txtTransName", "xtTransactionName", "txtTransactionKey", "txtTxName", "xtTxID", "xtTxName", "textTxId", "xtTransactionKey", "txtOrderId", "txtOrderID", "txtTxID", "txtTxId", "xtTxKey", "textTransactionId", "txtOrderKey", "txtTransID", "textTxName", "txtTXID", "xtTxId", "textTransactionID", "txtTransactionId", "txtTXId", "txtTransId", "textTxID", "txtTransKey", "xtTransactionID", "txtOrderName"], "txtOrderTotal": ["strOrderBase", "txtOrdId", "strOrderTotal", "txtArticleSum", "txtOrdBase", "strOrderComplete", "xtOrderId", "txtArticleTotal", "xtOrderInfo", "xtOrderSum", "txtOrdComplete", "strTransactionComplete", "txtTransactionBase", "xtOrdTotal", "txtOrderId", "xtOrdSum", "txtJobInfo", "txtOrderInfo", "txtTransactionTotal", "txtTradeTotal", "xtOrderTotal", "txtOrdSum", "txtArticleInfo", "xtOrdInfo", "txtTransactionComplete", "txtOrderSum", "txtOrdInfo", "txtJobTotal", "xtOrdId", "strTransactionTotal", "txtTradeBase", "strTransactionBase", "txtArticleId", "txtTradeComplete", "txtJobSum", "txtOrderComplete", "txtOrderBase", "txtJobId", "txtOrdTotal"], "txtShopId": ["textStoreById", "txtSiteAid", "textStoreID", "txtStreetid", "textShopID", "xtShopID", "xtSiteid", "txtShopAid", "txtForgeid", "textStoreid", "txtServerID", "textShopById", "txtStoreID", "txtSiteById", "xtShopId", "txtServerId", "txtSiteid", "txtForgeAid", "xtShopid", "xtShopAid", "xtSiteID", "textShopId", "xtSiteId", "txtStreetID", "txtShopID", "txtServerAid", "xtSiteAid", "txtShopById", "txtStoreById", "txtStoreid", "txtStreetId", "textShopid", "txtServerid", "txtForgeID", "txtShopid", "txtStoreId", "txtSiteId", "txtSiteID", "txtStreetById", "textStoreId", "txtForgeId"], "txtArtCurrency": ["txtArtConcurrency", "txtArticleCurrencies", "txtArticleConurrency", "txtArtCoulture", "txtArtCoategories", "txtArtConurrencies", "txtArtColategories", "txtArtCurrencies", "txtArtConategories", "txtArticleCocurrency", "txtArticleCourrency", "txtArticleConategories", "txtArtConulture", "txtArticleConcurrency", "txtArtCulture", "txtArtColurrency", "txtArtConurrency", "txtArtCourrency", "txtArticleCoulture", "txtArtCourrencies", "txtArticleCourrencies", "txtArtCocurrency", "txtArticleCcurrency", "txtArticleCulture", "txtArticleCategories", "txtArticleCurrency", "txtArtColcurrency", "txtArtCcurrency", "txtArtCategories"], "txtHashBack": ["textHashback", "texthashBACK", "txtHashFront", "txtLockback", "txtStockBACK", "texthashback", "xtStockback", "txtFilterFront", "texthashBack", "txtHelpFront", "txtLockBACK", "txtClearBACK", "txtFilterBack", "txtStockBack", "txtHelpBack", "textHashBack", "txtFilterback", "xtHashback", "txtStockback", "txtClearback", "txtHashback", "texthashValue", "txtFilterBACK", "textHashValue", "txtHelpBACK", "txthashFront", "xtHashFront", "txthashValue", "txtHashBACK", "xtStockBACK", "txtLockBack", "txtClearBack", "textHashFront", "xtHashBack", "txtRawback", "txtRawBACK", "txthashBACK", "txthashBack", "txtClearFront", "txtRawBack", "xtStockBack", "textHashBACK", "texthashFront", "txtStockFront", "txthashback", "txtHashValue", "txtRawValue", "xtHashBACK", "txtLockFront", "txtHelpback", "xtStockFront"], "hashSeed": ["hoAsetter", "hashFep", "hashSetter", "hashSourceetter", "hoSep", "hashFetter", "hoAseed", "hashSep", "hashSeeed", "hashSourceep", "hashSlee", " hashSeiper", "hashSliper", "hoSetter", " hashSee", "hashSleed", " hashSiper", "hoAsep", "hashSeeeds", " hashSeeds", "hashFeed", "hashSourceeed", " hashSeeeds", "hoSeder", "hashSeder", "hashSeiper", "hoSeed", "hashAseder", "hashAsep", "hashAseed", " hashSeeed", "hashSee", "hashAsetter", "hashSeeds", "hashSeee", "hashSleeds", " hashSeee", "hashSiper", "hashSourceeder", "hashFeder", "hoAseder"], "securityValue": [" securityValues", " securityData", "secVal", "SecurityData", "securityValues", "securityVal", "secData", "securityData", "secValues", "SecurityValue", " securityVal", "secValue", "SecurityValues", "SecurityVal"], "digest": ["equest", "contested", "digests", "Digested", "contse", "macested", "diget", "dEST", "Diget", "Digest", " digested", "Digests", "dependester", " digEST", " digester", "contest", "macgest", "diger", "equse", "contests", " diger", "DigEST", "digested", "der", "macester", "diggest", "dependgest", "macest", " digests", " digse", "Digse", "Diger", "digester", "digEST", "dester", " diget", "dependested", "equester", "Diggest", "equet", "digse", "dest", "dested", "dependest", "Digester", "dse"], "array": ["ashes", "v", "batch", "raw", "list", "record", "ash", "angle", "arrow", "av", "string", "audio", "response", "arr", "shape", "area", "ray", "iq", "bar", "collection", "stage", "attribute", "ar", "our", "number", "row", "export", "pair", "sha", "rays", " Array", "vector", "now", "RAY", "range", "map", "max", "angular", "Array", "binary", "object", "view", "share", "a", "length", "buffer", "archive", "instance"], "sb": ["pb", "abb", "bj", "bh", "bis", "sbm", "rob", "obs", "zb", "lb", "bt", "stab", "bps", "rb", "gob", "ob", "abs", "sa", "ssl", "sv", "rub", "lp", "bf", "sam", "bg", "ls", "cb", "ib", "sn", "sf", "obb", "kb", "gc", "soc", "bsp", "wb", "orb", "ctrl", "gb", "bb", "eb", "nb", "shell", "esm", "bs", "sg", "erb", "SB", "sq"], "j": ["ij", "n", "att", "v", "bj", "yy", "js", "it", "ja", "key", "jo", "k", "q", "obj", "el", "ind", "bot", "msg", "state", "jp", "kj", "jj", "jump", "json", "jit", "br", "aj", "from", "ody", "uj", "jl", "dj", "jet", "ix", "job", "jc", "_", "g", "gr", "J", "x", "i", "oj", "ji", "z"], "b": ["v", "bis", "bd", "h", "k", "bt", "base", "B", "bu", "BB", "rb", "bp", "bar", "ab", "bi", "bit", "ba", "bf", "bg", "br", "cb", "ib", "fb", "be", "beta", "gb", "bb", "bc", "eb", "binary", "bound", "db", "nb", "mb", "bs"], "hash": ["ashes", "uh", "report", "cache", "bh", "ash", "html", "header", "data", "address", "sum", "h", "href", "filter", "test", "key", "rh", "string", "total", "response", "Hash", "password", "flash", "json", "ssl", "ASH", "ah", "sample", "title", "where", "version", "hex", "block", "crypt", "check", "search", "url", "value", "format", "handle", "buster", "result", "oh", "hz", "message", "tag", "sha", "height"]}}
{"id1": "15904772", "id2": "2199604", "code1": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"getSystemStateHash": ["getSysStateHash", "getSystemRandomSalt", "getSystemLocalhash", "getSystemRandomhash", "getSysStateSalt", "getSystemStatesSalt", "getSystemRandomKey", "getSystemStateSalt", "getSysStateKey", "getSystemStatesKey", "getSysStatesSalt", "getSystemRandomHash", "getSystemStateshash", "getSystemStatesHash", "getSystemLocalHash", "getSysStateshash", "getSystemLocalSalt", "getSystemStateKey", "getSystemStatehash", "getSysStatesKey", "getSysStatesHash", "getSystemLocalKey", "getSysStatehash"], "sha1": ["haone", "SHA2", "ka01", " SHA11", "scheone", "shake61", "sha100", "sh3", "tarache", "shOne", "sh0", "ppa1", "sh9", "haacy", "SHA3", "wa1", "sh11", "sche9", "haache", " SHA001", "sche11", "tar384", "ka3", "shacy", "sche1", "sche81", "sh100", "sha51", "ppa100", "ha2", "ssh8", "tar100", " SHA1", "tar3", "ssh1", "sh384", "haOne", "sha7", "SHAone", "ppa01", "sh7", "shaacy", "shaache", "sche6", "sha6", "sche256", "no81", "sha2", "sh2", "sh81", "sha001", "ssh6", "sha3", "sh61", "ha100", "sche51", "sche3", "ha384", "sche4", "waone", "ha001", "shape4", "sh01", "sche61", "tar7", "sche0", "amiacy", "sh64", "ha4", "scheache", "sh8", "SHA4", "sha61", "ha256", "ha9", "ha6", "ami1", "sha9", "SHA1", "shone", "sh4", "sh1", "shake1", "sha11", "ha11", "sh256", "tar01", "ka81", "no3", "ha1", "ha3", "shapeache", "ka11", "ha01", "shake64", "ka1", "sha01", "sche2", "sha4", "shape1", "no1", "sche8", "sha384", "ssh81", "ka001", "no01", "shape51", "tar1", "scheOne", "ha0", "ha7", "shache", "ha8", "sche7", "ha64", "ha51", "ami7", "sche100", "sha8", "sha64", "ppaache", "sha0", "sha81", "shaone", "sha256", "shaOne", "sh6", "sche64", "wa3", "shake7", "ha81"], "props": ["Probs", "pperties", "prop", "preps", "pbs", "rors", "prperties", " proms", "Prop", "proPS", " prop", "prePS", "pports", "prports", "properties", "Prors", " proPS", "proms", "prors", " prors", "prbs", "roperties", "rops", "roms", "prps", "Props", "preperties", "Proports", "probs", " properties", "ProPS", "prep", "proports", "pps", "Proms", "Properties"], "names": ["strings", "n", "Names", "objects", "mas", "words", "members", "keys", "AMES", "ons", "papers", "als", "ids", "ern", "parents", "ews", "properties", "ens", "paces", "photos", "nos", "ms", "ames", "testers", "makers", "files", "nes", "events", "s", "versions", "aps", "pres", "beans", "nm", "modules", "groups", "ones", "these", "chains", "codes", "ers", "ors", "appers", "ren", "values", "ports", "nets", "ns", "terms", "idents"], "name": ["entry", "n", "print", "code", "named", "num", "node", "Name", "key", "NAME", "create", "address", "nam", "label", "no", "string", "term", "base", "prefix", "description", "type", "attribute", "item", "number", "str", "alias", "var", "class", "pair", "common", "ame", "title", "comment", "old", "info", "word", "size", "url", "resource", "value", "nm", "part", "id", "def", "event", "path", "a", "family", "parent"]}}
{"id1": "10451698", "id2": "4716110", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copy": ["link", "continue", "cat", "cp", "create", "cop", "perm", "download", "paste", "Copy", "pixel", "clip", "transfer", "split", "remove", "core", "export", "write", "co", "move", "clone", "sync", "proxy", "file", "crop", "gc", "map", "opy", "zip", "delete", "Cop", "slice", "share", "archive"], "source": ["http", "entry", "raw", "cache", "null", "in", "use", "space", "create", "inner", "SOURCE", "body", "site", "target", "store", "instance", "index", "directory", "image", "status", "template", "base", "name", "table", "secure", "details", "style", "subject", "class", "unit", "sql", "src", "scope", "note", "init", "sp", "none", "force", "ource", "origin", "Source", "size", "ce", "resource", "file", "from", "service", "local", "se", "original", "start", "config", "sit", "query", "spec", "get", "empty", "shell", "sin", "remote", "ie", "current", "parent"], "destinationDirectory": ["destinationApplication", "identinatorInternal", "destationApplication", " destinationFolder", "targetinationdirectory", "destinateApplication", "destationFolder", "targetinationsDir", "targetinationFolder", "destinatorDirectory", "destationDirectory", "identinationDirectory", "destationdirectory", " destinationdirectory", "targetinationsDirectory", "destinatorLocation", "destinedirectory", " destationdirectory", "destineApplication", "targetinationDir", "targetinationsFolder", "destarationInternal", "destinationsdirectory", "destineFolder", "identinatorLocation", "destinationFolder", "identinatorDirectory", " destationFolder", "identinationInternal", "destinationDir", "destinatedirectory", "destarationDirectory", "destinationsFolder", "identinationLocation", "destinationsDirectory", "destmentDir", "destinationsLocation", "destinatorInternal", "targetinationDirectory", "destineDirectory", "destmentFolder", "destmentDirectory", "destinationsInternal", "destinationLocation", " destinationApplication", " destationApplication", "destinationdirectory", "destarationLocation", "destinateDirectory", "targetinationsdirectory", "destinationsDir", "destinationInternal", "destinateFolder", " destationDirectory", "destmentdirectory"], "newDir": [" newDirectory", "NewFile", "newsFile", "newsDirectory", "Newdir", "nextFile", "NewDirectory", "newsdir", "NewRel", "nextDir", " newFolder", " newRel", "newsFolder", "newsDir", "newDirectory", "NewDir", "newFolder", "newRel", "NewFolder", "nextRel", "newdir", "nextdir", " newdir"], "children": ["reports", "objects", "cache", "images", "follow", "apps", "Children", "classes", "blocks", "members", "times", "services", "keys", "users", "uploads", "desc", "child", "lines", "related", "unknown", "ids", "links", "parents", "many", "details", "its", "cont", "when", "may", "files", "his", "resources", "each", "jobs", "names", "gc", "relations", "pres", "groups", "modules", "items", "packages", "ml", "nil", "kids", "these", "bc", "all", "sub", "ren", "projects", "pages", "ports", "stories", "ls"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "batch", "in", "ex", "ji", "it", "gi", "span", "key", "q", "chain", "phi", "us", "index", "base", "im", "y", "oi", "ki", "si", "iq", "li", "is", "ski", "gu", "ini", "iu", "ii", "client", "ie", "io", "xi", "bi", "json", "pi", "j", "u", "um", "x", "ms", "me", "init", "info", "iter", "ri", "ai", "sim", "t", "ti", "mi", "ix", "id", "point", "g", "ims", "di", "my", "ic", "remote", "I", "you", "hi", "qi", "uu"], "newFile": ["createfile", "goodSourceFile", "ewDir", "NewFile", "ewFile", "newsfile", "newSourceFile", "ewLe", "newsFile", "newfile", "nextFile", "createFile", "newLe", "goodfile", "NEWTh", "NEWDir", "nextLe", "NewTh", "nextfile", " newfile", " newSourceFile", "nextDir", "newsGlobal", "NEWFile", " newGlobal", "ewfile", "NEWfile", "newsDir", "NewDir", "createSourceFile", "Newfile", "newGlobal", "goodFile", "newsTh", "createDir", "NewGlobal", "newTh", "goodDir", "NewLe"], "output": ["batch", "print", "web", "network", "enabled", "blue", "four", "body", "response", "monitor", "admin", "document", "io", "open", "writer", "client", "outer", "export", "cut", "text", "connection", "write", "put", "position", "block", "ilo", "out", "next", "stream", "file", "internal", "format", "connect", "result", "auto", "config", "exit", "success", "update", "console", "object", "Output", "message", "display", "net", "pretty", "buffer", "online", "current", "parent"], "input": ["inf", "insert", "ip", "raw", "feed", "in", "it", "inc", "back", "operator", "inner", "unsigned", "buffer", "child", "reader", "image", "exec", "Input", "error", "io", "open", "ahead", "form", "rc", "init", "active", "upload", "info", "iter", "add", "before", "internal", "from", "local", "start", "storage", "initial", "op", "get", "ic", "ink", "out", "current"], "buff": [" buf", "pb", "b", "xx", "batch", "comp", "tab", "cat", "data", "black", "ind", "msg", "seq", "bin", "cond", "hold", "ff", "uf", "cmd", "xff", "buf", "text", "bed", "img", "bo", "mem", "ch", "bf", "bg", "nd", "box", "cb", "bytes", "old", "fb", "printf", "tt", "qq", "gb", "bb", "eb", "uff", "bl", "bound", "nb", "sb", "mb", "bs", "Buff", "buffer", "txt"], "read": ["d", "raw", "print", " Read", "give", "need", "feed", "in", "push", " count", "skip", "q", "test", " write", "buffer", "index", "bind", "reading", "tell", "ind", "seek", "load", "hold", "height", "end", "str", "count", "send", "mem", "write", "and", "old", "iter", "size", "check", "wait", "stream", "add", "before", "t", "handle", "start", "ready", "READ", "config", "query", "set", "en", "find", "get", "hello", "run", "like", "ink", "each", "length", "Read", "reads", "text", "select", "readable", "len"]}}
{"id1": "7276377", "id2": "13783549", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"checksum": [" checksume", "checksam", "checksume", "checksest", "csum", " checksest", "cksume", "csume", "csam", " checksam", "cksam", "cksum", "csest", "cksest"], "url": ["browser", "http", "rect", "link", "web", "l", "ll", "html", "xml", "address", "key", "q", "dll", "rel", "el", "string", "location", "image", "base", "name", "loc", "document", "email", "char", "str", "ul", "mail", "ssl", "dl", "u", "build", "ur", "nl", "domain", "bel", "mount", "request", "https", "URL", "gl", "file", "pattern", "log", "Url", "config", "get", "host", "path", "ls", "uri"], "algorithm": ["altergo", "malgorithm", "alignment", "Algorithm", "approgorith", " alculus", " algorith", "Algorith", "palter", "alter", "Alculus", "operabet", "aliment", "Alabet", "operter", "palgorithm", "altergorithm", "opergo", "Alignment", "alteriment", "palabet", "alculus", "approgo", "opergorithm", " algo", "approgorithm", "approculus", "palgo", "alabet", "algorith", "Algo", "maliment", "Aliment", "alterignment", "Alter", "malgo", "algo", "malignment"], "messageDigest": ["messageDesignester", "messageHasests", "messageMerist", "messageDiger", "applicationDigests", "MessageDigum", "Messagedigest", "messageHasester", "messageDse", "messageDigse", "messageDigester", "messagedigse", "messageDesigner", "MessageDigest", "MessageDigse", "applicationDesignests", "messagedigest", "MessageDiger", " messageDigidate", " messageDigse", "messagedigum", "messagedigester", "messageDigidate", "messagediger", "Messagediger", "applicationDigest", "messageDebuger", "messageDebugidate", "applicationDigester", "messageDesignest", "messageChecker", " messageDiger", "messageCheckest", "applicationDesigner", "applicationDesignest", "Messagedigse", "messageDebugest", "messageMerse", "messageDigum", "applicationDiger", "messagedigests", "messageDest", " messageDigist", "messageDum", "messagedigist", "messageDer", "messageDebugse", "messageCheckse", "messageDesignests", "messageHaser", "messageMerest", "messageHasest", "messageDigests", "applicationDesignester", "Messagedigum", "messageDigist", "messageCheckum", "messagedigidate"], "bytes": ["strings", "frames", "types", "images", "bes", "words", "classes", "blocks", "services", "parts", "users", "seconds", "lines", "pieces", "pointers", "gets", "bps", "its", "vs", "ces", "eps", "files", "bits", "steps", "resources", "rows", "tes", "out", "jobs", "names", "versions", "bos", "checks", "items", "groups", "es", "gb", "ions", "notes", "outs", "ies", "values", "pages", "bs", "units", "Bytes", "gs", "terms", "vals", "ones"], "in": ["inf", "m", "o", "n", "oin", "IN", "l", "inc", "it", "socket", "al", "null", "inner", "cin", "h", "proc", "ins", "input", "re", "reader", "ind", "one", "rin", "bin", "name", "up", "In", "is", "io", "form", "client", "again", "by", "or", "pi", "isin", "co", "init", "serv", "con", "info", "mc", "ma", "check", "asin", "ai", "nin", "t", "gin", "from", "handle", "impl", "mi", "can", "en", "ain", "conf", "inn", "on", "out", "din", "i", "p", "source"], "nBytesRead": ["nBytesFound", "nBytesWritten", "nRsRead", "nFilesRead", "nItemsFound", "nFramesread", " nBytesread", "nTokensread", "nRsRun", "NBytesread", "nItemsReader", "nBytesread", "nbytesread", "NBytesRead", "nRsSupported", " nRsSupported", "nBytesReader", "nFilesWritten", "NBytesWritten", "nItemsRead", "nFramesReader", "nbytesSupported", "nItemsWritten", "nFramesFound", "nTokensRead", " nRsRead", "NRsRead", "NRsRun", " nItemsWritten", " nBytesFound", "nTokensRun", "nTokensWritten", "nBytesRun", "nFilesread", "NBytesRun", "NRsWritten", "nFilesRun", "NRsread", "nFramesRead", " nItemsFound", " nBytesReader", " nItemsReader", "nbytesWritten", "nBytesSupported", "nRsFound", "nFramesSupported", "nFramesWritten", "nbytesRead", " nItemsRead", "nRsread", " nBytesSupported", " nRsWritten", "nRsWritten", "nRsReader", " nBytesWritten", " nRsread"], "checksumValue": [" checksummModel", "checksumVal", " checksamValue", "checksumervalue", " checksummValue", "checksummVal", " checksummvalue", "checksummModel", " checksummValues", " checksamData", "checksumModel", "checksummDocument", "checksamVal", "checksummValues", "checksumData", "checksummValue", "checksUMValue", "checksamData", " checksumvalue", "checksumDocument", " checksumDocument", " checksamDocument", "checksamValue", "checksumvalue", "checksumerValues", "checksUMModel", " checksumVal", " checksumModel", "checksumerValue", "checksumedData", "checksamDocument", "checksummvalue", "checksumedVal", "checksumerModel", "checksumedDocument", "checksummData", " checksumData", " checksumValues", "checksUMValues", "checksUMvalue", "checksumedValue", "checksumValues", " checksamVal"]}}
{"id1": "14502142", "id2": "20128728", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", "downloadStream", " copyFiles", "transferStream", "copyFiles", "copyPhoto", "downloadFile", "copyStream", "downloadPhoto", " copyPhoto", "downloadFiles", "transferFiles", "transferPhoto", " copyStream"], "source": ["null", "in", "SOURCE", "site", "target", "input", "seed", "image", "template", "base", "scene", "style", "subject", "sql", "src", "scope", "sample", "sp", "init", "ource", "origin", "Source", "sf", "search", "resource", "file", "service", "s", "se", "original", "start", "config", "query", "spec", "shell", "pse", "parent"], "dest": ["d", "pl", "rest", "dev", "comp", "null", "it", "cat", "them", "cp", "dat", "test", "target", "obj", "tif", "desc", "dist", "th", "self", "dc", "loc", "table", "decl", "Dest", "nw", "nom", "cont", "trans", "img", "sys", "usr", "src", "sp", "dir", "st", "origin", "copy", "opt", "result", "master", "etc", "del", "exp", "sit", "gt", "home", "lit", "foreign", "good", "tmp", "tom", "this", "temp", "out", "txt", "orig"], "from": ["d", "entry", "pos", "link", "in", "back", "tr", "without", "inner", "reset", "el", "no", "input", "user", "window", "re", "term", "lo", "base", "up", "da", "tar", "col", "form", "client", "f", "by", "un", "From", "cont", "str", "vol", "so", "a", "init", "owner", "st", "por", "old", "con", "sent", "origin", "ce", "with", "check", "fun", "normal", "before", "rom", "bean", "se", "start", "ent", "part", "can", "query", "low", "en", "fr", "bound", "of", "r", "de", "left", "ra", "or", "ie"], "to": ["b", "null", "total", "io", "client", "top", "bo", "pi", "news", "t", "eto", "te", "will", "file", "tmp", "ne", "o", "pt", "at", "token", "os", "ta", "ts", "see", "stable", "p", "pty", "nt", "toc", "l", " too", "that", "tar", "by", "oto", "sp", "must", "etc", "tt", "can", "all", "po", "on", "tom", "message", "pretty", "out", "or", "parent", "To", "tab", "phi", "target", "no", "table", "pro", "please", "co", "so", "st", "too", "auto", "tx", "op", "net", "TO"]}}
{"id1": "17199913", "id2": "4164833", "code1": "    protected static InputStream loadResource(String resource) throws MissingResourceException {\n        Thread thread = Thread.currentThread();\n        ClassLoader cLoader = thread.getContextClassLoader();\n        URL url = cLoader.getResource(resource);\n        if (url == null) {\n            throw new MissingResourceException(\"Unable to find resource '\" + resource + \"'.\", resource, resource);\n        }\n        try {\n            InputStream is = url.openStream();\n            return is;\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Unable to load resource '\" + resource + \"' (IOException).\", resource, resource);\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"loadResource": ["loadFile", "parseStream", "openStream", "parseresource", "openFile", "getresource", "getResource", "openresource", "getStream", "loadStream", "openResource", "parseResource", "loadresource", "parseFile", "getFile"], "resource": ["print", "null", "operation", "project", "record", "function", "hash", "controller", "string", "location", "term", "state", "collection", "client", "OURCE", "resources", "file", "release", "get", "component", "reference", "source", "web", "address", "template", "base", "sequence", "prefix", "description", "attribute", "password", "common", "module", "title", "color", "element", "version", "value", "library", "id", "Resource", "role", "method", "buffer", "uri", "entry", "rule", "problem", "pointer", "node", "server", "filename", "date", "system", "issue", "re", "response", "image", "document", "core", "subject", "context", "phrase", "application", "request", "from", "service", "reason", "message", "remote", "action", "resolution", "use", "space", "create", "property", "res", "directory", "expression", "status", "name", "field", "connection", "scope", "comment", "ource", "ce", "pattern", "query", "model", "relation", "event", "path", "instance"], "thread": ["time", "Thread", "session", "user", "window", "system", "th", "process", "template", "tem", "name", "type", "cmd", "ct", "worker", "engine", "subject", "connection", "context", "task", " Thread", "t", "service", "loader", "job", "tt", "inter", "TH", "object", "event", "this", "method", "buffer", "tc", "current", "parent", "nt"], "cLoader": ["lcBuilder", "lcUrl", "dcReader", "cJar", " cUrl", " cJar", "ccReader", "lcLoader", "cLoad", "cReader", "ccJar", " cReader", "ccLoader", "lcJar", " cLoad", " cBuilder", "cUrl", "cBuilder", "lcLoad", "dcUrl", "ccLoad", "lcReader", "dcLoader", "dcBuilder"], "url": ["browser", "http", "pl", "link", "web", "l", "ll", "rl", "rel", "el", "user", "lb", "oul", "name", "loc", "char", "f", "str", "abs", "mail", "ssl", "org", "dl", "ref", "build", "ur", "nl", "bel", "mount", "URL", "file", "gl", "impl", "loader", "log", "norm", "ml", "Url", "job", "sl", "kl", "cloud", "fl", "bb", "lr", "mb", "path", "util", "ls", "uri"], "is": ["dis", "ui", "ris", "isi", "bis", "lis", "has", "isa", "instance", "cms", "im", "ais", "os", "si", "its", "IS", "isf", "Is", "mis", "isin", "iso", "ms", "ios", "nis", "ri", "ai", "iss", "mi", "ist", "as", "ism", "get", "isl", "ims", "isc", "i", "imp"]}}
{"id1": "20623709", "id2": "9718328", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "label": 0, "substitutes": {"split": ["scale", "parse", "disk", "batch", "use", "process", "transfer", "seek", "open", "align", "scan", "count", "unit", "write", "append", "upload", "sync", "copy", "format", "map", "read", "part", "Split", "lock", "slice", "share", "join"], "targetDirectory": ["TargetDirect", "localdirectory", "TargetDirectory", "baseFile", "targetDir", " targetFolder", "localFile", "localDirectory", "baseDir", "basedirectory", "testDirectory", " targetDir", "TargetFolder", "baseFolder", "targetDirect", " targetMemory", "targetLocation", " targetFile", "targetFile", "Targetdirectory", " targetdirectory", "testLocation", "targetdirectory", "targetMemory", "baseDirectory", "targetFolder", "TargetLocation", "testDir", "TargetDir", "localDir", "testDirect", " targetDirect", "baseDirect", "baseMemory", " targetLocation", "TargetMemory"], "prefix": ["zero", "command", "pkg", "key", "filename", "root", "uri", "index", " suffix", "directory", "padding", "username", "status", "base", "template", "name", "fix", "type", "password", "division", "localhost", "alias", "PRE", "fixes", "pi", "FIX", "title", "version", "size", "format", "pres", "pattern", "pre", "ix", "Pref", "fixed", "this", "tag", "path", "p"], "maxUnitBases": ["maxUnitBages", "maxUnitbounds", "maxUnitReplages", "maxUnitChicas", "maxUnitChounds", "maxUnityLases", "maxUnitBades", "maxUnitChias", "maxUnitChases", "maxUnitReplicas", "maxUnitChades", "maxUnityLounds", "maxUnityBicas", "maxUnityBages", "maxUnityBias", "maxUnitReplases", "maxUnitAliounds", "maxUnitReplounds", "maxUnitbades", "maxUnityAliases", "maxUnitLages", "maxUnityAliounds", "maxUnitLases", "maxUnitBounds", "maxUnityLages", "maxUnityBases", "maxUnityBounds", "maxUnitLicas", "maxUnityAliades", "maxUnitAliades", "maxUnityLicas", "maxUnitBicas", "maxUnitbias", "maxUnitbases", "maxUnitAliases", "maxUnityBades", "maxUnitChages", "maxUnityAliias", "maxUnitBias", "maxUnitLounds", "maxUnitAliias"], "maxUnitEntries": ["maxunitEntries", "maxUnitentrs", "maxunitEntires", "maxUnitErrys", "maxUnitentires", "maxUnityentries", "maxUnityEntires", "maxUnitEntrys", "maxUnitErrs", "maxUnitentries", "maxUnitEntryires", "maxUnitIntegires", "maxUnitEntriers", "maxUnitErires", "maxUnitEntryries", "maxUnitEntryrys", "maxUnitEntryriers", "maxUnitIntegrys", "maxUnitEntrs", "maxUnityEntrs", "maxunitEntrys", "maxUnitIntegries", "maxUnitentrys", "maxUnityEntrys", "maxunitEntrs", "maxUnitIntegriers", "maxUnitErries", "maxUnityentrys", "maxUnityentrs", "maxUnityentires", "maxUnityEntries", "maxUnitEntires"], "fis": ["fic", "Fic", "fiss", "Fii", "vi", "vis", "fi", " fiss", " fic", "viss", "ifis", "Fiss", "ific", "Fci", "Fis", "ifii", "fii", "ifci", " fi", " fii", "vic", "Fi"], "fci": [" fai", "Fini", "fic", "Fic", "Fco", "fico", "fini", "cfic", "cfis", "tcu", " fcu", " fic", "tci", "cfco", " fico", "mcu", "mii", "Fci", "Fis", "tco", " fini", "Fai", "fcu", "tii", "cfini", "fii", " fii", "cfci", "cfai", "mco", "fai", "cfico", "Fico", "mci"], "fos": ["wbos", "yos", "yaos", "flOS", " fbos", "flaos", "fOS", "Foss", " faos", "ybos", " fios", "floss", "fios", "Fos", "wos", " foss", "foss", "FOS", "fbos", "flos", " fOS", "waos", "Faos", "yios", "wios", "faos"], "fco": ["fcon", "ccon", "cdo", "Fcos", "Fco", "pco", "cso", "tcos", "toco", "Fcon", "fso", "Fdo", " fcon", "tdo", "Foco", "fcos", " foco", "fdo", "foco", "Fci", "tco", " fso", "pci", " fdo", "Fso", " fcos", "pcos", "cco", "pso"], "buffer": ["entry", "batch", "cache", "print", "Buffer", "command", "record", "data", "black", "function", "address", "filter", "reset", "memory", "flush", "index", "window", "padding", "database", "holder", "limit", "timeout", "template", "button", "document", "table", "sequence", "char", "callback", "queue", "buf", "row", "phrase", "note", "sample", "buff", "pause", "comment", "append", "stack", "iter", "block", "position", "complete", "library", "result", "read", "match", "binary", "order", "event", "message", "temp", "channel", "length", "bridge", "source"], "currentBasesCount": ["currentbaseCode", "currentBaseCode", "currentbasesCode", "currentBasesLength", "currentbaseCount", "currentBadesCode", "currentbasesLength", "currentBadesCount", "currentBasesCode", "currentBasedCode", "currentBasedCount", "currentbasesCount", "currentBaseCount", "currentBaseLength", "currentBasedLength", "currentBadesLength", "currentbaseLength"], "currentEntriesCount": ["currentEntriesFlag", "currentEntiesCount", "currentEntrsCode", "currentEntiesCode", "currentEntrysFlag", "currentEntrysCount", "currentEntrysCode", "currentEntiesFlag", "currentEntriesCode", "currentEntrsFlag", "currentEntrsCount"], "targetCount": ["targetAmount", "targetNum", "TargetInfo", " targetAmount", "argetCount", "argetAmount", "TargetAmount", " targetInfo", "TargetNum", "argetNum", "argetInfo", "TargetCount", "targetInfo", " targetNum"], "fastaChannel": ["fastoStream", " fastaQueue", " fastoStream", " fastoChan", "fastoChannel", "fastoProvider", "fastaConnection", "fastoChan", "fastaStream", " fastaStream", "fastaiStream", "fastaiChannel", "fastoConnection", "fastpaConnection", " fastaProvider", "fastityChannel", "fastaButton", " fastoChannel", "fastityStream", "fastpaButton", "fastaiQueue", "fastaProvider", " fastaButton", "fastityQueue", "fastaChan", " fastaConnection", "fastpaChannel", "fastoQueue", "fastpaProvider", "fastaQueue", "fastityChan", "fastaiChan", "fastoButton", " fastoQueue", " fastaChan"], "totalSeqCount": ["totalSeqsCount", "totalSegSize", "totalSeqSize", "totalSegCount", "totalSeQCount", "totalSeQCode", "totalSeQSize", "totalSeqCode", "totalSegCode", "totalSeqsSize", "totalSegCounter", "totalSeqCounter", "totalSeQCounter", "totalSeqsCounter", "totalSeqsCode"], "totalResiduesCount": ["totalResidueCount", "totalResIdueCode", "totalResidueFlag", "totalResiduationsFlag", "totalResIduesCode", "totalResidusCount", "totalResIdueCount", "totalResiduesFlag", "totalResiduationsCode", "totalResIduesFlag", "totalResiduesCode", "totalResidusFlag", "totalResIdueFlag", "totalResiduationsCount", "totalResidusCode", "totalResidueCode", "totalResIduesCount"], "prevTime": [" prevT", "prevT", " prevThread", "parTime", "prevThread", " previousTime", "parThread", " previousT", " previousThread", "parT"], "fastaFileSize": ["fastAFileHeight", "fastAFileSize", "fastafileSIZE", "fastoFileSize", "fastaChainLength", "fastoFileOwner", "fastaTableLength", "fastaFilesSize", "fastoTableSIZE", "fastoTableSize", "fastaReaderSize", "fastoFileLength", "fastATableName", "fastaFileName", "fastaFilesHeight", "fastafileLength", "fastaFileLength", "fastaFileSIZE", "fastATableSize", "fastATableHeight", "fastaTableSize", "fastaTableHeight", "fastaTableOwner", "fastaChainSize", "fastaFilesName", "fastaFileHeight", "fastATableLength", "fastafileOwner", "fastoTableLength", "fastaReaderLength", "fastAFileLength", "fastaReaderHeight", "fastaTableName", "fastaFileOwner", "fastaChainSIZE", "fastoFileSIZE", "fastafileSize", "fastaTableSIZE", "fastaReaderName", "fastaFilesLength", "fastAFileName", "fastaChainOwner", "fastoTableOwner"], "fastaFileReadOffset": ["fastaChainCurrentLocation", "fastaFileWriteOffset", "fastaFileViewPos", "fastaFileLoadLength", "fastaFileReadPosition", "fastaFileReadLength", "fastaFileLoadOrder", "fastaFileInputAmount", "fastaFileInputPosition", "fastaPageReadOffset", "fastaChainCurrentoffset", "fastaFileReaderLocation", "fastaFileInputLocation", "fastaFileInputOrder", "fastaFilereadOrder", "fastaFileWriteAmount", "fastaChainReadPosition", "fastaFileViewOffset", "fastaFileReadoffset", "fastaFileInputoffset", "fastaChainReadoffset", "fastaFileReaderOffset", "fastaFilereadOffset", "fastaPageLoadOrder", "fastaFileInputOffset", "fastaFilesLoadLength", "fastaFileLoadAmount", "fastaPageLoadPos", "fastaFilereadPos", "fastaFilereadAmount", "fastaFileCurrentoffset", "fastaFileReadOrder", "fastaFileReaderoffset", "fastaPageReadOrder", "fastaFileReaderPosition", "fastaChainReadLocation", "fastaFileLoadOffset", "fastaPageReadAmount", "fastaFileCurrentLocation", "fastaFileCurrentPosition", "fastaFileViewAmount", "fastaFileInputLength", "fastaPageReadPos", "fastaFileViewOrder", "fastaFileWriteOrder", "fastaFilesLoadOffset", "fastaFileLoadPos", "fastaFilesReadOrder", "fastaFileCurrentOffset", "fastaPageLoadAmount", "fastaFileReadPos", "fastaFileReadLocation", "fastaFilesReadAmount", "fastaFilesLoadAmount", "fastaFilesLoadOrder", "fastaFileReadAmount", "fastaChainCurrentOffset", "fastaFileWriteLength", "fastaFilesReadOffset", "fastaChainReadOffset", "fastaChainCurrentPosition", "fastaFilesReadLength", "fastaPageLoadOffset"], "partitionStartOffset": ["partitonStartingPosition", "partitionStartingPoint", "partitionStartingOff", "partitionDataPosition", "partitonStartOffset", "partitonStartingOff", "partitionStartingOffset", "partitionStartPosition", "partitionStartingPosition", "partitionDataOffset", "partitonStartingPoint", "partitionEndPosition", "partitionEndPoint", "partitionStartPoint", "partitionDataOff", "partitonStartPoint", "partitonStartOff", "partitionEndOff", "partitionDataPoint", "partitonStartPosition", "partitonStartingOffset", "partitionStartOff"], "bufferSize": ["BufferName", "buffLength", "buffName", "bufferSIZE", "bufSize", "bufferCode", "sequenceSize", "BufferSIZE", "BufferLength", "buffSize", "BufferSize", " bufferCode", "bufSIZE", "bufLength", "tableSize", "bufferName", "sequenceCode", "bufCode", "tableName", "tableSIZE", " bufferLength", "tableLength", "sequenceSIZE", " bufferSIZE", "buffSIZE", "bufferLength", "sequenceLength"], "fastaBuffer": ["fastuMemory", "fastaDB", "FastmaBuff", "fastmaCache", "fastmaBuilder", "fastoCounter", "fastaBuilder", " fastoBuffer", "fastalQueue", "fastsaChannel", "wildaBuff", "fastcaBuffer", "fastanCache", "fastanRequest", "fastoBuffer", "wildanBuff", "fastasCounter", "fasteBuffer", " fastaBuilder", "fastsaBuffer", "fastcaRequest", "fastmaBuff", " fastaCache", "FastmaStore", "fastsaBuff", "fastasBuff", "fastasCache", "fastoRequest", "fastoBuff", "fastuDB", "fastasBuilder", "fastalCounter", "FastaBuffer", "FastmaBuffer", "fasteMemory", "fastanBuffer", "wildaCache", "fastuBuff", "wildaBuffer", " fastoQueue", "fastcaCache", "fastmaQueue", "fastaBuff", "fastanBuff", " fastoBuff", "FastaBuff", "fastasBuffer", "FastaRequest", "fastcaBuff", "fastaCache", " fastaBuff", "fastaRequest", "FastaStore", "fastasRequest", "fastalBuffer", "wildanBuffer", "wildanRequest", "fastmaBuffer", "FastmaRequest", " fastaDB", " fastaCounter", "fastuBuffer", "wildaRequest", "fastmaStore", " fastoCounter", " fastaQueue", "fasteBuff", "fastsaQueue", "fasteDB", "fastaStore", "fastmaRequest", "fastoStore", " fastaMemory", "fastasStore", "fastasQueue", "fastaCounter", "fastoQueue", "fastmaChannel", "fastaQueue", "fastalBuff", "wildanCache", "fastaMemory"], "fastaReadState": ["fastaReaderState", "fastaCurrentType", "fastoReaderSTATE", "fastoReaderStatus", "fastoReadState", "fastoReaderType", "fastaLoadStatus", "fastoReadStatus", "fastaLoadType", "fastaReaderStatus", "fastaReaderType", "fastoReadSTATE", "fastaCurrentState", "fastaReaderSTATE", "fastoReaderState", "fastaLoadSTATE", "fastaCurrentStatus", "fastaReadSTATE", "fastaReadType", "fastaCurrentSTATE", "fastaReadStatus", "fastaLoadState", "fastoReadType"], "nBytes": ["nsWords", "nsParts", " nItems", " nbytes", " nBlocks", " nNs", "numBlocks", "numNs", "NParts", "noBytes", " nWords", "noBlocks", "nItems", "nBlocks", "noNs", "nrBytes", "nbytes", "nobytes", "nrbytes", "Nbytes", "nParts", "nNs", "NKeys", "nsbytes", "nsBytes", "nKeys", "NItems", "numBytes", "nrKeys", "NBytes", "NWords", "numbytes", "nrItems", "nWords", " nParts", " nKeys"]}}
{"id1": "17786231", "id2": "530882", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"downloadFile": ["loadFile", "transferFile", "getContent", "loadfile", "transferContent", "getResource", "downloadResource", "loadContent", "downloadfile", "downloadContent", "transferResource", "transferfile", "loadResource", "getFile", "getfile"], "downloadUrl": ["reportUrl", "installLink", "downloadLink", "installUrl", "DownloadURL", " downloadUr", "DownloadWar", " downloadURL", "linkUr", "reportWar", "transferWar", "reportURL", "linkURL", "transferUrl", " downloadLink", "linkUrl", "installUr", "installURL", "reportUr", "transferURL", "downloadWar", "downloadUr", "DownloadUr", "DownloadUrl", "linkLink", "downloadURL", "transferUr"], "destinationFile": ["coordacementName", " destinationDir", "destacementFolder", "destiningSourceFile", "destificationDir", "destarationFile", " destinationPath", "coordinationFolder", "destacementName", " destificationSourceFile", "destarationFolder", "coordinationfile", "destinatedFolder", "destacementFile", " destificationFile", "destinationfile", "destificationFile", "destinatedFile", "destarationName", "destarationSourceFile", "destinationFolder", "coordinationName", "destinationSourceFile", "coordacementFolder", "destinationPath", " destificationDir", "destificationPath", " destinationSourceFile", "destiningDir", "coordinationFile", "destinationDir", "destarationfile", "destinatedfile", "destinationName", "destificationSourceFile", "destarationDir", "destacementfile", "destinatedName", "destarationPath", "coordacementfile", "coordacementFile", "destiningPath", " destificationPath", "destiningFile"], "client": ["http", "cache", "ci", "conn", "phone", "network", "key", "server", "city", "call", "system", "Client", "template", "io", "wrapper", "collection", "google", "channel", "api", "connection", "context", "co", "contact", "force", "request", "cli", "https", "url", "resource", "service", "query", "cl", "console", "cm", "pool", "net", "remote", "tc", "uri"], "httpGet": [" httpGET", "ttpPut", "ttpget", "httpGET", " httpPut", "utilPut", "ttpGet", "hPut", "HttpQuery", "httpQuery", "utilQuery", "httpPut", "utilGet", "Httpget", "HttpPut", "hGet", "utilGET", "HttpGet", " httpQuery", "hget", "httpget", "HttpGET"], "outputFile": ["outputPoint", "OutputStream", "tempFile", "outputPlace", "outPoint", "tempStream", "newPlace", "betaFILE", " outputFILE", "newFile", "seeFile", "outPlace", "regionStream", "outputFILE", "OutputFile", "newPoint", "regionFile", "betaFile", "regionFILE", "tempFILE", "outStream", "OutputPlace", "newStream", "outFile", "seeFILE", "OutputPoint"], "outputStream": ["printSteam", "inputstream", "printStream", "OutputStream", "OutputSteam", "responseStream", "outputStreamer", "putStyle", "OutputStyle", " outputForm", "inputStreamer", "putStreamer", "outputSteam", "outputStyle", "outputView", " outputView", "inputFile", " outputSteam", "putStream", "responseStreamer", " outputstream", " outputStreamer", "coinStyle", "responseSteam", "outputstream", "outputForm", "inputStyle", "coinSteam", "putSteam", "inputForm", "Outputstream", " outputStyle", "inputView", "responseStyle", "printForm", "OutputView", "inputSteam", "printFile", "coinStream", "coinStreamer"], "response": ["http", "entry", "data", "resp", "body", "server", "post", "onse", "image", "status", "yes", "answer", "document", "still", "description", "details", "attribute", "json", "connection", "application", "reply", "example", "request", "version", "block", "resource", "service", "result", "Response", "content", "initial", "output", "message", "given", "page", "remote"], "entity": ["entry", "security", "cache", "detail", "data", "xml", "body", "obj", "pe", "el", "unique", "total", "Entity", "activity", "status", "image", "group", "name", "document", "person", "error", "details", "type", "attribute", "secure", "email", "properties", "ity", "json", "associated", "enc", "valid", "iso", "note", "e", "comment", "info", "peer", "ilo", "metadata", "resource", "local", "profile", "existent", "account", "result", "existing", "ent", "member", "encrypted", "content", "quote", "object", "component", "event", "message", "translation", "buffer", "instance", "line"], "inputStream": ["InputSteam", "imageSteam", "evalStreamer", "inputstream", "readSteam", "upForm", "readStream", " inputStreamer", "sourceView", "thisStream", "sourcestream", "thisSteam", "inputStreamer", "imageStream", "InputStream", "outputSteam", "outputStyle", "outputView", "InputForm", " inputForm", "outputstream", "upStream", "outputForm", "activeStreamer", "evalStream", "thisForm", "inputStyle", " inputstream", " inputSteam", "Inputstream", "activeSteam", "upstream", "InputStyle", "inputForm", "activeView", "readstream", "upSteam", "activeStream", "inputView", "evalView", "readForm", "evalSteam", "imagestream", "thisStyle", "imageView", "sourceSteam", "inputSteam", "sourceStream", " inputView"], "callback": ["browser", "continue", "back", "consumer", "background", "policy", "function", "filter", "call", "processor", "parser", "window", "lambda", "token", "facebook", "builder", "wrapper", "actor", "handler", "alias", "cell", "closure", "CB", "hook", "func", "cb", "finder", "manager", "sound", "Callback", "binding", "gc", "loader", "library", "pattern", "job", "creator", "cc", "update", "backs", "message", "display", "soon"], "copiedLength": ["copIEDLength", "copedLength", "copedDuration", "copIEDNumber", "copiedNumber", "copedSize", "copyLen", "copifiedLen", "copifiedLength", "copifiedDuration", "copifiedNumber", "copyLength", "copedNumber", "copIEDDuration", "CopedSize", "CopedNumber", "copySize", "CopiedDuration", "CopedDuration", "copiedLen", "CopedLength", "CopedLen", "copiedDuration", "CopiedLength", "copifiedSize", "copyDuration", "CopiedSize", "CopiedLen", "CopiedNumber", "copiedSize", "copedLen"], "percentage": ["Percentage", "Percentages", "CENTage", "percentale", " percentages", "capale", "Percenture", " percentale", "capages", "capage", "CENTages", "capaging", "Percentale", "CENTure", "percentages", "percenture", "Percentaging", " percenture", "percentaging", " percentaging"]}}
{"id1": "7396682", "id2": "16572931", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"copy": ["link", "cat", "cp", "cop", "create", "fit", "download", "Copy", "pixel", "clip", "transfer", "split", "load", "replace", "php", "core", "write", "cross", "upload", "move", "clone", "sync", "py", "proxy", "repeat", "crop", "gc", "map", "read", "opy", "zip", "delete", "Cop", "slice", "share", "archive"], "srcFS": ["rcFS", "sysFS", "srcOS", "srcFs", "rcFs", "sourceOS", "sysOS", "srMS", "sourceFs", " srcCS", "sysFs", "rcSF", "rcOS", "sourceVS", "sourceFS", "srcMS", "srcCS", "rcMS", "sourceSF", " srcMS", "sourceCS", "sourcefs", " srcFs", "sysVS", "srfs", "srcSF", "rcCS", "srFS", "srFs", " srcfs", "srcfs", "rcfs", " srcVS", "rcVS", "srcVS", " srcOS", " srcSF"], "src": ["syn", "http", "comp", "sci", "ctr", "pkg", "node", "SOURCE", "sec", "proc", "filename", "rel", "obj", "desc", "input", "via", "ser", "target", "obs", "th", "lb", "RC", "req", "rs", "selected", "loc", "rx", "iv", "secure", "str", "cont", "img", "sys", "usr", "subject", "rc", "init", "dir", "st", "pri", "sync", "sn", "Source", "cur", "inst", "https", "check", "url", "resource", "from", "boot", "start", "nil", "sit", "sc", "spec", "sub", "supp", "sb", "tmp", "addr", "path", "sin", "dest", "sr", "txt", "sq", "uri", "source"], "dst": [" dest", "lgt", "dsnd", " dlt", "Ddest", "degt", "dsgt", "ddst", "dnd", "DST", "dddest", "dsST", "dsst", "Dlt", "dslt", "dhst", "ddnd", "desst", "desdest", "dST", "Dest", "lest", "dedest", "ldest", "dDest", " ddest", "dhlt", "deest", "ddest", "deslt", "dgt", "Dst", "lst", " dST", "dsdest", "desnd", "dlt", "ddlt", "dsest", "dhdest", " dDest", "dest", "dhDest", "DDest"], "deleteSource": ["removeDest", "updateSOURCE", "destroySources", "delSOURCE", "deleteTarget", "updateSourceFile", "deleteSite", "deleteSourceFile", "removeSource", "updateSource", "leteParent", "deleteDest", "DeleteSOURCE", "closeSite", "leteSources", "closeSource", "leteTarget", "destroyResult", "leteSource", "delDest", "DeleteSite", " deleteSources", "delParent", "DeleteSource", "deleteSources", "delSource", "deleteSOURCE", "deleteResult", " deleteResult", "removeParent", " deleteTarget", "leteSOURCE", "closeSourceFile", "updateSite", "removeSOURCE", "destroyTarget", "deleteParent", "closeSOURCE", "leteResult", "destroySource", "DeleteSourceFile", "leteDest"], "conf": ["m", "css", "acc", "ca", "cache", "plan", "conn", "report", "prop", "q", "hash", "ctx", "mm", "cms", "req", "param", "cf", "comm", "f", "scan", "Conf", "ref", "ch", "co", "comment", "cb", "con", "info", "ban", "ln", "irm", "check", "com", "map", "log", "fs", "config", "job", "def", "params", "cfg", "cm", "lib", "pool", "cc", "cn", "conv"], "contents": ["contends", "Contterms", "CONTodes", "CONTENT", "contodes", "CONTents", "CONTresses", "CONTants", " content", "CONTent", "CONTENTS", "Contodes", " contterms", "Content", "contENTS", "Contents", " contants", "contresses", "constents", "constends", " Content", " contENTS", "contaves", " ContENTS", " contresses", "constENTS", " Contresses", " contaves", "ContENT", "content", "contants", "CONTaves", " Contents", "contterms", "CONTends", " contends", "contENT", "Contants", "constaves", " contodes", "CONTterms", " contENT"], "i": ["m", "multi", "ip", "n", "ci", "ui", "ij", "o", "it", "ji", "ei", "gi", "span", "key", "ami", "I", "q", "chain", "phi", "us", "inner", "index", "ind", "im", "ori", "\u0438", "y", "oi", "ki", "si", "iq", "li", "is", "ii", "ski", "ini", "xi", "client", "docker", "ie", "bi", "json", "u", "pi", "j", "ms", "me", "init", "iter", "cli", "ai", "sim", "mi", "ti", "ix", "id", "ims", "di", "my", "ic", "x", "hi", "qi"], "in": ["inf", "raw", "IN", "inc", "xml", "inner", "cin", "body", "ins", "doc", "input", "re", "reader", "ind", "bin", "In", "ini", "is", "char", "by", "ze", "sql", "isin", "sample", "con", "and", "mc", "check", "add", "from", "read", "en", "inn", "r", "out", "din", " din", "source"]}}
{"id1": "1769771", "id2": "9805906", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "copyLine", " copyFiles", "copyFiles", " CopyLine", " copyStream", " CopyFiles", "copyStream", "CopyStream", " CopyStream", "CopyLine", " copyLine", "CopyFile", " CopyFile"], "in": ["inf", "b", "IN", "l", "inc", "inner", "cin", "ins", "el", "input", "mm", "ind", "rin", "bin", "up", "In", "ini", "io", "is", "isin", "init", "old", "gin", "from", " input", "en", "inn", "r", "on", "i", "ic", "din", "source"], "out": ["o", "b", "n", "v", "to", "l", "it", "ex", "err", "res", "OUT", "at", "msg", "c", "os", "up", "ou", "Out", "io", "serv", "ot", "w", "t", "file", "s", "help", "log", "gt", "update", "op", "output", "outs", "po", "net", "p", "nt"], "inChannel": ["ainClient", "sinButton", "dinChan", " inCategory", "InChan", " inConnection", " inchannel", " inCommand", "dinConnection", "InChannel", "insideCategory", "inchannel", " inScope", "intChan", "inCase", "sinChannel", "insideChannel", "ainCategory", "intCommand", "inConnection", "ainScope", "dinchannel", "dinChannel", "inChan", "inCommand", "outChan", "innCase", "inCategory", "inScope", " inClient", "innButton", "Inchannel", "outConnection", "outchannel", "inButton", "sinCommand", " inChan", "cinChannel", "sinClient", "ainChannel", "sinRoom", "InCommand", "sinCase", " inRoom", "insideClient", "inRoom", "innClient", "inClient", "insideScope", " inButton", "innChannel", "cinRoom", "cinCommand", "intchannel", "intChannel", " inCase"], "outChannel": ["aosChannel", " outCh", "blockGate", "blockChannel", "inSection", " outManager", "parentChannel", "inchannel", "aosMember", "outGate", "neChan", "outputchannel", "blockChan", "inChan", "inCh", "outCh", "outChan", "inMember", "neChannel", "outchannel", "cnChan", " outchannel", "outputChannel", "outSection", "parentGate", " outChan", "aosChan", "blockMany", "neSection", "aosSection", "parentChan", "parentMany", "outManager", " outMany", "outputChan", "outputCh", "cnChannel", "cnManager", "outputManager", "neMember", "outMember", " outGate", "outMany"]}}
{"id1": "13362846", "id2": "12744653", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"setContenu": ["setcontensenU", "setContennue", "setContenux", "setCont\u00ednue", "setContenue", "setContennu", "setContensenue", "setCont\u00ednU", "setContennU", "setcontenu", "setContennux", "setcontensenux", "setContensenux", "setCont\u00ednux", "setContenU", "setcontensenue", "setcontensenu", "setcontenue", "setcontenux", "setCont\u00ednu", "setContensenu", "setContensenU", "setcontenU"], "contenuFichier": ["contenuFsichier", "contenuFicheaire", "contenuFichaire", "contenuVchiere", "contenuFuffier", "contenuFachiere", "contenuVechiest", "contenuFiverier", "contenuFignier", "contenuMicher", "contenuMicheier", "contenuFihier", "contenuFithiere", "contenuFamilyichie", "contenuFrenchaire", "contenuFamilyichorie", "contenuFechieri", "contenuFChiere", "contenuFicheie", "contenuFechier", "contenuFachorie", "contenuFolfire", "contenuFolfer", "contenuVichier", "contenuFicher", "contenuFochie", "contenuFicheire", "contenuMichier", "contenuFihyr", "contenuFicheieri", "contenuFicheiere", "contenuFichieri", "contenuFsechier", "contenuFChier", "contenuFichyr", "contenuFichorie", "contenuVechiere", "contenuFsrenchieri", "contenuFichiest", "contenuFrenchier", "contenuFamilyachiere", "contenuFsicher", "contenuFsrenchire", "contenuFamilyachier", "contenuFithyr", "contenuFileichie", "contenuFiverieri", "contenuVechyr", "contenuFamilyichiere", "contenuFrenchieri", "contenuFichtie", "contenuFchiere", "contenuFuffire", "contenuFihiere", "contenuFsechire", "contenuFichIER", "contenuFithorie", "contenuFicheer", "contenuFihiest", "contenuFamilyachorie", "contenuVchie", "contenuFochiere", "contenuFiveraire", "contenuVchier", "contenuFithie", "contenuFchIER", "contenuFichire", "contenuFuffieri", "contenuFigniere", "contenuFachier", "contenuFochIER", "contenuFechire", "contenuMichaire", "contenuFileichiere", "contenuFichiere", "contenuFileichiers", "contenuFithiest", "contenuFileochiers", "contenuFsrenchaire", "contenuVechier", "contenuFachie", "contenuFichtIER", "contenuFignaire", "contenuFigner", "contenuFichie", "contenuFsichieri", "contenuVichyr", "contenuFchie", "contenuMicheaire", "contenuFamilyachie", "contenuFechiest", "contenuVchIER", "contenuFicheorie", "contenuFicheier", "contenuFchier", "contenuFsecher", "contenuFithier", "contenuFileochier", "contenuFichtier", "contenuFachiers", "contenuFechyr", "contenuVichIER", "contenuFsichire", "contenuVichiest", "contenuMichiere", "contenuFecher", "contenuVichie", "contenuFileichier", "contenuFsichaire", "contenuMicheer", "contenuFolfieri", "contenuMicheiere", "contenuFochier", "contenuFicheiers", "contenuFileochiere", "contenuFCher", "contenuVichiere", "contenuFiverire", "contenuFuffer", "contenuFrenchire", "contenuFolfier", "contenuFechiere", "contenuFichiers", "contenuFamilyichier", "contenuFsrenchier", "contenuFochiers", "contenuFileochie", "contenuFichtiere", "contenuFsechieri", "contenuFChaire"], "fichierElectronique": ["fichierTransferradorique", "fichierTransferradorius", "fichierTransferradorie", "fichierElectoniques", "fichierElectrontaire", "fichierElectronius", "fichierAdministroniques", "fichierelectrenic", "fichierCentronicy", "fichierCentronius", "fichierElectRONique", "fichierElectrenaire", "fichierElectrenic", "fichierElectronic", "fichierElectronipolar", "fichierElectroneique", "fichierElectchroniques", "fichierAdministroneiq", "fichierElectRONius", "fichierElectroneius", "fichierElectroneic", "fichierElectronsicity", "fichierElectronie", "fichierElectrontique", "fichierelectroniques", "fichierElectonique", "fichierElectRONaire", "fichierElectromie", "fichierCentRONius", "fichierSelectroneique", "fichierSelectroneiques", "fichierelectronique", "fichierElectonier", "fichierElectromique", "fichierElectronsie", "fichierElectradorique", "fichierElectchronicity", "fichierAdministroneiques", "fichierElectroneipolar", "fichierElectrenique", "fichierElectronsic", "fichierElectronicity", "fichierElectriciques", "fichierElectricique", "fichierElectchronaire", "fichierSelectronoch", "fichierTransferronie", "fichierElectrenier", "fichierAdministroneie", "fichierElectroneiques", "fichierElectromaire", "fichierCentRONique", "fichierElectroneoch", "fichierCentronique", "fichierElectroniq", "fichierElectrenius", "fichierAdministronique", "fichierElectronsoch", "fichierElectradorius", "fichierElectronoch", "fichierElectroneie", "fichierElectronsier", "fichierelectrenier", "fichierElectromipolar", "fichierElectricie", "fichierCentRONicy", "fichierElectroneaire", "fichierTransferradoric", "fichierSelectronique", "fichierElectromic", "fichierElectrontipolar", "fichierElectradoric", "fichierElectromius", "fichierElectronicy", "fichierSelectroniques", "fichierAdministronie", "fichierAdministroniq", "fichierElectroneiq", "fichierCentronaire", "fichierSelectronicity", "fichierElectronticity", "fichierElectroneicity", "fichierElectradorie", "fichierAdministroneique", "fichierElectronaire", "fichierElectronsiques", "fichierTransferronius", "fichierElectchronique", "fichierTransferronique", "fichierElectriciq", "fichierElectronier", "fichierelectrenique", "fichierelectronic", "fichierTransferronic", "fichierElectchronicy", "fichierElectchronius", "fichierelectronier", "fichierSelectroneicity", "fichierElectRONicy", "fichierElectchronoch", "fichierElectromicity", "fichierSelectroneoch", "fichierElectronsiq", "fichierElectronsique", "fichierElectrenicy", "fichierElectreniques", "fichierCentRONaire", "fichierElectonic", "fichierElectroniques", "fichierelectreniques"], "utilisateurCourant": ["utilisateursGoverniant", "utilisateursGovernants", "utilisateurGovernante", "utilisateurParticipants", "utilisateurParticipante", "utilisateurParticipant", "utilisateurGovernant", "utilisateursCourante", "utilisateurRepresentiant", "utilisateursGovernante", "utilisateurCourante", "utilisateurRepresentante", "utilisateurCouriant", "utilisateursGovernant", "utilisateursCourant", "utilisateurRepresentant", "utilisateurGoverniant", "utilisateurRepresentants", "utilisateurGovernants", "utilisateursCouriant", "utilisateursCourants", "utilisateurParticipiant", "utilisateurCourants"], "support": ["pport", "access", "null", "evidence", "use", " Support", "SUP", "know", "install", "system", "accept", "document", "language", "collection", "replace", "feature", "media", "please", "context", "cap", "force", "prototype", "trust", "supported", "port", "Support", "format", "allow", "service", "help", "library", "profile", "proof", "cover", "storage", "success", "supp", "see", "control", "history", "share"], "ficheDocument": ["foyerDoc", "FayeDocument", "fiqueDatabase", "hacheTransaction", "flicheMatrix", "fliciDatabase", "fliciDocument", "hacheJournal", "flicheDocument", "bicheDatabase", "bicheTree", "bicheDocument", "facheTree", "frenchDescription", "ficheDatabase", "hicheTransaction", "ficiMatrix", "bacheDocument", "fiqueDocument", "bacheDoc", "fitimeDescription", "fcheDocument", "facheDoc", "ficheJournal", "fruitJournal", "fayeDocuments", "fayeDocument", "frenchDatabase", "ficheTree", "fitimeDatabase", "foyerTree", "fruitDocument", "hachedocument", "frenchDocument", " frenchDocument", "bacheDatabase", "FicheDatabase", "FayeDoc", "FayeDocuments", "fcheTree", "bacheTree", " ficheDescription", "fiqueDescription", "fifaDocuments", "fcheDatabase", "facheJournal", "bicheDoc", "fliciTransaction", "ficiJournal", "frenchDoc", "FicheDocument", "hichedocument", "foyerDocument", "fichedocument", "fitimeMatrix", "fitimeTransaction", "ficheDocuments", "frenchDocuments", "ficheDoc", "fayeDatabase", "ficheDescription", "ficiDocument", "fifaDatabase", "hicheDocument", "fitimeDocument", "flicheTransaction", "fayeDoc", "fachedocument", "FayeDatabase", "ficidocument", "flicheDatabase", "fruitTransaction", "ficiDatabase", "ficiTransaction", "fruitdocument", "foyerDatabase", "frenchTransaction", " frenchDescription", "FicheDoc", "fliciMatrix", "FicheDocuments", "ficheTransaction", "facheDocument", "facheTransaction", "hicheJournal", "fifaDoc", "frenchMatrix", "fcheDoc", "ficheMatrix", " ficheDatabase", "hacheDocument", "facheDatabase", " frenchDatabase", "fifaDocument"], "nomFichier": ["nomFichanger", "nomFiverery", "nomFchiner", "nomFiliciller", "nomNichire", "nomFachire", "nomUFachire", "nomFachomer", "nomFericIER", "nomUFachier", "nomUFichery", "nomFchire", "nomFihire", "nomFicjer", "nomUFichIER", "nomFichoIER", "nomPFoilER", "nomPFoilier", "nomFichiere", "nomPacherer", "nomFichomer", "nomUFichier", "nomFicheire", "nomFolfie", "nomFichiner", "nomPFoililler", "nomPFichjer", "nomFachie", "nomFericanger", "nomFichER", "nomFolfire", "nomNolfie", "nomFichjer", "nomFicomer", "nomFilicER", "nomFicheiner", "nomFachIER", "nomFilicier", "nomPFichER", "nomFihIER", "nomFericancer", "nomFoiljer", "nomNichie", "nomFchier", "nomFichery", "nomFoililler", "nomFolfier", "nomFchiere", "nomFicheiere", "nomFicire", "nomPachire", "nomFihier", "nomFichiller", "nomPachomer", "nomFolfiere", "nomFichire", "nomFachiner", "nomFicER", "nomFichancer", "nomFicher", "nomFichoanger", "nomFihery", "nomFacherer", "nomFicheier", "nomFoilier", "nomFicier", "nomFericier", "nomFachancer", "nomNolfiere", "nomFachiere", "nomFchomer", "nomFiverire", "nomNichiere", "nomPFichier", "nomFcherer", "nomPichire", "nomPicherer", "nomFicheie", "nomFiverier", "nomFiverIER", "nomFichoancer", "nomFicheer", "nomFachier", "nomNichier", "nomFachery", "nomFilicjer", "nomNolfier", "nomPichier", "nomPachier", "nomFicerer", "nomNolfire", "nomFacher", "nomPichomer", "nomUFachIER", "nomFicherer", "nomUFichire", "nomFachanger", "nomPFoiljer", "nomFiciller", "nomFichoier", "nomUFachery", "nomFichie", "nomFcher", "nomFoilER", "nomPFichiller", "nomFichIER"], "extension": ["Extending", "expension", "protention", "strension", "strending", "expitude", "protractor", "extention", "expention", "extending", "extractor", "xtensions", "protitude", "Extension", "contitude", "expractor", "contension", "extensions", "strensions", "contention", "xtension", "extitude", "protension", "Extensions", "xtending", "contractor"], "fichierElectroniqueExistant": ["fichierElectronogramLocalistant", "fichierElectroniquePlusistant", "fichierElectronogueExistent", "fichierElectroniqueEXvant", "fichierElectroniqueEXistant", "fichierElectronogramLocalclusive", "fichierElectroniqueInert", "fichierElectroniqueInclusive", "fichierElectroniqueExvant", "fichierElectronicityInert", "fichierElectroniqueExiker", "fichierElectronogueExister", "fichierElectronicityInistant", "fichierElectroniquePresentiker", "fichierElectroniqueExplistance", "fichierElectroniquePresentistent", "fichierElectronogueExiker", "fichierElectroniqueEXistance", "fichierElectroniqueAssistance", "fichierElectroniqueInvant", "fichierElectronogueExistant", "fichierElectroniqueLocalclusive", "fichierElectronogramExistent", "fichierElectroniquePersistant", "fichierElectroniqueLocalistance", "fichierElectroniquePersistent", "fichierElectronicityInistance", "fichierElectroniquePersiker", "fichierElectroniqueLocalistent", "fichierElectroniqueExert", "fichierElectroniqueExistance", "fichierElectroniqueInistent", "fichierElectroniqueInistant", "fichierElectronoguePersiker", "fichierElectronicityExistant", "fichierElectronogramExclusive", "fichierElectroniqueExistent", "fichierElectronogramLocalistance", "fichierElectroniqueExplvant", "fichierElectronogramExistance", "fichierElectroniqueExclusive", "fichierElectroniqueLocalistant", "fichierElectroniquePlusistent", "fichierElectroniqueExplert", "fichierElectronicityInvant", "fichierElectronoguePersister", "fichierElectroniqueAssclusive", "fichierElectroniqueAssistent", "fichierElectronogramExistant", "fichierElectroniqueAssistant", "fichierElectronoguePersistant", "fichierElectroniqueExplistant", "fichierElectroniqueInistance", "fichierElectroniquePersister", "fichierElectroniquePlusister", "fichierElectronoguePersistent", "fichierElectroniqueEXert", "fichierElectroniquePresentistant", "fichierElectronicityExvant", "fichierElectroniquePresentister", "fichierElectronicityExert", "fichierElectronogramLocalistent", "fichierElectroniqueExister", "fichierElectroniquePlusiker", "fichierElectronicityExistance"], "idIgid": ["idImgid", "idIgdid", "idIvgid", "idIkgid", "idImglimit", "idIgcoid", "idIigmis", "idIgdoid", "idIgcido", "idIegdata", "idIgzid", "idAgaddress", "idIigmlimit", "idIkgaddress", "idAglimit", "idIIgido", "idIgzoid", "idIvgids", "idIgids", "idIvgkey", "idAmgaddress", "idImgis", "idIgcid", "idIigmid", "idAgis", "idImgids", "idAmgid", "idIIgoid", "idIgdata", "idIegkey", "idIIgzoid", "idIgkey", "idImgaddress", "idIgoid", "idIIgzido", "idIigmaddress", "idAmglimit", "idIIgid", "idIvgdata", "idIegid", "idIkgis", "idIglimit", "idIkglimit", "idIgdido", "idIgcida", "idIIgzida", "idIegids", "idImgdata", "idIgaddress", "idIgida", "idIgzido", "idIgis", "idImgkey", "idIIgzid", "idIgido", "idIgzida", "idIIgida", "idIgdida", "idAmgis", "idAgid"], "inputStream": ["InputSteam", "imageSteam", "inputstream", "imageLoop", "InputLoop", "helloStreamer", "outputStreamer", " inputThread", " inputStreamer", "helloSteam", "imageStream", " inputLoop", "InputStream", "inputThread", "outputSteam", "helloChannel", "inputStreamer", "inputChannel", "outputChannel", "outputThread", "inputLoop", "outputstream", "InputThread", " inputstream", " inputSteam", "helloStream", "Inputstream", "InputTime", "inputTime", " inputTime", " inputChannel", "imageTime", "inputSteam"], "outputStream": ["sequenceStream", "writeStream", "OutputStream", "OutputSteam", "outputStreamer", "OutputStyle", "webView", "outputSteam", "outputStyle", "outputView", " outputView", " outputSteam", "writeForm", " outputStreamer", "sequenceStreamer", "outputForm", "writeView", "writeSteam", "webStream", "webStreamer", "inputForm", " outputStyle", "sequenceSteam", "inputView", "sequenceStyle", "webSteam", "OutputStreamer", "OutputForm", "OutputView", "inputSteam"], "typeMime": ["typemime", "typeSmim", "Typemime", "typeSmme", "typeMim", "TypeMim", "typeRime", "typeMme", "TypeMme", "typeRim", "typeMIME", "typemme", "typeRme", "typeSmIME", "TypemIME", "typeSmime", "typemim", "TypeMIME", "Typemim", "typeRIME", "Typemme", "TypeMime", "typemIME"], "tailleFichier": [" tailleFicheies", " tailleFichie", " taillefichies", " tailleFuzzie", " tailleFixier", " tailleFixiers", " tailleFixies", " taillefichie", " tailleFicheier", " tailleFichies", " tailleficheie", " tailleFuzzier", " tailleFuzzies", " tailleFixie", " tailleficheier", " taillefichiers", " tailleFuzziers", " taillefichier", " tailleFichiers", " tailleFicheiers", " tailleficheiers", " tailleficheies", " tailleFicheie"]}}
{"id1": "7166270", "id2": "8665321", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"issueCommandToServer": [" sendCommandtoClient", " sendCommandFromRemote", " sendCommandTOserver", " sendCommandFromClient", " sendCmdToRemote", " sendCommandtoServer", " sendCmdtoServer", " sendCommandtoRemote", " sendCmdToClient", " sendCommandTORemote", " sendCmdtoRemote", " sendCommandToserver", " sendCommandToServer", " sendCmdtoserver", " sendCommandToClient", " sendCmdtoClient", " sendCommandTOServer", " sendCmdToserver", " sendCommandFromserver", " sendCommandTOClient", " sendCommandtoserver", " sendCommandFromServer", " sendCommandToRemote", " sendCmdToServer"], "command": ["menu", "code", "operation", "mode", "execute", "Command", "controller", "string", "directory", "template", "sequence", "document", "description", "attribute", "cmd", "password", "program", "form", "comm", "clear", "send", "connection", "application", "title", "request", "method", "help", "pattern", "requisite", "argument", "power", "direction", "query", "event", "message", "history", "channel", "action", "communication", "text", "uri"], "changeCapsule": ["changeClcapsULE", "changeCcapsale", "changeCapsale", "changeCapsULE", "changeCipherULE", "changeCpsules", "changeCcapsule", "changeCpsularity", "changeCipherue", "changeCapsue", "changeClapsULE", "changeClpsal", "changeCarsal", "changeCapsal", "changeCpsal", "changeClapsal", "changeClapsue", "changeCmsule", "changeClapsule", "changeCarsularity", "changeCcapsal", "changeCcapsules", "changeClapsularity", "changeClapsules", "changeCpsule", "changeClpsules", "changeCmsULE", "changeClcapsale", "changeCarsule", "changeCcapsULE", "changeCapsules", "changeCipherule", "changeClapsale", "changeCapsularity", "changeCarsules", "changeCcapsue", "changeClcapsue", "changeCmsale", "changeCmsue", "changeClcapsule", "changeCipherale", "changeCcapsularity", "changeClpsularity", "changeClpsule"], "urlConn": ["httpCon", "strConnection", "urlConnection", "logConnect", "urlconn", "UrlConnect", "httpCons", "strNum", " urlConnect", "httpConnection", "strConn", "urlCon", "urlNum", "fileConn", " urlCons", "dlconn", "logConnection", "retConn", "httpConnect", "retCons", "logconn", " urlCo", "dlConnect", "dlConn", " urlNum", "fileconn", "urlCo", "strCon", "strconn", "strConnect", "httpconn", "UrlConn", "httpConn", "retconn", "Urlconn", "strCo", "retConnect", "urlCons", "UrlNum", "httpCo", " urlconn", "urlConnect", "logConn", " urlCon", "fileConnect"], "wr": ["rew", "wk", "conn", "rw", "pr", "fw", "wp", "spr", "wx", "ew", "wo", "kr", "Writer", "wer", "wt", "writer", "wid", "nw", "wa", "we", "tw", "iw", "wy", "writ", "cr", "write", "writers", "vet", "w", "Wr", "RW", "wb", "wm", "mr", "sw", "tn", "vr", "vo", "hr", "fr", "WR", "wn"], "content": ["css", "code", "equ", "header", "data", "key", "address", "body", "label", "string", "ext", "expression", "template", "c", "load", "sequence", "document", "layout", "description", "Content", "core", "cont", "json", "media", "join", "context", "write", "application", "script", " Content", "section", "comment", "version", "txt", "ce", "search", "metadata", "value", "format", "resource", "ontent", "add", "reason", "config", "update", "output", "message", "text", "current", "source"], "input": ["submit", "http", "partial", "ip", "raw", "feed", "in", "inc", "background", "it", "xml", "inner", "alpha", "q", "data", "via", "reader", "image", "accept", "unknown", "Input", "inside", "open", " Input", "ahead", "form", "ssl", "init", "active", "upload", "info", "request", "enter", "iter", "ao", "acl", "iterator", "add", "internal", "local", "file", "pattern", "read", "query", "current", "update", "storage", "initial", "get", "output", "qi"], "response": ["report", "summary", "continue", "pos", "csv", "detail", "network", "resp", "reset", "dict", "respond", "server", "onse", "image", "verse", "related", "answer", "sequence", "still", "description", "collection", "trace", "application", "reply", "request", "version", "position", "vector", "block", "next", "value", "format", "service", "respons", "Response", "library", "result", "alert", "relation", "object", "view", "output", "message", "display", "buffer", "frame", "line"], "str": ["n", "print", "list", "err", "cat", "tr", "ctr", "dat", "data", "Str", "chain", "obj", "string", "re", "dr", "status", "msg", "exec", "name", "arr", "cert", "char", "line", "comm", "cont", "text", "j", "sp", "br", "st", "cs", "iter", "hex", "STR", "le", "t", "s", "piece", "exp", "del", "ent", "part", "set", "bc", "fr", "g", "expr", "r", "gr", "i", "txt", "p"]}}
{"id1": "8778962", "id2": "7948308", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFile2String", "decodeString2Files", "decodeFile2Files", "decodeFileFileFile", "decodeFileAsfile", "decodeFileToString", "decodeStringToFile", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToFiles", "decodeFileAsFile", "decodeFileFilefile", "decodeFile2file", "decodeString2file", "decodeStringTofile", "decodeFileAsString", "decodeString2String", "decodeFile2File", "decodeFileAsFiles", "decodeStringToString", "decodeFileToFiles", "decodeString2File"], "infile": ["inputname", "outname", "outfilename", "isinname", "isinfile", "inputfolder", "Infilename", "outfolder", "outbase", "inputFile", "Inbase", "isinFile", "inbase", "infolder", "fromFile", "Infile", "InFile", "inputfile", "inname", "frombase", "isinfolder", "inFile", "fromfile", "outFile", "infilename", "fromfilename"], "outfile": ["indir", "Outdir", "outname", "outfilename", "Outfile", "Outfilename", "toFile", "OutFile", "otname", "otfile", "otFILE", "tofilename", " outFILE", "inFILE", "outdir", "todir", "inname", "otFile", "tofile", "inFile", " outname", "outFile", "outFILE", "infilename", " outFile"], "in": ["inf", "conn", "oin", "IN", "it", "inc", "pin", "al", "inner", "cin", "ins", "input", "re", "ind", "rin", "bin", "im", "up", "In", "inside", "is", "ini", "form", "by", "or", "ar", "amin", "isin", "init", "con", "info", "iter", "nin", "t", "gin", "from", "id", "en", "ain", "get", "inn", "on", "per", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "print", "null", "ex", "oss", "it", "inner", "flush", "res", "OUT", "at", "os", "io", "ou", "Out", "aos", "writer", "fn", "end", "outer", "sys", "co", "write", "ot", "con", "ion", "opt", "t", "file", "auto", "gt", "can", "en", "g", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "header", "black", "memory", "paste", "window", "padding", "total", "available", "template", "base", "bone", "shape", "button", "table", "sequence", "document", "bar", "attribute", "password", "pad", "buf", "number", "row", "mem", "phrase", "note", "sample", "buff", "append", "comment", "stack", "info", "column", "block", "library", "variable", "binary", "initial", "view", "message", "temp", "display", "history", "frame", "character"], "read": ["n", "need", "give", " Read", "raw", "print", "shift", "push", "skip", "input", "index", "reading", "reader", "ind", "req", "seek", "load", "hold", "open", "Read", "end", "count", "send", "first", "write", "through", "iter", "size", "check", "wait", "connect", "add", "stream", "allow", "range", "start", "READ", "close", "query", "set", "find", "get", "ok", "run", "i", "before", "each", "length", "ready", "reads", "text", "select", "readable", "len"], "success": ["submit", "sufficient", "summary", "continue", "Success", "condition", "second", "cess", "city", " succ", "status", " successful", "ccess", "response", "accept", "democracy", "error", "town", "unity", "danger", "please", "exist", "commit", "snap", "valid", "first", "scope", "safe", "surv", " failure", "ceed", "setup", " okay", " successes", "primary", "same", "support", "complete", "value", "crit", "successfully", "result", " succeeds", "successful", "release", "ratulations", "good", "photo", "ok", "fail", " succeed", "done", "positive", "growth"]}}
{"id1": "5138455", "id2": "21824901", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"save": ["to", " append", " restore", "paste", "store", "Copy", " seal", "load", " store", " upload", " recover", "write", " Save", "upload", "clone", " merge", "copy", " move", " set", "gc", "dump", " clone", " persist", " swap", " dump", " insert", "Save", " paste"], "bytes": ["b", "raw", "some", "words", "ents", "classes", "blocks", "parts", "was", "aws", "seconds", "lines", "pieces", "bles", "gets", "rs", "bps", "odes", "its", "trans", "ces", "bits", "steps", "loads", "tes", "es", "ses", "gb", "binary", "amps", "ies", "values", "bs", "unks", "Bytes", "gs", "reads", "terms"], "outputFile": ["outDir", "inputPath", " outputPath", "tempFile", "tempfile", "referenceDir", "OutputFiles", " outputFilename", "outputPath", "referenceFiles", "inputFile", " outputFILE", "outFilename", "outputFilename", "inputDir", "outPath", "inputfile", " outputDir", "OutputPath", "outputFILE", "outputDir", "OutputFILE", "outputfile", "tempPath", "referenceFile", "OutputFile", "tempDir", "outputFiles", "OutputDir", "inputFilename", "referenceFILE", "outFile", " outputFiles", "Outputfile"], "in": ["inf", "m", "raw", "print", "IN", "l", "it", "inc", "al", "xml", "inner", "cin", "ins", "input", "mm", "reader", "ind", "im", "bin", "rin", "up", "In", "inside", "io", "is", "ini", "by", "f", "ze", "act", "isin", "st", "con", "iter", "mc", "ri", "gin", "from", "include", "mi", "pre", "read", "id", "en", "inn", "r", "on", "sin", "din", "i", "ie", " din", "source"], "out": ["o", "b", "v", "to", "n", "print", "null", "screen", "l", "it", "cache", "full", "obj", "res", "OUT", "at", "os", "io", "Out", "ou", "aos", "writer", "fn", "client", "end", "outer", "sys", "co", "write", "ot", "t", "file", "log", "auto", "can", " OUT", "op", "OU", "output", "outs", "on", "stable", "net", "i", "cn", "ne", "page", "nt"]}}
{"id1": "18891988", "id2": "4599372", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"getFile": ["getString", "createfile", "GetString", "selectFilename", "Getfile", "selectFile", "createString", "selectString", "GetFilename", "selectfile", "GetFile", "createFilename", "getFilename", "createFile", "getfile"], "serviceName": ["ServiceNames", " serviceType", "serviceCode", " serviceFamily", "libraryName", "serviceFamily", "ServiceType", " serviceNames", "ServiceName", "libraryNames", "ServiceCode", "libraryFamily", "serviceType", "serverType", "serverName", "serverCode", "libraryType", "ServiceFamily", "serviceNames", " serviceCode"], "wsdlLocation": ["wsdllocation", "wsDLlocation", "wsDLLocation", "awsdlURL", "wsdlURL", "awsdLoc", "wsdURL", "wsdlocation", "wslPath", "wslLoc", "wdlFolder", "wssdLocation", "wsdlLoc", "wsolURL", "awsolLocation", "wsDLLoc", "wslFolder", "wdlLoc", "wssdlocation", "awsollocation", "wdlPath", "wlLoc", "wdlLocation", "wssdLoc", "awsdlLoc", "awsdURL", "wssdPath", "awsdlocation", "wsollocation", "awsdlLocation", "wsdlFolder", "wlLocation", "awsdllocation", "wsdlPath", "wsDLURL", "wssdURL", "wsolLocation", "wsDLPath", "wslLocation", "wsDLFolder", "wsdLocation", "wssdFolder", "awsdLocation", "wsdLoc", "awsolURL", "wlFolder", "wsolLoc", "awsolLoc", "wlPath"], "endpoint": [" endport", "EndPoint", "beginpoints", "beginword", "endpoints", " endPoint", "startword", "Endword", "idPoint", "endPoint", "Endpoints", " endline", "bindPoint", "endport", "Endpoint", "bindpoint", " endpoints", "endline", "endword", "startpoints", "startpoint", "idpoints", "beginpoint", "idpoint", "bindport", "startPoint", "startline", "Endport", "bindpoints", "idline", "beginPoint"], "fileLocation": [" filelocation", " fileLoc", "filePosition", "Filelocation", "fileLoc", "documentlocation", "FileLoc", "filelocation", "FilePosition", "documentLocation", " filePosition", "FileLocation", "documentPosition", "documentLoc"], "tempDir": ["TempDir", "tempUrl", "TempUrl", "tmpdir", " tempPath", "tempdir", "tmpPath", "TempDirectory", " tempdir", "Tempdir", "tmpDirectory", " tempFolder", "tempPath", "TempPath", "tempDirectory", " tempDirectory", "tmpFolder", "TempFolder", " tempUrl", "tmpUrl", "tmpDir", "tempFolder"], "url": ["browser", "http", "pl", "m", "link", "conn", "web", "l", "socket", "ll", "cp", "rel", "window", "location", "re", "base", "loc", "up", "open", "li", "cert", "char", "f", "str", "il", "ul", "mail", "ssl", "dl", "ret", "un", "build", "ur", "nl", "cr", "bel", "mount", "https", "URL", "gl", "service", "Url", "job", "sl", "ctrl", "github", "r", "sur", "ls", "uri"], "WSDLFile": ["WSDQLFILE", "WSDDLFile", "WSDLType", "WNDDLFilename", "WIDDLfile", "WNDLFilename", "WSDELFILE", "WIDLfile", "WIDDLFile", "WSDLSType", "WSDQLfile", "WSDLLString", "WNDDLFile", "WSDELFile", "WNDLfile", "WSDLLFILE", "WIDLFile", "WSDDLfile", "WSDLLFile", "WSDLFILE", "WSDDLFilename", "WSDDLFILE", "WSDELFilename", "WIDLType", "WHDLFILE", "WIDLString", "WHDDLFile", "WSDLfile", "WSDLLFilename", "WNDLFile", "WSDMLFile", "WSDMLfile", "WSDELfile", "WIDDLType", "WSDLString", "WNDDLfile", "WSDLSString", "WNDDLFILE", "WNDLFILE", "WSDDLType", "WSDDLString", "WIDDLString", "WSDQLFile", "WHDLFile", "WHDDLFILE", "WHDDLfile", "WSDLLfile", "WSDLSfile", "WSDLFilename", "WSDLLType", "WSDLSFile", "WSDMLFILE", "WHDLfile"], "tmpWSDLFile": ["tmpWIDLFilename", "tmpWSDLDFile", "tmpWSDlfile", "tmpWSDLFILE", "tmpWSDLDFilename", "tmpWNDDLFiles", "tmpWSDlFiles", "tmpWSDDLFiles", "tmpWSDLDFILE", "tmpWIDLFile", "tmpWSDLLfile", "tmpWSDLLFILE", "tmpWIDDLFILE", "tmpWSDLFilename", "tmpWSDLLFile", "tmpWNDLfile", "tmpWNDLFiles", "tmpWNDDLFile", "tmpWSDlFilename", "tmpWNDDLFilename", "tmpWSDlFile", "tmpWSDDLFILE", "tmpWIDDLFilename", "tmpWIDDLFile", "tmpWIDLFILE", "tmpWSDLDfile", "tmpWNDLFile", "tmpWSDLfile", "tmpWIDLfile", "tmpWSDLLFiles", "tmpWSDLLFilename", "tmpWNDLFilename", "tmpWNDDLfile", "tmpWSDLFiles", "tmpWIDDLfile", "tmpWSDDLfile", "tmpWSDDLFile", "tmpWSDDLFilename"], "inputFile": ["infile", "inputPath", "errorStream", "InputFiles", "inputFILE", "inDo", "clientPath", "interfacefile", "errorFILE", "InputPath", "errorFile", "indexfile", " inputPlace", "errorfile", "tmpStream", "InputFile", "inputSourceFile", "intFile", "InputStream", "interfaceSourceFile", "indexFile", "Inputfile", "inputPlace", "tmpPlace", "intFiles", "outputStream", " inputPath", "indexStream", "inputfile", "inPath", "clientFile", "tmpSourceFile", "indexFILE", "outputFILE", "tmpfile", "outputfile", "interfacePlace", "clientFiles", " inputfile", "InputFILE", "intfile", "interfaceFile", "intFILE", "inputStream", " inputDo", " inputFILE", "inFile", "inputDo", "inputFiles", "clientFILE", " inputSourceFile", " inputFiles", "outputFile", "tmpFILE", "InputDo"], "tmpFile": ["empFilename", "inputFILE", "mpFiles", "tempFile", "tempfile", "mpPath", " tmpfile", "tempFilename", " tmpPath", "tmpPath", "tmpFiles", "empfile", "empFile", "tempFiles", "inputfile", "tmpFilename", "tmpfile", "tempPath", "mpfile", " tmpFiles", "inputFilename", "tempFILE", "mpFile", "empFILE", "tmpFILE"], "in": ["inf", "o", "n", "conn", "IN", "it", "inc", "inner", "cin", "ins", "inv", "input", "ind", "rin", "bin", "c", "In", "ini", "io", "is", "client", "ar", "cont", "isin", "ch", "init", "ln", "ri", "stream", "ai", "t", "from", "file", "mi", "id", "en", "ain", "inn", "sin", "r", "ic", "din", "source"], "out": ["o", "n", "to", "cache", "ne", "conn", "null", "ex", "oss", "obj", "inv", "buffer", "OUT", "at", "group", "c", "os", "Out", "ou", "io", "writer", "aos", "client", "by", "outer", "sys", "we", "connection", "conv", "ch", "co", "write", "ao", "w", "t", "file", "log", "auto", "can", "all", "en", "conf", "OU", "output", "outs", "tmp", "cm", "lock", "pool", "net", "this", "on"], "con": ["conn", "ws", "cp", "num", "cin", "sec", "cos", "Conn", "re", "c", "login", "acon", "exc", "cons", "fn", "cf", "un", "cone", "func", "fc", "connection", "nc", "ch", "co", "ln", "mc", "cur", "win", "com", "connect", "CON", "ran", "soc", "const", "can", "ain", "cm", "cal", "conf", "cn", "conv", "tc", "Con"], "fileLength": [" fileLen", "channelFontSize", "objectDuration", "ileLen", "ileLength", "objectSize", "channelDuration", "ileSize", " fileSize", "FILEDuration", "fileDuration", "FILESize", "fileLen", "FILELen", "channelSize", " fileFontSize", "ileDuration", "fileSize", "objectLength", "fileFontSize", "channelLength", " fileDuration", "objectFontSize", "FILELength"], "channelIn": ["ChannelSet", "clientIn", "ChannelIN", "Channelin", "ChannelOut", "channelin", "chanIn", "consoleedIn", "consoleIN", " channeledIn", "clientin", "channelSet", "clientSet", "consoleIn", "chanOut", "ChannelIn", "clientOut", "channeledIn", "ChanneledIn", "chanIN", "chanSet", "consoleOut", "clientIN", " channelin", " channelIN", "channelIN"], "channelOut": ["channelConn", "Channelout", "ChannelConn", " channelout", "ChannelOut", "chanIn", "consoleout", "channelout", "chanout", " channelConn", "courseOut", "courseout", "consoleIn", "chanOut", "ChannelOUT", "ChannelIn", "chanConn", " channelOUT", "courseIn", "courseOUT", "consoleOut", "consoleOUT", "channelOUT"], "tmpDocument": ["npMedia", "npDocument", "npFile", "tpFile", "mkDocument", "tpMedia", "tempdocument", " tmpDoc", "mkDoc", "mkdocument", "tmdocument", " tmpMedia", "tpDocument", "tmDoc", "tpDocuments", " tmpDocuments", " tmpdocument", "tmpDoc", "tempDoc", "tmpMedia", "npDocuments", "cpDocument", "cpdocument", "tempDocument", "tmpdocument", "mpDoc", "mpDocument", "tmDocument", "tmpDocuments", "cpDoc", "mpdocument"], "nl1": ["NL0", "pelOne", "ln3", "rn1", "ln6", "nl0", "ln01", "NL9", "NL2", "nl6", "sol2", "sol1", "nel1", "nel6", "nlOne", "nl01", "ln1", "pel01", "NL1", "sol9", "nl2", "rnOne", "nrOne", "ln0", "nl9", "nr1", "nr01", "ln2", "ln9", "rn6", "rn3", "nelOne", "pel1", "nl3", "nel3", "lnOne", "sol0"], "i": ["m", "multi", "n", "ip", "ci", "ui", "v", "ij", "o", "it", "ji", "gi", "span", "key", "ami", "I", "k", "us", "index", "mu", "\u0438", "ori", "y", "ini", "li", "is", "io", "ii", "ie", "bi", "pi", "u", "j", "ms", "a", "me", "init", "info", "cli", "ri", "ai", "sim", "mi", "ti", "ix", "hi", "id", "di", "ims", "ic", "x", "si", "xi", "qi"], "node1": ["Node1", " nodeOne", "ode0", "ode001", " node001", "Node2", "Node0", "node91", "layerOne", "NodeOne", "component1", "n1", "n0", "node2", " node91", " node0", "layer1", "Node001", "node001", "n91", "componentOne", " node2", "nOne", "ode2", "ode1", "nodeOne", "component0", "node0", "layer91", "component2", "layer0"], "tmpOut": ["npIn", "tempObj", "npout", "TempOUT", " tmpout", "cmpout", " tmpObj", "TempObj", " tmpIn", "mpOut", "tempOut", "npOut", "tmpIn", "cmpOut", "TempOut", "tempIs", "tmpObj", "tempout", "cmpIn", "tempIn", "mpIn", " tmpOUT", "tmpIs", "empIs", "tempOUT", "tmpOUT", "mpout", "npObj", "TempIn", "empout", "empOut", "mpObj", "tmpout", " tmpIs"], "retVal": ["returnVal", " retval", "returnval", "RetTrue", "Retval", "RetVal", "retValue", "RetValue", " retTrue", "retTrue", "returnTrue", " retValue", "returnValue", "retval"]}}
{"id1": "19810820", "id2": "88047", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFileChannel": [" copyByteStream", "copyFileStream", "copyByteStream", " copyFilesChannel", " copyByteFile", " copyFilechannel", " copyFilesStream", " copyFileschannel", "copyByteFile", " copyStreamStream", " copyFileStream", "copyByteChannel", "copyFilechannel", " copyBytechannel", " copyStreamChannel", " copyFileFile", " copyByteChannel", " copyStreamchannel", " copyStreamFile", "copyFileFile", " copyFilesFile", "copyBytechannel"], "src": ["syn", "usc", "js", "in", "ctr", "rt", "rl", "SOURCE", "sec", "rel", "filename", "ins", "input", "ser", "obs", "req", "RC", "rs", "rx", "loc", "SourceFile", "cont", "img", "sys", "usr", "rc", "init", "st", "txt", "sync", "cur", "sf", "inst", "Source", "s", "from", "start", "sl", "sc", "sb", "tmp", "bs", "dest", "sr", "ls", "sq", "source"], "dst": [" dest", "Ddest", "sest", "snd", " dth", "dist", "jest", "dnd", "jdest", "bst", "Dest", "Dist", "jut", "Dth", " ddest", "dut", "sdest", "ddest", "bdest", "sth", "jst", "Dst", "best", "dth", " dist", "sst", "bist", "Dnd", " dnd", "dest", "sut", "Dut"], "preserveModificationTime": ["preserveModifierTim", "preserveSpecificationTime", "preserveModifyTime", "preserveModifyingTime", "preserveModifiedTimes", "preserveModifierTimes", "preserveModifyPoint", "preserveModificationsTimes", "preserveSpecificationsTime", "preserveSpecificationTimes", "preserveQualificationPoint", "preserveModifyLength", "preserveModificationsPoint", "preserveModificationTimes", "preserveQualificationsLength", "preserveSpecificationTim", "preserveModificationsTime", "preserveQualificationsTime", "preserveModificationLength", "preserveModifyTimes", "preserveModifyingTimes", "preserveSpecificationsTimes", "preserveQualificationsTimes", "preserveModifierTime", "preserveModificationsLength", "preserveModifiedTime", "preserveModificationPoint", "preserveSpecificationsTim", "preserveQualificationTimes", "preserveModifiedTim", "preserveQualificationLength", "preserveModificationTim", "preserveQualificationsPoint", "preserveModifyingPoint", "preserveQualificationTime", "preserveModificationsTim", "preserveModifyingLength"], "inputChannel": ["inputConnection", "inputChan", "infoChuck", "outputBuffer", " inputListener", "interfaceCategory", "hiddenListener", "interfaceListener", "openGray", "Inputchannel", "clientGray", "openChannel", "entityChan", " inputChuck", "infochannel", " inputCategory", " inputStream", "outputchannel", "inputchannel", "InputStream", "innerChannel", "infoChannel", "inputBuffer", "inputListener", "hiddenCategory", "entityChannel", "infoChan", "outputStream", " inputchannel", " inputBuffer", " inputConnection", "outputChuck", "InputBuffer", "innerchannel", "clientConnection", "clientChannel", "inputGray", " inputGray", "clientChan", " inputChan", "openConnection", "evalChannel", "innerStream", "InputChannel", "inputStream", "hiddenChannel", "innerChan", "outputChan", "evalChan", "inputChuck", "interfaceChannel", "InputChan", "inputCategory", "openChan"], "outputChannel": ["inputConnection", "inputChan", "writeStream", "outputInstance", "displayChan", "displayButton", "OutputStream", "doubleField", "coinChannel", " outputConnection", "writechannel", "Outputchannel", "putButton", "coinField", "webManager", "inputInstance", "outputchannel", "OutputConnection", "coinChan", " outputButton", "putChan", "writeChannel", "webChannel", "outputStream", "doubleChannel", "writeManager", "outputConnection", "putchannel", "writeChan", "putChannel", "outputButton", "outputField", "displaychannel", "OutputChan", " outputStream", "doubleChan", "outputChan", "webchannel", "displayChannel", "outputManager", " outputchannel", "OutputChannel", "OutputManager", " outputChan", "inputManager", "coinInstance", "doubleInstance", " outputManager", "inputField"], "length": ["to", "capacity", "then", "list", "partial", "time", "l", "ength", "duration", "data", "amount", "full", "loop", "padding", "term", "volume", "available", "limit", "base", "load", "shape", "expected", "sequence", "details", "type", "width", "end", "number", "json", "text", "count", "offset", "Length", "bytes", "required", "size", "position", "ENGTH", "value", "present", "library", "needed", "max", "HH", "start", "all", "component", "left", "history", "family", "buffer", "height", "join", "len"], "total": ["done", "human", "summary", "scale", "zero", "raw", "to", "less", "num", "amount", "sum", "equal", "full", "unique", "no", "quant", "index", "available", "free", "base", "checked", "unknown", "used", "sequence", "bar", "meta", "description", "number", " Total", "count", "valid", "offset", "note", "ta", "title", "active", "info", "required", "size", "otal", "complete", "eta", "t", "last", "local", "created", "max", "successful", "all", "good", "stable", "this", "translation", "Total", "current"]}}
{"id1": "2736184", "id2": "23510383", "code1": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 0, "substitutes": {"getURLContent": ["geturlData", "postURLContents", "getUrlData", "getURLBody", "postHTTPData", "geturlContent", "getHTTPContents", "getURLData", "getUrlContent", "postURLContent", "getUrlContents", "getHTTPContent", "getURLContents", "geturlContents", "postURLBody", "postHTTPContents", "getUrlBody", "postURLData", "postHTTPContent", "getHTTPBody", "postHTTPBody", "getHTTPData", "geturlBody"], "urlPath": ["UrlName", " urlCl", "urlP", "urlCl", "UrlPath", "urlName", "dllName", "filePo", " urlName", "urlPo", " urlP", "uriCl", "UrlPo", "uriPa", "fileP", "uriPath", "dllCl", "uriName", "filePath", "dllPath", "dllPa", "UrlP", " urlPo", "urlPa", " urlPa", "fileName"], "requestData": ["caseString", "referenceInfo", "requestDATA", "requestString", " requestDATA", "caseDATA", "RequestString", "RequestDATA", "requestDate", "RequestData", "requestInfo", "questDate", " requestString", "caseData", "referenceContent", " requestContent", " requestInfo", "referenceData", " requestDate", "questData", "requestContent", "questInfo", "referenceDate", "RequestContent", "questContent", "caseContent"], "charset": ["chersabet", "chatset", "charsect", "chARSET", "Charspec", "chablesec", "chatsets", "chamesets", "contablesET", "charsat", "chapsET", "chasat", "contarsET", "chinsabet", "contarsets", "charsET", "chaset", "chinset", "ChARSET", "chersect", " chapsect", "chapsect", "chARSpec", "charspec", "chinsET", "chinsect", "Charsat", "charsabet", "chableset", "chablesET", "chARSat", "contarsec", "chameset", " charsET", "contablesec", " charsabet", "chapset", " chapset", "chersET", "chaspec", "chinsat", " charsect", "chamesET", "chatsec", "contablesets", "chARSet", "chamesec", "contarset", " chapsabet", "chasET", "ChARSet", "charsets", "charsec", "Charset", "contableset", "chinspec", "ChARSpec", "CharsET", "chablesets", "chatsET", "ChARSat", "cherset", "chapsabet", " chapsET"], "reader": ["print", "in", "rl", "inner", "Reader", "ro", "ner", "rd", "parser", "rar", "ser", "dr", "rx", "builder", "wrapper", "io", "handler", "writer", "rer", "client", "row", "ssl", "rc", "runner", "comment", "iter", "er", "stream", "resource", "file", "rr", "driver", "iterator", "loader", "read", "mr", "query", "r", "lr", "readable", "source"], "conn": ["att", "pg", "pkg", "dial", "rel", "Conn", "msg", "Connection", "c", "reg", "jp", "cf", "client", "ont", "bo", "org", "act", "nc", "init", "con", "pas", "connect", "com", " con", "n", "ca", "cp", "ctx", "exec", "open", "cert", "cmd", "comm", "j", "auth", "cb", "ln", "coll", "typ", "addr", "nt", "syn", "err", "yn", "ann", "ct", "fin", "cont", "ssl", "enc", "subject", "ch", "cs", "cur", "close", "en", "conf", "on", "ns", "ls", "apt", "gen", "lang", "canon", "proc", "obj", "res", "col", "tp", "connection", "co", "nn", "net", "cc", "cn", "conv", "txt", "wn"], "buffer": ["report", "batch", "cache", "print", "code", "Buffer", "command", "header", "black", "memory", "string", "total", "database", "response", "template", "table", "document", "sequence", "bar", "trace", "program", "buf", "row", "queue", "commit", "connection", "buff", "comment", "copy", "block", "file", "printf", "result", "binary", "output", "this", "message", "temp", "pool", "reference", "bridge", "line"], "out": ["o", "n", "to", "cache", "print", "ne", "cn", "in", "oss", "it", "source", "flush", "cos", "obj", "extra", "res", "user", "no", "OUT", "timeout", "at", "one", "os", "up", "Out", "ou", "io", "writer", "aos", "external", "client", "end", "by", "outer", "sys", "conv", "ch", "co", "note", "write", "serv", "ot", "con", "w", "t", "file", "gc", "auto", "ent", "can", "all", "en", "op", "g", "OU", "output", "outs", "on", "net", "or", "nt"], "url": ["http", "pl", "b", "link", "web", "l", "ll", "arl", "rl", "q", "rel", "el", "hl", "lb", "base", "name", "loc", "open", "char", "f", "str", "ul", "il", "abs", "ssl", "dl", "org", "api", "mail", "ur", "nl", "bel", "URL", "gl", "loader", "log", "ml", "Url", "sl", "r", "lr", "ol", "net", "ls"], "repCode": ["RepCount", " repCl", " repDay", "regCount", "repRate", "repDay", "servRate", "RepCode", "respRate", "repZone", "RepCl", "servCount", "regRate", "respZone", "servZone", "repCl", "respCount", "respCode", "repCount", "respDay", "respCl", "regZone", "servCode", "regCode", "RepDay", " repCount"], "count": ["report", "n", "acc", "cache", "batch", "code", "list", "ctr", "num", "amount", "sum", "found", "call", "index", "total", "child", "ind", "c", "len", "char", "ct", "cycle", "core", "number", "cont", "cell", "ch", "force", "Count", "size", "counter", "check", "port", "add", "depth", "start", "read", "max", "const", "ount", "match", "find", "conf", "nb", "cc", "length", "current", "nt"], "chBuffer": [" chLength", "qbuffer", "ichQueue", "chBuff", "achbuffer", "ChQueue", "achBuffer", "achBuff", "achQueue", "echFrame", "echBuffer", "charBegin", "chbuffer", "ichbuffer", "chFrame", "charbuffer", "qBegin", " chFrame", "qBuffer", "ChBuffer", " chbuffer", "chLength", "chQueue", "qBuff", "charBuffer", "ChBegin", "charBuff", "echbuffer", "ChBuff", "chBegin", "ichBuff", "achLength", "echLength", "Chbuffer", "achFrame", "ichBuffer"], "input": ["inf", "ip", "raw", "in", "it", "background", "inc", "more", "data", "inner", "q", "image", "Input", "inside", "open", "ahead", "char", "client", "form", "cont", "ch", "active", "add", "file", "local", "pattern", "read", "progress", "query", "get", "view", "output", "history", "before", "text", "current", "source"]}}
{"id1": "18793482", "id2": "19739421", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modureApplicationMsg", "modureApplicationmessage", "modifyAppData", "modureAppMsg", "modifyApplicationData", "modifyServerData", "modifyapplicationMessage", "modureApplicationMessage", "modifyServerMessage", "modureAppMessage", "modureAppmessage", "modifyApplicationmessage", "modureApplicationData", "modifyAppMsg", "modifyapplicationmessage", "modifyApplicationMsg", "modureAppData", "modifyServerMsg", "modifyAppMessage", "modifyapplicationMsg", "modifyAppmessage", "modifyServermessage", "modifyapplicationData"], "locale": ["regational", "LocALE", "localALE", "regales", "localaley", "regALE", "regale", "localational", "Locales", "locales", " locALE", "locational", "locALE", "Localey", " locales", "localales", " locational", " localey", "Locale", "Locational", "localale", "localey"], "messageName": ["msgType", "mediaKey", "mediaName", "MessageNAME", "messageNames", "MessageValue", "messageType", "msgKey", "MessageName", " messageNames", " messageKey", "mediaNames", "messageNAME", "messageKey", "msgValue", "msgName", "MessageType", " messageNAME", "MessageKey", " messageType", "mediaNAME", "MessageNames"], "messageValue": ["messageVALUE", "languageVALUE", "MessageValue", " messageVal", "messageType", "languagevalue", "MessageVALUE", "essageType", "MessageName", "messagevalue", "Messagevalue", "MessageVal", "essageName", "msgVALUE", "msgValue", "msgName", "MessageType", " messageType", "essageValue", "msgvalue", "languageName", "languageValue", "messageVal", "essageVal"], "properties": ["report", "types", "prop", "project", "settings", "policy", "data", "parts", "pid", "property", "options", "pro", "details", "json", "pdf", "files", " Properties", "utils", " props", "results", "metadata", "profile", "config", "params", "ps", "message", "perties"], "i18nPath": ["i18nePath", "i18rDir", "i18nP", "i8lDir", "i18neUrl", "i18nIf", "i8lStr", "i18bStr", "i18natDriver", "i18natPoints", "i18bPath", "i18neP", "i18nyPath", "i18rIf", "i18anIf", "i18lDir", "i18anPath", "i18nPoints", "i18nePoints", "i18rPath", "i18rDriver", "i18lPath", "i18anP", "i18nUrl", "i8nUrl", "i18anDir", "i18nDir", "i18neStr", "i18bDir", "i8lUrl", "i18nDriver", "i18lUrl", "i18bUrl", "i8nPath", "i18nyDriver", "i8nDir", "i8nStr", "i18natPath", "i18nyIf", "i18anDriver", "i18neDriver", "i18lStr", "i18nyDir", "i18anPoints", "i8lPath", "i18neDir", "i18nStr", "i18natP"], "englishFile": ["wikiPath", "enFilename", " englishPort", "ianaTable", "EnglishFilename", "languageFiles", "Englishfile", "electricFile", "ianaPort", "enFiles", "ianafile", " englishDirectory", "englishTable", "EnglishFiles", " englishDir", "englishfile", "englishFilename", " englishTable", "ianaFile", "languageFilename", "englishPath", "ianaDir", "languagefile", "wikiTable", " englishfile", "enfile", "englishDir", "electricPort", "EnglishFile", "englishPort", "englishFiles", "enFile", "wikiFile", "englishDirectory", "ianaPath", "electricDirectory", "ianaDirectory", "wikifile", "electricDir", " englishPath", "languageFile"], "propertiesFilePath": ["propertiesFilespath", "propertiesFilenameLocation", "settingsFilenameName", "propertiesFileName", "propertiesFilenameType", "propertiesfileLocation", "pertiesfileName", "propertiesFilesPath", "settingsFilenameLocation", "pertiesfilepath", "settingsFilenamepath", "propertiesFilepath", "settingsFileName", "propertiesfileType", "pertiesFileType", "propertiesFilesName", "propertiesfilepath", "settingsFilePath", "propertiesfileName", "settingsFilepath", "propertiesFilenameName", "pertiesFilepath", "pertiesFileName", "propertiesFilesType", "settingsFilenamePath", "pertiesfileType", "pertiesFilePath", "propertiesFileLocation", "propertiesFilenamePath", "pertiesfilePath", "propertiesFileType", "propertiesFilenamepath", "propertiesFilesLocation", "propertiesfilePath", "settingsFileLocation"], "file": ["entry", "rule", "report", "print", "null", "record", "use", "create", "data", "key", "xml", "filename", "string", "image", "base", "name", "os", "table", "document", "io", "language", "type", "fi", "attribute", "f", "ile", "style", "channel", "fp", "class", "connection", "application", "write", "files", "module", "domain", "comment", "info", "be", "port", "resource", "File", "format", "handle", "local", "library", "result", "complete", "model", "console", "content", "object", "output", "run", "path", "message", "page", "pool", "buffer", "FILE", "current", "parent", "source"], "in": ["inf", "oin", "IN", "inc", "it", "al", "inner", "cin", "ins", "input", "reader", "ind", "rin", "bin", "ir", "In", "ini", "io", "inside", "ar", "isin", "init", "iter", "asin", "ri", "ai", "gin", "from", "read", "en", "get", "ain", "inn", "sin", "ic", "din", "i", " din"], "out": ["o", "to", "n", "print", "screen", "cache", "csv", "ex", "it", "inner", "cos", "OUT", "at", "os", "Out", "ou", "io", "aos", "external", "again", "end", "outer", "we", "co", "write", "con", "put", "check", "w", "log", "sw", "can", "set", "conf", "output", "outs", "net", "conv", "nt"], "c": ["d", "n", "v", "cache", "code", "ac", "ca", "l", "cd", "cp", "lc", "k", "cos", "chain", "\u00e7", "call", "arc", "dc", "cf", "col", "char", "ct", "cont", "count", "fc", "u", "nc", "rc", "cr", "co", "ch", "cap", "cb", "con", "pc", "unc", "cs", "mc", "ce", "t", "gc", "etc", "cod", "cl", "bc", "C", "cm", "conf", "r", "ec", "i", "cc", "x", "cu", "character"], "is": ["ris", "isi", "it", "bis", "lis", "sis", "isa", "ins", "ais", "os", "tis", "its", "IS", "Is", "isf", "sys", "isin", "iso", "\u00eds", "ios", "nis", "ri", "iss", "es", "sit", "iris", "as", "isl", "ic", "isc", "i"], "breader": ["bler", "breadber", " breadber", " breadder", "breadar", "bbder", "breadr", "browber", "bbar", "brewer", "breade", "bbr", "bber", "brewber", " breadr", "breadger", " breadar", " breade", " breadger", "browger", "bleder", "blear", "brewger", "bleer", "browe", "brower", "brewe", "breadder"], "line": ["entry", "ip", "rule", "parse", "link", "continue", "code", "l", "record", "detail", "lin", "eline", "header", "node", "edge", "body", "chain", "no", "label", "string", "entity", "lines", "lo", "stroke", "sequence", "cmd", "trace", "char", "email", "side", "queue", "cell", "inline", "Line", "ine", "row", "online", "stay", "mail", "phrase", "nl", "note", "sample", "liner", "comment", "section", "column", "ln", "block", "iter", "word", "port", "next", "normal", "le", "LINE", "lane", "handle", "range", "se", "log", "part", "ice", "query", "point", "shell", "message", "left", "page", "slice", "frame", "text"], "strBuilder": ["StrBuffer", "StrParser", "objbuilder", "strParser", " strParser", "StrBuilder", "arrBuffer", "StrBuilt", "strBuilt", "arrBuilder", "StrBuild", "strbuilder", "frBuilder", "strBuffer", "strBuild", " strBuffer", "stringBuilder", "stringBuffer", "arrbuilder", "frBuild", "stringbuilder", "frParser", "StrBu", "arrBu", "objBuild", " strbuilder", "stringBuilt", "stringParser", "arrParser", "arrBuild", "strBu", "Strbuilder", " strBuild", " strBu", "frBuilt", "objBuilder", "objBuffer", "stringBuild"], "pieces": ["Parts", "strings", "types", "words", "blocks", "ops", "services", "times", "pins", "tools", "parts", "keys", "knife", "plates", "powers", "lines", "pointers", "links", "caps", "xes", "places", "its", "ctors", "fixes", "feet", "eps", "ces", "bits", "steps", "bytes", "letters", "cars", "tips", "sts", "ties", "checks", "piece", "fits", "groups", "items", "players", "cuts", "sections", "ps", "rings", "maps", "units", "terms", "finals"], "found": ["done", "ed", "forced", "err", "changed", " caught", "printed", " Found", "bool", "index", "failed", "loaded", "available", "identified", "sold", " founded", "opened", "used", "expected", "Found", "built", "mounted", "count", "valid", "first", "compl", "installed", "finder", "old", "sent", "supported", "search", "defined", "confirmed", "created", "read", "needed", "successful", "success", "find", "started", "fixed", "good", "filled", "empty", " detected", "given", "focused", "finished", "released", "tested"]}}
{"id1": "13368520", "id2": "18613870", "code1": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"sendTextFile": [" getTextFile", "getTextFile", " getLogFiles", " getReadStream", "getTextStream", " gettextStream", " gettextFile", " gettextPage", " gettextFiles", "getTextFiles", " getReadFiles", " getTextPage", " getTextFiles", " getLogPage", "getTextPage", " getLogFile", " getReadFile", "gettextFiles", "gettextPage", " getLogStream", "gettextFile", " getReadPage", "gettextStream", " getTextStream"], "filename": ["n", "ename", "wikipedia", "without", "NAME", "isa", "input", "string", "location", "oval", "journal", "username", "rison", "name", "sword", "document", "prefix", "FILE", "description", "fn", "kj", "license", "fil", "river", "f", "uno", "json", "Filename", "fp", "subject", "mpeg", "title", "jpg", "println", "file", "nm", "result", "nil", "kl", "fle", "output", "png", "path", "message", "stem", "txt", "fax", "uri", "source"], "url": ["browser", "http", "b", "pl", "rect", "link", "web", "l", "in", "ll", "q", "rel", "p", "base", "loc", "cert", "char", "client", "f", "str", "channel", "mail", "ret", "ssl", "dl", "build", "ur", "nl", "bel", "mount", "URL", "gl", "file", "resource", "t", "Url", "config", "sl", "fl", "run", "r", "page", "uri"], "out": ["o", "n", "to", "v", "print", "screen", "null", "list", "in", "it", "ex", "inner", "sum", "server", "flush", "obj", "res", "OUT", "os", "Out", "io", "ou", "writer", "aos", "sys", "write", "serv", "con", "ln", "stream", "w", "t", "file", "log", "can", "console", "output", "outs", "r", "tmp", "this", "net", "buffer", "txt", "p", "nt"]}}
{"id1": "21125261", "id2": "4056444", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 0, "substitutes": {"test": ["debug", "launch", "show", "server", "execute", "fit", "load", "feature", "tests", " testing", "unit", "Test", "T", "sample", "example", "evaluate", "volt", "t", " evaluate", "read", "train", "testing", "hello", " sample", "run", " tests"], "is": ["ris", "isi", "in", "ws", "lis", "sis", "xml", "has", "isa", "us", "are", "input", "rs", "ais", "os", "tis", "its", "IS", "sys", "Is", "mis", "iso", "ms", "serv", "ios", "does", "ri", "stream", "out", "ai", "xs", "s", "es", "fs", "sit", "as", "ps", "bs", "isc", "i", "ls"], "byteArrayOutputStream": ["byteArrayOutputString", "byteArray4String", "byteArrayoutputStream", "byteArrayByteView", "byteArrayoutputForm", "byteStreamOutputStream", "byteArray4View", "byteStringOutputSteam", "byteArray4Stream", "byteArrayoutputSteam", "byteArrayByteSteam", "byteStringOutputForm", "byteArray4Steam", "byteArrayByteString", "byteArrayByteStyle", "byteStringInputSteam", "byteStreamOutputForm", "byteArrayApplicationForm", "byteStringoutputForm", "byteStreamOutputStyle", "byteArrayByteForm", "byteStringInputString", "byteStreamInputStyle", "byteArrayOutputView", "byteArrayInputStyle", "byteArrayInputSteam", "byteArrayApplicationStyle", "byteArrayApplicationSteam", "byteStringOutputView", "byteStringOutputStream", "byteStringoutputString", "byteArrayByteStream", "byteStringoutputStream", "byteArrayOutputStyle", "byteArrayoutputString", "byteArrayInputForm", "byteArrayInputString", "byteArrayApplicationStream", "byteStreamOutputSteam", "byteStreamInputStream", "byteStringInputStream", "byteStreamInputForm", "byteStringInputView", "byteArrayInputView", "byteStreamInputSteam", "byteArrayOutputForm", "byteStringOutputString", "byteArrayInputStream", "byteArrayOutputSteam", "byteStringoutputSteam"], "def": ["dev", "d", "DE", "sche", "md", "cd", "dict", "hd", "desc", "DEF", "det", "define", "des", "ded", "pro", "da", "decl", "definition", "df", "json", "dl", "dem", "Def", "dec", "dal", "defined", "crit", "del", "sd", "ef", "conf", "default", "db", "de", "ds", "Definition"], "se": ["su", "SE", "ene", "ane", "parse", "Se", "sche", "sec", "ste", "pe", "ser", "sea", "ee", "ense", "spe", "engine", "she", "sa", "we", "ze", "ge", "est", "so", "sel", "e", "me", "sp", "ide", "he", "ase", "ce", "ve", "sem", "be", "le", "ke", "te", "ese", "es", "ses", "sd", "sl", "set", "sed", "ae", "ode", "see", "de", "ine", "ade", "pse", "ne", "ie"], "linkId": ["linkedIdent", " linkID", " linkName", "connectionIdent", "LinkId", "linkName", "lineName", "connectionID", "Linkid", "lineid", "connectionId", "linkid", "linkedID", "linkIdent", "lineId", "chainID", "linkID", " linkid", "LinkName", "chainId", "chainIdent", "lineID", "LinkID", "linkedId"], "segmentId": ["segmentName", "segroupID", "begmentId", "segmentID", "segroupById", "begroupID", "begroupName", "idegementName", "sementID", "semissionName", "begmentID", "segroupName", "sementRef", "segmentid", "segementId", "segementid", "idegementId", "idegmentid", "segmentRef", "idegementRef", "begroupId", "idegmentId", "sementid", "segementById", "segroupId", "semissionId", "segementRef", "sementById", "begmentName", "segmentById", "sementName", "semissionid", "idegmentRef", "begroupById", "idegementid", "idegmentName", "semissionRef", "sementId", "begmentById", "segementName", "segementID"], "linkSegments": ["linkFragments", "linkThreadments", "linkGroups", "linkParlements", "linkPargments", "linkConnectlements", " linkGment", " linkGroups", "linkSeggments", "linkBuildments", "linkBuildets", " linkGgments", " linkBuildments", " linkThreadments", " linkThreadgments", " linkThreadlements", "linkFraggments", " linkBuildets", " linkSegment", "linkSegment", "linkConnectables", " linkSeglements", " linkBuildables", "linkSegables", "linkBuildgments", " linkGments", "linkGgments", "linkBuildroups", " linkSegables", "linkThreadlements", "linkGments", "linkBuildment", " linkSeggments", " linkSegroups", "linkSements", "linkGment", " linkThreadroups", " linkSegets", "linkConnectets", "linkSeables", "linkBuildables", " linkBuildgments", "linkFragroups", "linkSeglements", "linkParments", "linkConnectroups", "linkParroups", "linkThreadroups", "linkConnectgments", "linkFragment", "linkThreadgments", "linkSegroups", "linkConnectments", "linkSeets", "linkSegets"], "segments": [" seges", "mements", "megments", "megs", "parsegments", " Seges", "segins", "segs", " Segments", "bevals", "sements", "vectors", "begments", " selements", " segs", "usegments", " segins", " Sevals", "seges", "megins", "usements", "parsectors", "bements", "usegs", " sectors", "vegments", " Sements", " sements", " sevals", "velements", "parselements", "beges", "selements", "vements", "sevals", "parsements", "sectors", "usegins"], "frameProperties": ["frameProptions", "frameParrics", "framePrrics", "frameProps", "frameComps", "frameProfilities", "frameComptions", " framePrptions", " frameProrics", "framePrps", "framePrperties", "frameComperties", "frameParps", " framePrps", "frameProrics", "frameByperties", " frameByptions", " frameByilities", " frameByperties", "frameProfperties", "frameProfptions", " frameProilities", "framePropilities", "frameByptions", "frameProfps", "frameProilities", "framePropptions", "frameComrics", " framePrperties", " frameProps", "framePropperties", " frameProptions", "frameByilities", "frameByps", "framePropps", " framePrrics", " frameByps", "frameParperties", "frameParptions", "framePrptions"], "time": ["timer", "TIME", "step", "duration", "times", "estamp", "second", "etime", "date", "window", "system", "total", "timeout", "distance", "year", "transform", "slow", "sequence", "trace", "frequency", "clock", "think", "rate", "Time", "count", "ime", "context", "tim", "trust", "version", "size", "task", "now", "check", "counter", "value", "t", "depth", "money", "ts", "start", "runtime", "length", "tt", "set", "tx", "point", "event", "speed", "message", "before", "each", "x", "delay"], "vehicle": ["verticles", "yardicle", "vertic", "vehic", "Vehocity", "vehendor", "vehICLE", "vehogram", "survogram", "survendor", "heroICLE", "ventocity", "verendor", "heroicles", "yardocity", "survicle", "verogram", "Vehicles", "heroicle", "verticle", "Vehicle", " vehocity", "venticle", " vehICLE", " vehicles", "heroocity", "yardogram", "venticles", "vertocity", "Vehic", "survocity", "VehICLE", "verocity", "ventic", "vericle", "yardendor", "vehocity", "vehicles"]}}
{"id1": "22708533", "id2": "12869602", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": [" copyDocumentToURI", " copyDocumenttoURI", " copydocumenttoUrl", " copyDocumentToFile", " copydocumenttoFile", " copyDocumentToUrl", " copyDocumentFromFile", " copydocumentToURI", " copyDocumentAsUrl", " copyDocumentToURL", " copyDocumentAsURL", " copyDocumenttoUrl", " copyDocumenttoURL", " copydocumenttoURI", " copydocumenttoURL", " copyDocumenttoFile", " copyDocumentFromURI", " copyDocumentFromUrl", " copydocumentToURL", " copyDocumentAsFile", " copyDocumentFromURL", " copyDocumentAsURI", " copydocumentToUrl", " copydocumentToFile"], "file": ["rule", "command", "data", "full", "filename", "doc", "input", "string", "image", "base", "name", "table", "document", "attribute", "fil", "f", "ile", "valid", "sample", "work", "title", "where", "origin", "check", "le", "resource", "local", "File", "from", "log", "default", "place", "path", "message", "FILE", "source"], "target": ["to", "link", "print", "project", "back", "root", "rel", "window", "location", "template", "base", "table", "layout", "replace", "alias", "top", "arg", "valid", "scope", "arget", "origin", "local", "Target", "pattern", "result", "home", "ARGET", "update", "component", "host", "view", "this", "dest", "remote", "join", "select", "source"], "is": ["ip", "dis", "ci", "ris", "isi", "oss", "bis", "it", "lis", "sis", "ists", "has", "isa", "us", "ins", "obs", "ir", "ais", "im", "rs", "vis", "ois", "tis", "its", "IS", "abs", "vs", "Is", "isf", "mis", "isin", "iso", "est", "ms", "ics", "bits", "\u00eds", "ys", "ios", "cs", "nis", "ri", "xs", "iss", "isal", "mi", "es", "fs", "iris", "ism", "isl", "ims", "ns", "bs", "i", "ains", "isc", "si", "mos"], "os": ["o", "css", "ose", "ks", "pos", "oin", "osa", "oss", "bis", "oa", "los", "ops", "oos", "cos", "us", "ins", "oses", "obs", "oS", "ori", "des", "ss", "aos", "io", "Os", "ows", "mes", "sys", "eps", "nos", "asis", "et", "ms", "dos", "mot", "ot", "none", "OS", "ios", "ols", "acs", "tes", "bos", "osi", "ts", "ones", "es", "ost", "uts", "ps", "ns", "bs", "out", "oes", "ox", "mos", "ros"], "url": ["http", "n", "link", "conn", "web", "l", "ll", "cp", "address", "rel", "user", "re", "location", "name", "open", "cert", "char", "client", "f", "str", "ul", "ssl", "ur", "nl", "domain", "mount", "con", "https", "URL", "t", "service", "Url", "job", "host", "r", "net", "channel", "ls", "uri"], "connection": ["entry", "n", "link", "conn", "command", "l", "condition", "pointer", "generation", "network", "session", " Connection", "city", "database", "response", "Connection", "c", "document", "still", "open", "description", "client", "number", "cone", "closure", "application", "con", "position", "established", "connect", "ion", "resource", "t", "service", "using", "result", "creation", "close", "opening", "relation", "reference", "net", "channel", "communication", "character", "uri"]}}
{"id1": "6421904", "id2": "20920051", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addRecord": ["addrecord", "writerecord", "newDocument", "AddFile", "writeDocument", "writeFile", "AddRecord", "AddDocument", "Addrecord", "addDocument", "newrecord", "newRecord", "addFile", "writeRecord", "newFile"], "input": ["m", "in", "it", "data", "address", "q", "reader", "image", "base", "up", "Input", "error", "open", "io", "table", "is", "media", "context", "upload", "request", "stream", "w", "add", "format", "from", "start", "config", "content", "initial", "get", "this", "out", "current", "p", "source"], "temporary": ["typoral", "comperature", "tempor", "typor", "temarily", "theporal", "semperature", "Temporal", "timmanent", "temcreated", "tymediate", "memporary", "temmediate", "temppty", "Temutable", "rempty", "tememp", "tempient", "transporal", "stemporary", "semporal", "stporal", "Temporary", "timporal", "temporal", "timmediate", "timperature", "remporal", "transporary", "tmporary", "timtemp", "tmutable", "comarily", "temmanent", "stporary", "tempporary", "memutable", "tempperature", "timutable", "tytemp", "temptemp", "tyient", " temporal", "transmanent", "tmient", "timarily", "transperature", "tempcreated", "timporary", "stemporal", "tmporal", "temutable", "comporary", "tmperature", "memperature", "remporary", "stemperature", "temtemp", "comporal", "temperature", "stemp", " tempty", "tenperature", "typerature", "tempty", "temputable", "remcreated", "Temperature", " temcreated", "semporary", "tmemp", "temient", "stemmanent", "theperature", "stperature", "tenporal", "temppor", "tenporary", "tempporal", "memporal", "tmpor", "themediate", "tenarily", "typorary", "tyutable", "theporary", "sememp"], "tempId": ["tempID", "fakeId", "tempUrl", "tempK", "templateK", "tempPart", "templateId", "templateRef", "fakePart", "templateIs", "TempId", "TempUrl", "currentK", "fakeID", "TempID", "stemId", "poraryRef", "fakeRef", "poraryPart", "tempRef", "templateID", "templateUrl", "tempIs", "poraryID", "stemID", "poraryUrl", "currentIs", "templatePart", "uniqueUrl", "currentId", "uniqueIs", "uniqueId", "currentUrl", "poraryId", "stemUrl", "uniqueK"], "length": ["n", "capacity", "code", "time", "l", "ength", "duration", "data", "amount", "full", "L", "filename", "total", "string", "location", "padding", "volume", "limit", "available", "loaded", "load", "name", "shape", "sequence", "description", "type", "width", "end", "number", "json", "SIZE", "count", "offset", "Length", "bytes", "version", "position", "size", "supported", "ENGTH", "value", "present", "read", "all", "maximum", "content", "default", "message", "path", "buffer", "height", "text", "readable", "len"], "digest": ["mdested", "Digested", "fingerest", "modested", " digist", "Digest", " digested", " digEST", " digester", "Digist", "signester", "fingerested", "diger", "identest", "identested", "DigEST", "mdest", " diger", "digested", "identig", "identester", "modEST", "mdester", "fingerEST", "mdig", "modest", "moder", "fingerester", "signest", "digig", "digEST", "Diger", "digester", "signested", "signist", "digist", "Digester", "Digig"], "output": ["o", "to", "web", "hidden", "generation", "network", "data", "four", "body", "unsigned", "no", "response", "image", "that", "open", "io", "ou", "client", "outer", "channel", "cut", "icon", "other", "connection", "write", "application", "none", "put", "ilo", "stream", "next", "result", "auto", "exit", "console", "object", "see", "Output", "message", "net", "display", "out", "page", "buffer", "you", "current", "source"], "file": ["print", "null", "in", "record", "data", "full", "user", "child", "io", "type", "dir", "upload", "le", "url", "File", "local", "binary", "get", "place", "page", "channel", "FILE", "source", "report", "to", "link", "al", "h", "base", "ile", "fp", "common", "stat", "module", "word", "resource", "value", "handle", "library", "result", "id", "run", "buffer", "entry", "rule", "body", "filename", "entity", "image", "document", "f", "il", "class", "valid", " File", "files", "work", "real", "info", "port", "same", "format", "db", "message", "temp", "out", "remote", "action", "tree", "line", "http", "create", "chain", "target", "name", "table", "error", "form", "e", "comment", "old", "block", "single", "log", "relation", "this", "path"], "parent": ["man", "m", "tree", "to", "rule", "ip", "null", "root", "folder", "child", "holder", "base", "name", "parents", "shape", "wrapper", "line", "global", "ger", "sp", "owner", "dir", "ma", "block", "port", "mother", "from", "master", "part", "op", "relation", "g", "per", "tmp", "this", "path", "pool", "Parent", "out", "p", "source"], "now": ["then", "zero", "null", "time", "since", "Now", "full", "sum", "NOW", "post", "date", "mm", "system", "aw", "yes", "amp", "omp", "loc", "after", "dd", "ct", "recent", "when", "st", "draw", "cmp", "off", "ow", "aj", "tim", "size", "wait", "from", "gov", "present", "always", "diff", "here", "exp", "sw", "set", "day", "onew", "mb", "ord", "before", "fx", "done", "ready", "current"]}}
{"id1": "21063400", "id2": "3809087", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"doImageProcess": ["doItemImageSort", "doItemImageProcess", " doImageprocess", " doImagesSort", " doImagesProcess", "doMediaWork", " doImageSort", " doImageWork", "doMediaprocess", "doImagesSort", "doImagesWork", "doItemImageprocess", "doImageSort", "doImagesprocess", " doImagesprocess", " doImagesWork", "doMediaProcess", "doImagesProcess", "doImageprocess", "doImageWork", "doMediaSort", "doItemImageWork"], "request": ["command", "address", "server", "session", "question", "input", "re", "image", "template", "document", "quest", "attribute", "client", "context", "application", "version", "resource", "Request", "start", "QUEST", "query", "model", "view", "reference", "message", "frame", "select"], "response": ["http", "report", "entry", "cache", "print", "continue", "list", "detail", "network", "xml", "resp", "server", "respond", "reset", "site", "hash", "res", "user", "onse", "re", "window", "image", "status", "one", "answer", "document", "sequence", "description", "collection", "json", "connection", "parent", "application", "write", "reply", "version", "position", "block", "ve", "next", "search", "format", "Response", "result", "exit", "model", "success", "query", "console", "content", "relation", "view", "output", "fire", "message", "page", "display", "frame", "tree"], "imgSize": [" imgName", "dimsize", "imagError", "imageSIZE", "dimSIZE", "propName", "certScale", "augSize", "certSIZE", "imageInfo", " imgShape", "imageScale", "divSIZE", "imgsize", "augOwner", " imgType", "imgInfo", "imgStyle", " imgsize", "divsize", "divSize", "imgScale", "appStyle", "certSize", "appShape", "imgShape", "appSize", " imgInfo", "augsize", "appsize", "certName", "imagSize", "imgOwner", "imagName", "propsize", "augShape", "imageStyle", "appType", " imgOwner", " imgStyle", "imageSize", " imgSIZE", "imgError", "dimSize", "imgSIZE", "imgName", "appInfo", " imgScale", "propSize", " imgError", "appOwner", "propError", "imgType", "imagsize", "imageName", "imageType"], "imageInputStream": [" imageInputPath", "imageOutputSteam", "imageInStream", "fileRawStream", "fileInputStream", "imageIntPath", "imageInterfaceStream", "imageInputSteam", "imageInSteam", "photoIntstream", "imageByteStream", "fileRawSteam", " imageStreamPath", "imageRawView", "fileRawstream", "imageByteForm", "mediaInputForm", "imageInputPath", "imageStreamPath", "imageRawstream", "imageInputView", "imageInstream", "mediaInputReader", "imageByteReader", "photoIntStream", "photoIntSteam", "imageStreamSteam", "mediaInputSteam", "imageInputReader", "fileInputSteam", " imageStreamStream", "imageRawStream", "imageInterfaceSteam", "imageIntStream", "imageByteSteam", "imageStreamStream", "imageOutputstream", "imageIntstream", "imageOutputForm", "imageOutputReader", "imageInterfaceView", "imageOutputStream", "photoInputstream", "imageInputstream", "fileInputView", "imageRawSteam", "mediaInputStream", " imageStreamSteam", "imageIntSteam", " imageInputSteam", "photoInputSteam", "imageInputForm", "imageInView", "fileRawView", "photoInputStream", "imageInterfacestream", "fileInputstream"], "imageBytes": ["photoGs", "pictureBytes", "audioBytes", "photoBytes", "imgGs", "imageSeries", "imgBs", "imageGs", "photoParts", "imageKeys", "issueParts", "audioSeries", "imageParts", "imageByte", "issueGs", "issueBytes", " imageBs", " imageGs", " imageSeries", " imageByte", "imgBytes", "photoByte", "audioParts", "pictureByte", "imgParts", "photoKeys", "pictureGs", "audioBs", "imgSeries", " imageParts", "pictureParts", "imgKeys", "issueKeys", "imageBs"]}}
{"id1": "3631989", "id2": "4389475", "code1": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"run": ["submit", "launch", "web", "background", "show", "thread", "execute", "test", "call", " Run", "loop", "process", "exec", "begin", "render", "runs", "running", "unit", "runner", "sample", "evaluate", "Run", "profile", "start", "app"], "url": ["browser", "http", "b", "v", "link", "pr", "null", "web", "l", "ll", "xml", "address", "h", "key", "k", "hub", "el", "p", "window", "location", "re", "hl", "git", "base", "name", "cert", "char", "client", "f", "il", "mail", "ssl", "dl", "u", "ret", "ur", "nl", "bel", "mount", "https", "URL", "stream", "gl", "t", "file", "Url", "sl", "id", "github", "r", "channel", "uri"], "in": ["inf", "n", "print", "oin", "IN", "l", "it", "ill", "inc", "al", "inner", "cin", "sum", "ins", "el", "input", "reader", "ind", "rin", "bin", "In", "is", "isin", "con", "and", "ln", "ma", "er", "mn", "gin", "from", "read", "all", "en", "inn", "r", "on", "ic", "out", "din", " din", "line"], "str": ["n", "list", "l", "err", "Str", "body", "obj", "string", "status", "c", "char", "f", "j", "ch", "nl", "sp", "serv", "st", "txt", "ln", "iter", "s", "fr", "bl", "r", "out", "i", "text", "p"]}}
{"id1": "620855", "id2": "6421904", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["DoVersionCheck", "doDatecheck", "doDateUpdate", "doLicenseUpdate", "doLicenseCheck", "doLicenseFix", "doLicensecheck", "doDateFix", "doVersionsUpdate", "doVersionsCheck", "DoVersionUpdate", "doVersionUpdate", "DoDateCheck", "doVersionscheck", "doVersionFix", "doVersioncheck", "DoVersionFix", "DoDateFix", "DoDatecheck", "DoVersioncheck", "DoDateUpdate", "doDateCheck", "doVersionsFix"], "view": ["browser", "http", "report", "v", "print", "web", "html", "show", "blade", "server", "q", "call", "doc", "input", "views", "window", "index", "controller", "hl", "image", "self", "eye", "document", "layout", "iew", "open", "table", "wrapper", "form", "client", "View", "engine", "row", "cell", "subject", "context", "review", "manager", "block", "check", "cv", "file", "help", "widget", "query", "model", "update", "console", "VIEW", "get", "see", "host", "tv", "component", "this", "display", "util", "out", "page", "buffer", "tree"], "url": ["browser", "http", "pl", "b", "v", "link", "null", "web", "l", "socket", "ll", "html", "rl", "address", "rel", "date", "string", "location", "hl", "lb", "oul", "loc", "language", "char", "client", "f", "str", "ul", "json", "ssl", "dl", "org", "ur", "nl", "bel", "mount", "URL", "gl", "file", "log", "Url", "sl", "id", "github", "host", "lr", "r", "path", "ls", "uri"], "in": ["inf", "b", "n", "IN", "l", "inc", " IN", "inner", "cin", "body", "ins", "input", "reader", "vin", "rin", "In", "is", "f", "isin", "kin", "init", "info", "ln", "asin", "mn", "stream", "file", "gin", "mat", "ain", "inn", "sin", "out", "din", "i", " din", "source"], "bin": ["b", "cache", "conn", "thin", "mon", "ebin", "cin", "inner", "abin", "cos", "buffer", "spin", " bins", "reader", "obin", "rin", " Bin", "rb", "by", "bi", "bed", "bn", "mem", "sam", "bg", "buff", "con", "pipe", "ln", "win", "file", "gin", "ran", "local", "loader", "binary", "bl", "stock", "inn", "sin", "nb", "lib", "out", "din", "bur", " din", "len"], "line": ["entry", "link", "print", "code", "l", "err", "record", "cat", "lin", "eline", "body", "chain", "el", "no", "store", "string", "lines", "one", "lo", " Line", "base", "state", "load", "field", "cmd", "col", "char", "trace", "style", "cell", "row", "Line", "ine", "inline", "sample", "ls", "liner", "comment", "section", "column", "ide", "ln", "block", "iter", "level", "word", "port", "le", "LINE", "file", "lane", "range", "se", "log", "job", "part", "ice", "point", "path", "page", "channel", "frame", "text"], "version": ["browser", "v", "scale", "command", "project", "serial", "usage", "key", "Version", "test", "hash", "major", "VER", "virtual", "date", "index", "string", "software", "VERSION", "volume", "image", "status", "video", "name", "sequence", "description", "latest", "type", "license", "feature", "river", "form", "client", "vers", "ver", "number", "language", "iso", "title", "info", "position", "ion", "vision", "value", "resource", "format", "versions", "release", "update", "match", "spec", "tag", "translation", "python"], "build": ["dev", "b", "building", "print", "link", "project", "struct", "use", "install", "full", "test", "hash", "develop", "date", "dist", "th", "ble", "ward", "load", "ship", "builder", "boost", "hold", "uild", "built", "latest", "ver", "style", "other", "unit", "Build", "work", "where", "old", "be", "add", "last", "bor", "log", "make", "release", "update", "match", "binary", "round", "bug", "db", "arch", "lib", "tag", "fail", "util"]}}
{"id1": "19549577", "id2": "9319440", "code1": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 1, "substitutes": {"callApiPost": ["callUapiDelete", "callAapiPut", "callAiPOST", "callUapiPost", "callApiDelete", "callUpiPost", "callActionsPut", "callUpiPut", "callAiDelete", "callActionsPost", "callUapiPut", "callUapiPOST", "callAapiPOST", "callAapiDelete", "callUpiDelete", "callAapiPost", "callApiPut", "callAiPost", "callUpiPOST", "callApiPOST", "callActionsDelete", "callActionsPOST", "callAiPut"], "apiUrl": ["piUrl", "apiName", "resourceURL", "apiUr", " apiUr", "resourceUr", "piUr", "baseUrl", "baseUr", "piURL", "baseURL", "apiPath", "apURL", "basePath", "piPath", "apUrl", "piName", "apPath", "resourceName", " apiName", "apUr", "apiURL", "resourceUrl", " apiURL"], "parameters": ["pperties", "paramParameters", "queters", "mParameters", "meters", "questParameters", "payants", "paramperties", "questperties", "paramants", "paramels", "paramions", "pParameters", "peters", "pions", "mions", "authorels", "authortons", "authoreters", "quels", "mperties", "paytons", "paramtons", "questeters", "authorants", "payels", "qutons", "payeters", "questions", "quants"], "expected": ["pected", "code", "test", "sex", "failed", "checked", " expectation", "error", "type", "allowed", "ped", "seen", "json", "count", "odd", " expect", "reported", "received", " expects", " unexpected", "safe", "e", "force", "actual", "example", "sent", "required", "size", "value", "future", "needed", "set", "encrypted", "posted", " expecting", "hello", "event", "default", "empty", "pect", "pects", "finished", "done", "foo", "current"], "url": ["http", "pl", "link", "l", "ll", "arl", "rl", "address", "q", "re", "hl", "base", "oul", "loc", "www", "f", "str", "ul", "abs", "mail", "ssl", "dl", "build", "ur", "nl", "bel", "mount", "https", "URL", "gl", "service", "gc", "loader", "impl", "log", "ml", "Url", "sl", "get", "r", "ls", "uri"], "request": ["access", "project", "record", "header", "reset", "q", "user", "req", "java", "reverse", "pull", "begin", "client", "pair", "setup", "enter", "connect", "release", "get", "reference", "change", "report", "parse", "web", "session", "memory", "store", "over", "friend", "open", "requ", "worker", "rate", "first", "version", "position", "resource", "require", "order", "object", "run", "buffer", "command", "socket", "xml", "question", "call", "re", "process", "response", "volume", "document", "quest", "remove", "register", "media", "send", "application", "search", "complete", "Request", "QUEST", "close", "forward", "initial", "message", "remote", "parent", "condition", "use", "create", "root", "accept", "name", "query", "exit"], "headerName": ["componentName", "attributename", "methodSpec", "profileSpec", "headingNAME", "authorname", "methodName", "headingHandle", "propertyNAME", " headerNAME", "authorName", "propertyname", "authorNAME", "componentNAME", "headingName", "headername", "methodLetter", "propertySet", "headerNAME", " headerFamily", "attributeNAME", "headingSpec", "methodHandle", "profileHandle", "attributeName", "headingLetter", "attributeSet", "headerLetter", "profileName", "headerSpec", "headerHandle", "componentFamily", "profileLetter", "authorSet", "headerFamily", "headingFamily", "propertyName", "headerSet"], "out": ["o", "n", "to", "print", "null", "in", "ex", "inner", "server", "flush", "res", "OUT", "timeout", "at", "os", "up", "table", "Out", "ou", "io", "writer", "aos", "client", "outer", "sys", "co", "write", "init", "comment", "check", "stream", "t", "s", "help", "log", "auto", "ent", "can", "set", "all", "console", "output", "outs", "tmp", "net", "pretty", "cn", "conv", "source"]}}
{"id1": "10218878", "id2": "8216539", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFromFile", "DecodeToLog", "DecvertMAPLog", "DecodeFromfile", "DecodeMAPfile", "DecodeToFile", "DecvertMAPFiles", "DecodeMAPFiles", "DecodeToFiles", "DecodeMapfile", "DecvertMAPfile", "DecvertMapfile", "DecodeMAPFile", "DecodeTofile", "DecodeMAPLog", "DecvertMAPFile", "DecvertMapFile", "DecodeMapLog", "DecodeFromLog", "DecvertMapLog", "DecodeMapFiles", "DecvertMapFiles", "DecodeFromFiles"], "mapFile": ["mapPath", "mapStream", " mapStream", "MapFile", " mapFilename", "cachePath", "imageStream", "Mapfile", "cacheFile", "imageFilename", "mapfile", "MapStream", "mapFilename", "listPath", "imagefile", "listFile", "imageFile", "mapFILE", " mapfile", " mapPath", " mapFILE", "cacheFILE", "listFILE", "MapFilename"], "outputFile": ["outDir", "writeStream", "writeDir", "mapName", " outputPath", "mapStream", "OutputFilename", "outputName", " outputFilename", "outputPath", "inputFile", "outFilename", "outputFilename", "outputStream", "inputDir", "outPath", " outputDir", "OutputPath", "writeName", "outputDir", "inputName", "OutputFile", "inputStream", "OutputDir", "writeFile", "outFile", "mapDir"], "magicKey": ["serialKEY", "magicValue", "magicCounter", "prefixCode", "uniqueValue", " magicCode", "magickey", " magicCounter", "MagicKey", "anticKey", " magicKEY", "uniqueKey", "encryptedkey", "magicField", "magicChar", "magicId", " magickey", "encryptedChar", "magicKEY", " magicChar", "prefixValue", "MagicName", "anticChar", "serialName", "MagicId", "uniqueCode", "encryptedKey", "prefixKey", " magicField", "serialId", " magicValue", "anticField", "magicName", "MagicKEY", "serialKey", "encryptedField", "magicCode", "prefixCounter", "uniqueCounter", " magicName", "antickey", " magicId"], "buffer": ["batch", "cache", "print", "code", "command", "Buffer", "screen", "detail", "header", "black", "sum", "filter", "memory", "paste", "index", "window", "total", "database", "template", "base", "bone", "stroke", "shape", "button", "table", "document", "sequence", "attribute", "program", "char", "pad", "flash", "buf", "queue", "row", "bo", "mem", "phrase", "sample", "buff", "append", "stack", "iter", "block", "vector", "check", "stream", "variable", "binary", "initial", "message", "display", "page", "history", "length", "frame", "bridge"], "nread": [" ntry", " nwrite", "rnREAD", "rawwrite", "maxread", "maxadd", "maxget", "nREAD", "ncreadable", "Nread", "nget", "Nget", "nadd", "ncread", "Nadd", "NREAD", "ncget", "maxRead", " nreader", "rnread", "nwrite", "renreader", "nRead", "NRead", "ncRead", "renread", "Nwrite", "rawtry", "rnRead", "Nreadable", "renwrite", "rawread", "nreader", "rawreader", "ncwrite", "rnwrite", " nREAD", " nRead", " nreadable", "rentry", "ntry", "nreadable", "ncadd"], "map": ["man", "m", "pl", "ip", "parse", "cache", "batch", "collect", "mate", "ap", "address", "memory", "window", "image", "load", "shape", "mod", "up", "table", "apper", "down", "meta", "open", "pack", "form", "clear", "mem", "co", "module", "where", "mount", "ace", "con", "manager", "block", "MAP", "mt", "com", "ape", "file", "mp", "mask", "aps", "master", "ml", "config", "read", "make", "set", "op", "view", "cm", "pose", "lock", "per", "app", "place", "maps", "apping", "bridge"], "output": ["o", "batch", "cache", "print", "web", "hidden", "socket", "network", "four", "blue", "target", "input", "entity", "response", "secure", "ou", "open", "oe", "latest", "client", "outer", "queue", "icon", "other", "write", "put", "block", "port", "ilo", "stream", "next", "format", "file", "log", "auto", "result", "plain", "exit", "can", "update", "console", "object", "Output", "display", "net", "out", "online", "current"], "i": ["m", "b", "v", "ip", "ci", "ui", "n", "batch", "multi", "it", "ji", "ei", "gi", "span", "ami", "q", "phi", "us", "index", "spin", "ind", "y", "ini", "ii", "li", "is", "gu", "iu", "fi", "ie", "bi", "ish", "pi", "u", "j", "x", "ms", "cli", "ri", "ai", "sim", "t", "mi", "ti", "ix", "ni", "id", "g", "di", "ic", "I", "si", "xi", "qi", "uri"]}}
{"id1": "12197169", "id2": "7846688", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"read": [" reads", " Read", " replay", "record", "download", "reading", "reader", " retrieve", " reopen", "load", "open", " seek", " recover", "init", " reader", "connect", "stream", "next", "gc", "start", "log", "close", "find", "hello", " ingest", "run", " request", "Read", " download"], "in": ["inf", "o", "entry", "IN", "l", "it", "ill", "source", "record", "inc", "al", "inner", "cin", "ing", "body", "ins", "ro", "input", "via", "index", "re", "reader", "at", "bin", "name", "In", "is", "io", "again", "f", "by", "or", "when", "isin", "con", "and", "info", "er", "check", "with", "stream", "add", "url", "file", "from", "log", "update", "all", "as", "get", "conf", "run", "inn", "on", "r", "message", "out", "din", "during", " din"], "line": ["entry", "code", "link", "l", "record", "detail", "lin", "eline", "data", "body", "chain", "string", "lo", "stroke", "sequence", "char", "cell", "row", "Line", "ine", "inline", "e", "sample", "liner", "comment", "ln", "block", "word", "stream", "le", "url", "file", "lane", "LINE", "se", "piece", "log", "part", "point", "message", "path", "page", "frame", "text"], "i": ["d", "m", "multi", "n", "to", "ci", "o", "v", "l", "ei", "phi", "index", "p", "ind", "base", "im", "ori", "c", "y", "oi", "sequence", "li", "ii", "is", "f", "bi", "pi", "j", "conv", "u", "x", "me", "iter", "cli", "ai", "sim", "t", "z", "mi", "ti", "hi", "ix", "id", "di", "I", "si", "xi", "qi", "zi"], "logDatum": ["logRummy", " logDump", "logBictionary", "logDum", "logDictionary", "logTratum", "logDoatum", "logBump", "LogDummy", "LogData", "logDoummy", "LogDum", "logDoump", "logRictionary", "logdummy", "logRatum", "logdata", "logRump", " logBictionary", " logBatum", " logDummy", " logBump", "logdum", " logDictionary", "logDump", " logBummy", "logData", "logdatum", "Logdum", "logTrum", "Logdata", "logTrummy", "logBatum", "logTrata", "Logdummy", "LogDatum", "logDummy", "logBummy", "Logdatum", "logDoictionary"]}}
{"id1": "13657527", "id2": "3197876", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"getDatasetsList": ["getDatasetsStatus", "getDatisetsStatus", "getDatisetsList", "getDatisetResult", "getDatasetResult", "getDatasetStatus", "getDatisetStatus", "getDatisetsResult", "getDatasesList", "getDatasetList", "getDatasetsResult", "getDatasuresResult", "getDatasesStatus", "getDatisetList", "getDatasuresStatus", "getDatasuresList", "getDatasesResult"], "surl": ["esurl", "slim", "esname", " smail", "sUrl", "stslt", "ssUrl", "stsurl", "sURL", "stsuri", " suri", "sysserver", "suri", "esURL", "ssURL", "lsuri", "jslim", "esuri", " sname", "sslim", "slt", "stsserver", "sysurl", "lsUrl", "lsserver", "lslt", "ssurl", "ssuri", "esUrl", "jsuri", " sUrl", "sysuri", "sname", "syslt", "jsurl", "lsurl", "smail", "jsUrl", "lsmail", "sserver"], "datasetsList": ["datassetsList", "datasetMap", "datarsetList", "datasagesData", "dataselinesList", "datasuresList", "datasureslist", "datasamesList", "datasagesSet", "datasuresSet", "datarsetsList", "datasetlist", "datmassetsMap", "datasetsLock", "datasameslist", "datmassetsLock", "datasamesSet", "datisetsName", "datasetsName", "datasetGroup", "datmasetsMap", "datasetLock", "datasetslist", "datarsetsLock", "datasuresMap", "datasourcesList", "datasagesList", "datassetsMap", "datasensList", "datasETSName", "datasETSList", "datarssetsLock", "datisetsGroup", "datasenslist", "datisetName", "datarssetsList", "datarsetMap", "datarsetsTable", "datassetsData", "datasetName", "datassetsSet", "datasamesMap", "datassetsLock", "datarssetsSet", "datarsetslist", "datasETSMap", "datasetsTable", "datassetsTable", "datasourcesLock", "datisetList", "datasETSGroup", "datasetsData", "datasourcesSet", "datasagesTable", "dataselinesGroup", "datasagesMap", "datassetslist", "datarssetsTable", "datasetsMap", "datasetsSet", "datmassetsData", "datmasetsLock", "datmasetsData", "datarsetSet", "datasetsGroup", "datisetsMap", "datisetsList", "dataselinesMap", "datasagesLock", "datarsetlist", "datasetData", "datarsetsSet", "datasetList", "datasourcesTable", "datmasetsList", "datmassetsList", "datarsetsMap", "dataselinesName", "datisetMap", "datasetSet", "datisetGroup", "datasensMap"], "result": ["report", "menu", "record", "detail", "Result", "test", "chain", "found", "res", "folder", "response", "status", "answer", "table", "sequence", "details", "cert", "description", "form", "exist", "ret", "valid", "first", "contact", "comment", "results", "search", "complete", "successfully", "diff", "successful", "set", "success", "there", "def", "relation", "default", "message", "buffer"], "reader": ["timer", "socket", "operator", "rl", "inner", "Reader", "body", "test", "ner", "ser", "reading", "parser", "rar", "ro", "dr", "via", "rd", "upper", "older", "field", "wrapper", "handler", "writer", "rer", "client", "river", "author", "layer", "row", "bo", "runner", "liner", "iter", "roller", "peer", "er", "stream", "iterator", "resource", "driver", "rr", "handle", "loader", "redo", "range", "file", "read", "mr", "READ", "query", "r", "per", "buffer"], "url": ["browser", "http", "link", "null", "web", "l", "ll", "rl", "address", "key", "user", "location", "char", "client", "str", "ul", "il", "row", "ssl", "dl", "org", "mail", "ur", "nl", "mount", "URL", "stream", "resource", "file", "loader", "Url", "sl", "id", "lr", "r", "ls", "uri"], "s": ["b", "n", "strings", "v", "csv", "l", "js", "ws", "less", "qs", "full", "h", "has", "us", "ins", "string", "rs", "gets", "ids", "os", "y", "S", "still", "ss", "hs", "is", "its", "str", "abs", "sv", "sql", "ms", "sample", "cs", "tes", "t", "sts", "ts", "series", "ats", "es", "sw", "as", "sym", "r", "sb", "ps", "bs", "i", "ns", "ds", "gs", "ls", "sq", "source"], "list": ["batch", "print", "l", "detail", "ll", "full", "listed", "chain", "test", "L", "array", "LIST", "group", "table", "sequence", "layout", "li", "collection", "php", "form", "join", "cont", "top", "dl", "note", "st", "stack", "block", "word", "single", "add", "format", "local", "log", "ml", "part", "member", "set", "def", "all", "ist", "lists", "pool", "pretty", "left", "ls"]}}
{"id1": "22366505", "id2": "8079516", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"incluir": ["inclouar", "incluiator", "inCLuier", "incluar", "incluier", "inclouir", "inclUar", "inclUir", "inclouier", "inCLuator", "inclUator", "incluator", "incluiier", "inCLUier", "incluiar", "inclUier", "inclouator", "inCLUar", "inCLuir", "inCLuar", "inCLUir", "inCLUator", "incluiir"], "igreja": ["igrejas", "igcrej", " iggreji", " igcreJa", "igopenj", " igrejas", " iggreva", "iggreji", " igcrej", "igarrej", "igcreja", "iggrejas", "iggreva", "iggrej", "igvrej", "igvrejas", "iggreja", " iggrejas", "igreji", " igreva", "igarreJa", " igreJa", " igreji", "igarreji", "igreje", "igrej", "igarreva", "igopenja", "igcreji", "igreJa", "igarreja", "iggreJa", "igvreje", "igopenva", " igcreja", "igreva", " iggrej", "igopenji", " igcreji", " iggreja", "igarrejas", " igrej", " iggreje", "igvreja", "igarreje", " igreje", "iggreje", "igcreJa"], "connection": ["n", "to", "which", "link", "conn", "command", "condition", "socket", "generation", "settings", "network", "gate", "operation", "session", "function", "server", " Connection", "computer", "city", "user", "statement", "connected", "system", "database", "directory", "response", "Connection", "c", "document", "open", "language", "collection", "description", "client", "engine", "container", "context", "application", "section", "con", "setup", "position", "established", "manager", "connect", "ion", "resource", "library", "created", "config", "creator", "close", "query", "relation", "management", "component", "db", "reference", "message", "pool", "communication", "instance", "current"], "sql": ["pl", "plan", "csv", "command", "serial", "install", "xml", "pel", "q", "spr", "inv", "statement", "string", "expression", "ql", "seed", "template", "login", "table", "description", "cmd", "form", "sk", "sys", "sv", "dl", "nl", "title", "ln", "sf", "select", "url", "normal", "series", "log", "san", "sd", "SQL", "query", "spec", "sol", "scl", "zip", "lock", "shell", "sq"], "sql2": ["SQL4", "sd02", "sql1", "sql02", "SQL1", " sql1", "SQL2", "SQL3", " sql3", "SQL02", "ql1", "ql3", "sql4", "sql3", "sd2", " sql02", "sd3", "sd4", "ql2", "ql02", " sql4"], "stmt": [" stmm", "estm", "tmt", "STmb", " stmb", "STmn", "tmb", "Stmm", "estmt", "statMT", "stm", "StMT", "statm", "restmm", "statmt", "STm", "tmm", "statmn", "Ststat", "strm", " stmn", "STmm", "strMT", "stmb", " stm", "STMT", "Stmt", "reststat", "strmb", "ststat", "estmb", "stmm", "Stmb", "stmn", "strmt", "stMT", "estMT", " stMT", "Stm", "restmt", "tMT", "STmt", "restm", "Stmn", " ststat"], "stmt2": ["stMT1", "stmem3", "stmp3", "stmt1", " stMT02", "stMT2", "stmptwo", "sttx3", "stmem1", " stmttwo", "Stmem2", "stmp2", " stmp3", "stm1", "stmrtwo", "stmr2", "stm3", " stmtTwo", "stmpTwo", "stmtTwo", "stmem2", "stMT02", " stmt02", "stMTtwo", "sttm3", "StmemTwo", " stmptwo", "stmttwo", "stmr1", "StmtTwo", "stmTwo", "stmp1", "Stmt1", "Stmem1", "Stmem3", " stMT3", "stmt3", "sttm4", "stMTTwo", " stmt1", " stmt3", " stmpTwo", "Stmt2", "stm02", "sttx1", "stmp4", "sttmTwo", "stmt02", "stmemTwo", "stmt4", "stMT4", " stmp2", " stmp1", "stm2", " stmt4", "sttx02", " stMT2", " stMT1", "sttm2", " stmp4", "sttx2", "Stmt3", "stMT3", "stmr4"], "rs": ["ks", "RS", "ris", "js", "ws", "rt", "qs", "ins", "res", "rd", "ss", "hs", "its", "vers", "ows", "ras", "vs", "eps", "usr", "rc", "ms", "rows", "ys", "ars", "cs", "results", "pers", "xs", "rates", "s", "sts", "Rs", "ts", "ats", "fs", "mr", "rss", "rys", "ims", "ps", "r", "bs", "ns", "ds", "gs", "ls", "sr", "ros"], "retorno": ["altano", " retorne", "montorno", "montorne", "eltorno", "montrero", "gotora", "gotorno", "retogo", "eltogo", "gotorne", "eltorn", "retorne", " retano", "gotrero", " retrero", "retora", " retorn", "retano", "altogo", "montora", " retogo", "altorn", " retora", "eltano", "retrero", "altorno", "retorn"]}}
{"id1": "7981642", "id2": "947406", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"update": ["insert", "feed", "updated", "Update", "edit", "create", "data", "change", "test", "post", "store", "alter", "input", "username", "load", "login", "mod", "up", "pack", "replace", "register", "remove", "touch", "commit", "auth", "write", "append", "save", "reply", "init", "upload", "sample", "move", "put", "check", "add", "escape", "handle", "printf", "read", "config", "set", "delete", "place", "apply", "UPDATE", "text"], "mail": ["m", "pl", "ip", "n", "http", "link", "print", "md", "pkg", "Email", "address", "server", "dial", "virtual", "test", "el", "label", "mm", "username", "msg", "im", "name", "hold", "cert", "cmd", "imp", "Mail", "tp", "grid", "dl", "eth", "mem", "dir", "domain", "mount", "old", "alt", "ln", "iter", "enter", "dn", "port", "mun", "com", "url", "mobile", "file", "local", "log", "mill", "del", "id", "host", "dm", "zip", "addr", "message", "net", "gmail", "mails"], "email": ["m", "ip", "n", "link", "phone", "html", "detail", "Email", "address", "server", "xml", "virtual", "test", "el", "label", "date", "entity", "username", "image", "atom", "template", "name", "external", "password", "number", "il", "echo", "cdn", "sql", "nl", "note", "e", "sample", "domain", "example", "ln", "enter", "dn", "ilo", "url", "file", "nm", "log", "del", "object", "host", "zip", "IL", "addr", "message", "ns", "cn", "et", "text", "uri", "line"], "pwd": [" pw", "pword", "dpword", "pow", "pswd", "Pwd", "dpw", "psow", " pword", " pws", "dpgen", "pgen", " pow", "psw", "dpwd", "Pgen", "ppriv", "pw", "presswd", "pws", "pressw", " ppriv", "presspriv", "psfx", "Pfx", "Ppriv", "pfx", "Pw", "pressws", " pgen", "Pword", "Pws", " pfx", "Pow"], "firstname": ["Firstname", "FirstNAME", "firstName", "lastrun", " firstNAME", "smallName", "lastNAME", "Firstnames", " firstnames", " firstName", "Firstparent", "firstrun", "lastnames", " firstrun", "smallNAME", "smallrun", "smallname", "lastparent", "firstparent", " firstparent", "lastName", "firstNAME", "firstnames", "FirstName"], "lastname": [" lastame", "lasttype", "givennum", " lasttype", "longName", "givenname", "firstName", "givenName", "firsttype", "longname", "giventype", "fullame", "longnum", " lastName", "firstame", "lastame", "fullName", "lastnum", "fullname", "lastName", "longame", "firstnum", " lastnum"], "connection": ["entry", "link", "conn", "command", "condition", "network", "session", "city", "connected", "system", "database", "directory", "response", "Connection", "c", "document", "description", "collection", "handler", "client", "engine", "onet", "cone", "nc", "context", "application", "con", "connect", "ion", "resource", "creator", "management", "relation", "event", "pool", "communication"], "attrs": ["avras", " attps", " attries", "actters", "attachras", "attsds", "atrics", "adrs", "attps", "attachrs", "actributes", "atrys", "attsributes", "addrs", "atras", "latributes", "attachRs", "attsps", "latrs", "attributes", "atributes", "latrys", "attrics", "atns", "attsras", "adns", "attsrics", "atries", "attsries", " attRs", "avrics", "addrd", "attachributes", "avributes", "attrd", " attrd", "attras", "actrys", "addRs", " attributes", "attns", "attRs", "addras", "avrs", "attds", "attters", "adras", "atps", "atds", "atrd", "atRs", "attries", "attrys", "atrs", "actrs", " attds", "atters", "addributes", " attras", "latters", "adributes", " attns", "attsrs"], "sha": ["comp", "shared", "ca", "sh", "ppa", "sche", "md", "HA", "shi", "ssh", "alpha", "sum", "has", "h", "SHA", " SHA", "cos", "no", "lambda", "total", "git", "mac", "tar", "da", "asha", "ya", "ha", "ksh", "sa", "wa", "func", "mem", "iso", "sam", "ka", "ma", "go", "acl", "sm", "auto", "mb", "shell", "a", "hi", "sq", "pa"], "digest": ["dests", "mdested", "divhest", "mdEST", "digests", "Digested", "dge", "Digest", " digested", "Digests", " digEST", "divEST", "digge", "Digge", "redests", "DigEST", "mdest", "dighest", "digested", "mdests", "mdhest", "redge", "redest", " digests", "digEST", "Digse", "redested", "Dighest", "divse", "mdse", "dested", "dest", "digse", "divest"], "hash": ["ashes", "sh", "print", "shadow", "bh", "cache", "md", "ash", "html", "key", "sum", "h", "has", "filter", "input", "rh", "total", "mac", "base", "Hash", "password", "ha", "flash", "auth", "dig", "score", "trust", "hex", "check", "search", "format", "handle", "dump", "result", "proof", "message", "tag", "each", "ASH"], "ctx": ["kw", "ca", "conn", "np", "pg", "ctr", "cp", "lc", "pkg", "obj", "Conn", "wx", "dc", " context", "loc", "xc", "jp", "tk", "Context", "cf", "ct", "gm", "conv", "context", "nc", "co", "rc", "cb", "cmp", "con", "mc", "cv", "gc", "mk", " cx", "ctrl", "tx", "kl", "bc", "sc", "ck", "cm", "tmp", "tz", "x", "cu", "tc", "txt", "sq", "nt"], "newName": ["NewName", " newNames", "oldname", "finalNames", " newNAME", " newname", "currentName", "newKey", "currentKey", "finalName", "newNAME", "Newname", " newKey", "finalname", "oldNames", "NewKey", "NewNAME", "newNames", "finalHome", "newname", " newHome", "oldHome", "currentNAME", "currentname", "newHome"], "oldName": ["oldKey", "olderKey", " oldPref", "oldname", "recentOr", "recentname", "smallOr", "prevName", " oldname", "smallName", "newOr", "oldername", "prevPref", " oldKey", "recentName", "oldPref", "newAnd", "olderName", "olderPref", "smallAnd", "smallname", "prevname", "prevKey", "recentAnd", "newname", "oldOr", "oldAnd"]}}
{"id1": "17083703", "id2": "720361", "code1": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"savaRolePerm": ["sDeleteRolePERm", "sDeleteRoleProm", "sDeleteResourcePerms", "sDeleteRolePerms", "sDeleteResourcePerM", "sDeleteRolePerm", "sDeleteRoleProms", "sDeleteRolePERms", "sDeleteResourcePerm", "sDeleteResourceProm", "sDeleteRoleProperm", "sDeleteRolePERperm", "sDeleteResourcePerperm", "sDeleteRolePerM", "sDeleteResourceProperm", "sDeleteRolePERM", "sDeleteResourceProms", "sDeleteResourceProM", "sDeleteRolePerperm", "sDeleteRoleProM"], "roleid": ["roleoid", "relationids", "rooid", "rolepid", " roleoid", "resourceId", "oleoid", "relationid", "resourceids", " roleId", "roleId", "roid", " rolepid", " roleids", "oleid", " rolename", "oleinfo", "olename", "roleinfo", "resourceid", "relationId", "rolename", "roinfo", "roname", "roleids", "relationpid", "resourcepid", " roleinfo"], "role_perm_collect": ["role_priv_collection", "role_compl_ct", "role_perm_draw", "role_priv2collection", "role_per_cont", "role_priv_Collect", "role_perm2collect", "role_per_coll", "role_perm_ct", "role_per_draw", "role_priv2coll", "role_perm_coll", "role_compl_coll", "role_perm_cont", "role_priv_coll", "role_perm_Collect", "role_perm2Collect", "role_permptdraw", "role_priv2collect", "role_perm2collection", "role_priv2Collect", "role_compl_collect", "role_permptcoll", "role_permptcont", "role_permptcollect", "role_perm_collection", "role_priv_collect", "role_perm2coll", "role_per_collect"], "cp": ["CP", "priv", "cd", "pkg", "cop", "lc", "px", "pd", "wp", "proc", "ctx", "Conn", "c", "jp", "cmd", "cf", "ct", "core", "fp", "tp", "rc", "cr", "ch", "cap", "cb", "cmp", "con", "pc", "cs", " CP", "mp", "mk", "vp", "pp", "ctrl", "cod", "cfg", "cm", "ec", "ps", "cc", "cn", "p"], "conn": ["pg", "pkg", "dial", "rel", "Conn", "req", "msg", "c", "jp", "cf", "client", "ont", "bo", "org", "wd", "act", "nc", "mem", "con", "pas", "connect", " con", "t", "local", " cur", "dt", "n", "ca", " ac", "link", "session", "ctx", "open", "cert", "cmd", "fn", "die", "comm", "gn", "j", "cb", "coll", "handle", " cx", "config", "addr", "pool", "p", "nt", "syn", "gate", "yn", "rn", "ann", "resp", "call", " cc", "ct", "enc", "ssl", "ch", "og", "trust", "cur", "mn", "close", "ain", "conf", "db", "on", "out", "ns", "bind", "ctr", "lang", "wp", "obj", "dc", "col", "tp", "connection", "sql", "co", "sync", "mt", "ce", "dn", "gc", "cfg", "g", "ait", "cc", "cn", "conv"], "rs": ["ds", "RS", "ris", " cs", "rt", "rl", "res", "ro", "re", "os", "rc", " rc", " res", "ls", "cs", " ss", "ri", "rm", "s", "Rs", "ts", "mr", "ps", " ra", "ns", " ls", " ps", "sr"], "pstmt": ["pstyms", "pStbl", "pstmk", "Pstmd", "pstcond", "pstatms", "pputmt", "apStbl", "postsql", "prestmn", " pswmb", "pstatemt", "apstbl", "pstdst", "postmn", " pstmd", " pstms", "pstrmg", "pstdbl", "pstatmt", "Pstat\t", "prestlt", " psttr", " pstatmt", "apStmt", "Pstatmd", "pstart\t", "pstmg", "psttr", " pStmt", "pStst", "pstbl", "pestms", "pst\t", "Pstatmk", "PstatMT", "Pstmt", "apStmb", "prestmt", "Pstsql", "postmd", " pStmb", "pctMT", "pstdmb", " prestmn", "postm", "Pstrs", "pstatlt", "Pstatlt", "Pstlt", " pstmb", "pstmsg", " pststat", "pstrmt", "pstmd", "Pstcond", "pstatrs", "pstlt", "pSTtr", "pstatem", "Pstatrs", "pstsql", "pconstmb", "Pstmg", " pstatm", "pstrm", "prestMT", " pstemb", "Pstatmg", "pstatstat", "pconstm", "prestm", " pstatmn", "pswemb", "Pstm", "pstmn", "pstyemb", "pctmt", "pputmk", "postmt", "Pstatmsg", " presttr", "postmsg", "pstremb", "pstymt", "pStm", "apstst", " pstatmd", "pconststat", "Pstmk", "apStst", "pstatst", "pstatecond", "ptrym", "pstymb", "pswmt", "Pstatmt", "pestmt", " pswemb", "pputm", "pctmd", "pstatmb", "pStmt", "pstst", "pstrmn", "apstmb", "Pst\t", " prestMT", "pststat", "pstmb", "Pstatcond", "pstrmb", "pstrmd", " pswmt", "pstatMT", "pStstat", "prest\t", "pstatmk", "pSTmn", "Pstms", "pputcond", "pestMT", " pstmn", "pstat\t", "pstm", "pstatmd", "pswmb", "pstatmsg", " pStm", "Pstatms", "pstrrs", "pstatsql", "pstartm", "pstartlt", "pstatemk", "pstMT", "pstms", "pSTMT", "pputrs", " prestmt", "pstemb", "pstartmt", "presttr", "pstrs", "pstatmn", "ptrymsg", "ptrysql", "pctms", "Pstatm", "pstrms", "pSTmt", "pstatcond", "pstdmt", "Pstatsql", " pstm", "Pstmsg", "PstMT", "pstatmg", "pStmb", "pestm", "pstatm", "pputmg", " pstMT", "pconstmt", "pstattr", "ptrymt", "pswms", " pswms", "pctm", "pstatbl", " pStstat", "apstmt"], "factory": [" foo", "cfictionary", "fictionary", "tade", " fFactory", "fFactory", "tFactory", "FFactory", "cfFactory", " fade", "tactory", "Fictionary", "cfactory", "fade", "Factory", "tacter", "Facter", "cfoo", "Foo", "facter", " facter", " fictionary", "Fade", "foo"], "op": ["o", " dop", "operation", " operate", "ops", " ep", "Operation", "OP", " cop", " opt", "Op", " act", "oe", " ov", " oper", " opp", " pop", " ip", " operator", " OP", "oper", " operational", " ops", " Operation", " Op", "iop", "p", " co"], "role_perm_ir": ["role_proc_et", "role_permrenet", "role_proc_i", "role_permmmi", "role_permobjyr", "role_permobjir", "role_permrenir", "role_perm_i", "role_permrenier", "role_proc_yr", "role_perm_ier", "role_proc_ir", "role_perm_et", "role_permmmyr", "role_priv_IR", "role_priv_iter", "role_permobjoi", "role_permmmoi", "role_perm_IR", "role_proc_ier", "role_perm_yr", "role_proc_iter", "role_permmmir", "role_permobji", "role_perm_iter", "role_proc_oi", "role_priv_i", "role_permreniter", "role_perm_oi", "role_priv_ir"], "rolePerm": ["olePerm", "olePERmission", "roleParp", "rolePersM", "rolePERmission", "rolePERmn", "olePerperm", "oleParperm", "rolePartm", " rolePerM", "rolePermn", "roleperM", " rolePerp", "rolePartperm", "rolePersl", "roleParg", "rolePERm", "rolePM", "rolePartr", "rolePp", "olePERg", "roleElem", "rolePERp", "oleParm", "roleParm", "rolePc", "roleParM", " roleParm", "roleEleM", "rolePerperm", "roleEleg", "rolePERc", " roleParM", "olePerl", "rolePermission", "roleParc", "rolePerg", "roleLikemn", "roleperl", "olePerg", "roleperm", "roleElemn", "roleLikeM", "rolePERperm", "rolePERM", "rolePerc", "olePERl", "rolePerM", " roleParp", "roleLikeg", "rolePersmission", "oleParg", "rolePerl", " rolePerc", "rolePERr", "olePERm", "olePERmn", "rolePersm", "roleParperm", "olePermission", "olePermn", "roleParr", " roleParc", "rolePERg", "olePERM", "rolePERl", "rolePerr", "oleParr", "rolePartg", "olePerM", "rolepermission", "olePerr", "rolePerp", "roleLikem", "rolePm"]}}
{"id1": "5808579", "id2": "8064604", "code1": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["decryptPassword", "encryptedString", "encrollPassword", "decryptedLogin", "encrollPass", "encryptedPassword", "enccryptLogin", "decryptedPassword", "encryptLogin", "encryptString", "encryptedLogin", "decryptString", "encryptPass", "encrollString", "decryptLogin", "decryptPass", "decryptedPass", "encrollLogin", "enccryptString", "enccryptPass", "decryptedString", "enccryptPassword", "encryptedPass"], "loginName": ["LoginName", "LoginType", "loginname", "loginCode", "blogN", "loginTime", "LoginTime", "blogTime", "loginType", "cellname", "Loginname", "loginN", "cellName", "cellType", "blogCode", " loginTime", "cellTime", " loginCode", " loginN", "usernameCode", "usernameTime", "usernameName", " loginname", " loginType", "usernameN", "blogName"], "password": ["Password", "secret", "command", "address", "session", "reset", "user", "paste", "pass", "string", "database", "padding", "username", "expression", "response", "token", "sword", "name", "prefix", "PASS", "description", "attribute", "email", "phrase", "comment", "another", "word", "value", "last", "confirmed", "pattern", "result", "argument", "encrypted", "content", "picture", "hello", "default", "past", "message", "path", "text", "p"], "md5": [" Md2", " Md3", "md2", " md7", "MD3", " md1", "sha2", "md6", " Md53", "sha1", "MD2", " md6", "MD8", "md7", "red3", "md53", "sha5", "MD5", " md2", " md53", "md8", " MD6", "MD53", " MD3", "red2", "md3", "MD6", "MD7", "red8", "MD1", " Md5", " MD5", "red5", " md3", "sha7", " md8", " MD2", "md1"], "ba": ["b", "fa", "ca", "bee", "aka", "CA", "aaa", "oa", "bas", "bd", "ja", "aba", "xa", "aa", "tta", "abc", "bu", "da", "ya", "ha", "bi", "bo", "Ba", "sa", "bre", "ta", "ka", "ada", "va", "ao", "beta", "ga", "sta", "pha", "bb", "bc", "BA", "cca", "a", "ena", "pa"]}}
{"id1": "13207437", "id2": "18164929", "code1": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"sendRequestObjectResponse": [" sendGetObjectresponse", " sendRequestHttpBlock", " sendRequestObjResponse", " sendRequestObjresponse", " sendGetObjectResponse", " sendGetObjBlock", " sendRequestHttpResponse", " sendRequestStringResponse", " sendRequestStringresponse", " sendGetObjresponse", " sendRequestObjBlock", " sendGetObjResponse", " sendRequestObjRes", " sendGetObjRes", " sendGetObjectBlock", " sendRequestHttpRes", " sendRequestObjectRes", " sendRequestObjectresponse", " sendGetObjectRes", " sendRequestHttpresponse", " sendRequestStringBlock", " sendRequestObjectBlock", " sendRequestStringRes"], "servletName": ["servLETNAME", "servletsNames", "servletsInfo", " servletsName", "servterValue", "servletCode", " servlename", " servletInfo", " servletKey", "servlename", "servletNAME", "servLETName", "servLETCode", "servletsName", " servletsKey", "servleKey", "servlerName", "servLETNames", "servleCode", "servterName", " servleInfo", "servlername", "servLETname", "servlerKey", " servleNAME", "servLETKey", "servletInfo", "servlerNames", "servtName", " servletNAME", " servletValue", "servtCode", "servletNames", "servterKey", "servletsValue", "servletname", "servtNAME", "servtname", "servletsKey", " servletsname", " servletname", "servleName", " servleName", "servleInfo", "servleValue", " servletsNames", " servletCode", " servleValue", "servletValue", " servleCode", "servleNAME", "servletKey", " servleKey", "servletsname", "servterInfo", " servletNames"], "request": [" Request", "command", "session", "server", "key", "q", "input", "req", "response", "param", "base", "quest", "json", "reply", "task", "resource", "Request", " req", "result", "argument", " input", "QUEST", "query", "model", "id", "object", "message", "method"], "osRoot": ["OSHome", "osroot", "OSRoot", "sysroot", "sysPath", "sysRoot", " osHome", "osHome", "OSPath", "osPath", "OSroot", " osPath", "sysHome", " osroot"], "fname": ["fullpath", "Fname", "fullversion", "fName", "fpath", " fName", "fullname", "Fpath", "fversion", " fversion", " fpath", "fullName", "FName", "Fversion"], "retobj": ["Retobj", "retobject", "Retobject", " retobject", " retObj", "resultobj", "RetObj", "resultobject", " retjs", "retObj", "resultjs", "Retjs", "retjs", "resultObj"], "myurl": ["meUrl", "mxUrl", "yUrl", " myUrl", "meurl", "mxURL", "myuri", "mosurl", "serveremail", "myUrl", "yll", "serverurl", "myll", "mosURL", "mosUrl", "mysUrl", "myemail", "mysurl", "myURL", "Myuri", "yemail", "mysURL", "meuri", "yurl", " myemail", "serverll", "Myport", "serverUrl", "Myurl", "MyURL", "mxport", " myll", "meURL", "mxurl", "mysuri", "MyUrl", "mosport"], "myport": ["meports", "serverport", "somepport", "typort", " mylimit", "mimobile", "miPORT", " myeport", "minetag", "mysPORT", "mineport", "MyPort", "mypport", "yourpport", "somePORT", "yourport", "yourPort", "mifloat", "mywidth", "memberport", "meport", "mipport", "meparent", "mePORT", "MyPORT", " myort", " myPort", "mysport", "mylength", "meeport", "tyfloat", " mylength", "memberpport", "myfloat", "someport", "memberPORT", "minefloat", "myparent", "Mypport", "serverPORT", "myeport", "milimit", "tyPort", " mytag", "miports", " myfloat", "somePort", "memberPort", "mewidth", "miwidth", "mepport", "yourfloat", "mytag", " myparent", "myslimit", "Myport", "serverPort", "mysPort", "miparent", "myPort", "miport", "mieport", "mymobile", "serverlength", "miPort", "minePORT", "mylimit", "myPORT", "yourort", "myort", "yourPORT", " myPORT", "tyort", " myports", "mitag", "memobile", " mywidth", " mymobile", " mypport", "myports", "Mylength"], "codebase": [" codebas", "tebased", "codebas", "Codebasic", " codebasic", "codebasic", "coebase", "coebuffer", "coeb", "Codebased", "xybasic", "cheBase", "chebas", "codebuffer", "Codebase", "codeBase", "codb", "CodeBase", "Codebuffer", "codBase", "tebas", "codeb", "teBase", "chebased", "Codeb", "xybase", "codebased", " codeBase", "xybased", "codbuffer", "coeBase", "xyBase", " codebased", "chebase", "tebase", "codbase"], "serverURL": ["serURL", "serverURI", "serurl", "erverUrl", "serviceEL", "serviceURL", "erverRL", "serverHTML", "erverurl", " serverURI", "serverOUT", " serverFILE", "consoleALL", " serverEL", "serverEL", "verFILE", "clientUrl", "ServerURL", "Serverurl", "serviceUrl", "verURL", "erverURL", "erverOUT", "serHTML", "ServerUrl", "serverurl", "erverER", "serALL", " serverRL", " serverOUT", "erverHTML", "clientURL", "consoleURI", " serverER", "consoleURL", "serviceALL", "ServerURI", "verurl", "verER", "ServerEL", "erverEL", "serverER", "serverALL", "serverRL", "serUrl", "serviceurl", "ServerUR", " serverUrl", "clientALL", "erverALL", "serviceRL", "serverUR", "erverUR", "serverUrl", " serverurl", "serverFILE", "erverURI", " serverUR", "erverFILE", "clientUR", "consoleOUT", " serverHTML", " serverALL", "serUR"], "ipdig": [" ipd", " ipplug", "hipbd", " ipmd", "hipcd", "hexDig", "ipd", " ipder", "hipDig", "hexmd", " ipcd", " sipdig", "ippbd", "ipDig", "ippd", " ipbd", "ipder", "hexdig", "ipbd", "hipdel", "ipmd", "ippdig", "ipdel", "icplug", "hipdig", "icdel", "hipd", "ippDig", "hexder", " sipcd", " ipdel", "ipplug", "hipplug", "iccd", "ippcd", "ipcd", " ipDig", "ippmd", "ippder", "icdig", " sipDig", " sipd"], "url": ["browser", "http", "conn", "web", "l", "ll", "rl", " URL", "el", "deb", "open", "uf", "www", "str", "il", "ul", "row", "ssl", "org", "dl", "ocl", "nl", "ur", "mount", "https", "URL", "au", "gl", "impl", "gc", "loader", "log", "Url", "sl", "r", "util", "ob", "ls", "uri", "uu"], "urlconn": ["lcert", "webcon", "webcert", "webann", "Urlcon", " urlcon", "webconn", "browsercert", " urljs", "Urljs", "Urlann", "webConn", "browsercon", "lconn", "urljs", "httpconn", " urlConn", "urlann", "UrlConn", "urlConn", "urlcert", "Urlconn", "urlcon", "httpConn", " urlann", "lConn", "browserconn", "browserConn", "httpjs", "httpcon", "lcon"]}}
{"id1": "8973505", "id2": "14773780", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "label": 0, "substitutes": {"writeFileType": ["readFileType", "writefiletype", "writefileName", "writeContentType", "writePageName", "writePagetype", "writeFileInfo", "writeContentInfo", "readFileInfo", "readfileInfo", "writeContenttype", "writefileType", "writeFiletype", "readfileType", "writeFileName", "readFiletype", "writePageType", "readfiletype", "writePageInfo", "readfileName", "readFileName", "writeContentName", "writefileInfo"], "uriFile": ["iriFile", "irifile", "urifile", "fileFiles", "rangeFILE", "uriFiles", "URIData", "rangeFile", "URIFilename", "fileFilename", "uriData", "rangefile", "filenamefile", "filenameFiles", "filenameFilename", "URIfile", "rangeData", "iriFILE", "URIFILE", "uriFilename", "URIFiles", "uriFILE", "filefile", "URIFile", "fileFile", "iriData", "filenameFile"], "outputfile": ["Outputport", " outputf", "inputFILE", "outputbase", "imageFILE", "outputport", "outputf", " outputFile", "inputport", "outfile", "inputf", "inputbase", "outbase", "inputFile", "inputfile", "outputFILE", "OutputFILE", "imagefile", "outf", "OutputFile", "imageFile", " outputbase", "imageport", "outFile", "outputFile", "Outputfile"], "num": ["m", "multi", "n", "zero", "mon", "np", "nam", "no", "index", "total", "NUM", "alph", "random", "end", "nom", "number", "count", "um", "Number", "x", "cmp", "con", "required", "check", "add", "nm", "max", "all", "Num", "nb", "done", "mult", "current"], "writer": ["timer", "record", "data", "function", "test", "wright", "term", "editor", "Writer", "external", "client", "layer", "commit", "writ", "riter", "manager", "w", "written", "file", "driver", "RW", "will", "loader", "variable", "to", "link", "network", "inner", "writing", "flush", "memory", "thus", "maker", "builder", "worker", "runner", "utils", "liner", "stream", "resource", "read", "console", "usher", "player", "buffer", "entry", "linger", "server", "Reader", "ener", "journal", "ender", "document", "handler", "author", "director", "width", "write", "owner", "iterator", "format", "service", "widget", "storage", "wire", "operator", "ner", "processor", "window", "table", "wrapper", "connection", "caster", "comment", "writers", "er", "creator", "event"], "uri": ["browser", "wiki", "ip", "ei", "iri", "verb", "user", "location", "ir", "basic", "pi", "du", "qu", "https", "file", "range", "mi", "reference", "channel", "i", "hi", "source", "link", "address", "inner", "folder", "prefix", "description", "ref", "ur", "copy", "URI", "resource", "result", "ni", "id", "umi", "bid", "general", "ui", " URI", "href", "filename", "image", "queue", "subject", "sofar", "phrase", "origin", "iterator", "remote", "http", "multi", "chain", "phi", "uni", "ugi", "via", "directory", "username", "details", "form", "uno", "uid", "connection", "unit", "hyper", "domain", "ource", "ri", "doi", "rid", "query", "obo", "qi", "uu"], "counter": ["browser", "entry", "timer", "continue", "walker", "time", "ier", "pointer", "book", "ctr", "TER", "amount", "inner", "key", "memory", "controller", "meter", "processor", "index", "total", "system", "loop", "term", "cms", "editor", "Counter", "ounter", "sequence", "random", "card", "mer", "currency", "clock", "number", "container", "outer", "frequency", "count", "conv", "context", "common", "ter", "phrase", "scope", "machine", "finder", "nr", "manager", "another", "cookie", "iterator", "coll", "money", "loader", "norm", "mr", "creator", "const", "mill", "cover", "order", "message", "buffer", "instance"], "reader": ["entry", "timer", "rl", "address", "inner", "Reader", "server", "ner", "input", "ro", "parser", "rar", "processor", "journal", "editor", "upper", "older", "rx", "document", "builder", "handler", "dd", "layer", "row", "context", "runner", "liner", "iter", "roller", "er", "resource", "iterator", "driver", "yer", "file", "loader", "redo", "read", "r", "player", "method", "buffer"], "url": ["browser", "http", "link", "web", "l", "ll", "address", "rel", "re", "location", "hl", "base", "name", "loc", "open", "li", "google", "char", "www", "client", "str", "il", "mail", "ssl", "dl", "ref", "build", "ur", "nl", "bel", "mount", "https", "URL", "resource", "gl", "Url", "sl", "github", "get", "r"], "myConnection": [" myConnect", " myConnector", "newLink", "thisConnect", "yourLink", "newConnect", " myLink", " myconnection", "thisLink", "myLink", "Myconnection", "myConnector", "myConn", "thisConnection", "yourconnection", "yourConnection", "MyConnector", "myConnect", "newConnection", " myConn", "MyConnection", "myconnection", "MyLink", "newConn", "yourConnector", "thisConn"], "myReader": ["mxFr", "yWriter", "MyRead", "myRead", "ySer", "yourReader", "yFr", " myFr", " myWriter", "mxReader", "MyWriter", "yourWriter", "mySer", "myParser", "myFr", " myParser", "myWriter", "yourParser", " myRead", "MyReader", "yReader", " mySer", "mxSer", "yourRead", "MyParser", "mxWriter"], "line": ["entry", "ip", "rule", "raw", "link", "code", "l", "detail", "lin", "eline", "edge", "body", " LINE", "no", "label", "user", "one", "lo", " Line", "stroke", "sequence", "trace", "email", "definition", "char", "side", "style", "inline", "cell", "Line", "ine", "row", "online", "ge", "sample", "liner", "comment", "ln", "block", "word", "iter", "cli", "le", "normal", "LINE", "lane", "range", "log", "part", "ole", "point", "ode", "message", "page", "channel", "frame", "text"], "linecount": ["linecounter", " lineconfig", "linamount", " linefound", "Linecount", " lineamount", "elinecounter", "linelength", "lincount", "lineconfig", "strokeconsider", "linerconfig", "linerfound", "elinecount", "linerCount", "inlineconst", "linnumber", "inlinecount", "Linefound", "strokenumber", "Lineconfig", "linefound", "lineconst", "elineconst", " lineconsider", "inlinelength", " linenumber", " lineconst", "strokecount", "linconsider", "inlinecounter", "LineCount", "elinelength", " linelength", "linenumber", "lineamount", " linecounter", "strokeamount", " lineCount", "lineCount", "lineconsider", "linercount"], "hasOWL": [" hasOWNL", "hasOWNLP", "hasOWLP", "hasOWSNL", " hasOWSL", "hasRONL", " hasEWLS", "hasEWLP", "hasOWSLP", "hasSOL", "hasOHL", "hasEWR", "HasOWS", "HasOWLP", "hasSOLP", "hasOHB", "hasEWL", " hasEWLP", "HasOWL", "hasSOLS", "hasOWNR", "hasOWB", "HasOWSB", "HasOWB", "hasOWSR", "hasOWLS", " hasOWSR", "hasOWSL", "hasEWLS", "hasOHS", "hasOWR", "hasROL", "hasOWNNL", " hasOWR", "hasEWB", " hasOWLS", " hasOWSLP", "hasOWSLS", "hasOWSB", "HasOWSLP", " hasOWSNL", "HasOWSS", "hasROR", "hasOWNL", "hasOWS", "hasROLP", "hasEWS", "hasSOR", " hasEWL", "hasOWSS", "HasOWSL", " hasOWLP", " hasEWR", "hasOHLP"], "hasRDFS": ["hasRMLS", "hasRDSs", "hasSRDSS", "hasORDSDS", "hasSRDSB", "hasSRDFS", "hasORDFDS", "hasSRDSs", "hasRRIS", "hasRDFB", "hasRdfB", "hasXDFs", "hasORDFs", "hasRRIB", "hasRDSB", "hasORDFM", "hasXDFDS", "hasRNFS", "hasSRDSCS", "hasRDSCS", "hasRNFs", "hasXDSDS", "hasRDSDS", "hasRDFM", "hasRNFM", "hasORDFS", "hasRdfS", "hasRMLs", "hasSRDFCS", "hasRDFCS", "hasXDSS", "hasORDSs", "hasRRIs", "hasRdfM", "hasORDSS", "hasRdfDS", "hasRMLDS", "hasXDFS", "hasRDFs", "hasRDSM", "hasSRDFs", "hasRRICS", "hasSRDFB", "hasRNFDS", "hasXDSM", "hasRdfs", "hasRDFDS", "hasRdfCS", "hasORDSM", "hasRMLM", "hasXDFM", "hasXDSs", "hasRDSS"], "hasRDF": [" hasRRNF", "hasRRDS", "hsRRDF", "hsRDT", "hasRDR", "hasRTDR", "hasRdf", "hasORDR", "hasREDS", "hasRCDF", " hasDCD", "hasORNF", "hasRDI", "hasDdf", "hasRADF", "hasRRDT", "hsRDF", " hasRRDS", "hsRDS", "hsRRDS", "hasRRdf", " hasDDF", "hasRRNF", " hasRNF", "hsRRDT", "hsRDI", "hasRRDR", "hasRCCD", "hasRCD", "hasRRDI", "hasRADI", "hasREDI", "hasDDF", "hasDNF", " hasDNF", "hasRTDF", "hasDCD", "hasRTDS", "hasRADT", "hasREDT", "hasRCdf", " hasRCD", "hasORDS", "hasRTNF", " hasRDS", "hasRADS", "hasRDT", "hasRRCD", "hasRRDF", " hasRDR", "hasREDF", "hasORDF", "hsRRDI", "hasRNF", "hasRCNF", "hasRDS", " hasRRDF", " hasDdf", " hasRdf", " hasRRDR"]}}
{"id1": "20855053", "id2": "10212189", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"init": [" Init", "launch", "Init", " login", " abort", "execute", "initialized", " authorize", "register", " service", " dispatch", "activate", " reset", " bind", " initialization", " refresh", " deploy", "construct", " initiation", "start", " restart", "config", "run", " initiate", " prepare", "action", " construct", " initialized"], "context": ["null", "web", "ex", "h", "chain", "ctx", "res", "self", "state", "c", "exc", "Context", "application", " contexts", "w", "config", "tx", "sc", "bc", "component", "event", "X", "this", "x", "txt"], "classLoader": ["urlloader", "classParser", " classBuilder", "classReader", "classManager", "taskBuilder", "taskElf", " classReader", "ClassPath", "fileParser", "classElf", "urlReader", "ClassLess", "urlLoader", "fileLoader", " classloader", "fileManager", "classBuilder", " classPath", "ClassReader", "fileReader", "ClassParser", " classManager", "urlPath", " classLess", "classloader", "taskLoader", "classLess", "ClassManager", "ClassBuilder", "ClassElf", " classParser", "ClassLoader", "classPath", "taskLess", " classElf", "Classloader"], "urls": [" urlms", "limgs", "urlms", "norms", "longports", "longies", "lps", "lls", "slies", "normports", "urxs", "urllets", "urs", "urlports", "lxs", "normists", "URLs", "urlls", "limms", "limlets", "limls", "ls", "limxs", "urlps", "sls", " urllets", "limps", "slists", "urlxs", "urps", " urlgs", "URLgs", "lims", "urlies", "slports", "normies", "longists", "URLlets", "URLms", "urlgs", "urlists", "longs"], "url": ["browser", "http", "entry", "b", "link", "web", "l", "ll", "rl", "address", "rel", "el", "res", "user", "re", "location", "req", "base", "name", "loc", "li", "email", "char", "f", "str", "ul", "mail", "row", "ssl", "org", "dl", "ref", "ret", "ur", "nl", "bel", "mount", "URL", "resource", "file", "log", "Url", "job", "sl", "r", "lr", "path", "page", "util", "channel", "ob", "ls", "uri", "uu"], "reader": ["iper", "entry", "rl", "inner", "Reader", "ro", "input", "reading", "parser", "rar", "ner", "rot", "older", "rx", "handler", "writer", "rer", "dd", "layer", "row", "runner", "iter", "roller", "er", "peer", " Reader", "stream", "iterator", "resource", "driver", "file", "range", "loader", "rr", "read", "per", "r", "buffer"], "className": ["classRel", " classToken", "titleNot", "cellRel", " classNames", "ClassName", "cellToken", "classString", "ClassPath", "stringType", "moduleName", "CLASSFull", "cellString", "packageName", "titleLine", "logname", "packageData", "moduleType", "classNAME", " classBody", "ClassRel", "classNames", " classTitle", "clNo", "moduleStart", "ClassData", "classLine", "partName", " classType", " classValue", "stringName", "partname", "completeRel", " classNAME", " classString", " classLine", "clPath", " classPath", "clBody", "packagePath", "stringStart", " ClassName", "moduleString", "Classname", "classNot", " classData", "titleString", "playName", "packagename", "stringString", "playString", "ClassNot", " classRel", " ClassFull", " classFull", "logValue", "classTitle", " classNo", "classData", "CLASSTitle", "playBody", "clName", "classBody", "classNo", "classFull", "playNo", "clString", "ClassToken", "completePath", "CLASSNames", "partNAME", "classToken", "classValue", "logName", "classType", " classname", "partValue", " classNot", "logNAME", "ClassLine", " ClassNames", " ClassTitle", "titleName", "CLASSName", " classStart", "ClassString", "cellName", "classname", "clRel", "completeName", "classStart", "classPath"], "clazz": ["glaz", "clclass", "classclass", "classazz", "lass", "glazz", "gluster", "shade", "clade", "glclass", "claz", "class", "glace", "shazz", "shuster", " clade", "glade", "shace", " cluster", "cluster", "classaz", "clace", "classass", "laz", "lclass", "glass", " clace", "lazz"]}}
{"id1": "10728243", "id2": "7761195", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"scramble411": ["scramlePassword", "scrambledPassword", "scrambleBasic", "scamblespassword", "scamblepassword", "scrambled ", "scramle ", "scramble ", "scrambledpassword", "scramblePassword", "scramleBasic", "scrambles ", "scramblesPassword", "scramblespassword", "scramblesBasic", "scrambledBasic", "scambleBasic", "scamblesPassword", "scambles ", "scamblesBasic", "scamble ", "scramlepassword", "scamblePassword", "scramblepassword"], "password": ["Password", "shadow", "secret", "words", "data", "key", "address", "reset", "hash", "user", "pass", "string", "padding", "database", "username", "token", "sword", "prefix", "description", "attribute", "email", "wd", "phrase", "auth", "remember", "word", "crypt", "primary", "profile", "pattern", "hello", "message", "text"], "seed": ["derived", "entry", "shadow", "feed", "secret", "create", "key", "reset", "test", "hash", "sex", "ser", "index", "padding", "prime", " seeds", "template", "needs", "rand", "sequence", "random", "eder", "mix", "df", "offset", "sql", "Salt", "phrase", "sample", "example", "setup", "vector", "sudo", "se", "start", "initial", "eed", " seeded", "source"], "md": ["d", "m", "multi", "amd", "mg", "ad", "cd", "ld", "pt", "mand", "pkg", "bd", "ann", "pd", "hd", "grad", "MD", "desc", "mm", "det", "rd", "od", "ind", "dr", "pm", "msg", "med", "exec", "mod", "rpm", "cmd", "dd", "ct", "red", "der", "df", "img", "gm", "pdf", "ms", "nd", "dig", "dh", "td", "mc", "mt", "ma", "mn", "metadata", "managed", "rm", "mp", "mind", "mk", "sm", "sd", "def", "dm", "cm", "di", "esm", "mb", "de", "addr", "sha", "nt"], "passwordHashStage1": ["passwordhashstage2", "passwordhashStageOne", "passwordHashPage2", "passwordHashPage5", "passwordhashstageOne", "passwordHashstage0", "passwordHashStageOne", "passwordHashSHA01", "passwordHashStage01", "passwordhashstage1", "passwordhashStage0", "passwordHashPhase2", "passwordHashstage5", "passwordhashstage0", "passwordhashStage2", "passwordHashStage5", "passwordHashPage0", "passwordHashSHA0", "passwordHashstage01", "passwordHashPage1", "passwordHashStage0", "passwordHashstage1", "passwordHashSHA2", "passwordHashPhase0", "passwordHashstageOne", "passwordHashstage2", "passwordhashStage1", "passwordHashSHA1", "passwordHashPhase1", "passwordHashPhaseOne"], "passwordHashStage2": ["passwordHashScene2", "passwordSaltStageTwo", "passwordHashScene62", "passwordHashStage4", "passwordHashStage62", "passwordHashStage3", "passwordSaltStage3", "passwordHashScene3", "passwordHashStyleTwo", "passwordHashstageTwo", "passwordHashPhase2", "passwordHashStyle62", "passwordHashVersion4", "passwordHashStageTwo", "passwordHashSceneTwo", "passwordSaltStage62", "passwordHashstage4", "passwordHashVersionTwo", "passwordHashPhaseTwo", "passwordSaltStage2", "passwordHashstage1", "passwordHashPhase4", "passwordHashstage2", "passwordHashVersion1", "passwordHashPhase1", "passwordHashStyle3", "passwordHashStyle2", "passwordHashVersion2"], "toBeXord": ["toBeXorg", "tobeYord", "toBeZXor", "tobeYold", "toBeZor", "toBeXLords", "toBEXorg", "toBeZorg", "toBeYord", "toBeXor", "toBEXords", "toBeXLod", "toBEXor", "tobeYords", "toBeTxond", "toBexords", "toBeTxords", "tobeXord", "toBeXords", "toBeYold", "toBeTxorg", "tobeXords", "tobeYor", "toBeZXold", "tobeXor", "toBeXLord", "toBexorg", "toBeYor", "toBeXod", "tobeXold", "toBeYod", "toBeZXords", "toBeXLor", "toBeYorg", "toBexor", "toBEXod", "toBexond", "toBeXond", "toBeZord", "toBeZXord", "toBexord", "toBeTxord", "toBeXold", "toBEXond", "tobeXorg", "toBEXord", "tobeYorg", "toBeYords", "toBeZords"], "numToXor": ["numtoYOR", "num2Restore", "num2XOR", "numToxord", "numToRestors", "numToZore", "num2RestOR", "num2Restor", "numToYor", "numToZor", "num2Xore", "numToXOR", "numtoYors", "numtoYor", "numtoXord", "numToYord", "numToZord", "numToxOR", "numToxors", "numtoYord", "numToRestOR", "numToxore", "numToZOR", "numToRestor", "numtoXor", "numToYOR", "num2Xor", "numtoXOR", "numToXord", "numToXore", "num2Xors", "numToYors", "numToRestore", "numToZors", "numToXors", "num2Restors", "numtoXors", "numToxor"], "i": ["m", "multi", "ip", "n", "ci", "ui", "batch", "o", "in", "it", "ex", "ji", "ei", "gi", "span", "I", "k", "phi", "us", "ind", "im", "\u0438", "y", "sequence", "ini", "li", "is", "io", "ii", "fi", "ie", "bi", "pi", "u", "j", "ms", "e", "init", "info", "cli", "zi", "ri", "ai", "sim", "t", "z", "s", "mi", "ti", "ix", "ni", "set", "g", "di", "ic", "x", "si", "xi", "qi", "uri"]}}
{"id1": "9796161", "id2": "8320469", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getmd2", "getSHA7", "toSHA2", "toSHA7", "getmd4", "getSHA4", "getMD2", "getmd5", "getMD4", "getMD7", "toMD2", "toMD4", "getSHA5", "getmd7", "toSHA5", "toMD7", "getSHA2", "toSHA4", "toMD5"], "s": ["b", "n", "v", "strings", "l", "js", "ws", "space", "data", "h", "ins", "aws", "string", "rs", "gets", "c", "os", "y", "S", "is", "ss", "its", "f", "ends", "str", "abs", "sv", "sql", "src", "ms", "ls", "bytes", "xs", "t", "sts", "ts", "es", "ats", "ses", "fs", " gets", "g", "sb", "ps", "ies", "bs", "i", "ns", "gs", "text", "sq", "p", "source"], "m": ["man", "v", "l", "md", "h", "perm", "mm", "mu", "pm", "mac", "M", "y", "rem", "mod", "tm", "gm", "mut", "ms", "fm", "me", "e", "em", "mc", "mt", "manager", "managed", "am", "rm", "mask", "mk", "sm", "nm", "om", "mr", "mi", "vm", "hm", "bm", "cm", "dm", "g", "mo", "made"]}}
{"id1": "8132219", "id2": "13891080", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", "copyfile", "copyFiles", "copyStream", " CopyFiles", " copyStream", "CopyStream", " CopyStream", "Copyfile", "CopyFile", " CopyFile", " Copyfile", " copyfile"], "inFile": ["dinFile", "ninName", " inEmail", "ninFilename", "inputFile", "innRow", "ninFile", "outFilename", "dinEmail", "dinPath", "outName", "inPath", " inRow", "innEmail", "innFile", "dinRow", "inputTemplate", "inputName", "inEmail", "inTemplate", "inputFilename", "inRow", "innPath", "inFilename", "outTemplate", "ninTemplate", "inName", " inPath"], "outFile": ["inTable", "ouFILE", "outFormat", "outfile", "ouFilename", "destFile", "ouFile", "outTable", "outputTable", " outFormat", " outFILE", "outputFilename", "outFilename", "destFormat", "inFILE", "ouTable", "outputFILE", "outputfile", "outputFormat", " outfile", "destFILE", "outFILE", "inFilename", "outputFile", "destfile"], "in": ["inf", "o", "IN", "inc", "it", "inner", "cin", "ins", "el", "input", "ind", "rin", "ir", "bin", "up", "In", "ini", "is", "ze", "isin", "init", "old", "info", "irm", "ai", "gin", "from", "s", " input", "id", "en", "ain", "inn", "sin", "on", "ic", "i", "din", " din", "source"], "out": ["o", "b", "n", "to", "v", "it", "ex", "res", "OUT", "at", "one", "c", "os", "name", "Out", "ou", "io", "aos", "client", "by", "co", "e", "ot", "w", "t", "file", "gt", "can", "all", "en", "g", "output", "outs", "net", "ne", "p"], "inChannel": ["cinBlock", "cinComponent", "inHandler", " inConnection", " inchannel", "inComponent", "newCategory", "insideHandler", "vinCategory", "inPanel", "inchannel", "cinHandler", "outBlock", "inBlock", "inCase", "sinChannel", "insideChannel", "inConnection", "innerChannel", "inStream", "inChan", "ginPanel", "isinCategory", " inHandler", "newChannel", "outChan", "inCategory", "ginCase", "vinPanel", "sinStream", "outConnection", "innCase", "outchannel", "inButton", "cinChannel", "sinBlock", "vinCase", " inChan", "sinCategory", "innerchannel", "inSlot", "newPanel", "newCase", "innSlot", "sinSlot", "outColumn", "insideComponent", "innerConnection", "sinCase", "cinColumn", "inColumn", "isinCase", "cinStream", "isinSlot", " inComponent", "innerChan", "vinChannel", "outStream", "sinColumn", " inButton", "ginChannel", "innChannel", "cinButton", "ginCategory", "isinChannel", "insideButton", "innCategory"], "outChannel": [" outCh", "oChan", " outPassword", "exBlock", "inchannel", "outPassword", "outBlock", "exChan", " outConnection", "outChain", "inStream", "inChan", "oChannel", "outCh", "outChan", " outClient", "outConnection", "exChannel", " outChain", "outchannel", "OutConnection", "nChannel", " outchannel", "outputChannel", " outBlock", "OutChan", "outputConnection", "inPassword", " outChan", "nStream", "outClient", "OutChannel", "OutCh", "inClient", "exChain", "outStream", "outputChan", "outputCh", "oClient", "oPassword", "nchannel", "nChan", " outStream"]}}
{"id1": "2521141", "id2": "16825994", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"copy": ["insert", "link", "cp", "edit", "create", "cop", "download", "paste", "Copy", "clip", "transfer", "ate", "load", "io", "replace", "remove", "export", "cut", "write", "save", "upload", "move", "clone", "sync", "file", "crop", "close", "set", "opy", "get", "zip", "delete", "slice", "drop", "share", "archive", "select", "source"], "from_name": ["fromkcase", " from_info", "from_names", "fromkname", " from_case", " from_no", " from_Name", "fromamefilename", "fromkpart", " from_key", " from_filename", "fromameName", "from_part", " from_names", "from_resource", " from_part", "fromamekey", "fromkName", "fromamename", "from_filename", "from_case", " from_resource", "from_info", "from_no", "from_Name", "from_key"], "to_name": ["eto_word", "from_new", "to_number", "toNamename", "toNamefile", "tolyname", "tolyfile", "from_get", "to7file", "tolynumber", " to_nm", "to_nm", "to_Name", "toNamenew", "eto_Name", "to_word", "to7get", "to_get", "toNameget", "to7new", "tolynm", " to_number", "eto_name", "to_new", "to7name"], "from_file": ["fromlyfile", "to_dir", "fromsname", "fromsfile", "or_File", "fromlyresource", "from_dir", " from_type", "or_name", "fromsdir", " from_port", "or_run", " from_File", "from_resource", " from_do", "fromlyFile", "from_do", "from_port", "fromlynode", "or_file", "from_File", "from_time", "from_run", " from_resource", "from_node", "from_type", " from_node", " from_time"], "to_file": ["to_dir", "TO_FILE", "to_drop", "toJfile", " to_drop", "to_block", "to_base", "to_run", "to_link", "to_File", "to_type", " to_block", "toJFile", "from_dir", "TO_port", "to_port", "TO_files", " to_dir", " to_base", " to_create", "TO_name", " to_File", " to_local", "to_tree", "to_create", "that_link", "toJblock", "to_local", "that_tree", "to_element", "TO_element", "from_type", "TO_file", "that_File", " to_run", "toJdrop", "that_file", "to_files", "to_FILE"], "parent": ["man", "tree", "ip", "rule", "null", "prop", "chain", "server", "test", "pid", "root", "desc", "pa", "folder", "p", "child", "directory", "user", "pixel", "timeout", "remote", "holder", "base", "name", "parents", "shape", "relative", "up", "prefix", "tar", "form", "client", "global", "top", "unit", "percent", "sp", "owner", "comment", "cmp", "where", "position", "peer", "ma", "port", "block", "par", "file", "mother", "paren", "master", "home", "part", "id", "point", "def", "params", "spec", "event", "default", "per", "path", "pool", "temp", "Parent", "family", "my", "page", "instance", "source"], "dir": ["d", "dim", "md", "cd", "tr", "dict", "rel", "folder", "dist", "det", "directory", "DIR", "dr", "ind", "self", "rec", "ir", "cond", "mod", "loc", "cmd", "dd", "red", "str", "cont", "wd", "vol", "sp", "init", "module", "div", "iter", "cur", "coll", "file", "local", "dep", "fd", "del", "part", "def", "good", "di", "db", "addr", "path", "Dir"], "from": ["entry", "pos", "link", "in", "back", "inner", "reset", "user", "store", "no", "window", "re", "term", "base", "error", "io", "form", "client", "by", "style", "From", "func", "vol", "so", "init", "st", "old", "and", "con", "with", "check", "fun", "normal", "com", "file", "before", "stream", "se", "local", "start", "false", "ent", "query", "set", "en", "fr", "bound", "empty", "on", "left", "ra", "out", "or", "ie", "orig", "source"], "to": ["o", "b", "To", "toc", "null", "tto", "tty", "target", "no", "total", "that", "token", "base", "table", "client", "by", "please", "top", "pi", "into", "sys", "so", "e", "ta", "co", "too", "must", "ma", "go", "t", "eto", "te", "ts", "will", "auto", "tt", "can", "ato", "op", "output", "po", "on", "stable", "pretty", "two", "out", "or", "ne", "TO", "nt"], "buffer": ["entry", "batch", "cache", "command", "Buffer", "function", "memory", "paste", "window", "database", "available", "template", "base", "stroke", "table", "sequence", "button", "document", "bar", "attribute", "password", "char", "buf", "queue", "row", "phrase", "sample", "buff", "append", "stack", "iter", "block", "word", "variable", "binary", "event", "message", "temp", "page", "frame", "character"], "bytes_read": ["bytesynclen", "Bytes_run", " bytes_write", "bytesyncwrite", "bytes2Read", " bytes2Read", "bytes_range", "bytesyncreport", "words_report", "wordsynclen", "bytes_write", " bytes_range", " bytes2write", "bytes_len", "bytes2read", "bytes_report", " bytes_Read", "wordsyncread", "bytes__Read", " bytes2read", "bytes__read", "words_len", "wordsyncwrite", " bytes2range", "wordsyncreport", "bytesyncread", "words_read", "bytes__range", "words_write", "bytes__write", "Bytes_read", "bytes2write", "Bytes_write", "bytes2range", "bytes_Read", "bytes_run"]}}
{"id1": "18989018", "id2": "13333160", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 0, "substitutes": {"doSetInput": ["doGetOutput", " doGetOutput", "doSetinput", " doGetInput", "doGetinput", "dosetData", "doGetData", "dosetOutput", " doSetOutput", "dosetInput", "doHandleOutput", " doSetData", "doHandleinput", " doGetinput", " doGetData", " doSetinput", "doSetOutput", "doSetData", "doGetInput", "doHandleInput", "doHandleData", "dosetinput"], "input": ["ip", "att", "print", "it", "key", "unknown", "Input", "client", "wa", "act", "init", "upload", "support", "local", "present", "ix", "get", "focus", "select", "raw", "al", "what", "plugin", "up", " Input", "attribute", "cmd", "password", "version", "config", "content", "supp", "output", "p", "entry", "command", "xml", "doc", "image", "cont", "arg", "um", "context", "qa", "ch", "note", "active", "request", "info", "from", "argument", "def", "initial", "conf", "history", "submit", "edit", "via", "accept", "table", "field", "error", "form", "text", "primary", "add", "ion", "ia", "pattern", "query", "op", "this", "control", "instance"], "monitor": ["man", "m", "report", "summary", "timer", "mon", "Monitor", "inner", "meter", "processor", "system", "window", "process", "timeout", "state", "rain", "im", " Monitor", "hist", "handler", "program", "stat", "sam", "runner", "manager", "mx", "mi", "log", "wm", "mr", "progress", "watch", "console", "dm", "cm", "message", "pool", "display", "history"], "root": ["m", "null", "project", "RO", "pkg", "node", "h", "roots", "server", "target", "res", "store", "ro", "system", "p", "directory", "room", "oots", "folder", "window", "base", "prefix", "localhost", "container", "sys", "top", "parent", "context", "scope", "ms", "owner", " Root", "box", "mount", "oot", "manager", "resource", "local", "home", "mr", "Root", "storage", "host", "r", "util", "tree"], "format": ["parse", "feed", "Format", "struct", "policy", "xml", "filter", "filename", "tif", "MAT", "former", "term", "fill", "process", "at", "template", "transform", "base", "mod", "layout", "actor", "type", "cf", "attribute", "form", "feature", "ct", "f", "api", "class", "fc", "unit", "act", "fm", "module", "title", "version", "supported", "metadata", "feat", "service", "pattern", "map", "config", "set", "spec", "tool", "util"], "source": ["cache", "null", "data", "string", "state", "is", "src", "proxy", "local", "shell", "ne", "i", "report", "raw", "inner", "address", "session", "store", "index", "ser", "template", "base", "sequence", "language", "license", "style", "sample", "copy", "Source", "resource", "handle", "console", "find", "spec", "object", "output", "buffer", "SOURCE", "body", "filename", "image", "context", "note", "sp", "origin", "port", "iterator", "from", "service", "reason", "remote", "out", "parent", "secret", "site", "target", "table", "wrapper", "details", "trace", "scan", "scope", "ource", "size", "se", "relation", "view", "this", "display", "dest", "join"], "in": ["null", "thin", "it", "pin", "data", "reset", "ins", "bin", "ini", "is", "io", "src", "init", "serv", "con", "iter", "win", "gin", "local", "include", "mi", "as", "get", "i", "raw", "inner", "cin", "store", "index", "In", "copy", "ln", "resource", "id", "ic", "buffer", "p", "l", "inc", "xml", "sum", "body", "doc", "reader", "ind", "image", "rin", "inside", "iterator", "internal", "from", "can", "all", "en", "ain", "on", "out", "IN", "create", "el", "scan", "container", "sql", "isin", "ma", "size", "add", "inn", "this", "din", "text", "nin"], "path": ["print", "pkg", "key", "full", "rel", "user", "string", "location", "ath", "loc", "pi", "dir", "local", "home", "PATH", "physical", "length", "link", "pos", "time", "pt", "cp", "address", " PATH", "index", "folder", "template", "transform", "base", "prefix", "api", "ref", "mount", "resource", "set", "p", "entry", "prop", "pointer", "Path", "system", "context", "where", "port", "from", "route", "host", "po", "temp", "history", "tree", "parent", "near", "pr", "policy", "chain", "th", "name", "pro", "trace", "alias", "ith", "pattern", "log", "member", "point", "dest", "join", "item"], "s": ["http", "b", "m", "v", "simple", "l", "js", "socket", "space", "h", "has", "us", "store", "rs", "c", "S", "is", "ss", "f", "abs", "ssl", "sys", "sv", "sa", "src", "sam", "stat", "serv", "st", "https", "sf", "single", "t", "sts", "ts", "sm", "fs", "sl", "sw", "set", "storage", "sol", "g", "conf", "stats", "sb", "r", "ps", "i", "a", "gs", "ls", "sq", "p"], "file": ["link", "l", "use", "node", "data", "key", "obj", "filename", "location", "image", "base", "name", "fo", "table", "io", "type", "form", "item", "f", "ile", "media", "il", "fp", "tile", "class", " File", "e", "files", "info", "sf", "be", "port", "le", "supported", "resource", "t", "File", "from", "local", "library", "fs", "value", "original", "id", "binary", "content", "object", "message", "i", "FILE", "p"], "uri": ["http", "ui", "link", " URI", "html", "address", "chain", "iri", "filename", "uni", "phi", "pid", "location", "term", "directory", "volume", "image", "msg", "template", "prefix", "description", "char", "form", "uid", "subject", "u", "unit", "ref", "ur", "phrase", "note", "pi", "domain", "du", "dir", "request", "origin", "copy", "URI", "ri", "doi", "resource", "nu", "local", "range", "result", "id", "query", "route", "reference", "remote", "i", "qi", "uu"], "url": ["browser", "http", "link", "l", "ll", "rl", "address", "href", "rel", "string", "location", "term", "name", "open", "char", "f", "str", "ul", "mail", "ssl", "dl", "api", "ref", "u", "ur", "nl", "mount", "URL", "gl", "resource", "Url", "sl", "get", "host", "r", "channel", "ls"], "cd": ["d", "idd", "md", "ld", "ctr", "cp", "bd", "pd", "hd", "desc", "rd", "od", "dc", "cmd", "dd", "cf", "ct", "did", "DC", "CD", "cr", "td", "vd", "cs", "dn", "kb", "sd", "cod", "gb", "xd", "cm", "dm", "db", "ec", "dt", "de", "cc", "ds"], "valid": ["dev", "multi", "v", "visible", "val", "md", "more", "bad", " invalid", "full", "legal", "al", "test", "found", "available", "Valid", "related", "used", "open", "form", "allowed", "basic", "by", "active", "info", "required", "multiple", "check", "supported", "ma", "normal", "defined", "local", "present", "def", "all", "solid", "formed", " Valid", "VAL", "good", "empty", "recent", "current"], "stream": ["raw", "steam", "data", "ous", "store", "clean", "instance", "reader", "image", "response", "im", "transform", " Stream", "is", " streaming", "dd", "form", "row", "context", "sam", "sample", "upload", "REAM", " upstream", "out", "resource", "Steam", "read", "sw", "sc", "console", "content", "view", "speed", "Stream", "empty", "ess", "pool", "channel", "buffer", "ream", " streamed"], "document": ["m", "record", "data", "NULL", "Document", "doc", "instance", " documents", "index", "string", "New", "information", "image", "Required", "FILE", "language", "collection", "Context", "media", "number", "ocument", "json", "cont", "context", "Source", "Internal", "Open", "value", "resource", "Supported", "content", "object", "Store", "_", "output", "IA", "Exception", "message", "text"]}}
{"id1": "62362", "id2": "3731077", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Conprocess", "compversion", "converting", "conversion", "Converting", "Converts", "ConVERT", "CONvert", "consVERT", "unprocess", "compvert", "compverts", "consverting", "consversion", "CONversion", "converts", "unfer", "unversion", "Converted", "Conversion", "unverts", "conVERT", "compprocess", "consvert", "CONverting", "Confer", "CONVERT", "converted", "unverted", "confer", "CONfer", "Convert", "conprocess", "CONverted", "unvert"], "src": ["http", "rest", "source", "pkg", "ebin", "SOURCE", "href", "filename", "rel", "ins", "ser", "input", "dist", "attr", "hl", "RC", "req", "rs", "scene", "rx", "loc", "iv", "ipl", "its", "str", "cont", "img", "scan", "sys", "usr", "orig", "func", "rc", "ur", "st", "upload", "ource", "Source", "cur", "stream", "inst", "url", "file", "from", "s", "buster", "start", "sit", "config", "sc", "host", "sin", "addr", "path", "cc", "sr", "txt", "sq", "uri", "SourceFile"], "dest": ["rest", "disk", " dst", " Dest", "dat", "test", "target", "tif", "dist", "table", "Dest", " destinations", "img", "est", "write", " Destination", "dir", "port", "gin", "mat", "result", " orig", "foreign", "temp", " destination", "txt", "orig", "source"], "in": ["inf", "d", "m", "b", "IN", "l", "ad", "inner", "cin", "ins", "el", "input", "res", "reader", "ind", "rin", "bin", "up", "In", "is", "io", "ar", "sql", "isin", "serv", "st", "stream", "file", "from", "en", "as", "inn", "r", "i", "din", "source"], "p": ["ping", "pb", "pl", "d", "parse", "m", "b", "pt", "l", "pg", "ap", "it", "cp", "pkg", "pd", "h", "wp", "post", "pe", "pa", "dp", "parser", "at", "pm", "rep", "c", "pro", "jp", "php", "f", "tp", "fp", "pi", "j", "lp", "sp", "pc", "py", "er", "pers", "t", "P", "pre", "vp", "pp", "ph", "part", "op", "g", "prot", "per", "ps", "r", "i"], "ds": ["ks", "pd", "hd", " os", "hs", "dl", "ys", "uds", " des", "iffs", " ads", "amps", "ps", "dt", "bs", "ils", "terms", "sets", "ws", "qs", "edes", "os", "cks", "dd", "ras", "eps", "ags", "loads", "ts", "ports", "gs", "mys", "js", "tags", "Ds", "points", "aws", "obs", "des", "tests", "df", "vs", "dh", "cs", "eds", " DS", "drivers", "xs", "s", "dds", "sts", "ats", "sd", "ands", "nas", "docs", "di", "db", "outs", "ns", "ls", "d", "dates", "DS", "dp", "gd", "posts", "rs", "yes", "ods", "ss", "ads", "its", "tp", " dd", "dos", "tes", " d", "scripts", "workers", "els", "lists"], "format": ["parse", "lat", "Format", "sche", "mode", "l", "policy", "it", "settings", "filter", "MAT", "at", "status", "template", " Format", "shape", "name", "table", "layout", "type", "cf", "form", "ct", "feature", "f", "style", "top", "fc", "unit", "act", "pi", "fm", "module", "title", "version", "mt", "size", "t", "file", "mat", "feat", "pattern", "ats", "set", "id", "spec", "output", "tag", "path", "pretty", "source"], "hasPixelData": ["hasixelDATA", "HaspixelData", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasPixelDATA", "hasixeldata", "HaspixelDATA", "haspixelDATA", "hasFrameData", "hasixelData", "hasFramedata", "HasPixelData", "Haspixeldata", "haspixelData", "HasPixelDATA", "HasPixeldata", "hasFrameDATA", "hasPixeldata"], "inflate": ["invalidATE", "Informat", "Inflat", " invalidocate", "Informocate", "inflat", "inFLocate", "inFlicate", "inflocate", " invalidate", " inflicate", "informocate", "Informate", " invalidicate", "inFlATE", "informated", "infolated", "invalidocate", "inflated", "infolat", "informate", "inflATE", " invalidATE", "inFLated", "infolate", "incelocate", " inflATE", "inflicate", "informat", "inFlocate", "incelicate", "inFlate", "incelate", "invalidicate", "Inflate", "invalidate", " inflocate", "inFLate", "infolocate", "inFLat", "Inflocate", "Informated", "Inflated", "incelATE"], "pxlen": ["xplen", "pixelfun", "mmlength", "pexlen", "pxden", "pxls", "packls", "pxlength", "pixellength", "packdec", "xpln", "xpden", "pixells", "mxlen", "tmplen", "xylin", "mxln", "mmln", "cplen", "phplength", "pxlin", "packlength", "pexden", "mxlength", "pexlength", "cplength", "pexfun", "mmlin", "xyln", "cpden", "pxln", "tmplength", "phpln", "packln", "xylen", "cpln", "phplen", "pexln", "mmlen", "pexls", "phpdec", "packfun", "xplength", "tmpln", "pxfun", "mxdec", "pxdec", "packlen", "pixellen", "tmplin", "xylength"], "out": ["print", "screen", "list", "conn", "ex", "err", "sum", "obj", "inv", "res", "store", "user", "OUT", "msg", "group", "name", "up", "prefix", "ou", "io", "Out", "writer", "aos", "cmd", "client", "outer", "sys", "init", "dir", "ln", "gov", "crit", "log", "inter", "cfg", "outs", "output", "gr", "temp", "net", "pretty"]}}
{"id1": "21063400", "id2": "22264586", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doItemImageSort", "doItemImageProcess", " doImageprocess", " doImagesSort", " doImagesProcess", "doMediaWork", " doImageSort", " doImageWork", "doMediaprocess", "doImagesSort", "doImagesWork", "doItemImageprocess", "doImageSort", "doImagesprocess", " doImagesprocess", " doImagesWork", "doMediaProcess", "doImagesProcess", "doImageprocess", "doImageWork", "doMediaSort", "doItemImageWork"], "request": ["command", "address", "server", "session", "question", "input", "re", "image", "template", "document", "quest", "attribute", "client", "context", "application", "version", "resource", "Request", "start", "QUEST", "query", "model", "view", "reference", "message", "frame", "select"], "response": ["http", "report", "entry", "cache", "print", "continue", "list", "detail", "network", "xml", "resp", "server", "respond", "reset", "site", "hash", "res", "user", "onse", "re", "window", "image", "status", "one", "answer", "document", "sequence", "description", "collection", "json", "connection", "parent", "application", "write", "reply", "version", "position", "block", "ve", "next", "search", "format", "Response", "result", "exit", "model", "success", "query", "console", "content", "relation", "view", "output", "fire", "message", "page", "display", "frame", "tree"], "imgSize": [" imgName", "dimsize", "imagError", "imageSIZE", "dimSIZE", "propName", "certScale", "augSize", "certSIZE", "imageInfo", " imgShape", "imageScale", "divSIZE", "imgsize", "augOwner", " imgType", "imgInfo", "imgStyle", " imgsize", "divsize", "divSize", "imgScale", "appStyle", "certSize", "appShape", "imgShape", "appSize", " imgInfo", "augsize", "appsize", "certName", "imagSize", "imgOwner", "imagName", "propsize", "augShape", "imageStyle", "appType", " imgOwner", " imgStyle", "imageSize", " imgSIZE", "imgError", "dimSize", "imgSIZE", "imgName", "appInfo", " imgScale", "propSize", " imgError", "appOwner", "propError", "imgType", "imagsize", "imageName", "imageType"], "imageInputStream": [" imageInputPath", "imageOutputSteam", "imageInStream", "fileRawStream", "fileInputStream", "imageIntPath", "imageInterfaceStream", "imageInputSteam", "imageInSteam", "photoIntstream", "imageByteStream", "fileRawSteam", " imageStreamPath", "imageRawView", "fileRawstream", "imageByteForm", "mediaInputForm", "imageInputPath", "imageStreamPath", "imageRawstream", "imageInputView", "imageInstream", "mediaInputReader", "imageByteReader", "photoIntStream", "photoIntSteam", "imageStreamSteam", "mediaInputSteam", "imageInputReader", "fileInputSteam", " imageStreamStream", "imageRawStream", "imageInterfaceSteam", "imageIntStream", "imageByteSteam", "imageStreamStream", "imageOutputstream", "imageIntstream", "imageOutputForm", "imageOutputReader", "imageInterfaceView", "imageOutputStream", "photoInputstream", "imageInputstream", "fileInputView", "imageRawSteam", "mediaInputStream", " imageStreamSteam", "imageIntSteam", " imageInputSteam", "photoInputSteam", "imageInputForm", "imageInView", "fileRawView", "photoInputStream", "imageInterfacestream", "fileInputstream"], "imageBytes": ["photoGs", "pictureBytes", "audioBytes", "photoBytes", "imgGs", "imageSeries", "imgBs", "imageGs", "photoParts", "imageKeys", "issueParts", "audioSeries", "imageParts", "imageByte", "issueGs", "issueBytes", " imageBs", " imageGs", " imageSeries", " imageByte", "imgBytes", "photoByte", "audioParts", "pictureByte", "imgParts", "photoKeys", "pictureGs", "audioBs", "imgSeries", " imageParts", "pictureParts", "imgKeys", "issueKeys", "imageBs"]}}
{"id1": "14758866", "id2": "6501291", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getStreamasStream", "getResourceInForm", "getStreamAsInput", "getStreamAsSteam", "getResourceASInput", "getStreamasInput", "getResourceAsForm", "getResourceasSteam", "getStreamAsForm", "getResourceInInput", "getResourceAsInput", "getStreamasSteam", "getStreamAsStream", "getResourceasInput", "getResourceasForm", "getResourceASStream", "getStreamasForm", "getResourceASSteam", "getResourceInSteam", "getResourceInStream", "getResourceasStream", "getResourceAsSteam", "getResourceASForm"], "name": ["n", "cache", "pkg", "Name", "NAME", "key", "address", "missing", "filename", "string", "location", "image", "base", "error", "prefix", "description", "type", "password", "client", "ame", "title", "domain", "version", "word", "size", "search", "names", "resource", "file", "local", "format", "part", "id", "initial", "run", "path", "a", "remote", "uri", "source"], "inputStream": ["InputSteam", "uploadView", "inputstream", " inputFile", "InputStream", "InputFile", "rawView", "rawStream", " inputPort", "inputPort", "inputFile", "currentFile", "inputChannel", "rawSteam", "InputForm", "uploadstream", " inputForm", "currentStream", " inputstream", " inputSteam", "quickChannel", "quickStream", "quickSteam", "inputForm", "quickForm", "InputPort", "InputChannel", " inputChannel", "uploadSteam", "inputView", "rawstream", "uploadStream", "inputSteam", "currentPort", " inputView", "currentSteam"], "in": ["inf", "m", "o", "n", "IN", "data", "inner", "xml", "ins", "buffer", "input", "bin", "In", "io", "context", "con", "info", "mc", "stream", "ai", "edIn", "file", "r", "din", "p"], "out": ["o", "b", "n", "m", "cache", "to", "list", "report", "screen", "l", "dis", "print", "err", "conn", "ex", "inner", "obj", "buffer", "res", "inv", "ins", "user", "OUT", "msg", "group", "c", "os", "up", "Out", "io", "ou", "writer", "client", "outer", "sys", "conv", "dir", "info", "ln", "w", "t", "last", "gov", "log", "all", "inter", "cfg", "output", "outs", "tmp", "net", "pretty", "cn", "p", "nt"], "url": ["browser", "http", "b", "raw", "link", "web", "l", "ll", "html", "rl", "xml", "address", "server", "rel", "el", "call", "re", "location", "git", "hl", "base", "loc", "char", "f", "str", "il", "mail", "abs", "ssl", "dl", "ref", "build", "ur", "nl", "sql", "bel", "domain", "mount", "https", "URL", "resource", "file", "gl", "handle", "impl", "log", "Url", "cl", "github", "get", "r", "addr", "this", "path", "remote", "ls", "uri"], "remoteName": ["localKey", "quickname", "remotePath", "commonName", "localname", "externalKey", "localPath", "commonPath", "quickName", " remotePath", " remotename", "commonKey", "externalName", "remotename", "remoteKey", " remoteKey", "quickPath", "externalPath", "commonname", "externalname", "quickKey"], "localName": ["localKey", "fixedName", "remoteValue", " localNode", " localNames", "singleName", "locFile", "singleNAME", "shortName", "localValue", "localFile", "localname", "remoteNode", " localValue", " localType", "singleFilename", "fixedNAME", "shortNAME", "shortname", "localNode", "LocalKey", "Localname", "remoteFile", "locImage", "remoteType", "fullKey", "locFilename", "singlename", "LocalValue", " localname", "locValue", "localNAME", "LocalName", "fixedFilename", "remoteKey", " localImage", "fullName", "fullNames", "fixedname", "remoteNames", "locName", "fullValue", "localType", " localFilename", "localFilename", "localImage", "remoteImage", "locType", "fullname", "localNames", "shortFilename", "locNode", " localKey", "remoteFilename", "LocalNames", " localFile"], "host": ["http", "ip", "ca", "campus", "address", "h", "server", "hd", "hop", "target", "root", "chain", "system", "base", "loc", "cert", "client", "www", "localhost", "top", "subject", "hook", "domain", "dir", "Host", "handle", "local", "ost", "home", "addr", "path", "remote", "bind", "height", "uri", "source"], "prot": ["ping", "http", "prop", "sche", "pkg", "header", "server", "system", "at", "rot", "tel", "pro", "prefix", "type", "Prot", "pat", "platform", "client", "iot", "password", "col", "tp", "top", "ssl", "eth", "ret", "ref", "version", "ios", "prototype", "ocol", "crypt", "https", "format", "pattern", "typ", "path", "pool", "net", "ht", "uri"], "port": ["ping", "pport", "report", "print", "pt", "socket", "project", "duration", "key", "server", "test", "PORT", "post", "pe", "pid", "priority", "padding", "limit", "timeout", "pro", "language", "password", "trace", "client", "width", "localhost", "number", "pi", "note", "column", "eport", "version", "trust", "position", "size", "proxy", "file", "ort", "Port", "point", "message", "ports", "page", "pool", "length", "p"], "cacheFile": ["cacheFolder", "apachefile", "acheUser", "apacheInfo", " cacheInfo", "localFiles", "CacheFiles", "cacheField", "tempFile", "CacheFILE", "tempfile", "localFile", "cacheFiles", " cacheUser", "cachefile", " cacheStore", " cacheFolder", "cacheInfo", " cacheFILE", "tempFilename", " cacheFilename", "cacheDir", "acheFolder", "localUser", "localStore", "proxyInfo", "localField", "localfile", "CacheFilename", "cacheEntry", "acheFile", "CacheDir", "Cachefile", "mapfile", "mapFile", "apacheFolder", "cacheFilename", "localEntry", "proxyfile", "CacheStore", "acheDir", " cacheField", "proxyFolder", "cacheUser", "CacheFolder", "apacheFile", "acheField", "localDir", "CacheEntry", "tempFILE", " cacheEntry", "proxyFile", "cacheFILE", "cacheStore", " cacheDir", " cacheFiles", "CacheFile", "achefile", "mapStore", "mapDir", " cachefile"], "urlConnection": [" urlResponse", "URLConnector", "dlConnector", "URLConnect", "urlLink", "urlFile", "httpTransaction", "UrlConnect", "channelConnect", "sslConnection", " urlConnect", "httpConnection", "llConn", "dlconnection", "channelConnector", " urlconnection", "browserConnection", "urlConnector", "UrlResponse", "urlconnection", "browserResponse", "URLFile", "httpConnect", "urlTransaction", "dlConn", "dlConnect", "UrlLink", "llConnector", "browserFile", "methodconnection", " urlTransaction", "channelConnection", "sslConnect", "sslconnection", "browserconnection", "llconnection", "Urlconnection", "methodConnect", "browserConnect", "dlConnection", "httpLink", "URLConn", "methodConnection", "sslTransaction", "urlConn", "urlResponse", "browserConnector", "httpConn", "UrlConnection", "llConnection", "dlComment", "URLComment", "channelComment", "methodLink", "URLConnection", "urlConnect", "browserConn", "httpconnection", "urlComment", "httpFile"], "httpURLConnection": ["httpsHTTPConnection", "webUrlEntry", "httpILconnection", "httpSRConnect", " httpMLConn", "HttpURLInstance", "httpTLConnect", "httpALLConnection", "httpPORTConnection", " httpURLConn", " httpURLConnect", "httpSSLEntry", "httpREConnector", "httpURLConnector", "httpSRConnection", "historyURLConnection", "httpREConnection", "HttpURLconnection", " httpURLconnection", "httpMLConnection", "webURLConnection", "httpsURLConnect", "httpHTTPInstance", "historyILConnection", "httpUrlNetwork", "httpUrlTransaction", "httpUrlConnect", "httpURLconnection", "webUrlConnect", "HttpURLConnect", "httpMLConnect", "httpsURLConnector", " httpMLconnection", "historyILNetwork", "httpDOMConnection", "httpURLConn", "httpsHTTPConnector", "httpILConnect", "HttpURLEntry", "httpsHTTPConn", "httpsURLConn", "httpSSLInstance", "httpILNetwork", "historyILConnect", "httpDBconnection", "httpDOMConnect", "githubUrlTransaction", "githubURLconnection", "historyILconnection", "webURLconnection", "httpALLConnect", "HttpHTTPConn", "httpsURLConnection", "httpURLInstance", "HttpHTTPEntry", " httpMLConnection", "githubURLTransaction", "httpDOMconnection", "HttpURLConnection", "httpURLEntry", "HttpHTTPInstance", "HttpHTTPconnection", "httpHTTPNetwork", "httpUrlEntry", "githubUrlconnection", "httpUrlConnection", "httpHTTPTransaction", "httpUrlconnection", "httpURLNetwork", "httpREConnect", "httpHTTPConn", "httpREConn", "httpILConnection", "githubUrlConnect", "githubUrlConnection", "webURLConnect", "historyURLConnect", "historyURLconnection", "httpSSLConnect", "httpURLConnect", "httpUrlConnector", "httpHTTPEntry", "httpTLConnection", "httpHTTPConnector", "HttpHTTPConnector", "webURLEntry", "httpHTTPConnect", "HttpURLConn", "httpsHTTPConnect", "httpDBConnect", "webUrlconnection", "httpTLConnector", "httpULEntry", "httpSRconnection", "httpULConnect", "HttpHTTPConnect", "httpDBTransaction", "httpALLconnection", " httpMLConnect", "httpSSLConnection", "httpURLTransaction", "githubURLConnection", "httpHTTPconnection", "httpULConnection", "httpPORTConnector", "httpSRConn", "HttpURLConnector", "httpHTTPConnection", "httpMLconnection", "httpDOMEntry", "httpTLConn", "httpALLConn", "httpPORTConnect", "webUrlConnection", "httpMLConn", "httpDBConnection", "HttpHTTPConnection", "httpULInstance", "historyURLNetwork", "githubURLConnect"], "responseCode": ["ResponseClass", "requestCount", "requestClass", " responseActionCode", "complianceClass", "ResponseSize", "requestSize", "ResponseCode", "replyCode", "complianceActionCode", "replyCategory", "responseClass", "responseCount", "complianceCategory", "resultCode", "responseSize", "resultCount", "ResponseCount", "replyClass", "replyActionCode", "resultSize", "resultClass", " responseClass", "complianceCode", " responseCategory", "requestCode", "responseActionCode", "responseCategory"], "lastModified": ["lastMODified", "lastContentified", " lastTrify", "LastModify", "lastMODification", " lastTrification", " lastModed", " lastModmodified", "LastContentify", "lastmodified", "lastTrified", "lastModification", "lastMODify", "LastContentified", "lastModed", "New", "lastModify", "lastModifier", "lastmodification", "lastmodmodified", "lastContentify", "LastModification", "lastmoded", " lastModification", "lastTrification", " lastModify", "lastMODifier", " lastTrmodified", "LastContentification", "lastModmodified", "lastContentmodified", "lastContentification", " lastTred", "lastmodify", "LastContentifier", "lastTrifier", "_", "lastTred", " lastTrified", "lastTrmodified", "LastModified", "LastModifier", "lastContentifier", "lastContented", "lastTrify"]}}
{"id1": "5441579", "id2": "823074", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"createPseudoUUID": ["createPseudoRandomUID", "createPseudoRandomID", "createPseudoRandomuid", "createPseudoUniqueuid", "createPseudoUUUID", "createPseanUId", "createPseudoUID", "createPseudoUId", "createPseanUID", "createPseanRandomID", "createPseudoUUId", "createPseanRandomuid", "createPseudoUniqueUID", "createPseanUuid", "createPseudoUniqueId", "createPseudoRandomId", "createPseudoUUuid", "createPseanRandomId", "createPseanUUID", "createPseanRandomUID", "createPseudoUuid", "createPseudoUniqueID"], "messageDigest": ["numberDigests", "messageHasester", "messageLocse", "messagedigifier", "messageDigested", "numberDesignist", "messageDester", " messageDigested", "messageDrise", " messagedigment", " messageDesignest", "messageMacest", "messageDesignester", "messageHasests", "messageMacested", "messageDigse", "messageDesignist", "messagedigse", "messagedigest", "messageDigment", "messageDesignest", " messageDiger", "numberDigest", "numberDesignests", "numberDesignest", " messageDigist", " messageDesignester", "messageLocifier", "messageDiger", "messageMacer", "messageDigester", "numberDesignester", "messagedigested", "messagedigester", " messageDigse", "messageDigifier", "messagediger", "messageLocment", "messageMacse", "messageHasist", "messagedigment", "messageDigests", "messageHasest", "messageDigist", "messageDist", " messagedigifier", "messageDests", " messageDesignse", "messageDesignse", " messagedigest", "numberDigester", "messageDriester", "messageDriist", "messageLocest", " messagedigse", " messageDigester", "messageDest", "messageDriest", "messagedigist", " messageDigment", "messageDesignests", " messageDigifier", " messageDesignist", "numberDigist"], "localHost": ["localPort", "localhostServer", "localAddress", " localAddress", "remotehost", "remoteHost", " localPort", " localhost", "LocalPort", "localhost", "Localhost", "LocalAddress", "LocalServer", "remotePort", " localServer", "localhostHost", "localhostPort", "localhosthost", "localServer", "remoteAddress", "LocalHost"], "digestBytes": ["mixestBytes", "digESTBytes", "mixestedBytes", "drivenesterValues", "drivenesterParts", "digesterArgs", "DigestServices", "drivenestBytes", "drivenestParts", "digetbytes", "drivenesterBytes", "digesterResults", " digestedValues", "digestValues", "diggestbytes", "digestedAttributes", "DiggestParts", " digestedbytes", "mixestedServices", "digstServices", "diggestKeys", "diggestExamples", " digestbytes", "digestbytes", "digestedResults", "digestResults", "digstParts", "digestedArgs", "digestedBytes", "drivenesterBs", "diggestBytes", "digestBs", "digetServices", "DiggestBytes", "mixestServices", "digestServices", "diggeBytes", "DiggestServices", "digesterBs", "digesterParts", "digestLinks", "digesterbytes", "mixestedLinks", "digstBytes", "digesterLinks", "mixestbytes", "digestArgs", "digestedBs", "mixestLinks", "digesterBytes", "mixestParts", "digestedValues", " digestParts", "mixestedArgs", "digestedServices", "digistanceExamples", "mixestedbytes", "digestExamples", "diggeParts", "diggeServices", "mixestAttributes", "DigestParts", " digestResults", "mixestArgs", "Diggestbytes", "digetParts", "mixestedParts", "digestParts", "drivenestValues", " digestedBytes", "diggestParts", "digestedLinks", "digESTLinks", "digestAttributes", "mixestedAttributes", "digstAttributes", "digESTArgs", " digestValues", "diggeAttributes", "digetBytes", "digESTValues", "Digestbytes", " digestKeys", "drivenestBs", "digistanceBytes", "DigestBytes", "digestedParts", "digestKeys", "diggestServices", "digestedbytes", " digestArgs", " digestExamples", "digesterValues", "digESTbytes", "digistanceKeys"], "sb": ["pb", "b", "abb", "bj", "sh", "bh", "pg", "bis", "bash", "sbm", "rob", "zb", "lb", "ub", "bt", "stab", "bps", "jp", "rb", "gob", "bp", "sa", "ssl", "sv", "bn", "lp", "src", "sam", "bg", "bf", "sp", "cb", "ib", "sn", "fb", "sf", "obb", "kb", "sth", "gc", "wb", "ctrl", "tn", "sl", "sw", "gb", "bb", "storage", "eb", "sd", "ibl", "nb", "db", "shell", "bs", "sg", "esm", "erb", "SB"]}}
{"id1": "13333160", "id2": "18693224", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"run": ["execute", "test", "proc", "pass", "process", "exec", "flow", "render", "scan", "running", "unit", "runner", "wal", "work", "go", "Run", "ran", "eval", "start", "read", "query", "view", "app", "apply", "action"], "xmlIn": ["domIn", "fileIns", "htmlIns", "htmlIn", "xOut", "filein", "xIns", "xInput", "xIn", "xmlin", "jsonOut", "xmlIns", "htmlin", "fileIn", "xmlInput", " xmlIns", "jsonIns", " xmlin", "jsonIn", "xmlOut", "jsonInput", "domInput", "domOut", "domIns"], "out": ["d", "o", "report", "to", "raw", "v", "null", "in", "ex", "ws", "err", "obj", "res", "OUT", "one", "os", "up", "Out", "io", "ou", "aos", "client", "end", "off", "stream", "w", "t", "file", "s", "log", "sw", "set", "OU", "output", "outs", "pool", "i", "p", "nt"], "dom": ["d", "browser", "m", "tree", "web", "md", "cd", "html", "node", "xml", "data", "iam", "el", "doc", "window", "parser", "dr", "atom", "process", "yang", "os", "document", "comm", "df", "img", "dl", "j", "utils", "dem", "domain", "div", "dn", "mat", "Dom", "om", "DOM", "result", "model", "fr", "dm", "mom", "host", "db", "page", "frame", "p"], "f": ["inf", "v", "d", "l", "it", "full", "tf", "fab", "xf", "F", "c", "fo", "ff", "uf", "cf", "ft", "rf", "fi", "df", "fc", "conv", "fg", "bf", "fm", "fort", "fac", "fb", "forge", "sf", "af", "w", "Factory", "fd", "fs", "lf", "fl", "foreign", "fr", "g", "conf", "of", "fx", "fy"], "b": ["d", "pb", "v", "m", "bh", "l", "Builder", "bd", "bt", "base", "c", "B", "builder", "rb", "ab", "bi", "j", "bf", "bg", "e", "fb", "be", "gb", "bb", "bc", "eb", "g", "sb", "nb", "r", "mb", "bs", "db", "a", "p"], "root": ["browser", "m", " rooted", "null", "html", "data", "bank", "roots", "ro", "bot", "loc", "used", "area", "type", "nav", "top", "ree", "head", "DOM", "wrap", "get", "ok", "right", "gr", "raw", "rt", "h", "rap", "base", "os", "row", "first", "module", "mount", "element", "result", "start", "object", "ax", "rank", "p", "node", "xml", "doc", "available", "document", "author", "valid", "owner", "box", "ow", "ram", "ain", "host", "r", "parent", "tree", "create", "chain", "av", "res", "group", "table", "rown", "roid", "feature", "container", "ul", "scope", " Root", "div", "oot", "primary", "mr", "Root", "cover", "instance"], "att": ["acc", "apt", "aff", "ac", "pt", "prop", "ap", "tr", "dat", "ATT", "rt", "data", "nat", "av", "attr", "at", " attribute", "aux", "attribute", "ct", "adj", "ar", "pet", "atts", " matt", " dat", "info", "attach", "alt", "aj", "aria", " ut", "feat", "t", "mat", "ts", "Att", "rib", "tt", "ach", "set", "def", "addr", "tmp", "txt", "nt"], "menu": ["m", "tree", "wiki", "cache", "ui", "list", "summary", "command", "consumer", "theme", "usage", "settings", "header", "node", "chain", "site", "us", "options", "window", "mu", "button", "up", "sequence", "li", "admin", "item", "mouse", "nav", "queue", "ul", "row", "um", "module", "title", "pie", "Menu", "manager", "block", "category", "next", " menus", "movie", "omo", "library", "ctrl", "config", "cm", "men", "option", "page", " Menu", "family", "parent"], "id": ["link", "Id", "data", "key", "pid", "target", "status", "ids", "name", "description", "type", "icon", "uid", "class", "ref", "scope", "init", "title", "version", "method", "url", "value", "file", "mid", "tag", "ID", "uri", "source"], "zout": ["czclient", "zipup", "ziposs", "Zout", "zipOUT", "zouter", "zeross", "zOut", "gzin", "gznet", "zerOUT", " zserv", "ozOUT", "zaos", "zipin", "Zaos", "zipOut", "zpoint", "ZOut", "znet", "zot", "ozouter", "ozot", " zin", " zclient", "zerouter", "ozouts", "ozOut", "zin", "Zin", "zerot", "enzpoint", "zup", "izout", "zouts", "izserv", "zipaos", "ezouts", "enzout", "zserv", "zipnet", "zipclient", "zor", "ozup", "zipserv", "zoss", "zclient", "zipor", "izaos", "zippoint", " zor", "czout", "czup", " zpoint", " zouts", "ezout", " znet", "gzor", " zaos", "enzOut", "ozoss", "zipot", "ozout", "ezpoint", "zOUT", " zup", "zipouter", "zipout", "gzout", "zerout", "czOut", "izOut", "zerup", " zOut", "ozpoint", "zerOut"], "content": ["cache", "code", "html", "header", "data", "full", "string", "c", "layout", "section", "file", "article", "page", "current", "source", "raw", "time", "address", "inner", "ext", "template", "load", "sequence", "description", "cmd", "title", "position", "htm", "value", "result", "read", "config", "object", "good", "default", "output", "pool", "x", "command", "xml", "body", "padding", "image", "document", "core", "media", "cont", "context", "lay", "request", "cur", "now", "search", "format", "ontent", "reason", "host", "message", "tree", "condition", "create", "expression", "accept", "wrapper", "Content", "json", "text", "script", "comment", "block", "size", "ce", "metadata", "query", "path", "txt"], "signal": ["seil", "scale", "seAL", "several", "SIGNature", " signale", " signil", "seale", " signAL", "SIGNale", "signil", "scature", "severaling", "scal", "SIGNaling", "Signaling", "severAL", "severale", "severil", " signaling", "severature", "signature", "signAL", "seal", "scaling", "SIGNal", "Signature", "signaling", "signale", "Signal", "sealing", " signature", "seature"], "n": ["d", "m", "o", "zero", "pos", "l", "np", "num", "nan", "node", "h", "no", "index", "natural", "c", "len", "nw", "number", "un", "ng", "count", "j", "nc", "nl", "N", "nn", "ln", "sn", "nr", "dn", "nv", "mn", "nu", "unn", "t", "nm", "nor", "norm", "ni", "tn", "an", "en", "g", "nb", "on", "i", "ns", "cn", "ne", "z", "p", "nt"], "entry": ["insert", "link", "slot", "record", "data", "RY", "instance", "pixel", "system", "quick", "table", "line", "row", "cell", "sheet", "join", "connection", "cue", "e", "comment", "element", "ace", "enter", "next", "add", "escape", "se", "result", "log", "ent", "office", "member", "query", "zip", "tmp", "Entry", "page", "ie", "ry", "nt"], "pout": ["ppond", "pto", "phpsys", "ppot", "ppent", "wpout", "phpout", "ptout", "pou", "phpnew", "pin", " pin", "pond", "ptouter", "jpconn", "psys", " pond", "phpot", "ppto", "Pin", "pinner", "zconn", "phpOut", " pouter", " pinner", "pnew", "phpouter", "zouter", "jpinner", "ppinner", "wpto", "pOut", "Pout", "jpout", "pconn", " psys", "wpond", "POut", " pent", "zinner", " pou", "pouter", "wpent", "ppout", "phpinner", "pent", "pot", "ptOut", "ptnew", "jpou", " pto", " pnew", "zou", " pOut", "zot", " pconn", "phpin", "ppouter", "Psys"]}}
{"id1": "6470716", "id2": "17557289", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"st": ["d", "sh", "rest", "ld", "ast", "step", "rt", "St", "sty", "ste", "store", "th", "std", "ST", "stri", "ft", "www", "str", "est", "sp", "nd", "sn", "inst", "stream", "sta", "sts", "service", "t", "se", "sm", "start", "ost", "sth", "tt", "sw", "set", "ist", "stable", "ust", "stra"], "url": ["browser", "http", "pl", "rect", "rest", "link", "null", "web", "l", "ll", "html", "address", "rel", "el", "string", "location", "hl", "base", "loc", "li", "cert", "char", "client", "www", "f", "str", "ul", "mail", "abs", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "ch", "bel", "mount", "domain", "URL", "gl", "file", "il", "impl", "Url", "sl", "fl", "cl", "github", "host", "r", "addr", "shell", "ls", "uri"], "fis": ["feis", "fei", "Fois", "fiss", "fier", "xfier", "fliss", "ufis", "xfois", "Fais", "flis", "f\u00eds", "tiss", "ufi", "efi", "fi", "tais", "efis", " fiss", "tis", "xfis", "ef\u00eds", "ufiss", "Fos", "flisl", "ufisl", "fli", "Fier", "feier", "Fiss", "uf\u00eds", "Fis", " fi", " fais", "efiss", "fois", "feois", "tos", " fisl", "fais", "Fi", " f\u00eds", "fisl", "xfi"], "zis": ["zris", "fisi", "ozis", "fiss", "ozits", "czits", " zris", " zisa", "ozes", "ozIs", "zeniss", "zipits", "czisa", " zIs", "czIs", "czis", " zisi", "zenris", " zits", "zenis", "zipis", " zos", "ziss", "zisi", "ozisa", "zits", "zhis", "zes", "zhisin", "zhes", "zisa", "zipIs", "fits", "zIs", " ziss", "zipes", "zenisi", "zipos", "zisin", "zhIs", "ozisin", "zos", "fris", "zipisin"], "entry": ["way", "jar", "link", "list", "null", "record", "source", "key", "jo", "chain", "obj", "index", "system", "entity", "name", "field", "attribute", "card", "form", "char", "line", "cell", "row", "valid", "e", "sp", "comment", "info", "element", "enter", "ce", "be", "word", "existent", "zo", "se", "result", "log", "pattern", "ent", "office", "member", "def", "match", "inter", "fr", "event", "zip", "tmp", "Entry", "de", "out", "or", "ie", "ry", "item", "nt"], "count": ["n", "acc", "code", "batch", "err", "ctr", "num", "amount", "sum", "found", "call", "index", "total", "child", "ind", "base", "c", "name", "len", "char", "ct", "end", "core", "number", "cell", "cont", "ch", "force", "comment", "Count", "iter", "size", "check", "counter", "add", "t", "depth", "last", "start", "read", "max", "ount", "match", "nb", "page", "cc", "length", "buffer", "current", "nt"], "data": ["d", "done", "n", "raw", "batch", "cache", "zero", "step", "dat", " DATA", "chain", "string", "mu", "image", "bin", "name", "area", "table", "number", "json", "DATA", "buf", "ata", "mem", "sample", "bytes", "block", "size", "next", "value", "format", "reason", "result", "part", "def", "all", "good", "output", "message", "out", "length", "buffer", "text", "source"], "fos": ["hoss", "hos", "fioss", "foos", "fol", "fOS", "Foss", "foops", "fiops", "fiol", "woss", "Fol", "fios", "wis", "Fos", "wos", " foss", "Fops", "his", "foss", "wOS", " fOS", "fooss", "fops", "fool", "hOS"], "dest": ["comp", "way", "rest", "comb", "gest", "gate", "cat", "them", "dat", "sum", "test", "target", "desc", "dist", "det", "std", "transfer", "bin", "des", "dc", "loc", "decl", "Dest", "writer", "nom", "cont", "trans", "send", "usr", "mem", "est", "src", "nd", "pipe", "origin", "ptr", "pas", "crit", "master", "result", "exp", "member", "coord", "foreign", "output", "nt", "temp", "out", "done", "parent", "source"]}}
{"id1": "20011285", "id2": "15166511", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["to", "link", "cat", "cp", "cop", "create", "download", "paste", "Copy", "pixel", "clip", "transfer", "split", "c", "php", "export", "cut", "write", "co", "save", "move", "clone", "sync", "py", "proxy", "file", "crop", "gc", "close", "opy", "zip", "delete", "Cop", "slice", "remote", "share", "p"], "sourceFile": ["samplefile", "ourcePath", "sourceUnit", "sourceFILE", "ourceFile", "packageUser", "sourceDir", "identFile", "SourceLine", " sourceLog", "sourceDirectory", "ourceFILE", "acePlace", "aceFile", "sourceWeb", " sourceFILE", "aceDate", "srcUser", " sourceFiles", "sourceUser", "sourceDate", " sourceUnit", "srcLocal", " sourceDir", "sourceFiles", "sourcePath", "sourcePlace", " sourcefile", "initfile", "initFile", "packageFILE", "originWeb", " sourcePath", "initHeader", "SourceLog", " sourceLocal", " sourceDate", "ourcefile", "packageDirectory", "srcFiles", " sourceHeader", "ourceLog", "SourceFiles", "sourceLine", "srcfile", "Sourcefile", "identPlace", "SourceWeb", "sampleFile", " sourceLine", "srcFILE", "initFILE", "sourceLog", "ourceDirectory", "sourcefile", "sourceHeader", "originDir", "SourceDir", " sourceWeb", "originLine", "srcDirectory", "packageFile", "identDate", "originFile", " sourcePlace", "sampleFILE", "identFiles", "sourceLocal", "srcFile", "srcUnit", "sampleLocal", "aceFiles", "srcHeader", "SourcePath", "SourceUnit", "ourceUser", "SourceFile"], "destinationFile": ["destificationfile", "destensionFile", "destentionLine", "destinateDisk", "estinationfile", "estinationPath", "destentionMail", "destinateLocation", "transinationFile", "destificationFile", "destinatedFile", "destructionLine", "destensionDir", "destinatefile", "destinationDisk", "destinofile", "transinateDisk", "destinatedfile", "destinationEmail", "identinationFILE", "destationDir", "destinatedMail", "parentinationFILE", "destinatorfile", "parentinationFile", "estinatorPath", "destinatorDisk", "transinateDir", "destificationDir", "destumentFile", "destinationFILE", "resultinationLocation", "identinatedFILE", "destinatorEmail", "destinatorFILE", "destinationLine", "destumentEmail", "destmentationDir", "destentionFILE", "transinationDir", "identinatedLine", "destinatedLocation", "transinationDisk", "catinationKey", "destinoKey", "parentinationEmail", "resultinationfile", "catinationFile", "destinateDir", "destructionFile", "resultinateFile", "destationPath", "parentinateEmail", "identinationMail", "destructionMail", "destinatorPath", "destinateKey", "identinatedFile", "destinatedDisk", "destensionFILE", "destinationPath", "destificationPath", "destationfile", "destinationDir", "estinatorFile", "estinatorDir", "transinateFILE", "destinatorFile", "destinationKey", "destinateEmail", "estinatorfile", "estinationFile", "transinateFile", "destinateFile", "parentinateFile", "destinationLocation", "transinationFILE", "destentionFile", "destructionFILE", "destinatorDir", "destationKey", "destinoFile", "destationFile", "destensionDisk", "destumentFILE", "identinatedMail", "destinatorLocation", "identinationFile", "resultinationFile", "destinationMail", "destinationfile", "catinateKey", "identinationLine", "resultinationDisk", "destmentationDisk", "destinatedFILE", "catinationfile", "catinatefile", "destmentationFile", "destinateFILE", "resultinatefile", "resultinateDisk", "catinateFile", "estinationDir", "parentinateFILE", "resultinateLocation", "destmentationFILE", "destinatedLine"], "tmp": ["m", "multi", "apps", "yy", "np", "tab", "aaa", "pkg", "data", "parts", "perm", "obj", "tf", "obs", "mm", "msg", "bt", "split", "aux", "tar", "xxx", "buf", "abs", "img", "src", "ms", "files", "buff", "dir", "sp", "cmp", "cb", "cur", "managed", "xs", "t", "mp", "pres", "mk", "etc", "tt", "qq", "emp", "shots", "nb", "mb", "my", "temp", "stuff", "txt", "p", "nt"], "f": ["d", "o", "v", "b", "m", "fa", "l", "fe", "full", "h", "fw", "k", "q", "obj", "tf", "fab", "F", "xf", "c", "flo", "fo", "field", "ff", "uf", "fi", "cf", "df", "fp", "func", "fc", "u", "bf", "fm", "e", "fac", "fb", "sf", "af", "w", "file", "t", "fd", "fs", "lf", "fl", "fr", "g", "a", "z", "p"], "i": ["o", "multi", "ip", "m", "ci", "ui", "ij", "batch", "v", "in", "it", "ji", "ei", "gi", "key", "ami", "q", "k", "phi", "us", "major", "index", "ind", "im", "ori", "y", "ki", "iq", "li", "ii", "iu", "ini", "xi", "is", "ie", "bi", "pi", "u", "j", "x", "ms", "e", "me", "init", "eu", "iter", "ma", "zi", "ri", "ai", "sim", "mi", "ti", "ix", "id", "point", "ims", "di", "my", "ic", "I", "si", "hi", "qi", "p"], "source": ["tree", "zero", "in", "use", "show", "session", "SOURCE", "body", "site", "missing", "inner", "input", "store", "system", "index", "seed", "image", "template", "base", "sequence", "comment", "style", "scan", "subject", "src", "scope", "sample", "init", "score", "none", "owner", "ource", "origin", "iter", "info", "Source", "size", "ce", "stream", "search", "resource", "file", "from", "service", "series", "se", "local", "result", "start", "query", "storage", "console", "iterator", "spec", "zip", "shell", "before", "archive", "ie", "parent"], "destination": ["declaration", "destation", "combinate", " destension", "Destination", "Destation", "destinate", " destinated", "Destaration", "combination", "destinator", "declinated", " destation", " destinate", "declation", "destinated", "coordation", "declinate", " destinator", " destaration", "combension", "coordinated", "Destinator", "combation", "declination", "coordination", "destension", "Destension", "coordinate", "declinator", "Destinate", "destaration"]}}
{"id1": "8778962", "id2": "16572931", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFile2String", "decodeString2Files", "decodeFile2Files", "decodeFileFileFile", "decodeFileAsfile", "decodeFileToString", "decodeStringToFile", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToFiles", "decodeFileAsFile", "decodeFileFilefile", "decodeFile2file", "decodeString2file", "decodeStringTofile", "decodeFileAsString", "decodeString2String", "decodeFile2File", "decodeFileAsFiles", "decodeStringToString", "decodeFileToFiles", "decodeString2File"], "infile": ["inputname", "outname", "outfilename", "isinname", "isinfile", "inputfolder", "Infilename", "outfolder", "outbase", "inputFile", "Inbase", "isinFile", "inbase", "infolder", "fromFile", "Infile", "InFile", "inputfile", "inname", "frombase", "isinfolder", "inFile", "fromfile", "outFile", "infilename", "fromfilename"], "outfile": ["indir", "Outdir", "outname", "outfilename", "Outfile", "Outfilename", "toFile", "OutFile", "otname", "otfile", "otFILE", "tofilename", " outFILE", "inFILE", "outdir", "todir", "inname", "otFile", "tofile", "inFile", " outname", "outFile", "outFILE", "infilename", " outFile"], "in": ["inf", "conn", "oin", "IN", "it", "inc", "pin", "al", "inner", "cin", "ins", "input", "re", "ind", "rin", "bin", "im", "up", "In", "inside", "is", "ini", "form", "by", "or", "ar", "amin", "isin", "init", "con", "info", "iter", "nin", "t", "gin", "from", "id", "en", "ain", "get", "inn", "on", "per", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "print", "null", "ex", "oss", "it", "inner", "flush", "res", "OUT", "at", "os", "io", "ou", "Out", "aos", "writer", "fn", "end", "outer", "sys", "co", "write", "ot", "con", "ion", "opt", "t", "file", "auto", "gt", "can", "en", "g", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "header", "black", "memory", "paste", "window", "padding", "total", "available", "template", "base", "bone", "shape", "button", "table", "sequence", "document", "bar", "attribute", "password", "pad", "buf", "number", "row", "mem", "phrase", "note", "sample", "buff", "append", "comment", "stack", "info", "column", "block", "library", "variable", "binary", "initial", "view", "message", "temp", "display", "history", "frame", "character"], "read": ["n", "need", "give", " Read", "raw", "print", "shift", "push", "skip", "input", "index", "reading", "reader", "ind", "req", "seek", "load", "hold", "open", "Read", "end", "count", "send", "first", "write", "through", "iter", "size", "check", "wait", "connect", "add", "stream", "allow", "range", "start", "READ", "close", "query", "set", "find", "get", "ok", "run", "i", "before", "each", "length", "ready", "reads", "text", "select", "readable", "len"], "success": ["submit", "sufficient", "summary", "continue", "Success", "condition", "second", "cess", "city", " succ", "status", " successful", "ccess", "response", "accept", "democracy", "error", "town", "unity", "danger", "please", "exist", "commit", "snap", "valid", "first", "scope", "safe", "surv", " failure", "ceed", "setup", " okay", " successes", "primary", "same", "support", "complete", "value", "crit", "successfully", "result", " succeeds", "successful", "release", "ratulations", "good", "photo", "ok", "fail", " succeed", "done", "positive", "growth"]}}
{"id1": "19113613", "id2": "1005108", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public void googleImageSearch(String search, String start) {\n        try {\n            String u = \"http://images.google.com/images?q=\" + search + start;\n            if (u.contains(\" \")) {\n                u = u.replace(\" \", \"+\");\n            }\n            URL url = new URL(u);\n            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n            httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n            BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n            googleImages.clear();\n            String text = \"\";\n            String lin = \"\";\n            while ((lin = readIn.readLine()) != null) {\n                text += lin;\n            }\n            readIn.close();\n            if (text.contains(\"\\n\")) {\n                text = text.replace(\"\\n\", \"\");\n            }\n            String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n            for (String s : array) {\n                if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                    String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                    googleImages.add(s1);\n                }\n            }\n        } catch (Exception ex4) {\n            MusicBoxView.showErrorDialog(ex4);\n        }\n        MusicBoxView.jButton7.setEnabled(true);\n        ImageIcon icon;\n        try {\n            icon = new ImageIcon(new URL(googleImages.elementAt(MusicBoxView.googleImageLocation)));\n            ImageIcon ico = new ImageIcon(icon.getImage().getScaledInstance(100, 100, Image.SCALE_SMOOTH));\n            MusicBoxView.albumArtLabel.setIcon(ico);\n        } catch (MalformedURLException ex1) {\n            MusicBoxView.showErrorDialog(ex1);\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["ip", "to", "link", "cat", "cp", "create", "cop", "cos", "download", "paste", "Copy", "pixel", "clip", "transfer", "split", "replace", "php", "core", "write", "co", "save", "init", "cross", "move", "clone", "sync", "py", "proxy", "same", "crop", "gc", "map", "opy", "zip", "delete", "Cop", "slice", "share"], "in": ["inf", "o", "IN", "l", "it", "inc", "inner", "cin", "ins", "el", "input", "inv", "re", "ind", "rin", "bin", "ir", "y", "up", "In", "inside", "is", "ini", "by", "ar", "act", "isin", "init", "con", "info", "old", "iter", "check", "ai", "from", "local", "gin", "mi", "id", "all", "en", "inn", "on", "sin", "ic", "net", "din", "i", "ie"], "out": ["o", "b", "n", "v", "to", "cache", "null", "conn", "l", "err", "it", "oss", "ex", "inner", "obj", "res", "store", "OUT", "at", "one", "base", "os", "y", "over", "io", "Out", "ou", "aos", "client", "end", "ver", "outer", "sys", "ch", "co", "write", "ot", "con", "port", "ion", "w", "t", "local", "log", "result", "ent", "gt", "set", "can", "all", "en", "op", "OU", "output", "outs", "on", "this", "tmp", "net", "not", "p", "nt"], "source": ["use", "space", "cause", "inner", "SOURCE", "key", "site", "input", "store", "system", "string", "index", "status", "template", "base", "sequence", "prefix", "language", "attribute", "style", "scan", "subject", "sql", "unit", "scope", "src", "lower", "sp", "title", "finder", "ource", "origin", "position", "Source", "ce", "search", "resource", "from", "service", "s", "format", "local", "start", "se", "range", "query", "relation", "sin", "shell", "this", "si", "ie", "select", "parent"], "target": ["tree", "goal", "to", "link", "print", "null", "step", "key", "test", "rel", "root", "tif", "location", "term", "that", "token", "template", "base", "table", "bolt", "style", "alias", "top", "other", "arg", "scope", "module", "arget", "origin", "url", "resource", "t", "local", "Target", "ARGET", "pattern", "gt", "query", "point", "match", "output", "translation", "dest", "join", "parent"], "files": ["reports", "objects", "images", "services", "members", "banks", "tools", "parts", "users", "uploads", "plates", "features", "lines", "iles", "pieces", "assets", "details", "balls", "les", "facts", "lets", "issues", "actions", "thumbnails", "resources", "headers", "jobs", "events", "books", "packages", "items", "fs", "modules", "workers", "models", "styles", "faces", "states", "values", "pages", "ports", "ls"], "file": ["entry", "tree", "rule", "print", "fe", "node", "data", "key", "full", "filename", "pe", "el", "play", "label", "folder", "child", "user", "image", "base", "name", "table", "document", "field", "feature", "line", "f", "ile", "row", "fp", "tile", "parent", "e", "work", "dir", "block", "word", "ve", "be", "port", "le", "resource", "File", "local", "library", "job", "model", "relation", "event", "path", "page", "foo", "FILE", "current", "item"], "inCh": ["inch", "cinch", "dinSam", "InChan", "inCor", "incCh", "rinCl", "cinCod", "rinChan", "inCr", "InCh", "rinCh", "rinCod", "incSam", "incCor", "InCod", "inChan", "dinCh", "inCl", "inCod", "outChan", "cinChan", "outch", "cinCr", " inChan", " inch", "dinCr", "inSam", "InCl", "cinCor", "incCr", " inCl", "outCod", "cinSam", "cinCh", "dinCor", " inCod"], "outCh": ["inch", " outCol", "newCh", " outCod", "newCol", "inCol", "outGr", "inChan", "outChan", " outch", "outch", "newCod", "newGr", " outChan", "outputCod", "newch", "outputGr", "outCod", "outCol", "outputChan", "outputCh", " outGr", "newChan"]}}
{"id1": "18164929", "id2": "22625683", "code1": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"isCodebaseDownloadable": ["isCodeBaseDownloadAvailable", "isCodebaseLoadAvailable", "isCodebasedownloaded", "isCodebaseDownloadAvailable", "isCodebaseLoaded", "isCodeBasedownloadAvailable", "isCodeBaseDownloadible", "isCodeBasedownloaded", "isCodebaseUploadible", "isCodebasedownloadAvailable", "isCodebaseDownloaded", "isCodebaseDownloadible", "isCodeBaseDownloaded", "isCodebasedownloadible", "isCodebasedownloadable", "isCodeBaseDownloadable", "isCodebaseLoadable", "isCodebaseUploaded", "isCodeBasedownloadable", "isCodebaseUploadAvailable", "isCodebaseLoadible", "isCodeBasedownloadible", "isCodebaseUploadable"], "p": ["pb", "d", "m", "o", "b", "v", "prop", "project", "np", "pkg", "cp", "h", "q", "pe", "pa", "c", "pro", "jp", "bp", "properties", "f", "tp", "fp", "u", "j", "lp", "e", "sp", "w", "t", "s", "P", "vp", "pp", "g", "r", "ps", "a"], "file": ["partial", "print", "link", "body", "total", "image", "status", "limit", "base", "name", "table", "error", "type", "line", "f", "ile", "fp", "offset", "dir", "title", "info", "port", "resource", "File", "format", "complete", "id", "content", "path", "message", "page", "length", "action", "FILE", "item", "source"], "codebase": [" codebas", " codease", " codebind", "codebas", "cachebase", "codebasic", "corebase", " codingbind", "cachebasic", "coebase", "cachebuffer", "corebas", "codbas", "Codebased", "corebased", "Codebase", "codebuffer", "codeBase", " codingbase", "codase", "CodeBase", "coebased", "corease", "Codebind", "corebasic", "keybasic", "codebased", " codeBase", "codebind", "keybase", "coeBase", "codease", " codingBase", "codbased", "keybuffer", " codebased", "keybas", "corebuffer", "cachebas", "codbase"], "cbUrl": ["cpUr", "cbEl", "cdOb", "sbOb", "sbIs", "cdURL", "sbURL", "cfgUr", "gbUr", "obbURL", "bbUr", "gbUrl", "ctrlIs", "cfgUrl", "cfgEl", "sburl", "ctrlUr", "gbURL", "ctrlInt", "cpURL", "cbURL", "ctrlUrl", "cbOb", "ctrlEl", "rburl", "cpEl", "fbUrl", "tcSl", "sbUrl", "bbSl", "cburl", "bbUrl", "ctrlurl", "obbUr", "obbUrl", "fbURL", "rbURL", "cpurl", "cbInt", "tcUrl", "obbOb", "cdUr", "cbSl", "tcURL", "sbUr", "gburl", "fbUr", "tcUr", "gbInt", "cbUr", "cfgURL", "cpSl", "rbUrl", "cdUrl", "cpUrl", "fbIs", "ctrlURL", "cbIs", "cpInt", "rbUr", "bbURL"], "protocol": ["patotype", "Protility", "Proticle", "Protocol", "bisility", "bisocol", "tocol", "totype", "pronrol", "pronotype", "proticle", "bisotype", "protrol", "tility", "prototype", "Prototype", "bisicle", "pronicle", "patrol", "pronocol", "paticle", "ticle", "Protrol", "protility", "patocol"], "filename": ["ename", "key", "til", "software", "string", "location", "directory", "username", "name", "prefix", "FILE", "fn", "fil", "river", "f", "json", "Filename", "fp", "ername", "assembly", "src", "ame", "title", "lower", "txt", "word", "resource", "names", "File", "nil", "fle", "binary", "path", "message", "stem", "family", "length", "text", "uri", "source"], "size": ["pos", "Size", "izes", "sum", "body", "equal", "name", "notice", "SIZE", "count", "send", "offset", "iz", "ze", "mem", "ms", "fee", "bytes", "sent", "s", "start", "ize", "empty", "z", "eng"], "files": ["reports", "frames", "objects", "images", "classes", "blocks", "members", "parts", "users", "plates", "features", "seconds", "iles", "links", "bees", "assets", "stars", "balls", " Files", "tests", "thumbnails", "Files", "resources", "headers", "videos", "bytes", "names", "packages", "items", "modules", "workers", "groups", "models", "fs", "faces", "sections", "pages", "ports", "mails"], "st": ["d", "sh", "rest", "l", "it", "ast", "step", "space", "rt", "St", "ste", " St", "std", "ST", "ss", "stage", "ft", "ct", "end", "str", "trans", "est", "sp", "nd", "ut", "stack", "mt", "inst", "t", "sts", "sta", "s", "se", "start", "ost", "tt", "sl", "sw", "set", "ist", "stru", "r", "stable", "stuff", "net", "ust", " ST", "stem", " est", "z", "stop", "nt"], "url": ["browser", "http", "b", "pl", "link", "conn", "web", "l", "socket", "ll", "cp", "html", "address", "key", "rel", "obj", "el", "uri", "base", "pro", "email", "char", "client", "f", "il", "mail", "ul", "ret", "org", "ssl", "ur", "nl", "mount", "https", "URL", "gl", "t", "handle", "impl", "service", "loader", "log", "Url", "tool", "host", "r", "addr", "path", "util", "or", "ob", "ls"], "part": ["thing", "partial", "rest", "pos", " Part", "pt", "val", "step", "span", "key", "parts", "body", "joined", "string", "base", "split", "name", "prefix", "pad", "str", "var", "trans", "top", "pair", "sp", "sample", "pet", "work", "and", "info", "PART", "par", "word", "with", "patch", "Part", "t", "local", "from", "se", "piece", "start", "pre", "point", "r", "tmp", "place", "path", "page", "art", "join"], "data": ["d", "entry", "summary", "to", "batch", "cache", "list", "ad", "record", "step", "dat", " DATA", "session", "key", "extra", "rel", "found", "user", "no", "obj", "instance", "what", "image", "video", "state", "response", "group", "table", "area", "error", "details", "writer", "client", "json", "DATA", "join", "row", "valid", "ata", "module", "dir", "info", "block", "results", "next", "metadata", "value", "format", "fd", "result", "def", "all", "content", "relation", "object", "good", "default", "db", "output", "this", "message", "done", "action", "text", "item"], "len": ["syn", "pos", "val", "l", "ll", "yn", " Len", "elt", "body", "el", "seq", "msg", "fn", "wid", "lon", "qual", "fin", "enc", "mem", "nl", "lim", "cap", "cb", "cmp", "lan", "ln", "vec", "dec", "mn", "mat", "del", "Len", "en", "ail", "repl", "ren", "mid", "gz", "mult", "ls"], "success": ["submit", "summary", "access", " Success", "continue", "Success", "serial", "secondary", "pass", "index", " succ", "failed", "process", "status", " successful", "msg", " proceed", "accept", "error", "platform", "client", "danger", "social", "global", "sys", "top", "first", "rc", "ata", "comment", "setup", "info", " successes", "results", "primary", "complete", "successfully", "result", "master", " succeeds", "successful", "progress", " successfully", "close", "photo", "good", "default", " suc", "fail", " succeed", "control", "length", "ready", "select"]}}
{"id1": "21425787", "id2": "310182", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "transferFile", "copyfile", " copyFiles", "copyFiles", "CopyByte", " copyByte", "Copyfile", "transferByte", "CopyFile", "transferFiles", "copyByte", "transferfile", " copyfile"], "in": ["inf", "o", "b", "n", "IN", "l", "inc", "it", "cin", "ins", "el", "input", "ind", "vin", "rin", "up", "In", "is", "ar", "isin", "old", "from", "gin", "en", "inn", "on", "ic", "din", "i", "ie", "source"], "out": ["o", "b", "n", "v", "to", "null", "l", "ex", "err", "it", "source", "oss", "OUT", "at", "c", "os", "Out", "ou", "io", "str", "ot", "w", "t", "s", "help", "ent", "gt", "g", "output", "outs", "po", "net", "i", "ne", "p", "nt"], "sourceChannel": ["inputConnection", "inputChan", "sourceManager", "startPanel", " sourceClass", "seedCategory", "seedPanel", "srcConnection", "sourceChan", "sourceCommand", "srcClass", "systemChannel", " sourceCommand", "ourceManager", "srcChan", "inputChannel", " sourceManager", "ourceChan", "srcManager", "ourceClass", " sourceCh", " sourceConnection", "sourcePanel", "sourceCategory", "ourceChannel", "ourceConnection", "sourceMachine", "systemCategory", "sourceConnection", "ourceCommand", "startCategory", "startMachine", "srcCh", "seedMachine", "systemPanel", "seedChannel", "inputCh", "sourceCh", "srcChannel", "sourceClass", "srcCommand", " sourceChan", "startChannel", "systemMachine"], "destinationChannel": ["destationChannel", "destinationsConnection", "DestationChan", "destinatorHandler", "destationchannel", "destationConnection", "destinationConnection", "destinatorChannel", "destensionchannel", "DestensionChannel", "destinatedContext", "destinoChan", "DestensionConnection", "DestinationConnection", "restinoChannel", "destinationHandler", "restinochannel", "Destationchannel", "Destensionchannel", "restinoContext", "DestationHandler", "restinationChannel", "destinoChannel", "DestinationChannel", "destinatedChan", "destinationsChan", "restinationContext", "destensionChannel", "destinochannel", "destinationchannel", "destensionChan", "destinationschannel", "restinoChan", "DestationChannel", "DestinationHandler", "destinationContext", "DestensionChan", "destationChan", "destinationChan", "Destinationchannel", "destinoContext", "destinatorChan", "restinationChan", "DestinationChan", "destationHandler", "destensionConnection", "destationContext", "destinatedChannel", "destinationsChannel", "restinationchannel", "destinatorchannel", "destinatedchannel"]}}
{"id1": "6906419", "id2": "16621503", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["decryptPassword", "encryptedString", "encryptedPassword", "decryptedpassword", "decryptedPassword", "encryptionPassword", "encryptionPass", "encryptionpassword", "encryptString", "decryptpassword", "encryptedpassword", "decryptString", "enccryptpassword", "encryptPass", "decryptPass", "decryptedPass", "enccryptString", "enccryptPass", "decryptedString", "enccryptPassword", "encryptionString", "encryptedPass", "encryptpassword"], "password": ["Password", "shadow", "print", "secret", "command", "data", "address", "key", "reset", "user", "pass", "input", "string", "padding", "database", "username", "token", "sword", "name", "login", "prefix", "description", "attribute", "email", "wd", "phrase", "auth", "word", "value", "pattern", "wordpress", "hello", "default", "message", "text"], "digest": ["decester", "Digested", "hashse", "minist", "Digest", " digested", " digEST", " digester", "Digist", "persested", "decse", "hashest", "DigEST", "digested", "hashester", "decest", "minest", "persester", "minested", " digse", "Digse", "decested", "digester", "digEST", "dester", "minester", "digist", "persist", "digse", "dest", "dested", "persest", "hashEST", "Digester", "dse"], "hash": ["ashes", "have", "report", "cache", "sh", "print", "ash", "her", "html", "hed", "address", "sum", "h", "filter", "has", "square", "memory", "test", "rh", "total", "esh", "mac", "array", "table", "hist", "attribute", "Hash", "ah", "dig", "score", "where", "alt", "hex", "block", "check", "search", "mask", "handle", "map", "oh", "here", "query", "all", "match", "stock", "host", "share", "hz", "history", "shift", "sha", "height"], "buf": ["pb", "b", "batch", "Buffer", "bh", "hung", "np", "pkg", "window", "fam", "mu", "msg", "bu", "rb", "uf", "cmd", "bar", "alph", "cf", "ob", "bag", "queue", "img", "agg", "bo", "func", "usr", "conv", "var", "bg", "buff", "cap", "cb", "box", "off", "br", "vec", "forge", "font", "fb", "cv", "block", "printf", "etc", "bc", "nb", "tmp", "db", "mb", "Buff", "pool", "buffer", "foo", "txt"], "i": ["m", "b", "ip", "v", "ci", "ui", "n", "multi", "to", "print", "in", "it", "ex", "ji", "ei", "gi", "key", "I", "q", "phi", "major", "index", "ind", "im", "\u0438", "c", "y", "oi", "ini", "ii", "li", "is", "iq", "ski", "iu", "io", "f", "ie", "bi", "json", "u", "pi", "j", "conv", "e", "init", "me", "info", "cli", "zi", "ri", "go", "ai", "sim", "t", "mi", "ti", "ix", "hi", "exp", "id", "point", "get", "g", "di", "my", "a", "ic", "x", "si", "slice", "xi", "qi", "uri"], "halfbyte": [" halflen", "Halfletter", " halfpiece", "Halfbuffer", "halfchar", "quarterpage", "phybyte", "halfpair", "phychar", "leftbuffer", "phypiece", "phypair", "halfletter", "quarterletter", "phybytes", "Halfpixel", "halflen", "quarterbyte", "quarterchar", "Halfpiece", "quarterword", "quarterlen", " halfcoin", "leftnode", "quarterpair", "halfbytes", " halfpage", " halfbytes", "halfpiece", " halfchar", "halfchannel", "quarterchannel", "halfword", "Halfword", "quartercoin", "phypixel", "Halfchar", " halfword", "Halfpage", "halfpage", " halfnode", "Halfnode", "phylen", " halfchannel", "halfbuffer", "Halfchannel", " halfletter", "quarterpixel", "leftchar", "leftbyte", " halfpixel", " halfpair", "halfpixel", "Halfcoin", "Halfbyte", "halfcoin", " halfbuffer", "Halfbytes", "halfnode"], "two_halfs": ["two_halfi", "two_halfups", "two_halfsets", "two_enthalisters", "two_enthals", "two_shakeisters", "two_turni", "two_parens", "two_halfss", "two_parenls", "two_parenups", "two_shakess", "two_ledsets", "two_leds", "two_halfls", "two_rounds", "two_halfisters", "two_pareni", "two_ledss", "two_roundups", "two_enthalss", "two_shakes", "two_roundls", "two_turnls", "two_roundi", "two_enthalsets", "two_shakesets", "two_ledisters", "two_turnups", "two_turns"]}}
{"id1": "14783950", "id2": "5744493", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compresswithzip", "composeWithZip", "composeWithzip", "compresswithExt", "compresswithFiles", "compressWithFiles", "compresswithZip", "compressByzip", "composeWithoutzip", "compressWithExt", "compressWithoutzip", "compressWithzip", "compressByExt", "composeWithExt", "composeWithoutFiles", "composeWithFiles", "compressByZip", "compressByFiles", "composeWithoutZip", "compressWithoutZip", "compressWithoutFiles", "composeWithoutExt", "compressWithoutExt"], "fileList": [" fileLIST", "wordList", "fileSet", "fileLIST", "wordLIST", " filelist", " FileSet", " FileCode", "itemNames", "wordIterator", " fileSet", "fileL", " fileL", "itemLock", " fileIterator", "itemList", "fileNames", "pageList", "resourceList", " fileLock", "ileList", "fileCode", "resourceLock", "fileLock", "tileList", "pageLIST", " FileLIST", "pageSet", " fileNames", " fileCode", "tileIterator", "filelist", "pageCode", "tileLIST", "tileSet", "ileL", "wordSet", "resourceNames", "ileLIST", "pageL", " FileList", "ilelist", "fileIterator", "pagelist"], "zipFileName": [" zipfileNames", "zipfileFilename", "zipDirNames", " zipFilePath", "zipDirName", " zipFileNames", "zipilePath", "zipfileName", "zipFilePath", "zipFilename", "zipFilenameName", "zipileName", "zipFilenameNames", "zipilename", "zipFileNames", "zipfileNames", "zFileFilename", "zipDirPath", " zipFileFilename", "zFilename", "zFileName", "zFilenameName", "zipFileFilename", " zipfilePath", "zipFilenamePath", "zipDirFilename", "zFilePath", " zipfileName", "zipFilenameFilename", "zFilenamePath", "zipileFilename", " zipfileFilename", "zipFilenamename", "zipfilePath", "zipfilename", "zFilenameFilename", "zFilenamename"], "fos": ["flOS", "los", "foos", "fOS", "Foss", "flis", "Foos", " foos", "woss", "Fos", "wos", "floos", "lOS", "loss", "foss", "FOS", "lfOS", "flos", "loos", "wOS", "lfos", " fOS", "woos", "lfoos", "lfis"], "zos": ["enos", "iners", "enz", "css", "zero", "bes", "js", "oss", "less", "zar", "los", "ws", "sis", "sbm", "ez", "zb", "hess", "zin", "webkit", "zik", "zag", "os", "ss", "zers", "zer", "eros", "zzle", "zu", "ze", "cz", "za", "rez", "zen", "zon", "zes", "ippers", "zo", "Sax", "es", "ses", "ossus", "zh", "jas", "nz", "iaz", "han", "zan", "rys", "zip", "hz", "ps", "ess", "z", "zi"], "iter": ["ip", "list", "walker", "it", "tr", "ipper", "inner", "fer", "cer", "loop", "ner", "ser", "former", "ator", "kit", "re", "user", "el", "orient", "ee", "ir", "reader", "maker", "vis", "loc", "iv", "is", "li", "Iterator", "its", "izer", "ver", "outer", "valid", "ter", "ger", "where", "ptr", "er", "liter", "iterator", "oper", "coll", "loader", "here", "exp", "train", "inter", "iner", "Iter", "order", "ait", "iver", "i", "gener"], "fileName": ["fileSource", "fileStore", "fieldName", " fileCurrent", "getname", "ilePath", "fileNumber", "fileSet", "fname", " fileStore", "fName", "FileNames", "tableSet", "fieldNAME", " filePath", "ileSet", "ileCurrent", " fileSet", "ileBody", "filename", "localname", "ileNAME", "tablePath", "getSource", "shortname", "fileNames", "ileSource", "ileString", "fileString", "getName", "localName", "ileList", "getStore", " fileString", "localList", "fileBody", "fileNAME", "Filename", " fileSource", "FileName", "ileNumber", "fSource", " fileBody", "ilename", "shortStore", "localNAME", " fileNames", "FilePath", "FileCurrent", "tableName", "fBody", "FileString", "ileName", " filename", "filePath", "fNumber", "fString", " fileNumber", "fNames", "fieldname", "fieldList", "fileCurrent", "shortSource"], "ind": ["d", "pred", "pl", "n", "att", "roll", "Ind", "pos", "ld", "md", "inc", "cd", "num", "dial", "wind", "index", "bind", "seed", "req", "med", "cond", "cand", "ded", "mod", "loc", "red", "count", "j", "nd", "sign", "div", "draw", "td", "ptr", "mind", "inder", "dj", "IND", "ent", "cod", "hend", "find", "typ", "kind", "stick", "inn", "i", "butt"], "shortName": ["quickname", "shortKey", "recentname", " shortname", "fullType", "ShortName", "smallName", "ShortString", "shortname", "recentCode", "quickName", "Shortname", " shortString", "recentFilename", "recentName", "fullString", "smallCode", "ShortFilename", "quickString", "ShortType", "smallFilename", "shortType", "ShortKey", "fullName", " shortKey", "ShortCode", "shortCode", "smallname", "fullname", "shortFilename", " shortType", "quickKey", "shortString"], "fis": [" fIs", "hois", " fris", "cfris", "fIs", "pis", "ufois", "sfIs", "ufis", "hris", "cfis", "FIs", "cfi", "cfois", "ufris", "ufi", "wIs", "fi", "ufIs", "Fris", "wis", "pi", "wi", "his", "wois", "Fis", "sfois", "sfi", "sfis", "pois", "pris", "fois", "fris", "hi"], "buf": ["b", "batch", "aka", "Buffer", "tab", "cat", "tr", "pkg", "buffer", "fam", "mu", "msg", "seq", "bin", "arr", "uf", "bar", "cmd", "rb", "bag", "bed", "var", "img", "ref", "mem", "fg", "br", "buff", "cap", "cb", "box", "bytes", "block", "vec", "fb", "cur", "cv", "wb", "bc", "bl", "db", "Buff", "temp", "conv", "orig", "bus"], "bytesRead": ["bytesNeed", "linesNeed", "linesWritten", " bytesLoad", " bytesWritten", "BytesNeed", "bytesLength", "postsRead", "blocksLoad", " bytesNeed", "usersFind", " bytesWrite", "BytesWritten", "secondsWrite", "secondsWritten", "BytesLength", "usersLoad", "flowsReady", "bytesFind", "flowsLoad", "linesRead", "postsLoad", "secondsRead", " bytesLength", "blocksRead", "postsReady", "blocksWrite", "bytesReady", "flowsRead", "bytesWrite", "postsFind", "linesLength", "usersRead", "bytesLoad", "BytesRead", "secondsLoad", "usersReady", "bytesWritten", "blocksWritten", "flowsFind"]}}
{"id1": "22560224", "id2": "19206412", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"hashStringMD5": [" hashStringMT0", " hashStringSHA0", " hashStringSHA1", " hashStringSHAHash", " hashStringSMHash", " hashBytesMT5", " hashBytesMD5", " hashStringSHA5", " hashStringSM0", " hashBytesMD1", " hashBytesMTHash", " hashStringMD0", " hashStringMTHash", " hashBytesMT0", " hashBytesMT1", " hashStringSM1", " hashBytesMDHash", " hashStringMT5", " hashStringSM5", " hashStringMDHash", " hashBytesMD0", " hashStringMT1", " hashStringMD1"], "string": ["setting", "strings", "v", "print", "list", "null", "space", "data", "function", "address", "ring", "test", "filename", "site", "input", "array", "name", "sequence", "prefix", "password", "char", "str", "number", "sql", "comment", "word", "value", "format", "file", "s", "service", "result", "content", "spec", "object", "host", "ident", "message", "buffer", "text", "source"], "md": ["d", "m", "amd", "ad", "cd", "ld", " Md", "mand", "mode", "bd", "pd", "hd", "grad", "MD", "desc", "mm", "dist", "Cmd", "det", "od", "dr", "ind", "cond", "mod", "down", "cmd", "dd", " MD", "red", "der", "df", "pdf", "ms", "nd", "dir", "and", "dh", "mc", "mt", "mn", "add", "mk", "sm", "alg", "sd", "dm", "di", "mb", "de", "nt"], "byteData": ["helloBytes", "viewData", "helloData", "byteLens", "componentBytes", "ByteBuffer", "wordDATA", "nodeBuffer", "phraseBytes", "seeLens", "displaydata", " ByteBuffer", "byteDo", "displayData", "charDATA", "charData", "ByteParts", "byteParts", " ByteForm", " ByteLens", "ByteBytes", "viewdata", "phraseData", " byteParts", "displayCount", "byteDATA", "nodeLens", "wordData", "helloDo", "viewDo", "helloDat", " byteDATA", "phraseDo", "chardata", "ByteData", "worddata", "displayDo", " ByteData", " byteBytes", "seeForm", " byteBuffer", "byteBytes", "nodeForm", "nodeData", "componentBuffer", "componentData", "byteDat", " bytedata", "ByteDat", " byteCount", "byteForm", "bytedata", "seeData", " byteDo", "phraseDat", "byteCount", "ByteDo", "seeBuffer", "byteBuffer", "componentParts", "viewCount"], "sb": ["pb", "b", "sh", "bj", "bh", "web", "ws", "bash", "zb", "lb", "bt", "rb", "alph", "sa", "ssl", "sv", "bf", "sam", "sp", "bg", "src", "cb", "ib", "sync", "sf", "kb", "sth", "soc", "bsp", "sw", "gb", "bb", "sc", "eb", "xb", "nb", "mb", "shell", "bs", "sg", "erb", "SB", "sq"], "i": ["m", "ip", "print", "list", "in", "it", "ei", "q", "c", "y", "ini", "io", "kj", "client", "ity", "bi", "pi", "me", "init", "mi", "ix", "hi", "o", "v", "ex", "span", "im", "base", "oi", "ki", "ii", "gu", "any", "j", "set", "id", "ic", "I", "xi", "z", "uri", "ci", "ui", "batch", "err", "\u0438", "iq", "iu", "info", "ai", "di", "iy", "history", "remote", "si", "ie", "zi", "ij", "multi", "yi", "gi", "chain", "phi", "us", "cgi", "name", "li", "ski", "json", "cli", "er", "ri", "series", "point", "g", "this", "my", "ti", "conv", "ji", "qi"], "hexString": [" hexStr", "exString", "httpString", " hexSet", "pexString", "serialString", "sexStatement", " hexSite", "exSocket", "sexList", "viewNumber", "exStatement", "expString", "sexSocket", "exText", " hexBuffer", "pexList", "hexSocket", "sexString", "alphaString", "alphaStr", "viewString", "viewSet", "hexBuffer", " hexNumber", " hexText", "exBuffer", "expSet", "hexScreen", "pexSocket", "hexText", "viewBuffer", "alphaSite", "hexSet", " hexScreen", "alphaScreen", "hexSite", "serialBuffer", "hexStatement", "httpSite", "pexStatement", "expNumber", "exList", "hexStr", "hexNumber", "exStr", "hexList", "httpStr", "httpScreen", "serialStr", "serialText", "expBuffer"], "hex": ["comp", "ip", "raw", "sh", "print", "prop", "tex", "ex", "rex", "html", "cat", "full", "oct", "h", "hash", "sex", "rh", "term", "ext", "hl", "pex", "xf", "des", "aux", " sex", "hp", "char", "form", "json", " Hex", "cont", "sv", "buff", " ex", "none", "cmp", "he", "com", "handle", "dump", "exp", "hw", "ph", "tx", "zh", "lit", "def", "hello", "hz", "x", "hi"]}}
{"id1": "5683576", "id2": "19910627", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "label": 0, "substitutes": {"shorten": [" Shortens", "Shorten", " Shorten", "Shortense", "shortener", " Shortener", "shortens", " shortens", "Shortens", " shortener", "Shortener", " Shortense", " shortense", "shortense"], "url": ["http", "b", "link", "web", "l", "html", "ll", "address", "key", "user", "string", "location", "p", "username", "base", "name", "document", "password", "str", "json", "ul", "api", "dl", "ret", "domain", "version", "URL", "format", "pattern", "log", "Url", "sl", "id", "host", "path", "message", "page", "ls"], "qparams": ["qualpackages", "Qpins", "sqParameters", "qParameters", "qualparams", "sqblocks", "sqdetails", "qvparams", "iqterms", "QParameters", "quargs", "qsparams", "qnames", "qsparam", "qqparams", "qpins", "qvargs", "qvfields", "sqams", "iqoptions", "dqmembers", "iqmarks", "qunames", "Qparams", "sqparams", "iqpins", "qualparts", "iqmembers", "qudetails", "quparts", "iqParameters", "dqparam", "iqnames", "qdetails", "quparam", "qparts", "sqnames", "qvparam", "sqparts", "qmembers", "sqparam", "qpackages", "qmarks", " qdetails", "sqoptions", "iqblocks", "quparams", " qargs", "qualparam", "sqpins", "qterms", " qams", "qqargs", "qblocks", "qumembers", "qoptions", "quams", "sqterms", "qparam", "qargs", "qsargs", "dqmarks", "qupins", "qqparam", "Qparam", "iqparam", "sqpackages", "qams", "sqargs", "dqparams", "qublocks", "quterms", "qupackages", "qfields", "iqparams", "qsfields", "qumarks", "quoptions", "qqfields"], "params": ["types", "settings", "cp", "data", "keys", "parts", "ctx", "options", "mm", "parser", "cms", "param", "rs", "caps", "details", "properties", "ams", "json", "api", "Parameters", "pi", "atos", "AMS", "Par", "parent", "headers", "names", "changes", "pres", "config", "spec", "conf", "stats", "ps", "pps", "gs", "terms", " parameters", "eters"], "httpclient": ["httpscache", "httpcli", " httpmanager", "Httpclient", "httpsconnection", " httpcache", "httpClient", "httpscli", "Httpcli", "Httpconnection", " httpcli", "Httpmanager", "httpmanager", "httpcache", "httpsClient", "httpsmanager", " httpconnection", "Httpcache", "httpsclient", " httpClient", "HttpClient", "httpconnection"], "uri": ["http", "wiki", "ui", " URI", "html", "universal", "address", "iri", "filename", "uni", "ugi", "via", "folder", "location", "database", "term", "base", "prefix", "description", "subject", "api", "u", "pi", "unit", "ur", "domain", "du", "origin", "URI", "ri", "doi", "resource", "nu", "range", "query", "storage", "path", "remote", "i", "qi", "source"], "httpget": ["httpsget", "httpscreate", "HTTPsearch", "httpcall", "hoverrequest", "httpscall", "httpull", "httGet", "ttpget", "ttprequest", "HTTPget", "hoverGet", "httpsearch", " httpGet", "ttpGet", "HTTPGet", " httpsearch", "httpcreate", "httget", "httcreate", "hoverquery", " httpcreate", "httcall", " httppull", "httquery", "hoverget", " httpcall", "httpGet", "httpspull", "httrequest", "httpquery", "httppull", "httprequest", "ttpsearch", "ttpquery"], "response": ["http", "entry", "report", "summary", "resp", "body", "respond", "onse", "one", "status", "image", "yes", "answer", "document", "still", "sequence", "description", "json", "connection", "application", "reply", "request", "block", "result", "Response", "close", "successful", "success", "content", "object", "output", "message", "given", "page", "out", "frame"], "entity": ["orm", "entry", "tex", "node", "body", "obj", "pe", "eme", "el", "Entity", "activity", "image", "ee", "status", "document", "person", "error", "oe", "email", "client", "json", "ity", "icon", "enc", "valid", "e", "em", "info", "ce", "peer", "le", "resource", "existent", "result", "existing", "om", "ent", "member", "encrypted", "content", "object", "good", "event", "output", "empty"], "instream": ["inputloader", "inputstream", "inputform", "intloader", "outform", "imstream", " inconsole", " inStream", "intcase", "intstream", "inconsole", "inStream", "outconsole", "outstream", "imcase", "inputcase", "INconsole", "imform", " inform", "imloader", "INstream", "inloader", "INform", "incase", "outStream", "intform", "INStream", "inform"], "f": ["v", "l", "alf", "full", "tf", "fab", "F", "c", "fo", "ff", "uf", "fi", "cf", "rf", "ct", "df", "fp", "fg", "bf", "fm", "e", "fac", "sf", "af", "w", "Factory", "t", "fd", "fs", "lf", "ph", "foreign", "fr", "conf", "of", "fx", "p"], "jp": ["pb", "parse", "bj", "conn", "js", "np", "pkg", "cp", "ja", "jo", "wp", "dp", "obj", "gp", "java", "hp", "kj", "bp", "fps", "adj", "jj", "jump", "tp", "fp", "pai", "eps", "j", "lp", "sp", "xp", "JP", "pas", "iat", "peg", "mp", "uj", "jl", "dj", "vp", "jas", "jen", "jc", "Ja", "fr", "op", "ijk", "prot", "ps", "p"], "responseObj": [" responseCtrl", "requestCtrl", "responseBody", "responseCtrl", "ResponseCtrl", "requestObject", "ResponseBody", "replyVal", " responseOb", "ResponseOb", "requestObj", "responseObject", "responseOb", "responseVal", "requestOb", "ResponseObject", "replyBody", " responseBody", " responseObject", "ResponseVal", "ResponseObj", "replyObj", " responseVal", "replyObject"], "token": ["browser", "tree", "KEN", "to", "parse", "zero", "list", "pointer", "step", "operator", "node", "span", "key", "session", "function", "data", "reset", "oken", "no", "total", "atom", "template", "state", "name", "tick", "table", "field", "document", "ski", "type", "topic", "notice", "error", "number", "json", "when", "j", "kn", "stat", "lex", "note", "element", "word", "task", "next", "normal", "value", "Token", "t", "local", "complete", "start", "variable", "trigger", "relation", "typ", "kt", "object", "ok", "event", "initial", "tag", "before", "channel", "buffer", "txt", "current", "p"], "fieldname": ["ieldtype", "fieldName", "columnName", "columnid", "keyval", "FIELDName", "fieldkey", "FIELDkey", "ieldlen", "columnname", "keyname", " fieldtype", "FIELDval", "Fieldval", "FIELDlen", "Fieldname", "cellname", "cellName", "Fieldkey", " fieldkey", " fieldlen", "FIELDname", "columnkey", "FIELDtype", " fieldName", "ieldName", "fieldid", "fieldtype", " fieldid", "ieldname", "keyName", "fieldlen", "cellkey", "fieldval", "cellid", "keykey", "FieldName"]}}
{"id1": "14473781", "id2": "4830847", "code1": "        @Override\n        protected String doInBackground(Void... params) {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpContext localContext = new BasicHttpContext();\n            HttpPost httpPost = new HttpPost(urlFormated);\n            try {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for (int index = 0; index < POSTparamList.size(); index++) {\n                    if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) {\n                        entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue())));\n                    } else {\n                        entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue()));\n                    }\n                }\n                httpPost.setEntity(entity);\n                HttpResponse response = httpClient.execute(httpPost, localContext);\n                return processAnswer(response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doAsRequest", "doInAsync", "doAsAsync", " doInsideRequest", " doInsideAsync", " doOnAsync", " doAsFuture", " doAsAsync", " doInsideBackground", " doOnRequest", " doAsBackground", " doInRequest", "doAsRequest", "doAsBackground", "doInRequest", " doInsideFuture", "doInFuture", " doInFuture", "doAsFuture", " doInAsync", " doOnBackground", " doOnFuture"], "params": ["errors", "images", "list", "settings", "tags", "services", "data", "parts", "proc", "ctx", "options", "Param", "posts", "param", "details", "properties", "ams", "Parameters", "cas", "sql", "files", "config", "conf", "ps", "values", "terms", "vals"], "httpClient": ["httpsSystem", "httpsControl", "htmlSystem", "httpclient", "httpContext", "hoverContext", "hoverSystem", "httpConnection", "ttpSystem", "htmlControl", "hoverClient", "htmlClient", " httpConnection", " httpclient", "httpSystem", "ttpConnection", "htmlContext", "httpsClient", "ttpClient", "httpsContext", "ttpclient", "httpsclient", "httpsConnection", "hoverControl", " httpSystem", "httpControl"], "localContext": ["localPort", "sessionContext", "currentCase", "LocalContext", " localState", "privateContext", "localCondition", "privatePort", "currentState", "LocalState", "sessionCase", "Localcontext", " localPort", "localcontext", "LocalPort", " localCase", "sessionState", "currentContext", "localCase", "localState", " localCondition", "privatecontext", "sessionCondition", " localcontext", "currentCondition", "privateState"], "httpPost": ["hoverPOST", "workPut", "ttppost", "httpPOST", "ttpPut", " httppost", "ttpPre", " httpPre", "HttpPOST", " httpPut", "httpsPut", "httpsPost", " httpPOST", "hoverPost", "httpsPre", "httpPut", "HttpPut", "workPre", "workPost", "httppost", "httpPre", "workPOST", "ttpPost", "HttpPost", "ttpPOST", "HttpPre", "httpsPOST", "hoverpost"], "entity": ["orm", "entry", "security", "rule", "complex", "command", "policy", "create", "xml", "data", "body", "iam", "pe", "el", "ell", "eme", "unique", "total", "Entity", "activity", "image", "one", "template", "base", "group", "table", "document", "person", "secure", "details", "oe", "collection", "email", "unit", "ment", "note", "comment", "and", "put", "ce", "metadata", "intent", "internal", "local", "result", "needed", "auto", "ent", "created", "member", "encrypted", "quote", "object", "component", "event", "output", "empty", "translation", "net", "channel", "or", "line"], "index": ["capacity", "zero", "access", "num", "axis", "key", "major", "loop", "state", "unknown", "loc", "layout", "mix", "iter", "go", "connect", "exp", "ix", "stick", "get", "scroll", "length", "i", "select", "ox", "pos", "ex", "Index", "address", "sequence", "prefix", "open", "row", "offset", "lex", "mount", "column", "version", "position", "coll", "IND", "config", "set", "success", "find", "see", "ax", "x", "insert", "scale", "inc", "date", "ind", "image", "shape", "eight", "document", "author", "context", "note", "active", "request", "check", "search", "ask", "max", "all", "match", "initial", "empty", "each", "EX", "condition", "create", "seek", "name", "error", "number", "osit", "draw", "sync", "size", "add", "point", "update", "slice", "display", "height", "instance"], "response": ["entry", "pos", "data", "xml", "resp", "body", "respond", "res", "onse", "image", "answer", "sequence", "document", "still", "json", "social", "api", "connection", "context", "application", "e", "reply", "request", "results", "zone", "value", "service", "respons", "result", "Response", "content", "object", "hello", "view", "output", "message", "page", "frame", "tree"]}}
{"id1": "17683082", "id2": "4599372", "code1": "    HttpRepository(Path path) throws IOException {\n        super(path);\n        this.url = new URL(path.toURLString());\n        HttpURLConnection.setFollowRedirects(true);\n        this.connection = (HttpURLConnection) url.openConnection();\n        this.ns = Names.getNamespace(path);\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"IOException": [" ioError", "DownloadEx", " ioProblem", " ioEx", "DownloadProblem", " ioException", "IOEx", "DownloadException", " IOError", " IOEx", "DownloadError", "IOProblem", " IOProblem", "IOError"], "url": ["http", "pl", "att", "access", "link", "conn", "web", "l", "ll", "rel", "re", "hl", "base", "loc", "char", "client", "str", "abs", "ul", "ssl", "ret", "dl", "org", "ur", "nl", "bel", "mount", "https", "URL", "gl", "file", "resource", "gc", "impl", "log", "Url", "sl", "fl", "sb", "path", "util", "channel", "ls"], "connection": ["link", "conn", "condition", "socket", "pointer", "network", "session", "connected", "system", "database", "response", "Connection", "c", "document", "io", "handler", "client", "engine", "context", "application", "port", "connect", "resource", "relation", "object", "pool", "page", "channel"], "ns": ["n", "NS", "res", "na", "rs", "Ns", "gs", "ss", "fn", "ny", "sys", "ms", "cs", "sn", "names", "s", "ts", "nm", "es", "fs", "ps", "bs", "net", "ds", "ne", "ls", "cn", "nt"]}}
{"id1": "14878593", "id2": "1357662", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": [" hyperLinkUpdate", " hyperlinkUpdated", "hyperloadUpdated", "hyperlineUpdate", "hyperlineClick", " hyperlinkupdate", " hyperLinkUpdated", " hyperlinkClick", "hyperLinkupdate", "hyperloadupdate", "hyperLinkUpdated", " hyperLinkupdate", "hyperlineupdate", "hyperloadUpdate", "hyperlinkupdate", "hyperlinkClick", "hyperlineUpdated", "hyperlinkUpdated", "hyperLinkUpdate", " hyperLinkClick", "hyperLinkClick", "hyperloadClick"], "e": ["d", "o", "m", "v", "n", "b", "ed", "l", "err", "ex", "fe", "it", "h", "esc", "el", "re", "eeee", "one", "ee", "c", "oe", "f", "ie", "ue", "eur", "u", "ge", "ame", "eu", "er", "ve", "ce", "ev", "w", "t", "s", "te", "se", "es", "ent", "E", "eg", "en", "ef", "ae", "event", "r", "ec", "Event", "de", "a", "et", "ea", "p"], "url": ["browser", "http", "pl", "link", "web", "l", "ll", "html", "rl", "address", "rel", "filename", "el", "re", "location", "term", "string", "hl", "base", "loc", "char", "form", "f", "str", "json", "mail", "ssl", "sql", "ur", "nl", "bel", "mount", "URL", "gl", "resource", "log", "Url", "job", "sl", "id", "host", "r", "lr", "addr", "path", "this", "buffer", "ob", "ls", "uri"], "stream": ["http", "feed", "in", "steam", "data", "body", "download", "user", "input", "clean", "window", "res", "reader", "image", "transform", "secure", "down", "open", "form", "our", "str", "row", "enc", "context", "sample", "upload", "mount", "stack", "pipe", "REAM", "iter", "sync", "out", "iterator", "file", "present", "resource", "read", "sl", "sw", "console", "view", "zip", "Stream", "path", "message", "pool", "channel", "buffer", "ream", "source"], "writer": ["browser", "to", "null", "wire", "writing", "wright", "ner", "unsigned", "window", "string", "reader", "maker", "Writer", "builder", "document", "io", "white", "client", "worker", "caster", "write", "writ", "liner", "draw", "riter", "writers", "manager", "er", "word", "w", "written", "file", "local", "loader", "master", "creator", "widget", "wrote", "storage", "console", "output", "player", "WR", "buffer"], "editor": ["browser", "insert", "entry", "code", "ui", "settings", "edit", "key", "server", "cer", "options", "folder", "action", "reader", "term", "area", "video", "edited", "accept", "maker", "answer", "over", "button", "document", "Editor", "external", "description", "EDIT", "builder", "actor", "definition", "license", "language", "offer", "oder", "paper", "author", "core", "media", "application", "init", "liner", "owner", "upload", "older", "finder", "enter", "er", "vector", "loader", "auto", "creator", "widget", "storage", "article", "order", "view", "option", "translation", "player", "or", "buffer", "instance"], "name": ["n", "code", "null", "named", "Name", "key", "NAME", "alpha", "filename", "root", "label", "no", "system", "string", "term", "one", "base", "prefix", "description", "type", "str", "nl", "lower", "ame", "me", "title", "comment", "init", "version", "info", "position", "word", "size", "normal", "names", "resource", "file", "local", "format", "nm", "part", "id", "all", "order", "path", "family", "length", "text", "tree", "source"], "dialog": ["choog", "dialop", "Dialogue", "dialogs", "dialOG", "initialog", "initialose", "compresh", "doiz", "rediz", "initialOG", "Dialop", "Dialose", "dialag", "DialOG", "dialg", "tdg", "dialch", "conog", "Dialch", "dlOG", "dialoder", "dializ", "dlag", "tdog", "dlogue", "choogs", "doect", "choogue", "dlose", "tdect", "Dialoder", "Dialresh", "compog", "choop", "dlogs", "Dialog", "initialag", "dlop", "doog", "Dialag", "tdiz", "conch", "conresh", "dialose", "redog", "redect", "conoder", "dialresh", "redg", "dlog", "compch", "dog", "Dialogs", "dialogue", "dialect", "compoder"]}}
{"id1": "14390569", "id2": "18693224", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"title": ["summary", "theme", "html", "header", "TIT", "parts", "hd", "question", "filename", "hash", "label", "string", "padding", "term", "msg", "template", "tip", "name", "itle", "layout", "prefix", "description", "type", "lead", "password", "details", "notice", " Title", "subject", "Title", "setup", "size", "metadata", "t", "help", "start", "heading", "content", "message", "holiday", "text"], "imageURL": ["mediaID", "fileURL", "photoURI", "ImageURI", "imageURI", "ImageURL", "imageUrl", "fileUrl", "mediaURL", " imageUR", "imageUR", "imageString", "fileString", " imageUrl", "ImageID", "photoURL", "ImageUR", " imageURI", "fileURI", "ImageUrl", "imageID", "mediaUrl", "photoUR", " imageString", "photoID", "photoUrl", "mediaURI", "photoString"], "jd": ["simD", "ujD", "Jp", "simmd", "ujdt", "djc", "jjD", "simd", "djad", " jsd", "ajpd", "kd", "jobdo", " jdt", "qdo", "javapd", "jbd", "djsd", "simdt", "JD", "kdo", "zad", "djdo", "jdm", "kds", "Jbd", "gdo", "jpd", "qds", "jds", "djd", "ijds", "zsd", " jc", "jc", "jsdm", "jspd", "Jc", " jad", "jdo", "gbd", "Jmd", "jsD", " jD", "jmd", "Jd", "ijd", "javad", " jds", "gds", "ujd", "jsd", "ajds", "jjd", "qd", "qD", "kdt", "Jdt", "ujmd", "qbd", "Jds", "ijD", "gd", "jobd", "javads", "qp", "ajd", "ujad", "kbd", "Jdo", "jdt", "djds", "Jad", "jjbd", "zd", "ajdm", "javadm", " jdo", "jjp", "jsds", "jad", "jobdt", "jD"], "jl": ["syn", "ij", "bj", "js", " li", "rl", "ja", "elt", "dll", "bol", "li", "kj", "dyl", "jj", "jac", "il", "gn", "dl", "lv", "jin", "j", "lp", " ol", "nl", "lu", "txt", "Label", "ln", "dj", "uj", "abl", "jet", "yl", "kl", "jc", "kel", "jah", "ijk", "igl", "isl", "ibl", "elle", "J", "elly", "mil", "ji", "kn", "ell"], "icon": ["syn", " tip", "fa", " captcha", " intent", "eric", "conn", "ex", " lang", "label", "image", " screen", "addon", "fn", "Icon", " Icon", "chron", "iao", "icons", "cil", "ocon", " conn", "con", "font", "ion", "ico", " ion", "gc", "pic", "jc", " canvas", "iban", " ancestor", " fruit", "icol", "pen", "png", "ICO", " widget", "lock", "ic", "\u4e2d", "cn", "conv", "nic"], "chooser": ["poose", "boerer", " choicer", " chooder", "poicer", "choose", "Choose", "pooder", "choosen", "chooder", "composer", " choerer", "booser", "compicer", "CHOosen", "boose", " choosen", "CHOose", "compose", "choerer", "pooser", "Chooser", "boosen", "choicer", "Choosen", " choose", "CHOicer", "Choicer", "comperer", "composen", "CHOoser", "Chooder"], "jp": ["ij", "bj", "js", "np", " sip", "ja", " np", " gp", " je", " joint", "kj", "bp", " sp", " pic", "j", "jin", " cp", "sp", " mp", " ip", "JP", " dj", " ap", "btn", "pic", "jc", " pl", " ja", "p"], "jb": ["jbd", "Jb", "qbd", "kjcb", " jcb", "Jbd", "jcb", "qcb", "Jcb", "kjbd", "qb", "kjb", " jbd"], "e": ["d", "o", "m", "v", "n", "ed", "it", "re", "ee", "c", "f", "u", "er", "ev", "w", "t", "s", "te", "es", "E", "en", "g", "event", "Event", "a", "or", "ie", "p"], "returnVal": ["retVAL", " returnVol", "getVAL", "ReturnVal", "getVol", " returnVAL", "responseVol", "getValid", " returnValue", "retValue", "returnValid", "returnval", "responseVal", "Returnval", "returnVAL", " returnval", "returnValue", "responseValid", "ReturnVAL", "returnVol", "responseVAL", "getVal", "ReturnValue", " returnValid", "retVal", "retval"], "file": ["http", "report", "to", "rule", "link", "null", "fe", "create", "angle", "h", "body", "full", "filename", "target", "user", "image", "status", "base", "name", "table", "document", "open", "io", "type", "f", "ile", "core", "il", "channel", "fp", "class", "valid", "stat", "dir", "work", "real", "info", "word", "be", "port", "le", "resource", "handle", "File", "format", "local", "library", "fs", "model", "relation", "get", "run", "db", "path", "place", "page", "drop", "or", "buffer", "foo", "FILE", "tree", "source"], "fileName": [" fileSystem", "taskFace", "entitySet", "fileSet", "handlename", "FileNames", "imagePath", "fileExt", " filePath", "FILENames", "ileNAME", "filename", "FILEExt", "FILENAME", " fileNAME", "entityNAME", "taskPath", "fileFace", "FileExt", "FileSet", "fileNames", "fileClass", " fileExt", "FILESystem", "FileNAME", "FILESet", "fileNAME", "Filename", "FileSystem", "FILEName", "fileSystem", "entityPath", "entityName", "FileName", "ilename", "taskName", "FILEPath", "handleNAME", "FileFace", "FilePath", "ileClass", " fileNames", "ileName", "imagename", " filename", "taskname", "filePath", " fileClass", "imageFace", "handleClass", "imageNAME", "handleName", "imageName"], "ext": ["ex", "test", "desc", "EXT", "ind", "req", "exc", "aux", "external", "cmd", "pat", "ct", "end", "cont", "ag", "Ext", "enc", "lex", "xp", "dir", "off", "hex", "word", "sem", "t", "exp", "ix", "part", "xt", "cod", "def", "exe", "fr", "vert", "typ", "prot", "ec", "lib", "ord", "eur", "txt", "len"], "i": ["m", "ci", "ui", "print", "it", "ei", "gi", "phi", "index", "status", "ori", "y", "ini", "li", "ii", "iu", "is", "fi", "bi", "pi", "j", "init", "info", "cli", "ai", "ti", "mi", "hi", "id", "di", "I", "si", "xi", "qi"], "doIt": [" doWhich", " doIs", "didIs", "donIt", " doit", "waIt", "doHe", "donIT", "odoHe", "doit", "didYou", "doneIt", "doneit", "diIt", "doWhich", " doYou", "didit", "doYou", "waIs", "donit", "odoIT", "doIs", "donYou", "diit", "odoWhich", "odoIt", " doHe", "diHe", "didIt", "doneIT", "odoit", "doIT", " doIT", "donIs", "diWhich", "waIT"], "src": ["syn", "http", "comp", "rest", "sh", "ctr", "rl", "rt", "inner", "rob", "proc", "sec", "rel", "ins", "ser", "input", "lb", "rs", "rx", "loc", "rb", "ources", "trans", "cont", "ssl", "usr", "sys", "conv", "rc", "init", "st", "ource", "copy", "ptr", "https", "inst", "url", "crop", "from", "impl", "start", "sl", "sc", "sub", "sb", "tmp", "r", "sr", "gs", "sq", "source"], "dest": ["way", "rest", "comb", "gest", "cat", "cp", "dat", "proc", "target", "rel", "desc", "dist", "des", "loc", "decl", "Dest", "nw", "nom", "cont", "trans", "sys", "usr", "mem", "est", "sp", "dir", "st", "pipe", "origin", "iter", "pas", "https", "port", "slave", "local", "pot", "master", "can", "coord", "foreign", "output", "tmp", "temp", "out", "orig", "source"]}}
{"id1": "14783950", "id2": "3024970", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compresswithzip", "composeWithZip", "composeWithzip", "compresswithExt", "compresswithFiles", "compressWithFiles", "compresswithZip", "compressByzip", "composeWithoutzip", "compressWithExt", "compressWithoutzip", "compressWithzip", "compressByExt", "composeWithExt", "composeWithoutFiles", "composeWithFiles", "compressByZip", "compressByFiles", "composeWithoutZip", "compressWithoutZip", "compressWithoutFiles", "composeWithoutExt", "compressWithoutExt"], "fileList": [" fileLIST", "wordList", "fileSet", "fileLIST", "wordLIST", " filelist", " FileSet", " FileCode", "itemNames", "wordIterator", " fileSet", "fileL", " fileL", "itemLock", " fileIterator", "itemList", "fileNames", "pageList", "resourceList", " fileLock", "ileList", "fileCode", "resourceLock", "fileLock", "tileList", "pageLIST", " FileLIST", "pageSet", " fileNames", " fileCode", "tileIterator", "filelist", "pageCode", "tileLIST", "tileSet", "ileL", "wordSet", "resourceNames", "ileLIST", "pageL", " FileList", "ilelist", "fileIterator", "pagelist"], "zipFileName": [" zipfileNames", "zipfileFilename", "zipDirNames", " zipFilePath", "zipDirName", " zipFileNames", "zipilePath", "zipfileName", "zipFilePath", "zipFilename", "zipFilenameName", "zipileName", "zipFilenameNames", "zipilename", "zipFileNames", "zipfileNames", "zFileFilename", "zipDirPath", " zipFileFilename", "zFilename", "zFileName", "zFilenameName", "zipFileFilename", " zipfilePath", "zipFilenamePath", "zipDirFilename", "zFilePath", " zipfileName", "zipFilenameFilename", "zFilenamePath", "zipileFilename", " zipfileFilename", "zipFilenamename", "zipfilePath", "zipfilename", "zFilenameFilename", "zFilenamename"], "fos": ["flOS", "los", "foos", "fOS", "Foss", "flis", "Foos", " foos", "woss", "Fos", "wos", "floos", "lOS", "loss", "foss", "FOS", "lfOS", "flos", "loos", "wOS", "lfos", " fOS", "woos", "lfoos", "lfis"], "zos": ["enos", "iners", "enz", "css", "zero", "bes", "js", "oss", "less", "zar", "los", "ws", "sis", "sbm", "ez", "zb", "hess", "zin", "webkit", "zik", "zag", "os", "ss", "zers", "zer", "eros", "zzle", "zu", "ze", "cz", "za", "rez", "zen", "zon", "zes", "ippers", "zo", "Sax", "es", "ses", "ossus", "zh", "jas", "nz", "iaz", "han", "zan", "rys", "zip", "hz", "ps", "ess", "z", "zi"], "iter": ["ip", "list", "walker", "it", "tr", "ipper", "inner", "fer", "cer", "loop", "ner", "ser", "former", "ator", "kit", "re", "user", "el", "orient", "ee", "ir", "reader", "maker", "vis", "loc", "iv", "is", "li", "Iterator", "its", "izer", "ver", "outer", "valid", "ter", "ger", "where", "ptr", "er", "liter", "iterator", "oper", "coll", "loader", "here", "exp", "train", "inter", "iner", "Iter", "order", "ait", "iver", "i", "gener"], "fileName": ["fileSource", "fileStore", "fieldName", " fileCurrent", "getname", "ilePath", "fileNumber", "fileSet", "fname", " fileStore", "fName", "FileNames", "tableSet", "fieldNAME", " filePath", "ileSet", "ileCurrent", " fileSet", "ileBody", "filename", "localname", "ileNAME", "tablePath", "getSource", "shortname", "fileNames", "ileSource", "ileString", "fileString", "getName", "localName", "ileList", "getStore", " fileString", "localList", "fileBody", "fileNAME", "Filename", " fileSource", "FileName", "ileNumber", "fSource", " fileBody", "ilename", "shortStore", "localNAME", " fileNames", "FilePath", "FileCurrent", "tableName", "fBody", "FileString", "ileName", " filename", "filePath", "fNumber", "fString", " fileNumber", "fNames", "fieldname", "fieldList", "fileCurrent", "shortSource"], "ind": ["d", "pred", "pl", "n", "att", "roll", "Ind", "pos", "ld", "md", "inc", "cd", "num", "dial", "wind", "index", "bind", "seed", "req", "med", "cond", "cand", "ded", "mod", "loc", "red", "count", "j", "nd", "sign", "div", "draw", "td", "ptr", "mind", "inder", "dj", "IND", "ent", "cod", "hend", "find", "typ", "kind", "stick", "inn", "i", "butt"], "shortName": ["quickname", "shortKey", "recentname", " shortname", "fullType", "ShortName", "smallName", "ShortString", "shortname", "recentCode", "quickName", "Shortname", " shortString", "recentFilename", "recentName", "fullString", "smallCode", "ShortFilename", "quickString", "ShortType", "smallFilename", "shortType", "ShortKey", "fullName", " shortKey", "ShortCode", "shortCode", "smallname", "fullname", "shortFilename", " shortType", "quickKey", "shortString"], "fis": [" fIs", "hois", " fris", "cfris", "fIs", "pis", "ufois", "sfIs", "ufis", "hris", "cfis", "FIs", "cfi", "cfois", "ufris", "ufi", "wIs", "fi", "ufIs", "Fris", "wis", "pi", "wi", "his", "wois", "Fis", "sfois", "sfi", "sfis", "pois", "pris", "fois", "fris", "hi"], "buf": ["b", "batch", "aka", "Buffer", "tab", "cat", "tr", "pkg", "buffer", "fam", "mu", "msg", "seq", "bin", "arr", "uf", "bar", "cmd", "rb", "bag", "bed", "var", "img", "ref", "mem", "fg", "br", "buff", "cap", "cb", "box", "bytes", "block", "vec", "fb", "cur", "cv", "wb", "bc", "bl", "db", "Buff", "temp", "conv", "orig", "bus"], "bytesRead": ["bytesNeed", "linesNeed", "linesWritten", " bytesLoad", " bytesWritten", "BytesNeed", "bytesLength", "postsRead", "blocksLoad", " bytesNeed", "usersFind", " bytesWrite", "BytesWritten", "secondsWrite", "secondsWritten", "BytesLength", "usersLoad", "flowsReady", "bytesFind", "flowsLoad", "linesRead", "postsLoad", "secondsRead", " bytesLength", "blocksRead", "postsReady", "blocksWrite", "bytesReady", "flowsRead", "bytesWrite", "postsFind", "linesLength", "usersRead", "bytesLoad", "BytesRead", "secondsLoad", "usersReady", "bytesWritten", "blocksWritten", "flowsFind"]}}
{"id1": "22560224", "id2": "16063533", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"hashStringMD5": [" hashStringMT0", " hashStringSHA0", " hashStringSHA1", " hashStringSHAHash", " hashStringSMHash", " hashBytesMT5", " hashBytesMD5", " hashStringSHA5", " hashStringSM0", " hashBytesMD1", " hashBytesMTHash", " hashStringMD0", " hashStringMTHash", " hashBytesMT0", " hashBytesMT1", " hashStringSM1", " hashBytesMDHash", " hashStringMT5", " hashStringSM5", " hashStringMDHash", " hashBytesMD0", " hashStringMT1", " hashStringMD1"], "string": ["setting", "strings", "v", "print", "list", "null", "space", "data", "function", "address", "ring", "test", "filename", "site", "input", "array", "name", "sequence", "prefix", "password", "char", "str", "number", "sql", "comment", "word", "value", "format", "file", "s", "service", "result", "content", "spec", "object", "host", "ident", "message", "buffer", "text", "source"], "md": ["d", "m", "amd", "ad", "cd", "ld", " Md", "mand", "mode", "bd", "pd", "hd", "grad", "MD", "desc", "mm", "dist", "Cmd", "det", "od", "dr", "ind", "cond", "mod", "down", "cmd", "dd", " MD", "red", "der", "df", "pdf", "ms", "nd", "dir", "and", "dh", "mc", "mt", "mn", "add", "mk", "sm", "alg", "sd", "dm", "di", "mb", "de", "nt"], "byteData": ["helloBytes", "viewData", "helloData", "byteLens", "componentBytes", "ByteBuffer", "wordDATA", "nodeBuffer", "phraseBytes", "seeLens", "displaydata", " ByteBuffer", "byteDo", "displayData", "charDATA", "charData", "ByteParts", "byteParts", " ByteForm", " ByteLens", "ByteBytes", "viewdata", "phraseData", " byteParts", "displayCount", "byteDATA", "nodeLens", "wordData", "helloDo", "viewDo", "helloDat", " byteDATA", "phraseDo", "chardata", "ByteData", "worddata", "displayDo", " ByteData", " byteBytes", "seeForm", " byteBuffer", "byteBytes", "nodeForm", "nodeData", "componentBuffer", "componentData", "byteDat", " bytedata", "ByteDat", " byteCount", "byteForm", "bytedata", "seeData", " byteDo", "phraseDat", "byteCount", "ByteDo", "seeBuffer", "byteBuffer", "componentParts", "viewCount"], "sb": ["pb", "b", "sh", "bj", "bh", "web", "ws", "bash", "zb", "lb", "bt", "rb", "alph", "sa", "ssl", "sv", "bf", "sam", "sp", "bg", "src", "cb", "ib", "sync", "sf", "kb", "sth", "soc", "bsp", "sw", "gb", "bb", "sc", "eb", "xb", "nb", "mb", "shell", "bs", "sg", "erb", "SB", "sq"], "i": ["m", "ip", "print", "list", "in", "it", "ei", "q", "c", "y", "ini", "io", "kj", "client", "ity", "bi", "pi", "me", "init", "mi", "ix", "hi", "o", "v", "ex", "span", "im", "base", "oi", "ki", "ii", "gu", "any", "j", "set", "id", "ic", "I", "xi", "z", "uri", "ci", "ui", "batch", "err", "\u0438", "iq", "iu", "info", "ai", "di", "iy", "history", "remote", "si", "ie", "zi", "ij", "multi", "yi", "gi", "chain", "phi", "us", "cgi", "name", "li", "ski", "json", "cli", "er", "ri", "series", "point", "g", "this", "my", "ti", "conv", "ji", "qi"], "hexString": [" hexStr", "exString", "httpString", " hexSet", "pexString", "serialString", "sexStatement", " hexSite", "exSocket", "sexList", "viewNumber", "exStatement", "expString", "sexSocket", "exText", " hexBuffer", "pexList", "hexSocket", "sexString", "alphaString", "alphaStr", "viewString", "viewSet", "hexBuffer", " hexNumber", " hexText", "exBuffer", "expSet", "hexScreen", "pexSocket", "hexText", "viewBuffer", "alphaSite", "hexSet", " hexScreen", "alphaScreen", "hexSite", "serialBuffer", "hexStatement", "httpSite", "pexStatement", "expNumber", "exList", "hexStr", "hexNumber", "exStr", "hexList", "httpStr", "httpScreen", "serialStr", "serialText", "expBuffer"], "hex": ["comp", "ip", "raw", "sh", "print", "prop", "tex", "ex", "rex", "html", "cat", "full", "oct", "h", "hash", "sex", "rh", "term", "ext", "hl", "pex", "xf", "des", "aux", " sex", "hp", "char", "form", "json", " Hex", "cont", "sv", "buff", " ex", "none", "cmp", "he", "com", "handle", "dump", "exp", "hw", "ph", "tx", "zh", "lit", "def", "hello", "hz", "x", "hi"]}}
{"id1": "12066447", "id2": "6470716", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"truncate": ["extvalidation", "trvalidize", "truncation", "extuncation", "trculation", "trculicate", "trvalidicate", "trculize", "trculate", "extvalidize", "trunation", "trunicate", "truncicate", "extuncize", "truncize", "extvalidicate", "trvalidation", "trunize", "extuncicate", "trunate", "trvalidate", "extvalidate", "extuncate"], "file": ["report", "to", "link", "null", "time", "use", "create", "data", "full", "filename", "user", "image", "base", "template", "name", "table", "io", "type", "attribute", "line", "f", "ile", "channel", "fp", "class", "parent", "e", "files", "dir", "work", "module", "info", "block", "word", "be", "port", "size", "le", "resource", "local", "File", "handle", "range", "format", "log", "from", "model", "spec", "get", "object", "event", "zip", "run", "lock", "frame", "message", "path", "page", "this", "out", "or", "foo", "FILE", "current", "tree", "source"], "backupRoot": ["BackupDir", "BackupidRoot", "backupsDir", "backupBox", "backflowDir", "backureroot", "workuproot", "backureRoot", " backupidBox", "workupDir", "backupidDir", "backflowFolder", "backumpDir", "backuproot", "BackupidDir", "backuperDir", "backupFolder", "workupidDir", "backureBoot", "workupBoot", "backupidFolder", "backupHome", "backmpRoot", " backupidRoot", "BackupRoot", "backumpRoot", "backflowRoot", "workupidHome", "workupRoot", "backuperHome", "backupidRoot", "BackupFolder", "backupBoot", "workupidBoot", "backupDir", "backupsroot", "backureHome", "backupidHome", "backmproot", "backureDir", " backupidroot", "backuperRoot", "backmpBoot", "backdownFolder", "backumpBox", "backupsRoot", " backupBox", "backdownRoot", "workupidRoot", "backmpDir", "backupidBoot", "backupidBox", "backumproot", "backdownDir", "backupsBox", " backupDir", "backupidroot", " backuproot", " backupidDir", "workupidroot", "BackupidFolder", "backuperroot", "workupHome"], "df": ["d", "DF", "dim", "md", "cd", "pd", "dp", "hd", "gd", "tf", "NF", "tif", "mm", "dr", " pdf", "dc", "deb", "uf", "cf", "dd", "f", "dx", "dl", "pdf", "bf", "raf", "Def", "du", "sf", "fun", "format", "dep", "fd", "lf", "sd", "def", "dm", "di", "db", "dt", "ds"], "date": ["age", "daily", "dated", "dates", "time", "duration", "dat", "create", "data", "sum", "string", " Date", "grade", "year", "ate", "name", "down", "standard", "number", "month", "when", "Date", "note", "late", "save", "module", "version", "zone", "now", "today", " day", "format", "resource", "value", "due", "future", "range", "start", "days", "update", "match", "day", "content", "get", "event", "default", "output", "run", "cal", "message", "dt", "tag", "frame"], "zipFile": ["zipfile", "zipPath", "logfile", "ZipFile", "Zipfile", "logPath", "zFile", "pdfStream", "pdfFile", "jsonFile", "zipFilename", "ZipPath", "zipStream", "zStore", "zfile", "jsonStore", "zFilename", "logFilename", "zipStore", "jsonfile", "pdfPath", "pdffile", "ZipStream", "logStream", "logStore", "jsonFilename", "logFile"], "zos": ["enos", "css", "enz", "bes", "shed", "stice", "js", "oss", "zar", "los", "ozo", "sbm", "sis", "ez", "cos", "sch", "asio", "oses", "zb", "hess", "zin", "webkit", "zik", "zag", "os", "asar", "south", "ss", "hs", "zers", "estro", "zer", "eros", "zzle", "ze", "cz", "za", "rez", "zen", "zon", "zes", " sands", "ones", "zo", "Sax", "ses", "jas", "nz", "zan", "sol", "zona", "hz", "esm", "bs", "tz", "z", "zi", "ros"], "fis": ["dfiss", "dfier", "dfIs", "ofib", "lia", "efisc", "lis", "fIs", "F\u00eds", "fiss", "fier", "sfier", "sfIs", "fisc", " fois", "cfis", "FIs", "foia", "dfis", "lIs", "ofis", "f\u00eds", "if\u00eds", "ifisc", "li", "cfiss", "fi", "ofois", "ofisc", "efis", " fiss", "Fisc", "ef\u00eds", "Fier", "ifIs", "fia", "sfits", "ifis", "Fiss", "cfisc", "Fis", "ofiss", " fib", "cfits", "foi", "fiois", "fits", "foIs", "efIs", "Fia", "ofits", "sfis", "fib", "fiis", "sfiss", "fois", "fiiss", "fiib", "Fi", "sfisc"], "entry": ["insert", "rance", "ary", "command", "tex", "record", "data", "xml", "key", "obj", "entity", "description", "attribute", "char", "sheet", "row", "cell", "connection", "ment", "cue", "e", "section", "comment", "and", "element", "ace", "ce", "word", "ion", "add", "escape", "resource", "search", "internal", "zo", "se", "office", "ent", "member", "set", "def", "object", "deep", "event", "zip", "delete", "Entry", "de", "option", "or", "ie", "ry"], "buffer": ["batch", "cache", "code", "zero", "command", "Buffer", "letter", "screen", "header", "memory", "paste", "window", "padding", "volume", "available", "template", "base", "button", "document", "table", "sequence", "bar", "attribute", "char", "queue", "buf", "phrase", "sample", "buff", "append", "comment", "stack", "iter", "block", "word", "category", "library", "variable", "binary", "view", "message", "temp", "page", "length", "frame"], "readed": ["READer", "READd", "Readd", "readared", "readied", "Reader", "reded", "READED", "reader", "redented", "Readed", "indexED", "redED", "readableED", "counted", "readableed", "readableared", " readeded", "Readied", "READed", "indexeded", "readableied", " readED", "counter", "readeded", "countED", "readented", " readented", "indexed", "indexented", "readED", "Readared", "readd", "ReadED", "findED", "countd", "findared", "finded", "rededed", "findied"]}}
{"id1": "14617444", "id2": "6008635", "code1": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"readUNI": [" readANi", "readUnION", " readUNS", " readUnI", " readANI", " readUNION", " readANS", " readOUS", "readUNION", "readUni", "readUNi", " readUni", "readUnS", " readOUI", " readANION", " readUNi", "readUnI", " readUnS", "readUNS", " readOUION", " readUnION", " readOUi"], "descriptions": [" describedIONS", "desriptations", "descriptcriptions", "desccription", "describesIONS", "descriptisions", "describion", "descructions", "desription", "desccriptIONS", "describedcriptions", "desripturations", "desriptions", " describedions", "desccriptions", "describedions", " descriptisions", "desccriptisions", "descripturations", "describedisions", "descriptations", "description", "describesions", "desccripturations", "desccriptations", " describedcriptions", "describurations", " descriptIONS", "descruction", "descructations", "descructurations", "desccriptcriptions", " descriptcriptions", " describedisions", "describions", "describesisions", "describescriptions", "describations", "describedIONS", "descriptIONS"], "source": ["code", "in", "address", "SOURCE", "body", "filename", "target", "input", "string", "seed", "name", "sequence", "description", "style", "subject", "sql", "src", "note", "sample", "ource", "origin", "Source", "stream", "resource", "file", "from", "value", "s", "start", "content", "output", "path", "message", "i", "text", "uri"], "is": ["ip", "dis", "ris", "isi", "in", "oss", "bis", "ws", "lis", "sis", "ists", "has", "isa", "us", "ins", "was", "ir", "ais", "os", "ois", "tis", "sels", "its", "IS", "Is", "isf", "sys", "isin", "iso", "ms", "serv", "ys", "info", "isp", "ios", "s", "iss", "es", "fs", "iris", "as", "isl", "ims", "bs", "isc", "i"], "url": ["browser", "http", "pl", "link", "web", "l", "ll", "html", "address", "rel", "user", "hl", "name", "loc", "open", "google", "char", "f", "str", "ul", "mail", "abs", "ssl", "build", "ur", "nl", "bel", "mount", "URL", "gl", "file", "resource", "service", "Url", "sl", "get", "host", "lr", "ls", "uri"], "scanner": ["Scanning", " scaner", "scanNER", "penner", "Scanner", "canNER", "gateer", "pener", " scanter", "Scanter", "gateter", "Scaner", " scanNER", "caniner", "scaniner", "canter", "gatening", "scaner", "canner", "Scaniner", "peniner", "penter", "scanning", "gatener", "caner", "scanter", "canning", "ScanNER"], "line": ["entry", "ip", "raw", "link", "code", "l", "record", "detail", "lin", "eline", "lc", "header", "pe", "label", "string", "lines", "lo", "email", "char", "str", "cell", "inline", "Line", "ine", "row", "text", "nl", "liner", "comment", "ide", "ln", "block", "iter", "word", "le", "LINE", "file", "range", "se", "log", "query", "page", "ne", "frame", "online"], "id": ["ip", "link", "oid", "ad", "md", "it", "sid", "Id", "key", "h", "hd", "pid", "label", "od", "ind", "status", "ids", "name", "description", "wid", "ver", "aid", "uid", "init", "title", "and", "info", "ide", "iter", "rid", "part", "iden", "bid", "mid", "ident", "kid", "db", "tag", "ID", "i"], "desc": ["dev", "summary", "pr", "null", "cd", "md", "lc", "sum", "sec", "esc", "Description", "rel", "doc", "label", "dist", "ser", "attr", "msg", "seq", "des", "dc", "name", "pro", "asc", "description", "cmd", "sup", "str", "json", "dl", "phrase", "title", "comment", "dir", "disc", "info", "cmp", "dec", "diff", "Desc", "def", "sc", "sub", "tag", "dest", "ds", "text"], "linescanner": ["linesscancell", "linecanner", "inesanter", "linespanner", "lineskner", "inesancell", " linesscaner", "linesancer", "inesaninner", " linescaninner", " linescaner", "linescanters", "linesanncer", "linespininner", "linesgateter", "inesscanener", "linesanninner", "linesscancer", "linespinner", " linesscaninner", "linesaner", "inescaninner", "linesscaninner", "lineskininner", "linesanters", "linescaninner", "linesscanters", "inescanner", "inescanters", "linespaninner", "lineskners", "lineskter", "linespanter", "linescancer", "linecanter", "linesscanNER", " linesscann", "linesgatener", "linesaninner", "linesscanner", "inesanters", "linesanners", "linecancer", "linespanNER", "linescancell", "lineskinter", "linespinters", "linesscanener", "linesannter", "linesanter", "inescanNER", "lineskinner", " linesscanter", "linescanNER", "linesgateNER", "inescanter", "linescanter", "linesannner", "linesancell", "linesscaner", "linesscanners", "linescann", "linesgateener", "inesanner", "inescanners", "linespanener", "linesscann", "linesscanter", "inesscanter", " linescanter", "linescanners", " linesscanner", "inescanener", "linesanncell", "lineskiner", " linescann", "linecaninner", "linescanener", "linescaner", "inesscanner", "linespinter", "inesanners", "inesscanNER", "linespann", "linesann", "linesanner", "inescancell"]}}
{"id1": "3958807", "id2": "1005107", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void googleImageSearch() {\n        if (artist.compareToIgnoreCase(previousArtist) != 0) {\n            MusicBoxView.googleImageLocation = 0;\n            try {\n                String u = \"http://images.google.com/images?q=\" + currentTrack.getArtist() + \" - \" + currentTrack.getAlbum() + \"&sa=N&start=0&ndsp=21\";\n                if (u.contains(\" \")) {\n                    u = u.replace(\" \", \"+\");\n                }\n                URL url = new URL(u);\n                HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n                httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n                BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n                String text = \"\";\n                String lin = \"\";\n                while ((lin = readIn.readLine()) != null) {\n                    text += lin;\n                }\n                readIn.close();\n                if (text.contains(\"\\n\")) {\n                    text = text.replace(\"\\n\", \"\");\n                }\n                String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n                for (String s : array) {\n                    if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                        String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                        googleImages.add(s1);\n                    }\n                }\n            } catch (Exception ex4) {\n                MusicBoxView.showErrorDialog(ex4);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadBinaryStream": ["loadBixedStream", "loadEmbinaryFile", "loadBinaryInput", "loadEmbinaryStream", "loadBignedInput", "loadEmbbinaryStreamer", "loadEmbbinaryInput", "loadEmbinaryInput", "loadBignedStreamer", "loadBixedFile", "loadBignedStream", "loadEmbinaryStreamer", "loadBbinaryFile", "loadBinaryStreamer", "loadEmbbinaryFile", "loadBignedFile", "loadBbinaryStreamer", "loadBbinaryStream", "loadBbinaryInput", "loadBixedInput", "loadBinaryFile", "loadBixedStreamer", "loadEmbbinaryStream"], "streamName": [" streamNAME", "streamHandle", "streamPath", "longName", "longPath", "stringName", "Streamname", "stringType", "resourceType", "recordNAME", "fileNAME", "streamNAME", "StreamNAME", "StreamName", "resourceName", " streamname", "recordHandle", "streamType", "stringNAME", " streamType", " streamPath", "longNAME", "filePath", "StreamHandle", "recordName", "streamname", "resourceNAME", " streamHandle", "fileName", "recordname"], "streamToLoad": [" streamToload", "streamtoLoad", "streamToRead", "streamToAdd", "streamTOload", "stringWillLoad", " streamToUse", "streamToUse", "streamWillAdd", "stream2load", "streamTORead", "stream2Read", " stream2Load", "stream2Use", "streamtoAdd", " streamWillload", " stream2Read", "stringToAdd", "streamTOLoad", "stringWillAdd", " streamWillLoad", "streamTOAdd", "streamWillLoad", "stringToLoad", " stream2load", "stringToload", "streamtoload", "stream2Load", " stream2Use", "streamWillload", "stringWillload", " streamToRead", "streamTOUse", "streamToload"], "sz": ["insz", "Sch", "sld", "rsld", " sze", "sch", " sld", " sch", "rsz", "Sld", "Siz", "insch", "Sz", "insiz", "rsze", "siz", "insze", "rsiz", "Sze", " siz", "sze"], "req": ["comp", "http", "wcs", "pkg", "qs", "q", "proc", "ctx", "inv", "wx", "dq", "res", "attr", "seq", "quick", "rx", "quest", "jp", "requ", "cmd", "client", "comm", "org", "usr", "request", "pas", "cur", "qt", "urg", "Request", "require", "qq", "query", "fr", "gr", "Requ", "sq"], "resp": ["http", "report", "dis", "pos", "conn", "esp", "html", "Res", "respond", "body", "rel", "proc", "wr", "res", "inv", "rend", "re", "wx", " Resp", "obj", "rec", "response", "rep", "status", "msg", "os", "jp", "RES", "cmd", "client", "comm", "sys", "ret", "vol", "compl", "sp", "serv", "cmp", "request", "pas", "https", "soc", "respons", "Response", "Resp", "exp", "fs", "result", "cl", "fr", "sol", "content", "output", "r", "gr", "conv", "p", "nt"], "out": ["o", "n", "to", "null", "in", "oss", "ex", "ws", "cos", "us", "obj", "ins", "res", "OUT", "os", "Out", "ou", "io", "yout", "aos", "client", "sys", "conv", "vol", "co", "ot", "w", "t", "ts", "log", "sw", "gt", " outs", "utt", "output", "outs", "bs", "net", "cn", "gs", "nt"], "bos": ["bes", "bh", "js", "oss", "bis", "ws", "los", "bas", "banks", "oos", "ubis", "obs", "bot", "bles", "bin", "base", "des", "os", "ods", "aos", "boards", "bi", "BS", "eros", "bo", "sys", "nos", "dos", "bits", "buff", "bytes", "ios", "ys", "ols", "tes", "ts", "fits", "oops", "jas", "bat", "oids", "uts", "bs", "bones", "mos"]}}
{"id1": "23273706", "id2": "3767903", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectListList", "getProjectNodeList", "getAppTreedata", "getProjectListData", "getAppTreeList", "getProjectListInfo", "getProjecttreeInfo", "getProjectTreeList", "getProjectNodeData", "getProjectTreeInfo", "getProjecttreeList", "getProjectNodeInfo", "getProjectNodedata", "getApptreedata", "getApptreeData", "getAppTreeInfo", "getAppTreeData", "getProjectTreedata", "getProjecttreedata", "getApptreeInfo", "getProjectListdata", "getApptreeList", "getProjecttreeData"], "treeData": [" treeList", "listDat", "reeData", "listData", "reeMap", " treeMap", "towerDat", "towerData", "TreeMap", " treeDat", "tableData", "tableValid", "treePart", "cachePart", "statusData", "treeInfo", "cacheDat", "treeDat", "statusDat", "TreeData", " treeValid", "treeList", " treeInfo", "reeInfo", "TreeInfo", "statusMap", "cacheData", "tableMap", "towerValid", "treeMap", "treeValid", "tableDat", "listPart", " treePart", "reeList", "reeDat", "tableList", "tableInfo"], "filename": ["FIL", "ename", "generation", "key", "root", "folder", "string", "location", "directory", "username", "name", "prefix", "fps", "fn", "latest", "fil", "river", "uno", "localhost", "SourceFile", "json", "Filename", "fp", "KEY", "ername", "sql", "ames", "save", "title", "jpg", "txt", "URL", "URI", "println", "metadata", "url", "file", "local", "original", "fs", "nil", "lua", "FN", "FS", "output", "png", "path", "temp", "FILE", "fax", "uri", "source"], "urlString": ["callstring", "urlService", "uristring", "UrlSite", "callStr", "lService", "callService", "urlStr", "uriSite", "URLString", " urlService", "UrlString", "lString", "URLstring", "URLSingle", "lstring", " urlstring", "uriSingle", " urlStr", "urlSingle", "lStr", "callString", "Urlstring", "UrlSingle", "uriString", "urlstring", "urlSite", "URLSite"], "urldata": ["urlenATA", "uriledATA", "urlfATA", "urrdatum", "urlfatum", " urldeATA", " urldATA", "urldedata", "urldeatum", "urldeATA", "uriledata", " urldeata", "udlenata", "urldatum", " urlddata", "udlenatum", "urledatum", "udldata", "urlfescription", "urledATA", "urileddata", " urldedata", "udlenATA", "uriledatum", "urlenescription", "urrdescription", "urlenatum", " urldeatum", "urldATA", "udlenescription", "urrdata", "urledata", "urlenata", "udldatum", "urrdATA", "udldATA", "udldescription", "urleddata", " urldatum", "urldescription", "urlfata", "urldeata", "urlddata"], "factory": ["facault", "Fotype", "efFactory", "Facet", "affacter", "vFactory", "facixture", "vacter", "fault", "votype", " fFactory", "fFactory", "affFactory", "facactory", "affactory", "Fixture", "FFactory", "vactory", "facet", "efrozen", "frozen", " fault", " facet", "efacet", "Fault", "Factory", "Facter", "facacter", "fotype", "affotype", "Frozen", "efactory", " frozen", "facter", " facter", " fixture", "fixture"], "parser": ["parse", "walker", "command", "Parser", "policy", "xml", "bank", "Reader", "processor", "reader", "dom", "actory", "expression", "builder", "io", "writer", "php", "sup", "df", "fp", "fascist", "pdf", "utils", "jack", "manager", "er", "sf", "au", "file", "loader", "apache", " parsing", "power", " parse", "arser", " df", "util", "x", "conv", "instance", "p", " p"], "u": ["su", "o", "ui", "l", "ua", "it", "uv", "h", "fu", "us", "util", "p", "mu", "iu", "ou", "io", "uf", "ue", "hu", "un", "ul", "uid", "lu", "ur", "ut", "eu", "cu", "au", "nu", "url", "U", "tu", "r", "ru", "uri", "uu"], "is": ["dis", "ui", "ris", "isi", "in", "it", "bis", "oss", "lis", "sis", "ists", "has", "us", "isa", "ins", "are", "obs", "ir", "im", "ais", "ires", "iu", "io", "its", "ar", "IS", "abs", "il", "Is", "sys", "mis", "iso", "ms", "ib", "ys", "ios", "info", "ri", "ai", "iss", "es", "fs", "ost", "iris", "ist", "rys", "isl", "ims", "ic", "isc", "si"], "os": ["o", "css", "pos", "osa", "socket", "oss", "ops", "oa", "oos", "cos", "us", "obs", "oses", "des", "io", "ss", "aos", "Os", "ens", "ows", "sys", "et", "so", "ms", "dos", "ot", "OS", "ios", "ys", "s", "bos", "osi", "es", "fs", "ost", "as", "uts", "bs", "out", "or", "oes", "ls", "ox", "mos", "ros"], "iBufSize": ["iBbufSIZE", "iBufLen", "iBphSize", "iBbufLength", "iBuffSize", "iBuffCount", "iBuffLen", "iLbufCount", "iRbufSize", "iBuffSIZE", "iBbufLen", "iBulCount", "iLufCount", "iBphCount", "iLufLen", "iLbufSize", "iLufSize", "iLbufLen", "iBbufSize", "iRbufCount", "iRufSize", "iBufSIZE", "iBulLen", "iBufLength", "iBbufCount", "iLufsize", "iBufCount", "iRbufSIZE", "iBulSize", "iBuffLength", "iBphLength", "iBufsize", "iBphSIZE", "iBuffsize", "iBbufsize", "iRufCount", "iRufSIZE", "iBulsize", "iRufLength", "iRbufLength", "iLbufsize"], "inBuf": ["InBBuff", "inBigbuf", "inBufferuf", "inChbuf", "inBigbuff", "inBBuff", "inRuc", "inBufferbuf", " inRbuf", "InBuff", "inLuf", "inLbuf", "outRuf", "outBul", " inBbuff", "outBBuff", "InBbuf", "outBuf", "inBufferul", " inBbuf", "inRul", "outBbuf", " inRuf", "InChuff", "inChuff", " inBuc", "inBluf", "inRBuff", "inRuff", "inRuf", "outRbuf", "InChuf", "inBlul", "inBiguf", "inBiguc", " inRuc", "inLbuff", "InChbuf", "inBlBuff", "inBuff", "inBbuff", "inRbuf", " inRbuff", "inLuc", "inRbuff", "inBlbuf", "inChBuff", "inChuf", "InBuf", "inBufferuff", "inBufferBuff", "inBuc", "InChBuff", "inBbuf", "inBul", "outRBuff", "outRul"], "iNumRead": ["iiNumFind", "iinumDef", "INumNeed", "iNumberWrite", "aiNumberWrite", "iNumNeed", "iNUMNeed", "inumRead", "InumPrint", "iLenPrint", "inumRun", "iNumDef", "iLenNeed", "iRemFind", "aiNumWrite", "INumRun", "iNumPrint", "iiNumRead", "iNUMRun", "iRemRead", "iFatDef", "iFatRead", "iiNumDef", "aiNumberRead", "INumRead", "InumRead", "inumNeed", "iLenRun", "iFatFind", "inumPrint", "InumNeed", "iNUMPrint", "iinumRead", "iNumWrite", "iinumFind", "iRemWrite", "inumDef", "inumFind", "INumPrint", "iNumberFind", "iNUMRead", "iNumberRead", "aiNumRead", "iLenRead", "aiNumFind", "iNumRun", "InumRun", "aiNumberFind", "iNumFind"], "f": ["d", "b", "v", "n", "o", "fa", "l", "fe", "h", "tf", "F", "c", "y", "fo", "fi", "cf", "df", "fp", "fc", "bf", "fm", "e", "fac", "sf", "af", "w", "file", "t", "fd", "fs", "fr", "g", "fax", "p"], "inputstream": ["Inputstyle", "iterscreen", "inputform", " inputdraw", " inputform", " inputStream", "InputStream", "uploadstyle", "Inputdraw", "uploadstream", "uploaddraw", "inputdraw", "iterstream", "iterstyle", "Inputstream", "inputStream", "Inputscreen", "iterStream", "uploadscreen", "uploadStream", "inputstyle", "inputscreen", "Inputform", "uploadform"], "document": ["browser", "m", "n", "raw", "command", "html", "node", "xml", "Document", "doc", "window", "directory", "dom", "information", "response", "expression", "database", "template", "language", "collection", "media", "number", "df", "ocument", "context", "application", "ree", "version", "complete", "file", "present", "apache", "result", "ml", "model", "article", "content", "object", "message", "page", "tree"], "nodelist": ["nannodeist", " nodesist", "nodeest", "nodist", "nodeety", "nodeeline", "nodeman", "snodelist", "neodeeman", "nodest", "nodeto", "nostestyle", "nodeist", "nodety", "nodeseto", "nodeemark", " nodeline", "nnodeety", "neodelist", " nodeselist", "nomist", "nodeelist", "neodist", "nannodeety", "nnodeelist", "nondist", "nODelist", " nodeto", "nodeselist", " nodeseline", "nannodeelist", "nanodelist", "nondeman", "noyelist", " nodist", "nodestyle", "neodeest", "nodeline", "nodedeline", "nomest", "snodeline", "nannodeemark", "snodemark", "noyeto", "nondest", "nodedelist", "neodeman", "neodeelist", "snodeeline", "snodeelist", "snodestyle", "noyeline", "nanodety", "nodemark", "nodedestyle", "nODeto", "nodedemark", "nodedist", "nanodemark", "nodedety", "snodeemark", "nostelist", "nodeestyle", "nodeeman", "nomelist", "neodeist", "noyist", "nodesist", "nomeman", "nondelist", "nanodist", "nosteline", "nnodeemark", "nodeseline", "neodest", "nnodeist", "nostemark", "nODeline", "nODist", " nodeseto", "snodeestyle"], "num": ["su", "m", "multi", "n", "man", "dim", "zero", "list", "mon", "np", "sum", "perm", "proc", "uni", "nam", "no", "umer", "total", "NUM", "mu", "alph", "nom", "number", "un", "count", "um", "mem", "Number", "UM", "con", "mn", "nu", "nm", "result", "om", "max", "coord", "set", "umi", "all", "cal", "Num", "net", "length", "mult", "current"], "i": ["m", "multi", "ip", "n", "ci", "ui", "ij", "batch", "l", "in", "it", "ex", "ji", "ei", "gi", "them", "ami", "I", "q", "phi", "us", "major", "index", "p", "im", "\u0438", "y", "iq", "li", "ii", "io", "ini", "iu", "ie", "bi", "pi", "j", "x", "wi", "me", "init", "e", "info", "cli", "ri", "ai", "sim", "z", "mi", "ix", "hi", "di", "this", "my", "a", "ic", "ti", "si", "history", "xi", "qi", "zi"]}}
{"id1": "255765", "id2": "3801655", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"f": ["d", "b", "v", "o", "m", "n", "fa", "l", "it", "fw", "h", "test", "q", "filename", "tf", "fab", "F", "base", "elf", "c", "name", "y", "fo", "fn", "cf", "rf", "fi", "form", "ft", "df", "fp", "ret", "fc", "j", "fed", "bf", "fm", "e", "dir", "info", "fac", "fb", "sf", "w", "file", "t", "fd", "fs", "exp", "lf", "def", "fr", "g", "r", "path", "fx", "fax", "p"], "in": ["inf", "o", "m", "n", "ac", "oin", "IN", "l", "inc", "it", "ex", " IN", "al", "thin", "inner", "cin", "h", "ins", "input", "mm", "re", "reader", "ind", "at", "lo", "rin", "bin", "im", "up", "In", "io", "is", "again", "by", "pi", "isin", "init", "con", "info", "iter", "ma", "er", "ai", "add", "t", "gin", "from", "local", "nin", "log", "make", "all", "en", "get", "inn", "r", "on", "ic", "din", " din"], "cbuf": ["abbfg", "cff", "CBf", "cbuffy", "abbuf", "rboff", "gbuff", "cbdf", "cbbf", "bcoff", "cbbuf", "bcdf", "sbuf", "rbbuf", "cduff", "gbuf", "CBbf", "cfbf", "cfuf", "cduf", "cbather", "cfuff", "sbather", "rbdf", "cduffy", "rbuffy", "CBuf", "cdoff", "rbather", "sbuff", "gbf", "rbfg", "abbbuf", "cdbuf", "cbfg", "sbbuf", "rbuf", "CBuff", "nbbuf", "bcbuf", "nbuff", "rbuff", "cboff", "bcather", "gbbf", "nbuf", "nbfg", "cbf", "abbdf", "bcfg", "bcuf", "CBbuf", "cbuff", "bcuff", "CBuffy"], "read": ["ed", "ip", "print", "it", "record", "data", "key", "q", "test", "reading", "fill", "hold", "io", "is", "pack", "ly", "end", "mix", "mem", "iter", "connect", "range", "reach", "get", "ok", "fail", "ink", "length", "current", "select", "dev", "report", "n", "parse", "raw", "link", " Read", "feed", "skip", "input", "index", "ext", "load", "open", "row", "rate", "est", "stream", "ke", "value", "handle", "allow", "depth", "start", "pre", "READ", "set", "ead", "find", "default", "run", "rank", "buffer", "reads", "shift", "x", "roll", "need", "give", "ignore", "Reader", "k", "play", "re", "reader", "ind", "slow", "core", "think", "clear", "send", "saw", "write", "trust", "check", "wait", "ai", "close", "r", "bind", "ready", "miss", "chain", "pe", "seek", "error", "burst", "scan", "ret", "count", "old", "sync", "add", "ank", "se", "log", "query", "hello", "view", "poll", "Read", "height", "text", "orig", "readable"], "totRead": ["tiatBreak", " toteFind", "tOTWrite", "tobyCheck", "tottedWrit", "tootVal", "totaFill", "tootRead", "ltotaLoad", "retotPrint", "ttotAdd", "totaHave", "tcotDisplay", "totSend", "notLoad", "tottPrint", "tOTFind", "toticRead", "atotaFill", "tottFind", "toiotVal", "trotRead", "trotSee", "tootSend", "notalPrint", "ltotaRead", "tcotCheck", "totedHave", "ptOTRead", "totalPrint", " totRun", "toteNeed", "totConnect", "notNeed", "notaRead", "notPrint", " totFind", "totNeed", "tacotConnect", "ptotFind", "notalWrite", "tottRun", "toteFill", "tokFind", "tobyLoad", "tootCheck", "ptotLoad", "tokWrite", "totFind", "totRun", "notCheck", "tcotRead", "toteLoad", "totaLength", "totalCheck", "toteRun", "totSee", "letrotRead", "totaConnect", "toteRead", "tobyRead", "totPrint", "totedFill", "totalLoad", "tiotWrit", "totalSee", "tcotVal", "totaCheck", "totaRead", "totaWrite", "totFill", "tootBreak", "ltotBuild", "toiotBreak", " totBuild", "ttotNeed", "tOTLoad", "letotRead", "ltotFill", "totWrit", "totAdd", " totalRead", "totalNeed", "totDisplay", "ttottRead", "atotRead", "tiatRead", "toteFind", "totaPrint", "tottedReader", "tOTNeed", "ptOTFind", "totBreak", "tokLoad", "toteBuild", "notalCheck", "tiatVal", "tiotBreak", "atotaPrint", "ptOTLoad", "tfatLoad", "retottReader", "totalWrite", "tfatRead", " toteRead", "tiotSend", "ptotRead", "tottNeed", "trotWrite", " totalLength", "toteReader", "totalRead", "totaSee", "totVal", "toteAdd", "tottedPrint", "retotReader", "tacotDisplay", "tottWrit", "ptOTWrite", "totReader", "notalLoad", "totaNeed", "tottWrite", "totLoad", "toteWrite", "ttotRead", "tootConnect", "tacotCheck", "tiotRead", "taotCheck", "taotRead", "letrotWrite", "toticWrite", "retotRead", "retotWrit", "taotConnect", "toteLength", "totaBuild", "toiotRead", "totedRead", "tottRead", "tOTRead", "ltotaBuild", "retottWrit", "letotSee", "tfatWrite", "ltotaFill", "tottedRead", "totHave", "totalLength", "totaLoad", "toticFind", "retottRead", "tcotSend", "totWrite", " totLength", "tacotRead", "notReader", "tiotPrint", "atotHave", "totBuild", "tobyWrite", "notalRead", "trotFind", "totCheck", "taotDisplay", "tiotReader", "tiatBuild", "tiotFill", "notaWrite", "atotPrint", "tcotBreak", "ltotLoad", "notaLoad", "tootDisplay", "ttotWrite", " totWrite", "tfatReader", "retottPrint", "atotaRead", "atotaHave", "totalBuild", "ttottAdd", "tcotConnect", "letotWrite", "notalNeed", "ltotRead", "totalFind", " totalBuild", "tobyNeed", "notaReader", "tiatLoad", "tiatSend", "ptotWrite", "totaDisplay", "letotFind", "tottReader", "atotFill", "totaAdd", "letrotFind", " toteWrite", "toiotSend", "tottAdd", "ttottWrite", "letrotSee", "tiotHave", "tiotVal", "tokRead", "toticRun", "tobyPrint", " toteRun", "totLength", "totedPrint", " totalWrite", "notRead", "totaReader", "tiatFill", "ttottNeed", "totaFind", "notWrite"], "out": ["o", "b", "to", "n", "v", "ex", "oss", "obj", "res", "OUT", "at", "c", "os", "up", "Out", "io", "ou", "writer", "aos", "end", "sys", "we", "conv", "ch", "co", "write", "con", "w", "t", "s", "log", "auto", "g", "OU", "output", "outs", "r", "net", "or"], "i": ["m", "b", "ip", "print", "it", "ei", "q", "c", "y", "ini", "io", "is", "client", "bi", "ity", "pi", "me", "init", "t", "integer", "mi", "ix", "you", "hi", "o", "v", "to", "index", "dr", "im", "oi", "ki", "ii", "any", "j", "set", "id", "ic", "I", "x", "xi", "p", "uri", " I", "PI", "ci", "ui", "l", "mm", "ind", "\u0438", "iq", "iu", "php", "um", "info", "ai", "ico", "sim", "s", "ice", "iii", "di", "iy", "r", "si", "ie", "zi", "ij", "multi", "gi", "ami", "chain", "phi", "us", "status", "li", "ski", "e", "cli", "ri", "ion", "ia", "point", "g", "ims", "this", "my", "ti", "ji", "qi"]}}
{"id1": "3266833", "id2": "2642914", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"is": ["ris", "isi", "in", "bis", "lis", "sis", "ists", "parts", "has", "isa", "us", "was", "ais", "os", "ois", "its", "any", "IS", "Is", "isf", "sys", "isin", "iso", "init", "serv", "bits", "ios", "info", "s", "iss", "fs", "iris", "as", "get", "isl", "bs", "isc", "i"], "name": ["n", "code", "null", "in", "named", "create", "Name", "NAME", "key", "body", "data", "filename", "string", "location", "term", "image", "self", "template", "base", "admin", "sequence", "prefix", "description", "type", "alias", "number", "class", "ame", "title", "version", "info", "position", "word", "size", "search", "names", "value", "file", "local", "handle", "normal", "format", "url", "part", "id", "order", "get", "default", "this", "path", "family", "length", "i", "current", "parent", "source"], "contentType": ["messageUnit", "messageTypes", " contentControl", "messageLength", "contenttype", "ContentType", "messageType", "fileLength", "messageControl", " contentLength", "mediaQuery", "ContentLength", "messagetype", "mediaControl", "contentLength", "contentTypes", " contenttype", "contentUnit", "mediatype", "fileType", "fileTypes", "contentQuery", "mediaTypes", "contentControl", "mediaUnit", "Contenttype", " contentUnit", "mediaType", " contentTypes", "fileQuery", "mediaLength", "messageQuery", "ContentTypes"], "index": ["n", "access", "batch", "pos", "list", "code", "num", "create", "Index", "address", "axis", "key", "test", "action", "ind", "image", "timeout", "sequence", "prefix", "open", "type", "error", "si", "number", "dx", "row", "offset", "count", "fee", "info", "position", "size", "level", "value", "depth", "start", "max", "length", "id", "success", "sort", "update", "find", "content", "exclusive", "lock", "path", "slice", "x", "i", "height", "instance"], "extension": ["extitude", "protitude", "protention", "contend", "protension", "contitude", "xtitude", "protend", "xtention", "contension", "contention", "xtend", "xtension", "extention", "extend"], "isImage": ["ISimage", "isoItemImage", "areImage", "isoImage", "ISImage", " isMedia", "wasFile", "wasMedia", "ISPhoto", "needsImage", "isaimage", "isoFile", "isFile", "needsMedia", "ISPicture", "needsPicture", "isimage", "areMedia", "wasimage", "needsimage", " isItemImage", "hasFile", "isaPicture", "wasImage", "hasImage", "isPicture", "needsFile", "isItemImage", "isaImage", "needsPhoto", "isMedia", "areFile", "isaPhoto", " isFile", "isPhoto", "hasMedia", "isoMedia", "hasimage", "areItemImage"], "isAux": ["isAcUX", " isCAaux", "isAAux", "isiAiox", "isPamp", "isCAx", "wasAAUX", "isSAaux", "isAx", "isinAaux", " isCAux", "isCAux", " isAUX", "wasAUX", "isSAux", "isCAiox", "isiOAux", "isinPamp", "isAAult", "isinAux", "isiOAiox", "isNAaux", "isOAiox", "isNAux", "isPaux", "isAxx", " isAaux", "isSAmp", "isAult", "isAndx", "isOAaux", "isOAUX", "isNAUX", "isAcux", "isAAxx", "isAcx", "isAcaux", "isiAuxe", "wasAult", "isinAmp", "isAiox", "isOAux", "isPaUX", "isinAUX", "wasAux", "isinPaUX", "wasAAult", "isSAUX", "isauxe", "isCAUX", "isiAux", " isAx", "wasAxx", "wasAAux", "isAndUX", "isaux", "isiOAaux", "isiOAuxe", "wasAAxx", "isAmp", "isaiox", "isaaux", "isCAuxe", "isCAaux", "isOAult", "isNAmp", "isAaux", "isAUX", "isOAuxe", "isAndux", "isAuxe", "isinPaux", " isCAx", " isCAUX", "isinPaaux", "isiAaux", "isAAUX", "isPaaux", "isAndaux", "isOAxx"], "out": ["o", "b", "n", "to", "batch", "v", "null", "pos", "list", "in", "oss", "ex", "cache", "conn", "it", "sum", "chain", "cos", "res", "user", "OUT", "timeout", "at", "os", "up", "Out", "io", "aos", "by", "outer", "sys", "we", "vol", "co", "con", "port", "go", "w", "ion", "t", "gc", " output", "boot", " Out", "auto", "log", "ent", "result", "all", " OUT", "order", "OU", "output", "outs", "tmp", "lock", "this", "pool", "net", "cn", "conv", "p", "nt"], "bufferedImage": ["bufferingImage", "renderingVideo", "bufferredimage", "buffererImage", "bufferingImages", "renderedimage", "renderedImage", "buffererVideo", "renderingImage", "bufferedVideo", "bufferredImage", "bufferredVideo", "bufferedImages", "renderedImages", "renderingImages", "renderingimage", "bufferingVideo", "buffererImages", "bufferingimage", "buffererimage", "renderedVideo", "bufferedimage", "bufferredImages"], "inputStream": ["currentView", "InputSteam", "outputstream", "InputStream", "outputSteam", "inputstream", "InputView", "outputView", "currentStream", "Inputstream", "inputSteam", "outputStream", "currentSteam", "currentstream", "inputView"]}}
{"id1": "20751378", "id2": "19868933", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"hashPassword": [" hashpassword", "updateText", " hashText", "HashText", "HashPassword", "updatePassword", "Hashpassword", "hashPrivate", " hashPrivate", "updatePrivate", "hashpassword", "hashText", "HashPrivate", "updatepassword"], "password": ["Password", "security", "shadow", "print", "secret", "command", "address", "key", "reset", "property", "user", "pass", "input", "string", "database", "directory", "username", "padding", "expression", "token", "sword", "login", "name", "prefix", "PASS", "description", "attribute", "language", "email", "client", "device", "wd", "connection", "phrase", "auth", "application", "comment", "column", "request", "word", "crypt", "w", "value", "pattern", "argument", "wordpress", "query", "encrypted", " Password", "hello", "default", "message", "p"], "hash": ["uh", "cache", "print", "sh", "shadow", "zero", "ash", "hed", "html", "key", "ho", "test", "user", "reading", "total", "string", "array", "other", "dig", " hashing", "sha", "report", "her", "tr", "address", "h", "locking", "index", "token", "also", "replace", "build", "title", "version", "copy", " Hash", "value", "handle", "here", "result", "alert", "object", "tag", "method", "shift", "bh", "sum", "response", "Hash", "hing", "str", "class", "where", "trust", "hex", "put", "crypt", "check", "search", "mask", "message", "ping", "has", "filter", "rh", "username", "cloth", "ashing", "ha", "mass", "number", "ah", "block", "oh", "alg", "log", "proof", "hello", "checking", "height"], "md": ["d", "m", "man", "ad", "ld", "cd", "js", "mand", "bd", "pd", "hd", "obj", "grad", "MD", "mm", "det", "od", "dr", "ind", "pm", "mod", "cmd", "dd", "red", "der", "df", "sam", "nd", "ms", "dir", "and", "dh", "mt", "mc", "mn", "managed", "add", "mp", "mk", "sm", "del", "sd", "dm", "di", "ds", "sha"]}}
{"id1": "5436973", "id2": "13946197", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 0, "substitutes": {"httpToStringStupid": ["httpToStrStuid", "httpToStrStuff", "httpToStringUuid", "httpToStrUuid", "httpToStrStupid", "httpToStringRestuid", "httpToStringRestupid", "httpToStringRestuff", "httpToStringUuff", "httpToStringUamp", "httpToStringSnuff", "httpToStringSnamp", "httpToStrUamp", "httpToStringUupid", "httpToStrUupid", "httpToStringStuff", "httpToStringSnuid", "httpToStrUuff", "httpToStrStamp", "httpToStringStuid", "httpToStringSnupid", "httpToStringRestamp", "httpToStringStamp"], "url": ["http", "b", "pl", "link", "web", "l", "ll", "address", "key", "server", "string", "location", "p", "base", "name", "loc", "password", "char", "str", "ul", "ssl", "dl", "u", "ref", "ret", "ur", "https", "URL", "file", "pattern", "result", "Url", "id", "host", "path", "page", "out", "i", "ls", "uri"], "IOException": ["TimeoutError", "TimeoutException", "ioException", "ioError", " IOError", "IOError"], "HttpException": ["RuntimeException", "HttpError", "HTTPError", "httpException", "HTTPException", "httpError", "RuntimeError"], "InterruptedException": [" InterruptException", "InterruptionEx", "InterruptionError", "InterinterruptedEx", "InterruptEx", "InterruptedEx", "InterinterruptedException", "InterruptError", "InterruptedError", " InterruptedError", " InterruptError", "InterinterruptedError", " InterruptedEx", "InterruptionException", " InterruptEx", "InterruptException"], "URISyntaxException": ["URISyntlexEx", "URISyntlexWarning", "URISeticaxEx", "URISeticntaxWarning", "URISyntixEx", "URISeticntaxEx", "URISyntntaxWarning", "URISyntaxEx", "URISyntixWarning", "URISyntntaxException", "URISeticntaxException", "URISyntaxWarning", "URISeticaxWarning", "URISyntlexException", "URISyntixException", "URISyntntaxEx", "URISeticaxException"], "pageDump": ["pageStump", "pageSump", "pageStdump", "pageDoumper", " pageDumper", "pageDumps", "pageSumper", "pagePash", "pagedump", "pageDoump", " pageDamp", "pageDumper", "pagedumps", "pagePdump", "pageStash", "pagePump", "pageStamp", "PageDumps", "pageDodump", "pageSumps", "pageDoumps", "PageDumper", "PageDdump", "pageDdump", "pagePamp", "PageDump", "pageddump", "pageSdump", "pagedumper", " pageDumps", "pageDamp", " pageDash", "pageDash", " pageDdump"], "httpget": [" httpGET", " httpfind", "ttppost", "httpcall", " httppost", "ttpcall", "ttpget", "httpGET", "HTTPget", "hoverGet", "httpfind", " httpGet", "ttpGet", "HTTPGet", "httpcreate", "HTTPfind", "Httppost", "Httpget", " httpcreate", "hoverGET", "ttpfind", "Httpfind", "httppost", "HTTPGET", "hovercreate", "ttpcreate", "hoverget", "HTTPcreate", "httpGet", "Httpcall", " httpcall"], "response": ["entry", "report", "pos", "command", "resp", "body", "respond", "res", "onse", "status", "that", "yes", "answer", "document", "sequence", "still", "description", "attribute", "open", "json", "connection", "application", "reply", "request", "block", "next", "service", "profile", "result", "Response", "successful", "content", "object", "event", "output", "message", "given", "page", "remote", "frame"], "entity": ["entry", "security", "detail", "address", "body", "obj", "pe", "el", "inv", "environment", "Entity", "activity", "image", "ee", "group", "ITY", "document", "person", "email", "json", "ity", "icon", "unit", "e", "me", "comment", "ce", "metadata", "resource", "existent", "result", "ent", "model", "encrypted", "voice", "content", "object", "event", "output", "page", "ie", "line"]}}
{"id1": "3584508", "id2": "13891080", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": ["copyAddress", " copyFile", "downloadUrl", "downloadFile", " copiedAddress", " copiedFile", " copiedUrl", "downloadAddress", "copyUrl", " copyAddress", "downloadResource", "copyFile", " copyUrl", " copiedResource"], "url": ["browser", "http", "link", "null", "web", "l", "ll", "html", "rl", "address", "rel", "el", "re", "string", "hl", "base", "loc", "cert", "char", "f", "str", "ul", "mail", "gif", "ssl", "dl", "ret", "ref", "ur", "nl", "mount", "https", "URL", "resource", "file", "gl", "service", "ml", "Url", "sl", "fl", "github", "cl", "host", "r", "mb", "path", "util", "ls", "uri", "source"], "input": ["http", "ip", "access", "raw", "feed", "null", "parse", "in", "it", "inner", "sum", "missing", "index", "user", "audio", "reader", "image", "exec", "base", "state", "unknown", "accept", "up", "Input", "inside", "open", "pull", "form", "cont", "ssl", "act", "context", "qa", "init", "active", "upload", "info", "request", "iter", "enter", "stream", "add", "acl", "file", "local", "eval", "start", "read", "config", "can", "initial", "op", "ain", "get", "focus", "empty", "PUT", "before", "text", "select", "source"], "output": ["o", "print", "continue", "null", "web", "hidden", "network", "secondary", "four", "unsigned", "bool", "entity", "response", "image", "remote", "group", "table", "secure", "ou", "client", "outer", "text", "icon", "other", "connection", "write", "position", "put", "beta", "ilo", "next", "format", "file", "auto", "exit", "update", "success", "console", "object", "component", "Output", "net", "display", "out", "ne", "you", "online", "current"], "b": ["d", "m", "v", "l", "body", "k", "obj", "ble", "base", "c", "B", "y", "rb", "bp", "char", "f", "by", "ab", "bi", "u", "bit", "ba", "j", "bf", "br", "buff", "bits", "cb", "ib", "fb", "block", "be", "t", "wb", "gb", "bb", "bc", "eb", "binary", "g", "nb", "db", "mb", "sb", "bs", "r", "i", "ob", "z", "p"]}}
{"id1": "1798720", "id2": "9261777", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"save": ["pkg", "data", "install", "filename", "download", "store", "folder", "aw", " seal", "accept", "Save", "pack", "register", "export", "send", " Save", "upload", "saving", "init", "version", "dump", "release", "update", "zip", "delete", "archive"], "packageName": ["packagename", "PackageId", "modulename", " packageNames", "moduleKey", "pkgName", "PackageType", " packageType", "packageNames", "pkgCode", "PackageNames", "moduleNames", "packageCode", " packageId", "moduleName", "packageType", " packagename", "packageKey", "pkgKey", "pkgNames", "PackageName", " packageKey", "moduleId", "pkgId", "pkgType", "moduleCode", " packageCode", "pkgname", "packageId"], "fileContents": ["byteContent", "packageContent", "FileNames", "pageBytes", "byteContents", "FileItems", "byteValues", "packageIngredients", " fileContent", "fileContent", "pageContents", " fileIngredients", " fileItems", "FileValues", "FileContents", "packageNames", "FileIngredients", "FileBytes", " fileValues", "fileValues", "fileItems", "pageNames", "FileContent", " fileBytes", "byteNames", "fileBytes", "fileIngredients", "packageContents", "pageItems"], "fileNames": ["dirLeaks", " fileKeys", "FileNames", " fileLeaks", "dirKeys", "resourceNumbers", "messageNames", "fileName", "FileKeys", " fileNumbers", "fieldNumbers", "moduleContents", "FileValues", "moduleVaults", "messageName", "FileContents", "issueName", "issueContents", "fileVaults", "moduleNames", "fieldNames", "moduleName", " fileName", " fileValues", "fileValues", "issueVaults", "FileName", "messageKeys", "resourceValues", "FileTypes", " fileVaults", "fieldContents", "fileTypes", "dirTypes", " fileTypes", "fieldTypes", "fileKeys", "resourceTypes", "FileLeaks", "resourceNames", "dirNames", "messageValues", "fileNumbers", "issueNames", "fileLeaks", "resourceContents"], "dirBase": ["pkgBas", "pkgBase", "dirBottom", "DIRBottom", "irBas", "dirBasic", "DirBuilder", "dirSet", "DirBase", "pkgbase", "directoryBasic", "directoryBase", "folderBase", "irbase", "DIRBase", "dirbase", "dirBuilder", " directoryBuilder", "dirBas", "pathBas", "pathBase", "directorybase", " directoryBas", "DIRBuilder", "irSet", "DIRBas", " directoryBase", "folderbase", "irBase", "folderBas", "pathbase", " directoryBottom", "pathBasic", "folderBasic", "DirBas", "directorySet", "pkgSet", "directoryBas", "DirBottom"], "packageDir": ["packageRel", "moduleFolder", "packageFolder", "moduleRel", "packageDef", "pkgFolder", "installDist", "pkgDef", "installD", " packageD", " packageDef", "podD", " packageRel", "pkgDir", "installDef", "moduleDir", "packageDist", "podDist", "podDef", "modulePath", "pkgPath", "packagePath", " packagePath", " packageDist", "packageD", " packageFolder", "moduleDef", "installDir", "podDir", "pkgRel"], "created": ["generated", "forced", "printed", "create", "Created", "recorded", "joined", "loaded", "checked", "developed", "added", "founded", "registered", "allowed", "TED", "associated", "mounted", "produced", " generated", "locked", "reported", "arted", "provided", "installed", "activated", "creat", "defined", "present", "existent", "confirmed", "called", "ced", "creation", "creator", "successful", "raised", " started", "started", "filled", "given", "released", "ready", "made"], "currentPath": ["currentlyFile", "recentPoint", "currentlyPath", " currentName", "CurrentFile", "CurrentPath", "recentParent", "currentParent", "currentlyName", " currentPoint", "CurrentPoint", "recentPath", " currentFile", " currentCh", "currentName", "currentFile", "recentName", "CurrentParent", "CurrentCh", "CurrentName", "currentlyCh", "currentCh", " currentParent", "currentPoint"], "i": ["m", "ip", "in", "it", "ei", "key", "q", "major", "y", "ini", "bi", "ity", "pi", "me", "init", "go", "mi", "ix", "exp", "hi", "o", "v", "ex", "them", "index", "im", "os", "oi", "ki", "ii", "jj", "u", "j", "id", "ic", "I", "xi", "p", "uri", "ci", "ui", "batch", "ind", "iq", "iu", "f", "info", "ai", "sim", "iii", "di", "iy", "si", "ie", "zi", "ij", "multi", "yi", "gi", "ami", "chain", "phi", "cgi", "mu", "status", "li", "ski", "cli", "ri", "g", "this", "my", "slice", "ti", "ji", "qi"], "file": ["rule", "link", "disk", "l", "header", "h", "body", "play", "p", "child", "base", "template", "name", "fo", "table", "io", "type", "handler", "f", "ile", "row", "dir", "comment", "info", "sf", "port", "le", "resource", "File", "format", "handle", "local", "log", "set", "db", "path", "pool", "page", "buffer", "et", "FILE", "parent", "source"], "fos": ["ffaos", " foes", "sfos", "foes", "oos", "flaos", "fOS", "oow", "Foss", " faos", "fow", "ffos", "floses", "flo", "fo", "floss", "woss", "Foes", "Fos", "woes", "wos", " foss", "floes", "foss", "Fo", "ffo", "fbaos", "oaos", "FOS", "fbos", "flos", " fow", " fOS", "fbow", " foses", "woses", "sfOS", "foses", "fbo", "Faos", "sfaos", "oo", " fo", "ffoes", "sfoss", "faos"], "fileSrc": ["fileSource", "jobSrl", "jobSci", "fileSrl", "jobNri", "fileInssrc", " fileSRC", " fileInssrc", "fileErc", "fileEci", "fileErl", "fileInrc", "fileSri", "jobNrc", "fileInource", "fileSRC", "fileSci", "jobNrl", " fileInsource", "fileNrc", "fileDri", "jobSri", "fileInsrc", "fileDrc", "fileInsource", "fileDource", "fileEri", " fileSource", " fileInsRC", "fileInRC", "jobSrc", "fileDci", "fileDrl", "fileInsRC", " fileInsrc", "fileNrl", "fileNci", " fileSsrc", "fileDsrc", "jobNci", "fileDRC", "fileSsrc", "fileNri"], "fileDst": ["FileDlt", "fileDnd", "filednd", "filedld", "fileDot", "fileSnd", "FileSpl", "fileScr", "FileSlt", "FileDcr", "fileWpl", "fileDpl", "filedst", "FileSst", "fileNnd", "fileWlt", "filedcr", "fileNld", "fileNpl", "fileDcr", "fileSld", "FileDot", "fileWot", "fileSst", "fileSot", "fileSpl", "FileSot", "FileDld", "FileSld", "fileDld", "FileScr", "FileDnd", "FileDst", "fileNlt", "fileNot", "fileDlt", "fileNst", "fileWst", "fileSlt", "FileSnd", "FileDpl", "fileNcr"], "reader": ["entry", "ocker", "book", "rl", "inner", "Reader", "controller", "ro", "ner", "reading", "rar", "parser", "dr", "rot", "upper", "rx", "actor", "handler", "rer", "author", "oder", "row", "rc", "context", "review", "runner", "iter", "roller", "er", "ri", "stream", "iterator", "resource", "driver", "rr", "loader", "read", "ler", "query", "ader", "Larry", "r", "buffer", "readable"], "writer": ["browser", "entry", "report", "print", "walker", "wire", "operator", "function", "server", "flush", "adder", "Reader", "test", "wright", "writing", "store", "window", "parser", "user", "editor", "maker", "Writer", "table", "document", "builder", "wrapper", "handler", "later", "client", "worker", "outer", "caster", "write", "ter", "runner", "liner", "draw", "riter", "writers", "iter", "word", "manager", "println", "stream", "w", "iterator", "format", "driver", "service", "loader", "read", "creator", "query", "storage", "console", "variable", "order", "player", "buffer"], "line": ["entry", "rule", "link", "continue", "print", "code", "l", "record", "detail", "lin", "eline", "source", "edge", "node", "header", "chain", "pe", "user", "date", "label", "string", "entity", "stroke", "sequence", "style", "number", "row", "inline", "cell", "Line", "ine", "valid", "nl", "sample", "liner", "comment", "column", "ln", "block", "word", "port", "le", "LINE", "range", "ole", "point", "lined", "message", "page", "kin", "frame", "text"]}}
{"id1": "21368981", "id2": "14464131", "code1": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"create": ["submit", "insert", "launch", "install", "execute", "post", "process", "api", "send", "Create", "build", "write", "activate", "save", "upload", "request", "creat", "add", "created", "read", "creation", "release", "get", "hello", "instance"], "application": ["b", "entry", "code", "command", "usage", "data", "address", "amount", "system", "database", "information", "expression", "base", "document", "sequence", "description", "language", "type", "attribute", "client", "json", "api", "provided", "request", "position", "Application", "binding", "value", "resource", "service", "apache", "aton", "content", "management", "object", "component", "face", "app", "message"], "response": ["report", "summary", "entry", "continue", "command", "detail", "network", "function", "resp", "server", "respond", "site", "hash", "onse", "index", "information", "status", "image", "answer", "document", "sequence", "description", "attribute", "collection", "json", "api", "me", "reply", "example", "request", "version", "position", "block", "next", "add", "value", "format", "complete", "service", "profile", "respons", "Response", "result", "library", "model", "relation", "object", "view", "see", "output", "default", "message", "page", "action", "frame", "tree"], "connection": ["entry", "n", "link", "conn", "command", "condition", "operation", "generation", "web", "network", "usage", "pointer", "session", "server", "function", "no", "statement", "connected", "user", "location", "directory", "database", "information", "volume", "expression", "Connection", "c", "builder", "open", "language", "collection", "description", "attribute", "license", "client", "wrapper", "engine", "container", "cone", "device", "number", "bo", "subject", "when", "machine", "con", "government", "version", "position", "method", "connect", "ion", "library", "creation", "office", "close", "set", "query", "relation", "component", "event", "reference", "translation", "channel", "communication", "character"], "obj": ["o", "objects", "bj", "js", "np", "err", "data", "resp", "body", "dict", "ctx", "inv", "obs", "msg", "os", "arr", "tk", "adj", "str", "json", "onet", "org", "j", "ref", "og", "obb", "Obj", "uj", "oj", "ent", "obo", "object", "utt", "output", "po", "tmp", "ob", "txt", "nt"]}}
{"id1": "3401153", "id2": "19868933", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"getHTML": [" getJS", "printPDF", " getURL", "processHTML", "printHTML", "getPDF", "printJS", "printURL", " getPDF", "processJS", "processPDF", "processURL", "getJS", "getURL"], "pageURL": ["baseURI", "pageUrl", "PageURI", "baseUrl", " pageUR", "baseURL", "pageURI", " pageURI", "cacheurl", "cacheURL", "baseUR", "PageURL", "PageUR", " pageurl", "Pageurl", "cacheUrl", "pageUR", "PageUrl", " pageUrl", "cacheURI", "pageurl"], "encoding": ["encoder", "decoder", "Encuation", "encuation", "decaching", "enoding", "ecoded", "ecaching", "ecoding", "Encaching", "enaching", "uncoder", "enoder", "ecoder", "uncaching", "encaching", "uncoding", "decuation", "uncoded", "Encoding", "Encoded", "decoding", "encoded", "enuation", "Encoder"], "dirPath": [" dirDirectory", "viewPATH", "directoryPath", "viewPath", "pkgName", "dirName", "dirRoot", " dirRoot", "folderDir", "pkgDir", "viewName", "pkgDirectory", "pathRoot", "dirPATH", "dirDir", "pkgPath", "dirDirectory", "directoryDir", "directoryPATH", "viewDir", "folderPath", "pathDir", " dirFile", "pathPath", "pathFile", "dirFile", "folderFile", " dirName", " dirPATH", "directoryName", "directoryDirectory", "folderRoot", " dirDir"], "pageHTML": ["displayHTML", " pageSQL", "pageHTTP", "entryJS", "ageSQL", "pageAPI", "entryAPI", "PageHTTP", "componentWP", "ageJSON", "searchHTML", "entryHTML", " pageWP", "searchJS", "pointHTML", "ageWP", "searchHT", "viewHTML", "PageHT", "componentHTML", "pageMD", " pageMD", "ageMD", " pageHT", "ageHT", "displayJS", "pageSQL", "pointAPI", "viewMD", "searchURL", "viewJSON", "componentHT", "pageHT", " pageJS", "PageHTML", "pageJS", "entryHTTP", "PageURL", "displayHTTP", "viewPUT", " pagePUT", "agePUT", "ageHTML", "displayURL", "pagePUT", "pointHTTP", "PageJS", " pageAPI", "pageWP", "pageJSON", "componentSQL", "pointJS", " pageHTTP", " pageJSON"], "connection": ["browser", "http", "entry", "to", "link", "conn", "web", "condition", "socket", "generation", "command", "network", "operation", "session", "server", "user", "statement", "connected", "processor", "database", "directory", "response", "Connection", "c", "document", "still", "open", "io", "description", "writer", "client", "engine", "number", "channel", "bo", "nc", "application", "con", "government", "position", "established", "internet", "connect", "ion", "resource", "library", "creation", "creator", "close", "console", "relation", "reference", "message", "remote", "communication", "character", "current", "uri"], "url": ["http", "b", "link", "conn", "web", "l", "ll", "rl", "address", "rel", "p", "location", "base", "atl", "name", "open", "google", "client", "f", "str", "ul", "ssl", "dl", "api", "ur", "nl", "bel", "https", "URL", "resource", "gl", "loader", "Url", "sl", "get", "r", "path", "net", "ls", "uri"], "br": ["b", "BR", "pr", "bh", "tr", "bd", "ber", "wr", "dr", "bt", "kr", "rb", "bp", "shr", "buf", "str", "ch", "cr", "bf", "sp", "bro", "er", "be", "mr", "vr", "bb", "bc", "gb", "fr", "hr", "bl", "r", "lr", "bs", "sr", "Br", "bridge"], "line": ["entry", "print", "continue", "link", "code", "l", "detail", "lin", "eline", "source", "chain", "label", "user", "string", "entity", "stroke", "sequence", "field", "email", "style", "number", "row", "cell", "Line", "ine", "inline", "stay", "online", "phrase", "nl", "sample", "liner", "comment", "section", "ln", "block", "word", "le", "LINE", "range", "log", "point", "quote", "page", "frame", "text"], "e": ["ed", "err", "ex", "fe", "pe", "esome", "eeee", "re", "ee", "xe", "error", "oe", "ue", "f", "ine", "ze", "ge", "he", "er", "be", "ce", "ve", "le", "je", "ke", "te", "ite", "se", "es", "ent", "E", "eb", "ae", "en", "ode", "see", "event", "de", "x", "ne", "ie", "p"], "file": ["report", "ca", "print", "link", "web", "data", "h", "el", "directory", "image", "base", "name", "table", "io", "email", "f", "ile", "mail", "fp", "tile", " File", "work", "dir", "task", "port", "le", "resource", "File", "handle", "log", "output", "db", "lock", "path", "page", "out", "buffer", "et", "FILE", "parent"], "bufferedWriter": ["builteredWriter", " bufferedwriter", "bufferingReader", " bufferedStreamer", "bufferedClient", " bufferredStreamer", " bufferredClient", "bufferingClient", "bufferredWrite", " bufferedHelper", "bufferedReader", "buffererWriter", "buffaredWrite", "bufferedWrite", "buffaredMember", "buffererReader", "bufferingWriter", "bufferingStreamer", "buffaredStreamer", "buffenedWriter", "bufferedStreamer", "buffaredwriter", "builteredMember", " bufferedClient", "bufferingHelper", " bufferredWrite", "bufferedwriter", " bufferedWrite", "buffaredWriter", " bufferredwriter", "bufferredWriter", "buffenedClient", " bufferredHelper", "bufferingWrite", "bufferredClient", "bufferingwriter", "builteredReader", "buffaredReader", "bufferredStreamer", "bufferredwriter", "builteringWriter", "bufferedMember", "buffenedWrite", "bufferredHelper", "buffenedHelper", "buffererMember", "bufferedHelper", "builteringReader", "builteringMember", " bufferredWriter", "bufferingMember"]}}
{"id1": "6341264", "id2": "5543349", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getServerResource", " getJarInfo", "getResourceResource", "getServerEntry", " getJarItem", "getFileItem", "getZipEnt", "getResourceItem", " getZipEntry", "getResourceInfo", "getJarFile", "getJavaEnt", "getServerItem", " getFileItem", " getFileResource", "getJavaFile", "getModuleItem", "getZipFile", " getFileInfo", "getFileEntry", " getZipItem", "getZipItem", "getJarResource", "getServerInfo", "getJarItem", "getModuleEntry", "getZipEntry", " getFileEntry", "getJarEnt", " getZipEnt", " getZipFile", "getModuleEnt", "getModuleFile", "getJavaItem", "getJavaEntry", " getJarFile", "getResourceEntry", " getJarEnt", "getFileInfo", "getFileResource", "getJarInfo", " getJarResource"], "jarName": ["jarname", "jarKey", "sessionKey", "jarLocal", "jobname", "jobN", "sessionName", "jobLocal", "binaryName", " jarLocal", "binaryname", "JarN", "Jarname", " jarname", " jarN", " jarKey", "jarN", "JarLocal", "sessionname", "JarName", "binaryKey", "jobName"], "entry": ["jar", "print", "command", "data", "key", "address", "xml", "server", "uri", "input", "index", "string", "name", "field", "description", "ie", "cell", "row", "e", "comment", "element", "enter", "word", "er", "search", "resource", "file", "log", "ent", "query", "zip", "delete", "Entry", "path", "archive", "text", "ry", "quit"], "port": ["age", "ip", "pos", "project", "pt", "socket", "it", "address", "server", "key", "PORT", "index", "priority", "string", "limit", "type", "width", "localhost", "export", "row", "offset", "count", "connection", "eport", "pc", "version", "position", "value", "format", "ort", "start", "Port", "point", "host", "path", "ports", "page", "remote", "length", "p"], "b": ["pb", "d", "v", "l", "bas", "h", "buffer", "bt", "base", "bin", "c", "B", "y", "bp", "emb", "f", "buf", "ab", "bi", "u", "j", "ba", "bit", "bf", "e", "br", "buff", "cb", "ib", "bits", "fb", "be", "s", "wb", "gb", "bb", "eb", "bl", "xb", "sb", "r", "mb", "nb", "bs", "db", "a", "i", "ob", "p"], "codebase": [" codebas", " codease", "codebas", "codefile", "corebase", "linkBase", "Codebased", "cheBase", "Codebas", "Codebase", "codeBase", "codespace", "CodeBase", "chespace", "ceBase", "Codespace", "cebase", "cease", "coreBase", "chefile", "codebased", "cebased", " codeBase", "linkbase", "Codefile", "codease", "corespace", " codebased", "chebase", "Codease", "linkbas", "corefile"], "protocol": ["scheocol", "protos", "patotype", "patol", "cryptotype", "cryptix", "scheility", "cryptol", "proavior", "scheix", "phyility", "pronotype", "proticle", "pertotype", "protication", "phyication", "proocol", "phyix", "phyocol", "cryptos", "pronavior", "pertavior", "protix", "prototype", "cryptility", "cryptication", "perticle", "pronicle", "pronocol", "cryptocol", "protol", "proos", "patos", "protavior", "prool", "proicle", "pertocol", "prootype", "protility", "scheication", "patocol"], "x": ["nex", "n", "xx", "xy", "ex", "px", "wx", "index", "xa", "ox", "xf", "xxxxxxxx", "y", "rx", "xc", "xes", "dx", "xp", "ux", "w", "mx", "xs", "t", " cx", "ix", "tx", "max", "xd", "X", "ax", "inx", "i", "xi", "z", "p"], "s2": ["es02", "ss4", "s1", "ps2", "sv02", "s4", "pslt", "sv1", "ss3", "x02", " stwo", "s3", " s02", "estwo", "ps1", "es1", "ts02", "ps02", "sv2", "svtwo", "xlt", "slt", "ts3", "stwo", "ss2", "s02", "ss02", "ts4", "x1", "es2", "ts2", " s1", " slt"], "x2": ["ex02", "ix1", "x02", "ax1", "ex1", " x3", "rx2", "ex3", "x3", "ax3", "ax2", "rx02", "ex2", " x1", "ax02", "ix2", " x02", "x1", "ix02", "rx1"], "downloadHost": ["dumphost", "transferPort", "DownloadDomain", "Downloadhost", "DownloadHead", "downloadDomain", "dumpUrl", "downloadNode", " downloadPort", "downloadUrl", "dumpDomain", "DownloadPath", " downloadUrl", "DownloadHost", " downloadHead", "transferUrl", "archiveUrl", " downloadPath", "downloadPort", "archiveHead", "archivehost", "downloadPath", "dumpPath", "dumpHost", " downloadhost", "transferHost", "downloadhost", "DownloadNode", "archiveHost", "downloadHead", "DownloadUrl", " downloadDomain", " downloadNode", "transferhost", "dumpNode", "DownloadPort"], "url": ["browser", "http", "pl", "jar", "link", "web", "l", "ll", "arl", "rl", "rel", "obj", "el", "call", "download", "hl", "lb", "base", "atl", "name", "loc", "open", "www", "json", "str", "ul", "il", "mail", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "bel", "serv", "mount", "URL", "gl", "file", "log", "ml", "Url", "sl", "zip", "lr", "sb", "mil", "ob", "ls", "uri"], "jurl": ["jarname", "zUrl", "jcname", "jpUrl", "jURL", "jarurl", "Jname", "zgl", "jjurl", "zurl", " jll", "jjjob", "jcUrl", " jUrl", "jjUrl", "Jkl", "jsll", "jUrl", " jURL", "jll", "jname", "jpurl", "jkl", "jssl", "zll", "jarkl", "jsjob", "Jurl", "jpgl", " jjob", "jsl", "jpsl", "jcurl", " jgl", "jgl", "JUrl", "jarUrl", "jsurl", "jckl", "jsURL", "jsUrl", "jjURL", "jjob", " jsl", "jsgl"], "je": ["nex", "bj", "zy", "js", "ei", "ja", "elt", "jo", "ffe", "sec", "pe", "ee", "jp", "oe", "jj", "vre", "ze", "j", "ge", "e", "pet", "ve", " Je", "te", "dj", "zo", "ese", "jl", "se", "jet", "jen", "exe", "ae", "zip", "ne", "ie", "ele"], "is": ["ris", "isi", "in", "js", "atis", "lis", "sis", "ists", "isa", "ins", "obs", "ir", "ais", "im", "os", "si", "ois", "ii", "ires", "tis", "its", "IS", "bi", "il", "Is", "isin", "iso", "\u00eds", "bits", "ib", "ios", "nis", "ri", "ai", "s", "iss", "mi", "es", "fs", "ist", "isl", "sb", "bs", "isc", "i"], "bis": ["xy", "ris", "isi", "bh", "bes", "oss", "onis", "lis", "pins", "sbm", "ubis", "abin", "ins", "res", "obs", "ibe", "rison", "rs", "ais", "bps", "os", "oi", "aos", "tis", "its", "bi", "vs", "conv", "isin", "bits", "buff", "cb", "serv", "bytes", "bil", "rots", "ios", "uds", "nis", "ri", "uffy", "bos", "es", "fs", "ses", "bb", "fr", "binary", "sb", "bs", "ns", "gs", "ob", "ls"], "size": ["scale", "ose", "n", "capacity", "time", "settings", "use", "Size", "space", "num", "mode", "sum", "body", "sex", "index", "sy", "re", "status", "year", "name", "shape", "area", "notice", "type", "number", "SIZE", "zie", "small", "count", "iz", "ze", "pi", "sv", "unit", "send", "sample", "score", "news", "sn", "now", "nr", "range", "se", "ize", "max", "storage", "empty", "scroll", "message", "length", "si", "len"], "rb": ["pb", "rw", "err", "rex", "RB", "ctr", "num", "rt", "rob", "ring", "ro", "rd", "rar", "lb", "rs", "bone", "umb", "bp", "rod", "rf", "ob", "buf", "ref", "rc", "cr", "br", "cb", "nr", "ptr", "fb", "ri", "kb", "rid", "rm", "buster", "rab", "wb", "mr", "gb", "bb", "rss", "eb", "rg", "xb", "nb", "sb", "db", "r", "ord", "lr", "ru", "erb", "ruby"], "chunk": ["Chunks", "tchunk", "cow", "chedoint", " chord", "tchow", "ichunk", " chump", "ichulk", "charunk", " chulk", "ichunks", "choint", "echbyte", "cork", "cpow", "charord", "tchunks", "echunk", "charbyte", "cunks", " chbyte", "cpork", "charunks", " chunks", "chow", "chord", "chbyte", "chedunk", "cpunks", "Chulk", "chulk", "cpunk", "echunks", "charoint", "chump", "charump", "chedump", " choint", "Chunk", "echord", "chork", "chunks", "cunk", "tchork", "chedunks"]}}
{"id1": "11477906", "id2": "16142024", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["readdefaultSettings", "loaddefaultsettings", "loaddefaultSettings", "loaddefaultSetting", "loadDefaultSetting", "loaddefaultValues", "loadDefaultValues", "loadFAULTSetting", "readDefaultValues", "readDefaultSettings", "loadFAULTSettings", "loadDefaultsettings", "readDefaultsettings", "readDefaultSetting", "loadFAULTValues", "readdefaultSetting", "readdefaultValues", "loadFAULTsettings", "readdefaultsettings"], "configFileName": ["configFilenamename", "configFileNames", "configFILEPath", "configFileLocation", "configStreamname", "configPagePath", "configFilenameName", "configFilenameLocation", "configStreamName", "configFilePath", "configFilenameNames", "configfilePath", "confFileNames", "configFILEName", "conffileNames", "confFilename", "configStreamLocation", "configFilenamePath", "conffilePath", "confFilenameName", "configPagename", "confFilePath", "confFileLocation", "configStreamPath", "confFilenamePath", "configfileNames", "configPageNames", "configfileName", "configFILELocation", "configFilename", "conffilename", "confFileName", "configPageName", "configFILEname", "conffileName", "confFilenamename", "confFilenameLocation", "configfilename"], "in": ["inf", "m", "o", "n", "IN", "l", "it", "ad", "al", "inner", "cin", "ins", "doc", "input", "user", "re", "ro", "ind", "rin", "bin", "im", "up", "In", "ini", "is", "ar", "or", "ze", "isin", "e", "init", "con", "info", "mc", "ma", "check", "ai", "t", "gin", "from", "mi", "id", "en", "ain", "run", "inn", "on", "i", "din", "ls", " din", "source"], "out": ["m", "cache", "null", "it", "ins", "user", "io", "client", "sys", "ge", "init", "ot", "con", "w", "t", "file", "ne", "o", "n", "to", "raw", "v", "ex", "store", "at", "os", "over", "up", "Out", "aos", "copy", "une", "handle", "read", "ent", "output", "de", "not", "nt", "oss", "server", "ing", "OUT", "ind", "des", "writer", "off", "check", "port", "can", "all", "en", "OU", "outs", "po", "or", "obj", "are", "res", "ou", "co", "ion", "gc", "log", "auto", "gt", "update", "net", "cn", "conv"]}}
{"id1": "1698200", "id2": "2017833", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginByteshare", "loginByteShare", " loginbitShare", " loginBitshare", "loginBitshare", "loginByteStock", "loginbitShare", "loginbitshare", " loginbitStock", " loginBitStock", " loginbitshare", "loginBitStock", "loginbitStock"], "params": ["http", "types", "settings", "tags", "cp", "services", "members", "pins", "keys", "parts", "requires", "points", "hash", "options", "mm", "parser", "posts", "cms", "param", "rs", "caps", "details", "properties", "ams", "json", "photos", "Parameters", "pi", "Par", "auth", "headers", "pas", "metadata", "acl", "changes", "names", "pres", "config", "chains", "stats", "pps", "ps", "ports", "pretty", "comments", "gs", "terms", "p"], "httpclient": ["httpsrequest", "ttpco", "http2", "httpcli", "hyperconnection", "Httpclient", " http2", "hyperclient", "httpsconnection", "Httprequest", "https2", "httpClient", "httpscli", "httco", "httcontroller", "ttpcontroller", "Httpconnection", " httpcli", "httpsco", "httclient", "httpsClient", "ttpClient", " httpconnection", "ttpclient", "httpsclient", "httpscontroller", "hyper2", "httpcontroller", "httpco", " httpClient", "httprequest", "hypercli", "HttpClient", "httClient", " httprequest", "httpconnection"], "httppost": [" httpost", " httpom", " httpppost", "httploint", " httppop", "httposter", "httplpost", "httpom", "httpost", "httppoint", "httpoint", "httppart", "httphpost", "httpplop", " httpop", "httpploint", "httpposter", "httppom", "httmpost", "httpppart", "httppop", "httploster", "httpploster", "httpperop", "httpplpost", "httpart", "httplart", "httpperpost", " httppom", "httpppop", "httphost", "httplost", "httpperom", "httpperost", "httpop", "httpppoint", "httmpart", "httpplost", "httppposter", "httmppost", "httphoint", "httplop", "httplom", "httppppost", "httpppost", "httmpop", "httphoster", "httpplart"], "formparams": ["formerrors", "functionproperties", "formednames", "formauthors", " formParameters", "functionmembers", "condsettings", "inputparams", "formchanges", "formdetails", "formmembers", "foremembers", "foreparams", "functionargs", "formedtags", "forechanges", "formsettings", " formchanges", "condnames", "inputerrors", "batchnames", "formederrors", "feedParameters", "batchparams", "condparams", "batchtags", "formtags", " formnames", "batcherrors", "inputdetails", " formdetails", "foreproperties", "foreargs", "forenames", "formargs", "formnames", "foresettings", "foreauthors", "inputnames", " formparam", "formParameters", "functionparams", " formargs", "foredetails", "inputtags", "inputparam", "formparam", "inputParameters", " formauthors", "condproperties", "feedparam", "feeddetails", " formmembers", "formproperties", "functionchanges", " formproperties", "functiondetails", " formsettings", "formedparams", "feedparams", "functionauthors"], "entity": ["orm", "entry", "security", "ENT", "html", "create", "xml", "data", "body", "el", "eme", "inv", "user", "Entity", "ew", "activity", "ee", "template", "ITY", "document", "person", "form", "line", "ity", "json", "enc", "note", "em", "fee", "comment", "ce", "metadata", "profile", "ent", "quote", "content", "object", "component", "event", "empty", "out", "buffer", "ell"], "httpresponse": ["httpresp", "HTTPconnection", "ttpconnection", "httpresult", "procresult", "HTTPreply", "procresponse", " httpresp", "httpconnection", " httpResponse", "ttpresponse", "HTTPresponse", "httpreply", "procreply", "HTTPresp", "ttpResponse", " httpreply", "HTTPresult", " httpconnection", "ttpresp", "procResponse", "httpResponse", "HTTPResponse", " httpresult"], "it": ["ed", "v", "ip", "l", "ex", "MIT", "al", "rit", "el", "you", "IT", "ind", "at", "It", "im", "ate", "ert", "ect", "li", "is", "its", "il", "itter", "ul", "iz", "act", "est", "init", "ut", "st", "ot", "he", "iter", "itted", "ite", "t", "mit", "ent", "sit", "lit", "ist", "ic", "i", "et"], "escookie": ["esctrl", "isecookie", "eyancel", "desccookie", "eycookie", "iseccookie", "descookie", "eccake", "esccookie", "ecookie", "espcookie", "escace", "ectrl", "eyace", "desctrl", "httpscookie", "ecoder", "ecace", "ecog", "ecue", "Esccookie", "occcake", "escue", "espookie", "escotton", "iseccake", "occcookie", "eccookie", "occookie", "escancel", "espancel", "descue", "Escue", "httpsookie", "httpsotton", "ecancel", "occog", "isecoder", "escoder", "Esctrl", "occoder", "espace", "escog", "ecotton", "occotton", "Escookie", "esccake", "eyookie", "httpsog"]}}
{"id1": "16590954", "id2": "13783549", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"createJAR": ["createJAP", "createPHARS", "createGAP", "createIJARS", "createPHART", "saveJART", "saveJAP", "createPHAR", "createIJAP", "saveIJAP", "createGART", "createIJART", "createJARS", "createIJAR", "createJART", "saveIJAR", "createGAR", "saveJARS", "createGARS", "saveIJARS", "saveIJART", "createPHAP", "saveJAR"], "fileString": ["Filestring", "pathstring", "fileStr", "pathStr", " filestring", " fileText", "ileString", "messageName", " fileRest", "ileStr", "pathString", "filestring", " fileStr", "FileText", " fileName", "FileName", "FileRest", "messageStr", "ilestring", "messageString", "fileRest", "FileString", "ileName", "fileText", "FileStr", "ileRest", "messageText", "fileName"], "ext": ["rest", "suff", "ex", "except", "js", "tex", "desc", "EXT", "ind", "req", "name", "external", "type", "cmd", "pat", "char", "end", "str", "cont", "text", "Ext", "enc", "ime", "append", "xp", "e", "off", "format", "t", "ort", "exp", "ix", "xt", "exe", "fr", "typ", "prot", "gz", "path", "txt"], "file": ["http", "tree", "report", "to", "cache", "link", "list", "null", "disk", "time", "data", "h", "memory", "user", "store", "input", "doc", "image", "base", "name", "table", "document", "open", "io", "type", "line", "f", "ile", "channel", "mail", "fp", "this", "class", " File", "module", "work", "force", "info", "port", "le", "url", "resource", "t", "File", "from", "handle", "local", "log", "format", "model", "get", "default", "output", "run", "db", "lock", "path", "pool", "message", "page", "buffer", "foo", "FILE", "parent", "source"], "i": ["o", "m", "n", "ip", "ci", "v", "ui", "gi", "ami", "phi", "index", "ind", "ir", " j", "c", "ini", "ii", "li", "is", "f", "ati", "bi", "pi", "j", "x", "ri", "ai", "t", "s", "mi", "id", "di", "I", "si", "xi", "p"], "dir": ["d", "done", "disk", "project", "pkg", "direct", "star", "rel", "root", "folder", " directory", "DIR", "directory", "dist", "ind", "ir", "mod", "loc", "dd", "dy", " folder", "wd", "vol", "org", " Dir", "div", " d", "url", "home", "del", "direction", "part", "id", "db", "lib", "tmp", "path", "addr", "Dir", "uri"], "jarFile": ["javaName", "jName", "jarFILE", "jarField", "JarEmail", "javaFile", "tarFile", "jfile", "jFile", " jarName", " jarFilename", "jFilename", "javaFilename", "Jarfile", " jarfile", "javafile", "JarField", "JarFilename", "jarEmail", "tarEmail", "JarFile", "pkgFile", "tarFilename", "jarFilename", "jarfile", " jarField", "tarfile", "jarName", "pkgField", "pkgFILE", "JarFILE", " jarEmail", " jarFILE"], "fstrm": ["ftrdm", "fdrm", "fcrms", "fbstrms", "ftrp", "fstrp", "fbstrp", " fdrcm", " fdrmed", "ftrcm", "fstrdm", "fstrmed", "fcrp", "fsprp", "fbsprm", "fdrcm", "fstrum", " fstrum", "fstrcm", " fdrm", "fbsprms", "fdrum", "fcrdm", "fsprms", "fbsprp", "fslm", " fstrcm", "ftrm", "fbstrm", "fcrm", "fbsprdm", "fslmed", "fsprm", " fdrum", "ftrms", "fdrmed", "fsprdm", "fbstrdm", "fslum", "ftrmed", "ftrum", "fstrms", "fslcm", " fstrmed"], "in": ["inf", "m", "o", "oin", "IN", "it", "inc", "pin", " IN", "inner", "cin", "ins", "input", "mm", "re", "ind", "rin", "bin", "im", "up", "In", "inside", "io", "is", "f", "pi", "isin", "init", "iter", "ai", "add", "gin", "from", "read", "en", "inn", "sin", "r", "ic", "din", " din"], "out": ["o", "m", "v", "n", "to", "conn", "null", "ex", "it", "inner", "cos", "obj", "inv", "OUT", "at", "c", "os", "io", "Out", "ou", "aos", "writer", "client", "outer", "channel", "cont", "conv", "ch", "co", "serv", "w", "t", "s", "gc", "cm", "OU", "output", "outs", "net", "cn", "p"], "temp": ["m", "tree", "Temp", "cache", "to", "fake", "null", "pt", "cp", "full", "thread", "memory", "res", "util", "mm", "directory", "term", "template", "tem", "name", "mod", "document", "tar", " temporary", "cont", "porary", "tm", " Temp", "EMP", "parent", "mem", "copy", "mt", "mint", "t", "mp", "local", "TM", "mk", "wrap", "tt", "tx", " tmp", "emp", "current", "zip", "output", "tmp", "path", "stem", "pool", "Tem", "dest", "buffer", "tc", "orig", "p"], "fstrm2": ["fstrM1", "fStrtm1", "fstrcm7", "fStrp2", "fstrcm1", "fstrM7", "fstrmm1", "fStrp7", "fStrm2", "fstrmm2", "fstrcm2", "fstrtm2", "fstrm1", "fstrp2", "fstrp1", "fstrM2", "fStrp1", "fStrtm2", "fStrm1", "fStrm7", "fstrtm1", "fstrp7", "fstrm7"], "ostrm": ["ortRM", "ostnm", "ostrem", "ostlamm", "osnm", "osrm", "istmr", "istm", " ostrom", "osRM", "astRM", "ostmr", " ostnm", "ortrom", " ostRM", "istRM", "astm", " ostlamm", "astlamm", "oslamm", "ortlamm", "ortrm", " ostrem", "astrm", "osm", "ostrom", "astmr", "ostRM", "osmr", "astrom", "astrem", "istnm", "istrm", "ostm", "osrem", "istrem", " ostm"], "docFile": ["docLine", "DocFiles", "documentFiles", "DocLine", "docDir", " docPath", "documentFile", "Docfile", "manPath", " docfile", "DocFile", "DocDir", "docPath", "documentLine", "docfile", "manFile", "DocPath", "manfile", " docDir", " docLine", " docFiles", "documentDir", "docFiles", "manDir"]}}
{"id1": "8815137", "id2": "17792212", "code1": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"copyToDir": ["copytoDir", "copyFromFile", "copyToFile", "transfer2Dir", "copy2Directory", "transfer2Directory", "copyFromDir", "transferToPath", "transferToDirectory", "copyFromPath", "transfer2Path", "copy2Path", "copytoFile", "copyToDirectory", "transferToDir", "copy2Dir", "copytoDirectory", "copytoPath", "transfer2File", "copyToPath", "copy2File", "transferToFile", "copyFromDirectory"], "dir": ["d", "ds", "dis", "disk", "pos", "null", "md", "tr", "det", "pkg", "data", "full", "rel", "root", "res", "doc", "folder", "re", "DIR", "directory", "desc", "dr", "window", "rec", "ext", "base", "ir", "req", "name", "mod", "loc", "dd", "fin", "cont", "wd", "draft", "vol", "src", "init", "module", "div", "old", "manager", "cur", "local", "fd", "mk", "del", "id", "def", "spec", "dist", "dm", "db", "tmp", "lib", "path", "de", "out", "Dir", "parent"], "file": ["cache", "print", "null", "project", "full", "controller", "limit", "msg", "state", "used", "io", "type", "init", "force", "le", "url", "local", "File", "get", "page", "change", "FILE", "current", "source", "report", "to", "link", "h", "label", "base", "open", "fn", "ile", "fp", "title", "module", "task", "resource", "value", "handle", "result", "output", "p", "entry", "rule", "disk", "filename", "play", "flag", "issue", "entity", "image", "f", "core", "il", "class", "info", "port", "format", "job", "all", "db", "message", "out", "tree", "parent", "line", "http", "use", "create", "el", "status", "name", "table", "field", "form", "unit", "domain", "comment", "log", "model", "lock", "this", "path", "foo"], "fileOutputStream": [" fileOutputForm", "fileLogStream", "fileInputView", "FileOutputSteam", "fileControlSocket", "fileSystemSocket", " fileWriteSteam", "filePutSteam", "FileInputSteam", "filePutStream", "fileOutputSocket", "fileOutputstream", "fileSystemStream", " fileWriteForm", "fileInputSteam", "FileInputForm", "fileWriteForm", "filePutstream", "filePutForm", " fileWriteStream", "FileInputSocket", "fileOutputView", "fileOutputSteam", " fileOutputstream", "FileOutputForm", " fileOutputSteam", "fileInputSocket", "fileSystemSteam", "fileOutputForm", "fileSystemView", "fileControlView", "fileControlSteam", "fileControlStream", "FileOutputView", "fileLogSteam", " fileWritestream", "FileOutputSocket", "fileWriteSteam", "fileInputstream", "FileInputView", "fileInputForm", "fileLogForm", "fileWriteStream", "fileWritestream", "FileOutputStream", "FileInputStream"], "fileInputStream": ["fileOutputController", "FILEInputStreamer", "fileInputThread", " fileOutputController", " fileInputSource", "FileOutputSteam", "fileOutputList", "fileinputSource", "FILEOutputstream", "FileInputSteam", "fileinputRead", "fileOutputSource", "fileOutputstream", "fileInputSteam", "fileOutputStreamer", "fileOutputRead", "FILEOutputStreamer", " fileInputController", "fileInterStreamer", "FILEOutputStream", "FileInputList", "fileInsertStream", "FileInputRead", " fileOutputSource", "fileInsertList", "fileOutputSteam", "fileInputStreamer", "fileInsertRead", "fileinputStream", "FILEInputThread", "FILEOutputThread", "fileOutputThread", "fileInputSource", " fileOutputSteam", "fileInController", "FileOutputRead", "FileOutputList", "fileinputList", "fileInputList", " fileInputSteam", "FILEInputStream", "fileInputController", "fileInterstream", "fileinputController", "fileinputSteam", "FILEInputstream", "fileInputRead", "fileInterStream", "fileInsertSteam", "fileInSource", "fileInputstream", "fileInStream", "fileInterThread", "fileInSteam", "FileOutputStream", "FileInputStream"], "read": ["have", "report", "n", "parse", "need", "print", "raw", "shift", "in", "push", "num", "skip", " write", "input", "index", "reading", "tell", "reader", "ind", "req", "seek", "load", "shape", "hold", "open", "pack", "height", "end", "seen", "count", "send", "offset", "write", "x", "trust", "size", "with", "check", "wait", "add", "stream", "last", "ask", "start", "ready", "READ", "close", "set", "find", "get", "ok", "run", "r", "i", "each", "length", "Read", "reads", "readable", "len"], "buffer": ["capacity", "batch", "cache", "print", "command", "Buffer", "header", "filter", "chain", "body", "memory", "window", "available", "template", "table", "button", "sequence", "document", "bar", "attribute", "char", "buf", "row", "phrase", "sample", "buff", "append", "stack", "iter", "block", "word", "stream", "reason", "result", "variable", "binary", "initial", "event", "message", "page", "history", "frame", "text"]}}
{"id1": "2518655", "id2": "5744992", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"fnOut": ["synOut", "synOr", "synOutput", " fnIn", "pdfOs", "bfIn", "dnOutput", " fnOutput", "pdfNet", "fnIn", " fnNet", "bfNet", " fnOr", "bfOs", "fnOr", " fnOs", "pdfOut", "bfOut", "pdfIn", "fnNet", "fnOutput", "dnOr", "dnIn", "dnOut", "fnOs", "synIn"], "writer": ["rator", "report", "zero", "print", "walker", "her", "operator", "inner", "writing", "flush", "wright", "window", "parser", "reader", "journal", "editor", "maker", "Writer", "table", "builder", "wrapper", "external", "fn", "handler", "white", "client", "worker", "width", "aster", "outer", "commit", "send", "caster", "write", "writ", "runner", "comment", "and", "riter", "writers", "println", "w", "written", "format", "file", "driver", "service", "loader", "master", "auto", "widget", "creator", "close", "console", "variable", "buffer"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "batch", "v", "it", "ei", "gi", "key", "q", "chain", "phi", "us", "ind", "im", "\u0438", "c", "y", "ki", "ini", "li", "is", "gu", "ski", "ii", "iu", "client", "ie", "bi", "pi", "u", "j", "x", "me", "init", "ma", "ri", "ai", "sim", "mi", "ti", "hi", "ix", "id", "ogi", "g", "di", "ims", "my", "ic", "I", "si", "xi", "qi", "uri"], "fInput": ["lNew", " fOutput", "sfOutput", "sfInput", "fIn", "cfNew", "sfIn", "fileinput", "fileIn", "fileInput", "sfinput", "finput", "cfinput", "fileOutput", "lOutput", "fOutput", "linput", "lInput", " fIn", " finput", "fNew", "cfOutput", "cfInput", " fNew"], "in": ["inf", "n", "IN", "thin", "inc", "pin", "it", "al", "inner", "cin", "ins", "input", "re", "ind", "vin", "rin", "bin", "In", "inside", "is", "ini", "client", "again", "or", "conv", "isin", "serv", "con", "din", "info", "ln", "ma", "check", "t", "gin", "all", "en", "conf", "inn", "sin", "r", "out", "kin", " din"]}}
{"id1": "3252116", "id2": "5723876", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMC1", "getmd1", "Getmd4", "getMC4", "Getmd10", "GetMD5", "getMD10", "getmd4", "getMC10", "getmd5", "GetMD4", "GetMD10", "getMD4", "getHash1", "getHash4", "getHash5", "getMD1", "GetMD1", "getMC5", "getmd10", "Getmd1", "getHash10", "Getmd5"], "source": ["b", "code", "secret", "null", "data", "SOURCE", "site", "target", "input", "ser", "string", "seed", "image", "template", "base", "c", "name", "sequence", "f", "style", "subject", "src", "sample", "e", "ource", "copy", "origin", "Source", "file", "from", "start", "content", "object", "output", "this", "message", "dest", "buffer", "text"], "s": ["ds", "b", " ans", "bes", "js", " returns", "ws", "parts", "ins", "p", "rs", "gets", "os", "S", "ss", "hs", "ads", "ends", "uns", "its", " sets", "abs", "eps", "cs", " ss", " outputs", "xs", "t", " streams", "ts", "sts", "es", "fs", "ses", "ats", " samples", "ings", " rs", " gets", "sb", " ts", "ps", "ies", "bs", "a", "ns", " ls", "gs", "ls", " fs", " es"], "hexDigits": ["hexDities", "exdigals", "hexdigists", " hexDigals", " hexDigities", "hexFunbits", " hexDigbits", "hexPosits", "hexdigities", "hexDigit", "exDigities", "hexPositions", "exDigals", "hexDigitions", "hexdigbits", "hexDists", "exdigits", "hexDits", " hexDigitions", "hexdigals", "exDigits", "hexFunals", "hexDigities", "hexDigbits", "hexDigists", "hexFunit", " hexDigists", "hexdigit", "exdigities", "exdigitions", "hexdigits", "hexPosals", "exDigitions", "hexDitions", "hexdigitions", "hexDigals", " hexDigit", "hexPosities", "hexFunits"], "md": ["d", "m", "amd", "ad", "cd", "ld", " Md", "bd", "pd", "hd", "grad", "MD", "desc", "mm", "det", "od", "dr", "ind", "cond", "mod", "cmd", "dd", "red", "der", "df", "pdf", "ms", "nd", "dig", "dh", "td", "mt", "mc", "mn", "add", "rm", "mk", "sm", "sd", "dm", "di", "mb", "de", "nt"], "tmp": ["comp", "Temp", "xy", "fake", "yy", "js", "np", "bis", "html", "pkg", "test", "proc", "obj", "ctx", "perm", "dirty", "up", "table", "sup", "bag", "img", "sp", "buff", "cb", "cmp", "bytes", "cur", "xs", "mp", "local", "etc", "tt", "qq", "emp", "params", "sym", "zip", "db", "nb", "mb", "temp", "txt"], "str": ["m", "b", "v", "n", "cast", "print", "list", "it", "cat", "tr", "ctr", "data", "Str", "obj", "string", "arc", "dr", "c", "name", "arr", "stri", "char", "ar", "buf", "vol", "ch", "cr", "sp", "e", "br", "st", "div", "txt", "hex", "cs", "iter", "STR", "w", "t", "sl", "sw", "set", "sc", "fr", "r", "gr", "out", "text", "p"], "k": ["K", "m", "d", "v", "n", "ks", "b", "kw", "l", "unk", "key", "h", "q", "ik", "kh", "c", "ikk", "ak", "kj", "tk", "sk", "f", "kar", "km", "j", "kk", "ko", "ka", "w", "ke", "t", "z", "mk", "id", "kl", "set", "ku", "ck", "kan", "ok", "g", "kt", "kid", "x", "kn", "p"], "i": ["o", "m", "ip", "n", "ci", "ui", "multi", "print", "ij", "in", "it", "ji", "gi", "chain", "phi", "index", "p", "status", "im", " j", "\u0438", "ini", "li", "ii", "io", "iu", "is", "bi", "pi", "j", "u", "conv", "x", "e", "me", "info", "cli", "ri", "ai", "sim", "mi", "ti", "ix", "hi", "inter", "di", "v", "ic", "I", "si", "xi", "qi", "zi"], "byte0": ["Byte1", "Byte140", "byte140", "byte3", "byte1", "Byte3", " byte140", "byte8", " byte8", "pixel6", "pixelElement", "node8", "channel140", "Byte0", "hex1", " byteElement", "pixel1", "Byte8", "byteElement", "channel3", "node2", "byte6", " byte6", "byte2", "hex0", "pixel0", "channel0", " byte3", " byte2", " byte1", "channel1", "Byte2", "node0", "hexElement", "node1", "hex6"]}}
{"id1": "12039034", "id2": "494226", "code1": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 0, "substitutes": {"importRoles": ["importResles", "importRles", "importPules", "importResoles", "importPole", "importPles", " importRole", "importResole", "importResules", "importRole", "importPoles", " importRles", "importRules", " importRules"], "urlString": ["urlRest", "urlList", " urlList", "UrlSource", "uriSource", " curlList", "uristring", "urlStr", " URLRest", "UrlStr", " URLList", "UrlString", " curlRest", " urlSource", " curlString", " urlRest", " urlstring", " urlStr", " URLStr", "Urlstring", " curlStr", "uriString", " URLString", "urlstring", "urlSource", "uriStr"], "results": ["reports", "ults", "objects", "forms", "images", "sets", "csv", "settings", "tops", "blocks", "times", "parts", "roots", "users", "helps", "uploads", "res", "options", "posts", "features", "pieces", "parents", " Results", "details", "places", "properties", "runs", "tests", "its", "RESULTS", "photos", "ces", "artifacts", "works", "changes", "rates", "Results", "s", "games", "relations", "result", "items", "es", "modules", "ands", "finals", "successful", "chains", "olds", "outs", "rings", "values", "abilities", "maps", "locks", "reads", "rows", "vals", "prints", "products"], "url": ["browser", "http", "b", "pl", "link", "web", "l", "ll", "q", "rel", "el", "p", "re", "lb", "base", "loc", "open", "char", "f", "str", "ul", "mail", "ssl", "dl", "u", "ret", "ur", "nl", "mount", "URL", "resource", "file", "gl", "Url", "sl", "get", "r", "uri"], "in": ["inf", "m", "IN", "l", "inc", "ill", "inner", "cin", "sum", "body", "ins", "el", "input", "buffer", "doc", "reader", "ind", "rin", "bin", "In", "is", "io", "by", "f", "serv", "con", "and", "iter", "file", "from", "fs", "get", "conf", "inn", "on", "i", "out", "din"], "buff": ["pb", "comp", "b", "Buffer", "tab", "grow", "tf", "rend", "bind", "cond", "aux", "builder", "zz", "uf", "alph", "cmd", "ob", "ff", "form", "col", "hold", "buf", "bed", "tm", "row", "bo", "pdf", "build", "mem", "conv", "bg", "raf", "nd", "cb", "off", "fb", "urg", "printf", "prof", "qq", "bb", "fr", "bm", "bound", "uff", "zip", "roc", "sb", "tmp", "mb", "supp", "Buff", "bs", "ack", "ck", "buffer", "butt", "txt", "quit"], "line": ["entry", "n", "code", "link", "command", "l", "record", "lin", "eline", "header", "node", "body", "chain", "pe", "no", "label", "string", "lines", "msg", "lo", "stroke", "cmd", "email", "str", "cell", "row", "Line", "ine", "inline", "channel", "nl", "note", "e", "sample", "liner", "comment", "ln", "block", "iter", "word", "le", "LINE", "file", "lane", "range", "log", "lf", "ice", "point", "page", "out", "buffer", "frame", "text", "len"], "name": ["n", "ename", "named", "num", "node", "Name", "NAME", "key", "nam", "system", "string", "group", "sequence", " Name", "prefix", "person", "spe", "qual", "alias", "number", " names", "mem", "common", "ame", "cap", "title", "zone", "names", "value", " NAME", "profile", "nm", "ni", "part", "member", "id", "ident", "role", "ns", "cn", "instance"]}}
{"id1": "3046085", "id2": "9371421", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"s": ["m", "b", "n", "strings", "v", "js", "data", "h", "q", "string", "rs", "c", "name", "os", "gs", "S", "is", "ss", "f", "its", "str", "e", "ls", "w", "t", "es", "g", "r", " ts", "ps", "a", "ns", "i", "text", "p"], "tokenizer": ["webize", "Tokenized", "Tokenifier", "okenizer", "terminitor", "okenifier", " tokenner", "datezer", " tokenizable", "kinize", "toolizers", "tokeniser", "webization", " tokenifier", " tokeniner", "operatorizer", "operatorized", "terminization", "dateize", "terminize", "tokenitor", "okenisher", "tokener", "tokenoser", "serialize", "okenoser", " tokenisher", "okenazer", "webizable", " tokenzer", "operatorization", "terminazer", "templateization", "Tokener", "toolizer", "Tokenzer", "templateizer", " tokenoser", "nodeizer", "operatorzie", "okenitor", "webitor", "okenener", "toolzer", "Tokenner", "Tokenize", "dateizer", "webisher", "Tokenization", "okenize", "valueisher", "kinizer", "Tokenizer", "templateer", "operatorisher", "Tokenisher", "okeniser", " tokener", "terminisher", "tokenizers", "terminiter", "terminiser", "toolize", "serializable", "kinizers", "templateizable", "operatoriser", "kinzer", "nodeized", "tokenize", "okeniter", "tokenener", "tokenzie", "operatoriter", "okenzie", "templatezer", "nodeization", "templateisher", "tokenzer", "tokenner", "serialzer", " tokenzie", "tokenisher", "valueizer", "serializer", "okenzer", "terminizer", "nodeisher", "okenner", "operatorazer", "operatoriner", " tokenener", " tokenization", "webizer", "tokenazer", "Tokenener", "terminizable", "okeniner", "tokenized", "tokeniner", "tokenization", "tokenizable", "Tokenizers", "dateizable", "okenizable", "tokeniter", "valueizable", "tokenifier", "valueoser"], "title": ["summary", "important", "itled", "horse", "filename", "label", "displayText", "total", "term", "template", "tip", "name", "table", "itle", "prefix", "lead", "description", "type", "meta", "author", "Title", "phrase", "note", "version", "position", "primary", "metadata", "t", "profile", "part", "holiday", "id", "article", "tag", "art", "story", "text", "source"], "artist": ["project", "music", "user", "folder", "audio", "Artist", "directory", "username", "song", "volume", "image", "track", "person", "attribute", "author", "associated", "adult", "chapter", "position", "metadata", "assisted", "album", "part", "creator", "voice", "picture", "object", "component", "photo", "gallery", "tag", "player", "art", "rank", "archive", "item", "source"], "location": ["near", "Location", "time", "phone", "address", "folder", "directory", "activity", "shape", "loc", "area", "layout", "description", "language", "feature", "media", "country", "comment", "origin", "position", "zone", "local", "direction", "gallery", "reference", "place", "translation", "source"], "rating": ["scale", "playing", "scoring", "erate", "music", "boarding", "meta", "ranking", "training", "fps", "frequency", "media", "confidence", "rate", "genre", "average", "rated", "weight", "score", "metadata", "rates", "movie", "profile", "Rating", "library", "race", "credit", "rank"], "overplay": [" overgrade", "Overplay", "appride", "Overcast", "appgrade", " override", "appplay", "appcast", "Override", "overgrade", "override", " overcast", "overcast", "Overgrade"], "temp": ["Temp", "partial", "cache", "generated", "fake", "time", "null", "Temperature", "key", "test", "memory", "term", "base", "template", "tem", "name", "loc", "prefix", " temporary", "type", "flash", "porary", "tm", " Temp", "orig", "unit", "mem", "texture", "now", "local", "created", "set", " tmp", "emp", "encrypted", "empty", "output", "tmp", "stem", "buffer", "current", "source"], "tags": ["reports", "strings", "types", "images", "dates", "words", "keys", "parts", "options", "lines", "links", "assets", "details", "balls", "stars", "weights", "thumbnails", "files", "atts", "ags", "Tags", "names", "relations", "packages", "groups", "flags", "tracks", "fields", "lists", "styles", "stats", "lights", "pages", "marks", "comments", "nets", "terms"], "bytes": ["frames", "images", "words", "classes", "blocks", "services", "keys", "parts", "uploads", "lines", "seconds", "gets", "ids", "bps", "terms", "files", "bits", "videos", "loads", "tes", "ips", "es", "groups", "gb", "fields", "values", "mb", "pages", "bs", "comments", "Bytes", "gs", "rows", "vals", "len"], "hasher": ["hater", "haveest", "hascher", "hasHer", "haveher", "hadger", " hasest", "hydher", "haster", "haspher", "havehers", "hadHer", "hydger", "hadher", " hashed", " hader", " hascher", " hadDR", "Haspher", "hashed", "hadter", "hashers", "hasDR", "Haser", "haser", "hadcher", "hasest", "hadpher", "Hasher", " haster", " hasHer", "Hashed", " hasDR", "HasDR", " haser", "Haster", " hasger", "hadhed", "haher", " haspher", "hasger", " hashers", "hydcher", " hadher", "hahers", "hydHer", "haest", "haveter", " hadter"]}}
{"id1": "5951961", "id2": "10158738", "code1": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["http", "b", "pl", "parse", "link", "l", "ll", "arl", "h", "q", "el", "re", "hl", "lb", "base", "oul", "name", "loc", "char", "www", "f", "str", "ul", "abs", "ssl", "dl", "u", "ref", "build", "ur", "nl", "bel", "mount", "URL", "au", "gl", "ml", "Url", "sl", "github", "get", "r", "ls", "uu"], "httpCon": ["htmlCons", "httpCons", "ttpcon", "htmlCon", "HttpConn", "Httpcon", "ttpCon", " httpConnect", "HttpCon", "httpConnect", " httpCons", "ttpConn", " httpCON", "ttpCo", " httpConn", "buildCON", "buildCon", "ttpCons", "ttpConnect", "httpCON", "buildConnect", "httpConn", "htmlCON", "ttpCON", "buildConn", "httpCo", " httpcon", "htmlCo", "httpcon", " httpCo", "HttpConnect"], "out": ["d", "o", "report", "v", "to", "n", "print", "screen", "null", "list", "in", "ex", "it", "err", "data", "inner", "sum", "flush", "user", "OUT", "at", "one", "status", "msg", "std", "name", "up", "table", "error", "Out", "ou", "io", "writer", "aos", "sys", "co", "write", "init", "serv", "ln", "check", "println", "w", "s", "crit", "log", "auto", "can", "set", "exit", "all", "console", "output", "outs", "r", "net", "conv", "txt", "nt"]}}
{"id1": "15797402", "id2": "23517481", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["ping", "scale", "print", "use", "create", "xml", "filter", "execute", "pe", "parser", "process", "transform", "split", "load", "shape", "render", "php", "build", "write", "save", "patch", "add", "format", "resource", "handle", "dump", "se", "map", "interpret", "read", "close", "tag", "slice", "apply", "p"], "stream": ["http", "in", "data", "chain", "test", "download", "input", "clean", "window", "instance", "reader", "response", "image", "sequence", "document", "open", "form", "cont", "sample", "upload", "stack", "sync", "iterator", "resource", "file", "handle", "url", "read", "console", "content", "event", "zip", "Stream", "output", "message", "channel", "length", "buffer", "archive", "ream", "source"], "handler": ["policy", "address", "server", "function", "h", "ctx", "controller", "processor", "hander", "parser", "reader", "shape", "wrapper", "writer", "password", "worker", "callback", "Handler", "connection", "application", "hand", "resource", "handle", "service", "loader", "storage", "management", "event", "host", "message", "pool"], "metadata": ["m", "adata", "md", "material", "detail", "policy", "header", "data", "xml", "parts", "ctx", "property", "MD", "memory", "image", "template", "dirty", "unknown", "java", "document", "tar", "hold", "meta", "details", "properties", "dd", "definition", "google", "still", "basic", "json", "met", "pdf", "mem", "common", "module", "info", "td", "mt", "manager", "managed", "iterator", "handle", "config", "content", "management", "message", "general"], "context": ["null", "command", "condition", "network", "usage", "dict", "chain", "ctx", "environment", "options", "system", "location", "response", "state", "template", "document", "sequence", "collection", "Context", "connection", "module", "stack", "ce", "resource", "local", "reason", "config", "set", "sc", "content", "component", "event", "translation", "cc", "frame", "instance", "current"], "name": ["n", "null", "time", "l", "named", "create", "Name", "key", "NAME", "data", "body", "filename", "no", "label", "pass", "system", "string", "term", "image", "base", "prefix", "description", "type", "len", "client", "alias", "channel", "common", "nl", "lower", "ame", "title", "comment", "none", "old", "version", "size", "names", "value", "resource", "url", "service", "local", "reason", "nm", "file", "part", "id", "all", "default", "on", "path", "family", "current", "source"], "out": ["o", "n", "v", "to", "print", "list", "null", "gen", "in", "oss", "ex", "it", "sum", "flush", "cos", "obj", "us", "user", "res", "OUT", "one", "up", "table", "ou", "Out", "external", "aos", "col", "cmd", "io", "writer", "outer", "sys", "co", "lay", "serv", "con", "url", "file", "auto", "all", "conf", "OU", "output", "outs", "po", "net", "cn", "conv"]}}
{"id1": "19549489", "id2": "20091126", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" Copy", " duplicate", "csv", "cat", "cp", "create", "download", "paste", "Copy", "transfer", "load", "replace", "export", " cp", "write", "save", "upload", "move", "clone", "sync", "add", "rm", "map", "read", "delete", "Cop", "slice", " mirror"], "sourceFile": [" sourcePage", "Sourcefile", " sourcefile", "ourceFilename", "ourceFile", "sourcePage", " sourceLine", "ourceLine", "inputFile", "SourceFilename", "inputfile", "sourceFilename", "sourcefile", "SourceLine", "inputPage", "ourcefile", "SourcePage", "inputLine", "ourcePage", " sourceFilename", "sourceLine", "SourceFile"], "destinationFile": ["estinatedFilename", "destinationsFilename", "estinatedFile", "estinationfile", "declinatorPath", "declinationPlace", "destinatePlace", "destrativePlace", "destinationfile", "destinationsfile", "estinationPlace", "destinatedFile", "declinatorFile", "destinationsFile", "destinatorPath", "destinoFilename", "destinofile", "destinationPlace", "destinationPath", "destinatorFilename", "destinatedfile", "declinationFile", "destrativePath", "destinateFilename", "declinationPath", "destinationsPlace", "estinationFilename", "destinatorFile", "destrativeFile", "destinatePath", "destinoPlace", "declinationFilename", "declinatorPlace", "estinationFile", "destinatedPlace", "declinatorFilename", "destinateFile", "destinationFilename", "estinatedPlace", "estinatedfile", "destrativeFilename", "destinatorPlace", "destinoFile", "destinatedFilename"], "sourceFileChannel": ["sourceLineChannel", " sourceFileChuck", "sourceLinechannel", "sourceFileConnection", "sourceFileApplication", "sourceFileChan", "srcBlockConnection", "ourceFileChan", "sourceStreamChannel", "sourceBaseChuck", "ourceEntryChan", "srcBlockchannel", "ourceEntryConnection", "sourceFileHandler", "sourceStreamChan", "sourceStreamApplication", "sourceEntryChannel", "sourceBlockConnection", "srcBlockEntry", " sourceFileHandler", "sourceFileEntry", "sourceBaseApplication", "sourceBaseHandler", "ourceFileChannel", "sourceBytechannel", "sourceEntryChan", "sourceByteConnection", "sourceBlockEntry", "sourceStreamConnection", "srcBlockChannel", "ourceFilechannel", "sourceByteEntry", "sourceEntryConnection", "sourceStreamchannel", "sourceBlockchannel", "sourceBaseChannel", "srcFileConnection", "sourceByteChannel", "ourceEntrychannel", "sourceLineConnection", "ourceFileConnection", "sourceLineChan", "srcFileChannel", "sourceBlockChannel", "srcFilechannel", "sourceLineEntry", "sourceEntrychannel", "sourceStreamHandler", " sourceFileApplication", "sourceFileChuck", "ourceEntryChannel", "srcFileEntry", "sourceFilechannel", "sourceStreamChuck"], "destinationFileChannel": ["destmentResourcechannel", "destinationFilesChan", "destinatorFilesConnection", "destinationFileConnection", "destmentPageContext", "destinationDirectorychannel", "destinationfileChannel", "destinationfilechannel", "destinationChannelContext", "destinationFileChan", "destinationChannelChan", "destinatorFilesCh", "destmentFilechannel", "destinationfileEntry", "destinationFilesConnection", "destmentPageChan", "destmentFileManager", "destinationfileContext", "destinationFileManager", "destinationResourcechannel", "destinatorFilesChan", "destinationPageEntry", "destinationFilesCh", "destmentFileContext", "destinationfileChan", "destinationDirectoryChan", "destinationDirectoryManager", "destinationFileEntry", "destinationFileCh", "destinationFilechannel", "destmentFileChan", "destinationChannelConnection", "destmentPageEntry", "destmentPageChannel", "destinationResourceChan", "destinatorFileChan", "destmentResourceChannel", "destinatorFileChannel", "destinationChannelChannel", "destinatorFileCh", "destinationfileManager", "destinationResourceManager", "destmentFileChannel", "destmentResourceChan", "destinationPageChan", "destinationPageContext", "destmentFileEntry", "destinationfileConnection", "destinationFileContext", "destinationChannelCh", "destmentResourceManager", "destinationFilesChannel", "destinationChannelEntry", "destinationPageChannel", "destinatorFileConnection", "destinationDirectoryChannel", "destinationResourceChannel", "destinatorFilesChannel", "destinationfileCh"]}}
{"id1": "15051083", "id2": "5676111", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getContentDigests", "getMessageTimest", "getMessagedigest", "getContentdigests", "getContentDigested", "getMessagedigests", "getContentDigse", "getMessageDigse", "getContentdigse", "getMessageDigested", "getMessagedigse", "getContentdigested", "getContentdigest", "getContentDigest", "getMessageTimse", "getMessagedigested", "getMessageDigests", "getMessageTimested", "getMessageTimests"], "digest": ["mdested", "modester", "Digested", "modested", " Digend", " digestest", "Digest", " digested", "signgest", " digester", " digestester", "signester", " Digest", "hashest", " Digester", "mdest", "hashgest", " digast", "digested", "hashester", "dend", "diggest", " digestested", " Digested", "mdester", "modest", "digast", "Digast", "signest", " digse", "driverester", "driverested", "dependast", "Digse", "dependested", "digester", "dester", "signested", "digend", "Diggest", "hashested", "driverest", "mdse", "Digend", " diggest", "dested", "dest", "digse", "dependest", "Digester", "drivergest", "dependester"], "node": ["entry", "n", "dependent", "link", "network", "yn", "create", "inner", "missing", "post", "root", "system", "child", "process", "one", "name", "document", "open", "attribute", "cell", "common", "note", "Node", "nn", "element", "peer", "normal", "resource", "job", "angular", "query", "binary", "object", "host", "run", "role", "remote", "ne", "tree", "source"], "external": ["n", "express", "ex", "tern", " External", "secondary", "extra", "obj", "unique", "custom", "child", "ext", "self", "intern", "name", "outside", "any", "global", "export", "common", "note", "External", "https", "ternal", "multiple", "escape", "complete", "internal", "local", "qualified", "exit", "foreign", "binary", "object", "optional", "get", "this", "ns", "reference", "remote"], "messageDigest": ["messagedigesting", "messageDateesting", "essageDigest", "Messagedigest", "messageDigse", "essageDigesting", "messagedigse", "MessagedigEST", "messagedigested", "MessageDigest", "MessageDigested", "messagedigest", "messagedighest", "messageDateest", "messageDatese", "messagedigEST", "messageMixse", " messageDigse", "messageDighest", "messageDesignested", "messageDesignse", "Messagedigested", " messageDigEST", "essageDatese", "messageDigested", "MessageDigEST", "messageGuested", "messageDesignest", "essageDateesting", "MessageDighest", "messageGuEST", "messageMixest", "essageDigse", "messageMixesting", " messageDigested", "messageGuest", "messageDigEST", "messageDesignEST", "messageGuhest", "Messagedighest", "messageDigesting", "essageDateest"]}}
{"id1": "15241397", "id2": "8747840", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "doPut", " doget", "DoGet", "DoGET", "Doget", " doGET", "doGET", " doPut", "handleget", "handlePut", "doget", "handleGET", "DoPut"], "request": ["http", "report", "command", "in", "create", "address", "server", "reset", "question", "user", "input", "re", "req", "transform", "document", "quest", "attribute", "the", "client", "first", "connection", "context", "application", "setup", "position", "each", "complete", "Request", "start", "QUEST", "query", "initial", "forward", "get", "hello", "reference", "message", "frame", "current"], "response": ["http", "report", "print", "network", "xml", "session", "resp", "reset", "respond", "body", "server", "site", "res", "onse", "status", "image", "answer", "document", "sequence", "description", "form", "json", "send", "connection", "context", "write", "application", "reply", "version", "position", "ce", "ve", "block", "next", "resource", "service", "Response", "result", "exit", "success", "console", "content", "object", "view", "output", "fire", "message", "page", "frame"], "rewrittenQueryString": ["rewartedQueryString", "rewartedHeaderstring", "rewwrittenQuerystring", "rewrittenHeaderStr", "rewartedHeaderString", "rewrittenQueryStream", "rewrittenqueryStream", "rewrittenQueryQuery", "rewwrittenQueryString", "rewartedHeaderStream", "rewwrittenqueryQuery", "rewartedHeaderStr", "rewrittenquerystring", "rewwrittenQueryStr", "rewrittenURLStream", "rewrittenQuestionString", "rewrittenQuerystring", "rewwrittenQueryQuery", "rewrittenURLStr", "rewrittenURLstring", "rewrittenqueryQuery", "rewliedqueryStream", "rewrittenQustring", "rewliedQueryStream", "rewrittenqueryString", "rewrittenQuStream", "rewliedqueryString", "rewwrittenquerystring", "rewrittenHeaderString", "rewartedQueryStr", "rewrittenCurrentstring", "rewrittenQuString", "rewliedQueryStr", "rewrittenHeaderStream", "rewwrittenqueryString", "rewrittenCurrentStr", "rewrittenHeaderstring", "rewliedQueryString", "rewrittenqueryStr", "rewrittenRequestQuery", "rewartedQuerystring", "rewrittenCurrentString", "rewwrittenqueryStr", "rewrittenRequestStr", "rewrittenQuestionStr", "rewartedQueryStream", "rewrittenRequestString", "rewrittenQueryStr", "rewrittenQuestionStream", "rewrittenRequeststring", "rewrittenQuStr", "rewrittenURLString", "rewliedqueryStr", "rewrittenCurrentQuery"], "rewrittenUrl": ["rewrittenString", "rewriterURL", "RewrittenUr", "rewwrittenURL", "rewartedPosition", "rewartedURL", "rewrapedUr", "rewroteLink", "rewriteUrl", "RewrittenUrl", "rewartedUrl", "RewwrittenLink", "rewrapedUrl", "rewedUr", "rewrittenPosition", "rewittenurl", "rewartedUr", "rewrownUr", "rewadjustedPort", "rewedUrl", "rewwrittenString", "RewrittenString", "rewwrittenUr", "RewrittenPort", "rewedString", "rewrittenURL", "RewwrittenString", "rewriddenPosition", "rewriteUr", "rewriteURL", "rewriteurl", "rewwrittenPosition", "RewwrittenPosition", "rewroteUr", "RewrittenLink", "rewrittenPort", "RewwrittenPort", "RewwrittenURL", "rewartedurl", "RewwrittenUr", "rewrittenLink", "rewriterString", "rewittenLink", "rewrapedURL", "rewadjustedUrl", "rewrapedPort", "rewriterUrl", "RewrittenPosition", "rewadjustedUr", "rewrotePosition", "rewedURL", "Rewrittenurl", "rewrownUrl", "rewwrittenUrl", "rewroteURL", "rewwrittenurl", "rewwrittenPort", "rewriddenURL", "rewroteUrl", "rewrittenurl", "rewriddenUrl", "rewroteurl", "rewrownURL", "rewriterUr", "RewwrittenUrl", "rewittenURL", "RewrittenURL", "Rewwrittenurl", "rewadjustedURL", "rewrownPosition", "rewittenUrl", "rewwrittenLink", "rewriddenUr", "rewrittenUr"], "httpURLConnection": ["httpRLApplication", "httpURLControl", " httpURLApplication", "httpSRConnect", "httpFileConnect", "httpRLConnection", " httpUrlconnection", "ttpUrlConnect", " httpURLConnect", " httpUrlConnect", "httpSRConnection", "ttpUrlControl", "HttpURLconnection", " httpURLconnection", "httpMLConnection", "HttpUrlconnection", "httpHTTPApplication", "httpUrlConnect", "ttpUrlConnection", "httpURLconnection", "httpSRControl", "HttpURLConnect", "httpMLConnect", "httpURLConn", "ttpURLConnect", "httpURLApplication", "httpFileApplication", "httpMLApplication", "ttpURLControl", "ttpUrlconnection", "httpUrlControl", "HttpUrlConnection", "HttpHTTPConfiguration", "HttpURLApplication", "httpUrlConfiguration", "HttpURLConnection", "httpUrlApplication", "ttpURLConn", "HttpHTTPconnection", "HttpHTTPApplication", "httpHTTPControl", "httpUrlConnection", "httpRLConnect", "httpUrlconnection", "httpHTTPConn", "httpFileConn", "httpHTTPConfiguration", "ttpUrlApplication", "httpURLConnect", "ttpURLconnection", "httpHTTPConnect", "httpUrlConn", "httpSRApplication", " httpUrlApplication", "httpSRconnection", "HttpHTTPConnect", "httpSRConfiguration", "httpURLConfiguration", "ttpUrlConn", "httpHTTPconnection", "ttpURLConnection", "httpHTTPConnection", "httpMLconnection", "httpFileConnection", " httpUrlConnection", "HttpHTTPConnection", "HttpUrlConnect", "httpRLconnection", "HttpURLConfiguration", "ttpURLApplication"], "header": ["rule", "hidden", "detail", "policy", "operator", "Header", "address", "h", "filter", "hash", "user", "padding", "term", "dr", "status", "holder", "token", "state", "field", "prefix", "wrapper", "meta", "attribute", "handler", "feature", "client", "layer", "core", "device", "ter", "init", "head", "comment", "section", "column", "version", "title", "info", "block", "er", "peer", "zone", "check", "metadata", "port", "format", "handle", "heading", "argument", "part", "query", "variable", "relation", "component", "event", "headers", "option", "tag", "page", "shift", "buffer", "line"], "value": ["entry", "v", "val", "record", "create", "data", "key", "server", "address", "test", "hash", "property", "label", "string", "expression", "des", "name", "field", "sequence", "language", "attribute", "description", "password", "email", "ue", "text", "json", "VALUE", "pair", "sv", "unit", "sample", "save", "comment", "example", "version", "element", "vector", "zone", "format", "Value", "job", "content", "hello", "see", "default", "values", "message", "instance", "current", "python"], "inputStream": ["inputstream", "InputLoop", " inputThread", " inputLoop", "InputStream", "inputThread", "outputSteam", "outputView", "outputLoop", "errorWindow", "outputThread", "InputThread", "inputLoop", "outputstream", "InputView", " inputstream", "errorSteam", " inputSteam", "inputWindow", "inputView", "errorstream", " inputWindow", "inputSteam", " inputView", "outputWindow", "errorStream"], "outputStream": ["inputstream", "outputLength", "OutputStream", "OutputSteam", "responseStream", " outputForm", "displaystream", "responseForm", "outputSteam", "outputView", " outputView", "displayView", " outputSteam", " outputstream", "responseSteam", "outputstream", "outputForm", " outputLength", "displaySteam", "inputView", "OutputForm", "inputSteam", "OutputLength", "displayStream", "responseLength"]}}
{"id1": "19739421", "id2": "20619879", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownFormatException", " UnknownCommandException", "UnknownOptionClass", " UnknownCommandHandler", " UnknownCommandError", "UnknownParameterException", "UnknownFormatClass", " UnknownOptionHandler", "UnknownParameterClass", "UnknownCommandHandler", "UnknownOptionError", " UnknownCommandClass", "UnknownCommandError", "UnknownFormatHandler", "UnknownFormatError", " UnknownOptionError", " UnknownOptionClass", "UnknownCommandClass", "UnknownOptionHandler", "UnknownParameterHandler", "UnknownCommandException", "UnknownParameterError"], "cmdLineParser": ["cmdBlockProvider", "cmdBlockBuilder", "cmdChainLoader", "commandLinePers", "cmdListReader", "cmdChainReader", " cmdPageReader", "mdlineBuilder", "mdLineBuilder", "cmdlinePers", "cmdListBuilder", "cmdBlockReader", "mdlineReader", "cmdLineReader", "cmdLineRunner", "cmdNetReader", " cmdLineBuilder", "CmdLineParser", "cmdLParser", "cmdlineOptions", "cmdPageBuilder", "cmdlineProvider", "cmdListparser", "cmdSetBuilder", "cmdLinePers", "cmdSetparser", "commandLineParser", "mdLineHandler", "cmdlineLoader", "cmdlineReader", "cmdNetHandler", "cmdSetReader", "commandLineProvider", "mdlineParser", "cmdlineStreamer", "CmdLineProvider", "cmdLineBuilder", "cmdLineparser", "cmdLBuilder", "mdLineLoader", "mdLinearser", "cmdLineProvider", "mdlineHandler", "cmdLineOptions", "cmdFrameParser", "cmdlineBuilder", "cmdNetStreamer", "cmdPageParser", "commandlinePers", "cmdPageReader", "commandlineProvider", "cmdlineparser", " cmdPageBuilder", " cmdPageParser", " cmdLineReader", "commandlineParser", "cmdlineParser", "cmdlineHandler", "cmdLOptions", "mdLineParser", "mdlineparser", "CmdLineBuilder", "mdLineparser", "cmdFrameReader", "commandlineRunner", "CmdlineParser", "commandlineBuilder", "cmdListParser", "cmdLinearser", "CmdLineReader", "cmdFramePers", "cmdlinearser", "cmdLineLoader", "mdlineLoader", "CmdlineReader", "cmdChainarser", "mdlinearser", "commandLineRunner", "cmdlineRunner", "cmdLineStreamer", "commandLineBuilder", "CmdlineProvider", "mdlineOptions", "mdLineReader", "cmdChainParser", "cmdBlockOptions", "cmdPageProvider", "cmdFrameRunner", "cmdNetParser", "mdLineOptions", "cmdBlockParser", "commandLineReader", "mdlineStreamer", "cmdBlockHandler", "cmdLHandler", "cmdLineHandler", "cmdSetParser", "mdLineStreamer", "commandlineReader", "CmdlineBuilder"], "formatOption": ["FormatOption", " formatEntry", " formatOperation", "formatOptions", "FormatOperation", "filterOption", "transformEntry", "transformOperation", "formatEntry", "FormatOptions", "filterEntry", "transformOption", "formatOperation", "transformOptions", " formatOptions"], "outputEncodingOption": ["outputEncamingOption", "outputEncamingOptional", "outputEncgingOptional", "outputEncachingOptions", "outputEncachingOption", "outputEncodingOptions", "outputEncappingOptions", "outputEncachingOptional", "outputencappingOption", "outputEncamingOptions", "outputEncappingOption", "outputEncappingOptional", "outputencodingOptional", "outputencodingOption", "outputEncappingoption", "outputencappingOptional", "outputencodingoption", "outputEncamingoption", "outputencachingOption", "outputencachingOptional", "outputEncodingoption", "outputencodingOptions", "outputencappingoption", "outputEncgingOption", "outputencachingOptions", "outputEncgingoption", "outputEncodingOptional"], "inputEncodingOption": ["inputEncendingOptional", "inputEncodingOptional", "inputCachingOption", "inputEncodingAttribute", "inputEncappingOption", "inputEncachingOption", "inputCachingOptions", "inputencodingOptions", "inputEncordingOption", "inputEncappingOptional", "inputEnclingoption", "inputEncendingOption", "inputCachingOptional", "inputEncendingOptions", "inputencodingOption", "inputEnclingOption", "inputEncodingOptions", "inputEncachingOptions", "inputEncappingOptions", "inputenclingoption", "inputEncordingOptions", "inputCodingOptions", "inputEncappingAttribute", "inputEnclingOptions", "inputencodingAttribute", "inputEncordingAttribute", "inputCodingOption", "inputEncappingoption", "inputenclingAttribute", "inputEncordingoption", "inputenclingOption", "inputenclingOptions", "inputencodingoption", "inputEnclingAttribute", "inputEncachingOptional", "inputEncodingoption", "inputCodingOptional"], "format": ["scale", "parse", "print", "command", "Format", "use", "policy", "it", "filter", "filename", "tif", "string", "what", "term", "at", "status", "template", "transform", "accept", "name", "table", "layout", "prefix", "language", "type", "license", "fix", "form", "error", "f", "style", "export", "api", "pi", "unit", "note", "title", "module", "force", "version", "with", "file", "printf", "pattern", "config", "set", "sort", "get", "output", "option", "pretty", "display", "method", "join", "source"], "outputEncoding": [" outputDecoding", "outputEngoder", "currentEnging", "outputEnaching", "publicEncling", "outputEngoding", "outputencaging", "outputEnalling", "outputencling", "outputCompaming", "currentEnaching", "responseEncryption", "outputEngaling", " outputDecaming", "responseEncoding", "outputEncoder", "currentEncoding", "outputMessaming", "publicEncaging", "outputMessryption", "outputEncryption", " outputDecryption", " outputEncaling", "outputEncording", "outputEnording", "outputencging", "currentEnling", "outputEnging", "outputEnaging", "outputencoding", "outputEncining", " outputEncining", "outputEnacing", "outputEncacing", "publicEncording", " outputEngoder", "publicEncoding", "outputencording", "outputEncging", "outputDecaming", "outputCompryption", "outputEncaming", "outputDecining", "outputEnryption", "outputDecryption", "outputEngging", "outputEngling", "outputEncaling", "outputEnaling", " outputEngacing", "outputDecling", "outputEnoder", "outputencaching", " outputEngaling", "outputEnling", "outputMessoding", "responseEncling", "outputEncalling", "currentEncaching", " outputDecining", " outputEncaming", "outputEncling", "outputDecalling", " outputEngoding", "outputCompoding", "outputEngacing", "outputEncaching", "outputMessining", "outputEnoding", "responseEncalling", "currentEncging", " outputEncacing", "currentEnoding", " outputEncryption", "outputEngaching", "outputCompining", "outputEncaging", "currentEncling", " outputEncoder", "outputDecoding"], "inputEncoding": ["outputEnging", "sourceEncoding", "inputEngale", "inputCodling", "sourceEncing", "sourceEnoding", "inputEncoder", "contextEnacing", "inputChacing", "inputEnale", "inputPackale", "inputCoding", "sourceEncling", "sourceEnacing", "outputEnoder", "inputPackging", "inputCododing", "outputEnoding", "inputencoder", "inputChale", "outputEncale", "inputEning", "sourceEnling", "sourceEning", "inputEnoding", "contextEncale", "inputChoder", "inputEnging", "contextEnoder", "inputEnacing", "inputEncing", "inputencing", "outputEnale", "contextEncacing", "inputencling", "outputEncging", "inputEncacing", "contextEncoder", "inputencacing", "contextEnoding", "inputEncging", "inputPackoding", "inputencoding", "outputEncoder", "contextEnale", "inputCodacing", "inputEngoding", "inputEnling", "inputEncling", "inputEncale", "inputencale", "inputPackoder", "inputEngoder", "inputChoding", "inputEnoder", "inputEngging", "contextEncoding", "sourceEncacing"], "remainingArgs": ["trainingItems", "remainingFrames", "remainedArgs", "trainingArgs", "remendingFrames", "remistingLinks", "remainedJs", "remainArgs", "mainingParts", "remainsParameters", "removalGS", "trainItems", "remainingParameters", "resainedItems", "trainingFrames", "removalBlocks", "remendingItems", "remgoingGS", "remainingGS", "remainedargs", "remainingParts", "remainedBlocks", "remainParts", "remendingGS", "remainedItems", "remainedLinks", "mainedArgs", "resainingItems", "trainGS", "mainingGS", "remainFrames", "remainingItems", "resainedargs", "resainingLinks", "mainedJs", "remainedFrames", "remainGS", "remainargs", "mainedGS", "resainingGS", "removalParameters", "remainedGS", "remainingJs", "remgoingParts", "resainingargs", "mainingJs", "remainingLinks", "remgoingJs", "resainingParameters", "resainedParameters", "remainsBlocks", "remainedParameters", "remendingArgs", "remainsArgs", "remainItems", "remgoingArgs", "remistingGS", "mainingArgs", "resainedArgs", "remainsGS", "removalArgs", "remgoingItems", "trainArgs", "remainedParts", "resainingArgs", "remistingArgs", "trainingGS", "resainedBlocks", "resainingBlocks", "remistingBlocks", "mainedParts", "resainedLinks", "remgoingargs", "remainJs", "trainFrames", "remainBlocks", "remainingargs", "resainedGS", "remainingBlocks", "remainLinks"], "inputFile": ["inputPath", "inputFILE", "hiddenLike", "InputPath", "acceptfile", " inputPlace", "InputPlace", "acceptPlace", "InputFile", "outputPath", " inputLine", "Inputfile", "acceptFile", "inputPlace", "outputLike", " inputPath", "hiddenFile", "inputfile", "requestFILE", "inputLike", "hiddenPath", "outputfile", "requestPath", " inputfile", "acceptLine", "InputFILE", "requestfile", "requestFile", " inputFILE", "hiddenfile", "InputLine", "inputLine", " inputLike"], "outputFile": ["writefile", " outputfile", "clientDir", "outputFolder", "coinFolder", "OutputDo", "OutputFilename", "cachefile", " outputDo", "OutputFiles", "cacheDir", "cacheFile", "clientDo", "coinFile", "outputFilename", "inputDir", "inputfile", "clientFile", " outputDir", "cacheFilename", " outputFolder", "writeDo", "outputDir", "outputfile", "clientFiles", "OutputFile", "outputDo", "outputFiles", "writeFolder", "OutputDir", "coinDo", "inputFilename", "coinfile", "writeFile", " outputFiles", "Outputfile"], "out": ["inf", "report", "n", "print", "screen", "gen", "conn", "list", "in", "ex", "err", "null", "inner", "session", "obj", "inv", "res", "ins", "user", "ser", "OUT", "msg", "up", "error", "ou", "io", "Out", "writer", "aos", "outer", "sys", "init", "dir", "con", "ln", "manager", "log", "all", "inter", "cfg", "output", "outs", "on", "gr", "temp", "net", "pretty"]}}
{"id1": "3584508", "id2": "13063241", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyResource": ["copyAddress", " copyFile", "downloadUrl", "downloadFile", " copiedAddress", " copiedFile", " copiedUrl", "downloadAddress", "copyUrl", " copyAddress", "downloadResource", "copyFile", " copyUrl", " copiedResource"], "url": ["browser", "http", "link", "null", "web", "l", "ll", "html", "rl", "address", "rel", "el", "re", "string", "hl", "base", "loc", "cert", "char", "f", "str", "ul", "mail", "gif", "ssl", "dl", "ret", "ref", "ur", "nl", "mount", "https", "URL", "resource", "file", "gl", "service", "ml", "Url", "sl", "fl", "github", "cl", "host", "r", "mb", "path", "util", "ls", "uri", "source"], "input": ["http", "ip", "access", "raw", "feed", "null", "parse", "in", "it", "inner", "sum", "missing", "index", "user", "audio", "reader", "image", "exec", "base", "state", "unknown", "accept", "up", "Input", "inside", "open", "pull", "form", "cont", "ssl", "act", "context", "qa", "init", "active", "upload", "info", "request", "iter", "enter", "stream", "add", "acl", "file", "local", "eval", "start", "read", "config", "can", "initial", "op", "ain", "get", "focus", "empty", "PUT", "before", "text", "select", "source"], "output": ["o", "print", "continue", "null", "web", "hidden", "network", "secondary", "four", "unsigned", "bool", "entity", "response", "image", "remote", "group", "table", "secure", "ou", "client", "outer", "text", "icon", "other", "connection", "write", "position", "put", "beta", "ilo", "next", "format", "file", "auto", "exit", "update", "success", "console", "object", "component", "Output", "net", "display", "out", "ne", "you", "online", "current"], "b": ["d", "m", "v", "l", "body", "k", "obj", "ble", "base", "c", "B", "y", "rb", "bp", "char", "f", "by", "ab", "bi", "u", "bit", "ba", "j", "bf", "br", "buff", "bits", "cb", "ib", "fb", "block", "be", "t", "wb", "gb", "bb", "bc", "eb", "binary", "g", "nb", "db", "mb", "sb", "bs", "r", "i", "ob", "z", "p"]}}
{"id1": "23532405", "id2": "13783549", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"persist": ["remain", "insiste", "remister", "Persiste", "remiste", "Persister", "persiste", "insist", "persain", "remist", "insister", "persister", "insain", "Persist", "Persain"], "ffConfigurable": ["efconfigural", "effConfigurated", "ffRequestorable", "efConfiguring", "ffCerturated", "efConfigural", "ffconfiguer", "ffConfigurationURA", "ffConfurer", "ffConfigurated", "ffConfigorable", "ffLogurable", "ffconfigured", "ffConfigured", "ffRequesturing", "ffConfigutable", "uffconfiguer", "effPortutable", "ffCerturable", "uffconfigurable", "ffCerturate", "ffconfiguring", "ffSpecurate", "ffConfiguring", "ffPortutable", "ffRequestuer", "ffCertural", "efConfigurate", "efconfiguring", "effPorturer", "effConfigurable", "ffConfuer", "effConfigURA", "ffConfutable", "effCerturable", "ffPorturated", "ffSpecuring", "ffConfigurate", "effConfigured", "ffconfigurated", "uffConfigurable", "effPorturated", "uffConfiguer", "ffPorturer", "ffCertURA", "ffSpecural", "ffPorturable", "ffConfigurationurable", "ffCertured", "ffLogurated", "ffconfigorable", "ffconfigurable", "ffRequesturable", "ffConfigurationured", "ffconfigural", "ffCerturing", "ffconfigURA", "efConfigurable", "ffConfigurer", "effCerturated", "ffConfigURA", "effConfigurer", "efconfigurate", "effCertured", "ffconfigurate", "ffSpecurable", "ffConforable", "ffConfuring", "uffconfigorable", "effPorturable", "ffConfigural", "ffConfigurationurated", "uffConfiguring", "ffLogurer", "efconfigurable", "ffLogutable", "effCertURA", "ffConfurable", "uffConfigorable", "ffConfiguer", "effConfigutable", "uffconfiguring", "ffConfurated"], "relativePath": [" relativeFile", "absoluteUrl", "relDir", "relativeUrl", "absoluteDir", "relPath", "relUrl", "relativeRoot", " relativeName", "qualifiedName", "relativeFile", "absolutePath", "relativeDir", "qualifiedPath", "qualifiedDir", " relativeRoot", "qualifiedFile", " relativeUrl", "relRoot", "absoluteName", " relativeDir", "relativeName", "absoluteRoot", "absoluteFile"], "file": ["entry", "rule", "to", "link", "list", "command", "project", "use", "al", "header", "create", "full", "filename", "memory", "play", "user", "store", "string", "issue", "folder", "image", "base", "template", "name", "table", "document", "fil", "f", "ile", "queue", "fp", "class", " File", "e", "work", "dir", "force", "word", "port", "stream", "le", "resource", "File", "local", "handle", "format", "url", "log", "auto", "set", "spec", "view", "output", "db", "lock", "path", "message", "page", "pool", "out", "buffer", "frame", "FILE"], "is": ["ip", "ris", "isi", "in", "js", "bis", "lis", "sis", "ists", "us", "are", "ins", "isa", "im", "ais", "ir", "ires", "its", "IS", "Is", "isin", "iso", "ms", "bits", "ib", "ios", "nis", "xs", "s", "iss", "es", "fs", "iris", "ist", " Is", "isl", "bs", "ic", "isc", "i", "ls"], "os": ["o", "ose", "ui", "pos", "oss", "ops", "los", "oa", "oos", "cos", "us", "oses", "obs", "oS", "des", "io", "Os", "sys", "iso", "ms", "mot", "ot", "OS", "ios", "ols", "ys", "bos", "osi", " Os", "oz", "es", "fs", "bs", "i", "ds", "si", "ls", "ox"]}}
{"id1": "14303294", "id2": "12586404", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "label": 0, "substitutes": {"getServerHash": ["getserverHash", "getClientPassword", "getServerMac", "toClientMac", "toServerMac", "getServerSalt", "getUserPassword", "getClientSalt", "getUserMac", "getUserSalt", "toClientSalt", "toServerHash", "toServerSalt", "getserverSalt", "getClientMac", "getClientHash", "getserverPassword", "toClientPassword", "getserverMac", "toClientHash", "getServerPassword", "toServerPassword", "getUserHash"], "passwordHash": [" passwordKey", "serverSalt", "PasswordKey", "serverPassword", "emailHash", "PasswordHash", "swordSalt", "emailHTML", "emailHas", "passwordHTML", "PasswordHas", "PasswordPassword", "serverHash", " passwordPassword", "PasswordHTML", " passwordSalt", "emailSalt", "passwordSalt", "swordHas", "passwordHas", "passwordKey", "passwordPassword", "swordHash", "swordHTML", "serverKey"], "PasswordSalt": [" PasswordPassword", " PasswordToken", "PasswordToken", "PasswordHash", " passwordToken", "UserToken", "UserSalt", "UserSecret", "PasswordPassword", "passwordSecret", " PasswordHash", " passwordPassword", " PasswordSecret", "UserHash", " passwordSalt", "passwordToken", "passwordSalt", "PasswordSecret", "passwordPassword"], "hash": ["report", "cache", "print", "sh", "serial", "ash", "html", "key", "sum", "h", "address", "test", "filter", "index", "total", "response", "mac", "transform", "password", "Hash", "char", "row", "json", "echo", "build", "sample", "dig", "score", "copy", "hex", "block", "crypt", "word", "search", "value", "handle", "mask", "map", "result", "log", "match", "component", "message", "tag", "shift", "sha", "height"], "digest": ["mdested", "displaygest", "mdEST", "decester", "Digested", "dEST", "descester", "Digest", " digested", " digEST", " digester", "displayester", "decse", "hashest", "hashgest", "DigEST", "mdest", "digested", "hashester", "descse", "diggest", "decest", "mdester", "displayest", " digse", "Digse", "decested", "digester", "digEST", "dester", "Diggest", "hashested", "displayested", "descest", "digse", "descested", "dest", "dested", "Digester"]}}
{"id1": "23510383", "id2": "20128728", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": ["createPackage", " saveFile", "saveFile", "saveApp", "savePackage", " SaveFile", "createApp", " saveApp", " savePackage", " SaveProject", " SavePackage", " SaveApp", "createFile", "createProject"], "file": ["report", "link", "project", "use", "in", "create", "data", "full", "filename", "image", "base", "table", "open", "io", "ile", "files", "e", "ame", "dir", "info", "real", "port", "File", "resource", "local", "handle", "log", "complete", "id", "get", "db", "path", "foo", "FILE", "parent"], "types": ["strings", "objects", "otypes", "apps", "sets", "classes", "tags", "sites", "times", "services", "keys", "parts", "pes", "views", "options", "posts", " Types", "features", "ids", "assets", "tests", "issues", "actions", "thumbnails", "packs", "files", "resources", "ypes", "names", "scripts", "plugins", "versions", "events", "ties", "ts", "packages", "items", "groups", "models", "codes", "Types", "styles", "projects", "values", "ports", "pages"], "images": ["frames", "classes", "tags", "blocks", "uploads", "views", "image", "links", "assets", "Image", "media", "photos", "boxes", "thumbnails", "icons", "files", "Images", "videos", "scripts", "events", "versions", "groups", "models", "styles", "picture", "faces", "pages"], "trajectories": ["traceptors", "Trajectors", "Trajables", "trajectables", "traceptory", "trajors", "Trajories", "tractories", "Trajectories", "trajables", "tractors", "trajories", "Trajors", "trajectory", "trajectors", "Trajectables", "traceptories", "Trajectory", "traceptables", "tractory", "trajory", "tractables", "Trajory"], "databasesIncluded": ["datadesInsjected", "databasesInsclusion", "databasesInified", "datadesInclusion", "datadesInified", "databasesINclusion", "databasesInjected", "databasesedInified", "databasesInsclusions", "databasesInclusions", "daturesInclusions", "databasesIngcluded", "daturesIncluded", "databasesedInjected", "datadesInsclusion", "databasesInlisted", "daturesInsclusions", "databasesInslisted", "datadesInscluded", "datadesIncluded", "daturesInslisted", "databasesedInclusion", "databasesINcluded", "databasesInsified", "databasesInclusion", "databasesedInclusions", "datadesInsified", "databasesInscluded", "databasesINjected", "daturesInlisted", "daturesInscluded", "databasesedIncluded", "datadesInjected", "databasesInsjected", "databasesIngclusions", "databasesedInlisted", "databasesInglisted", "databasesINified"], "onlyLinks": [" onlylinks", "onlyLink", " onlyLink", "forceLink", "alsoRelations", "forceLinks", "Onlylinks", "onlylinks", "onlyRelations", "OnlyLink", " onlyRelations", "alsoLinks", "OnlyLinks", "forcelinks", "OnlyRelations", "alsoLink"], "index": ["n", "zero", "pos", "inc", "ex", "num", "Index", "amount", "address", "second", "no", "ind", "loc", "sequence", "open", "end", "number", "offset", "first", "nn", "info", "position", "check", "ion", "connect", "add", "max", "length", "set", "update", "all", "match", "find", "initial", " Index", "fail", "x", "i", " sidx"], "name": ["man", "m", "n", "named", "create", "Name", "NAME", "full", "data", "filename", "root", "system", "string", "image", "about", "base", "table", "prefix", "ame", "me", "title", "none", "word", "primary", "names", "local", "nm", "id", "default", "run", "path", "parent"], "format": ["v", "scale", "print", "parse", "list", "Format", "it", "use", "data", "MAT", "term", "base", " Format", "table", "layout", "prefix", "language", "form", "style", "unit", "percent", "fm", "init", "color", "mt", "value", "printf", "pattern", "set", "get", "cal", "default", "pretty", "util"], "count": ["code", "err", "num", "skip", "amount", "sum", "reset", "found", "flag", "total", "process", "c", "table", "error", "Count", "size", "counter", "add", "depth", "start", "ount", "set", "order", "mark", "length", "z"], "version": ["tree", "v", "summary", "record", "header", "xml", "server", "Version", "virtual", "VER", "major", "root", "journal", "VERSION", "information", "database", "video", "about", "java", "document", "description", "latest", "vers", "ver", "number", "json", "connection", "draft", "build", "j", "parent", "section", "mint", "versions", "result", "release", "alone", "translation", "page", "current", "python"], "writer": ["browser", "report", "entry", "to", "access", "print", "walker", "operator", "data", "inner", "writing", "function", "flush", "server", "wright", "window", "reader", "journal", "editor", "maker", "Writer", "document", "builder", "wrapper", "description", "handler", "external", "language", "client", "author", "outer", "connection", "caster", "write", "writ", "comment", "writers", "er", "counter", "stream", "w", "written", "driver", "iterator", "service", "creator", "sw", "wrote", "console", "variable", "order", "output", "woman", "buffer"], "xmlDir": ["mlFile", "logdir", "xmldir", "xmlFile", "logDir", "mlDirectory", " xmlDirectory", "imageFolder", "imageDir", "xmlFolder", "logDirectory", "xmlDirectory", " xmlFolder", "imagedir", " xmlFile", " xmldir", "logFolder", "mlDir", "imageDirectory", "mlFolder", "logFile"], "databases": [" datables", "Databases", " datas", "generabases", " datasha", "generabase", "baselines", "Datas", "database", "notures", "Datates", "basabases", "datasha", "generas", "mutabases", "Datures", "mutases", "datures", "mutables", "datables", " datates", "notelines", "Datables", "generates", "datases", "notables", "notabases", "Datasha", "basures", "datates", "Datases", "basables", "Datelines", " database", "datas", "mutasha", " datases", "Database", "datelines"], "t": ["o", "v", "n", "pt", "it", "tr", "h", "k", "q", "term", "template", "c", "y", "ct", "str", "tm", "j", "T", "e", "ot", "mt", "w", "te", "s", "ts", "tt", "id", "typ", "temp", "x", "i", "tc", "txt", "p"], "type": ["ping", "to", "rule", "parse", "link", "null", "time", "key", "address", "test", "site", "pe", "root", "template", "ype", "base", "Type", "shape", "y", "error", "language", "TYPE", "ver", "style", "top", "class", "other", "unit", "ime", "title", "module", "info", "single", "check", "resource", "te", "result", "config", "id", "match", "relation", "object", "kind", "tool", "typ", "ty", "role", "tag", "this", "action", "instance", "p"], "currentName": ["currentLock", "updateFace", "currentlyTime", "currentlyPath", "updateName", "baseName", "reportedDir", "CurrentPath", "updatePort", "currentParent", "currentlyName", "thisKey", " currentFace", "updateOrder", "currentDir", "currentlyKey", "reportedParent", "currentlyYear", "currentOrder", "CurrentLock", "currentSet", "basePort", "completeYear", "currentlySet", "reportedLock", "currentKey", " currentNames", "currentNames", "CurrentParent", "currentYear", " currentPort", " currentOrder", " currentDir", "CurrentName", "currentlyLock", "completeSet", "thisName", "reportedTime", "currentFace", "baseFace", "completeKey", "baseOrder", "reportedPath", "completeName", " currentParent", "thisYear", "currentTime", "reportedName", "thisSet", "CurrentTime", "reportedNames", "currentPath", "currentPort", "CurrentDir", "CurrentNames"], "baseCopy": ["Basecopy", "baseStore", "parentCop", "BaseCopy", "baseName", "basiccopy", "buffercopy", "basicCopy", " baseStore", " baseName", "basecopy", "parentcopy", "bufferCopy", "baseCop", "parentCopy", "bufferCop", "BaseName", "basicCop", " basecopy", "basicStore", "parentName", "BaseStore", "BaseCop", " baseCop"], "source": ["space", "create", "data", "inner", "SOURCE", "site", "target", "input", "store", "system", "reader", "base", "sequence", "scan", "ources", "subject", "connection", "src", "scope", "sample", "init", "owner", "ource", "origin", "Source", "size", "stream", "search", "resource", "from", "service", "local", "se", "iterator", "start", "master", "original", "console", "initial", "shell", "before", "channel", "join", "select", "parent"], "destination": ["messuation", "declregation", "datination", "Destination", "Destregation", "datinations", "datregation", "Destinations", " destinations", "messination", "Destinated", "declinations", "declinator", "destinator", "datinator", "destuation", "destinated", " destuation", " destructure", "messinated", "Destinator", "declination", "messinations", "Destuation", "destinations", "messructure", " destinated", "Destructure", "destregation", "destructure"], "clefs": ["cleFs", "Clefs", " Clefits", "CLEcs", " CleFS", "CleFS", "clefits", "CLEFs", "Clecs", "CLEfits", " Clecs", "CLEfs", " cleFs", "cleFS", " Clefs", " Clebs", " CleFs", " clebs", "Clebs", "clecs", "CleFs", "Clefits", " cleFS", "clebs"], "st": ["rest", "pt", "it", "h", "St", "ste", "statement", "sy", "std", "irst", "bt", "ST", "dd", "ct", "str", "est", "cr", "stat", "sp", "sn", "mt", "inst", "sth", "sts", "se", "sm", "start", "ost", "ts", "tt", "sl", "query", "sw", "cl", "storage", "sc", "ist", "fr", "bl", "sb", " ST", "stra"], "rs": ["ks", "RS", "ris", " ms", " cs", " ps", "rt", "ins", "res", "rd", " iss", "os", " ins", " RS", "rc", "cs", "sts", "Rs", "ts", "mr", "as", "ers", "rys", " sr", "ps", " pts", "ds", "ls"]}}
{"id1": "7981642", "id2": "10212189", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"update": ["insert", "feed", "updated", "Update", "edit", "create", "data", "change", "test", "post", "store", "alter", "input", "username", "load", "login", "mod", "up", "pack", "replace", "register", "remove", "touch", "commit", "auth", "write", "append", "save", "reply", "init", "upload", "sample", "move", "put", "check", "add", "escape", "handle", "printf", "read", "config", "set", "delete", "place", "apply", "UPDATE", "text"], "mail": ["m", "pl", "ip", "n", "http", "link", "print", "md", "pkg", "Email", "address", "server", "dial", "virtual", "test", "el", "label", "mm", "username", "msg", "im", "name", "hold", "cert", "cmd", "imp", "Mail", "tp", "grid", "dl", "eth", "mem", "dir", "domain", "mount", "old", "alt", "ln", "iter", "enter", "dn", "port", "mun", "com", "url", "mobile", "file", "local", "log", "mill", "del", "id", "host", "dm", "zip", "addr", "message", "net", "gmail", "mails"], "email": ["m", "ip", "n", "link", "phone", "html", "detail", "Email", "address", "server", "xml", "virtual", "test", "el", "label", "date", "entity", "username", "image", "atom", "template", "name", "external", "password", "number", "il", "echo", "cdn", "sql", "nl", "note", "e", "sample", "domain", "example", "ln", "enter", "dn", "ilo", "url", "file", "nm", "log", "del", "object", "host", "zip", "IL", "addr", "message", "ns", "cn", "et", "text", "uri", "line"], "pwd": [" pw", "pword", "dpword", "pow", "pswd", "Pwd", "dpw", "psow", " pword", " pws", "dpgen", "pgen", " pow", "psw", "dpwd", "Pgen", "ppriv", "pw", "presswd", "pws", "pressw", " ppriv", "presspriv", "psfx", "Pfx", "Ppriv", "pfx", "Pw", "pressws", " pgen", "Pword", "Pws", " pfx", "Pow"], "firstname": ["Firstname", "FirstNAME", "firstName", "lastrun", " firstNAME", "smallName", "lastNAME", "Firstnames", " firstnames", " firstName", "Firstparent", "firstrun", "lastnames", " firstrun", "smallNAME", "smallrun", "smallname", "lastparent", "firstparent", " firstparent", "lastName", "firstNAME", "firstnames", "FirstName"], "lastname": [" lastame", "lasttype", "givennum", " lasttype", "longName", "givenname", "firstName", "givenName", "firsttype", "longname", "giventype", "fullame", "longnum", " lastName", "firstame", "lastame", "fullName", "lastnum", "fullname", "lastName", "longame", "firstnum", " lastnum"], "connection": ["entry", "link", "conn", "command", "condition", "network", "session", "city", "connected", "system", "database", "directory", "response", "Connection", "c", "document", "description", "collection", "handler", "client", "engine", "onet", "cone", "nc", "context", "application", "con", "connect", "ion", "resource", "creator", "management", "relation", "event", "pool", "communication"], "attrs": ["avras", " attps", " attries", "actters", "attachras", "attsds", "atrics", "adrs", "attps", "attachrs", "actributes", "atrys", "attsributes", "addrs", "atras", "latributes", "attachRs", "attsps", "latrs", "attributes", "atributes", "latrys", "attrics", "atns", "attsras", "adns", "attsrics", "atries", "attsries", " attRs", "avrics", "addrd", "attachributes", "avributes", "attrd", " attrd", "attras", "actrys", "addRs", " attributes", "attns", "attRs", "addras", "avrs", "attds", "attters", "adras", "atps", "atds", "atrd", "atRs", "attries", "attrys", "atrs", "actrs", " attds", "atters", "addributes", " attras", "latters", "adributes", " attns", "attsrs"], "sha": ["comp", "shared", "ca", "sh", "ppa", "sche", "md", "HA", "shi", "ssh", "alpha", "sum", "has", "h", "SHA", " SHA", "cos", "no", "lambda", "total", "git", "mac", "tar", "da", "asha", "ya", "ha", "ksh", "sa", "wa", "func", "mem", "iso", "sam", "ka", "ma", "go", "acl", "sm", "auto", "mb", "shell", "a", "hi", "sq", "pa"], "digest": ["dests", "mdested", "divhest", "mdEST", "digests", "Digested", "dge", "Digest", " digested", "Digests", " digEST", "divEST", "digge", "Digge", "redests", "DigEST", "mdest", "dighest", "digested", "mdests", "mdhest", "redge", "redest", " digests", "digEST", "Digse", "redested", "Dighest", "divse", "mdse", "dested", "dest", "digse", "divest"], "hash": ["ashes", "sh", "print", "shadow", "bh", "cache", "md", "ash", "html", "key", "sum", "h", "has", "filter", "input", "rh", "total", "mac", "base", "Hash", "password", "ha", "flash", "auth", "dig", "score", "trust", "hex", "check", "search", "format", "handle", "dump", "result", "proof", "message", "tag", "each", "ASH"], "ctx": ["kw", "ca", "conn", "np", "pg", "ctr", "cp", "lc", "pkg", "obj", "Conn", "wx", "dc", " context", "loc", "xc", "jp", "tk", "Context", "cf", "ct", "gm", "conv", "context", "nc", "co", "rc", "cb", "cmp", "con", "mc", "cv", "gc", "mk", " cx", "ctrl", "tx", "kl", "bc", "sc", "ck", "cm", "tmp", "tz", "x", "cu", "tc", "txt", "sq", "nt"], "newName": ["NewName", " newNames", "oldname", "finalNames", " newNAME", " newname", "currentName", "newKey", "currentKey", "finalName", "newNAME", "Newname", " newKey", "finalname", "oldNames", "NewKey", "NewNAME", "newNames", "finalHome", "newname", " newHome", "oldHome", "currentNAME", "currentname", "newHome"], "oldName": ["oldKey", "olderKey", " oldPref", "oldname", "recentOr", "recentname", "smallOr", "prevName", " oldname", "smallName", "newOr", "oldername", "prevPref", " oldKey", "recentName", "oldPref", "newAnd", "olderName", "olderPref", "smallAnd", "smallname", "prevname", "prevKey", "recentAnd", "newname", "oldOr", "oldAnd"]}}
{"id1": "804637", "id2": "8490297", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewend", "readAndrewWrite", "readAndResend", "readAndrewrite", "readAndRepend", "readAndRewrites", "readAndResrites", "readAndRewWrite", "readAndRewend", "readAndRepWrite", "readAndResWrite", "readAndResrite", "readAndrewrites", "readAndReprites"], "inFile": ["infile", "InFilename", " inFilename", "docFilename", "inPlace", "outfile", "initFile", "INPlace", "iFILE", "inputFile", "inputPlace", "initFace", "inputFace", "iTime", "outFilename", "INFile", "Infile", "docTime", "InFile", "inFILE", "docFile", "initFilename", "iFilename", " infile", "inFace", "initPlace", "INFilename", "inTime", "inputFilename", "INTime", "inFilename", "iFile", "docFILE", "INFace", "INFILE"], "outFile": ["infile", "nameFILE", "checkFile", "outfile", "toFile", "checkFILE", "toFilename", "nameFilename", "checkfile", "toFILE", "checkFilename", "reportfile", "outFilename", " outFILE", "inFILE", "namefile", "reportFILE", "reportFilename", "tofile", " outfile", " outFilename", "outFILE", "reportFile", "nameFile", "inFilename"], "iis": ["diIs", "liis", "IIs", " iiss", "liris", "iIs", "iiss", " iIs", "iIS", "diis", "liisc", "diiss", "iiris", "eIs", "eIS", "Ii", "iiis", "ii", "liIs", " iIS", "eis", "dii", " iisc", " ii", "Iis", "aiis", "aiIs", "aiIS", "iiIs", " iris", "iiisc", "iris", "iisc", "Iiss"], "dcmParser": ["dcomParser", "dpmBuilder", " dpmPar", "dromParser", "dcommParser", "dfmBuilder", "dgrPar", "dcrparser", "DcmReader", "decmReader", "dmReader", " dpmAssistant", "deromReader", " dcmarser", "dcmStatement", "dcmReader", "dromReader", "dromparser", "dromListener", "dcmLoader", "dmmParser", "dpmLoader", "DpmPar", "dcommAssistant", "dmodulePrivate", "dmarser", "dmParser", "dcrParser", "DcmAdapter", "dcrBuilder", "DpmReader", "dcmPrivate", "dpmparser", " dpmReader", "DpmAdapter", "dmmmParser", "Dcmparser", "dpmStatement", "drumReader", " dpmPrivate", "dpcPrivate", " dpmBuilder", "dcmPar", "dfmLoader", "dgrStatement", "dcfStatement", "dmmmAdapter", " dcmLoader", "dpcParser", "DcmPar", "Dpmparser", "drumPar", "dcfReader", "dpmAdapter", " dpmListener", "dcomLoader", " dcmparser", "dgrReader", "DcmBuilder", "deromparser", "dpmAssistant", "deromParser", "drumParser", " dcmListener", "dpmarser", "decmParser", "drumBuilder", " dpmParser", "dmmarser", " dpmparser", "dcomReader", "dgrParser", "dcommReader", "dmoduleParser", " dpmStatement", "dpcReader", "deromarser", "dcmAssistant", " dcmPar", "dcommListener", "dpcAssistant", "dmoduleReader", "DpmBuilder", "dcmAdapter", "dcrReader", "dpmReader", "dfmReader", "dmmmReader", "decmarser", "dcomBuilder", "dpmPar", "dromAssistant", "dpmPrivate", " dcmBuilder", " dcmAssistant", "dpmParser", "dpmListener", "DcmParser", "dmmmparser", "dmoduleAssistant", "dcfPar", "dcmBuilder", " dcmPrivate", "decmparser", "dcmarser", "dmmparser", "dmparser", "dfmParser", " dcmStatement", "dromarser", "dcmListener", "DpmParser", " dpmarser", "dcmparser", " dcmReader", "dmmReader", " dpmLoader", "dcfParser", "dmmAdapter"], "ds": ["d", "ks", "sets", "js", "in", "ws", "DS", "services", "dat", "bd", "data", "pd", "Ds", "hd", "qs", "gd", "dq", "ins", "obs", "rs", "des", "os", "da", "ods", "ss", "hs", "details", "dd", "aos", "ads", "its", "der", "dx", "df", "vs", "sys", "dl", "eps", "sv", "dos", "ys", "dh", "cs", "uds", "eds", " DS", "drivers", "tes", "pers", "xs", "s", " des", "dds", "es", "fs", "sd", "as", "ims", "ps", "db", "outs", "dt", "bs", "ils", "ns", "gs", "ls"], "pdReader": ["tdReader", "ddLoader", "ddRunner", "xdLoader", "pedCar", "ddCar", "pedLoader", "tdParser", "pedReader", "hdWriter", "pdRead", "ddHelper", "pdCar", "pedRunner", "vdWriter", "pdParser", "vdLoader", "vdHelper", "dpLoader", "hdReader", "ddRead", "hdRead", "xdWriter", "ddReader", "vdReader", "dpRunner", "tdRead", "dpReader", "pdHelper", "pdLoader", "ddWriter", "dpCar", "ddParser", "hdParser", "tdWriter", "xdHelper", "pdRunner", "xdReader"], "out": ["cache", "list", "null", "in", "it", "data", "full", "ins", "desc", "msg", "c", "io", "client", "end", "sys", "we", "serv", "con", "go", "w", "t", "gr", "tmp", "o", "n", "to", "raw", "v", "pos", "ex", "inner", "flush", "at", "os", "over", "up", "Out", "cmd", "aos", " err", "cb", "ent", "sw", "id", "output", "pool", "p", "nt", "screen", "conn", "js", "oss", "err", "sum", "OUT", "one", "writer", "str", "ch", "nr", "opt", "s", "all", "en", "outs", "on", "gen", "obj", "inv", "res", "status", "name", "ou", "outer", "co", "log", "auto", "gt", "inter", "cfg", "net", "cn", "conv", "txt"], "dcmEncParam": ["dcmEscNum", "dcmencParam", "dmmencParam", "dcmDecCmd", "dcmEncPar", "dmmEncMsg", "dmmEncPar", "dcmencPar", "dcmencCmd", "dmmencNum", "dcmEncVal", "dmmEncParam", "dmmEncCmd", "dcmEscPar", "dcmEscVal", "dcmEnNum", "dmmEnPar", "dcmDecMsg", "dcmEncNum", "dcmEncCmd", "dmmEnNum", "dcmencMsg", "dmmencCmd", "dcmDecNum", "dcmEnVal", "dcmEnParam", "dcmEncMsg", "dmmencMsg", "dcmEscParam", "dcmencNum", "dmmEncNum", "dmmEnParam", "dmmEncVal", "dcmDecParam", "dcmEnPar"], "pdWriter": ["pdwriter", "dpWrite", "tdWriting", "pcWriting", "PDWriter", "pcwriter", "pidWriting", "pdWrite", "pdWriting", "PDReader", "PDWrite", "pdEditor", "tdWrite", "PDEditor", "tdwriter", "pidwriter", "pcWrite", "pidWriter", "pcWriter", "dpReader", "pidWrite", "dpEditor", "tdWriter", "tdReader", "tdEditor", "dpWriter"]}}
{"id1": "20851065", "id2": "411595", "code1": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"open": ["ping", "launch", "link", "use", "create", "show", "full", "reset", "dial", "test", "call", "download", "orient", "one", "exec", "load", "login", "over", "secure", "error", "align", "global", "connection", "valid", "build", "arg", "note", "init", "info", "sync", "enter", "block", "forge", "check", "connect", "Open", "construct", "complete", "establish", "eval", "start", "pre", "read", "require", "master", "close", "set", "release", "update", "point", "match", "initial", "enable", "op", "exclusive", "lock"], "openStr": ["forgeTr", "lockEv", " openSTR", " closeSt", "openInt", "enterSTR", "urlSt", "opSTR", "drawStr", "callStr", "openSpr", "openRem", "updateStr", "urlStr", "urlString", "closeEl", "updateSpr", " openSpr", " openSt", "opEl", " openInt", "enterStr", "alignSTR", "opString", "alignStr", "openBr", "callRem", "parseStr", "openTr", "enterBr", "closeYe", " closeString", "callSTR", "forgeInt", "closeSt", "lockString", " openString", "openSTR", "openSt", "lockYe", "openEv", "closeBr", " openDec", "updateYe", "forgeString", "drawEl", "openEl", " closeBr", "closeTr", "closeDec", "opStr", "openDec", "closeEv", "callSpr", "lockStr", "drawSTR", "linkStr", " openEv", "updateBr", "closestr", " closeStr", "forgeSTR", "linkTr", "parsestr", "alignBr", "urlstr", "closeSTR", "closeStr", "closeString", "openYe", "parseString", "openString", "openstr", "updateSTR", " openYe", "enterYe", "alignYe", " openBr", "linkSTR", " openRem", "drawString", "updateRem", "parseSt", "linkString", "closeInt", "forgeDec", "forgeStr"], "commProtocol": ["commprotiod", "commPrototype", "commProtype", "comProtocol", "commTeleication", "cmPatication", "broadProtistry", "cmPrototype", "cmPatocol", "commprotace", "commPatistry", "comProace", "comProotype", "commProtected", "commTerministry", "broadPatocol", "broadPatotype", "commPotype", "commProication", "cmPatected", "commTeleocol", "commPiod", "commPrefected", "commProtistry", "cmProtication", "comProtication", "commprotocol", "comPrototype", "broadPatistry", "commPatotype", "commprotication", "cmPiod", "commPrication", "comProication", "cmProtected", "commTerminotype", "cmPocol", "commProocol", "commProcol", "broadPrototype", "commProotype", "commProtiod", "commTeleected", "commPocol", "commProtace", "commPrefocol", "cmProtocol", "commProace", "commPrace", "commTerminocol", "commProtication", "cmProtiod", "commprototype", "commprotistry", "comProtace", "commPatication", "cmPotype", "comProocol", "commPrefication", "commPatected", "commPatocol", "broadProtocol"], "rxtxProtocol": ["rxtxprotrome", "rxtxPatrome", "rxtxprotport", "rxtxNetocal", "rxtxResotype", "rxtxProtrome", "rxtXProtport", "rxtxprototype", "rxtXprotocal", "rxtxProfocal", "rxtxProtocal", "rxtxNetocol", "rxtXPrototype", "rxtXProtocal", "rxtxResocol", "rxtxprotocal", "rxtxProfport", "rxtxPatotype", "rxtxProtport", "rxtxNetport", "rxtXprotrome", "rxtxPatocol", "rxtXprotport", "rxtxProfocol", "rxtxprotocol", "rxtXProtrome", "rxtxPrototype", "rxtXprototype", "rxtXProtocol", "rxtXprotocol", "rxtxResrome"], "netProtocol": ["webHorotype", "webProtocol", "Netprotocol", "netDefotype", "netProace", "netprototype", "verTerminocol", "NetProtace", "NetPrototype", "netProotype", "netProtology", "verProtocol", "netHorotype", "Netprotace", "verPrototype", "netProocol", "netTerminotype", "netPatocol", "verTerminology", "webHorocol", "webPrototype", "netDefology", "netPatotype", "verProtology", "netPatace", "netPrefocol", "netprotace", "NetProtocol", "Netprototype", "netPrefotype", "netProtace", "netTerminology", "netPrefology", "netDefocol", "netPrototype", "netHorocol", "netprotocol", "verTerminotype", "netTerminocol"], "commConnection": ["comConn", " commDialog", "commConn", "cmdConnection", " commSession", "cmdSocket", "ommDialog", "ommSocket", "cmControl", "cmdconnection", "comConnect", "cmdConnect", "comconnection", " commconnection", "commSocket", "cmpSocket", "cmdConn", "ommConnection", " commConn", "commDialog", "commConnect", "cmConnection", "cmpConnection", "ommControl", "ommSession", "cmDialog", "comConnection", "commControl", "cmpConnect", "cmSession", "cmpConn", " commControl", "commSession", "ommConn", " commConnect", "commconnection", "ommConnect"], "rxtxConnection": ["rxtxSession", "rxtrxSession", "rxtrxConn", "rxtxconnection", "rxtxtconnection", "rtxtrxConnect", "rxtXConnect", "rXTxSession", "rxtrxConnect", "rXTXConnection", "rxtxtConn", "rtxtxconnection", "rxtxtConnection", "rxtXconnection", "rxtxConn", "rXTxtConnection", "rtxtrxConn", "rXTxConnection", "rxtxtSession", "rxtXSession", "rXTxtSession", "rXTxconnection", "rXTxConnect", "rXTxConn", "rXTXconnection", "rxtXConnection", "rxtrxConnection", "rxtxtConnect", "rtxtrxConnection", "rtxtrxconnection", "rXTxtConnect", "rtxtxConnection", "rtxtxConn", "rxtxConnect", "rXTXConn", "rXTXConnect", "rtxtxConnect", "rXTxtconnection", "rxtrxconnection", "rxtXConn"], "socketConn": ["ocketDial", "socketconn", "SocketObj", "ocketCon", "procConn", "ocketSyn", "ocketconn", "ocketObj", "socketSyn", "netConn", "procConnection", "procconn", "SocketConn", "socketConnection", " socketConnection", " socketObj", "procCon", "socketCon", " socketCon", "socketDial", "socketObj", "linuxCon", "ocketConn", "SocketSyn", " socketDial", "SocketConnection", "netDial", "linuxConn", "netConnection", "linuxconn", "ocketConnection", " socketSyn", "linuxConnection", "netCon"], "url": ["browser", "http", "b", "parse", "link", "conn", "l", "ll", "address", "rel", "user", "re", "location", "hl", "name", "google", "f", "str", "ul", "il", "mail", "ssl", "dl", "build", "ur", "nl", "bel", "mount", "https", "URL", "resource", "gl", "service", "log", "Url", "sl", "github", "get", "r", "sb", "ls", "uri"], "urlConn": ["urlComm", "logPtr", "uriconn", "uriPtr", "implconn", "urlPtr", "urlconn", "webComm", " urlCont", "uriNum", "uriConnection", " urlConnect", "webconn", "urlNum", "implConn", "logconn", "logNum", " urlNum", "UrlSocket", " urlComm", "UrlCont", "UrlConn", "implConnect", "uriCont", "UrlConnection", "urlSocket", "webConnect", " urlPtr", "uriConn", " urlConnection", " urlconn", "uriSocket", "urlConnect", "logConn", "webConn", " urlSocket", "implComm", "urlCont", "urlConnection"]}}
{"id1": "9954926", "id2": "9449064", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"simulate": ["simure", " simulation", "smulation", "modulates", "smulates", "modure", "simulates", " simulates", "simulation", " simure", "modulate", "modulation", "smure", "smulate"], "out": ["b", "cache", "print", "list", "null", "in", "it", "hit", "ins", "state", "c", "io", "client", "sys", "ger", "init", "con", "manager", "go", "w", "t", "exp", "gr", "o", "report", "n", "to", "raw", "v", "ex", "inner", "flush", "store", "at", "base", "os", "up", "Out", "aos", "cmd", "copy", "handle", "gov", "help", "ent", "set", "content", "output", "pool", "buffer", "p", "nt", "batch", "screen", "conn", "err", "sum", "OUT", "writer", "f", "write", "put", "nr", "last", "can", "all", "conf", "OU", "outs", "on", "pretty", "tree", "gen", "obj", "inv", "res", "group", "name", "error", "ou", "outer", "co", "e", "gc", "log", "cfg", "net", "cn", "conv"], "file": ["b", "report", "l", "data", "filename", "play", "input", "base", "template", "name", "table", "document", "io", "type", "f", "ile", "channel", "fp", "connection", "e", "port", "le", "format", "t", "resource", "File", "handle", "library", "result", "log", "set", "model", "console", "output", "db", "lock", "path", "message", "pool", "buffer", "FILE", "source"], "obtainUserReputationRequest": ["obtainUserRepetitionRequest", "obtainUserRepositoryQuery", "obtainUserRepresentationError", "obtainUserReputationTarget", "obtainUserRepresentationResponse", "obtainUserRepresentutationError", "obtainUserReputationsTask", "obtainUserRelutationTask", "obtainUserReputationrequest", "obtainUserRepetitionResponse", "obtainUserReputationsResponse", "obtainUserReporationQuery", "obtainUserRepationTarget", "obtainUserReplutationRequest", "obtainUserRelutationResponse", "obtainUserReputationsQuery", "obtainUserRepresentutationRequest", "obtainUserReplutationTarget", "obtainUserReporationError", "obtainUserRelutationsResponse", "obtainUserRelutationQuery", "obtainUserRelutationRequest", "obtainUserRepresentutationTarget", "obtainUserRepationrequest", "obtainUserReplutationResponse", "obtainUserReputionResponse", "obtainUserReputationQuery", "obtainUserReporationRequest", "obtainUserReputationsRequest", "obtainUserRepationError", "obtainUserRepresentationrequest", "obtainUserRepationResponse", "obtainUserReputionrequest", "obtainUserRepationRequest", "obtainUserRepationQuery", "obtainUserRepresentutationrequest", "obtainUserReputationsrequest", "obtainUserReputionTarget", "obtainUserRelutationsQuery", "obtainUserReputationError", "obtainUserRelutationsRequest", "obtainUserRelutationsTask", "obtainUserRepresentationQuery", "obtainUserRepresentationTarget", "obtainUserRepositoryTask", "obtainUserRepresentutationResponse", "obtainUserReputationsError", "obtainUserReporationResponse", "obtainUserRepresentationRequest", "obtainUserReputionTask", "obtainUserRepositoryResponse", "obtainUserRepetitionTarget", "obtainUserRepresentutationQuery", "obtainUserReputionQuery", "obtainUserReputationTask", "obtainUserRepositoryRequest", "obtainUserReputionRequest", "obtainUserReputationsTarget"], "obtainUserReputationResponse": ["obtainUserRepulationService", "obtainUserRepulationResponse", "obtainUserRepositoryAnswer", "obtainUserReportositoryAnswer", "obtainUserReputationsResp", "obtainUserRepositoryService", "obtainUserReportositoryResponse", "obtainUserReputationsResponse", "obtainUserReputationService", "obtainUserReportositoryResp", "obtainUserRepulationResp", "obtainUserReputationResp", "obtainUserReportositoryService", "obtainUserReportutationAnswer", "obtainUserReputationAnswer", "obtainUserRepositoryResp", "obtainUserReportutationResp", "obtainUserReportutationResponse", "obtainUserReputationsAnswer", "obtainUserReportutationService", "obtainUserRepositoryResponse", "obtainUserReputationsService", "obtainUserRepulationAnswer"], "rateUserRequest": ["RateUserResponse", "rateJobRequest", "rateOwnerRecord", "createUserCommand", "rateTimeRequest", "rateRowResponse", "createUserRequest", "raceUserrequest", "rateOwnerResponse", "rateOwnerRequest", "rateLineResponse", "RateUserRequest", "createuserRequest", "rateUserChange", "scaleOwnerResponse", "RateLineQuery", "rateUsersRequest", "rateJobResponse", "raceRowRecord", "rateSampleCommand", "rateClientrequest", "rateSampleRequest", "rateOwnerrequest", "rateUserQUEST", "RateClientResponse", "createUserRequ", "rateJobChange", "scaleOwnerRequest", "RateClientGrant", "RateLineResponse", "rateUserJob", "rateLineGrant", "rateUserGrant", "rateOwnerAccess", "scaleUserRequest", "rateClientGrant", "rateLineRequ", "rateDateGrant", "RateUsersRequest", "raceUserRequest", "rateLineQuery", "RateClientRequest", "rateSamplerequest", "rateUserAccess", "rateLinerequest", "rateProxyResponse", "raceUserRecord", " rateUserJob", "rateUserQuery", "RateUsersQuery", "rateUserRequ", "rateuserCommand", " rateUserrequest", "rateuserQUEST", "rateUsersAccess", "rateuserResponse", "rateSampleRequ", "scaleUserAccess", "rateClientRequest", "rateUsersQuery", "rateUserCommand", "rateRowRecord", "rateRowrequest", " rateUserQuery", "rateTimeResponse", "rateRowJob", "rateProxyRequest", "createuserrequest", "rateUsersQUEST", "rateRowRequest", "rateUsersrequest", "createuserCommand", "rateUsersResponse", "rateTimerequest", "raceRowRequest", "RateUsersQUEST", "rateProxyQuery", "rateuserQuery", "RateUserQuery", "rateDateRequest", "rateClientResponse", "rateUsersChange", "rateUserRecord", "rateuserRequ", "RateUserChange", "RateUserrequest", "scaleUserResponse", "rateDateResponse", "createUserrequest", "RateUsersrequest", "rateuserrequest", "rateProxyQUEST", "RateUsersResponse", "RateUserQUEST", "createuserRequ", "RateLineRequest", "rateLineRequest", "RateUserGrant", "rateuserRequest", "rateuserAccess", "RateLinerequest", "rateLineCommand", "RateUsersChange", "rateClientJob", "rateUserrequest", "scaleOwnerAccess", "raceRowrequest"], "rateUserResponse": ["RateUserResponse", "ratesUserMessage", "rateClientReturn", "rateControllerRequest", "rateTimeRequest", "rateControllerMessage", "rateUsersReply", "rateMethodVersion", "rateUserReply", "rateTimeAnswer", "RateUserRequest", "ratesClientResp", "rateUserResp", "rateFileresponse", "rateUsersRequest", "rateWordRequest", "rateFileRequest", "rateWordReturn", "ratesUserResponse", "rateMemberResponse", "rateUserReturn", "ratesClientMessage", " rateClientResponse", " rateClientRequest", "rateMethodRequest", "rateMethodResponse", "RateUsersRequest", "rateUserVersion", "RateUserVersion", "RateUsersReply", "rateuserresponse", "rateMemberReply", "RateUsersresponse", "rateUserMessage", "rateManagerMessage", "rateUserresponse", "ratesUserRequest", "rateWordresponse", "rateFileResponse", "rateMemberresponse", "rateuserResponse", "rateUserAnswer", "rateDateVersion", "rateMemberRequest", "RateUserresponse", "RateUserReply", "rateDateData", "rateMethodData", "rateClientRequest", "rateTimeResponse", " rateUserStatus", " rateUserAnswer", "rateManagerRequest", " rateUserReturn", " rateUserresponse", "rateUsersStatus", "rateUserStatus", "rateUsersResponse", "rateControllerResponse", "rateControllerResp", "rateManagerResponse", "rateUserData", " rateClientresponse", "ratesClientResponse", "ratesUserResp", "rateDateRequest", "rateClientResponse", "RateUserData", " rateClientReturn", "rateClientResp", "rateWordResponse", "rateClientresponse", "rateuserReply", "rateTimeStatus", "rateDateResponse", "rateUsersresponse", "rateClientMessage", "RateUsersResponse", "rateManagerResp", "rateuserRequest", "rateUsersAnswer", "ratesClientRequest", "rateFileReturn"], "fis": [" fisa", "bis", "liss", "lis", "bisa", "fiss", "fIs", "sfIs", "fisa", "FIs", "flis", "lIs", "fi", "bi", "fli", "Fiss", "fIS", "sfIS", "Fis", "flisa", " fi", "sfis", "sfiss", "FIS", "lIS"], "br": ["browser", "BR", "pr", "bh", "tr", "ctr", "bd", "ber", "wr", "adr", "dr", "bt", "kr", "bp", "shr", "str", "bi", "buf", "bn", "ch", "cr", "bf", "ger", "bro", "div", "nr", "be", "mr", "vr", "gb", "hr", "fr", "bm", "bl", "lr", "gr", "sr", "Br", "bridge"], "call": ["Call", "report", "n", "code", "list", "continue", "command", "use", "function", "cin", "dial", "test", "execute", "play", "inv", "label", "ell", "status", "c", "name", "trace", "char", "callback", "str", "cell", "send", "contact", "comment", "draw", "request", "info", "block", "word", "check", "add", "url", "called", "result", "log", "query", "update", "all", "cal", "message", "action", "frame", "bridge", "line"]}}
{"id1": "7276377", "id2": "20275821", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"checksum": [" checksume", "checksam", "checksume", "checksest", "csum", " checksest", "cksume", "csume", "csam", " checksam", "cksam", "cksum", "csest", "cksest"], "url": ["browser", "http", "rect", "link", "web", "l", "ll", "html", "xml", "address", "key", "q", "dll", "rel", "el", "string", "location", "image", "base", "name", "loc", "document", "email", "char", "str", "ul", "mail", "ssl", "dl", "u", "build", "ur", "nl", "domain", "bel", "mount", "request", "https", "URL", "gl", "file", "pattern", "log", "Url", "config", "get", "host", "path", "ls", "uri"], "algorithm": ["altergo", "malgorithm", "alignment", "Algorithm", "approgorith", " alculus", " algorith", "Algorith", "palter", "alter", "Alculus", "operabet", "aliment", "Alabet", "operter", "palgorithm", "altergorithm", "opergo", "Alignment", "alteriment", "palabet", "alculus", "approgo", "opergorithm", " algo", "approgorithm", "approculus", "palgo", "alabet", "algorith", "Algo", "maliment", "Aliment", "alterignment", "Alter", "malgo", "algo", "malignment"], "messageDigest": ["messageDesignester", "messageHasests", "messageMerist", "messageDiger", "applicationDigests", "MessageDigum", "Messagedigest", "messageHasester", "messageDse", "messageDigse", "messageDigester", "messagedigse", "messageDesigner", "MessageDigest", "MessageDigse", "applicationDesignests", "messagedigest", "MessageDiger", " messageDigidate", " messageDigse", "messagedigum", "messagedigester", "messageDigidate", "messagediger", "Messagediger", "applicationDigest", "messageDebuger", "messageDebugidate", "applicationDigester", "messageDesignest", "messageChecker", " messageDiger", "messageCheckest", "applicationDesigner", "applicationDesignest", "Messagedigse", "messageDebugest", "messageMerse", "messageDigum", "applicationDiger", "messagedigests", "messageDest", " messageDigist", "messageDum", "messagedigist", "messageDer", "messageDebugse", "messageCheckse", "messageDesignests", "messageHaser", "messageMerest", "messageHasest", "messageDigests", "applicationDesignester", "Messagedigum", "messageDigist", "messageCheckum", "messagedigidate"], "bytes": ["strings", "frames", "types", "images", "bes", "words", "classes", "blocks", "services", "parts", "users", "seconds", "lines", "pieces", "pointers", "gets", "bps", "its", "vs", "ces", "eps", "files", "bits", "steps", "resources", "rows", "tes", "out", "jobs", "names", "versions", "bos", "checks", "items", "groups", "es", "gb", "ions", "notes", "outs", "ies", "values", "pages", "bs", "units", "Bytes", "gs", "terms", "vals", "ones"], "in": ["inf", "m", "o", "n", "oin", "IN", "l", "inc", "it", "socket", "al", "null", "inner", "cin", "h", "proc", "ins", "input", "re", "reader", "ind", "one", "rin", "bin", "name", "up", "In", "is", "io", "form", "client", "again", "by", "or", "pi", "isin", "co", "init", "serv", "con", "info", "mc", "ma", "check", "asin", "ai", "nin", "t", "gin", "from", "handle", "impl", "mi", "can", "en", "ain", "conf", "inn", "on", "out", "din", "i", "p", "source"], "nBytesRead": ["nBytesFound", "nBytesWritten", "nRsRead", "nFilesRead", "nItemsFound", "nFramesread", " nBytesread", "nTokensread", "nRsRun", "NBytesread", "nItemsReader", "nBytesread", "nbytesread", "NBytesRead", "nRsSupported", " nRsSupported", "nBytesReader", "nFilesWritten", "NBytesWritten", "nItemsRead", "nFramesReader", "nbytesSupported", "nItemsWritten", "nFramesFound", "nTokensRead", " nRsRead", "NRsRead", "NRsRun", " nItemsWritten", " nBytesFound", "nTokensRun", "nTokensWritten", "nBytesRun", "nFilesread", "NBytesRun", "NRsWritten", "nFilesRun", "NRsread", "nFramesRead", " nItemsFound", " nBytesReader", " nItemsReader", "nbytesWritten", "nBytesSupported", "nRsFound", "nFramesSupported", "nFramesWritten", "nbytesRead", " nItemsRead", "nRsread", " nBytesSupported", " nRsWritten", "nRsWritten", "nRsReader", " nBytesWritten", " nRsread"], "checksumValue": [" checksummModel", "checksumVal", " checksamValue", "checksumervalue", " checksummValue", "checksummVal", " checksummvalue", "checksummModel", " checksummValues", " checksamData", "checksumModel", "checksummDocument", "checksamVal", "checksummValues", "checksumData", "checksummValue", "checksUMValue", "checksamData", " checksumvalue", "checksumDocument", " checksumDocument", " checksamDocument", "checksamValue", "checksumvalue", "checksumerValues", "checksUMModel", " checksumVal", " checksumModel", "checksumerValue", "checksumedData", "checksamDocument", "checksummvalue", "checksumedVal", "checksumerModel", "checksumedDocument", "checksummData", " checksumData", " checksumValues", "checksUMValues", "checksUMvalue", "checksumedValue", "checksumValues", " checksamVal"]}}
{"id1": "12678045", "id2": "7118860", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"addQDInformation": ["addQdinformation", "addQdinfo", "addQDinfo", "addQDMinfo", "addQuestiondInfo", "addQDinformation", "addQdInfo", "addQuestionDinfo", "addQuestionDInformation", "addQSinformation", "addQDMInformation", "addQDInfo", "addQDMInfo", "addQSInformation", "addQuestiondInformation", "addQSinfo", "addQdInformation", "addQuestionDInfo", "addQSInfo", "addQuestiondinformation", "addQDMinformation", "addQuestiondinfo", "addQuestionDinformation"], "qdDate": ["qlDo", "qadDate", "requduDisplay", "qedDate", "qlDat", "qdmTime", "qedNow", "qdsDisplay", "qduTime", "qdxDat", "qdsDate", "qdtDate", "qdDisplay", "requdDat", "requduTime", " qdodate", " qdTime", "questedDo", "qdoNow", "qdoDate", " qddate", "qdtDat", "qdxTime", "qedDat", "qdsTime", "qduDate", "qlDate", "qdxDo", "qdxFile", "qedDo", "qadNow", "qdtNow", "qdmDate", "qdDat", "qldDisplay", "qdodate", "questedDate", "qddate", "qdmFile", "qldTime", " qdoNow", "questdNow", "qdTime", "requdDisplay", " qdNow", "questdDat", "qldDate", "requduDat", " qdoDate", "questedDat", "qdxNow", "requduDate", "qdmDo", "qdDo", "questdDo", "requdDate", " qdoDat", " qdDat", "questedNow", "qdsDat", "qdxdate", "qduDat", "questdDate", "qadDat", "qdtdate", " qdDo", "qduDisplay", "qlNow", "qdoDat", "qdxDate", "requdTime", "qadDo", "qdNow", "qldDat"], "qdFile": ["qsdFile", "qdTime", "qmdfile", "qdSourceFile", "querydFile", "iqdSourceFile", "qsdByte", "qdoByte", "iqdofile", "qmdByte", "qdsTime", "qdTable", "qdmTime", "qdsByte", "qsdSourceFile", "qdrfile", "qdsTable", "iqdFile", "iqdByte", "qdfile", "qmdFile", "qdrTable", " qdfile", "querysdByte", "qdrFilename", "querysdTime", "qrdByte", "qdFilename", "querydSourceFile", "querysdSourceFile", "qrdSourceFile", "qdmSourceFile", "qdoSourceFile", "qsdTime", "qdsFile", "iqdoByte", "iqdfile", "iqdoSourceFile", "qdsfile", "qrdFile", "querysdFile", "qdsSourceFile", "qdmFile", "qrdfile", "querydTime", "qmdSourceFile", "qdofile", "qdrFile", "iqdoFile", "qdoFile", " qdTable", "qdsFilename", "qdmByte", "qdByte", "querydByte", " qdFilename"], "_qdFileDate": ["_qpFileFormat", "_qdSetMap", "_qdDirDate", "_qdsfileNumber", "_qdDirFormat", "_qdfileMap", "_qdFileWrite", "_qdUnitFormat", "_qdDirMap", "_qpTotalYear", "_qdfileDo", "_qdSetNumber", "_qdTotalDate", "_qdTotalYear", "_qpTotalWrite", "_qdDirYear", "_qpFileYear", "_qdsFileDate", "_qdsFileNumber", "_qdTotalWrite", "_qpFileDate", "_qdFileYear", "_qdFileDo", "_qdsFileMap", "_qdDirDo", "_qdFileNumber", "_qdsFileDo", "_qdFileFormat", "_qpTotalFormat", "_qpTotalDate", "_qdDirWrite", "_qdsfileDate", "_qdUnitDate", "_qdUnitYear", "_qdsfileMap", "_qdfileNumber", "_qdSetDo", "_qdUnitWrite", "_qdFileMap", "_qdfileDate", "_qdDirNumber", "_qdSetDate", "_qpFileWrite", "_qdTotalFormat", "_qdsfileDo"], "ii": ["yi", "inch", "ij", "ci", "Si", "ei", "gi", "ami", "iri", "cgi", "ind", "aa", "ishi", "oci", "ori", "ani", "II", "oi", "ini", "li", "iq", "fi", "xi", "ou", "ski", "jj", "ati", "pi", "iso", "co", "chi", "ta", " iii", "cu", "iat", "ai", "ico", "sim", "ia", "mi", " ni", "ni", "qq", "ice", "ix", "iii", "umi", "hi", "aii", "ku", "di", "iy", "ims", "i", "iona", "ti", "si", "ie", "qi", "zi"], "info": ["inf", "http", "entry", "INFO", "summary", "ip", "Info", "time", "data", "key", "inner", "instance", "index", "what", "information", "status", "about", "unknown", "name", "tip", "fo", "used", "error", "details", "type", "io", "is", "notice", "f", "alias", "pi", "iso", "note", "init", "none", "check", "id", "query", "def", "success", "object", "conf", "translation", "history", "ti", "i", "join", "item"], "_qdValue": ["_qdovalue", "_dqDResult", "_dqdvalue", "_qdvalue", "_qldvalue", "_qdoValue", "_qldInfo", "_dqDValue", "_qldResult", "_qldValue", "_dqdValue", "_qdoResult", "_qDResult", "_qDvalue", "_dqDvalue", "_qdoInfo", "_qdInfo", "_qDInfo", "_qDValue", "_dqdResult", "_qdResult", "_dqDInfo", "_dqdInfo"], "reader": ["then", "feed", "rl", "data", "inner", "Reader", "body", "ner", "ro", "reading", "parser", "rar", "dr", "holder", "rot", "upper", "rx", "builder", "wrapper", "pull", "handler", "writer", "random", "dd", "worker", "row", "runner", "iter", "er", "iterator", "driver", "resource", "handle", "loader", "redo", "library", "rr", "read", "READ", "relation", "r", "lr", "buffer"], "urlName": ["UrlName", " urlKey", "URLNames", " urlPath", "lname", "Urlname", "urlNames", "UrlPath", "strKey", "URLKey", "UrlN", "urlDefault", "lN", "URLname", "lNames", "URLPath", "UrlDefault", "rowname", "urlString", "URLString", "UrlKey", "urlN", "strname", "UrlString", "URLDefault", "urlPath", " urlname", "urlKey", "strName", " urlDefault", "rowN", " urlString", "rowNames", "urlname", "UrlNames", "strNames", "URLName", "rowName", " urlNames", "lName"], "url": ["browser", "http", "b", "link", "l", "ll", "rl", "address", "rel", "user", "re", "location", "string", "hl", "name", "loc", "open", "char", "f", "str", "mail", "ssl", "ref", "ur", "nl", "bel", "mount", "URL", "resource", "gl", "Url", "sl", "console", "host", "r", "lr", "mb", "uri"], "stream": ["feed", "screen", "socket", "in", "network", "data", "inner", "body", "input", "clean", "window", "system", "instance", "stage", "platform", "form", "pod", "str", "row", "cont", "sample", "stack", "REAM", "iter", "iterator", "resource", "present", "sl", "sw", "console", "Stream", "poll", "message", "channel", "buffer", "ream"], "file": ["report", "rule", "in", "header", "data", "body", "filename", "input", "table", "document", "io", "fast", "handler", "writer", "open", "f", "ile", "fp", "files", "dir", "port", "format", "File", "handle", "range", "fd", "loader", "fs", "fr", "run", "r", "db", "message", "page", "buffer", "FILE", "tree"], "line": ["ip", "code", "print", "record", "detail", "lin", "header", "user", "string", "lo", "inline", "section", "iter", "level", "le", "normal", "LINE", "range", "page", "channel", "raw", "link", "continue", "eline", "store", "sequence", "cmd", "dd", "char", "side", "row", "sample", "liner", "column", "ln", "position", "word", "next", "handle", "piece", "part", "buffer", "entry", "rule", "l", "node", "body", "lines", "one", "queue", "cell", "Line", "ine", "phrase", "note", "port", "job", "ice", "message", "out", "frame", "chain", "no", "field", "error", "trace", "sql", "e", "comment", "block", "se", "log", "query", "point", "online"], "_qdDate": ["_kdxGeneral", "_kdFile", "_kdTotal", "_qdoFile", "_qdtPort", "_qdoTime", "_iqdDate", "_kdxDate", "_iqtTime", "_kdDate", "_qdoDat", "_qdDat", "_qdtTime", "_iqtValue", "_qdTime", "_qlValue", "_qdxFile", "_qdxGeneral", "_qdoTotal", "_qdmGeneral", "_qlDat", "_qdGeneral", "_qdTotal", "_qtValue", "_iqtDate", "_qudTime", "_qdmTotal", "_qtDate", "_iqtDat", "_qdtDat", "_qdoPort", "_qdsDat", "_qlTime", "_qdsValue", "_iqdDat", "_qdtDate", "_qdoGeneral", "_qudtPort", "_qtTime", "_iqdTime", "_qdmFile", "_qdoDate", "_qudDate", "_qlDate", "_qtDat", "_qudDat", "_kdxFile", "_qdmDate", "_qudPort", "_qdsDate", "_iqdValue", "_qdsTime", "_qudtTime", "_qdPort", "_qdxTotal", "_qudtDate", "_qdFile", "_qdxDate", "_qudtDat", "_kdxTotal", "_kdGeneral", "_qdsPort"], "pos": ["o", "n", "zero", "pr", "Pos", "pt", "slot", "num", "axis", "px", "proc", "cos", "pid", "no", "index", "ind", "apo", "yes", "cond", "os", "loc", "min", "pro", "prefix", "neg", "pat", "pad", "or", "top", "offset", "snap", "nos", "sp", "pc", "position", "size", "win", "port", "POS", "add", "present", "pres", "start", "max", "exp", "part", "point", "def", "prot", "conf", "pose", "po", "ps", "length", "i", "p", "len"], "projectNum": ["componentNo", "projectDir", "ProjectNum", "modelNum", " projectConn", "modelNo", "componentNum", " projectnum", "projectnum", "modelDir", "projectNumber", "projectConn", "ProjectConn", "ProjectNumber", "projectNo", "componentnum", " projectNo", " projectDir", "Projectnum", "componentConn", " projectNumber", "componentNumber", "modelnum", "componentDir"], "value": ["v", "scale", "val", "project", "data", "key", "property", "index", "total", "distance", "name", "field", "description", "type", "feature", "ue", "number", "VALUE", "unit", "port", "format", "profile", "result", "Value", "point", "object", "values"]}}
{"id1": "16511008", "id2": "13063241", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMessageSchentax", "createNewProfilingMsgSymbol", "createNewProfilingMessageSchembol", "createNewProfilingMsgSyntax", "createNewProfilingMsgSchembol", "createNewProfilingMessageCyntax", "createNewProfilingMessagesymbol", "createNewProfilingMsgSchentax", "createNewProfilingMessageSyntax", "createNewProfilingMessageCymbol", "createNewProfilingMessagesyntax"], "configID": ["componentId", "confPK", "caseid", " configURL", "configOR", "Configid", "configURI", "configid", "configML", " configOR", " configML", "cfgIDs", "ConfigML", " configIDs", "caseML", "ConfigID", "configIDs", " configid", " configId", "cfgID", "configPK", "caseID", "configId", "cfgId", "confId", "cfgURI", "confURI", " configPK", "confIDs", "confOR", "ConfigURL", "confID", "componentID", "caseURL", "componentOR", " configURI", "configURL", "componentPK"], "programMessageSymbolID": ["programMessageSymmbolIDs", "programMessageSyTypeName", "programMessageSySyName", "programMessageSymbID", "programMessageSyTypeValue", "programMessageSyrorN", "programMessageSyElementID", "programMessageSymmbolName", "programMessageSymbId", "programMessageSyElementValue", "programMessageSymbN", "programMessageSymbolid", "programMessageSySyID", "programMessageSymmbolValue", "programMessageSySyid", "programMessageSyptionName", "programMessageSymmbolN", "programMessageSySyId", "programMessageSymbolIDs", "programMessageSymmbolID", "programMessageSyrorId", "programMessageSyrorIDs", "programMessageSyptionid", "programMessageSyptionId", "programMessageSyTypeId", "programMessageSymmbolId", "programMessageSymbolId", "programMessageSymbolValue", "programMessageSymbolN", "programMessageSyrorID", "programMessageSyptionID", "programMessageSyElementName", "programMessageSymbIDs", "programMessageSyElementId", "programMessageSymmbolid", "programMessageSyTypeID", "programMessageSymbolName"], "profilingMessageSymbol": ["profilingMessageSymb", "profilingMsgSyavior", "profilingMessageSyntax", "profilingMessagesyols", "profilingMessageSyols", "profilingMsgSymbol", "profilingMessagePymbol", "profilingMessageSYse", "profilingMessageSymntax", "profilingMsgSyntax", "profilingMsgSymntax", "profilingMessageSymse", "profilingMsgSymavior", "profilingMessageCyntax", "profilingMessagePyntax", "profilingMessageSymavior", "profilingMessageCyavior", "profilingMessagesyse", "profilingMessageSYmb", "profilingMessageSymols", "profilingMessagesymb", "profilingMsgSymmbol", "profilingMessageSymmb", "profilingMessageSysmb", "profilingMessageSYmbol", "profilingMessageSysols", "profilingMessageSysmbol", "profilingMessageSymmbol", "profilingMessageCymbol", "profilingMessageSyavior", "profilingMessagePyavior", "profilingMessagesymbol", "profilingMessageSyse"], "connection": ["entry", "link", "conn", "command", "condition", "operation", "settings", "generation", "network", "usage", "socket", "session", "server", "function", "city", "connected", "system", "database", "directory", "volume", "response", "information", "Connection", "table", "document", "sequence", "open", "collection", "writer", "handler", "client", "engine", "device", "cone", "associated", "bo", "subject", "we", "context", "application", "note", "module", "con", "position", "ce", "established", "connect", "ion", "resource", "library", "created", "config", "close", "initial", "relation", "db", "reference", "channel", "communication", "character", "current", "line"], "statement": ["report", "linger", " Statement", "parse", "print", "list", "rule", "command", "condition", "policy", "usage", "network", "session", "function", "execute", "chain", "memory", "processor", "Statement", "database", "journal", "expression", "volume", "response", "state", "template", "directory", "activity", "document", "sequence", "language", "description", "EMENT", "stan", "subject", "sql", "ment", "phrase", "stat", "note", "application", "sp", "comment", "mt", "position", "resource", "t", "se", "library", "set", "storage", "relation", "management", "shell", "message", "reference", "bind", "instance"], "resultSet": ["resultHandle", "rowSet", "ResultSource", " resultRow", "recordList", "traceSource", "resultS", "ResultS", "rowS", "recordset", "rowRow", "ResultScan", " resultSource", "resultPath", " resultS", "traceset", "resultset", "ResultPath", "eventset", "rowHandle", "ResultHandle", "ResultList", "rowset", "ResultRow", " resultPath", "resultRow", "recordHandle", "eventSet", "traceList", "ResultSet", "resultList", " resultScan", " resultList", "rowScan", "rowList", "eventList", "traceSet", "Resultset", "recordSet", "resultSource", " resultset", "resultScan", "eventPath"], "query": ["menu", "parse", "print", "code", "command", "condition", "gate", "create", "show", "key", "sum", "execute", "q", "question", "test", "call", "string", "expression", "ql", "volume", "transform", "Query", "ERY", "sequence", "quest", "table", "password", "scan", "commit", "send", "sql", "scope", "note", "script", "init", "title", "comment", "qu", "where", "request", "how", "check", "ion", "select", "search", "read", "update", "find", "content", "quote", "spec", "get", "QU", "lock", "message", "eries", "join", "sq"], "msg": ["man", "m", "mg", "gen", "md", "err", "ex", "html", "pkg", "sum", "meg", "doc", "term", "ext", "req", "mu", "med", "ung", "name", "kg", "error", "notice", "cmd", "char", "comm", "warn", "nom", "str", "mail", "gm", "sql", "mem", "note", "bg", "Msg", "title", "e", "em", "txt", "cmp", "og", "ged", "mt", "mun", "mn", "gem", "reason", "sm", "log", "nm", "mag", "cfg", "g", "gr", "rup", "mb", "message", "sg", "mess", "gs", "text"]}}
{"id1": "17111859", "id2": "12242903", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 1, "substitutes": {"getHash": ["gethash", "GetKey", " getSum", "createKey", "createHash", "getKey", "createSum", "GetSum", "GetHash", "Gethash", " gethash", " getKey", "createhash", "getSum"], "string": ["strings", "v", "cache", "list", "null", "space", "data", "key", "function", "address", "ring", "test", "filename", "hash", "chain", "input", "instance", "status", "array", "name", "prefix", "type", "password", "char", "attribute", "pair", "sql", "sample", "comment", "word", "value", "format", "s", "dump", "pattern", "content", "object", "ident", "message", "buffer", "text", "source"], "hashTime": [" hashTimer", "messageLength", "HashTimes", "messageTimer", "hashTimeout", "HashTime", "hashLength", " hashLength", "messageLock", "HashTimer", " hashLock", "messageTimeout", " hashTimeout", "HashLock", "clockTime", "hashLock", "clockTimeout", "clockLength", "clockTimer", " hashTimes", "messageTime", "hashTimes", "messageTimes", "hashTimer"], "md5": [" md512", " md10", "md45", " Md3", "md2", "MD3", " md1", " md55", "det2", " Mdock", "md55", "MD10", "dig45", "MD2", " Md55", " MD55", "MD512", "MD45", "det5", "det3", "dig5", "hash3", "MD5", " md2", " mdock", "md1", "mdock", "dig2", " md45", " MD3", "md3", "hash5", "hash2", "MD1", "md512", "dig1", " MDock", " Md5", " MD5", " MD10", " md3", "hash512", " MD2", "md10"], "result": ["su", "comp", "report", "cache", "mate", "list", "comb", "Result", "test", "chain", "res", "total", "response", "array", "answer", "table", "sequence", "reverse", "card", "cup", "currency", "correct", "RESULTS", "row", "ret", "pair", "valid", "work", "comment", "hex", "cur", "results", "search", "complete", "diff", "success", "match", "params", "product", "output", "r", "done", "buffer", "current"], "hexString": ["exString", " hexStr", "hexCharacter", "alphChain", " hexArray", "charString", " hexCharacter", "alphString", "exCharacter", " hexBuffer", "exArray", "exResult", "hexArray", " HexString", "charArray", " HexArray", " hexChain", "hexBuffer", " HexResult", "charResult", "exBuffer", " HexStr", "charBuffer", "alphCharacter", "hexChain", "exChain", "hexStr", "alphArray", "exStr", " hexResult", "hexResult"], "i": ["m", "multi", "ip", "v", "ci", "ui", "n", "o", "to", "l", "in", "it", "ji", "ei", "gi", "I", "q", "k", "phi", "us", "chain", "index", "ind", "\u0438", "y", "ki", "sequence", "ini", "li", "is", "gu", "ii", "io", "bi", "u", "pi", "j", "e", "a", "me", "cli", "ai", "sim", "z", "mi", "ti", "ix", "hi", "id", "di", "my", "ic", "x", "si", "xi", "qi", "uri"], "str": ["n", "cache", "tr", "ctr", "data", "Str", "key", "chain", "hash", "obj", "res", "dr", "status", "msg", "name", "arr", "sequence", "char", "ret", "enc", "cr", "br", "sp", "st", "txt", "hex", "STR", "t", "sw", "fr", "output", "r", "stable", "out", "buffer", "text", "p"]}}
{"id1": "3558512", "id2": "4982745", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "label": 0, "substitutes": {"serialize": ["finalize", "serializer", "initialization", "initialize", "erialize", "serialization", " serialate", "Serialized", "initialized", "finalization", " serialized", "Serialze", "finalized", "erialate", "serialized", "serialate", " serializer", "initialze", "serialze", "Serialate", "Serializer", "Serialize", "Serialization", "finalze", "erializer", "erialized"], "out": ["d", "o", "b", "v", "report", "n", "to", "err", "it", "sum", "res", "OUT", "c", "os", "up", "Out", "ou", "io", "aos", "f", "ch", "serv", "stream", "w", "t", "file", "log", "result", "sw", " OUT", "OU", "output", "outs", "pool", "a", "i", "p"], "parser": ["tree", "parse", "aser", "plan", "walker", "command", "Parser", "policy", "magic", "pkg", "xml", "inner", "bank", "proc", "util", "processor", "p", "reader", "token", "base", "builder", "tar", "language", "writer", "password", "handler", "asser", "rer", "worker", "layer", "style", "tp", "lp", "ger", "manager", "er", "peer", "now", "format", "file", "loader", "ler", "job", "part", "arser", "per", "jack", "instance", "ker"], "on_disk": [" on_dis", " on_disc", "on_download", "on_volume", "on_disc", "on2file", "on_file", "On_link", " on_Disk", " on_volume", "On2Disk", "on_cloud", "On2file", "On_cloud", "On2link", "On_disk", " on_file", "On_Disk", "on_Disk", "on_dis", "On_file", "on2link", "on_link", "On2disk", "on2Disk", "on2disk", " on_download"], "in": ["inf", "IN", "ad", "inc", "it", " IN", "inner", "cin", "body", "ins", "input", "ind", "vin", "rin", "bin", "min", "In", "inside", "io", "is", "isin", "and", "gin", "from", "mi", "id", "en", "ain", "inn", "sin", "on", "r", "i", "din", " din"]}}
{"id1": "19113613", "id2": "6421904", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["ip", "to", "link", "cat", "cp", "create", "cop", "cos", "download", "paste", "Copy", "pixel", "clip", "transfer", "split", "replace", "php", "core", "write", "co", "save", "init", "cross", "move", "clone", "sync", "py", "proxy", "same", "crop", "gc", "map", "opy", "zip", "delete", "Cop", "slice", "share"], "in": ["inf", "o", "IN", "l", "it", "inc", "inner", "cin", "ins", "el", "input", "inv", "re", "ind", "rin", "bin", "ir", "y", "up", "In", "inside", "is", "ini", "by", "ar", "act", "isin", "init", "con", "info", "old", "iter", "check", "ai", "from", "local", "gin", "mi", "id", "all", "en", "inn", "on", "sin", "ic", "net", "din", "i", "ie"], "out": ["o", "b", "n", "v", "to", "cache", "null", "conn", "l", "err", "it", "oss", "ex", "inner", "obj", "res", "store", "OUT", "at", "one", "base", "os", "y", "over", "io", "Out", "ou", "aos", "client", "end", "ver", "outer", "sys", "ch", "co", "write", "ot", "con", "port", "ion", "w", "t", "local", "log", "result", "ent", "gt", "set", "can", "all", "en", "op", "OU", "output", "outs", "on", "this", "tmp", "net", "not", "p", "nt"], "source": ["use", "space", "cause", "inner", "SOURCE", "key", "site", "input", "store", "system", "string", "index", "status", "template", "base", "sequence", "prefix", "language", "attribute", "style", "scan", "subject", "sql", "unit", "scope", "src", "lower", "sp", "title", "finder", "ource", "origin", "position", "Source", "ce", "search", "resource", "from", "service", "s", "format", "local", "start", "se", "range", "query", "relation", "sin", "shell", "this", "si", "ie", "select", "parent"], "target": ["tree", "goal", "to", "link", "print", "null", "step", "key", "test", "rel", "root", "tif", "location", "term", "that", "token", "template", "base", "table", "bolt", "style", "alias", "top", "other", "arg", "scope", "module", "arget", "origin", "url", "resource", "t", "local", "Target", "ARGET", "pattern", "gt", "query", "point", "match", "output", "translation", "dest", "join", "parent"], "files": ["reports", "objects", "images", "services", "members", "banks", "tools", "parts", "users", "uploads", "plates", "features", "lines", "iles", "pieces", "assets", "details", "balls", "les", "facts", "lets", "issues", "actions", "thumbnails", "resources", "headers", "jobs", "events", "books", "packages", "items", "fs", "modules", "workers", "models", "styles", "faces", "states", "values", "pages", "ports", "ls"], "file": ["entry", "tree", "rule", "print", "fe", "node", "data", "key", "full", "filename", "pe", "el", "play", "label", "folder", "child", "user", "image", "base", "name", "table", "document", "field", "feature", "line", "f", "ile", "row", "fp", "tile", "parent", "e", "work", "dir", "block", "word", "ve", "be", "port", "le", "resource", "File", "local", "library", "job", "model", "relation", "event", "path", "page", "foo", "FILE", "current", "item"], "inCh": ["inch", "cinch", "dinSam", "InChan", "inCor", "incCh", "rinCl", "cinCod", "rinChan", "inCr", "InCh", "rinCh", "rinCod", "incSam", "incCor", "InCod", "inChan", "dinCh", "inCl", "inCod", "outChan", "cinChan", "outch", "cinCr", " inChan", " inch", "dinCr", "inSam", "InCl", "cinCor", "incCr", " inCl", "outCod", "cinSam", "cinCh", "dinCor", " inCod"], "outCh": ["inch", " outCol", "newCh", " outCod", "newCol", "inCol", "outGr", "inChan", "outChan", " outch", "outch", "newCod", "newGr", " outChan", "outputCod", "newch", "outputGr", "outCod", "outCol", "outputChan", "outputCh", " outGr", "newChan"]}}
{"id1": "22022715", "id2": "937612", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"digest": ["mdested", "dests", "mdist", "digen", "dum", "digests", "Digested", "dge", "Digine", "digate", "Digest", "mnest", "date", "decge", "dist", "mden", "digge", "mdine", "mnen", "Digge", "dine", "decate", "Digate", "mdum", "mdest", "mnests", "digested", "mdests", "digum", "decest", "den", "digine", "decested", "digist", "dested", "dest", "Digum", "mnist"], "s": ["m", "b", "v", "n", "strings", "o", "l", "js", "space", "h", "string", "c", "y", "S", "is", "ss", "f", "str", "sv", "sql", "ms", "e", "ls", "bytes", "t", "sts", "ts", "ats", "ses", "sb", "r", "ps", "a", "i", "text", "sq", "p"], "ret": ["report", "att", "val", "RET", "it", "cat", "tr", "back", "rt", "data", "elt", "resp", "reset", "test", "found", "res", "det", "re", "ext", "rep", "rs", "ert", "over", "rem", "reg", "arr", "jp", "Return", "uf", "ft", "az", "cont", "buf", "arg", "ref", "pet", "Ret", "mt", "rm", "t", "ts", "result", "gt", "xt", "gb", "repl", "r", "tmp", "out", "rets", "txt", "nt"], "md": ["d", "m", "man", "mg", "ld", "cd", " Md", "mand", "bd", "pd", "hd", "MD", "mm", "det", "od", "dr", "ind", "pm", "med", "mod", "cmd", "dd", " MD", "red", "der", "df", "mail", "met", "pdf", "ms", "nd", "and", "dh", "mt", "mc", "mn", "managed", "rm", "mk", "sm", "del", "sd", "mo", "dm", "di", "mb", "ds"]}}
{"id1": "6625074", "id2": "8667872", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"SHA1": ["HS2", " SHAOne", "sha512", "sha1", "HS512", "SHA2", "SHA512", " SHA2", "HSOne", "SHAOne", "sha2", " SHA512", "shaOne", "HS1"], "text": ["v", "code", "print", "pt", "it", "data", "sum", "body", "test", "q", "doc", "input", "string", "ext", "msg", "template", "name", "document", "TEXT", "password", "form", "str", "cont", "act", "title", "comment", "ut", "hex", "word", "url", "value", "t", "read", "tx", "content", "event", "output", "nt", "message", "path", "translation", "buffer", "Text", "txt", "source"], "sha1hash": ["sha31hash", "SHA1hash", "sha3message", "SHA1Hash", "sha3hash", "sha31Hash", "sha0Hash", "shaonemessage", "sha1sum", "shaonesum", "sha1message", "SHA2hex", "sha1Hash", "ha2Hash", "ha1hash", "ha2hash", "SHA2Hash", "SHA1hex", "sha2Hash", "sha1hex", "ha1address", "sha2hash", "sha0address", "sha31address", "shaoneHash", "haonehash", "ha2address", "haonemessage", "haonesum", "ha1Hash", "sha3sum", "ha1message", "SHA2hash", "ha2sum", "sha0sum", "sha3Hash", "sha2hex", "sha0hash", "SHA1sum", "shaonehex", "sha2message", "SHA2sum", "sha2sum", "sha31sum", "ha1sum", "shaonehash", "sha2address", "sha1address", "haoneHash"], "md": ["d", "m", "amd", "ad", "cd", "ld", " Md", "mand", "strong", "bd", "pd", "hd", "hash", "obj", "MD", "mm", "det", "od", "dr", "ind", "pm", "mod", "cmd", " MD", "dd", "der", "df", "pdf", "ms", "nd", "and", "dh", "mt", "mc", "mn", "rm", "mk", "sm", "alg", "sd", "dm", "di", "ds", "sha"]}}
{"id1": "1485383", "id2": "13783549", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetApplisting", "runGetApplistING", "runGetApplistening", "runGetAppAllings", "runGetApplicationListening", "runGetApplicationListING", "runGetAppListening", "runGetApplistings", "runGetApplicationListing", "runGetAppListings", "runGetAppAlling", "runGetApplicationListings", "runGetAppListING", "runGetAppAllening", "runGetAppAllING"], "url": ["http", "link", "web", "l", "ll", "address", "server", "k", "user", "res", "location", "lb", "base", "google", "ul", "abs", "ssl", "dl", "u", "ret", "ref", "ur", "nl", "api", "domain", "https", "URL", "acl", "au", "gc", "service", "result", "Url", "job", "id", "host", "sb", "path", "ls", "uri"], "appListingList": ["appListingStatus", "appHoldingsType", "appListedList", "appListingsStatus", "appListlingGroup", "appListeningList", "applistlingSpec", "appParterL", "appParterlist", "appListningL", "appListINGL", "appListlingL", "appListuingGroup", "appListlingList", "appLististinglist", "appLististingL", "appBlocklingList", "appHoldinglist", "appPartingNot", "applistlingEx", "appListingsGroup", "appLististingList", "appListlingEx", "appListerList", "appListINGlist", "appListlingSpec", "appHoldingList", "appListINGStatus", "appListeningType", "appListningList", "appHoldingsL", "appHoldingL", "appBlockingList", "appBlockingStatus", "appPartinglist", "appListingEx", "applistingList", "appListedlist", "appListningNot", "appPartingL", "applistingEx", "appListedSpec", "appListingsList", "appListhingSpec", "appListeninglist", "applistingL", "appBlockINGStatus", "appListingSpec", "appListingType", "appBlockINGlist", "appListingGroup", "appListhingL", "appBlocklingL", "appBlockingL", "appBlockINGList", "appListhingEx", "appListhingList", "appBlockingGroup", "appListedType", "appPartingList", "appListedL", "appBlockinglist", "appBlockINGL", "appListerlist", "appBlocklingGroup", "appHoldingslist", "appListinglist", "appListerNot", "appListningStatus", "appListuingL", "appListninglist", "appHoldingsList", "applistlingList", "appListingsType", "appListINGList", "appHoldingType", "appListeningL", "appListedEx", "appListingsL", "applistingSpec", "applistlingL", "appListuingList", "appListerL", "appListingslist", "appParterList", "appLististingNot", "appListingL", "appListingNot", "appParterNot"], "request": ["http", "report", "ip", "print", "list", "command", "condition", "project", "record", "use", "create", "reset", "q", "question", "root", "call", "change", "input", "re", "process", "req", "accept", "shape", "over", "quest", "open", "writer", "begin", "remove", "client", "queue", "rate", "first", "connection", "application", "setup", "copy", "method", "position", "resource", "Request", "complete", "service", "apache", "job", "QUEST", "query", "set", "trip", "close", "forward", "initial", "get", "hello", "order", "object", "message", "relative", "buffer", "instance", "select"], "readTimeout": ["readtimeout", "writetimeout", "connectTime", "ReadTimeout", "Readtimeout", "readLimit", "writeTime", "sendTimeout", "httpLimit", "writeLimit", "httpTime", "ReadTime", "sendtimeout", "connectTimeout", "connectLimit", "sendLimit", "ReadLimit", "writeTimeout", "sendTime", "readTime", "httpTimeout", "connecttimeout", "httptimeout"], "response": ["http", "report", "entry", "feed", "network", "data", "resp", "body", "respond", "server", "res", "onse", "process", "status", "image", "remote", "group", "answer", "document", "sequence", "open", "description", "trace", "json", "channel", "connection", "application", "e", "reply", "bytes", "block", "ce", "ve", "next", "resource", "service", "respons", "result", "Response", "exit", "success", "object", "view", "output", "message", "page", "out", "frame", "tree"]}}
{"id1": "21063400", "id2": "12236729", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"doImageProcess": ["doItemImageSort", "doItemImageProcess", " doImageprocess", " doImagesSort", " doImagesProcess", "doMediaWork", " doImageSort", " doImageWork", "doMediaprocess", "doImagesSort", "doImagesWork", "doItemImageprocess", "doImageSort", "doImagesprocess", " doImagesprocess", " doImagesWork", "doMediaProcess", "doImagesProcess", "doImageprocess", "doImageWork", "doMediaSort", "doItemImageWork"], "request": ["command", "address", "server", "session", "question", "input", "re", "image", "template", "document", "quest", "attribute", "client", "context", "application", "version", "resource", "Request", "start", "QUEST", "query", "model", "view", "reference", "message", "frame", "select"], "response": ["http", "report", "entry", "cache", "print", "continue", "list", "detail", "network", "xml", "resp", "server", "respond", "reset", "site", "hash", "res", "user", "onse", "re", "window", "image", "status", "one", "answer", "document", "sequence", "description", "collection", "json", "connection", "parent", "application", "write", "reply", "version", "position", "block", "ve", "next", "search", "format", "Response", "result", "exit", "model", "success", "query", "console", "content", "relation", "view", "output", "fire", "message", "page", "display", "frame", "tree"], "imgSize": [" imgName", "dimsize", "imagError", "imageSIZE", "dimSIZE", "propName", "certScale", "augSize", "certSIZE", "imageInfo", " imgShape", "imageScale", "divSIZE", "imgsize", "augOwner", " imgType", "imgInfo", "imgStyle", " imgsize", "divsize", "divSize", "imgScale", "appStyle", "certSize", "appShape", "imgShape", "appSize", " imgInfo", "augsize", "appsize", "certName", "imagSize", "imgOwner", "imagName", "propsize", "augShape", "imageStyle", "appType", " imgOwner", " imgStyle", "imageSize", " imgSIZE", "imgError", "dimSize", "imgSIZE", "imgName", "appInfo", " imgScale", "propSize", " imgError", "appOwner", "propError", "imgType", "imagsize", "imageName", "imageType"], "imageInputStream": [" imageInputPath", "imageOutputSteam", "imageInStream", "fileRawStream", "fileInputStream", "imageIntPath", "imageInterfaceStream", "imageInputSteam", "imageInSteam", "photoIntstream", "imageByteStream", "fileRawSteam", " imageStreamPath", "imageRawView", "fileRawstream", "imageByteForm", "mediaInputForm", "imageInputPath", "imageStreamPath", "imageRawstream", "imageInputView", "imageInstream", "mediaInputReader", "imageByteReader", "photoIntStream", "photoIntSteam", "imageStreamSteam", "mediaInputSteam", "imageInputReader", "fileInputSteam", " imageStreamStream", "imageRawStream", "imageInterfaceSteam", "imageIntStream", "imageByteSteam", "imageStreamStream", "imageOutputstream", "imageIntstream", "imageOutputForm", "imageOutputReader", "imageInterfaceView", "imageOutputStream", "photoInputstream", "imageInputstream", "fileInputView", "imageRawSteam", "mediaInputStream", " imageStreamSteam", "imageIntSteam", " imageInputSteam", "photoInputSteam", "imageInputForm", "imageInView", "fileRawView", "photoInputStream", "imageInterfacestream", "fileInputstream"], "imageBytes": ["photoGs", "pictureBytes", "audioBytes", "photoBytes", "imgGs", "imageSeries", "imgBs", "imageGs", "photoParts", "imageKeys", "issueParts", "audioSeries", "imageParts", "imageByte", "issueGs", "issueBytes", " imageBs", " imageGs", " imageSeries", " imageByte", "imgBytes", "photoByte", "audioParts", "pictureByte", "imgParts", "photoKeys", "pictureGs", "audioBs", "imgSeries", " imageParts", "pictureParts", "imgKeys", "issueKeys", "imageBs"]}}
{"id1": "4164833", "id2": "7927042", "code1": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"buildDeb": [" rebuildDeb", " buildAud", "BuildAud", " buildDub", "builddeb", "BuildDub", " rebuildAud", " rebuilddeb", "Builddeb", " builddeb", "buildDub", "BuildDeb", " rebuildDub", "buildAud"], "debFile": ["debFILE", "debfile", "ubFilename", "debFilename", "audFiles", " debFiles", "pkgFiles", "debile", " debile", "obFile", "audFilename", " debFILE", " debfile", "audFILE", "obile", "pkgFilename", "pkgFile", "obFilename", "ubFile", "debFiles", "ubile", "audFile", "pkgFILE", "obfile", "ubfile", " debFilename"], "controlFile": [" controlChain", "controlChain", "controlFiles", "scriptFiles", "configFILE", "controlfile", "configfile", "rolFile", " controlfile", "rolFILE", "ctrlFiles", " controlLog", "rolfile", "ctrlfile", "ctrlFile", "configFile", "dataFiles", "scriptFILE", "dataLog", "scriptfile", " controlFiles", "dataChain", "controlFILE", "ctrlLog", "controlLog", "configFiles", " controlFILE", "scriptFile", "ctrlChain", "ctrlFILE", "datafile"], "dataFile": ["datSet", "dataFILE", "datFile", "DATAStream", "dataList", "datfile", " dataTable", "runfile", "valueLot", "runFILE", " dataFiles", "datFILE", " dataSet", "valueFILE", "dataFiles", "DataTable", "helpList", "dataSet", " datafile", "runFile", "runList", "runSet", "helpFile", "byLot", "valueFile", " dataList", "dataTable", "runLot", "DataFile", "DATAFile", "byFile", "DATAFiles", "DataFiles", "helpfile", "byFILE", "DataStream", "DATATable", "helpLot", "dataLot", "valueFiles", "dataStream", " dataFILE", " dataStream", " dataLot", "byFiles", "datafile"], "now": ["age", "then", "zero", "time", "since", "num", "create", "Now", "full", "NOW", "post", "date", "store", "system", "aw", "java", "loc", "after", "www", " Now", "first", "percent", "force", "off", "old", "ow", "aj", " NOW", "size", "cur", "today", "wait", "from", "present", "here", "start", "always", "sw", "set", "low", "and", "on", "app", "stuff", "fx", "length", "current"], "deb": ["daily", "pkg", "rel", "desc", "ub", "req", "gob", "abs", "dl", "we", "und", "dec", "com", "bl", "cm", "sb", "dt", "erb", "ob", "Deb", "dev", "report", "web", "priv", "cp", "cmd", "red", "comm", "img", "pub", "compl", "reb", "cb", " Deb", "aud", "del", "eb", "dan", "sub", "prep", "mb", "de", "broad", "rob", "pay", "download", "stab", "bar", "fin", "df", "review", "jpg", "og", "put", "be", "etc", "sd", "def", "iban", "conf", "db", "debug", "cd", "dat", "dp", "av", "debian", "decl", "gif", "ib", "div", "fb", "dep", "bb", "eg", "dm"], "control": ["comp", "roll", "ca", "code", "command", "ll", "ctr", "rl", "rel", "controller", "ro", "system", "cond", "cons", "cmd", "form", "Control", "comm", "core", "trl", "cell", "cont", "critical", "correct", "rc", "compl", "co", "controlled", "ctl", "con", "setup", "check", "com", "connect", "crit", "ctrl", "const", "config", "console", "content", "cm", "scroll", "cc", "rol", "history", "current"], "buffer": ["rule", "batch", "cache", "print", "parse", "command", "absolute", "Buffer", "function", "filter", "chain", "memory", "label", "paste", "window", "database", "directory", "term", "template", "base", "shape", "table", "sequence", "button", "document", "bar", "attribute", "hold", "buf", "row", "number", "queue", "bo", "context", "phrase", "note", "append", "buff", "sample", "comment", "stack", "iter", "block", "stream", "resource", "library", "result", "match", "variable", "binary", "view", "scroll", "message", "temp", "page", "history", "length", "frame", "bridge"], "read": ["ip", "then", "print", "in", "key", "ro", "rd", "fill", "ek", "req", "hold", "io", "end", "ang", "mix", "iter", "connect", "get", "scroll", "like", "length", "select", "report", "raw", " Read", "val", "push", "skip", "pass", "input", "index", "exec", "load", "dd", "char", "red", "build", "est", "word", "stream", "ke", "depth", "handle", "start", "config", "READ", "find", "run", "reads", "len", "need", "give", "play", "reader", "ind", "rand", "remove", "core", "cont", "send", "valid", "write", "check", "search", "close", "reflect", "match", "each", "bind", "thread", "pe", "seek", "error", "count", "draw", "old", "through", "size", "add", "se", "query", "height", "text", "readable"], "data": ["dev", "http", "d", "to", "debug", "raw", "feed", "batch", "list", "cache", "dat", "test", "extra", "rel", "no", "window", "database", "na", "reader", "image", "mu", "one", "video", "bin", "table", "error", "da", "meta", "DATA", "valid", "ata", "div", "info", "news", "next", "normal", "internal", "file", "help", "auto", "query", "def", "good", "di", "db", "share", "not", "bus"]}}
{"id1": "9413074", "id2": "12171364", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"getLocation": [" getURL", " getLoc", " getDescription", "GetLocation", "newLoc", "getURL", "loadDescription", "newlocation", "getlocation", "newDescription", "loadLocation", "getURI", "loadURI", "newLocation", "GetDescription", "GetURL", "GetURI", " getlocation", "Getlocation", "getDescription", "getLoc", "GetLoc", "loadURL", " getURI"], "clazz": ["clClass", "scaz", "clos", "clclass", " clamp", "ClClass", "Clos", "klClass", " claz", "Clclass", "scazz", "CLaz", "claz", "Clamp", "CLazz", "klazz", " clos", "CLclass", "clamp", "klclass", "klaz", "Clazz", "scamp", "Claz", "scos", "CLClass"], "url": ["browser", "http", "link", "conn", "web", "l", "err", "socket", "ll", "rl", "xml", "address", "q", "rel", "user", "string", "hl", "base", "loc", "cert", "char", "client", "f", "str", "ul", "abs", "mail", "ssl", "ret", "dl", "ref", "org", "ur", "nl", "build", "u", "sql", "mount", "channel", "https", "URL", "gl", "resource", "impl", "handle", "loader", "result", "log", "ml", "Url", "sl", "get", "host", "run", "r", "lr", "this", "row", "sb", "addr", "util", "remote", "path", "buffer", "ob", "ls", "uri"], "location": ["summary", "Location", "command", "l", "slot", "resolution", "operation", "usage", "address", "function", "filename", "displayText", "selection", "string", "directory", "padding", "expression", "family", "name", "loc", "area", "document", "layout", "ocation", "language", "description", "type", "trace", "feature", "behavior", "media", "row", "nl", "scope", "availability", "application", "title", "comment", "color", "where", "none", "origin", "position", "peer", "ion", "resource", "value", "local", "range", "library", "result", "direction", "update", "relation", "region", "reference", "path", "message", "history", "translation", "display", "length"], "file": ["ca", "angle", "full", "filename", "pe", "user", "folder", "entity", "image", "checked", "name", "table", "io", "f", "ile", "fp", "ref", " File", "files", "module", "dir", "ory", "block", "port", "out", "le", "resource", "File", "format", "library", "binary", "object", "face", "db", "output", "run", "path", "page", "channel", "FILE", "parent"]}}
{"id1": "22431487", "id2": "23532405", "code1": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 0, "substitutes": {"doPost": ["doQuery", " doPOST", "DoGet", "DoPOST", "internalGet", " doQuery", "internalPost", " doGet", "doGet", "internalPOST", "internalQuery", "DoQuery", "DoPost", "doPOST"], "URL": ["HTTP", "TL", "Location", "IN", "Path", "Name", "NAME", "SOURCE", "L", "SSL", "PORT", "HTML", "Address", "OUT", "CL", "SR", "RL", "EL", "LL", "AT", "API", "GET", "METHOD", "URI", "STR", "url", "REF", "UL", "Url", "PATH", "RAW", "IL", "DL", "PUT", "ID", "UR", "FILE"], "params": ["batch", "idents", "forms", "words", "settings", "tags", "ops", "members", "requires", "pins", "times", "parts", "keys", "points", "options", "mm", "posts", "lines", "param", "rs", "details", "properties", "ams", "months", "json", "actions", "photos", "Parameters", "AMS", "sql", "Par", "phys", "par", "news", "names", "changes", "packages", "items", "config", "fields", "styles", "amps", "stats", "ps", "pps", "values", "ports", "pages", "marks", "terms", "vals", "p"], "util": ["http", "uh", "security", "ility", "ui", "usage", "install", "utf", "hog", "til", "fu", "mu", "rot", "iu", "form", "hu", "il", "ul", "api", "u", "Ut", "um", "lu", "utils", "wal", "ut", "eu", "info", "cu", "ool", "fun", "url", "nu", "format", "help", "etc", "modern", "tu", "hum", "lib", "ils", "conv", "tree"], "uri": ["http", "wiki", "ui", "link", " URI", "source", "address", "based", "phi", "uni", "location", "term", "directory", "msg", "base", "prefix", "client", "uid", "subject", "api", "u", "pi", "unit", "ur", "sky", "ref", "domain", "du", "URI", "ri", "url", "nu", "resource", "service", "range", "course", "quote", "host", "this", "path", "uu"], "httpclient": ["hClient", "Httpclient", "httpserver", "httpsnet", "httpsconnection", " httpce", "httpClient", "Httpnet", "hce", "Httpconnection", "httpnet", "Httpce", "hclient", "httpsClient", " httpconnection", "httpsclient", " httpnet", " httpserver", " httpClient", "HttpClient", "httpconnection", "httpce", "Httpserver", "hserver"], "postMethod": ["putField", "preMethod", "PostMETHOD", "preRequest", "httpField", "putMETHOD", "httpOperation", "pubOperation", "postField", "postClient", "putClient", "httpMethod", "postOperation", "pubRequest", "handleMethod", "pubMethod", "putOperation", " postMETHOD", "PostOperation", "putMethod", "handleClient", "pubMETHOD", "PostMethod", "preOperation", "postRequest", "putRequest", "handleMETHOD", "PostField", "handleRequest", " postRequest", "httpmethod", "postmethod", "preMETHOD", "putmethod", " postClient", "Postmethod", "PostRequest", "postMETHOD"], "paramString": ["paramSet", "paramBuffer", "ParamUnit", "ParamList", "permChain", "aramString", "pstring", "permFile", "ParamStr", "termNumber", " paramSet", "paramstring", "termString", "processstring", "postStr", "permBuffer", "paramStr", "paramsSet", " paramChain", "attributeBuffer", "paramsUnit", "ParamArray", "attributeArray", " paramFile", " paramNumber", "attributeString", "permNumber", "postBuffer", "postString", "ParamBuffer", "paramsList", "aramStr", "ParamShort", "paramList", "permString", "paramsstring", "paramsStr", " paramUnit", "paramChain", "permByte", "pSet", " paramStr", "attributeByte", "pStr", "termFile", "paramNumber", "paramShort", "paramArray", " paramList", "termChain", "processString", "ParamString", "aramShort", "paramByte", "aramBuffer", "paramsString", "pString", "permArray", "paramUnit", "paramFile", "ParamByte", "postShort", "argString", " paramstring", "argstring"], "i": ["m", "b", "ip", "in", "it", "ei", "key", "q", "c", "y", "iv", "ini", "is", "io", "fi", "bi", "pi", "me", "init", "t", "mi", "ix", "a", "hi", "o", "v", "index", "im", "oi", "ii", "gu", "u", "j", "eu", "id", "ic", "x", "I", "xi", "p", "ci", "ui", "ind", "ql", "ori", "iu", "f", "il", "ms", "info", "ai", "sim", "di", "or", "si", "ie", "d", "ij", "multi", "gi", "ami", "chain", "phi", "us", "li", "ski", "e", "er", "ia", "ims", "my", "slice", "ti", "ji", "qi", "uu"], "xx": ["kw", "xy", "XXXX", "von", "yy", "aaa", "ous", "fw", "wx", "zzy", "xxxxxxxx", "y", "xxxx", "zz", "bu", "xxx", "ang", "ng", " XX", "yk", "enc", "kk", "txt", "hex", "ux", "xs", "XXX", "mk", "smith", "pp", "ck", "hz", "ess", "REDACTED", "fx", "x", "fy", "foo", "xi", "XX"], "httpResponse": [" httpresponse", " httpEntity", "HttpResponse", " httpRes", " httpResp", "httpsResponse", "consoleResponse", "httpAnswer", "consoleEntity", "consoleresponse", "httpResp", "ttpResp", "httpClient", "ttpresponse", "httpresponse", "ttpEntity", "ttpResponse", "HttpResp", "HttpRes", "httpsRes", "httpsresponse", "httpsClient", "ttpClient", "consoleAnswer", "ttpAnswer", "Httpresponse", "httpRes", "httpEntity", " httpClient", " httpAnswer", "ttpRes"], "strResult": ["Strresult", "stringResult", "STRNow", " strRes", "StrNow", "StrResult", "strRest", " strRest", "txtRes", "STRRest", "StrResults", "stringresult", "txtResults", "StrRes", "STRRes", "STRResults", "txtNow", "strNow", "strResults", "strRes", " strresult", "strresult", "STRresult", "txtresult", "txtRest", "stringResults", "txtResult", " strResults", "STRResult", "stringRes"]}}
{"id1": "17999474", "id2": "88047", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipTofile", "getZipFromfile", "getBoxFromfile", "getZipToPath", "getBoxFromLocal", "getZipInLocal", "getBoxFromFile", "getZipFromPath", "getBoxFromPath", "getBoxAsLocal", "getBoxAsFile", "getBoxAsPath", "getZipInPath", "getZipFromFile", "getZipToLocal", "getZipToFile", "getZipInFile", "getZipAsLocal", "getZipAsPath", "getZipAsfile", "getZipInfile", "getBoxAsfile", "getZipFromLocal"], "digOb": ["chemEx", "chemObj", "DigObject", " digOcc", "digObject", "digOB", "DigEx", "DigOb", "digEx", "DigOcc", "divObj", "DigObj", "digOcc", "gradOb", " digObj", "gradObject", "divObject", "divOb", " digObject", "divOcc", " digOB", "gradOB", "chemOB", "DigOB", "chemOb", "gradObj", " digEx", "digObj"], "folderName": ["FolderNames", "folderSize", "foldername", "Foldername", "FolderPath", "folderNames", "fileNames", "foldNames", " folderNames", "foldSize", "foldname", " foldername", "folderPath", "FolderName", "foldPath", " folderKey", " folderSize", "folderKey", "fileKey", "foldKey", "foldName", "fileSize", " folderPath", "fileName"], "tmpFolder": [" tmpfolder", "mpDirectory", "mpDir", "mpFolder", " tmpDir", "cmpDir", "tmpParent", "cmpFolder", "tmpDirectory", " tmpDirectory", "cmpParent", "tempfolder", "tempDirectory", "tempDir", "mpfolder", "cmpfolder", "tmpDir", "tempFolder", "tmpfolder", "tempParent", "mpParent"], "zip": ["report", "jar", "entry", "ip", "link", "feed", "csv", "project", "pkg", "xml", "install", "body", "test", "post", "folder", "drop", "sea", "template", "tar", "io", "cf", "pack", "form", "col", "bag", "f", "sheet", "json", "mail", "row", "pdf", "sample", "box", "sp", "upload", "ow", "zone", "proxy", "file", "se", "library", "exp", "cloud", "Zip", "wrap", "quote", "content", "lock", "tmp", "gz", "pool", "temp", "archive", "z"], "out": ["o", "to", "n", "print", "v", "null", "list", "in", "ex", "oss", "it", "inner", "flush", "cos", "us", "inv", "ins", "res", "OUT", "one", "os", "up", "ou", "Out", "io", "aos", "writer", "co", "write", "sp", "serv", "copy", "ln", "check", "t", "s", "auto", "ent", "set", "all", "en", "OU", "output", "outs", "tmp", "net", "i", "conv"]}}
{"id1": "19868933", "id2": "8788371", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingRFile", "copyFromFileToFileUsingRIO", "copyFromFileToFileUsingNHFile", "copyFromFileToFileUsingMIE", "copyFromFileToFileUsingRIE", "copyFromFileToFileUsingMFile", "copyFromFileToFileUsingRIF", "copyFromFileToFileUsingNIE", "copyFromFileToFileUsingNHIF", "copyFromFileToFileusingRIE", "copyFromFileToFileUsingNFile", "copyFromFileToFileusingRIF", "copyFromFileToFileUsingNIF", "copyFromFileToFileusingNIF", "copyFromFileToFileusingRIO", "copyFromFileToFileUsingNHIO", "copyFromFileToFileusingNFile", "copyFromFileToFileusingRFile", "copyFromFileToFileusingNIE", "copyFromFileToFileUsingNHIE", "copyFromFileToFileUsingMIO", "copyFromFileToFileUsingMIF", "copyFromFileToFileusingNIO"], "inputFile": ["openfile", "inputPath", "loadfile", "outputByte", "loadLe", "openLe", "loadFile", "importByte", " inputStream", " inputLe", "importFile", "outputStream", " inputPath", "inputfile", "inputLe", "outputPage", "inputPage", "importStream", " inputfile", " inputPage", "inputStream", "importPage", "loadPath", "inputByte", "openPath", "openFile", " inputByte"], "outputFile": [" outputfile", "putFile", "toStream", "putfile", "outputPlace", "toFile", " outputPlace", "putDirectory", "resultFile", "resultFiles", "toPlace", "outputStream", "inputDir", "resultStream", "inputfile", " outputDir", "outputDir", "putDir", "outputfile", "outputFiles", " outputStream", "outputDirectory", " outputDirectory", " outputFiles", "resultPlace", "toFiles", "inputDirectory"], "inputChannel": ["inputConnection", "inputChan", "outputBuffer", " inputListener", "internalChannel", "importCategory", "tableChannel", "internalScope", "openChannel", " inputChuck", " inputCategory", "loadManager", "httpConnection", "httpChannel", " inputStream", "outputchannel", "inputchannel", "InputStream", "tableScope", "inputListener", " inputManager", "inputBuffer", "internalListener", "outputStream", " inputchannel", " inputBuffer", " inputConnection", "importChuck", "InputBuffer", "outputConnection", "rawChannel", " inputScope", " inputBlock", "importChannel", " inputChan", "openConnection", "inputBlock", "InputChannel", "inputStream", "tableListener", "loadChannel", "rawChan", "openchannel", "outputChan", "inputScope", "importManager", "inputChuck", "rawConnection", "loadChuck", "internalBlock", "inputManager", "inputCategory", "rawFile", "httpChan", "openChan", "tableBlock", "InputConnection", "httpFile", "loadCategory"], "outputChannel": ["publicchannel", "languageChannel", "OutputStream", "putButton", "hiddenChan", "outputchannel", "languagechannel", "consoleStream", "publicCow", "removeChannel", "displayCategory", " outputCamera", " outputButton", "putChan", "displayClient", "outputStream", " outputClient", "hiddenCamera", "languageCategory", "outputClient", "removechannel", "hiddenButton", "putChannel", "consoleCow", "putCamera", "OutputFile", "outputButton", "publicChannel", " outputCategory", "consolechannel", "displaychannel", "languageClient", "OutputChan", " outputStream", "hiddenChannel", "outputChan", "outputCow", "removeCow", "displayChannel", "outputCategory", "OutputChannel", " outputchannel", " outputChan", "outputCamera", "consoleFile", "consoleChannel", "consoleChan"]}}
{"id1": "7458833", "id2": "23666867", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFiletocodeFiles", " copyParseFileToGofile", " copyParseFiletoCodefile", " copyParseFileTocodefile", " copyParseFileToInfoTable", " copyParseFileToInfoFiles", " copyParseFileToInfofile", " copyParseFiletoCodeFile", " copyParseFileToCodeTable", " copyParseFileToGoFile", " copyParseFiletocodeTable", " copyParseFileToCodefile", " copyParseFileToGoFiles", " copyParseFileTocodeTable", " copyParseFileTocodeFile", " copyParseFiletocodeFile", " copyParseFileToGoTable", " copyParseFiletoCodeTable", " copyParseFiletocodefile", " copyParseFiletoCodeFiles", " copyParseFileToInfoFile", " copyParseFileTocodeFiles", " copyParseFileToCodeFiles"], "in": ["inf", "IN", "ad", "it", "inc", "al", "inner", "cin", "ins", "input", "mm", "ind", "rin", "bin", "im", "ir", "up", "inside", "In", "io", "is", "ini", "ar", "ze", "act", "isin", "init", "con", "info", "iter", "check", "ai", "gin", "from", "read", "en", "ain", "inn", "on", "i", "ic", "din"], "out": ["o", "v", "to", "dis", "n", "null", "ne", "ex", "it", "oss", "inner", "cos", "obj", "res", "OUT", "at", "one", "os", "up", "Out", "ou", "io", "aos", "writer", "client", "by", "outer", "sys", "conv", "write", "co", "ot", "con", "and", "check", "t", "auto", "can", "en", "g", "output", "outs", "on", "net", "cn", "i", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "memory", "paste", "window", "database", "template", "bone", "button", "table", "document", "sequence", "bar", "attribute", "char", "pad", "queue", "buf", "cell", "row", "phrase", "append", "buff", "sample", "comment", "stack", "iter", "block", "word", "resource", "reason", "result", "variable", "binary", "initial", "view", "component", "message", "temp", "display", "history", "frame", "character", "bridge"], "length": ["capacity", "print", "l", "ength", "duration", "data", "angle", "amount", "full", "reading", "total", "padding", "database", "lambda", "volume", "available", "distance", "load", "shape", "sequence", "collection", "len", "height", "frequency", "number", "closure", "count", "Length", "availability", "how", "position", "size", "binding", "ENGTH", "t", "integer", "impl", "present", "start", "point", "maximum", "component", "hello", "deep", "message", "history", "family", "frame", "join", "bow", "stop", "enth"]}}
{"id1": "20091126", "id2": "23666867", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" Copy", "to", "cat", "cp", "create", "call", "download", "store", "Copy", "paste", "system", "transfer", "load", "y", "Transfer", "io", "open", "write", "save", "upload", "move", "sync", "clone", "file", "map", "get", "delete", "Cop"], "in": ["inf", "b", "n", "IN", "l", "inc", "inner", "cin", "ins", "el", "input", "mm", "ind", "rin", "up", "In", "ini", "io", "isin", "init", "old", "info", "file", "gin", "from", " input", "id", "en", "ck", "ain", "r", "inn", "din", "i", " din", "source"], "out": ["o", "b", "n", "v", "to", "null", "l", "ex", "it", "err", "res", "OUT", "at", "one", "msg", "self", "c", "os", "y", "io", "Out", "ou", " os", "end", "or", "channel", "ch", "co", "write", "e", "ot", "bytes", "w", "t", "file", "s", " output", "result", "log", "gt", "as", "_", "output", "outs", "tmp", " it", "net", "x", "p", "nt"], "inChannel": ["conListener", "cinBlock", "conChannel", "conChan", "InChan", " inConnection", " inchannel", " inCommand", "INConnection", "incChannel", "inSection", "innConnection", "ginChuck", "InChannel", "inPanel", "binChannel", "inchannel", "outCommand", "binCommand", "outBlock", "inBlock", "insideChannel", "INChan", "innchannel", "incChain", "inConnection", "INChannel", "inChan", "ginPanel", "inCommand", "binChain", "inChain", "Inchannel", "outchannel", "conConnection", "incPanel", "incChuck", "cinChannel", " inChan", "binChuck", " inRow", "binRow", "binPanel", "insideSection", "inChuck", "ginChain", "cinchannel", " inSection", "InConnection", "insideRow", "ginChannel", "innChannel", "inListener", " inListener", "inRow", "binSection", " inBlock", "cinCommand", "insideCommand", "INListener", "innChan"], "outChannel": [" outCh", "cmdChan", "OUTSlot", "skyGate", "cmdGate", "skyMany", " outManager", " outPassword", "OUTChan", "inchannel", "outPassword", "cosChan", "outGate", "inUser", "Outchannel", "inChan", "inCh", "outCh", "outChan", "skyChan", "moduleChannel", "outchannel", "OUTUser", "outSlot", "cmdMany", " outchannel", "outputChannel", "moduleManager", "cmdChannel", "OutChan", "inSlot", "OUTChannel", "cosUser", " outChan", "cosSlot", "outUser", "OutChannel", "OutCh", "outManager", " outMany", "outputChan", "outputPassword", "cosChannel", "modulePassword", "skyChannel", "outputManager", "moduleChan", " outGate", "outMany"]}}
{"id1": "16572931", "id2": "18433984", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"unJar": ["UnPath", "removeExt", "UnJar", "removeJar", "removePath", "unExt", "UnZip", "unPath", "unZip", "UnExt", " unPath", "removeZip", " unZip", " unExt"], "jarPath": ["browserUrl", "reportpath", "reportUrl", "javaName", "pkgpath", "reportPath", " jarLocation", "jobPath", "jFull", "javaHost", "browserpath", "jarFull", "javaBase", " jarBase", "jName", "browserHome", " jarHome", "pkgName", "jHost", "pkgInfo", "relInfo", "bareFull", "jobLocation", "javapath", "javaFile", " jarName", "browserPath", "javaPath", "javaUrl", "javaInfo", "pkgPath", "jPath", "browserName", " jarpath", "jarpath", "bareName", "jarHost", "barePath", " jarUrl", " jarFile", "carBase", "carPath", "jobFile", "jarLocation", "carpath", "bareHost", "jarUrl", "javaLocation", "carName", "reportName", "jobpath", " jarInfo", "relpath", "jarInfo", "browserInfo", "jarName", "relHome", "jarBase", "jarHome", "jarFile", "javaFull"], "jarEntry": ["browserEnt", " jarentry", "certentry", "springEnt", "JarPost", "springEntry", "reportPost", "jitEntry", "jEnt", "Jarentry", "javaentry", "jEntry", "browserPost", "sessionEntry", "jitInfo", "sessionName", "springItem", " jarName", "jobEnt", " jarEnter", "jitEnt", "jobEntry", "javaItem", "JarEnt", "certName", "browserEnter", "certEnt", "javaEntry", "sessionEnt", "jarentry", "browserName", "javaEnt", "jentry", "jobPost", "jitEnter", "certEntry", "jarItem", "jarEnt", "reportentry", "jarPost", "jItem", "browserEntry", "springentry", "reportEnt", " jarInfo", "jarInfo", "browserInfo", " jarEnt", "jarName", "sessionentry", "jarEnter", "javaPost", "browserentry", "JarEntry", "reportEntry"], "path": ["partial", "print", "it", "pkg", "data", "key", "full", "test", "walk", "string", "location", "ath", "loc", "client", "pi", "dir", "url", "file", "home", "PATH", "right", "select", "to", "address", "input", "folder", "index", "self", "at", "template", "base", "transform", "min", "prefix", "cmd", "api", "ref", "module", "title", "mount", "position", "value", "here", "set", "id", "order", "zip", "output", "method", "x", "p", "Path", "room", "core", "context", "where", "hex", "check", "with", "port", "format", "route", "host", "empty", "message", "left", "history", "relative", "temp", "tree", "parent", "near", "phi", "root", "distance", "name", "trace", "text", "pattern", "log", "point", "this", "join"], "relPath": ["elEntry", "RELPort", " relText", "RelPort", " relName", "RelText", "relName", "RELName", "relPort", " relPort", "RelEntry", "Relpath", "RELText", "relText", "relEntry", " relEntry", "relpath", " relpath", "RelName", "elPath", "RELPath", "elpath", "elName", "RelPath"], "jar": ["comp", "batch", "tab", "ctr", "pkg", "cp", "ja", "jo", "star", "rar", "sea", "war", "java", "tar", "deb", "jp", "bar", "cert", "pack", "bag", "ar", "jj", "jit", "j", "vol", "sp", "bare", "og", "Jar", "be", "le", "se", "zo", "jet", "job", "jc", "car", "good", "zip", "lib", "archive", "ie"], "ze": ["ene", "enz", "sle", "zy", "ZE", "Ze", "jo", "aze", "ez", "pe", "ee", "oe", "sk", "ie", "she", "zer", "zie", "ge", "so", "cz", "e", "za", "ce", "be", "ve", "le", "je", "te", "zes", "ke", "se", "zo", "sl", "zing", "ae", "zip", "zed", "ne", "ea", "z", "zi"], "bin": ["b", "bian", "thin", "in", "pin", "ebin", "cin", "abin", "dll", "spin", "obin", "pan", "bu", " Bin", "fin", "bi", "bed", "skin", "jin", "kin", "sam", "bg", "buff", "box", "con", "ln", "win", "gin", "pic", "binary", "bl", "bat", "bm", "di", "db", "sin", "png", "lib", "ic", "din"]}}
{"id1": "10795866", "id2": "7372311", "code1": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"upload": [" up", "edit", "create", "uploads", "download", "store", "paste", " uploaded", " summarize", "load", "up", " Upload", " resize", "save", "move", "copy", " move", "Upload", "present", " overwrite", "read", " demo", "picture", " thumbnail", " destroy", " ugly", " insert", " download"], "destDir": ["DestPath", "DestLoc", "procLoc", "procDIR", "destPath", " destPath", "declDir", "declPath", "declPat", " destdir", "destDirectory", " destDIR", "decldir", "procDir", "Destdir", "DestDir", "DestDirectory", "destDIR", "destdir", " destPat", "DestDIR", " destDirectory", "destPat", "procDirectory", "destLoc", "DestPat", " destLoc"], "fos": ["to", "flOS", "feose", " fose", "los", "foos", "fOS", " fom", "Foss", "feos", "toss", "fom", "fose", "Foos", "fo", " foos", "floss", "woss", "flot", "Fos", "wos", "floos", " foss", "fot", "wose", "lOS", "loss", "foss", "Fo", "FOS", "Fot", "flos", "feoss", "wOS", " fOS", "feOS", "flose", "tos", " fo", " fot", "tOS", "wom", "flom", "lose"]}}
{"id1": "19549577", "id2": "1473212", "code1": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"callApiPost": ["callUapiDelete", "callAapiPut", "callAiPOST", "callUapiPost", "callApiDelete", "callUpiPost", "callActionsPut", "callUpiPut", "callAiDelete", "callActionsPost", "callUapiPut", "callUapiPOST", "callAapiPOST", "callAapiDelete", "callUpiDelete", "callAapiPost", "callApiPut", "callAiPost", "callUpiPOST", "callApiPOST", "callActionsDelete", "callActionsPOST", "callAiPut"], "apiUrl": ["piUrl", "apiName", "resourceURL", "apiUr", " apiUr", "resourceUr", "piUr", "baseUrl", "baseUr", "piURL", "baseURL", "apiPath", "apURL", "basePath", "piPath", "apUrl", "piName", "apPath", "resourceName", " apiName", "apUr", "apiURL", "resourceUrl", " apiURL"], "parameters": ["pperties", "paramParameters", "queters", "mParameters", "meters", "questParameters", "payants", "paramperties", "questperties", "paramants", "paramels", "paramions", "pParameters", "peters", "pions", "mions", "authorels", "authortons", "authoreters", "quels", "mperties", "paytons", "paramtons", "questeters", "authorants", "payels", "qutons", "payeters", "questions", "quants"], "expected": ["pected", "code", "test", "sex", "failed", "checked", " expectation", "error", "type", "allowed", "ped", "seen", "json", "count", "odd", " expect", "reported", "received", " expects", " unexpected", "safe", "e", "force", "actual", "example", "sent", "required", "size", "value", "future", "needed", "set", "encrypted", "posted", " expecting", "hello", "event", "default", "empty", "pect", "pects", "finished", "done", "foo", "current"], "url": ["http", "pl", "link", "l", "ll", "arl", "rl", "address", "q", "re", "hl", "base", "oul", "loc", "www", "f", "str", "ul", "abs", "mail", "ssl", "dl", "build", "ur", "nl", "bel", "mount", "https", "URL", "gl", "service", "gc", "loader", "impl", "log", "ml", "Url", "sl", "get", "r", "ls", "uri"], "request": ["access", "project", "record", "header", "reset", "q", "user", "req", "java", "reverse", "pull", "begin", "client", "pair", "setup", "enter", "connect", "release", "get", "reference", "change", "report", "parse", "web", "session", "memory", "store", "over", "friend", "open", "requ", "worker", "rate", "first", "version", "position", "resource", "require", "order", "object", "run", "buffer", "command", "socket", "xml", "question", "call", "re", "process", "response", "volume", "document", "quest", "remove", "register", "media", "send", "application", "search", "complete", "Request", "QUEST", "close", "forward", "initial", "message", "remote", "parent", "condition", "use", "create", "root", "accept", "name", "query", "exit"], "headerName": ["componentName", "attributename", "methodSpec", "profileSpec", "headingNAME", "authorname", "methodName", "headingHandle", "propertyNAME", " headerNAME", "authorName", "propertyname", "authorNAME", "componentNAME", "headingName", "headername", "methodLetter", "propertySet", "headerNAME", " headerFamily", "attributeNAME", "headingSpec", "methodHandle", "profileHandle", "attributeName", "headingLetter", "attributeSet", "headerLetter", "profileName", "headerSpec", "headerHandle", "componentFamily", "profileLetter", "authorSet", "headerFamily", "headingFamily", "propertyName", "headerSet"], "out": ["o", "n", "to", "print", "null", "in", "ex", "inner", "server", "flush", "res", "OUT", "timeout", "at", "os", "up", "table", "Out", "ou", "io", "writer", "aos", "client", "outer", "sys", "co", "write", "init", "comment", "check", "stream", "t", "s", "help", "log", "auto", "ent", "can", "set", "all", "console", "output", "outs", "tmp", "net", "pretty", "cn", "conv", "source"]}}
{"id1": "14598566", "id2": "22801734", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFileByNDIR", "copyFileByStandardII", "copyFileBynII", "copyFilebyNio", "copyFilebynIR", "copyFilebynII", "copyFileBynIR", "copyFileByNio", "copyFileByStandardIR", "copyFilebynIO", "copyFilebyNIR", "copyFileByNDio", "copyFilebyNIO", "copyFilebynio", "copyFileByNIR", "copyFileByStandardio", "copyFileBynIO", "copyFilebyNII", "copyFileByNII", "copyFileByNDIO", "copyFileByNDII", "copyFileByStandardIO", "copyFileBynio"], "in": ["o", "b", "IN", "l", "inc", "it", "cin", "ins", "el", "input", "mm", "ind", "vin", "rin", "up", "In", "is", "ar", "sql", "isin", "st", "old", "edIn", "gin", "from", "id", "as", "en", "inn", "on", "ic", "din", "i", "source"], "out": ["o", "b", "v", "n", "to", "null", "l", "it", "ex", "err", "oss", "OUT", "at", "os", "ou", "Out", "io", "str", "u", "ch", "serv", "ot", "check", "w", "t", "s", "log", "gt", "op", "g", "output", "outs", "po", "net", "ne", "nt"], "sourceChannel": [" sourcechannel", "seedCategory", "SourceConnection", "srcConnection", "sourceChan", " sourceChain", "SourceListener", "sourceButton", "srcListener", "sourceMessage", "srcChan", " sourceProvider", "parseCategory", "givenMessage", "srcMember", "ourceChan", " sourceMessage", " sourceConnection", "srcMessage", "sourceChain", "sourceCategory", "ourceChannel", "seedMember", "ourceConnection", "sourceConnection", "sourceProvider", "givenChannel", "parseMember", "parseButton", "parseChannel", "seedChannel", "Sourcechannel", "seedButton", "ourceListener", "sourcechannel", "sourceListener", "srcProvider", "sourceMember", "srcChannel", "SourceChannel", "ourcechannel", "givenListener", "srcCategory", "givenProvider", " sourceChan", "srcChain", "ourceChain", " sourceListener", "srcButton"], "destinationChannel": ["destationChannel", "destinationsConnection", "DestationChan", "destensionConnector", "destationConnection", "destinationConnection", "destationComponent", "DestinatorConnection", "destinatorChannel", " destationChan", "destinatedStream", "destinationClient", "DestinationConnection", "destinationConnector", "DestinatorClient", "destinatorClient", " destationConnection", " destinationConnection", "DestinationClient", "destinationStream", " destinationChan", " destinationComponent", "DestationConnector", "DestinationChannel", "destinatedChan", "destinationComponent", "destructionComponent", "destinationsChan", "destensionChannel", "DestinationConnector", "destructionChan", "destationConnector", "destensionChan", "destensionStream", " destationComponent", "destinatorConnection", "DestinatorChan", "DestationChannel", "DestinationStream", "destationChan", "destinationChan", "destationStream", "destructionConnection", "destinatedConnector", "DestinatorChannel", "destinatorChan", "DestinationChan", "destinationsComponent", "destensionConnection", "destinatedChannel", " destationChannel", "destinationsChannel", "destationClient", "destructionChannel", "destensionClient", "DestationStream"]}}
{"id1": "9647576", "id2": "8778962", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"Reserve": ["Servation", "Resolve", "Conserve", "reserve", "reservation", "Reservation", "Solve", "reserved", "Conservation", "resolve", "Serve", "Served", "Conserved", "Consolve", "Reserved"], "stbookings": ["Stbookings", "Stbooksies", "stbooksing", "Stbookers", "Stbooking", "stbindings", "stbooksings", "stbooking", "stbinding", "stbooksies", "Stbooksing", "Stbookies", "stbookers", "Stbooksers", "Stbooksings", "stbinders", "stbookies", "stBookers", "stBookies", "stbindies", "stBookings", "stBooking", "stbooksers"], "stchartwl": ["STchartwal", "STChartwal", "stchartbook", "stChartbook", "STChartwl", "stplotml", "stChartml", "stChartwal", "stchartml", "STChartbook", "stplotwal", "STchartbook", "stplotwl", "stChartwl", "STchartml", "stpagewl", "stchartwal", "stplotbook", "stpageml", "STChartml", "stpagebook", "stpagewal", "STchartwl"], "sp": ["osp", "pb", "sh", "yp", "pt", "ap", "sil", "esp", "space", "policy", "cp", "SP", "spr", "pe", "sy", "asp", " esp", "jp", "ss", "spe", "sk", "tp", "Sp", "sv", "vol", "lp", "scope", "so", "st", "isp", "sf", "service", "se", "sm", "bsp", "pp", "sw", "sc", "pol", "sb", " SP", "ps", "si", "p"], "userbooksql": ["userbookssql", "agentbookssql", "userbooksQL", "userbindql", "userooksql", "usertypesqs", "usertypessql", "userooksels", "userscriptsql", "userbookQL", "userbookql", "userpagesQL", "usertypesql", "userreadsql", "userscriptsels", "userBooksquer", "userreadsqs", "userbooksels", "userbooksSQL", "userbysquer", "userooksqs", "clientreadsqs", "userscriptselly", "userpagesqs", "userbindsql", "userbyssql", "userbindSQL", "userbookqs", " userbooksSQL", "userpagesql", " userbindsql", "userbysSQL", "clientbooksql", "userBookssql", " userbindquer", "userbookselly", "clientreadselly", "userpagessql", " userbooksquer", " userbindSQL", "agentpagessql", "userreadsels", "agentbooksqs", "userbindquer", "agentpagesqs", "userookselly", "userBooksSQL", "clientbooksqs", "agentpagesQL", "clientreadsels", " userbindql", "userbysql", "agentpagesql", "userBooksql", "clientbooksels", "clientreadsql", "clientbookselly", " userbookssql", "userbooksquer", "userscriptsqs", "userreadselly", "usertypesQL", "agentbooksQL", "userbooksqs"], "agentbooksql": ["agentbookquer", "agentbooksqu", "agentbookssql", "agentletsql", " agentBooksql", "ownerbeansquer", "agentletsquer", "agentletsqu", " agentbookili", " agentbookql", "agentBookssql", "agentBooksqu", "agentbeansili", "agentBooksql", "agentbookili", "agentiquesquer", "agentbookQL", "ownerbooksQL", "agentbeansQL", " agentBooksquer", "agentBooksili", "agentBooksQL", "agentbeansquer", "agentpagesili", "agentletssql", "ownerbeansQL", " agentBookssql", "agentiquesqu", "agentbooksili", "ownerbooksili", "agentiquesQL", " agentbooksqu", "agentiquessql", " agentbookQL", "agentbookql", " agentbooksquer", "ownerbeansili", " agentBooksqu", "ownerbooksql", " agentbookssql", "agentbeansql", "agentpagessql", " agentbooksQL", "agentiquesql", " agentbooksili", "agentpagesQL", "ownerbeansql", "agentpagesql", "ownerbooksquer", "agentbooksquer", "agentiquesili", "agentBooksquer", "agentbooksQL"], "bookingid": ["bookingingids", "bookillingID", "BookingID", "Bookingids", "bookingsID", "bookingsids", "bookingingid", "BookingsID", "bookingids", "bookillingids", "bookingingID", "Bookingid", "bookingsid", "Bookingsids", "Bookingsid", "bookingID", "bookillingid"], "currentcoach": ["currentlycoac", "currentCoarch", " currentcoACH", "currentlyCoech", "currentconac", "currentCoch", "currentCoACH", " currentcoch", "currentcalachable", "currentfoch", "currentlyCoch", " currentcoarch", "currentCOat", "currentCoachable", "currentcalech", "currentfoarch", "currentlycat", "currentfoACH", "currentcalch", "currentfoech", "currentcasp", "currentcoeACH", " currentfoach", "currentfoachable", "currentcoearch", "currentlycoch", "currentfoach", "currentcoac", "currentlycoech", "currentconasp", "currentcat", "currentcoasp", "currentCoach", "currentlycoach", "currentlycac", "currentcalach", "currentcac", "currentcoech", "currentcoarch", "currentconat", " currentfoarch", "currentCOach", "currentlycoasp", "currentlyCoach", "currentcoat", "currentCOac", "currentlyCoachable", "currentlycoachable", "currentlycach", "currentcoachable", "currentCOasp", "currentconach", "currentlycasp", " currentfoACH", "currentcach", " currentfoch", "currentcoch", "currentlycoat", "currentcoACH", "currentcoeach", "currentCoech"], "currentseat": ["reportedport", "currentslot", "currentlysen", "reportedseat", "Currentslot", "currentlysel", "currentsen", "reportedroute", "currentroute", "currentlyslot", "curseat", "currentsel", "Currentsen", "Currentsel", "currentlyseat", "currentport", " currentsel", " currentslot", " currentsen", " currentport", "reportedsel", "cursel", " currentroute", "curroute", "Currentseat", "curport"], "tickpos": ["tickpo", "stickpos", "rickPos", "snappo", "checkpo", "popPos", "ickpos", "popposition", "ickposition", "stickposition", "rickpos", " tickPos", "tickPos", "rickpo", "poppos", "poppo", "testpos", "stickPos", "stickprop", "quoteno", "quoteposition", "snapposition", " tickprop", "testPos", "checkPos", " tickno", "snapPos", "ickpo", "quotePos", "stickpo", "tickposition", "testpo", " tickposition", "checkpos", " tickpo", "snappos", "checkposition", "ickPos", "stickno", "quotepos", "rickprop", "testposition", "tickno", "tickprop"], "chartavailupdsql": ["chartavailupdsQL", "chartavailupdatesq", "chartavailupysQL", "chartavailupsdsq", "chartavailupyssql", "chartavailupdatessql", "chartavailupsdsQL", "chartavailupdssql", "chartavailupdq", "chartavailupsdatessql", "chartavailupsdatesql", "chartavailupdsq", "chartavailupsdatesq", "chartavailupdQL", "chartavailupdatesql", "chartavailupysq", "chartavailupysql", "chartavailupsdatesQL", "chartavailupsdssql", "chartavailupsdsql", "chartavailupdatesQL", "chartavailupdql"]}}
{"id1": "3330944", "id2": "3430784", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"extractImage": ["ExtprocessImage", "ExtractImages", "ExtprocessImages", "extprocessImages", "extlateFrame", "extractorFrame", "ExtractFrame", "extlateImage", "extlateImages", "Extractimage", "extlateimage", "extractimage", "extractorImage", "ExtprocessFrame", "Extprocessimage", "extractorimage", "extprocessimage", "extprocessFrame", "extprocessImage", "extractFrame", "extractorImages", "extractImages", "ExtractImage"], "input": ["ip", "partial", "raw", "null", "hidden", "it", "background", "xml", "address", "data", "q", "ins", "buffer", "index", "string", "audio", "uri", "seed", "image", "base", "accept", "Input", "prefix", "error", "str", "img", "rc", "qa", "context", "sample", "init", "upload", "txt", "request", "origin", "check", "url", "format", "file", "from", "local", "internal", "pattern", "start", "config", "query", "current", "initial", "hello", "empty", "tmp", "this", "path", "before", "out", "i", "text", "select", "p", "source"], "output": ["o", "generated", "to", "print", "hidden", "filename", "target", "OUT", "response", "image", "name", "prefix", "oe", "type", "icon", "write", "put", "port", "format", "file", "result", "success", "Output", "STDOUT", "OU", "path", "temp", "display", "out", "PUT", "pretty", "current", "source"], "params": ["m", "types", "images", "prop", "settings", "tags", "pkg", "members", "requires", "pins", "tools", "parts", "keys", "points", "proc", "ctx", "phi", "users", "options", "mm", "las", "devices", "param", "rs", "parents", "pro", "jp", "caps", "details", "fps", "properties", "ams", "photos", "json", "actions", "eps", "Parameters", "AMS", "Par", "phys", "pi", "ars", "par", "pas", "results", "names", "changes", "s", "packages", "modules", "config", "eters", "arms", "chains", "styles", "spec", "docs", "conf", "stats", "ims", "pps", "ps", "abilities", "ports", "pretty", "marks", "units", "gs", "terms", " parameters", "p"], "w": ["d", "m", "kw", "v", "n", "o", "rw", "ws", "h", "wp", "q", "wr", "wx", "window", "ew", "wo", "Writer", "wt", "writer", "nw", "f", "we", "wa", "wd", "write", "e", "wal", "word", "wl", "wb", "hw", "wh", "sw", "W", "Ws", "out", "p"], "in": ["inf", "raw", "null", "IN", "it", " IN", "al", "inner", "cin", "ins", "mm", "p", "vin", "one", "rin", "bin", "base", "name", "In", "ini", "is", "Input", "f", "ar", "sql", "isin", "phys", "e", "init", "con", "old", "copy", "ln", "mc", "ma", "win", "info", "edIn", "nin", "file", "gin", "from", "local", "include", "mi", "read", "id", "all", "en", "conf", "inn", "sin", "po", "path", "out", "din", "i", " din", "source"], "dest": ["to", "rest", "way", "comb", "csv", "prop", "cat", "ws", " dst", "dat", "data", "resp", "deg", "target", "desc", "tif", "dist", "des", "shape", "loc", "decl", "Dest", "oe", "end", "nom", "buf", "cont", "trans", "img", "usr", "mem", "src", "write", "save", "dir", "st", "alt", "pipe", "origin", "pas", "port", "opt", "result", "wb", "lit", "tmp", "path", "temp", "display", "out", " destination", "txt", "orig", "p", "source"], "bi": ["pb", "yi", "b", "isi", "bh", "bis", "gi", "bas", "rob", "bank", " nib", "iri", "phi", "ibe", "hog", "vi", "mu", "ble", "ali", "bin", "bone", "oi", "ki", "phy", "ini", "li", "bp", "fi", "obi", "bo", "pi", "ba", "beck", "bf", "BI", "abi", "buff", "bg", "bits", "ib", "bil", "be", "ai", "mi", "ni", "bie", "bra", "bb", "bc", "ibi", "umi", "obo", "bm", "Bi", "di", "jiang", "nb", "bs", "i", "ji", "qi", "zi"], "os": ["o", "css", "ks", "ose", "pos", "oid", "oss", "ops", "los", "oos", "cos", "us", "oses", "obs", "is", "io", "aos", "Os", "ows", "or", "sys", "mot", "ot", "OS", "ios", "ols", "cs", "ow", "ys", "acs", "s", "bos", "osi", "ts", "es", "fs", "oo", "ns", "bs", "oes", "ons", "ds", "et", "ls", "ox", "mos", "ros"]}}
{"id1": "11716816", "id2": "20375440", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"updateFile": ["updateSourceFile", "UpdateContent", "updatePage", "UpdatePage", "archiveSourceFile", "downloadFile", "updateContent", "archiveContent", "archivePage", "downloadSourceFile", "UpdateFile", "downloadContent", "UpdateSourceFile", "archiveFile", "downloadPage"], "file": ["entry", "report", "rule", "link", "null", "use", "source", "data", "full", "h", "filename", "input", "issue", "image", "base", "name", "table", "document", "io", "type", "attribute", "f", "ile", "channel", "fp", "e", "title", "info", "port", "le", "url", "resource", "t", "File", "format", "local", "handle", "log", "content", "get", "output", "db", "path", "message", "page", "FILE", "p", "line"], "IOException": ["OperationProblem", "SecurityError", " IOProblem", "OperationException", "SecurityProblem", " IOError", "SecurityException", "IOProblem", "OperationError", "IOError"], "destFile": ["DestPlace", " destEmail", " destinationDir", " destinationDo", "sourceFile", "DestPath", "DestFile", " destPlace", "destPath", " destPage", " destFolder", "declFile", "destile", " destile", "Destile", "sourcePath", "targetDir", "tempfile", "tempFile", " DestDir", " destinationFile", "destPlace", " destPath", "Destfile", " DestEmail", "destPage", "optFolder", "sourceDir", " destSourceFile", "declSourceFile", "DestFolder", "declFolder", "targetFile", "DestDir", "DestSourceFile", "destDir", "destSourceFile", "targetPath", "DestPage", "destFolder", "tempPath", "declile", "optPage", "optPlace", "tempDir", " destfile", "targetFolder", " DestFile", " DestDo", "sourceFolder", "optFile", "destDo", " destDir", "destfile", " destinationEmail", " destDo", "destEmail"], "in": ["inf", "m", "n", "raw", "ne", "oin", "IN", "l", "it", "inc", " IN", "al", "inner", "cin", "ins", "input", "mm", "re", "pass", "ind", "rin", "bin", "im", "up", "In", "inside", "io", "is", "ini", "f", "act", "isin", "init", "con", "info", "ln", "iter", "ai", "edIn", "gin", "s", "from", "local", "mi", "read", "all", "en", "ain", "inn", "r", "on", "sin", "ic", "net", "din", "i", "ie", " din"], "out": ["o", "b", "v", "n", "to", "null", "conn", "cache", "oss", "it", "ex", "flush", "chain", "cos", "obj", "no", "OUT", "at", "one", "msg", "os", "up", "jp", "Out", "io", "ou", "oe", "aos", "cmd", "client", "again", "fn", "or", "outer", "channel", "sys", "conv", "ch", "co", "write", "note", "ot", "con", "ion", "t", "s", "result", "log", "gt", "can", "en", " OUT", "g", "OU", "output", "outs", "net", "cn", "ne", "nt"]}}
{"id1": "1133123", "id2": "8024375", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"openConnection": [" openClient", "readConnection", "createClient", "openChannel", " openSession", "readChannel", "openClient", "readReader", "openLink", "newChannel", "newSession", "OpenReader", "OpenLink", "openReader", "createChannel", "createSession", "openSession", "createConnection", " openLink", "OpenConnection", " openChannel", " openReader", "newConnection", "newClient", "readLink", "OpenChannel"], "url": ["http", "b", "pl", "rect", "link", "web", "l", "ld", "ll", "rl", "xml", "address", "q", "string", "location", "base", "load", "name", "loc", "str", "ul", "mail", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "URL", "file", "log", "Url", "sl", "host", "path", "page", "util", "uri"]}}
{"id1": "17583193", "id2": "17337238", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"populateRecord": ["popupdateRec", "populatesData", "populatedrecord", "populateData", "populatesrecord", "popupdateData", "populatedData", "populaterecord", "populatedRec", " populateRec", " populatesrecord", " populatesRecord", " populaterecord", "popupdaterecord", "popupdateRecord", " populatesData", " populateData", "populatesRec", "populatesRecord", "populateRec", " populatesRec", "populatedRecord"], "attrIDs": ["addrids", "rmIDS", "aaaENTS", "attEMS", "sortids", "attrFS", "rmID", "attrFiles", "adjUES", "attributeID", "attIDS", "permFS", "attrById", "urgIDS", "cmpIDs", "attributeEMS", "attributeids", "arrIDs", "immIDS", "attributeIDS", "permIDS", "attributeLS", "attrID", "errIDs", "attFS", "attID", "attributeIDs", "sortFiles", "immEMS", "attributeById", "attrENTS", "urgIDs", "permID", "aaaIDs", "aaaLS", "cmpIDS", "attributeFS", "attById", "attrKids", "attributeENTS", "urgENTS", "attributeFiles", "adjIDs", "filterKids", "addrIDs", "attributeKids", "permIDs", "immID", "attrEMS", "attIDs", "adjIDS", "attrids", "rmIDs", "aaaIDS", "filterIDS", "errIDS", "filterids", "urgLS", "filterIDs", "sortIDS", "addrUES", "attrLS", "arrIDS", "sortKids", "attrUES", "addrIDS", "attrIDS", "attFiles", "arrids", "errUES", "immIDs", "sortID", "arrKids", "addrKids", "rmById"], "i": ["m", "ip", "print", "list", "in", "it", "ei", "q", "ir", "c", "y", "ini", "is", "io", "ity", "bi", "pi", "me", "init", "iter", "mi", "ix", "hi", "o", "n", "v", "h", "ik", "index", "im", "base", "ki", "ii", "any", "u", "eu", "ni", "ic", "I", "x", "xi", "z", "uri", "p", "ci", "ui", "l", "err", "ind", "\u0438", "ori", "iq", "iu", "f", "info", "ai", "sim", "iti", "di", "si", "ie", "zi", "parent", "d", "ij", "multi", "gi", "ami", "chain", "phi", "us", "status", "name", "li", "wi", "e", "cli", "er", "ri", "ia", "g", "ims", "my", "ti", "ji", "qi"], "sortIDs": ["SortLS", "servFiles", "relationensions", " sortIDES", "orderIDs", " sortensions", "sortBytes", "sortids", "attrIE", "parseIDs", "servensions", "attrFiles", "sortBs", "ordEMS", "saveKids", "ortID", "successKids", "ortIDS", "saveIDES", " sortID", "sortIDES", "ortBs", "sortMS", "sortIE", "filterBs", "servResults", "updateEMS", "successEMS", "syncBytes", "parseIDES", " sortEMS", "saveLS", "sortUES", "ortDetails", "attrID", " sortDocuments", " sortBytes", " sortResults", "parseIDS", "successIDs", "sortTags", "servBS", "SortIE", "orderUES", "filterDocuments", "altIDES", "sortResults", "ortBS", "sortVs", "updateIDS", " sortVs", "sortFiles", "saveResults", "servID", "altBytes", "saveMS", "altKids", "sortMembers", "servKids", "ortIDs", "sortDOS", " sortBs", "relationMembers", "relationIDs", "ortDocuments", "altIDs", "attrKids", "filterKids", "servEMS", "orderKids", "sortBS", "successTags", "servMembers", "parseKids", "filterIDES", "servVs", "successUES", "servIDs", "ortResults", " sortKids", "updateIDs", "successDOS", "successIDS", "attrEMS", "servIDS", "SortIDS", " sortMS", "orderDOS", "SortEMS", "shareIDs", "shareDOS", "attrids", "syncIDs", "ortVs", "saveIE", "relationIDS", "syncIDS", "filterIDS", "sortDetails", "sortLS", " sortFiles", "saveIDS", "syncEMS", "SortMembers", "sortEMS", "successIDES", " sortids", "shareKids", "ordids", "servTags", " sortDetails", "filterIDs", "altEMS", " sortMembers", "sortIDS", " sortBS", "attrLS", "attrMS", "SortIDs", "sortKids", " sortIDS", "attrIDS", "sortensions", "ortids", "shareUES", "sortDocuments", "saveIDs", "updateMembers", "sortID", "ordIDS", "altIDS", "servDetails", "servids", "ordIDs", " sortTags"], "j": ["d", "ij", "b", "v", "n", "bj", "m", "pr", "pt", "js", "err", "l", "it", "tr", "ja", "jo", "q", "k", "rel", "obj", "el", "ind", "c", "y", "jp", "kj", "by", "adj", "jj", "jump", "json", "jac", "jit", "other", "bo", "br", "e", "aj", "er", "beta", "next", "je", "dj", "jl", "uj", "jet", "ix", "job", "jc", "fr", "g", "r", "J", "out", "x", "oj", "ji", "z"], "temp": ["Temp", "fake", "thread", "test", "tty", "perm", "term", "prime", "template", "tem", "rem", "mod", "porary", "tm", " Temp", "EMP", "mem", "alt", "tim", "ptr", "cum", "wait", "t", "mp", "pre", "read", "tt", "unt", "set", " tmp", "emp", "current", "variable", "tmp", "length", "buffer", "tc", "txt", "orig"]}}
{"id1": "3187685", "id2": "14691829", "code1": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"copyJar": ["copyPath", " copyPath", " copyFile", " copyingFile", "CopyPath", "CopyFile", "copyFile", " copyingJar", " copyingPath", "CopyJar"], "src": ["syn", "usc", "js", "ctr", "rt", "rob", "sec", "ins", "input", "ser", "req", "rs", "rx", "iv", "ipl", "str", "cont", "img", "sys", "usr", "rc", "init", "st", "sn", "Source", "cur", "inst", "urg", "s", "from", "start", "sc", "stock", "sb", "dest", "sr", "sq", "source"], "dst": [" dlt", "Ddest", "ddst", "deskt", "dnd", "dddest", "Dkt", "Dlt", "ddnd", "desst", "ddct", "dedest", "dend", " dkt", "ddest", "dkt", "deslt", "Dct", "dect", "Dst", "dct", "desnd", "dlt", "Dnd", " dnd", "dest"], "srcChannel": ["stClass", "singChannel", " srcchannel", "singConnection", "sourceChan", "srcConnection", "srCategory", "serManager", "srcchannel", "srcClass", " srcClass", "srChan", " srcChain", "srcChan", "srManager", " srcManager", "sbchannel", "sbChannel", "serCategory", " srcChan", " srcContext", "serChannel", "rcChannel", "srcManager", "rcClass", "srChannel", "sourceChain", "rcCategory", "serChan", "srcContext", "sourceConnection", "singContext", " srcConnection", "rcContext", "rcConnection", "stChannel", "sourceChannel", "sbChan", "singCategory", "stchannel", "sourcechannel", "sbChain", "rcChain", " srcCategory", "stChan", "srcCategory", "rcChan", "srcChain", "rcchannel"], "dstChannel": ["dndWriter", "ddestchannel", " dotConnection", "dnetConnection", "dotButton", "dotManager", " dndWriter", "dmtchannel", "dstsConnection", "dnetButton", " dmtchannel", "dotChannel", "dstRow", " dstchannel", "dotConnection", "dstsChan", " dotchannel", "dndChan", "dndManager", "ddestRow", " dmtConnection", " dotChannel", "ddrChannel", "ddrchannel", "dnetChan", "dstManager", "dndchannel", "dnetchannel", " dstConnection", "dmtChannel", "dnetManager", " dnetChan", " dstChan", "dstsChannel", " dnetManager", "dndButton", " dstManager", "dndRow", " dmtChannel", "dmtConnection", "dotChan", "dstchannel", " dotChan", " dndRow", "ddrWriter", "dndConnection", "dstWriter", "dotchannel", "dstConnection", "ddrRow", " dstButton", " dstWriter", "dstButton", " dnetChannel", " dndChannel", " dnetButton", "dmtChan", " dmtChan", "dstChan", " dstRow", "dstschannel", "dndChannel", "ddestChannel", "dnetChannel", "ddestWriter", " dndchannel"]}}
{"id1": "18011804", "id2": "8932510", "code1": "    public FileChooserTestFrame() throws HeadlessException, MalformedURLException {\n        super();\n        addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent aEvent) {\n                System.exit(0);\n            }\n        });\n        Dimension dim = getToolkit().getScreenSize();\n        Rectangle abounds = getBounds();\n        setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2);\n        setVisible(true);\n        URL url = new URL(\"ftp://cendantstp/\");\n        char[] password = \"spnr\".toCharArray();\n        PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password);\n        FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication);\n        JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView);\n        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        fileChooser.setMultiSelectionEnabled(true);\n        File[] selectedFiles = null;\n        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {\n            selectedFiles = fileChooser.getSelectedFiles();\n            for (int i = 0; i < selectedFiles.length; i++) {\n                if (selectedFiles[i] instanceof FTPFileFile) {\n                    FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i];\n                    logger.fine(ftpFile.getName());\n                    logger.fine(ftpFile.getPath());\n                } else {\n                    logger.fine(selectedFiles[i].toString());\n                    logger.fine(selectedFiles[i].getAbsolutePath());\n                }\n            }\n        }\n        remoteFileSystemView.disconnect();\n        try {\n            if (null != selectedFiles) {\n                FTPClient ftpClient = new FTPClient();\n                InetAddress inetAddress = InetAddress.getByName(url.getHost());\n                ftpClient.connect(inetAddress);\n                if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                    throw new FTPBrowseException(ftpClient.getReplyString());\n                }\n                if (null != passwordAuthentication) {\n                    ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString());\n                }\n                for (int i = 0; i < selectedFiles.length; i++) {\n                    FTPFileFile file = (FTPFileFile) selectedFiles[i];\n                    logger.fine(file.getPath());\n                    FileOutputStream fos = new FileOutputStream(new File(\"d:/junk/ftp/test.txt\"));\n                    logger.fine(\"\" + ftpClient.retrieveFile(file.getPath().replaceAll(\"\\\\\\\\\", \"/\"), fos));\n                    fos.close();\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(0);\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"HeadlessException": ["HeadLessError", "Headlessception", "HeadlesslyError", "HeadLessception", "HeadlesslyException", "HeadlevelEvent", "HeadLessEvent", "HeadlevelException", " HeadlesslyEvent", "HeadlessError", "HeadlesslyEvent", "HeadlevelError", " HeadlessError", "HeadLessException", "Headlesslyception", " Headlessception", " HeadlesslyError", " Headlesslyception", "Headlevelception", "HeadlessEvent", " HeadlesslyException", " HeadlessEvent"], "MalformedURLException": ["MalformedURLExpression", "MalformedURLExption", "MalformedURLEexception", "MalformedURLAexception", "MalformedURLEssption", "MalformedURLEexption", "MalformedURLAxception", "MalformedURLExpption", "MalformedURLEssression", "MalformedURLEssception", "MalformedURLAxion", "MalformedURLAexption", "MalformedURLEexression", "MalformedURLExion", "MalformedURLAexression", "MalformedURLAexion", "MalformedURLAxption", "MalformedURLAxression", "MalformedURLExpion", "MalformedURLEexion", "MalformedURLEssion", "MalformedURLExression", "MalformedURLExpception"], "aEvent": [" oEvents", " anFolder", " anCommand", " aFolder", " aEvents", "iCommand", " aCommand", " anEvents", " oCommand", " anEvent", " oFolder", "iEvents", "iFolder", "iEvent", " oEvent"], "dim": ["d", "px", "ality", "sum", "iam", "mm", "dom", "dr", "im", "shape", "mod", "Rect", "vis", "details", "wid", "tm", "gm", " dimension", "Dim", "mem", "lim", "dem", "sam", "dir", "du", "div", "py", "size", "cam", " Dim", "ram", "sd", "dimension", "coord", "def", "spec", "region", "dm", "di", "ims", "mid", "db", "mb", "height"], "abounds": ["Abodies", "absounces", "rabensions", "abqs", "Abounds", "aporders", "aborders", "rabounds", "absounds", "rabounces", " abounces", "Abounding", "absorders", " ABounding", "bbles", "abbles", "borders", "abbqs", "bounds", "borts", "amborders", "apounds", "abensions", " abensions", "apbles", "absensions", "Abqs", "abbounds", "abbounding", "raborders", "amborts", "abounding", "abbodies", "ambbles", " ABqs", "abodies", " ABodies", "aports", "aborts", "ambounds", " aborders", " ABounds", "abounces"], "url": ["browser", "http", "link", "absolute", "l", "web", "socket", "ll", "usb", "html", "address", "server", "hub", "window", "location", "term", "parser", "base", "loc", "client", "www", "f", "localhost", "str", "abs", "mail", "ssl", "dl", "api", "ref", "connection", "ur", "nl", "u", "bel", "domain", "https", "URL", "resource", "Url", "sl", "github", "host", "r", "lr", "addr", "path", "ls", "uri"], "password": ["Password", "security", "shadow", "secret", "command", "words", "address", "session", "key", "hash", "reset", "user", "pass", "padding", "database", "directory", "username", "token", "sword", "login", "prefix", "description", "attribute", "random", "language", "definition", "phrase", "word", "crypt", "profile", "pattern", "power", "wordpress", "encrypted", "hello"], "passwordAuthentication": ["passwordCommunication", "passwordAuthenticating", "passwordAuthicator", " passwordAuthications", "passwordCommunications", "passwordAuthenticator", "passwordCommunicator", " passwordAuthicating", "passwordAuthification", " passwordAuthiction", "passwordauthentication", "passwordauthentiction", " passwordAuthentications", "passwordAuthication", "passwordAuthentiction", "passwordCommuniction", " passwordAuthentification", "passwordauthenticator", "passwordAuthiction", " passwordAuthentiction", "passwordAuthications", " passwordAuthenticator", "passwordAuthentification", "passwordCommunicating", " passwordAuthication", " passwordAuthicator", "passwordAuthicating", "passwordauthentications", " passwordAuthification", "passwordCommunification", "passwordauthentification", "passwordAuthentications", "passwordauthenticating", " passwordAuthenticating"], "remoteFileSystemView": ["remoteFilesystemview", "remoteFileTreeModel", "remotePlaceSystemDisplay", "remoteFileSystemContext", "remoteFileystemResponse", "remoteFileTreeview", "remoteFileystemDisplay", "remoteFileListResponse", "remoteFileListDisplay", "remoteFileSystemModel", "remoteFileSystemResponse", "remoteFileListContext", "remoteFileListView", "remoteFilesSystemContext", "remotePlaceSystemView", "remoteFilesystemResponse", "remoteFileTreeContext", "remoteFilesSystemModel", "remoteFileystemView", "remotePlaceSystemModel", "remoteFileListModel", "remoteFilesSystemView", "remoteFileTreeView", "remoteFilesSystemview", "remoteFileSystemview", "remoteFileListview", "remotePlaceSystemview", "remoteFilesystemView", "remoteFileSystemDisplay", "remoteFilesystemDisplay", "remoteFilesystemModel"], "fileChooser": ["resourceCompose", "fileSeressor", "fileCompressor", "fileSeorer", "fileSeicker", " fileChoer", "channelchooser", "fileClicker", "fileSelectose", "resourceChoer", "fileChoosen", "fileCompose", " fileSelecticker", " fileCompose", "fileSelectressor", " fileChosen", " fileSelectressor", "filechoorer", "fileSelectoder", "fileChicker", "channelChoicker", "fileChooder", "fileChoressor", "fileChoicker", " fileChicker", "fileClorer", "channelchoicker", " fileCompressor", "filechoicker", "fileClerer", " fileChose", "resourceChooser", "fileSeerer", " fileCompoder", " fileSelectoser", "fileComper", "fileChoerer", "resourceChoicker", " fileChoser", " fileChoosen", "fileChoer", "fileSeoser", " fileSelecter", "fileChosen", "fileChose", "filechoerer", "fileCompicker", "fileCloser", "fileComposer", " fileChoose", "fileSelecter", "fileSeoder", "fileChoose", "fileSeose", "channelChoorer", "fileChoorer", "channelchoerer", "resourceComposer", " fileChooder", "resourceComper", "fileSelectoser", "fileComposen", " fileComposer", "filechooser", "resourceChoose", "channelchoorer", "fileChoser", "channelChooser", "fileSelecticker", "channelChoerer", " fileChoressor", " fileChoicker", "fileCompoder", "resourceCompicker"], "selectedFiles": ["lectedBooks", "checkedItems", "selectedBooks", "printedOps", "electedFeatures", "identifiedBooks", " selectedfiles", "namedOps", "reviewedBooks", "linkedFiles", "coloredBytes", "selectedItems", "printedFiles", " selectedBooks", "coloredFiles", "lectedfiles", "reviewedFile", "printedFile", " selectedOps", "pressedItems", "selectedPhones", "linkedFile", "namedFile", "namedPhones", " selectedItems", "coloredThese", "lectedFiles", "verifiedFeatures", "identifiedFiles", "pressedBytes", "fetchedFiles", "selectedFile", "pressediles", "lectedResources", "namedFiles", "fetchedfiles", "reviewedFiles", "selectedThese", "selectedResources", "pickedBooks", "selectedfiles", "checkedfiles", "selectedOps", " selectedResources", " selectedFile", "selectediles", "selectedFeatures", "printedPhones", "electedFiles", "pressedThese", "fetchedBooks", "linkedResources", "electedItems", "fetchedThese", "fetchedBytes", "pressedBooks", "fetchedItems", "pickedFiles", "selectedThings", "lectedFile", "checkedFiles", "pressedFile", "pressedFiles", "coloredThings", "identifiedItems", "identifiedOps", "pressedOps", "verifiedBooks", "pickedItems", "checkedBooks", "linkedfiles", "pressedfiles", "pickedFeatures", "fetchedThings", "verifiedFiles", "electedBooks", "verifiedItems", " selectediles", "pressedPhones", "lectediles", "selectedBytes", "pressedThings", "lectedItems"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "batch", "print", "v", "err", "it", "in", "ex", "ei", "gi", "ji", "key", "ami", "chain", "phi", "us", "index", "mu", "status", "\u0438", "y", "ki", "sequence", "iq", "li", "is", "ii", "iu", "ini", "io", "bi", "pi", "u", "j", "x", "me", "init", "info", "cli", "ri", "ai", "sim", "t", "s", "mi", "ti", "hi", "ix", "exp", "id", "di", "my", "ic", "history", "I", "si", "xi", "qi", "uri"], "ftpFile": [" fttpFile", "ftPChain", "ftapiComment", "iftpFile", "ftpResource", "ftpiChain", "iftpFolder", "ftpaFile", "iftpAction", "ftpingfile", "ftrResource", "ftPAction", " fttpFILE", "ftpaAction", "ftpiFile", "ftpChat", " ftpChain", "ftpAction", "ftPFile", " ftpfile", "ftpingFILE", " ftpFILE", "fttpResource", "ftrFILE", "ftapiFile", "ftPComment", " ftPChat", "fttpFile", "fttpChain", "fttpChat", "iftapiAction", "ftpfile", " ftPfile", "ftPChat", " ftPFile", "iftapiFolder", "ftpaComment", "ftpingResource", "ftpaFolder", "iftpComment", " ftpChat", "ftapiFolder", "ftPfile", "ftapiAction", "iftapiComment", " fttpfile", "ftrFile", "fttpfile", "ftpFILE", "ftpingFile", "ftrfile", "ftpifile", "ftpComment", "iftapiFile", "ftpiChat", "ftpChain", " ftPChain", "fttpFILE", " ftpResource", "ftpFolder", "ftPFolder", " fttpResource"], "ftpClient": ["ftcConnection", "aftpProxy", "aftcpConnection", "fttpclient", " fttClient", "ftcpclient", "fttpClient", " ftpConnection", "fttClient", "fttServer", "ftpConnection", "fttpProxy", "ftcpClient", "ftcClient", "fttProxy", "aftpclient", " ftpServer", "ftpclient", "ftcpServer", "fttpConnection", "fttclient", "aftpClient", " ftpclient", "fttConnection", " fttServer", "ftpProxy", "aftcpClient", "ftcpConnection", " fttclient", "ftcpProxy", "ftpServer", " fttConnection", "aftcpclient", "aftcpProxy", "ftcclient", "ftcServer", "aftpConnection"], "inetAddress": ["netAdd", "inetAdd", "ptonAdd", "physHost", "physAddress", "physClient", "inetHost", "netaddress", "netAddress", "inetaddress", "physAdd", "etaddress", "networkAddress", "netClient", "networkAdd", "inetClient", "networkHost", "etAdd", "ptonAddress", "networkClient", "ptonaddress", "netHost", "etAddress"]}}
{"id1": "14390569", "id2": "18696387", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"title": ["summary", "theme", "html", "header", "TIT", "parts", "hd", "question", "filename", "hash", "label", "string", "padding", "term", "msg", "template", "tip", "name", "itle", "layout", "prefix", "description", "type", "lead", "password", "details", "notice", " Title", "subject", "Title", "setup", "size", "metadata", "t", "help", "start", "heading", "content", "message", "holiday", "text"], "imageURL": ["mediaID", "fileURL", "photoURI", "ImageURI", "imageURI", "ImageURL", "imageUrl", "fileUrl", "mediaURL", " imageUR", "imageUR", "imageString", "fileString", " imageUrl", "ImageID", "photoURL", "ImageUR", " imageURI", "fileURI", "ImageUrl", "imageID", "mediaUrl", "photoUR", " imageString", "photoID", "photoUrl", "mediaURI", "photoString"], "jd": ["simD", "ujD", "Jp", "simmd", "ujdt", "djc", "jjD", "simd", "djad", " jsd", "ajpd", "kd", "jobdo", " jdt", "qdo", "javapd", "jbd", "djsd", "simdt", "JD", "kdo", "zad", "djdo", "jdm", "kds", "Jbd", "gdo", "jpd", "qds", "jds", "djd", "ijds", "zsd", " jc", "jc", "jsdm", "jspd", "Jc", " jad", "jdo", "gbd", "Jmd", "jsD", " jD", "jmd", "Jd", "ijd", "javad", " jds", "gds", "ujd", "jsd", "ajds", "jjd", "qd", "qD", "kdt", "Jdt", "ujmd", "qbd", "Jds", "ijD", "gd", "jobd", "javads", "qp", "ajd", "ujad", "kbd", "Jdo", "jdt", "djds", "Jad", "jjbd", "zd", "ajdm", "javadm", " jdo", "jjp", "jsds", "jad", "jobdt", "jD"], "jl": ["syn", "ij", "bj", "js", " li", "rl", "ja", "elt", "dll", "bol", "li", "kj", "dyl", "jj", "jac", "il", "gn", "dl", "lv", "jin", "j", "lp", " ol", "nl", "lu", "txt", "Label", "ln", "dj", "uj", "abl", "jet", "yl", "kl", "jc", "kel", "jah", "ijk", "igl", "isl", "ibl", "elle", "J", "elly", "mil", "ji", "kn", "ell"], "icon": ["syn", " tip", "fa", " captcha", " intent", "eric", "conn", "ex", " lang", "label", "image", " screen", "addon", "fn", "Icon", " Icon", "chron", "iao", "icons", "cil", "ocon", " conn", "con", "font", "ion", "ico", " ion", "gc", "pic", "jc", " canvas", "iban", " ancestor", " fruit", "icol", "pen", "png", "ICO", " widget", "lock", "ic", "\u4e2d", "cn", "conv", "nic"], "chooser": ["poose", "boerer", " choicer", " chooder", "poicer", "choose", "Choose", "pooder", "choosen", "chooder", "composer", " choerer", "booser", "compicer", "CHOosen", "boose", " choosen", "CHOose", "compose", "choerer", "pooser", "Chooser", "boosen", "choicer", "Choosen", " choose", "CHOicer", "Choicer", "comperer", "composen", "CHOoser", "Chooder"], "jp": ["ij", "bj", "js", "np", " sip", "ja", " np", " gp", " je", " joint", "kj", "bp", " sp", " pic", "j", "jin", " cp", "sp", " mp", " ip", "JP", " dj", " ap", "btn", "pic", "jc", " pl", " ja", "p"], "jb": ["jbd", "Jb", "qbd", "kjcb", " jcb", "Jbd", "jcb", "qcb", "Jcb", "kjbd", "qb", "kjb", " jbd"], "e": ["d", "o", "m", "v", "n", "ed", "it", "re", "ee", "c", "f", "u", "er", "ev", "w", "t", "s", "te", "es", "E", "en", "g", "event", "Event", "a", "or", "ie", "p"], "returnVal": ["retVAL", " returnVol", "getVAL", "ReturnVal", "getVol", " returnVAL", "responseVol", "getValid", " returnValue", "retValue", "returnValid", "returnval", "responseVal", "Returnval", "returnVAL", " returnval", "returnValue", "responseValid", "ReturnVAL", "returnVol", "responseVAL", "getVal", "ReturnValue", " returnValid", "retVal", "retval"], "file": ["http", "report", "to", "rule", "link", "null", "fe", "create", "angle", "h", "body", "full", "filename", "target", "user", "image", "status", "base", "name", "table", "document", "open", "io", "type", "f", "ile", "core", "il", "channel", "fp", "class", "valid", "stat", "dir", "work", "real", "info", "word", "be", "port", "le", "resource", "handle", "File", "format", "local", "library", "fs", "model", "relation", "get", "run", "db", "path", "place", "page", "drop", "or", "buffer", "foo", "FILE", "tree", "source"], "fileName": [" fileSystem", "taskFace", "entitySet", "fileSet", "handlename", "FileNames", "imagePath", "fileExt", " filePath", "FILENames", "ileNAME", "filename", "FILEExt", "FILENAME", " fileNAME", "entityNAME", "taskPath", "fileFace", "FileExt", "FileSet", "fileNames", "fileClass", " fileExt", "FILESystem", "FileNAME", "FILESet", "fileNAME", "Filename", "FileSystem", "FILEName", "fileSystem", "entityPath", "entityName", "FileName", "ilename", "taskName", "FILEPath", "handleNAME", "FileFace", "FilePath", "ileClass", " fileNames", "ileName", "imagename", " filename", "taskname", "filePath", " fileClass", "imageFace", "handleClass", "imageNAME", "handleName", "imageName"], "ext": ["ex", "test", "desc", "EXT", "ind", "req", "exc", "aux", "external", "cmd", "pat", "ct", "end", "cont", "ag", "Ext", "enc", "lex", "xp", "dir", "off", "hex", "word", "sem", "t", "exp", "ix", "part", "xt", "cod", "def", "exe", "fr", "vert", "typ", "prot", "ec", "lib", "ord", "eur", "txt", "len"], "i": ["m", "ci", "ui", "print", "it", "ei", "gi", "phi", "index", "status", "ori", "y", "ini", "li", "ii", "iu", "is", "fi", "bi", "pi", "j", "init", "info", "cli", "ai", "ti", "mi", "hi", "id", "di", "I", "si", "xi", "qi"], "doIt": [" doWhich", " doIs", "didIs", "donIt", " doit", "waIt", "doHe", "donIT", "odoHe", "doit", "didYou", "doneIt", "doneit", "diIt", "doWhich", " doYou", "didit", "doYou", "waIs", "donit", "odoIT", "doIs", "donYou", "diit", "odoWhich", "odoIt", " doHe", "diHe", "didIt", "doneIT", "odoit", "doIT", " doIT", "donIs", "diWhich", "waIT"], "src": ["syn", "http", "comp", "rest", "sh", "ctr", "rl", "rt", "inner", "rob", "proc", "sec", "rel", "ins", "ser", "input", "lb", "rs", "rx", "loc", "rb", "ources", "trans", "cont", "ssl", "usr", "sys", "conv", "rc", "init", "st", "ource", "copy", "ptr", "https", "inst", "url", "crop", "from", "impl", "start", "sl", "sc", "sub", "sb", "tmp", "r", "sr", "gs", "sq", "source"], "dest": ["way", "rest", "comb", "gest", "cat", "cp", "dat", "proc", "target", "rel", "desc", "dist", "des", "loc", "decl", "Dest", "nw", "nom", "cont", "trans", "sys", "usr", "mem", "est", "sp", "dir", "st", "pipe", "origin", "iter", "pas", "https", "port", "slave", "local", "pot", "master", "can", "coord", "foreign", "output", "tmp", "temp", "out", "orig", "source"]}}
{"id1": "1133123", "id2": "23402240", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"openConnection": [" openClient", "readConnection", "createClient", "openChannel", " openSession", "readChannel", "openClient", "readReader", "openLink", "newChannel", "newSession", "OpenReader", "OpenLink", "openReader", "createChannel", "createSession", "openSession", "createConnection", " openLink", "OpenConnection", " openChannel", " openReader", "newConnection", "newClient", "readLink", "OpenChannel"], "url": ["http", "b", "pl", "rect", "link", "web", "l", "ld", "ll", "rl", "xml", "address", "q", "string", "location", "base", "load", "name", "loc", "str", "ul", "mail", "ssl", "dl", "ret", "ref", "build", "ur", "nl", "URL", "file", "log", "Url", "sl", "host", "path", "page", "util", "uri"]}}
{"id1": "20717531", "id2": "17522011", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["uncrypted", "Encipher", "decryption", "encrypted", "encipher", "uncrypt", "decrypted", "encryption", "Encryption", "uncipher", "Encrypt", "Encrypted", "decrypt", "decipher", "uncryption"], "plainText": ["cleanText", "tableConfig", "cleantext", "ainOutput", "realtext", "longtext", " plaintext", "ainName", "aintext", "hardtext", "publicData", "leadPath", " plainUrl", "formWord", "floatText", "publictext", "realSource", "plainData", "ainTEXT", "plainString", "cleanTEXT", "longString", "ainData", "ainUrl", "plainUrl", "longTextColor", "formTEXT", "hardTEXT", "leadText", "plaintext", "realTEXT", "hardWord", "ainTextColor", "plainConfig", "longText", " plainPath", "plainTEXT", " plainString", "tableUrl", "tableText", "ainPassword", "longSource", "ainWord", " plainName", "longTEXT", "ainText", "broadTEXT", "plainName", "broadText", "floatTEXT", "realText", "plainWord", "ainDelete", "leadtext", " plainOutput", "plainDelete", "publicOutput", "formtext", " plainSource", "tableTEXT", "publicText", "plainTextColor", "ainString", "floatDelete", "floatPassword", "formText", "broadDelete", "ainPath", "plainSource", "plainPassword", "cleanName", "hardText", "leadTEXT", "broadPassword", " plainTextColor", "ainConfig", " plainTEXT", " plainConfig", "plainOutput", " plainData", "plainPath"], "text": ["print", "struct", "cat", "sum", "math", "input", "ext", "ind", "image", "process", "template", "quick", "prefix", "TEXT", "writer", "ct", "end", "cont", "act", "write", "title", "comment", "ut", "word", "format", "t", "log", "start", "read", "tt", "tx", "all", "quote", "content", "binary", "view", "event", "output", "nt", "path", "left", "net", "message", "translation", "aut", "buffer", "Text", "txt", "select", "source"], "i": ["m", "ip", "print", "in", "it", "ei", "q", "y", "ini", "io", "is", "bi", "ity", "pi", "init", "iter", "t", "mi", "ix", "asi", "hi", "o", "v", "n", "index", "im", "oi", "ki", "ii", "gu", "u", "j", "eu", "ni", "id", "ic", "x", "I", "xi", "z", "p", "uri", "ci", "ui", "\u0438", "ori", "iu", "f", "ms", "ai", "sim", "di", "iy", "si", "zi", "yi", "multi", "gi", "ami", "chain", "phi", "us", "cgi", "uni", "li", "ski", "cli", "ri", "point", "g", "ims", "my", "ti", "ji", "qi"], "mDigest": ["mDigher", " mDher", "mDoher", " mDigester", "mHashum", "mMDse", " mDigested", "mDoested", " mDigse", "Mdiggest", "mdigher", "mdigse", "Mdiger", " mHashest", "mdigest", "mDigested", "mDester", "mDest", "mDiger", "mMacester", "mDigger", "mdigger", "MDigest", "mMacse", "mDigum", "mExecested", " mHashger", " mDigger", "mMDest", "mdigester", "mHashest", "MDiger", "mdigested", "mExecger", "MDigse", " mDigum", " mDest", "mdiggest", "mHashger", " mHashum", "MDiggest", "mMDer", "mDigester", "mExecest", "mFindgest", "mDiggest", "mdiger", " mDigher", "Mdigest", "mFinder", "mMDgest", " mDse", "mFindest", "mDse", " mDester", "mDose", "mExecum", "mMacest", " mDested", "mDher", "mDigse", "mFindse", " mHashested", "mDoest", "Mdigse", "mdigum", "mHashested", "mMacested", "mDested"], "d": ["m", "ed", "n", "b", "v", "done", "l", "cd", "md", "ld", "dat", "bd", " D", "h", "dict", "pd", "p", "dot", "c", "dc", "y", "da", "dd", "f", "dx", "df", "u", "j", "x", "nd", "e", "dh", "dec", "with", "w", "t", "s", "fd", "diff", "sd", "g", "di", "db", "r", "de", "a", "ds", "D"], "hash": ["report", "summary", "shadow", "print", "sh", "cache", "code", "ash", "her", "html", "tr", "header", "ssh", "key", "sum", "filter", "dict", "test", "h", "square", "href", "rh", "buffer", "total", "array", "checked", "table", "random", "Hash", "password", "flash", "style", "our", "ah", "save", "div", "dh", "hex", "block", "radius", "check", "search", "handle", "always", "oh", "id", "all", "hz", "message", "tag", "shift", "sha"]}}
{"id1": "10936821", "id2": "8135072", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 0, "substitutes": {"doIt": ["doWhat", "DoWhat", "doWhatever", " doThis", "makeWhatever", "makeWhat", "makeIt", "makeThis", " doWhatever", "doThis", "DoIt", " doWhat", "DoThis", "DoWhatever"], "client": ["http", "to", "cache", "conn", "simple", "web", "socket", "phone", "network", "key", "server", "dial", "call", "util", "Client", "response", "template", "quick", "secure", "wrapper", "open", "cmd", "google", "ct", "core", "cell", "channel", "api", "ssl", "connection", "co", "utils", "contact", "force", "con", "cli", "connect", "url", "resource", "local", "service", "pattern", "cloud", "close", "cl", "console", "cm", "lib", "pool", "net", "cc", "remote", "control", "parent"], "ff": ["aff", "FF", "alf", "tf", "tif", " fid", "fo", "uf", "fi", "ft", "cf", "dd", "xff", "df", "fp", "fc", "fg", "bf", "fm", "nd", "buff", "cb", "off", "sf", "af", "eff", "fd", "pp", "lf", "ph", "aft", "cl", "ef", "fact", "uff", "fx", "ck", "ffer"], "jfc": ["jpc", "nFC", "jvc", "flc", " jlc", "tFC", "jmc", "ncf", " jpc", " jvc", "Jpc", "jcf", "Jfc", "qFC", "tfc", "llc", " jmc", "tpc", "lvc", "jsFC", "npc", "jsfc", "Jcf", " jFC", "jspc", "Jmc", "fvc", "jFC", "tcf", "lfc", "jlc", " jcf", "qfc", "qcf", "qpc", "fcf", "JFC", "nfc", "jsmc", "lcf", "ffc"], "f": ["inf", "m", "v", "b", "fa", "l", "h", "tf", "fab", "only", "F", "xf", "c", "fo", "fi", "rf", "cf", "df", "fc", "fg", "bf", "e", "sf", "w", "file", "t", "fd", "fs", "lf", "ef", "g", "fx", "i", "p"], "selection": ["security", "finding", "which", "slot", "pling", "ing", "ification", " Selection", "ION", "reading", "location", " selecting", "icing", "elect", "state", "sea", "choice", "selected", "something", "election", "xxx", "wa", "connection", "sel", " selected", "where", "position", "binding", "search", "ion", "from", "soc", "lection", "opening", "focus", "SELECT", "select"], "msg": ["summary", "print", "mg", "md", "html", "pkg", "sum", "body", "resp", "desc", "doc", "wx", "mu", "gent", "notice", "cmd", "comm", "str", "mail", "gm", "sys", "mem", "ms", "bg", "Msg", "init", "comment", "cmp", "info", "og", "news", "irm", "task", "mn", "crit", "mk", "sm", "log", "nm", "map", "alg", "cfg", "g", "cal", "dm", "conf", "gr", "mb", "message", "sg", "mess", "ck", "gs", "txt"]}}
{"id1": "1362", "id2": "17856064", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubargeLess", "bubblesSort", "gobbleCompare", "bubblingLess", "gobblingSort", "gobbleSort", "gobblingCompare", "bubblingCompare", "bubargeSort", "bubblingSort", "bubargeCompare", "bubbleCompare", "bubbleLess", "bubblesLess", "gobblingLess", "gobbleLess", "bubblesCompare"], "a": ["o", "b", "v", "att", "cache", "aka", "ac", "ed", "list", "l", "aaa", "ap", "oa", "data", "alpha", "h", "isa", "el", "window", "na", "aa", "la", "array", "c", "arr", "area", "da", "eas", "trace", "apa", "form", "f", "ab", "aaaa", "sa", "act", "ata", "ma", "ao", "va", "go", "w", "ga", "changes", "am", "ia", "au", "t", "es", "an", "all", "as", "ae", "order", "g", "app", "era", "history", "out", "A", "ea", "z", "p"], "swapped": ["wapping", "scapped", "swapping", "stickaps", "Swaped", " swaps", "waps", "swaped", "snapping", "SWaped", " snap", "stickapped", "Swapping", " snapping", "SWap", "stickaped", " swapping", " snaped", "SWapping", "swaps", "wapped", " snapped", "SWapped", "snapped", "snaps", "stickapping", "waped", "Swap", "scaped", " swap", "Swapped", "scaps", "snaped", "swap", "scapping", " swaped"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "uli", "in", "it", "ji", "ei", "gi", "key", "ami", "chain", "iri", "phi", "us", "index", "ind", "status", "im", "base", "c", "ori", "y", "oi", "ki", "si", "ini", "li", "is", "ii", "io", "iu", "gu", "client", "xi", "f", "bi", "pi", "u", "j", "iso", "x", "me", "init", "origin", "cli", "zi", "ri", "ai", "sim", "t", "mi", "ti", "ix", "hi", "ir", "id", "di", "my", "ic", "I", "ie", "qi", "uri"], "tmp": ["comp", "m", "xy", "cache", "np", "pkg", "test", "perm", "ctx", "obj", "tf", "tg", "attr", "clip", "timeout", "amp", "prefix", "MP", "sup", "nom", "mut", "gm", "orig", "sam", "sp", "cmp", "td", "cur", "managed", "same", "t", "mp", "mk", "result", "pre", "etc", "tt", "emp", "db", "nb", "my", "temp", "lib", "txt", "sq"]}}
{"id1": "189963", "id2": "7006052", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewend", "readAndrewWrite", "readAndResend", "readAndrewrite", "readAndRepend", "readAndRewrites", "readAndResrites", "readAndRewWrite", "readAndRewend", "readAndRepWrite", "readAndResWrite", "readAndResrite", "readAndrewrites", "readAndReprites"], "inFile": ["infile", "InFilename", " inFilename", "docFilename", "inPlace", "outfile", "initFile", "INPlace", "iFILE", "inputFile", "inputPlace", "initFace", "inputFace", "iTime", "outFilename", "INFile", "Infile", "docTime", "InFile", "inFILE", "docFile", "initFilename", "iFilename", " infile", "inFace", "initPlace", "INFilename", "inTime", "inputFilename", "INTime", "inFilename", "iFile", "docFILE", "INFace", "INFILE"], "outFile": ["infile", "nameFILE", "checkFile", "outfile", "toFile", "checkFILE", "toFilename", "nameFilename", "checkfile", "toFILE", "checkFilename", "reportfile", "outFilename", " outFILE", "inFILE", "namefile", "reportFILE", "reportFilename", "tofile", " outfile", " outFilename", "outFILE", "reportFile", "nameFile", "inFilename"], "iis": ["diIs", "liis", "IIs", " iiss", "liris", "iIs", "iiss", " iIs", "iIS", "diis", "liisc", "diiss", "iiris", "eIs", "eIS", "Ii", "iiis", "ii", "liIs", " iIS", "eis", "dii", " iisc", " ii", "Iis", "aiis", "aiIs", "aiIS", "iiIs", " iris", "iiisc", "iris", "iisc", "Iiss"], "dcmParser": ["dcomParser", "dpmBuilder", " dpmPar", "dromParser", "dcommParser", "dfmBuilder", "dgrPar", "dcrparser", "DcmReader", "decmReader", "dmReader", " dpmAssistant", "deromReader", " dcmarser", "dcmStatement", "dcmReader", "dromReader", "dromparser", "dromListener", "dcmLoader", "dmmParser", "dpmLoader", "DpmPar", "dcommAssistant", "dmodulePrivate", "dmarser", "dmParser", "dcrParser", "DcmAdapter", "dcrBuilder", "DpmReader", "dcmPrivate", "dpmparser", " dpmReader", "DpmAdapter", "dmmmParser", "Dcmparser", "dpmStatement", "drumReader", " dpmPrivate", "dpcPrivate", " dpmBuilder", "dcmPar", "dfmLoader", "dgrStatement", "dcfStatement", "dmmmAdapter", " dcmLoader", "dpcParser", "DcmPar", "Dpmparser", "drumPar", "dcfReader", "dpmAdapter", " dpmListener", "dcomLoader", " dcmparser", "dgrReader", "DcmBuilder", "deromparser", "dpmAssistant", "deromParser", "drumParser", " dcmListener", "dpmarser", "decmParser", "drumBuilder", " dpmParser", "dmmarser", " dpmparser", "dcomReader", "dgrParser", "dcommReader", "dmoduleParser", " dpmStatement", "dpcReader", "deromarser", "dcmAssistant", " dcmPar", "dcommListener", "dpcAssistant", "dmoduleReader", "DpmBuilder", "dcmAdapter", "dcrReader", "dpmReader", "dfmReader", "dmmmReader", "decmarser", "dcomBuilder", "dpmPar", "dromAssistant", "dpmPrivate", " dcmBuilder", " dcmAssistant", "dpmParser", "dpmListener", "DcmParser", "dmmmparser", "dmoduleAssistant", "dcfPar", "dcmBuilder", " dcmPrivate", "decmparser", "dcmarser", "dmmparser", "dmparser", "dfmParser", " dcmStatement", "dromarser", "dcmListener", "DpmParser", " dpmarser", "dcmparser", " dcmReader", "dmmReader", " dpmLoader", "dcfParser", "dmmAdapter"], "ds": ["d", "ks", "sets", "js", "in", "ws", "DS", "services", "dat", "bd", "data", "pd", "Ds", "hd", "qs", "gd", "dq", "ins", "obs", "rs", "des", "os", "da", "ods", "ss", "hs", "details", "dd", "aos", "ads", "its", "der", "dx", "df", "vs", "sys", "dl", "eps", "sv", "dos", "ys", "dh", "cs", "uds", "eds", " DS", "drivers", "tes", "pers", "xs", "s", " des", "dds", "es", "fs", "sd", "as", "ims", "ps", "db", "outs", "dt", "bs", "ils", "ns", "gs", "ls"], "pdReader": ["tdReader", "ddLoader", "ddRunner", "xdLoader", "pedCar", "ddCar", "pedLoader", "tdParser", "pedReader", "hdWriter", "pdRead", "ddHelper", "pdCar", "pedRunner", "vdWriter", "pdParser", "vdLoader", "vdHelper", "dpLoader", "hdReader", "ddRead", "hdRead", "xdWriter", "ddReader", "vdReader", "dpRunner", "tdRead", "dpReader", "pdHelper", "pdLoader", "ddWriter", "dpCar", "ddParser", "hdParser", "tdWriter", "xdHelper", "pdRunner", "xdReader"], "out": ["cache", "list", "null", "in", "it", "data", "full", "ins", "desc", "msg", "c", "io", "client", "end", "sys", "we", "serv", "con", "go", "w", "t", "gr", "tmp", "o", "n", "to", "raw", "v", "pos", "ex", "inner", "flush", "at", "os", "over", "up", "Out", "cmd", "aos", " err", "cb", "ent", "sw", "id", "output", "pool", "p", "nt", "screen", "conn", "js", "oss", "err", "sum", "OUT", "one", "writer", "str", "ch", "nr", "opt", "s", "all", "en", "outs", "on", "gen", "obj", "inv", "res", "status", "name", "ou", "outer", "co", "log", "auto", "gt", "inter", "cfg", "net", "cn", "conv", "txt"], "dcmEncParam": ["dcmEscNum", "dcmencParam", "dmmencParam", "dcmDecCmd", "dcmEncPar", "dmmEncMsg", "dmmEncPar", "dcmencPar", "dcmencCmd", "dmmencNum", "dcmEncVal", "dmmEncParam", "dmmEncCmd", "dcmEscPar", "dcmEscVal", "dcmEnNum", "dmmEnPar", "dcmDecMsg", "dcmEncNum", "dcmEncCmd", "dmmEnNum", "dcmencMsg", "dmmencCmd", "dcmDecNum", "dcmEnVal", "dcmEnParam", "dcmEncMsg", "dmmencMsg", "dcmEscParam", "dcmencNum", "dmmEncNum", "dmmEnParam", "dmmEncVal", "dcmDecParam", "dcmEnPar"], "pdWriter": ["pdwriter", "dpWrite", "tdWriting", "pcWriting", "PDWriter", "pcwriter", "pidWriting", "pdWrite", "pdWriting", "PDReader", "PDWrite", "pdEditor", "tdWrite", "PDEditor", "tdwriter", "pidwriter", "pcWrite", "pidWriter", "pcWriter", "dpReader", "pidWrite", "dpEditor", "tdWriter", "tdReader", "tdEditor", "dpWriter"]}}
{"id1": "8385785", "id2": "14038176", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"MD5": ["MDHash", "SHA2", " md2", " MD3", " md5", "MD2", "MD3", "SHAHash", " mdHash", " md3", " MDHash", " MD2", "SHA3", "SHA5"], "text": ["code", "print", "command", "pt", "source", "aut", "data", "test", "q", "input", "string", "term", "ext", "msg", "name", "document", "prefix", "TEXT", "password", "form", "ct", "str", "subject", "act", "context", "title", "comment", "word", "now", "url", "value", "t", "format", "pattern", "log", "read", "tx", "content", "event", "output", "message", "path", "translation", "out", "x", "buffer", "Text", "txt", "select", "nt"], "UnsupportedEncodingException": ["UnsupportedDecodingError", "UnsupportedDecodingEx", "UnsupportedEncode ", "UnsupportedEncoderException", "UnsupportedEncodedException", "UnsupportedEncodeEx", "UnsupportedDecoding ", "UnsupportedEncoder ", "UnsupportedEncodeError", "UnsupportedEncodingError", "UnsupportedEncodingEx", "UnsupportedDecoder ", "UnsupportedEncoderEx", "UnsupportedDecoderException", "UnsupportedEncodedEx", "UnsupportedEncodeException", "UnsupportedEncoding ", "UnsupportedEncodedError", "UnsupportedDecoderEx", "UnsupportedDecoderError", "UnsupportedEncoderError", "UnsupportedDecodingException", "UnsupportedEncoded "], "md": ["d", "m", "mg", " cmd", "ad", "ld", "pt", "ctr", "mand", "pkg", "bd", " de", "pd", "h", "hd", "hash", " ok", "MD", "grad", "mm", " mk", "Cmd", " done", " man", "dr", "det", " med", " sch", "ind", "od", "mod", " doc", "cmd", "dd", "mond", "red", "der", "df", "mail", "ms", "nd", " rand", "dig", "dir", " ind", "mt", " img", "mn", "add", "rm", "mp", "mk", "sd", " def", " dist", "deep", "dm", " df", "di", " cd", "mb", " exec", " del"], "md5hash": ["md4hex", "md2Hash", "md5hex", "md4index", " md5hex", "md4hash", "md4Hash", "md5index", "MD5sum", "md512hex", " md5sum", "md7Hash", "md5sum", " md4key", "md4key", " md5Hash", "md7hash", "md5key", "md7sum", " md3Hash", " md5h", "MD2hash", "MD2Hash", "md2hash", "md512key", "MD5Hash", "md5h", "md3h", "md3hash", "md7h", " md3hash", " md4hex", "md5Hash", "MD2sum", "md512index", "md4sum", "md3sum", "MD2h", " md4hash", "MD5h", "md512hash", "md2sum", "md4h", "md2h", " md3h", " md5key", "md3key", "md3Hash", " md5index", "MD5hash", " md3sum", " md4index", "md3hex", "md3index"]}}
{"id1": "6988216", "id2": "23677147", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"testSimpleQuery": [" testSimpleQuestion", " executeBasicQ", " executeSimpleContent", " testRawQuestion", " testQueryQuestion", " testRawQ", " testSimpleContent", " executeBasicQuery", " executeSimpleQ", " testRawContent", " testQueryQuery", " executeSimpleQuestion", " testQueryContent", " testBasicContent", " testQueryQ", " testRawQuery", " testBasicQuestion", " executeBasicContent", " testSimpleQ", " testBasicQ", " executeSimpleQuery", " testBasicQuery", " executeBasicQuestion"], "dummySource": ["daatumSource", "dumpStore", "datalFile", "determinedParent", "dummyStore", "determinedFile", " duffyInput", "dumpSource", "duffyContent", "datumSource", "dancySource", "daummyInput", "dummyInput", "datalParent", " duffySourceFile", "dumpResource", "daatumInput", "dummSource", "dummyResource", "udummySource", "dancyContent", " dummySourceFile", "duffySourceFile", "dancyFile", "udummyContent", "determinedContent", "datalSource", "dummySourceFile", "dummiesStore", "dancyParent", "udeterminedContent", "udeterminedSource", "dummyParent", "udeterminedFile", "determinedSource", "dumpInput", " duffySource", "datalContent", " dummyInput", "dummiesSource", "udummyParent", "dummContent", "dummSourceFile", "daummyStore", "udummyFile", "daatumResource", "datumResource", "udeterminedParent", "datumInput", "daummyResource", "dancyInput", "duffyInput", "dancySourceFile", "daatumStore", "dummiesInput", "datumStore", "duffySource", "dummInput", "dummyFile", " duffyContent", "daummySource", "dummiesResource"], "os": ["o", "css", "ose", "dis", "ui", "pos", "conn", "js", "oss", "socket", "ops", "los", "oa", "oos", "cos", "oses", "obs", "oS", "ori", "des", "io", "is", "aos", "Os", "ens", "ows", "or", "sys", "et", "asis", "ants", "ms", "dos", "ot", "ols", "ios", "OS", "ys", "windows", "s", "bos", "osi", "ts", "om", "fs", "ost", "ats", "es", "ors", "oids", "ims", "uts", "bs", "out", "ds", "si", "oes", "ox", "mos", "ros"], "dummyContent": ["dumpingContent", "dummiesTemplate", "deltaInt", "DumpText", "dummyContents", "dynamicContents", " dummiesContents", "dummyText", "DummyInt", "dumpMedia", "DumpContent", " dummiesTemplate", "dumpingTemplate", "determinedMedia", "DumpInt", "DummyContent", "dummyInt", "determinedContent", "dummyMedia", "determinedText", "dummyCode", "dumpInt", " dummyContents", "DummyText", "determinedInt", "dynamicTemplate", "dumpingCode", "dynamicContent", "dumpingContents", "dumpContent", "deltaContent", "dummyTemplate", "dummiesContents", " dummyCode", "dummiesContent", " dummiesContent", " dummyTemplate", "deltaMedia", "dummiesCode", "DummyMedia", " dummiesCode", "dumpText", "dynamicCode", "DumpMedia", "deltaText"], "source": ["in", "use", "space", "inner", "server", "SOURCE", "site", "user", "ser", "instance", "store", "seed", "image", "status", "template", "table", "google", "ie", "core", "sys", "sql", "src", "scope", "sample", "sp", "ource", "ace", "Source", "sf", "proxy", "search", "resource", "from", "series", "service", "se", "s", "result", "relation", "spec", "sin", "pse", "sr", "join", "uri"], "content": ["summary", "cache", "code", "command", "html", "header", "node", "data", "xml", "key", "body", "ext", "expression", "response", "activity", "status", "template", "editor", "document", "layout", "quest", "sequence", "license", "description", "Content", "cont", "json", " contents", "context", "application", "script", "title", "section", "comment", "example", "version", "txt", "value", "format", "ontent", "resource", "result", "config", "tx", "article", "output", "message", "path", "action", "text", "current", "tree"], "qResult": ["queryResult", "queryReport", "qReport", "QRes", "qresult", "queryResponse", "dqRes", "iqResult", "dqResult", "dqView", " qResults", "iqResponse", "qResponse", "queryRes", "iqResults", " qresult", "iqReport", "dqresult", "qResults", "qRes", "iqRes", "queryResults", "Qresult", " qRes", " qResponse", " qReport", "QResult", "QView", " qView", "qView"], "results": ["reports", "ults", "objects", "forms", "ries", "orders", "settings", "blocks", "members", "times", "data", "missions", "users", "ULTS", "res", "views", "posts", "features", "roads", "assets", "details", " Results", "xes", "lections", "its", "runs", "tests", "RESULTS", "photos", "Contents", "actions", "thumbnails", "terms", "ms", "resources", "events", "Results", "s", "versions", "relations", "result", "items", "ands", "hips", "chains", "olds", "archives", "values", "pages", "children", "rows", "products"], "it": ["m", "ip", "v", "ci", "in", "MIT", "rit", "hit", "h", "IT", "pit", "at", "It", "exec", "is", "li", "its", "ul", "iz", "stat", "init", "st", "info", "he", "iter", "ite", "t", "mit", "read", "id", "lit", "op", "they", "ait", "ic", "out", "i", "et", "p"], "rSrc": [" rSsrc", "rSlrc", "rSRC", "rDesRC", "rSlrs", "rSyssrc", "rSourcerc", "crDesrs", "rSysRC", "crDessrc", "crSrc", "crDesRC", "rSeRC", "rSlcs", " rSource", "rSecs", "rSrs", "rSource", " rScs", "crDesrc", "rSlRC", " rSRC", "rSerc", "rDesrc", "rSysource", "rSourcers", "crSsrc", "rSysrc", "crSRC", "crSrs", "rSourcesrc", "rDesrs", "rScs", "rDessrc", "rSsrc", "rSers", " rSrs", "rSourceRC"], "rSrcIn": ["rSncCon", "rSetsrcin", "rSrsIn", "rSetrcIN", "rSRCCon", "rSrsIN", "rSrcCon", "rSetrcIn", "rSrcOut", "rSncIn", "rSncin", "rSldIn", "rSldOut", "rSldin", "rSldIN", "rSetrcOut", "rSrsInput", "rSetrcin", "rSsrcin", "rSetsrcIn", "rSetsrcIN", "rSRCIN", "rSRCOut", "rSsrcOut", "rSRCIn", "rSldInput", "rSsrcIn", "rSsrcIN", "rSrcIN", "rSRCin", "rSrcin", "rSetsrcOut", "rSsrcInput", "rSncOut", "rSldCon", "rSrcInput", "rSrsOut"], "actualOut": ["realOut", "finalOut", "UALOut", "ualEnd", "actualCopy", "realIn", "actualIs", " actualCopy", "finalout", "actualIn", " actualIn", "actualBytes", "ualBytes", " actualBytes", " actualEnd", "virtualOut", "actuallyCopy", "realCopy", "UALIn", "actuallyOut", "actuallyIn", "UALEnd", " actualout", "actuallyIs", "realIs", "ualout", " actualIs", "virtualIn", "actualout", "ualOut", "ualIn", "UALBytes", "actualEnd", "finalIn"]}}
{"id1": "6190356", "id2": "14053882", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldMBHash", " hashPasswordForoldMD5", " hashPasswordForOldMB4", " hashPasswordForOldSHA4", " hashPasswordForOldMD4", " hashPasswordForoldMD1", " hashPasswordForoldMD4", " hashPasswordForOldSHA1", " hashPasswordForOldMB1", " hashPasswordForOldMDHash", " hashPasswordForOldSHAHash", " hashPasswordForoldMDHash", " hashPasswordForOldMB5", " hashPasswordForOldMD1", " hashPasswordForOldSHA5"], "password": ["Password", "entry", "raw", "shadow", "secret", "command", "words", "data", "address", "reset", "hash", "user", "pass", "input", "string", "padding", "database", "username", "token", "sword", "login", "name", "prefix", "description", "attribute", "wd", "phrase", "word", "value", "pattern", "wordpress", "default", "message", "text", "p"], "md": ["d", "m", "cd", "ld", " Md", "mand", "mode", "bd", "pd", "hd", "grad", "MD", "mm", "det", "od", "dr", "ind", "pm", "mod", "down", "cmd", "dd", " MD", "ct", "red", "der", "df", "pdf", "ms", "dir", "dig", "cmp", "and", "dh", "mt", "mc", "mn", "add", "mk", "sm", "del", "sd", "deep", "dm", "di", "mb", "de", "ds", "sha"], "messageDigest": ["messageWithest", "messagedigear", "Messagedigester", "Messagedigest", "messageDigester", "messageDigse", "messageDatatest", "messageDesignist", "messagedigse", "MessageDigist", "messagedigested", "MessageDigest", "MessageDigse", "messageWithse", "messageDigtest", "MessagedigEST", "messagedigest", "messagedigEST", "messagedigester", "messageWithear", "messageDataester", "messageDesignested", " messagedigested", " messagedigest", " messageDigEST", "messageDesignest", " messagedigist", "messageDigested", "messageDriear", "messageDigear", "MessageDigester", "MessageDigEST", "messageDataEST", "MessageDigtest", "Messagedigse", "messageDriist", "messageDataest", " messageDigested", "messageDigitalest", "messageDigitalested", "messageDigEST", "messageDrise", "messageDigitalist", " messagedigEST", " messageDigist", "messageDesignEST", "messageDriest", "Messagedigear", "messagedigtest", "messagedigist", "messageWithist", "Messagedigist", "messageDigitalEST", "Messagedigtest", "MessageDigear", "messageDigist"], "hexString": ["phpStr", " hexStr", "exString", "hexSingle", " hexSet", "octResponse", "exSingle", " hexSite", "phpSingle", " hexArray", " HexSite", "colorBuffer", "octArray", "phpSite", " hexSingle", "colorStr", " hexBuffer", "phpString", "hexArray", " HexString", " HexArray", " Hexstring", " hexChain", "hexBuffer", "exBuffer", " hexResponse", "phpRest", "hexstring", "octstring", " HexStr", "hexSet", " HexSet", "colorString", "phpChain", "hexSite", " hexstring", " HexResponse", "octString", "phpBuffer", " HexRest", "hexChain", " HexBuffer", "hexRest", "hexStr", " HexChain", "exStr", " hexRest", "colorSet", "hexResponse"], "i": ["m", "multi", "ip", "n", "ci", "ui", "yi", "ij", "o", "in", "it", "ji", "gi", "key", "I", "q", "chain", "phi", "loop", "uri", "index", "ind", "im", "c", "y", "ini", "li", "is", "gu", "ski", "ii", "bi", "u", "pi", "j", "conv", "e", "init", "ai", "sim", "t", "z", "mi", "ti", "ix", "hi", "id", "set", "g", "di", "my", "a", "ic", "x", "si", "ie", "qi", "zi"], "hex": ["comp", "raw", "sh", "print", "prop", "tex", "ex", "rex", "html", "serial", "it", "full", "oct", "h", "rendered", "sex", "pex", "hl", "ext", "xf", "alph", "cf", "form", "php", "red", "imal", "flash", "json", " Hex", "cont", "row", "mix", "sv", "percent", "br", "none", "check", "com", "dump", "exp", "hi", "ph", "tx", "def", "lit", "solid", "hello", "zip", "prof", "x", "EX"]}}
{"id1": "23510383", "id2": "5632808", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"saveProject": ["createPackage", " saveFile", "saveFile", "saveApp", "savePackage", " SaveFile", "createApp", " saveApp", " savePackage", " SaveProject", " SavePackage", " SaveApp", "createFile", "createProject"], "file": ["report", "link", "project", "use", "in", "create", "data", "full", "filename", "image", "base", "table", "open", "io", "ile", "files", "e", "ame", "dir", "info", "real", "port", "File", "resource", "local", "handle", "log", "complete", "id", "get", "db", "path", "foo", "FILE", "parent"], "types": ["strings", "objects", "otypes", "apps", "sets", "classes", "tags", "sites", "times", "services", "keys", "parts", "pes", "views", "options", "posts", " Types", "features", "ids", "assets", "tests", "issues", "actions", "thumbnails", "packs", "files", "resources", "ypes", "names", "scripts", "plugins", "versions", "events", "ties", "ts", "packages", "items", "groups", "models", "codes", "Types", "styles", "projects", "values", "ports", "pages"], "images": ["frames", "classes", "tags", "blocks", "uploads", "views", "image", "links", "assets", "Image", "media", "photos", "boxes", "thumbnails", "icons", "files", "Images", "videos", "scripts", "events", "versions", "groups", "models", "styles", "picture", "faces", "pages"], "trajectories": ["traceptors", "Trajectors", "Trajables", "trajectables", "traceptory", "trajors", "Trajories", "tractories", "Trajectories", "trajables", "tractors", "trajories", "Trajors", "trajectory", "trajectors", "Trajectables", "traceptories", "Trajectory", "traceptables", "tractory", "trajory", "tractables", "Trajory"], "databasesIncluded": ["datadesInsjected", "databasesInsclusion", "databasesInified", "datadesInclusion", "datadesInified", "databasesINclusion", "databasesInjected", "databasesedInified", "databasesInsclusions", "databasesInclusions", "daturesInclusions", "databasesIngcluded", "daturesIncluded", "databasesedInjected", "datadesInsclusion", "databasesInlisted", "daturesInsclusions", "databasesInslisted", "datadesInscluded", "datadesIncluded", "daturesInslisted", "databasesedInclusion", "databasesINcluded", "databasesInsified", "databasesInclusion", "databasesedInclusions", "datadesInsified", "databasesInscluded", "databasesINjected", "daturesInlisted", "daturesInscluded", "databasesedIncluded", "datadesInjected", "databasesInsjected", "databasesIngclusions", "databasesedInlisted", "databasesInglisted", "databasesINified"], "onlyLinks": [" onlylinks", "onlyLink", " onlyLink", "forceLink", "alsoRelations", "forceLinks", "Onlylinks", "onlylinks", "onlyRelations", "OnlyLink", " onlyRelations", "alsoLinks", "OnlyLinks", "forcelinks", "OnlyRelations", "alsoLink"], "index": ["n", "zero", "pos", "inc", "ex", "num", "Index", "amount", "address", "second", "no", "ind", "loc", "sequence", "open", "end", "number", "offset", "first", "nn", "info", "position", "check", "ion", "connect", "add", "max", "length", "set", "update", "all", "match", "find", "initial", " Index", "fail", "x", "i", " sidx"], "name": ["man", "m", "n", "named", "create", "Name", "NAME", "full", "data", "filename", "root", "system", "string", "image", "about", "base", "table", "prefix", "ame", "me", "title", "none", "word", "primary", "names", "local", "nm", "id", "default", "run", "path", "parent"], "format": ["v", "scale", "print", "parse", "list", "Format", "it", "use", "data", "MAT", "term", "base", " Format", "table", "layout", "prefix", "language", "form", "style", "unit", "percent", "fm", "init", "color", "mt", "value", "printf", "pattern", "set", "get", "cal", "default", "pretty", "util"], "count": ["code", "err", "num", "skip", "amount", "sum", "reset", "found", "flag", "total", "process", "c", "table", "error", "Count", "size", "counter", "add", "depth", "start", "ount", "set", "order", "mark", "length", "z"], "version": ["tree", "v", "summary", "record", "header", "xml", "server", "Version", "virtual", "VER", "major", "root", "journal", "VERSION", "information", "database", "video", "about", "java", "document", "description", "latest", "vers", "ver", "number", "json", "connection", "draft", "build", "j", "parent", "section", "mint", "versions", "result", "release", "alone", "translation", "page", "current", "python"], "writer": ["browser", "report", "entry", "to", "access", "print", "walker", "operator", "data", "inner", "writing", "function", "flush", "server", "wright", "window", "reader", "journal", "editor", "maker", "Writer", "document", "builder", "wrapper", "description", "handler", "external", "language", "client", "author", "outer", "connection", "caster", "write", "writ", "comment", "writers", "er", "counter", "stream", "w", "written", "driver", "iterator", "service", "creator", "sw", "wrote", "console", "variable", "order", "output", "woman", "buffer"], "xmlDir": ["mlFile", "logdir", "xmldir", "xmlFile", "logDir", "mlDirectory", " xmlDirectory", "imageFolder", "imageDir", "xmlFolder", "logDirectory", "xmlDirectory", " xmlFolder", "imagedir", " xmlFile", " xmldir", "logFolder", "mlDir", "imageDirectory", "mlFolder", "logFile"], "databases": [" datables", "Databases", " datas", "generabases", " datasha", "generabase", "baselines", "Datas", "database", "notures", "Datates", "basabases", "datasha", "generas", "mutabases", "Datures", "mutases", "datures", "mutables", "datables", " datates", "notelines", "Datables", "generates", "datases", "notables", "notabases", "Datasha", "basures", "datates", "Datases", "basables", "Datelines", " database", "datas", "mutasha", " datases", "Database", "datelines"], "t": ["o", "v", "n", "pt", "it", "tr", "h", "k", "q", "term", "template", "c", "y", "ct", "str", "tm", "j", "T", "e", "ot", "mt", "w", "te", "s", "ts", "tt", "id", "typ", "temp", "x", "i", "tc", "txt", "p"], "type": ["ping", "to", "rule", "parse", "link", "null", "time", "key", "address", "test", "site", "pe", "root", "template", "ype", "base", "Type", "shape", "y", "error", "language", "TYPE", "ver", "style", "top", "class", "other", "unit", "ime", "title", "module", "info", "single", "check", "resource", "te", "result", "config", "id", "match", "relation", "object", "kind", "tool", "typ", "ty", "role", "tag", "this", "action", "instance", "p"], "currentName": ["currentLock", "updateFace", "currentlyTime", "currentlyPath", "updateName", "baseName", "reportedDir", "CurrentPath", "updatePort", "currentParent", "currentlyName", "thisKey", " currentFace", "updateOrder", "currentDir", "currentlyKey", "reportedParent", "currentlyYear", "currentOrder", "CurrentLock", "currentSet", "basePort", "completeYear", "currentlySet", "reportedLock", "currentKey", " currentNames", "currentNames", "CurrentParent", "currentYear", " currentPort", " currentOrder", " currentDir", "CurrentName", "currentlyLock", "completeSet", "thisName", "reportedTime", "currentFace", "baseFace", "completeKey", "baseOrder", "reportedPath", "completeName", " currentParent", "thisYear", "currentTime", "reportedName", "thisSet", "CurrentTime", "reportedNames", "currentPath", "currentPort", "CurrentDir", "CurrentNames"], "baseCopy": ["Basecopy", "baseStore", "parentCop", "BaseCopy", "baseName", "basiccopy", "buffercopy", "basicCopy", " baseStore", " baseName", "basecopy", "parentcopy", "bufferCopy", "baseCop", "parentCopy", "bufferCop", "BaseName", "basicCop", " basecopy", "basicStore", "parentName", "BaseStore", "BaseCop", " baseCop"], "source": ["space", "create", "data", "inner", "SOURCE", "site", "target", "input", "store", "system", "reader", "base", "sequence", "scan", "ources", "subject", "connection", "src", "scope", "sample", "init", "owner", "ource", "origin", "Source", "size", "stream", "search", "resource", "from", "service", "local", "se", "iterator", "start", "master", "original", "console", "initial", "shell", "before", "channel", "join", "select", "parent"], "destination": ["messuation", "declregation", "datination", "Destination", "Destregation", "datinations", "datregation", "Destinations", " destinations", "messination", "Destinated", "declinations", "declinator", "destinator", "datinator", "destuation", "destinated", " destuation", " destructure", "messinated", "Destinator", "declination", "messinations", "Destuation", "destinations", "messructure", " destinated", "Destructure", "destregation", "destructure"], "clefs": ["cleFs", "Clefs", " Clefits", "CLEcs", " CleFS", "CleFS", "clefits", "CLEFs", "Clecs", "CLEfits", " Clecs", "CLEfs", " cleFs", "cleFS", " Clefs", " Clebs", " CleFs", " clebs", "Clebs", "clecs", "CleFs", "Clefits", " cleFS", "clebs"], "st": ["rest", "pt", "it", "h", "St", "ste", "statement", "sy", "std", "irst", "bt", "ST", "dd", "ct", "str", "est", "cr", "stat", "sp", "sn", "mt", "inst", "sth", "sts", "se", "sm", "start", "ost", "ts", "tt", "sl", "query", "sw", "cl", "storage", "sc", "ist", "fr", "bl", "sb", " ST", "stra"], "rs": ["ks", "RS", "ris", " ms", " cs", " ps", "rt", "ins", "res", "rd", " iss", "os", " ins", " RS", "rc", "cs", "sts", "Rs", "ts", "mr", "as", "ers", "rys", " sr", "ps", " pts", "ds", "ls"]}}
{"id1": "9261777", "id2": "19810820", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"source": ["tree", "ui", "use", "back", "address", "SOURCE", "body", "site", "target", "filename", "input", "store", "string", "index", "clip", "status", "volume", "expression", "template", "base", "table", "sequence", "prefix", "details", "language", "char", "form", "style", "str", "subject", "parent", "context", "sql", "src", "scope", "sample", "script", "init", "lower", "where", "ource", "origin", "copy", "title", "Source", "ce", "info", "search", "resource", "file", "from", "service", "check", "reason", "se", "start", "config", "query", "content", "spec", "component", "view", "path", "size", "text", "uri"], "destination": ["portine", "destine", "destacement", "destinant", "goodinator", "certinator", "distination", "origend", "goodacement", "testino", "distinant", "portend", "distinations", "destino", "destinate", "testinate", "combination", "originator", "portination", "testinator", "declinant", "certacement", " destend", "declinations", "destinator", "origination", "testination", "certination", "combinator", " destinate", "tempinator", "origine", "certinate", "distinator", "portinator", "tempination", "declinate", " destinator", "goodination", "declination", "declacement", "tempino", "destinations", "tempinate", " destino", " destine", "declinator", "goodinate", "combinant", "combinations", "destend"], "is": ["ip", "dis", "ris", "isi", "js", "oss", "bis", "in", "lis", "sis", "has", "isa", "us", "ins", "are", "was", "obs", "webkit", "im", "ir", "ais", "vis", "ires", "ois", "icks", "tis", "its", "IS", "abs", "vs", "Is", "isf", "sys", "mis", "isin", "iso", "ms", "ics", "bits", "init", "ib", "ios", "info", "iter", "nis", "ri", "zes", "s", "iss", "ts", "es", "iris", "ist", "mus", "isl", "ims", "ps", "ns", "bs", "i", "ains", "isc", "ic", "si", "ie"], "os": ["o", "css", "ose", "ks", "dis", "zero", "pos", "oss", "bis", "ops", "los", "oa", "oos", "cos", "obs", "oses", "oS", "ss", "aos", "ob", "Os", "io", "mes", "sys", "asis", "ms", "dos", "mot", "ot", "OS", "ios", "ols", "ys", "\u00f3", "s", "bos", "osi", "ts", "ones", "es", "fs", "ost", "outs", "uts", "on", "bs", "ns", "or", "oes", "ox", "mos"], "buffer": ["batch", "cache", "command", "Buffer", "background", "memory", "paste", "window", "padding", "database", "total", "available", "template", "shape", "table", "button", "sequence", "document", "bar", "pad", "queue", "buf", "row", "mem", "phrase", "sample", "buff", "append", "comment", "stack", "block", "word", "library", "variable", "binary", "view", "event", "message", "temp", "history", "display", "frame"], "length": ["capacity", "partial", "time", "bus", "l", "ength", "duration", "span", "angle", "full", "loop", "reading", "string", "database", "total", "volume", "distance", "ind", "th", "ence", "padding", "split", "load", "shape", "sequence", "type", "collection", "pad", "end", "width", "frequency", "number", "text", "count", "offset", "ment", " Length", "Length", "enth", "position", "size", "ith", "ENGTH", "last", "integer", "start", "needed", "point", "tail", "component", "hello", "of", "display", "ty", "path", "history", "before", "family", "height", "character", "bow", "stop", "len"]}}
{"id1": "2461169", "id2": "7149578", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFile2String", "decodeString2Files", "decodeFile2Files", "decodeFileFileFile", "decodeFileAsfile", "decodeFileToString", "decodeStringToFile", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToFiles", "decodeFileAsFile", "decodeFileFilefile", "decodeFile2file", "decodeString2file", "decodeStringTofile", "decodeFileAsString", "decodeString2String", "decodeFile2File", "decodeFileAsFiles", "decodeStringToString", "decodeFileToFiles", "decodeString2File"], "infile": ["inputname", "outname", "outfilename", "isinname", "isinfile", "inputfolder", "Infilename", "outfolder", "outbase", "inputFile", "Inbase", "isinFile", "inbase", "infolder", "fromFile", "Infile", "InFile", "inputfile", "inname", "frombase", "isinfolder", "inFile", "fromfile", "outFile", "infilename", "fromfilename"], "outfile": ["indir", "Outdir", "outname", "outfilename", "Outfile", "Outfilename", "toFile", "OutFile", "otname", "otfile", "otFILE", "tofilename", " outFILE", "inFILE", "outdir", "todir", "inname", "otFile", "tofile", "inFile", " outname", "outFile", "outFILE", "infilename", " outFile"], "in": ["inf", "conn", "oin", "IN", "it", "inc", "pin", "al", "inner", "cin", "ins", "input", "re", "ind", "rin", "bin", "im", "up", "In", "inside", "is", "ini", "form", "by", "or", "ar", "amin", "isin", "init", "con", "info", "iter", "nin", "t", "gin", "from", "id", "en", "ain", "get", "inn", "on", "per", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "print", "null", "ex", "oss", "it", "inner", "flush", "res", "OUT", "at", "os", "io", "ou", "Out", "aos", "writer", "fn", "end", "outer", "sys", "co", "write", "ot", "con", "ion", "opt", "t", "file", "auto", "gt", "can", "en", "g", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "header", "black", "memory", "paste", "window", "padding", "total", "available", "template", "base", "bone", "shape", "button", "table", "sequence", "document", "bar", "attribute", "password", "pad", "buf", "number", "row", "mem", "phrase", "note", "sample", "buff", "append", "comment", "stack", "info", "column", "block", "library", "variable", "binary", "initial", "view", "message", "temp", "display", "history", "frame", "character"], "read": ["n", "need", "give", " Read", "raw", "print", "shift", "push", "skip", "input", "index", "reading", "reader", "ind", "req", "seek", "load", "hold", "open", "Read", "end", "count", "send", "first", "write", "through", "iter", "size", "check", "wait", "connect", "add", "stream", "allow", "range", "start", "READ", "close", "query", "set", "find", "get", "ok", "run", "i", "before", "each", "length", "ready", "reads", "text", "select", "readable", "len"], "success": ["submit", "sufficient", "summary", "continue", "Success", "condition", "second", "cess", "city", " succ", "status", " successful", "ccess", "response", "accept", "democracy", "error", "town", "unity", "danger", "please", "exist", "commit", "snap", "valid", "first", "scope", "safe", "surv", " failure", "ceed", "setup", " okay", " successes", "primary", "same", "support", "complete", "value", "crit", "successfully", "result", " succeeds", "successful", "release", "ratulations", "good", "photo", "ok", "fail", " succeed", "done", "positive", "growth"]}}
{"id1": "2936678", "id2": "8385785", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"getUniqueKey": [" getRandomkey", "getuniqueKey", " getUniqueId", "getRandomString", "getNewString", " getRandomId", " getUniqueString", "getuniqueId", "getUniqueString", "getUniquekey", " getRandomKey", "getNewKey", "getNewId", "getNewkey", "getRandomkey", " getRandomString", "getuniquekey", "getRandomKey", " getUniquekey", "getRandomId", "getuniqueString", "getUniqueId"], "digest": ["integse", "feedested", "contested", "digests", "feedest", "Digested", " DigEST", " Digse", "displayist", "contity", "Digest", " digested", " digEST", " digester", "Digist", "displayester", "validests", "feedist", " digity", "contest", "integgest", "validity", " Digest", "integest", "DigEST", "digested", " Diggest", "diggest", " digests", "displayest", "validest", "digEST", "Digse", "digester", "Diggest", "displayested", "digist", "feedEST", "displayEST", "digse", "integEST", "digity", "Digester", "validested", "contests"], "md": ["d", "m", "mg", "ad", "cd", "ld", "pt", "magic", "mand", "bd", "pd", "hd", "grad", "MD", "mm", "det", "od", "dr", "ind", "pm", "cond", "mod", "cmd", "dd", "red", "der", "df", "wd", "pdf", "bf", "ms", "nd", "dig", "dh", "td", "mc", "mt", "dn", "ma", "mn", "add", "rm", "mp", "mk", "sm", "fd", "sd", "dm", "di", "mb", "de", "mark", "ds"], "timeVal": ["timeval", " timePref", "TimeDef", "timeValue", " timeval", "TimeValue", "imeval", "TimePref", "imeVal", "imePref", " timeValue", "timeDef", "TimeVal", "imeValue", "Timeval", "timePref", "imeDef", " timeDef"], "localHost": ["localPort", "localAddress", " localAddress", "localValue", "lochost", "locPort", " localValue", "realHost", "realAddress", " localGuest", " localPort", " localhost", "LocalPort", "localhost", "Localhost", "locHost", "LocalAddress", "LocalValue", "locValue", "localGuest", "locGuest", "realPort", "realGuest", "LocalHost", "locAddress"], "randVal": ["Randval", "randomValue", "ndVal", "randomStr", " randInt", " randStr", "RandValue", "ndInt", "randomVal", "randStr", "randomval", "RandVal", "ndval", " randValue", " randval", "randValue", "ndValue", "randomInt", "randInt", "RandStr", "randval"], "val": ["v", "pt", "it", "al", "data", "alpha", "test", "obj", "grad", "ctx", "res", "p", " Val", "oval", "ind", "msg", "mod", "reg", "ival", "buf", "ret", "valid", "vol", "sel", "div", "aval", "value", "eval", "result", "aud", "Value", "sl", "tx", "def", "Val", "VAL", "cal", "values", "rol", "vt", "vals", "item"]}}
{"id1": "20568568", "id2": "293167", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"createHTML": ["CreateHTML", "CreateHT", "seeURL", "CreateSQL", "createSQL", "seeSQL", " createHT", "CreateURL", " createURL", "createURL", "seeHTML", "seeHT", "createHT", " createSQL"], "requestPage": ["responseLine", "Requestpage", " requestFrame", "responseFrame", "RequestFrame", "questionpage", "referenceApp", "RequestLine", "requestpage", "RequestType", "RequestApp", "RequestPage", "requestLine", "responseType", "requestFrame", "questionPage", "referencePage", "requestApp", "questionApp", "referenceType", "requestType", " requestType", "questionType", " requestLine", "referencepage", "responsePage"], "result": ["report", "summary", "cache", "command", "detail", "html", "Result", "function", "figure", "root", "memory", "res", "date", "term", "response", "answer", "document", "error", "sequence", "prefix", "description", "trace", "cup", "feature", "line", "render", "json", "work", "section", "comment", "request", "true", "word", "results", "search", "complete", "format", "value", "reason", "success", "all", "params", "match", "relation", "product", "output", "r", "this", "message", "page", "out", "buffer", "join", "source"], "url": ["browser", "http", "link", "web", "l", "in", "ws", "ll", "html", "rl", "xml", "rel", "res", "re", "base", "open", "char", "f", "str", "il", "abs", "ssl", "dl", "ref", "ur", "nl", "URL", "gl", "resource", "loader", "fs", "Url", "sl", "get", "lr", "sb", "ol", "r", "ls", "uri"], "ins": ["ks", "lins", "ris", "in", "ws", "pins", "qs", "cin", "inner", "res", "input", "reader", "als", "gs", "is", "its", "vs", "Ins", "rus", "isin", "ints", "ics", "con", "din", "includes", "cs", "uds", "asin", "ln", "eds", "ars", "pers", "rates", "gin", "sts", "kins", "ts", "ips", "ats", "fs", "mr", "rys", "INS", "ils", "ains", "bs", "ds", " in", "ls", " din"], "bufferedReader": ["bufferedBuilder", "bufferingReader", "buffiledContainer", "buffedWriter", "buffedLoader", "buffedReader", "buffererWriter", " bufferedBuilder", " buffedReader", " buffererWriter", "buffererReader", "bufferingWriter", "buffedreader", "bufferedContainer", " buffedreader", " bufferedWriter", "bufferedWriter", "bufferedreader", " bufferedreader", " buffererReader", "bufferingContainer", " buffedContainer", "buffaredWriter", "bufferingreader", "buffiledReader", "buffedBuilder", "buffaredBuilder", " buffedWriter", "buffiledreader", "buffaredReader", "buffaredLoader", " bufferedLoader", "buffererBuilder", " buffererBuilder", " buffererLoader", " bufferedContainer", "buffedContainer", "buffiledWriter", "buffererLoader", "bufferedLoader"], "cssLine": ["cssLin", "cssline", "ssline", "styleData", "ssLine", "CSSLine", "rssBlock", "javascriptLin", "csData", "rssLine", "javascriptLine", "styleRow", "csRow", "cssBlock", "cosLine", "cssData", "cssRow", "csline", "CSSBlock", "ssBody", "CSSRow", "ssData", "cosBlock", "cssBody", "csLine", "rssRow", "cosBody", "ssRow", "ssLin", "javascriptRow", "javascriptBlock", "ssBlock", "cosRow", "styleLine", "rssBody", "CSSLin", "styleline"], "e1": ["ee1", " e5", "e01", "ee0", "o5", " e01", " e0", "E1", "ee3", "o1", "o01", " e3", "e5", "E0", "e0", "o0", "E2", "e3", "ee5", "ee01", "o2", "ee2", "e2", " e2", "E3"], "queryZoom": ["queryZome", "queryDoo", "queryZoneolution", "queryXom", "viewzome", " queryZooming", "queryDom", "queryZolution", "queryZoo", "queryzoo", " queryzolution", " queryzoom", "viewzom", " queryZolution", "viewZom", "queryZXolution", "queryzom", "queryZom", "queryXome", "queryzolution", " queryzom", "queryDoom", "queryDome", " queryzooming", "queryZoneoom", "viewzoom", "queryZXoom", "viewZome", "queryzoom", "queryzooming", "queryzome", "queryXoo", " queryZom", "viewzoo", "queryZoneooming", "viewZoo", "queryXoom", "queryZXooming", "viewZoom", "queryZXom", "queryZooming", "queryZoneom"], "appendToHome": ["appendTOQuery", "addToQuery", "addtoMenu", "appendToUrl", "appendetoUrl", "appendetoHome", "appendtoHome", "addToUrl", "addtoHome", "appendToQuery", "appendTOUrl", "appendtoUrl", "appendetoMenu", "appendTOHome", "appendToMenu", "addtoUrl", "addtoQuery", "appendetoQuery", "appendtoMenu", "addToHome", "appendtoQuery", "appendTOMenu", "addToMenu"], "sql": ["csv", "condition", "xml", "q", "spr", "rel", "inv", "statement", "string", "expression", "ql", "table", "fn", "cmd", "imp", "json", "sys", "dl", "sv", "sel", "nl", "ms", "sp", "qu", "where", "setup", "ma", "mt", "sn", "select", "QL", "series", "sd", "SQL", "query", "params", "quote", "spec", "sol", "scl", "expr", "db", "ls", "sq"], "pstmt": [" pStst", "pStMT", "pstmr", "postsql", " pfrpr", "pfrmt", "postpr", " pstms", "pstatmt", " pfrmt", "pstrmr", " pStmt", " pstrmt", "pStst", "pstbl", "pstrpr", "psem", "pstartst", "postm", "pmtpr", "prstStatement", "pmtmt", "psebl", "pstrmt", "pstStatement", "psthStatement", "pstsql", " pfrsql", "pstrm", "pfrm", "prstpr", "pSTst", " pstrmr", "postmt", "pSTpr", "pstartms", " pStms", "psemt", "pstpr", "psthmt", "pstst", "pStmt", "pstartMT", "prsthStatement", " pstsql", "pstrsql", " pstbl", " pstrm", "prsthst", "pstm", "prsthpr", "prstst", "pstMT", "pstms", "pSTMT", "psthst", " pstrbl", "pstrbl", "pstartmt", "pmtStatement", "psemr", " pfrm", "pStms", " pstpr", "prstmt", "pSTStatement", " pstmr", "pSTmt", " pstm", " pStMT", "psthpr", "pSTms", "pfrpr", " pstst", "pstatm", "pmtst", " pstMT", "prsthmt", "pstatbl", "pstatmr", "pfrsql"], "rs": ["ks", "RS", "ris", "ws", "rt", "res", "rd", "os", "ss", "its", "ows", "ras", "rc", "ms", "rows", "ys", "ars", "cs", "ues", "xs", "rates", "sts", "Rs", "ts", "ats", "fs", "mr", "rys", "ims", "ps", "bs", "ds", "gs", "ls"]}}
{"id1": "8778962", "id2": "6866575", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFile2String", "decodeString2Files", "decodeFile2Files", "decodeFileFileFile", "decodeFileAsfile", "decodeFileToString", "decodeStringToFile", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToFiles", "decodeFileAsFile", "decodeFileFilefile", "decodeFile2file", "decodeString2file", "decodeStringTofile", "decodeFileAsString", "decodeString2String", "decodeFile2File", "decodeFileAsFiles", "decodeStringToString", "decodeFileToFiles", "decodeString2File"], "infile": ["inputname", "outname", "outfilename", "isinname", "isinfile", "inputfolder", "Infilename", "outfolder", "outbase", "inputFile", "Inbase", "isinFile", "inbase", "infolder", "fromFile", "Infile", "InFile", "inputfile", "inname", "frombase", "isinfolder", "inFile", "fromfile", "outFile", "infilename", "fromfilename"], "outfile": ["indir", "Outdir", "outname", "outfilename", "Outfile", "Outfilename", "toFile", "OutFile", "otname", "otfile", "otFILE", "tofilename", " outFILE", "inFILE", "outdir", "todir", "inname", "otFile", "tofile", "inFile", " outname", "outFile", "outFILE", "infilename", " outFile"], "in": ["inf", "conn", "oin", "IN", "it", "inc", "pin", "al", "inner", "cin", "ins", "input", "re", "ind", "rin", "bin", "im", "up", "In", "inside", "is", "ini", "form", "by", "or", "ar", "amin", "isin", "init", "con", "info", "iter", "nin", "t", "gin", "from", "id", "en", "ain", "get", "inn", "on", "per", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "print", "null", "ex", "oss", "it", "inner", "flush", "res", "OUT", "at", "os", "io", "ou", "Out", "aos", "writer", "fn", "end", "outer", "sys", "co", "write", "ot", "con", "ion", "opt", "t", "file", "auto", "gt", "can", "en", "g", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "header", "black", "memory", "paste", "window", "padding", "total", "available", "template", "base", "bone", "shape", "button", "table", "sequence", "document", "bar", "attribute", "password", "pad", "buf", "number", "row", "mem", "phrase", "note", "sample", "buff", "append", "comment", "stack", "info", "column", "block", "library", "variable", "binary", "initial", "view", "message", "temp", "display", "history", "frame", "character"], "read": ["n", "need", "give", " Read", "raw", "print", "shift", "push", "skip", "input", "index", "reading", "reader", "ind", "req", "seek", "load", "hold", "open", "Read", "end", "count", "send", "first", "write", "through", "iter", "size", "check", "wait", "connect", "add", "stream", "allow", "range", "start", "READ", "close", "query", "set", "find", "get", "ok", "run", "i", "before", "each", "length", "ready", "reads", "text", "select", "readable", "len"], "success": ["submit", "sufficient", "summary", "continue", "Success", "condition", "second", "cess", "city", " succ", "status", " successful", "ccess", "response", "accept", "democracy", "error", "town", "unity", "danger", "please", "exist", "commit", "snap", "valid", "first", "scope", "safe", "surv", " failure", "ceed", "setup", " okay", " successes", "primary", "same", "support", "complete", "value", "crit", "successfully", "result", " succeeds", "successful", "release", "ratulations", "good", "photo", "ok", "fail", " succeed", "done", "positive", "growth"]}}
{"id1": "14773782", "id2": "10547671", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" decodeJPPGRasters", " decodeJPEGGrasters", " decodeJPEGRaster", " decodeJPEGPaster", " decodeJPEGraster", " decodeJPEGPater", " decodeJPPGrater", " decodeJPPGrotation", " decodeJPPGrasters", " decodeJPPGRaster", " decodeJPEGrotation", " decodeJPPGRotation", " decodeJPEGRater", " decodeJPEGrater", " decodeJPEGGrotation", " decodeJPEGPotation", " decodeJPEGrasters", " decodeJPEGGraster", " decodeJPPGRater", " decodeJPEGRotation", " decodeJPEGRasters", " decodeJPEGGrater", " decodeJPPGraster", " decodeJPEGPasters"], "IOException": ["ConnectionException", " IOFailure", "ConnectionFailure", "IOFailure", "URIFailure", "IOProblem", "URIProblem", " IOProblem", "URIException", "ConnectionProblem"], "start": ["insert", "rest", "print", "time", "it", "step", "starting", "create", "reset", "wind", "seed", "Start", "base", "open", "birth", "begin", "delay", "end", "trans", "top", "send", "first", "offset", "init", "st", "wait", "t", "from", "read", "set", " started", "started", "initial", "get", "before", "art"], "i": ["m", "multi", "b", "ij", "ci", "ui", "batch", "in", "ex", "it", "gi", "key", "q", "phi", "us", "major", "index", "ind", "im", "c", "name", "ki", "sequence", "ini", "li", "is", "iq", "ski", "gu", "ii", "si", "client", "f", "xi", "bi", "pi", "j", "u", "conv", "x", "me", "init", "info", "request", "counter", "go", "ai", "sim", "s", "mi", "ti", "ix", "exp", "id", "g", "di", "my", "ic", "out", "I", "ie", "qi", "p", "uu"], "url": ["browser", "http", "link", "web", "l", "ll", "xml", "key", "q", "hub", "rel", "el", "res", "string", "location", "external", "char", "ul", "gif", "mail", "row", "dl", "ref", "ur", "nl", "domain", "mount", "URL", "gl", "resource", "pattern", "log", "Url", "job", "id", "host", "r", "lr", "path", "ls", "uri"], "istream": ["iftank", "aststream", "istStream", "iftriver", "ISTram", "ISTub", "isriver", "stStream", "isub", "ISTank", "istsream", "istub", "iftub", "astram", "istabel", "astStream", "iststream", "ISTroll", "istsstream", "astream", "itram", "iftream", "astabel", "ststream", "istsStream", "isream", "itream", "ISTriver", "stabel", "stream", "itroll", "istsabel", "itstream", "ISTstream", "ISTream", "istroll", "istriver", "isank", "istram", "istank", "astroll"], "dec": ["dev", "dis", " enc", "bd", "oct", "deg", "Dec", "desc", "det", "rec", " DEC", "exec", "bec", " Dec", "c", "dc", "des", "da", "decl", "ra", "der", "agg", "enc", "valid", "DEC", "dem", "dig", "disc", "dra", "div", "ko", "draw", "cam", "De", "coll", "dep", "del", "def", "ec", "de", "cor"], "raster": ["braster", " rraphic", "matter", "replreement", "Rraphic", " rasters", "rreement", "Rreement", "ratter", "Raster", "remasters", "rmap", " rastered", " rmap", "rastered", " rast", "bratter", "remraphic", "Ratter", "brastered", "replasters", "mastered", "brast", "Rasters", "mast", "rraphic", "rast", "remaster", " ratter", "rasters", "master", " rreement", "remmap", "Rmap", "replatter", "replaster"], "width": ["ose", "issa", "dim", "orth", "ength", "cale", "step", "tall", "resolution", "fw", "body", "displayText", "window", "padding", "term", "Width", "idth", "shape", "layout", "wid", "strength", "cut", "wa", "write", "weight", "position", "size", "w", "axy", "widget", "const", "sw", "success", "frame", "path", "left", "length", "change", "text", "len"], "height": ["kw", "capacity", "resolution", "alpha", "h", "angle", "grow", "window", "padding", "Height", "volume", "th", "rank", "stroke", "shape", "gravity", "holes", "density", "confidence", "style", "hang", "count", "acity", "inches", "radius", "size", "depth", "power", "dimension", "cision", "frame", "ty", "history", "length", "buffer"], "stop": ["rest", "null", "quit", "it", "step", "ops", "skip", "post", "root", "obj", "no", "term", "status", " Stop", "timeout", "period", "end", "fin", "jump", "ab", "cut", "commit", "est", "pause", "st", "wake", "wait", "counter", "next", "Stop", "gc", "pop", "max", "result", "close", "set", "trip", "success", "update", "enable", "op", "disable", "delete", "termination"]}}
{"id1": "4618237", "id2": "17817568", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFileAsDisk", "writeFile2Files", "writeFileAsFiles", "writeFile2Stream", "writeFileToFiles", "writeFiles2File", "writeFilesToFiles", "writeFile2File", "writeFiles2Disk", "writeFiles2Stream", "writeFileToDisk", "writeFilesToFile", "writeFileAsStream", "writeFileToStream", "writeFiles2Files", "writeFile2Disk", "writeFileAndFiles", "writeFilesToDisk", "writeFileAndStream", "writeFileAndFile", "writeFileAndDisk", "writeFilesToStream", "writeFileAsFile"], "fin": ["FIN", "syn", "n", "fa", "in", "lin", "fw", "inv", "lo", "rin", "Fin", "ini", "details", "fn", "fi", "rf", "fil", "f", "fp", "fc", "raf", "init", "din", "ln", "irm", "mn", "normal", "ran", "fd", "lf", "jen", "fl", "en", "fr", "fur", "fre", "han", "focus", "mid", "ic", "mil", "kin"], "fout": ["tout", "koutput", "kOut", "fbout", "fbOut", "fou", "fpo", "FOut", "kout", "fOut", "Fin", "ffou", " fOut", "ffout", "tou", " fpo", "ffin", "foutput", "fbpo", "fboutput", "Fou", "Fout", "tin", "kpo", " foutput", "tOut", "ffOut"], "append": ["insert", "pend", "batch", "express", "command", "csv", "absolute", "push", "ended", "equal", "grow", "folder", "string", "ext", "seed", "ind", "replace", "ends", "end", "send", "note", "buff", "force", "bold", "add", "allow", "printf", "include", "flat", "update", "vert", "animate", "app", "fail", "apply", "join"], "inChannel": ["inputChan", " inSession", "sinButton", " inCategory", "pinChannel", " inConnection", " inchannel", " inCommand", "rinChan", "pinCategory", "InChannel", "inchannel", "outCommand", "intChan", " inStream", "sinChannel", "insideChannel", "inConnection", "inMachine", "inputListener", "inStream", "iChan", "inChan", "inCommand", "outChan", "inCategory", "innButton", "outConnection", "Inchannel", "inputChannel", " inClient", "outchannel", "inButton", " inChan", "sinCategory", "iChannel", "innMachine", "intSession", "inClient", "rinListener", "iCommand", "insideSession", "intClient", "insideChan", "insideClient", "pinMachine", "pinButton", "InStream", "InConnection", "outStream", "rinChannel", "rinCategory", "inSession", "innChannel", "inListener", "iStream", " inListener", "inputCategory", "sinMachine", "intChannel", "innCategory"], "outChannel": [" outCh", "OUTController", "OUTChan", "netChannel", "inchannel", "netchannel", "OUTchannel", "nameScope", "netChan", "userChannel", "outputchannel", " outConnection", "inChan", "inCh", "outCh", "outChan", "netController", "outConnection", "outputScope", "outchannel", " outchannel", "outputChannel", "netCh", "outputConnection", "nameConnection", "outController", "invMember", "OUTChannel", " outChan", " outController", "nameChannel", " outScope", "nameChan", "userCh", "outputChan", "outputCh", "invCh", "invChannel", "userMember", "outMember", "outScope", "netMember"]}}
{"id1": "1188100", "id2": "4468255", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"test": ["debug", "print", " Test", "some", "use", "show", "server", "execute", " TEST", "Testing", "store", "load", "tests", " testing", "unit", "Test", "est", "sample", "example", "evaluate", "check", " evaluate", "testing", "tested", " tests"], "s": ["http", "b", "n", "v", "m", "l", "js", "socket", "ws", "less", "qs", "session", "h", "aws", "store", "status", "self", "state", "rs", "c", "os", "y", "sports", "south", "S", "is", "ss", "details", "still", "comm", "abs", "sys", "sa", "sv", "ssl", "sql", "j", "so", "ms", "e", "st", "t", "cs", "https", "w", "pers", "xs", "service", "ts", "sm", "ats", "fs", "ses", "sts", "z", "sl", "sw", "sd", "sc", "spec", "stats", "sb", "ps", "bs", "i", "ns", "ds", "gs", "ls", "sq", "p"], "input": ["ip", "raw", "feed", "null", "in", "data", "inner", "buffer", "reader", "image", "accept", "Input", "inside", "open", "ahead", "io", "form", "media", "cont", "json", "context", "sample", "active", "upload", "request", "stream", "iterator", "file", "start", "read", "initial", "get", "hello", "output", "this", "my", "i", "text", "current", "source"], "writer": ["rew", "to", "wire", "her", "operator", "inner", "writing", "wright", "processor", "window", "reader", "term", "editor", "maker", "Writer", "winner", "builder", "external", "handler", "worker", "end", "caster", "write", "writ", "draw", "riter", "writers", "manager", "word", "stream", "w", "written", "format", "file", "driver", "service", "loader", "WR", "widget", "creator", "wrote", "storage", "console", "output", "temp", "woman", "player", "out", "buffer"]}}
{"id1": "11645260", "id2": "10540676", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"doGet": ["handleGet", "actionGET", "actionQuery", " doget", "handleQuery", " doQuery", " doGET", "doGET", "handleGET", "actionGet", "handleget", "doget", "actionget", "doQuery"], "request": ["http", "report", "raw", "command", "record", "create", "xml", "address", "reset", "execute", "question", "test", "call", "input", "string", "req", "transform", "document", "quest", "requ", "attribute", "begin", "remove", "client", "core", "subject", "claim", "application", "setup", "version", "enter", "position", "each", "connect", "resource", "Request", "complete", "search", "argument", "require", "QUEST", "query", "set", "update", "initial", "forward", "get", "object", "hello", "view", "order", "art", "reference", "message", "change", "frame", "instance", "parent"], "response": ["http", "report", "summary", "security", "cache", "print", "continue", "socket", "network", "xml", "session", "resp", "server", "respond", "site", "environment", "hash", "controller", "res", "user", "onse", "image", "status", "answer", "document", "sequence", "description", "render", "client", "json", "we", "connection", "context", "application", "write", "reply", "version", "position", "ce", "block", "next", "stream", "format", "service", "respons", "Response", "result", "exit", "release", "success", "content", "relation", "view", "object", "default", "output", "fire", "message", "page", "buffer", "frame", "tree", "line"], "target": ["goal", "to", "launch", "link", "null", "project", " targeted", "address", "href", "rel", "controller", "window", "location", "template", "transform", "table", "layout", "bolt", "localhost", "alias", "top", "arg", "subject", "context", "scope", "blank", "arget", "prototype", "copy", "peer", "origin", "next", "search", "resource", "internal", "value", "range", "Target", "ARGET", "pattern", "set", "route", "point", "tool", "host", "focus", "output", "reference", "path", "dest", "select", "uri", "source"], "requestUrl": ["questionurl", "resourceURL", "resourceStr", "RequestURL", " requestStr", "RequestCert", "requesturl", "responseCert", " requestURL", "requestStr", "responseurl", "Requesturl", "requestCert", " requestEmail", "RequestUrl", "responseURL", "questionURL", "questionUrl", "requestURL", "responseUrl", "RequestEmail", "requestEmail", "resourceEmail", "resourceUrl", "RequestStr", "questionCert"], "en": ["syn", "ene", "n", "enn", "ane", "ben", "gen", " En", "sen", "EN", "agen", "ener", "pe", "el", "een", "ense", "ern", "En", "ens", "end", "aten", "un", "enc", "ensen", "ze", "wen", "em", "den", "con", "ln", "mun", "ve", "zen", "mn", "ven", "atten", "se", "reen", "ent", "an", "jen", "oen", "pn", "ren", "pen", "on", "hen", "et", "eng", "len"], "nextUrl": ["Nexturl", "nextUr", "nextPage", " nextURL", " nexturl", "NextUrl", "NextURL", "nextURL", "newPage", "NextUr", "newurl", "newUr", "NextPage", "prevPage", "prevUrl", "nexturl", "newUrl", "prevURL", "prevUr", "newURL", " nextUr"], "allowedToAccess": ["allowtoAccess", "allowedTOUse", "allowedtoaccess", " allowedToaccess", "allowToAccess", "allowedtoAdmin", "allowToaccess", " allowedToUse", "allowtoaccess", "allowedTOaccess", "allowedForAccess", "allowedForUse", "allowedToAdmin", "allowedtoAccess", "allowedForaccess", "allowedTOAdmin", " allowedToAdmin", "allowedToUse", "allowedTOAccess", "allowedToaccess"], "is": ["ip", "ris", "isi", "in", "oss", "bis", "it", "js", "lis", "sis", "inner", "has", "isa", "us", "ins", "ress", "obs", "ir", "im", "ais", "os", "ois", "tis", "its", "IS", "abs", "vs", "Is", "sys", "isf", "isin", "iso", "ms", "init", "ib", "ys", "ios", "info", "iter", "inst", "s", "iss", "mi", "es", "fs", "as", "isl", "rys", "ims", "bs", "i", "ic", "isc", "or", "si", "imp"], "out": ["o", "css", "n", "to", "v", "conn", "null", "list", "in", "it", "oss", "ex", "inner", "flush", "us", "cos", "inv", "res", "obj", "user", "OUT", "at", "timeout", "status", "os", "up", "Out", "io", "ou", "aos", "writer", "client", "end", "or", "outer", "sys", "conv", "co", "write", "ion", "w", "t", "file", "ent", "gt", "can", "all", "OU", "output", "outs", "ns", "net", "cn", "ne", "nt"], "url": ["browser", "http", "link", "conn", "web", "l", "ll", "pkg", "rl", "rel", "call", "hl", "loc", "str", "il", "ul", "ssl", "u", "build", "ur", "nl", "context", "bel", "mount", "https", "URL", "gl", "log", "Url", "sl", "cl", "cal", "lr", "mb", "path", "ls", "uri"], "uc": ["uh", "uma", "ci", "ui", "conn", "usc", "lc", "oc", "UC", "us", "upt", "ub", "c", "cus", "ou", "anc", "uf", "ul", "u", "fc", "nc", "rc", "cr", "um", "connection", "ud", "context", "eu", "con", "unc", "mc", "ux", "cv", "auc", "bc", "sc", "ec", "ucc", "ocr", "uca", "cu", "tc", "uri", "uu"], "buf": ["b", "batch", "aka", "Buffer", "prop", "tab", "cat", "ctr", "pkg", "cp", "obs", "seq", "msg", "arr", "uf", "bar", "cmd", "rb", "cf", "bag", "emb", "queue", "var", "img", "conv", "mem", "br", "buff", "box", "cap", "cb", "vec", "cam", "cur", "block", "cv", "big", "bc", "db", "Buff", "temp", "buffer", "orig", "bus", "len"], "bytesRead": ["bytesNeed", "linesReader", "bytesread", " bytesLoad", "linesWritten", " bytesread", "linesLoad", "BytesNeed", "bytesLength", "cellsWritten", "filesread", " bytesNeed", "cellsRead", "tesRead", "tesLoad", " bytesWrite", "secondsWrite", "filesRead", "secondsWritten", "BytesLength", "cellsLoad", "cellsReader", "tesNeed", "linesRead", "secondsRead", " bytesLength", "filesLoad", "tesLength", "secondsread", "bytesWrite", "BytesLoad", "bytesLoad", "BytesRead", "secondsReader", "secondsLoad", "bytesWritten", "filesWrite", "bytesReader"]}}
{"id1": "12869602", "id2": "23531898", "code1": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"test_validate_tag_getTopAlbums": ["test_validate_tag_getTopAlalbumments", "test_validate_tag_getTopAllalbumments", "test_validate_tag_getTopAllalbumes", "test_validate_tag_getTopAlalbumls", "test_validate_tag_getTopAllalbumls", "test_validate_tag_getTopAllbumments", "test_validate_tag_getTopAloggs", "test_validate_tag_getTopAlalbumes", "test_validate_tag_getTopAlbumments", "test_validate_tag_getTopAlbumls", "test_validate_tag_getTopAllbumes", "test_validate_tag_getTopAllbumls", "test_validate_tag_getTopAlalbums", "test_validate_tag_getTopAloggments", "test_validate_tag_getTopAlogges", "test_validate_tag_getTopAlbumes", "test_validate_tag_getTopAllalbums", "test_validate_tag_getTopAloggls", "test_validate_tag_getTopAllbums"], "factory": ["liller", "vFactory", "vacter", "fFactory", "cactory", "facactory", "lancy", "FFactory", "vactory", "facade", "fancy", "ciller", "cancy", "fade", "Factory", " filler", "Facter", "facacter", "lacter", " fancy", "facFactory", "lactory", "facter", "vade", " facter", "cacter", "Fade", "filler"], "schemaLocation": ["scheaturelocation", "schemasLocation", "semaLocation", "schemaPath", "scheatureLoc", "schealLocation", "scheaturePath", "syalPath", "scheatureLocation", "scheallocation", "schembolLocation", "schealPath", "symalocation", "schemaslocation", "schemalocation", "seatureLocation", "schemePath", "syalLocation", "schemeLocation", "seaturelocation", "symaLocation", "schemaLoc", "schemasLoc", "schembollocation", "semalocation", "seatureLoc", "schemelocation", "syallocation", "semaLoc", "schembolLoc", "symaPath"], "schema": [" scheature", "Scheator", "validm", "cheature", "scheme", "Scheme", " schem", "mame", " scheme", "cheator", "ScheEMA", "maator", "scheature", "mama", "scheator", "validma", "scheEMA", "maEMA", "schem", "cheEMA", "validme", "validature", "chem", "Schema", "cheme", "chema"], "validator": ["scheener", " valider", " validigator", "navigator", "validigator", "variigator", "verator", "valma", "scheator", "valer", "valider", "varier", "validma", "varima", "naver", "valener", "navma", "navator", "verener", "verer", " validma", "variator", "validener", "verma", "scheer", "valator"], "url": ["browser", "http", "b", "link", "null", "web", "l", "html", "ll", "xml", "address", "hub", "rel", "user", "res", "window", "location", "base", "name", "external", "char", "f", "str", "abs", "ul", "api", "ssl", "u", "dl", "ur", "nl", "bel", "mount", "URL", "resource", "file", "gl", "service", "log", "Url", "sl", "get", "r", "channel", "uri"], "inputStream": ["inputstream", "inputSource", " inputStreamer", "audioStreamer", "sourcestream", "feedStream", "inputStreamer", "InputStream", " inputSource", "audiostream", "feedSteam", "InputStreamer", "feedstream", "sourceSource", "feedSource", " inputstream", " inputSteam", "Inputstream", "audioStream", "sourceSteam", "inputSteam", "sourceStream"], "source": ["in", "data", "xml", "SOURCE", "body", "inner", "session", "ser", "input", "store", "reader", "response", "status", "sequence", "wrapper", "str", "class", "sql", "context", "src", "scope", "sample", "sp", "ource", "Source", "sf", "stream", "iterator", "resource", "file", "from", "service", "series", "result", "sl", "console", "channel"]}}
{"id1": "14617444", "id2": "3495460", "code1": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"readUNI": [" readANi", "readUnION", " readUNS", " readUnI", " readANI", " readUNION", " readANS", " readOUS", "readUNION", "readUni", "readUNi", " readUni", "readUnS", " readOUI", " readANION", " readUNi", "readUnI", " readUnS", "readUNS", " readOUION", " readUnION", " readOUi"], "descriptions": [" describedIONS", "desriptations", "descriptcriptions", "desccription", "describesIONS", "descriptisions", "describion", "descructions", "desription", "desccriptIONS", "describedcriptions", "desripturations", "desriptions", " describedions", "desccriptions", "describedions", " descriptisions", "desccriptisions", "descripturations", "describedisions", "descriptations", "description", "describesions", "desccripturations", "desccriptations", " describedcriptions", "describurations", " descriptIONS", "descruction", "descructations", "descructurations", "desccriptcriptions", " descriptcriptions", " describedisions", "describions", "describesisions", "describescriptions", "describations", "describedIONS", "descriptIONS"], "source": ["code", "in", "address", "SOURCE", "body", "filename", "target", "input", "string", "seed", "name", "sequence", "description", "style", "subject", "sql", "src", "note", "sample", "ource", "origin", "Source", "stream", "resource", "file", "from", "value", "s", "start", "content", "output", "path", "message", "i", "text", "uri"], "is": ["ip", "dis", "ris", "isi", "in", "oss", "bis", "ws", "lis", "sis", "ists", "has", "isa", "us", "ins", "was", "ir", "ais", "os", "ois", "tis", "sels", "its", "IS", "Is", "isf", "sys", "isin", "iso", "ms", "serv", "ys", "info", "isp", "ios", "s", "iss", "es", "fs", "iris", "as", "isl", "ims", "bs", "isc", "i"], "url": ["browser", "http", "pl", "link", "web", "l", "ll", "html", "address", "rel", "user", "hl", "name", "loc", "open", "google", "char", "f", "str", "ul", "mail", "abs", "ssl", "build", "ur", "nl", "bel", "mount", "URL", "gl", "file", "resource", "service", "Url", "sl", "get", "host", "lr", "ls", "uri"], "scanner": ["Scanning", " scaner", "scanNER", "penner", "Scanner", "canNER", "gateer", "pener", " scanter", "Scanter", "gateter", "Scaner", " scanNER", "caniner", "scaniner", "canter", "gatening", "scaner", "canner", "Scaniner", "peniner", "penter", "scanning", "gatener", "caner", "scanter", "canning", "ScanNER"], "line": ["entry", "ip", "raw", "link", "code", "l", "record", "detail", "lin", "eline", "lc", "header", "pe", "label", "string", "lines", "lo", "email", "char", "str", "cell", "inline", "Line", "ine", "row", "text", "nl", "liner", "comment", "ide", "ln", "block", "iter", "word", "le", "LINE", "file", "range", "se", "log", "query", "page", "ne", "frame", "online"], "id": ["ip", "link", "oid", "ad", "md", "it", "sid", "Id", "key", "h", "hd", "pid", "label", "od", "ind", "status", "ids", "name", "description", "wid", "ver", "aid", "uid", "init", "title", "and", "info", "ide", "iter", "rid", "part", "iden", "bid", "mid", "ident", "kid", "db", "tag", "ID", "i"], "desc": ["dev", "summary", "pr", "null", "cd", "md", "lc", "sum", "sec", "esc", "Description", "rel", "doc", "label", "dist", "ser", "attr", "msg", "seq", "des", "dc", "name", "pro", "asc", "description", "cmd", "sup", "str", "json", "dl", "phrase", "title", "comment", "dir", "disc", "info", "cmp", "dec", "diff", "Desc", "def", "sc", "sub", "tag", "dest", "ds", "text"], "linescanner": ["linesscancell", "linecanner", "inesanter", "linespanner", "lineskner", "inesancell", " linesscaner", "linesancer", "inesaninner", " linescaninner", " linescaner", "linescanters", "linesanncer", "linespininner", "linesgateter", "inesscanener", "linesanninner", "linesscancer", "linespinner", " linesscaninner", "linesaner", "inescaninner", "linesscaninner", "lineskininner", "linesanters", "linescaninner", "linesscanters", "inescanner", "inescanters", "linespaninner", "lineskners", "lineskter", "linespanter", "linescancer", "linecanter", "linesscanNER", " linesscann", "linesgatener", "linesaninner", "linesscanner", "inesanters", "linesanners", "linecancer", "linespanNER", "linescancell", "lineskinter", "linespinters", "linesscanener", "linesannter", "linesanter", "inescanNER", "lineskinner", " linesscanter", "linescanNER", "linesgateNER", "inescanter", "linescanter", "linesannner", "linesancell", "linesscaner", "linesscanners", "linescann", "linesgateener", "inesanner", "inescanners", "linespanener", "linesscann", "linesscanter", "inesscanter", " linescanter", "linescanners", " linesscanner", "inescanener", "linesanncell", "lineskiner", " linescann", "linecaninner", "linescanener", "linescaner", "inesscanner", "linespinter", "inesanners", "inesscanNER", "linespann", "linesann", "linesanner", "inescancell"]}}
{"id1": "755203", "id2": "3806532", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewend", "readAndrewWrite", "readAndResend", "readAndrewrite", "readAndRepend", "readAndRewrites", "readAndResrites", "readAndRewWrite", "readAndRewend", "readAndRepWrite", "readAndResWrite", "readAndResrite", "readAndrewrites", "readAndReprites"], "inFile": ["infile", "InFilename", " inFilename", "docFilename", "inPlace", "outfile", "initFile", "INPlace", "iFILE", "inputFile", "inputPlace", "initFace", "inputFace", "iTime", "outFilename", "INFile", "Infile", "docTime", "InFile", "inFILE", "docFile", "initFilename", "iFilename", " infile", "inFace", "initPlace", "INFilename", "inTime", "inputFilename", "INTime", "inFilename", "iFile", "docFILE", "INFace", "INFILE"], "outFile": ["infile", "nameFILE", "checkFile", "outfile", "toFile", "checkFILE", "toFilename", "nameFilename", "checkfile", "toFILE", "checkFilename", "reportfile", "outFilename", " outFILE", "inFILE", "namefile", "reportFILE", "reportFilename", "tofile", " outfile", " outFilename", "outFILE", "reportFile", "nameFile", "inFilename"], "iis": ["diIs", "liis", "IIs", " iiss", "liris", "iIs", "iiss", " iIs", "iIS", "diis", "liisc", "diiss", "iiris", "eIs", "eIS", "Ii", "iiis", "ii", "liIs", " iIS", "eis", "dii", " iisc", " ii", "Iis", "aiis", "aiIs", "aiIS", "iiIs", " iris", "iiisc", "iris", "iisc", "Iiss"], "dcmParser": ["dcomParser", "dpmBuilder", " dpmPar", "dromParser", "dcommParser", "dfmBuilder", "dgrPar", "dcrparser", "DcmReader", "decmReader", "dmReader", " dpmAssistant", "deromReader", " dcmarser", "dcmStatement", "dcmReader", "dromReader", "dromparser", "dromListener", "dcmLoader", "dmmParser", "dpmLoader", "DpmPar", "dcommAssistant", "dmodulePrivate", "dmarser", "dmParser", "dcrParser", "DcmAdapter", "dcrBuilder", "DpmReader", "dcmPrivate", "dpmparser", " dpmReader", "DpmAdapter", "dmmmParser", "Dcmparser", "dpmStatement", "drumReader", " dpmPrivate", "dpcPrivate", " dpmBuilder", "dcmPar", "dfmLoader", "dgrStatement", "dcfStatement", "dmmmAdapter", " dcmLoader", "dpcParser", "DcmPar", "Dpmparser", "drumPar", "dcfReader", "dpmAdapter", " dpmListener", "dcomLoader", " dcmparser", "dgrReader", "DcmBuilder", "deromparser", "dpmAssistant", "deromParser", "drumParser", " dcmListener", "dpmarser", "decmParser", "drumBuilder", " dpmParser", "dmmarser", " dpmparser", "dcomReader", "dgrParser", "dcommReader", "dmoduleParser", " dpmStatement", "dpcReader", "deromarser", "dcmAssistant", " dcmPar", "dcommListener", "dpcAssistant", "dmoduleReader", "DpmBuilder", "dcmAdapter", "dcrReader", "dpmReader", "dfmReader", "dmmmReader", "decmarser", "dcomBuilder", "dpmPar", "dromAssistant", "dpmPrivate", " dcmBuilder", " dcmAssistant", "dpmParser", "dpmListener", "DcmParser", "dmmmparser", "dmoduleAssistant", "dcfPar", "dcmBuilder", " dcmPrivate", "decmparser", "dcmarser", "dmmparser", "dmparser", "dfmParser", " dcmStatement", "dromarser", "dcmListener", "DpmParser", " dpmarser", "dcmparser", " dcmReader", "dmmReader", " dpmLoader", "dcfParser", "dmmAdapter"], "ds": ["d", "ks", "sets", "js", "in", "ws", "DS", "services", "dat", "bd", "data", "pd", "Ds", "hd", "qs", "gd", "dq", "ins", "obs", "rs", "des", "os", "da", "ods", "ss", "hs", "details", "dd", "aos", "ads", "its", "der", "dx", "df", "vs", "sys", "dl", "eps", "sv", "dos", "ys", "dh", "cs", "uds", "eds", " DS", "drivers", "tes", "pers", "xs", "s", " des", "dds", "es", "fs", "sd", "as", "ims", "ps", "db", "outs", "dt", "bs", "ils", "ns", "gs", "ls"], "pdReader": ["tdReader", "ddLoader", "ddRunner", "xdLoader", "pedCar", "ddCar", "pedLoader", "tdParser", "pedReader", "hdWriter", "pdRead", "ddHelper", "pdCar", "pedRunner", "vdWriter", "pdParser", "vdLoader", "vdHelper", "dpLoader", "hdReader", "ddRead", "hdRead", "xdWriter", "ddReader", "vdReader", "dpRunner", "tdRead", "dpReader", "pdHelper", "pdLoader", "ddWriter", "dpCar", "ddParser", "hdParser", "tdWriter", "xdHelper", "pdRunner", "xdReader"], "out": ["cache", "list", "null", "in", "it", "data", "full", "ins", "desc", "msg", "c", "io", "client", "end", "sys", "we", "serv", "con", "go", "w", "t", "gr", "tmp", "o", "n", "to", "raw", "v", "pos", "ex", "inner", "flush", "at", "os", "over", "up", "Out", "cmd", "aos", " err", "cb", "ent", "sw", "id", "output", "pool", "p", "nt", "screen", "conn", "js", "oss", "err", "sum", "OUT", "one", "writer", "str", "ch", "nr", "opt", "s", "all", "en", "outs", "on", "gen", "obj", "inv", "res", "status", "name", "ou", "outer", "co", "log", "auto", "gt", "inter", "cfg", "net", "cn", "conv", "txt"], "dcmEncParam": ["dcmEscNum", "dcmencParam", "dmmencParam", "dcmDecCmd", "dcmEncPar", "dmmEncMsg", "dmmEncPar", "dcmencPar", "dcmencCmd", "dmmencNum", "dcmEncVal", "dmmEncParam", "dmmEncCmd", "dcmEscPar", "dcmEscVal", "dcmEnNum", "dmmEnPar", "dcmDecMsg", "dcmEncNum", "dcmEncCmd", "dmmEnNum", "dcmencMsg", "dmmencCmd", "dcmDecNum", "dcmEnVal", "dcmEnParam", "dcmEncMsg", "dmmencMsg", "dcmEscParam", "dcmencNum", "dmmEncNum", "dmmEnParam", "dmmEncVal", "dcmDecParam", "dcmEnPar"], "pdWriter": ["pdwriter", "dpWrite", "tdWriting", "pcWriting", "PDWriter", "pcwriter", "pidWriting", "pdWrite", "pdWriting", "PDReader", "PDWrite", "pdEditor", "tdWrite", "PDEditor", "tdwriter", "pidwriter", "pcWrite", "pidWriter", "pcWriter", "dpReader", "pidWrite", "dpEditor", "tdWriter", "tdReader", "tdEditor", "dpWriter"]}}
{"id1": "18793482", "id2": "20619879", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modureApplicationMsg", "modureApplicationmessage", "modifyAppData", "modureAppMsg", "modifyApplicationData", "modifyServerData", "modifyapplicationMessage", "modureApplicationMessage", "modifyServerMessage", "modureAppMessage", "modureAppmessage", "modifyApplicationmessage", "modureApplicationData", "modifyAppMsg", "modifyapplicationmessage", "modifyApplicationMsg", "modureAppData", "modifyServerMsg", "modifyAppMessage", "modifyapplicationMsg", "modifyAppmessage", "modifyServermessage", "modifyapplicationData"], "locale": ["regational", "LocALE", "localALE", "regales", "localaley", "regALE", "regale", "localational", "Locales", "locales", " locALE", "locational", "locALE", "Localey", " locales", "localales", " locational", " localey", "Locale", "Locational", "localale", "localey"], "messageName": ["msgType", "mediaKey", "mediaName", "MessageNAME", "messageNames", "MessageValue", "messageType", "msgKey", "MessageName", " messageNames", " messageKey", "mediaNames", "messageNAME", "messageKey", "msgValue", "msgName", "MessageType", " messageNAME", "MessageKey", " messageType", "mediaNAME", "MessageNames"], "messageValue": ["messageVALUE", "languageVALUE", "MessageValue", " messageVal", "messageType", "languagevalue", "MessageVALUE", "essageType", "MessageName", "messagevalue", "Messagevalue", "MessageVal", "essageName", "msgVALUE", "msgValue", "msgName", "MessageType", " messageType", "essageValue", "msgvalue", "languageName", "languageValue", "messageVal", "essageVal"], "properties": ["report", "types", "prop", "project", "settings", "policy", "data", "parts", "pid", "property", "options", "pro", "details", "json", "pdf", "files", " Properties", "utils", " props", "results", "metadata", "profile", "config", "params", "ps", "message", "perties"], "i18nPath": ["i18nePath", "i18rDir", "i18nP", "i8lDir", "i18neUrl", "i18nIf", "i8lStr", "i18bStr", "i18natDriver", "i18natPoints", "i18bPath", "i18neP", "i18nyPath", "i18rIf", "i18anIf", "i18lDir", "i18anPath", "i18nPoints", "i18nePoints", "i18rPath", "i18rDriver", "i18lPath", "i18anP", "i18nUrl", "i8nUrl", "i18anDir", "i18nDir", "i18neStr", "i18bDir", "i8lUrl", "i18nDriver", "i18lUrl", "i18bUrl", "i8nPath", "i18nyDriver", "i8nDir", "i8nStr", "i18natPath", "i18nyIf", "i18anDriver", "i18neDriver", "i18lStr", "i18nyDir", "i18anPoints", "i8lPath", "i18neDir", "i18nStr", "i18natP"], "englishFile": ["wikiPath", "enFilename", " englishPort", "ianaTable", "EnglishFilename", "languageFiles", "Englishfile", "electricFile", "ianaPort", "enFiles", "ianafile", " englishDirectory", "englishTable", "EnglishFiles", " englishDir", "englishfile", "englishFilename", " englishTable", "ianaFile", "languageFilename", "englishPath", "ianaDir", "languagefile", "wikiTable", " englishfile", "enfile", "englishDir", "electricPort", "EnglishFile", "englishPort", "englishFiles", "enFile", "wikiFile", "englishDirectory", "ianaPath", "electricDirectory", "ianaDirectory", "wikifile", "electricDir", " englishPath", "languageFile"], "propertiesFilePath": ["propertiesFilespath", "propertiesFilenameLocation", "settingsFilenameName", "propertiesFileName", "propertiesFilenameType", "propertiesfileLocation", "pertiesfileName", "propertiesFilesPath", "settingsFilenameLocation", "pertiesfilepath", "settingsFilenamepath", "propertiesFilepath", "settingsFileName", "propertiesfileType", "pertiesFileType", "propertiesFilesName", "propertiesfilepath", "settingsFilePath", "propertiesfileName", "settingsFilepath", "propertiesFilenameName", "pertiesFilepath", "pertiesFileName", "propertiesFilesType", "settingsFilenamePath", "pertiesfileType", "pertiesFilePath", "propertiesFileLocation", "propertiesFilenamePath", "pertiesfilePath", "propertiesFileType", "propertiesFilenamepath", "propertiesFilesLocation", "propertiesfilePath", "settingsFileLocation"], "file": ["entry", "rule", "report", "print", "null", "record", "use", "create", "data", "key", "xml", "filename", "string", "image", "base", "name", "os", "table", "document", "io", "language", "type", "fi", "attribute", "f", "ile", "style", "channel", "fp", "class", "connection", "application", "write", "files", "module", "domain", "comment", "info", "be", "port", "resource", "File", "format", "handle", "local", "library", "result", "complete", "model", "console", "content", "object", "output", "run", "path", "message", "page", "pool", "buffer", "FILE", "current", "parent", "source"], "in": ["inf", "oin", "IN", "inc", "it", "al", "inner", "cin", "ins", "input", "reader", "ind", "rin", "bin", "ir", "In", "ini", "io", "inside", "ar", "isin", "init", "iter", "asin", "ri", "ai", "gin", "from", "read", "en", "get", "ain", "inn", "sin", "ic", "din", "i", " din"], "out": ["o", "to", "n", "print", "screen", "cache", "csv", "ex", "it", "inner", "cos", "OUT", "at", "os", "Out", "ou", "io", "aos", "external", "again", "end", "outer", "we", "co", "write", "con", "put", "check", "w", "log", "sw", "can", "set", "conf", "output", "outs", "net", "conv", "nt"], "c": ["d", "n", "v", "cache", "code", "ac", "ca", "l", "cd", "cp", "lc", "k", "cos", "chain", "\u00e7", "call", "arc", "dc", "cf", "col", "char", "ct", "cont", "count", "fc", "u", "nc", "rc", "cr", "co", "ch", "cap", "cb", "con", "pc", "unc", "cs", "mc", "ce", "t", "gc", "etc", "cod", "cl", "bc", "C", "cm", "conf", "r", "ec", "i", "cc", "x", "cu", "character"], "is": ["ris", "isi", "it", "bis", "lis", "sis", "isa", "ins", "ais", "os", "tis", "its", "IS", "Is", "isf", "sys", "isin", "iso", "\u00eds", "ios", "nis", "ri", "iss", "es", "sit", "iris", "as", "isl", "ic", "isc", "i"], "breader": ["bler", "breadber", " breadber", " breadder", "breadar", "bbder", "breadr", "browber", "bbar", "brewer", "breade", "bbr", "bber", "brewber", " breadr", "breadger", " breadar", " breade", " breadger", "browger", "bleder", "blear", "brewger", "bleer", "browe", "brower", "brewe", "breadder"], "line": ["entry", "ip", "rule", "parse", "link", "continue", "code", "l", "record", "detail", "lin", "eline", "header", "node", "edge", "body", "chain", "no", "label", "string", "entity", "lines", "lo", "stroke", "sequence", "cmd", "trace", "char", "email", "side", "queue", "cell", "inline", "Line", "ine", "row", "online", "stay", "mail", "phrase", "nl", "note", "sample", "liner", "comment", "section", "column", "ln", "block", "iter", "word", "port", "next", "normal", "le", "LINE", "lane", "handle", "range", "se", "log", "part", "ice", "query", "point", "shell", "message", "left", "page", "slice", "frame", "text"], "strBuilder": ["StrBuffer", "StrParser", "objbuilder", "strParser", " strParser", "StrBuilder", "arrBuffer", "StrBuilt", "strBuilt", "arrBuilder", "StrBuild", "strbuilder", "frBuilder", "strBuffer", "strBuild", " strBuffer", "stringBuilder", "stringBuffer", "arrbuilder", "frBuild", "stringbuilder", "frParser", "StrBu", "arrBu", "objBuild", " strbuilder", "stringBuilt", "stringParser", "arrParser", "arrBuild", "strBu", "Strbuilder", " strBuild", " strBu", "frBuilt", "objBuilder", "objBuffer", "stringBuild"], "pieces": ["Parts", "strings", "types", "words", "blocks", "ops", "services", "times", "pins", "tools", "parts", "keys", "knife", "plates", "powers", "lines", "pointers", "links", "caps", "xes", "places", "its", "ctors", "fixes", "feet", "eps", "ces", "bits", "steps", "bytes", "letters", "cars", "tips", "sts", "ties", "checks", "piece", "fits", "groups", "items", "players", "cuts", "sections", "ps", "rings", "maps", "units", "terms", "finals"], "found": ["done", "ed", "forced", "err", "changed", " caught", "printed", " Found", "bool", "index", "failed", "loaded", "available", "identified", "sold", " founded", "opened", "used", "expected", "Found", "built", "mounted", "count", "valid", "first", "compl", "installed", "finder", "old", "sent", "supported", "search", "defined", "confirmed", "created", "read", "needed", "successful", "success", "find", "started", "fixed", "good", "filled", "empty", " detected", "given", "focused", "finished", "released", "tested"]}}
{"id1": "13024538", "id2": "4852691", "code1": "    public static String getHash(String uri) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(uri.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"getHash": ["gethash", "GetKey", " getSum", "createKey", "createHash", "getKey", "createSum", "GetSum", "GetHash", "Gethash", " gethash", " getKey", "createhash", "getSum"], "uri": ["su", "http", "wiki", "ui", "link", " URI", "html", "address", "q", "filename", "uni", "via", "msg", "name", "iu", "ou", "requ", "io", "password", "description", "subject", "u", "unit", "ur", "dir", "du", "uu", "URI", "ri", "url", "resource", "file", "course", "har", " ur", "this", "path", "message", "remote", "qi", "source"], "mDigest": ["hdiget", "ddigester", "mDigUse", "mDefake", "mDests", "hdigester", "mDefse", " mDigse", "mCritUse", "mDake", "mDesignest", "mDiget", "mdigest", " mDer", "mDest", "mDester", "hDigests", "mDet", "hDigester", "mDiger", "dDigUse", "mModake", "mModest", "mdigester", "mDesignests", "mdigests", "mDigests", "mdiget", " mDest", "hdigests", "mDefest", "mDesignester", "mDigester", "ddigUse", "hDiget", "mdigUse", "hDigest", "mDer", " mDse", " mDake", "mDigake", "dDigester", "mModse", "mDse", " mDiger", "dDigest", "mCritester", "mDesignet", "mModer", "mDefer", "ddigest", " mDigake", "mDigse", "mCritest", "hdigest"], "d": ["m", "done", "v", "b", "n", "ed", "dim", "l", "ld", "md", "cd", "dat", "bd", "data", " D", "pd", "dict", "h", "dist", "p", "dot", "ind", "des", "c", "da", "dd", "df", "j", "nd", "dig", "dh", "td", "dec", "with", "t", "s", "diff", "sd", "def", "g", "dm", "db", "de", "ds", "D"], "hash": ["report", "summary", "shadow", "print", "sh", "bh", "cache", "ash", "html", "ssh", "header", "key", "h", "sum", "test", "filter", "memory", "square", "address", "user", "reset", "window", "total", "esh", "array", "transform", "shape", "used", "bar", "random", "Hash", "password", "echo", "build", "ah", "hex", "block", "check", "now", "search", "dump", "always", "oh", "map", "host", "output", "hz", "message", "tag", "shift", "buffer", "archive"], "i": ["m", "multi", "v", "ip", "ci", "ui", "yi", "in", "it", "err", "ex", "ei", "gi", "span", "ji", "I", "q", "phi", "us", "index", "ind", "im", "\u0438", "y", "ini", "li", "is", "gu", "io", "ski", "ii", "fi", "ie", "bi", "u", "pi", "j", "ms", "a", "init", "cli", "ri", "ai", "sim", "mi", "ti", "ix", "hi", "point", "di", "ims", "my", "ic", "x", "si", "xi", "qi", "zi"]}}
{"id1": "21438069", "id2": "10715601", "code1": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"createNewProjectDeploymentConfig": ["createNewProjectDeploymentsConfiguration", "createNewProjectDeployationConfig", "createNewProjectDeployationConfiguration", "createNewProjectDeployingConf", "createNewProjectDeploymentConf", "createNewProjectDevelopingConfiguration", "createNewProjectDevelopmentConf", "createNewProjectDeploymentConfiguration", "createNewProjectDevelopingCmd", "createNewProjectDeploymentsCmd", "createNewProjectDeployingCmd", "createNewProjectDeployingConfig", "createNewProjectDeployationConf", "createNewProjectDevelopingConf", "createNewProjectDeployingConfiguration", "createNewProjectDevelopmentConfiguration", "createNewProjectDevelopmentConfig", "createNewProjectDeploymentCmd", "createNewProjectDeploymentsConfig", "createNewProjectDeployationCmd", "createNewProjectDeploymentsConf", "createNewProjectDevelopingConfig", "createNewProjectDevelopmentCmd"], "projectID": ["appName", "applicationComplete", " projectType", " projectid", "appID", "applicationIDs", "portid", "ProjectID", " projectComplete", "ProjectId", "projectIC", "projectIDs", "ProjectComplete", "archiveIC", " projectName", "archiveID", "ProjectIDs", " projectId", "applicationID", "portId", "portID", "ProjectED", " projectED", "ProjectName", "portED", "ProjectIC", "projectName", "appId", "projectED", "projectComplete", "Projectid", "projectType", " projectIC", "appid", "archiveId", "archiveType", "projectId", "ProjectType", "projectid", " projectIDs"], "name": ["n", "to", "command", "named", "Name", "key", "NAME", "alpha", "address", "data", "filename", "property", "unique", "label", "term", "username", "image", "about", "base", "admin", "sequence", "prefix", "error", "license", "type", "item", "author", "definition", "number", "alias", "class", "common", "ame", "title", "comment", "old", "version", "info", "position", "word", "size", "search", "names", "resource", "value", "local", "format", "part", "id", "initial", "order", "ident", "family", "instance", "parent", "source"], "description": ["cription", "summary", "resolution", "usage", "NAME", "address", "body", "function", "Description", "environment", "question", "filename", "desc", "directory", "database", "expression", "information", "response", "edition", "template", "about", "video", "des", "document", "sequence", "escription", "license", "language", "password", "definition", "type", "DES", "media", "phrase", "title", "comment", "version", "position", "word", "metadata", "value", "reason", "library", "creation", "direction", "release", "exclusive", "termination", "reference", "message", "display"], "config": ["acc", "ca", "cache", "conn", "ac", "project", "np", "it", "oc", "proc", "desc", "p", "c", "loc", "admin", "cert", "cf", "cmd", "Config", "ct", "adj", "cont", "rc", "comment", "con", "setup", " fig", "fig", "cur", "com", "apache", "result", "log", "etc", "set", "def", "sc", "bc", "spec", "cfg", "content", "g", "conf", "component", "output", "db", "temp", "control", "tc", "quit"], "connection": ["entry", "link", "conn", "command", "condition", "operation", "settings", "generation", "network", "usage", "pointer", "socket", "session", "server", "function", "city", "system", "location", "database", "directory", "information", "response", "Connection", "document", "open", "license", "collection", "writer", "client", "engine", "device", "associated", "bo", "subject", "we", "context", "sql", "application", "con", "manager", "ce", "established", "position", "connect", "ion", "resource", "library", "close", "set", "console", "initial", "relation", "management", "db", "reference", "net", "channel", "communication", "line"], "statement": [" Statement", "command", "condition", "policy", "usage", "network", "session", "function", "execute", "server", "chain", "memory", "processor", "Statement", "system", "database", "journal", "expression", "response", "directory", "state", "template", "volume", "status", "Connection", "document", "sequence", "writer", "trace", "bo", "subject", "sql", "unit", "ment", "stat", "note", "echo", "application", "phrase", "comment", "sp", "request", "mt", "resource", "t", "confirmed", "se", "library", "set", "storage", "relation", "management", "shell", "message", "reference", "instance", "tree"], "resultSet": ["eventStream", "ruleS", "rowSet", "specInfo", " resultExport", "resourceSet", "resultS", "ResultS", "rowS", "answerInfo", " resultEx", "resultInfo", "ResultEx", "resultSET", "answerSET", "resSet", "specSet", "resset", "ruleset", "ResultSET", " resultS", "specSET", "specExport", " resultStream", "answerExport", "resS", "resultset", "eventset", "resourceEx", "resultExport", "rowSET", "resultStream", "ResultTime", "resultTime", "ruleSET", "answerSet", "rowset", "ruleSet", "eventSet", " resultInfo", "resourceS", "ResultSet", " resultSET", "ResultStream", "Resultset", "resultEx", " resultset", "eventTime", " resultTime", "resourceset"], "query": ["menu", "parse", "link", "command", "condition", "key", "q", "question", "test", "call", "string", "ql", "Query", "ERY", "sequence", "quest", "table", "style", "send", "sql", "unit", "scope", "note", "script", "init", "title", "comment", "qu", "where", "request", "how", "module", "check", "sq", "search", "service", "update", "sort", "find", "quote", "spec", "content", "get", "lock", "message", "eries", "join", "select", "uri"], "msg": ["m", "print", " message", "mg", "gen", "md", "ex", "err", "html", "pkg", "sum", "meg", "desc", "doc", "string", "ext", "req", "mu", "gp", "ung", "med", "error", "notice", "cmd", "char", "warn", "str", "mail", "gm", "sql", "ge", "mem", "ms", "bg", "em", "title", "Msg", "e", "txt", "cmp", "og", "mt", "mun", "urg", "mn", "gem", "gin", "reason", "sm", "log", "nm", "say", "mag", "mor", "cfg", "g", "dm", "bug", "gr", "rup", "gor", "message", "sg", "gmail", "mess", "gs", "text"]}}
{"id1": "6301863", "id2": "2982747", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {\n        this.inFile = fileStr;\n        this.type = type;\n        System.out.println(\"File str \" + fileStr);\n        if (fileStr.indexOf(\"http://\") == 0) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"File\")) {\n            File inFile = new File(fileStr);\n            size = inFile.length();\n            inStream = new FileInputStream(inFile);\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URL\")) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URLZip\")) {\n            URL url = new URL(fileStr);\n            inStream = new GZIPInputStream(url.openStream(), 16384);\n            InputStreamReader zis = new InputStreamReader(inStream);\n            bufReader = new BufferedReader(zis, 16384);\n        } else {\n            System.out.println(\"Unknown FileParse inType \" + type);\n        }\n    }\n", "label": 0, "substitutes": {"doRawRequest": ["sendRawCall", "doNativeRequest", "doHttpAction", "sendRawRequest", "doHttpQuery", "doRawCall", "doRawQuery", "sendRawQuery", "sendHttpCall", "doRawAction", "doDirectRequest", "sendRawAction", "sendHttpAction", "doNativeQuery", "doNativeCall", "doDirectCall", "sendHttpQuery", "sendHttpRequest", "doNativeAction", "doDirectQuery", "doDirectAction", "doHttpCall", "doHttpRequest"], "postData": ["postedString", "requestMessage", "postedData", "postMessage", "requestDATA", "preMessage", "preDATA", "PostMessage", "Postdata", "postBody", "postString", "requestData", "PostData", "postDATA", "POSTMessage", " postdata", "POSTBody", "requestBody", "preBody", " postMessage", "postdata", " postString", "posteddata", "preData", "POSTData", "PostString", "POSTDATA", "postedMessage"], "url": ["http", "pl", "link", "web", "l", "ld", "ll", "pkg", "rel", "re", "hl", "lb", "loc", "cert", "cmd", "google", "client", "www", "str", "ul", "mail", "abs", "ssl", "dl", "ret", "org", "build", "ur", "nl", "bel", "mount", "con", "https", "URL", "gl", "Url", "sl", "addr", "ls", "uri"], "conn": ["syn", "l", "pt", "pg", "cp", "resp", "canon", "rel", "res", "Conn", "inv", "exec", "c", "loc", "jp", "open", "cert", "cmd", "col", "ct", "client", "comm", "fin", "cont", "gn", "enc", "org", "connection", "j", "iw", "nc", "ch", "act", "ssl", "sys", "cb", "con", "nec", "cur", "pas", "connect", "com", "close", "addr", "net", "ns", "cn", "conv", "nt"], "wr": ["wk", "rew", "rw", "pr", "fw", "wp", "spr", "wx", "dr", "kr", "Writer", "wer", "wt", "writer", "wid", "nw", "dx", "wd", "iw", "wy", "writ", "write", "vet", "rou", "w", "Wr", "RW", "mk", "wb", "wm", "mr", "sw", "kl", "vr", "tn", "hr", "fr", "r", "lr", "WR", "wn"], "rd": ["rect", "pr", "rw", "RD", "ld", "nder", "rn", "rt", "rl", "rob", "ro", "rh", "rend", "rar", "reader", "adr", "dr", "rs", "rog", "rx", "rand", "rpm", "rb", "rod", "dd", "rer", "red", "rc", "cr", "nd", "ru", "ptr", "ri", "rid", "rr", "mr", "erd", "hr", "fr", "r", "ra", "sr", "ry"], "sb": ["pb", "b", "bj", "sh", "bh", "bis", "RB", "bd", "rob", "obs", "zb", "lb", "bt", "bps", "lbs", "rb", "bp", "gob", "ob", "bag", "abs", "sa", "bn", "sv", "lp", "bf", "sp", "bg", "cb", "ib", "sf", "obb", "kb", "sth", "gc", "sm", "bsp", "sd", "gb", "bb", "eb", "xb", "nb", "mb", "bs", "sg", "si", "erb", "SB", "sq"], "line": ["entry", "rule", "code", "link", "print", "list", "l", "lin", "eline", "header", "chain", "pe", "label", "string", "entity", "stroke", "name", "sequence", "style", "number", "cell", "row", "Line", "ine", "inline", "stay", "valid", "phrase", "nl", "e", "sample", "liner", "comment", "ln", "block", "word", "zone", "check", "le", "LINE", "file", "log", "ice", "point", "message", "page", "display", "buffer", "frame", "text"]}}
{"id1": "5620792", "id2": "23199071", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "label": 0, "substitutes": {"SHA1": ["HS2", " SHAOne", "sha1", "SHA2", " SHA2", "HS256", " SHA256", "HSOne", "SHAOne", "shaOne", "sha2", "sha256", "SHA256", "HS1"], "text": ["code", "print", "pt", "data", "key", "test", "q", "input", "string", "term", "ext", "msg", "template", "name", "document", "prefix", "TEXT", "password", "form", "ct", "str", "cont", "subject", "act", "comment", "word", "url", "value", "t", "pattern", "read", "config", "tx", "current", "content", "event", "output", "nt", "message", "path", "translation", "out", "Text", "txt", "select", "source"], "HASH_VALUE_SIZE": ["HASH_VALUE_TYPE", "HASH_value_DIR", "HASH_VALUE_Size", "HASH_value_SIZE", "HASH_VAL_NAME", "HASH_VAL_Size", "HASH_VALUE_NAME", "HASH_VALUE_NO", "HASH_value_TYPE", "HASH_VAL_SIZE", "HASH_VALUE_DIR", "HASH_VALUE_SOURCE", "HASH_value_SOURCE", "HASH_VAL_NO"], "md": ["d", "m", " ms", "mg", " cmd", "ad", "cd", " sd", " Md", "mand", "ld", "js", "bd", "ctr", "h", "pd", "hd", "grad", "MD", " mm", "mm", "det", " man", "od", "ind", "cond", " mc", "mod", "cmd", "dd", "mond", " ma", "der", "df", " del", " dd", "ms", "nd", "dig", "dir", "and", "dh", "td", "mc", " rm", "mt", "mn", "add", "metadata", "rm", "mp", "mk", "sm", "sd", "mode", "hm", "dm", "mb", " mo", "ds", " cd"], "sha1hash": ["sha1str", "sha1result", "sha31hash", " SHA1sum", " SHA1have", "SHA1Hash", "SHA1hash", "shaonesum", "sha3hash", "sha5value", "sha1sum", "SHA2hex", "sha1Hash", "ha2Hash", "ha1hash", "ha2hash", "SHA2Hash", "SHA1hex", "sha2Hash", "sha5hash", "sha1hex", "sha2have", "sha2hash", "sha31have", "shaoneresult", " SHA31sum", "sha2value", "SHA2str", "sha31value", "ha1result", "sha5sum", "shaoneHash", "sha7hash", "sha3str", " SHA31have", "sha2result", "sha7hex", "ha1Hash", "sha2str", "sha7str", " SHA1value", "sha1value", "SHA2hash", "ha2sum", "sha5have", "sha3hex", " SHA1hash", "sha3Hash", "sha7Hash", "sha2hex", " SHA31hash", " SHA31value", "sha2sum", "sha31sum", "shaonehash", "ha1sum", "SHA1str", "sha1have", "ha2result"]}}
{"id1": "10218878", "id2": "4468255", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFromFile", "DecodeToLog", "DecvertMAPLog", "DecodeFromfile", "DecodeMAPfile", "DecodeToFile", "DecvertMAPFiles", "DecodeMAPFiles", "DecodeToFiles", "DecodeMapfile", "DecvertMAPfile", "DecvertMapfile", "DecodeMAPFile", "DecodeTofile", "DecodeMAPLog", "DecvertMAPFile", "DecvertMapFile", "DecodeMapLog", "DecodeFromLog", "DecvertMapLog", "DecodeMapFiles", "DecvertMapFiles", "DecodeFromFiles"], "mapFile": ["mapPath", "mapStream", " mapStream", "MapFile", " mapFilename", "cachePath", "imageStream", "Mapfile", "cacheFile", "imageFilename", "mapfile", "MapStream", "mapFilename", "listPath", "imagefile", "listFile", "imageFile", "mapFILE", " mapfile", " mapPath", " mapFILE", "cacheFILE", "listFILE", "MapFilename"], "outputFile": ["outDir", "writeStream", "writeDir", "mapName", " outputPath", "mapStream", "OutputFilename", "outputName", " outputFilename", "outputPath", "inputFile", "outFilename", "outputFilename", "outputStream", "inputDir", "outPath", " outputDir", "OutputPath", "writeName", "outputDir", "inputName", "OutputFile", "inputStream", "OutputDir", "writeFile", "outFile", "mapDir"], "magicKey": ["serialKEY", "magicValue", "magicCounter", "prefixCode", "uniqueValue", " magicCode", "magickey", " magicCounter", "MagicKey", "anticKey", " magicKEY", "uniqueKey", "encryptedkey", "magicField", "magicChar", "magicId", " magickey", "encryptedChar", "magicKEY", " magicChar", "prefixValue", "MagicName", "anticChar", "serialName", "MagicId", "uniqueCode", "encryptedKey", "prefixKey", " magicField", "serialId", " magicValue", "anticField", "magicName", "MagicKEY", "serialKey", "encryptedField", "magicCode", "prefixCounter", "uniqueCounter", " magicName", "antickey", " magicId"], "buffer": ["batch", "cache", "print", "code", "command", "Buffer", "screen", "detail", "header", "black", "sum", "filter", "memory", "paste", "index", "window", "total", "database", "template", "base", "bone", "stroke", "shape", "button", "table", "document", "sequence", "attribute", "program", "char", "pad", "flash", "buf", "queue", "row", "bo", "mem", "phrase", "sample", "buff", "append", "stack", "iter", "block", "vector", "check", "stream", "variable", "binary", "initial", "message", "display", "page", "history", "length", "frame", "bridge"], "nread": [" ntry", " nwrite", "rnREAD", "rawwrite", "maxread", "maxadd", "maxget", "nREAD", "ncreadable", "Nread", "nget", "Nget", "nadd", "ncread", "Nadd", "NREAD", "ncget", "maxRead", " nreader", "rnread", "nwrite", "renreader", "nRead", "NRead", "ncRead", "renread", "Nwrite", "rawtry", "rnRead", "Nreadable", "renwrite", "rawread", "nreader", "rawreader", "ncwrite", "rnwrite", " nREAD", " nRead", " nreadable", "rentry", "ntry", "nreadable", "ncadd"], "map": ["man", "m", "pl", "ip", "parse", "cache", "batch", "collect", "mate", "ap", "address", "memory", "window", "image", "load", "shape", "mod", "up", "table", "apper", "down", "meta", "open", "pack", "form", "clear", "mem", "co", "module", "where", "mount", "ace", "con", "manager", "block", "MAP", "mt", "com", "ape", "file", "mp", "mask", "aps", "master", "ml", "config", "read", "make", "set", "op", "view", "cm", "pose", "lock", "per", "app", "place", "maps", "apping", "bridge"], "output": ["o", "batch", "cache", "print", "web", "hidden", "socket", "network", "four", "blue", "target", "input", "entity", "response", "secure", "ou", "open", "oe", "latest", "client", "outer", "queue", "icon", "other", "write", "put", "block", "port", "ilo", "stream", "next", "format", "file", "log", "auto", "result", "plain", "exit", "can", "update", "console", "object", "Output", "display", "net", "out", "online", "current"], "i": ["m", "b", "v", "ip", "ci", "ui", "n", "batch", "multi", "it", "ji", "ei", "gi", "span", "ami", "q", "phi", "us", "index", "spin", "ind", "y", "ini", "ii", "li", "is", "gu", "iu", "fi", "ie", "bi", "ish", "pi", "u", "j", "x", "ms", "cli", "ri", "ai", "sim", "t", "mi", "ti", "ix", "ni", "id", "g", "di", "ic", "I", "si", "xi", "qi", "uri"]}}
{"id1": "14001795", "id2": "8430178", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyoverwarFiles", "copyOverTarFilename", "copyOverwarfile", "copyOverTarfile", "copyOverWarFilename", "copyOverWarfile", "copyoverwarFile", "copyoverWarfile", "copyOverwarFile", "copyOverTarFiles", "copyoverWarFilename", "copyOverwarFiles", "copyOverwarFilename", "copyoverwarFilename", "copyoverWarFiles", "copyoverwarfile", "copyOverWarFiles", "copyoverWarFile", "copyOverTarFile"], "dir": ["d", "dim", "disk", "md", "ld", "cd", "dat", "dial", "direct", "desc", "rel", "res", "doc", "folder", "dist", "DIR", "directory", " directory", "dr", "ind", "re", "window", "ir", "name", "loc", "dd", "form", "fin", "df", "wd", "dl", "vol", " Dir", "old", "div", "iter", "cur", " d", "add", "coll", "file", "url", "dep", "local", "fd", "mk", "log", "del", "def", "good", "dm", "zip", "di", "db", "addr", "tmp", "path", "out", "Dir", "parent"], "ff": ["aff", " af", "FF", "alf", "ld", "ffe", "filter", "wind", "tf", "xf", " eff", "F", "cond", " aft", "uf", "ft", "cf", "xff", "iff", "df", "fp", "fc", "fg", " FF", "bf", "buff", "cb", "off", "mt", "sf", "af", " cf", " ref", "eff", "file", "UFF", "fd", "lf", "aft", " def", "fl", "ef", "fact", "uff", " df", "fx", "ck"], "files": ["frames", "objects", "forms", "images", "mas", "members", "keys", "parts", "uploads", "plates", "features", "lines", "iles", "ories", "bees", "assets", "ails", "leases", "balls", "les", "tests", "facts", "issues", "Files", "ls", "resources", "jobs", "names", "file", "items", "fs", "days", "models", "ions", "fields", "styles", "faces", "values", "ports", "flows", "rows"], "f": ["d", "b", "fa", "v", "n", "m", "l", "alf", "fe", "h", "fw", "k", "tf", "fab", "F", "xf", "elf", "c", "uf", "cf", "ft", "rf", "col", "fp", "fc", "bf", "fm", "e", "fac", "sf", "w", "file", "t", "fd", "fs", "exp", "lf", "fl", "def", "g", "a", "i", "p"], "newFile": ["NewFilename", "NewFile", "newsfile", "securefile", "newFiles", "newsFile", "NewPage", "newfile", "newNode", "secureFile", "uniqueNode", "secureKey", "NewNode", "newPlace", "anotherFile", "anotherPlace", "newPage", "NEWNode", "newKey", " newfile", "NEWFile", "oldFile", "newFilename", "oldFilename", "NEWfile", "uniqueFile", "uniquefile", " newPlace", "anotherfile", "oldfile", "newsKey", "NEWPage", " newFilename", "Newfile", "NewKey", "uniquePage", " newFiles", "NewFiles", "NewPlace", "anotherFiles"], "fi": ["fa", "ci", "isi", "fe", "phi", "ifa", "afi", "flo", "ki", "si", "ini", "iu", "ii", "io", "cf", "li", "uf", "fin", "bi", "fp", "pi", "bf", "ife", "sf", "ri", "fd", "mi", "ni", "lf", "fr", "di", "FI", "ti", "i", "Fi", "zi"], "fo": ["o", "tto", "ho", "jo", "sty", "tf", "tif", "fam", "ott", "wo", "xf", "hea", "flo", "ki", "wt", "zz", "oe", "cf", "tk", "uo", "bo", "co", "FO", "ko", "ow", "opa", "sf", "te", "eto", "zo", "eno", "ph", "vo", "ato", "oooo", "mo", "oo", "po", "ti", "hi"]}}
{"id1": "6987642", "id2": "21999120", "code1": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 1, "substitutes": {"encodePassword": ["Encodepassword", "enodeValue", "encodedPass", "EncodeValue", "EnodePassword", "enlatepassword", "EnodePass", "encodepassword", "enodepassword", "enlateValue", "enlatePassword", "EncodePassword", "enodePass", "encodePass", "encodedValue", "EnodeValue", "enlatePass", "EncodePass", "Enodepassword", "enodePassword", "encodedpassword", "encodeValue"], "password": ["Password", "shadow", "secret", "command", "data", "address", "key", "reset", "user", "pass", "input", "string", "padding", "database", "username", "token", "sword", "name", "login", "expected", "prefix", "description", "attribute", "random", "email", "wd", "phrase", "word", "value", "pattern", "hello", "default", "message", "path", "text", "p"], "md": ["d", "m", " mt", " ms", "mg", " cmd", "ad", "cd", "ld", " Md", "mand", "bd", "pd", "hd", "grad", "MD", "mm", "det", "od", "ind", "dr", "pm", "exec", "msg", " mc", "mod", " mg", "cmd", "dd", "mond", " mac", "red", "der", "df", " dd", "bf", "ms", "nd", "dh", "mc", " rm", "mt", "mn", "metadata", "add", "ke", "rm", "mp", "mk", "sm", "sd", "hm", "mo", "dm", "di", "mb", " mo", "sha", " cd", "nt"], "encodedPassword": ["equatedpassword", "ecodedSecret", "encodingpassword", "encatedString", "ecodedString", "encatedConnection", "encachedString", "ecodedpassword", "encryptedPassword", "equodedPassword", "ecodingSecret", "encodingString", "equodedpassword", "encatedPassword", "equatedPassword", "encatedSecret", "encodedString", "ecodedPassword", "ecodingString", "encodedUser", "encatedpassword", "encryptedConnection", "encatedUser", "encryptedpassword", "encodingSecret", "encryptedUser", "encodedSecret", "encodingPassword", "equatedUser", "encachedpassword", "equodedUser", "encachedSecret", "encachedPassword", "ecodingPassword", "encodedConnection", "encodedpassword", "encodingUser", "encodingConnection", "equodedConnection", "equatedConnection", "ecodingpassword"]}}
{"id1": "16556717", "id2": "18370075", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "label": 1, "substitutes": {"getSHADigest": ["getSHADigester", "getSHAdigse", "getSHADDigester", "getSHAdegester", "getSHADdigest", "getSHADDigests", "getSHADDigse", "getSHAdigest", "getSHAdegest", "getSHADdigester", "getSHADdigse", "getSHADigse", "getSHADigests", "getSHADdigests", "getSHAdegse", "getSHADDigest", "getSHADegester", "getSHADegest", "getSHAdegests", "getSHAdigests", "getSHADegests", "getSHAdigester", "getSHADegse"], "password": ["Password", "secret", "words", "command", "data", "key", "address", "reset", "hash", "session", "user", "pass", "input", "string", "padding", "database", "username", "response", "token", "sword", "name", "login", "prefix", "description", "email", "wd", "phrase", "auth", "word", "w", "value", "pattern", "id", " Password", "message", "text"], "digest": ["digment", " digment", "Digested", "decester", "mentester", "dEST", "mentest", " digist", "Digest", " digested", " digEST", "dist", "Digist", "Digment", "Dighash", " dighash", "hashest", "igse", "DigEST", "digested", "dighash", "diggest", "decest", "decgest", " digse", "hashment", "digEST", "Digse", "igest", "digester", "decEST", "ighash", "hashested", "Diggest", "mentgest", "mentEST", "igEST", "digist", "dested", "dest", "digse", "hashEST", "Digester"], "sha": ["shared", "ca", "sh", "access", "ppa", "md", "HA", "sche", "shi", "ssh", "alpha", "sum", "has", "ho", "SHA", "phi", "hash", "no", "lambda", "na", "git", "mac", "si", "tar", "da", "asha", "ya", "ha", "ssl", "wa", "sa", "pi", "api", "qa", "ah", "sam", "func", "ta", "wal", "iso", "ka", "ma", "ao", "go", "acl", "auto", "po", "addr", "shell", "a", "hi", "sq", "pa"], "pwhash": ["pWHash", "pthashed", "pthat", "pswashed", "pWHhash", "pthash", " pswashed", " pwhat", "pswash", " pswat", "psway", "pwhay", " pswhash", " psway", "pWHashed", "pwhhash", "pwhashed", "pthhash", "pswhash", "pshash", " pswash", "pshashed", " pwhay", "pWHay", " pwhhash", "pswat", "pshay", "pWHat", " pwhashed", "pshhash", "pwhat"]}}
{"id1": "21063400", "id2": "8983517", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public User getUser(String userlogin) {\n        UserDAO userDAO = new UserDAO();\n        User user = null;\n        try {\n            user = userDAO.load(userlogin);\n            if (user == null) {\n                URL url = Thread.currentThread().getContextClassLoader().getResource(\"users.cfg\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                String linea = br.readLine();\n                while (linea != null) {\n                    StringTokenizer st = new StringTokenizer(linea, \":\");\n                    if (st.countTokens() == 3) {\n                        String login = st.nextToken();\n                        String password = st.nextToken();\n                        String profile = st.nextToken();\n                        if (login.equals(userlogin)) {\n                            user = new User(login, password, profile);\n                            userDAO.save(user);\n                        }\n                    } else {\n                    }\n                    linea = br.readLine();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return user;\n    }\n", "label": 0, "substitutes": {"doImageProcess": ["doItemImageSort", "doItemImageProcess", " doImageprocess", " doImagesSort", " doImagesProcess", "doMediaWork", " doImageSort", " doImageWork", "doMediaprocess", "doImagesSort", "doImagesWork", "doItemImageprocess", "doImageSort", "doImagesprocess", " doImagesprocess", " doImagesWork", "doMediaProcess", "doImagesProcess", "doImageprocess", "doImageWork", "doMediaSort", "doItemImageWork"], "request": ["command", "address", "server", "session", "question", "input", "re", "image", "template", "document", "quest", "attribute", "client", "context", "application", "version", "resource", "Request", "start", "QUEST", "query", "model", "view", "reference", "message", "frame", "select"], "response": ["http", "report", "entry", "cache", "print", "continue", "list", "detail", "network", "xml", "resp", "server", "respond", "reset", "site", "hash", "res", "user", "onse", "re", "window", "image", "status", "one", "answer", "document", "sequence", "description", "collection", "json", "connection", "parent", "application", "write", "reply", "version", "position", "block", "ve", "next", "search", "format", "Response", "result", "exit", "model", "success", "query", "console", "content", "relation", "view", "output", "fire", "message", "page", "display", "frame", "tree"], "imgSize": [" imgName", "dimsize", "imagError", "imageSIZE", "dimSIZE", "propName", "certScale", "augSize", "certSIZE", "imageInfo", " imgShape", "imageScale", "divSIZE", "imgsize", "augOwner", " imgType", "imgInfo", "imgStyle", " imgsize", "divsize", "divSize", "imgScale", "appStyle", "certSize", "appShape", "imgShape", "appSize", " imgInfo", "augsize", "appsize", "certName", "imagSize", "imgOwner", "imagName", "propsize", "augShape", "imageStyle", "appType", " imgOwner", " imgStyle", "imageSize", " imgSIZE", "imgError", "dimSize", "imgSIZE", "imgName", "appInfo", " imgScale", "propSize", " imgError", "appOwner", "propError", "imgType", "imagsize", "imageName", "imageType"], "imageInputStream": [" imageInputPath", "imageOutputSteam", "imageInStream", "fileRawStream", "fileInputStream", "imageIntPath", "imageInterfaceStream", "imageInputSteam", "imageInSteam", "photoIntstream", "imageByteStream", "fileRawSteam", " imageStreamPath", "imageRawView", "fileRawstream", "imageByteForm", "mediaInputForm", "imageInputPath", "imageStreamPath", "imageRawstream", "imageInputView", "imageInstream", "mediaInputReader", "imageByteReader", "photoIntStream", "photoIntSteam", "imageStreamSteam", "mediaInputSteam", "imageInputReader", "fileInputSteam", " imageStreamStream", "imageRawStream", "imageInterfaceSteam", "imageIntStream", "imageByteSteam", "imageStreamStream", "imageOutputstream", "imageIntstream", "imageOutputForm", "imageOutputReader", "imageInterfaceView", "imageOutputStream", "photoInputstream", "imageInputstream", "fileInputView", "imageRawSteam", "mediaInputStream", " imageStreamSteam", "imageIntSteam", " imageInputSteam", "photoInputSteam", "imageInputForm", "imageInView", "fileRawView", "photoInputStream", "imageInterfacestream", "fileInputstream"], "imageBytes": ["photoGs", "pictureBytes", "audioBytes", "photoBytes", "imgGs", "imageSeries", "imgBs", "imageGs", "photoParts", "imageKeys", "issueParts", "audioSeries", "imageParts", "imageByte", "issueGs", "issueBytes", " imageBs", " imageGs", " imageSeries", " imageByte", "imgBytes", "photoByte", "audioParts", "pictureByte", "imgParts", "photoKeys", "pictureGs", "audioBs", "imgSeries", " imageParts", "pictureParts", "imgKeys", "issueKeys", "imageBs"]}}
{"id1": "8430178", "id2": "755203", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "cpLine", "copyPath", " copyFiles", " copyPath", "copyFiles", "cpPath", "cpFile", "CopyLine", "cpFiles", " copyLine", "CopyPath", "CopyFile", "copyLine"], "source_name": ["src_file", "source_Name", "source09name", "src_name", "sourceEcase", "src_format", "src_case", "source09names", "sourceEName", "sourceptcheck", "sourcePNAME", "Source_NAME", "source_names", "src_check", "sourcePlocal", "source_word", "sourceEname", "source_link", "src_Name", "source09link", "Source_name", "sourceptname", "source_NAME", "source09file", "Source_local", "src_names", "source_local", "source_check", "sourceptnames", "source_format", " source_word", "src_link", " source_names", "sourceptName", "sourcePname", "sourceEnames", "source_case"], "dest_name": ["dest_create", "src_file", "Dest_name", "dest__key", " dest_names", " dest_min", "destationName", "start_name", "source_Name", "destationcommon", "src_name", "dest_min", "dest_file", "destitycommon", "dest_time", " dest_time", " dest_file", "destityName", "Dest_group", "destipname", "dest9Name", "start_admin", " dest_no", "dest9admin", "dest__size", "dest_no", "startityName", "dest_id", "src_id", "dest_admin", "dest9name", "dest_key", "source_names", "startityname", "destationadmin", "destityadmin", "dest__name", "dest_group", "destaxyname", "dest_NAME", "Dest_admin", "src_create", " dest_size", "dest9group", "Dest_Name", "dest_names", " dest_key", "destationname", "destaxynam", "dest_Name", "dest__names", "start_Name", "source_NAME", "startitycommon", "dest_size", "startityadmin", "destipid", "destipcreate", " dest_Name", "source_nam", "destaxyName", "dest_nam", "start_common", "destaxynames", "destityname", "dest_common", "destipfile"], "source_file": ["src_file", "sourceistname", "src_stream", "source___service", "site_file", "ource_time", "ource_class", "site_le", "source___time", "sourcepyservice", "sourcepystream", "source_time", "sourceistid", "src_name", "ource_file", "site_service", "source_File", "source_id", "source___file", "sourcephpstream", "site___file", "sourcepyle", "site___stream", " source_info", "source1name", "source2info", "sourcephple", "sourcephpservice", "source___le", "source___File", " source_id", "source2file", "sourcepyfile", "source_le", "source___stream", "source_link", "sourcephpfile", "source_path", "source1path", " source_link", "site_stream", "source2entry", "source1file", " source_entry", "sourceistlink", "source___class", "source_entry", "source_service", "site___service", "sourceistfile", "source_info", "site___le", "source1stream", "source_stream", "src_path", "ource_File", "source_class"], "destination_file": ["destinant_File", "destinant_fp", "destination_link", "destination_db", "destrant_image", "destination____db", "destification_path", "destination__File", "destination__db", "destination_do", "destination_dir", "destination_image", "destination_domain", "destinant____File", "destinate_file", "destrant_file", "destinant____domain", "destinationJimage", "destination_ile", "destination____domain", "destination_File", "destrantJpath", "destification_port", "destinationJfp", "destinant____file", "destinate_ile", "destination__domain", "destinant_link", "destinant_file", "destination_path", "destification_ile", "destinant_port", "destinationJfile", "destrant_fp", "destification_file", "destrantJfile", "destinant_domain", "destination____File", "destinant_db", "destrantJimage", "destination__file", "destinate_dir", "destinationJpath", "destrantJfp", "destinant____db", "destrant_path", "destination_fp", "destinate_do", "destination____file", "destination_port"], "source": ["shadow", "secret", "use", "cause", "session", "SOURCE", "server", "site", "target", "major", "input", "ser", "system", "store", "directory", "reader", "volume", "image", "status", "template", "base", "sequence", "feature", "client", "ources", "join", "class", "connection", "unit", "src", "scope", "script", "note", "title", "sample", "ource", "copy", "origin", "iter", "Source", "ce", "proxy", "search", "resource", "file", "local", "service", "from", "master", "start", "existing", "config", "argument", "set", "query", "content", "object", "product", "tool", "sin", "dest", "out", "or", "ie", "parent"], "destination": ["originination", "alterninate", "gestinator", "origininator", "restination", "destation", "alterninated", "originification", " destification", "termininator", "targetion", "destification", "Destination", "Destation", "destociation", "destinate", "restion", "methodinator", "destion", "origininated", "estication", "gestinated", "Destinations", "restinate", "targetination", "Destinated", "gestociation", "destinator", "Destion", " destication", " destation", "targetinated", "targetinations", " destinate", "destication", "estinate", "coordication", "terminination", "restinator", "termininated", "destinated", "restinations", "targetinator", "methodinated", "alterninator", " destinator", "restinated", "gestination", "coordinated", "targetociation", "Destinator", "alternination", "coordination", "methodination", "estination", "methodinate", "targetification", "destinations", "estinated", "restation", "coordinate", "terminociation", " destinated"], "buffer": ["b", "batch", "cache", "Buffer", "command", "paste", "window", "transfer", "base", "table", "sequence", "document", "buf", "context", "append", "buff", "comment", "iter", "block", "stream", "read", "bb", "binary", "message", "length", "frame", "text"], "bytes_read": ["bytes2Read", "bytes2written", " bytes_written", "bytes2left", "bytes2read", "bytes_left", "bytesunRead", " bytes_Read", "bytes_written", " bytes_left", "bytesunread", "bytesunleft", "bytes_Read", "bytesunwritten"], "in": ["inf", "n", "IN", "l", "err", "it", " IN", "inner", "cin", "sum", "body", "ins", "user", "input", "doc", "mm", "reader", "ind", "std", "rin", "bin", "In", "ini", "is", "io", "client", "ar", "isin", "con", "mn", "stream", "nin", "file", "gin", "from", "t", "add", "diff", "log", "read", "id", "all", "en", "get", "conf", "inn", "r", "ic", "out", "din", "p"], "response": ["ping", "entry", "zero", "continue", "print", "command", "bye", "network", "data", "resp", "reset", "respond", "question", "hash", "res", "onse", "window", "one", "status", "choice", "answer", "sequence", "description", "notice", "offer", "json", "echo", "connection", "application", "sample", "reply", "remember", "example", "request", "version", "block", "vector", "value", "format", "respons", "result", "Response", "exit", "query", "success", "relation", "hello", "output", "message", "page", "python", "line"], "parentdir": ["Parentdir", "parentfile", "parentfolder", " parentd", "rootd", "parentDir", " parentfolder", "rootdirectory", "parentdirectory", "Parentfolder", "masterdir", "ParentDir", " parentfile", " parentdirectory", "masterDir", " parentDir", "rootdir", "fatdirectory", "masterfile", "fatdir", "fatd", "parentdirect", "Parentfile", "rootDir", "rootfolder", "Parentdirectory", "rootdirect", " parentdirect", "fatdirect", "masterdirectory", "parentd"]}}
{"id1": "6421904", "id2": "20128728", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"addRecord": ["addrecord", "writerecord", "newDocument", "AddFile", "writeDocument", "writeFile", "AddRecord", "AddDocument", "Addrecord", "addDocument", "newrecord", "newRecord", "addFile", "writeRecord", "newFile"], "input": ["m", "in", "it", "data", "address", "q", "reader", "image", "base", "up", "Input", "error", "open", "io", "table", "is", "media", "context", "upload", "request", "stream", "w", "add", "format", "from", "start", "config", "content", "initial", "get", "this", "out", "current", "p", "source"], "temporary": ["typoral", "comperature", "tempor", "typor", "temarily", "theporal", "semperature", "Temporal", "timmanent", "temcreated", "tymediate", "memporary", "temmediate", "temppty", "Temutable", "rempty", "tememp", "tempient", "transporal", "stemporary", "semporal", "stporal", "Temporary", "timporal", "temporal", "timmediate", "timperature", "remporal", "transporary", "tmporary", "timtemp", "tmutable", "comarily", "temmanent", "stporary", "tempporary", "memutable", "tempperature", "timutable", "tytemp", "temptemp", "tyient", " temporal", "transmanent", "tmient", "timarily", "transperature", "tempcreated", "timporary", "stemporal", "tmporal", "temutable", "comporary", "tmperature", "memperature", "remporary", "stemperature", "temtemp", "comporal", "temperature", "stemp", " tempty", "tenperature", "typerature", "tempty", "temputable", "remcreated", "Temperature", " temcreated", "semporary", "tmemp", "temient", "stemmanent", "theperature", "stperature", "tenporal", "temppor", "tenporary", "tempporal", "memporal", "tmpor", "themediate", "tenarily", "typorary", "tyutable", "theporary", "sememp"], "tempId": ["tempID", "fakeId", "tempUrl", "tempK", "templateK", "tempPart", "templateId", "templateRef", "fakePart", "templateIs", "TempId", "TempUrl", "currentK", "fakeID", "TempID", "stemId", "poraryRef", "fakeRef", "poraryPart", "tempRef", "templateID", "templateUrl", "tempIs", "poraryID", "stemID", "poraryUrl", "currentIs", "templatePart", "uniqueUrl", "currentId", "uniqueIs", "uniqueId", "currentUrl", "poraryId", "stemUrl", "uniqueK"], "length": ["n", "capacity", "code", "time", "l", "ength", "duration", "data", "amount", "full", "L", "filename", "total", "string", "location", "padding", "volume", "limit", "available", "loaded", "load", "name", "shape", "sequence", "description", "type", "width", "end", "number", "json", "SIZE", "count", "offset", "Length", "bytes", "version", "position", "size", "supported", "ENGTH", "value", "present", "read", "all", "maximum", "content", "default", "message", "path", "buffer", "height", "text", "readable", "len"], "digest": ["mdested", "Digested", "fingerest", "modested", " digist", "Digest", " digested", " digEST", " digester", "Digist", "signester", "fingerested", "diger", "identest", "identested", "DigEST", "mdest", " diger", "digested", "identig", "identester", "modEST", "mdester", "fingerEST", "mdig", "modest", "moder", "fingerester", "signest", "digig", "digEST", "Diger", "digester", "signested", "signist", "digist", "Digester", "Digig"], "output": ["o", "to", "web", "hidden", "generation", "network", "data", "four", "body", "unsigned", "no", "response", "image", "that", "open", "io", "ou", "client", "outer", "channel", "cut", "icon", "other", "connection", "write", "application", "none", "put", "ilo", "stream", "next", "result", "auto", "exit", "console", "object", "see", "Output", "message", "net", "display", "out", "page", "buffer", "you", "current", "source"], "file": ["print", "null", "in", "record", "data", "full", "user", "child", "io", "type", "dir", "upload", "le", "url", "File", "local", "binary", "get", "place", "page", "channel", "FILE", "source", "report", "to", "link", "al", "h", "base", "ile", "fp", "common", "stat", "module", "word", "resource", "value", "handle", "library", "result", "id", "run", "buffer", "entry", "rule", "body", "filename", "entity", "image", "document", "f", "il", "class", "valid", " File", "files", "work", "real", "info", "port", "same", "format", "db", "message", "temp", "out", "remote", "action", "tree", "line", "http", "create", "chain", "target", "name", "table", "error", "form", "e", "comment", "old", "block", "single", "log", "relation", "this", "path"], "parent": ["man", "m", "tree", "to", "rule", "ip", "null", "root", "folder", "child", "holder", "base", "name", "parents", "shape", "wrapper", "line", "global", "ger", "sp", "owner", "dir", "ma", "block", "port", "mother", "from", "master", "part", "op", "relation", "g", "per", "tmp", "this", "path", "pool", "Parent", "out", "p", "source"], "now": ["then", "zero", "null", "time", "since", "Now", "full", "sum", "NOW", "post", "date", "mm", "system", "aw", "yes", "amp", "omp", "loc", "after", "dd", "ct", "recent", "when", "st", "draw", "cmp", "off", "ow", "aj", "tim", "size", "wait", "from", "gov", "present", "always", "diff", "here", "exp", "sw", "set", "day", "onew", "mb", "ord", "before", "fx", "done", "ready", "current"]}}
{"id1": "21656668", "id2": "3184073", "code1": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"copyResourceToFile": ["copyStringtoFiles", "copyResourceFileFiles", "copyResourceFromFiles", "copyResourceToFILE", "copyResourceFilePath", "copyResourceFromPath", "copyStringtoFile", "copyResourcetoFILE", "copyResourceFileFILE", "copyResourcetoFile", "copyStringtoPath", "copyResourcetoFiles", "copyStringToFiles", "copyStringToFile", "copyStringToPath", "copyStringtoFILE", "copyResourcetoPath", "copyResourceFromFILE", "copyResourceFromFile", "copyResourceToFiles", "copyResourceFileFile", "copyStringToFILE", "copyResourceToPath"], "resourceFilename": ["sourceName", " resourceSourceFile", "fromName", "sourceFile", "sourceTitle", "fileTitle", " resourceTitle", " resourceWriter", "fromFilename", "resourceSourceFile", "fileWriter", "sourceWriter", " resourceName", " resourceFile", "fromFile", "fileFilename", "fromSourceFile", "sourceFilename", "resourceName", "resourceWriter", "resourceTitle", "resourceFile", "fileFile", "sourceSourceFile"], "destinationFilename": ["destinedSourceFile", "destificationFILE", "DestificationSourceFile", "destinalFILE", "DestinationFil", "destinationFILE", "declificationfilename", "destinationFil", "destificationFile", "destinatedFile", "destinalSourceFile", "DestinationSourceFile", "destinatedFil", "destificationFilename", "destinationfilename", "destinatedFILE", "destinatedSourceFile", "destinationSourceFile", "declificationFILE", "destinedFile", "destinalFilename", "declinationFILE", "DestificationFil", "declinationfilename", "declificationSourceFile", "destinedFilename", "destificationSourceFile", "DestinationFilename", "declificationFilename", "declinationFilename", "destinationFile", "DestificationFilename", "DestinationFile", "destinatedfilename", "declinationSourceFile", "destificationFil", "destinalfilename", "destificationfilename", "destinedFil", "destinatedFilename", "DestificationFile"], "inStream": ["insForm", "inputIterator", "insStream", "INForm", "linForm", "inSource", " inInterface", "inputSource", " inSteam", "outForm", " inForm", "linStream", "InSteam", "insSteam", "linIterator", " inSource", "outSource", "innerSteam", "outInterface", "inSteam", "inInterface", "innerStreamer", "INStreamer", " inIterator", "innerStream", "inputForm", "inputStream", "outStreamer", "insStreamer", "InForm", "inStreamer", "InStream", "outSteam", "inIterator", "inForm", "INStream", "INSteam", "inputSteam", "linSteam", "InInterface", "innerForm"], "outStream": ["instream", " outstream", "exStreamer", "outputStreamer", "outForm", "netStream", " outForm", "outputSteam", "exForm", "ouStreamer", "outputStream", "inSteam", "netForm", "outstream", "outputstream", "outputForm", "exSteam", "ouStream", "exStream", "outStreamer", " outStreamer", "oustream", "inStreamer", "ouSteam", "outSteam", "inForm", "netStreamer", "netSteam", " outSteam"]}}
{"id1": "21092340", "id2": "8754809", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToZipZip", "addInArchFile", "addInArchiver", "addToZipiver", "addToHarZip", "addToArchiver", "addInArchive", "addToExZip", "addToArchZip", "addInHarZip", "addToHariver", "addToHarive", "addInArchZip", "addToArchFile", "addToZipive", "addToExiver", "addInHarFile", "addInHarive", "addInHariver", "addToHarFile", "addToExFile", "addToExive", "addToZipFile"], "pod": ["report", "disk", "ad", "project", "policy", "pkg", "cp", "body", "wp", "proc", "post", "od", "volume", "pick", "table", "ods", "pack", "pad", "device", "top", "module", "pc", "Pod", "task", "check", "zone", "start", "job", "point", "spec", "op", "component", "ack", "poll", "message", "archive", "p"], "podArchiveOutputStream": ["podArchiverInputStream", "podArchiveInputSteam", "podArchiveOutputSync", "podArchiveStreamSync", "podArchiveInputForm", "podArchiverInputSync", "podArchiveInputMap", "podArchiveInputStreamer", "podArchiveEntryPoint", "podArchiveOutputstream", "podArchiveResourcestream", "podArchiveResourceContext", "podArchiveInputContext", "podArchiveOutputContext", "podArchiveoutputStream", "podArchiveOUStream", "podArchiveInputstream", "podArchiveMainStream", "podArchiveResourceSteam", "podArchiveMainSteam", "podArchiveMainForm", "podArchiveOutstream", "podArchiveOUForm", "podArchiveStreamForm", "podArchiverOutputstream", "podArchiverInputMap", "podArchiveStreamStream", "podArchiverInputPoint", "podArchiveResourceStream", "podArchiveoutputForm", "podArchiveStreamMap", "podArchiverOutputStreamer", "podArchiveOutContext", "podArchiveOUSync", "podArchiverOutputForm", "podArchiveOutputSteam", "podArchiverOutputContext", "podArchiverOutputSteam", "podArchiveInputStream", "podArchiveOUMap", "podArchiverInputSteam", "podArchiveEntryStream", "podArchiverOutputPoint", "podArchiveOutputForm", "podArchiveoutputSteam", "podArchiveOutputStreamer", "podArchiverOutputStream", "podArchiverInputstream", "podArchiverInputContext", "podArchiveOutputMap", "podArchiverOutputMap", "podArchiveInputPoint", "podArchiveInputSync", "podArchiverInputStreamer", "podArchiveOutputPoint", "podArchiveMainStreamer", "podArchiveOutPoint", "podArchiverInputForm", "podArchiverOutputSync", "podArchiveOutStream", "podArchiveoutputStreamer", "podArchiveOutSteam", "podArchiveEntrySteam"], "filename": ["ename", "key", "NAME", "folder", "string", "location", "directory", "username", "p", "name", "prefix", "FILE", "description", "fn", "latest", "fil", "Filename", "fp", "subject", "ame", "title", "jpg", "upload", "version", "println", "url", "names", "file", "resource", "original", "nm", "nil", "kl", "release", "FN", "binary", "output", "png", "path", "message", "stem", "family", "archive", "txt", "uri"], "source": ["use", "inner", "SOURCE", "body", "proc", "address", "ser", "store", "input", "seed", "image", "template", "sequence", "password", "style", "sql", "context", "src", "sample", "force", "ource", "copy", "info", "Source", "stream", "iterator", "resource", "file", "from", "service", "series", "loader", "start", "spec", "get", "supp", "component", "view", "shell", "select"], "entry": ["link", "record", "book", "data", "key", "obj", "system", "quick", "attribute", "card", "char", "line", "sheet", "row", "cell", "connection", "ment", "cue", "comment", "element", "ace", "enter", "ce", "task", "word", "resource", "file", "se", "log", "ent", "job", "set", "query", "component", "good", "zip", "tmp", "Entry", "channel", "or", "archive", "ie", "ry", "nt"]}}
{"id1": "2009072", "id2": "1005107", "code1": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "code2": "    public void googleImageSearch() {\n        if (artist.compareToIgnoreCase(previousArtist) != 0) {\n            MusicBoxView.googleImageLocation = 0;\n            try {\n                String u = \"http://images.google.com/images?q=\" + currentTrack.getArtist() + \" - \" + currentTrack.getAlbum() + \"&sa=N&start=0&ndsp=21\";\n                if (u.contains(\" \")) {\n                    u = u.replace(\" \", \"+\");\n                }\n                URL url = new URL(u);\n                HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n                httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n                BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n                String text = \"\";\n                String lin = \"\";\n                while ((lin = readIn.readLine()) != null) {\n                    text += lin;\n                }\n                readIn.close();\n                if (text.contains(\"\\n\")) {\n                    text = text.replace(\"\\n\", \"\");\n                }\n                String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n                for (String s : array) {\n                    if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                        String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                        googleImages.add(s1);\n                    }\n                }\n            } catch (Exception ex4) {\n                MusicBoxView.showErrorDialog(ex4);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openInput": ["OpenOutput", "openinput", " openinput", "Openinput", " openRead", "createRead", "OpenInput", "createinput", "OpenRead", "openOutput", "createInput", " openOutput", "openRead", "createOutput"], "path": [" oath", "entry", "rect", "conn", "pt", "pointer", "Path", "prop", "pkg", "cp", "full", " PATH", "test", "doc", " expansion", "desc", "ath", "self", "msg", "template", "transform", "name", "cert", "cmd", "platform", "pat", "form", "f", "text", "ref", "context", "phrase", "mount", "request", "patch", "com", "w", "mat", "pattern", "log", "exp", "part", "PATH", "query", "tx", "route", "progress", "fr", "component", " pat", "app", "message", " remainder", "txt"], "len": [" clen", "n", "pl", "pos", "l", "ld", "ll", " l", "h", "L", " length", "el", "seq", "loc", "li", "lon", "fin", "un", "il", "enc", "count", "lp", "nl", "Length", "lim", "lan", "ln", "dec", "size", "t", "lf", "sl", "Len", "en", "mil", "length", "ls", "nt"], "p": ["pb", "m", "b", "v", "n", "d", "pr", "l", "ap", "np", "cp", "pkg", "press", "h", "q", "wp", "pid", "param", "c", "prefix", "jp", "f", "fp", "u", "j", "lp", "sp", "t", "s", "P", "pattern", "vp", "pre", "pp", "part", "ps", "pa"], "url": ["browser", "http", "b", "link", "null", "web", "l", "ll", "html", "server", "user", "window", "hl", "base", "loc", "cert", "char", "client", "f", "str", "ul", "mail", "ssl", "ret", "ref", "build", "ur", "nl", "bel", "mount", "URL", "gl", "log", "Url", "job", "sl", "r", "out", "ls", "uri"], "result": ["report", "mate", "Result", "proc", "pak", "res", "database", "process", "response", "answer", "table", "sequence", "open", "cert", "cup", "feature", "currency", "ret", "pair", "comment", "request", "true", "results", "stream", "value", "surface", "profile", "successful", "success", "relation", "product", "event", "region", "output", "r", "message", "instance", "current", "uu"]}}
{"id1": "15896098", "id2": "11546108", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checkcksam", "getSHA256Chechecksum", "getSHA256Checkam", "getSHA256Checkcksums", "getSHA256Checkum", "getSHA256Checsume", "getSHA256Checsums", "getSHA256Checsum", "getSHA256Checkchecksums", "getSHA256Chechecksums", "getSHA256Checkchecksam", "getSHA256Checkcksume", "getSHA256Checkums", "getSHA256Chechecksume", "getSHA256Checsam", "getSHA256Checkchecksume", "getSHA256Checksums", "getSHA256Checkchecksum", "getSHA256Chechecksam", "getSHA256Checkume", "getSHA256Checksume", "getSHA256Checksam", "getSHA256Checkcksum"], "source": ["raw", "secret", "in", "data", "SOURCE", "body", "filename", "target", "input", "string", "seed", "image", "status", "template", "base", "name", "sequence", "style", "subject", "context", "src", "sample", "ource", "Source", "url", "value", "file", "from", "s", "format", "reason", "content", "output", "this", "message", "path", "out", "buffer", "text"], "checksum": ["ckssum", "csume", "checkim", "checksim", "cksim", "checkume", "checksume", " checksumb", "cksumb", " checkssum", " checksums", "cksum", "checksumb", "cksums", "checkssum", "checksums", "cssum", "checkums", "csim", " checksim", " checksume", "csum", "cksume", "checkumb", "checkum"], "md": ["d", "m", "mg", "ad", "cd", "ld", " Md", "mand", "bd", "pd", "hd", "grad", "MD", "mm", "det", "Cmd", "od", "dr", "ind", "pm", "mod", "down", "cmd", "dd", " MD", "red", "der", "df", "wd", "pdf", "ms", "dh", "mc", "mt", "mn", "mp", "mk", "sm", "sd", "def", "mo", "dm", "di", "mb", "nt"], "byteData": ["bleParts", "channelData", "ioDATA", "wordDATA", "sliceDATA", "phraseBytes", "wordArray", "wordBytes", "channelParts", "bytesBytes", "byteParts", "ByteParts", "ioList", "ByteBytes", "reverseDat", "phraseData", " byteParts", "routeDat", "bytesDATA", "byteDATA", "channelRel", "ioDat", "wordData", "reverseCount", "byteList", " byteDATA", "phraseParts", "phraseDATA", "ByteData", "bledata", "ioData", "bleRel", "sliceDat", "sliceData", " byteBytes", "sliceList", "bytesData", "byteBytes", "reverseDATA", "byteDat", "routeData", " bytedata", " byteList", " byteCount", " byteDat", "byteArray", "bytedata", "channeldata", "bleData", "reverseData", "ByteDATA", "bytesArray", " byteArray", "routeDATA", "byteCount", "routeCount", "byteRel", " byteRel"], "sb": ["pb", "b", "bj", "sh", "bh", "bis", "bash", "sbm", "zb", "lb", "ub", "bt", "bps", "rb", "SF", "ob", "sa", "ssl", "sv", "lp", "bf", "sam", "bg", "sp", "cb", "ib", "sf", "obb", "kb", "sm", "bsp", "wb", "sw", "gb", "bb", "eb", "xb", "nb", "db", "shell", "bs", "sg", "mb", "si", "erb", "SB", "sq"], "i": ["m", "ip", "print", "list", "it", "ei", "q", "major", "loop", "y", "ini", "io", "client", "ity", "bi", "pi", "me", "init", "mi", "ix", "hi", "o", "to", "im", "oi", "ki", "ii", "gu", "any", "u", "j", "id", "set", "ic", "I", "xi", "uri", "ci", "ui", "l", "err", "ind", "\u0438", "iq", "iu", "ms", "info", "ai", "sim", "di", "iy", "history", "remote", "si", "ie", "ij", "multi", "gi", "chain", "phi", "life", "li", "ski", "json", "ime", "cli", "er", "ri", "ion", "series", "point", "g", "ims", "this", "my", "ti", "ji", "qi"], "hexString": ["exString", "fullBuffer", "htmlstring", "shortArray", "hexResource", "shortstring", " hexArray", "shortBuffer", " hexStore", " hexBuffer", "exArray", "hexArray", " HexString", "exStore", " Hexstring", "hexBuffer", "exBuffer", "htmlString", "fullString", "hashstring", " hexResource", "hexstring", "hashArray", "exstring", "shortResource", "htmlBuffer", " hexstring", "hashBuffer", " HexBuffer", "hexStore", "hashString", "fullStore", "fullstring", " HexResource", "htmlArray", "shortString"], "hex": ["comp", "raw", "sh", "prop", "tex", "ex", "rex", "html", "cat", "full", "oct", "h", "rendered", "sex", "rh", "term", "ext", "hl", "pex", "des", " sex", "alph", "php", "form", "flash", "alias", "json", " Hex", "cont", "mix", " ex", "none", "he", "com", "dump", "exp", "ph", "tx", "zh", "lit", "def", "solid", "hello", "temp", "x"]}}
{"id1": "19868933", "id2": "536614", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingRFile", "copyFromFileToFileUsingRIO", "copyFromFileToFileUsingNHFile", "copyFromFileToFileUsingMIE", "copyFromFileToFileUsingRIE", "copyFromFileToFileUsingMFile", "copyFromFileToFileUsingRIF", "copyFromFileToFileUsingNIE", "copyFromFileToFileUsingNHIF", "copyFromFileToFileusingRIE", "copyFromFileToFileUsingNFile", "copyFromFileToFileusingRIF", "copyFromFileToFileUsingNIF", "copyFromFileToFileusingNIF", "copyFromFileToFileusingRIO", "copyFromFileToFileUsingNHIO", "copyFromFileToFileusingNFile", "copyFromFileToFileusingRFile", "copyFromFileToFileusingNIE", "copyFromFileToFileUsingNHIE", "copyFromFileToFileUsingMIO", "copyFromFileToFileUsingMIF", "copyFromFileToFileusingNIO"], "inputFile": ["openfile", "inputPath", "loadfile", "outputByte", "loadLe", "openLe", "loadFile", "importByte", " inputStream", " inputLe", "importFile", "outputStream", " inputPath", "inputfile", "inputLe", "outputPage", "inputPage", "importStream", " inputfile", " inputPage", "inputStream", "importPage", "loadPath", "inputByte", "openPath", "openFile", " inputByte"], "outputFile": [" outputfile", "putFile", "toStream", "putfile", "outputPlace", "toFile", " outputPlace", "putDirectory", "resultFile", "resultFiles", "toPlace", "outputStream", "inputDir", "resultStream", "inputfile", " outputDir", "outputDir", "putDir", "outputfile", "outputFiles", " outputStream", "outputDirectory", " outputDirectory", " outputFiles", "resultPlace", "toFiles", "inputDirectory"], "inputChannel": ["inputConnection", "inputChan", "outputBuffer", " inputListener", "internalChannel", "importCategory", "tableChannel", "internalScope", "openChannel", " inputChuck", " inputCategory", "loadManager", "httpConnection", "httpChannel", " inputStream", "outputchannel", "inputchannel", "InputStream", "tableScope", "inputListener", " inputManager", "inputBuffer", "internalListener", "outputStream", " inputchannel", " inputBuffer", " inputConnection", "importChuck", "InputBuffer", "outputConnection", "rawChannel", " inputScope", " inputBlock", "importChannel", " inputChan", "openConnection", "inputBlock", "InputChannel", "inputStream", "tableListener", "loadChannel", "rawChan", "openchannel", "outputChan", "inputScope", "importManager", "inputChuck", "rawConnection", "loadChuck", "internalBlock", "inputManager", "inputCategory", "rawFile", "httpChan", "openChan", "tableBlock", "InputConnection", "httpFile", "loadCategory"], "outputChannel": ["publicchannel", "languageChannel", "OutputStream", "putButton", "hiddenChan", "outputchannel", "languagechannel", "consoleStream", "publicCow", "removeChannel", "displayCategory", " outputCamera", " outputButton", "putChan", "displayClient", "outputStream", " outputClient", "hiddenCamera", "languageCategory", "outputClient", "removechannel", "hiddenButton", "putChannel", "consoleCow", "putCamera", "OutputFile", "outputButton", "publicChannel", " outputCategory", "consolechannel", "displaychannel", "languageClient", "OutputChan", " outputStream", "hiddenChannel", "outputChan", "outputCow", "removeCow", "displayChannel", "outputCategory", "OutputChannel", " outputchannel", " outputChan", "outputCamera", "consoleFile", "consoleChannel", "consoleChan"]}}
{"id1": "20724937", "id2": "23088292", "code1": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getTopicMap": ["getTopicTree", " getTopicInfo", "getThreadInfo", " getTopicTree", " getTopicsList", "getTopicInfo", "getMessageList", "getMessageMap", " getTopicList", "getThreadTree", "getTopicsInfo", "getMessageTree", " getTopicsInfo", "getTopicsTree", " getTopicsTree", "getEventList", " getThreadMap", "getEventTree", " getThreadInfo", "getEventInfo", "getEventMap", "getTopicList", "getTopicsMap", " getThreadTree", " getThreadList", "getThreadMap", "getThreadList", "getTopicsList", "getMessageInfo", " getTopicsMap"], "url": ["browser", "http", "b", "pl", "parse", "link", "null", "web", "l", "ll", "html", "xml", "address", "server", "string", "location", "base", "name", "loc", "document", "char", "item", "str", "mail", "ssl", "dl", "u", "ref", "build", "ur", "nl", "domain", "mount", "request", "URL", "resource", "file", "gl", "pattern", "log", "Url", "job", "id", "cl", "host", "lr", "page", "ls", "uri"], "baseURI": ["basedURL", "basedU", "BaseURL", "BaseUR", " baseUR", " baseURL", "basedUR", "baseURL", "baseU", "baseUR", "BaseURI", "BaseU", " baseU", "basedURI"], "inputStream": ["InputSteam", "openPort", "inputstream", "openSteam", " inputFile", "unsignedstream", " inputStreamer", "inputStreamer", "InputStream", "InputFile", "inputStack", "openStream", " inputPort", "inputPort", "inputFile", "openStack", "InputStreamer", "InputStack", "unsignedStreamer", "unsignedSteam", "InputView", " inputstream", " inputSteam", "Inputstream", "openView", "InputPort", "inputView", "unsignedStream", "openFile", "inputSteam", " inputStack", " inputView"]}}
{"id1": "13499897", "id2": "8932510", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"CopyFile": [" CopyDir", " CopyPath", "DownloadPath", "TransferFile", "Downloadfile", "DownloadDir", "TransferPath", "CopyPath", "DownloadFile", "Copyfile", "Transferfile", "TransferDir", "CopyDir", " Copyfile"], "sourcefile": ["srcfile", "sourceFile", "styleFile", "Sourcefile", "srckey", "Sourcepath", "sourceattribute", "ourcekey", "srcFile", "ourceFile", "startpath", "Sourceurl", " sourceFile", " sourceurl", "srcattribute", "startFile", "sourcepath", "ourcefile", " sourcepath", "sourceurl", "startfile", "starturl", "ourceattribute", "sourcekey", "stylekey", "styleattribute", "stylefile", "SourceFile"], "destfile": ["destfilename", "srcfile", "masterpath", "Desturl", "resultpath", "sourceFile", "DestFile", "sourcefilename", "desturl", "destile", "tempFile", "tempfile", " destile", "Destile", "srcFile", "resultfile", "Destfile", "destFile", "resultfilename", "destport", "resultFile", "sourcename", "sourceile", "destpath", " destfilename", "masterFILE", "Destname", "sourceport", " destFile", "sourcepath", " destFILE", " destpath", "tempfilename", "masterfile", "temppath", "Destpath", "sourceurl", "Destfilename", "tempFILE", "masterFile", "destFILE", " destname", " destport", "destname", "srcport", "srcpath", " desturl"], "last": ["Last", "rest", "shadow", "ast", "since", "show", "most", "based", "full", "index", "total", "dist", "lot", "base", "prev", "reverse", "latest", "after", "bottom", "end", "any", "top", "count", "first", "est", "nd", "st", "and", "old", "strip", "size", "master", "pop", "max", "start", "region", "good", "default", "right", "get", "this", "left", "recent", "length"], "parent": ["m", "ip", "prop", "key", "server", "full", "chain", "missing", "pid", "root", "pa", "test", "folder", "p", "child", "padding", "holder", "tip", "older", "parents", "shape", "up", "prefix", "tar", "wrapper", "global", "snap", "unit", "sp", "owner", "dir", "where", "and", "request", "ma", "fat", "mother", "paren", "master", "home", "exp", "part", "point", "def", "params", "fr", "spec", "per", "tmp", "path", "pool", "page", "Parent", "family", "temp", "instance", "tree"], "f": ["m", "v", "b", "l", "alf", "fe", "fw", "h", "tf", "fab", "F", "elf", "c", "fo", "fi", "cf", "rf", "ft", "df", "fp", "fc", "fed", "bf", "fm", "e", "fac", "sf", "af", "w", "file", "local", "fd", "fs", "lf", "part", "fl", "fr", "g", "of", "p"], "srcChannel": ["subChannel", "subchannel", "sqchannel", "curConnection", "instchannel", " srcchannel", "srcConnection", "curChan", "ctrChain", "sourceChan", "srcchannel", "sourceButton", " srcChain", "instButton", "srcChan", "ctrChannel", " srcButton", "curchannel", " srcChan", "curChannel", "instChan", "srcCase", "rcChannel", "subPanel", "ctrChan", "instChannel", " srcCase", " srcPanel", "sqCase", "rcButton", " srcConnection", "rcConnection", "ctrButton", "sourceChannel", "sourcechannel", "srcPanel", "subCase", "rcChain", "sqPanel", "sqChannel", "rcChan", "srcChain", "rcchannel", "srcButton"], "dstChannel": [" dotConnection", "dbrChan", "deltChannel", "cdistChannel", "destChan", "dotChannel", "dndCh", "dblCh", "dbrchannel", "drtChannel", "deltButton", "cdstChannel", "dotConnection", " dotchannel", " dstchannel", "dndChan", "dltChan", "deltChan", "distCategory", "drtCh", "ddrChan", " dotChannel", "ddrChannel", "dndCategory", "dltChannel", "ddrchannel", "cdstCategory", "distButton", "cdstCh", "dstCh", "cdistButton", " dstConnection", "dblButton", "destCh", "destChannel", "distCh", "dblChannel", "ddrConnection", " dstChan", "cdstButton", "cdistCategory", "dndButton", "dblChan", "dltButton", "destButton", "dotChan", "dstchannel", " dotChan", "dbrConnection", "dotchannel", "dstConnection", "deltCh", "drtButton", "dstButton", "dltCh", "distChannel", "dstCategory", "dstChan", "drtCategory", "dndChannel", "dbrChannel", "cdistCh"]}}
{"id1": "6403868", "id2": "19096138", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUninstallItems", "extractUnInstallFiles", "extractuninstallItems", "extractUnInstallItems", "extractuninstallFile", "extractUnpackFiles", "extractUnInstallFile", "extractUnpackFile", "extractuninstallFiles", "extractunInstallFile", "extractUninstallFile", "extractunInstallItems", "extractUnpackItems", "extractunInstallFiles"], "_destPath": ["_privDir", "_srcDir", "_destTh", "_destPoint", "_srcPath", "_DestDir", "_sourcePath", "_tempPoint", "_DestPath", "_privTh", "_restDir", "_tempDir", "_combFormat", "_tempPath", "_DestKey", "_tempFormat", "_sourceDir", "_srcPoint", "_DestTh", "_restKey", "_privPoint", "_sourceFormat", "_combDir", "_tempTh", "_restPoint", "_destFormat", "_destKey", "_destDir", "_combPath", "_srcKey", "_restPath", "_DestPoint", "_privPath"], "upgrade": ["upcheck", "exgrade", "downchange", "upcp", "exchange", "equgrade", "unate", "downgrades", "uncp", " upchange", "equgrad", "excheck", "equcp", "downgrade", "equate", "upate", " upcheck", "upgrad", " upgrades", "ungrad", " upcp", " upgrad", "upgrades", " upate", "downcheck", "upchange", "exgrades", "ungrade"], "lastVer": ["LastVer", " lastVersion", "oldVers", "nextRes", "Lastver", "latestRes", "nextServ", "lastVers", "oldver", "nextVer", "LastVers", " lastVers", " lastver", "oldVer", " lastRes", "lastver", "oldVersion", "latestVer", "nextVers", "LastVersion", "latestVers", "lastRes", " lastServ", "lastServ", "lastVersion", "latestServ"], "oldlog": [" oldLog", "oldLog", " olderr", "olderlog", "Oldog", "olderog", "OLDpath", "olderLog", "Oldpath", "oldpath", "OLDerr", "OldLog", "OLDLog", " oldog", "OLDlog", "olderpath", "Oldlog", " oldpath", "oldererr", "oldog", "olderr", "OLDog"], "destPath": ["locTime", "originPort", "DestPath", "restDir", "srcPort", "privPath", "identPoint", "destFile", "declDir", "potDir", "destRoot", " destHost", "originTh", "destPort", "srcDir", "destRef", "DestPos", "destPos", "destName", "DestParent", "altParent", "DestDir", "DestRef", "srcPath", "restFile", "sortFont", "originPath", " destDirectory", "destFont", "descNet", "foreignStream", "declFull", "DestPoint", "identPath", "DestFile", "gestHost", "descKey", "gestNode", "estRef", "sortDir", "srcLog", " destPos", "restPoint", "destNode", " destNode", "altPath", "descPath", "estKey", "destStream", "gestDisk", "destDirectory", "estName", " destRoot", "DestDirectory", "destTh", "DestFull", " destDir", "gestPath", " destTh", "estDir", "DestStream", "privPos", "destDisk", "gestNet", "sortPath", "destFull", "privDir", "locDisk", "potStream", "descTime", "altDir", "destTime", "destParent", "destPoint", "destDir", "DestPort", "sortFull", " destFile", "destNet", "srcDirectory", " destRef", "destHost", "destKey", "destLog", "DestPod", "estPos", "DestFont", "descName", "DestRoot", "DestLog", "privRoot", "locPath", "srcFile", "potPod", "gestName", "descDisk", " destLog", "foreignDir", "declPath", " destKey", "restPath", "DestName", " destParent", " destName", "descPos", "locNet", "declFont", "altPoint", "identPort", "gestTime", "destPod", "estPath", "altNode", "altName", " destPort", "identTh", "altHost", "foreignPod", "originPoint", "foreignPath", " destPoint", "potPath"], "lastVerPath": ["highestVerPath", " lastVersLog", "lastVersionCh", "lastverpath", "highestVERPath", "lastverForm", "lastVerLog", "lastVersPath", "lastVERpath", "lastVersCh", "lastVersionpath", "lastverName", "lastVersName", " lastVersFile", "lastverLog", "lastVerName", "lastVerDir", "lastverDir", "highestVerpath", "lastResDir", "highestVerFile", "highestVERVal", "lastVerForm", " lastVersCh", " lastVersPath", "highestVERpath", "lastResPath", " lastVerForm", " lastVerDir", " lastverForm", "lastverFile", "lastVERFile", "lastVerspath", "lastVERForm", "lastResForm", "lastVERVal", "highestVerVal", "lastverCh", " lastverDir", "lastVersFile", " lastVerName", " lastverPath", "lastVerVal", "lastVersionFile", " lastverpath", "lastVersionPath", " lastVerLog", "lastVersVal", "lastVERPath", "highestVERFile", "lastverPath", " lastVerpath", "lastVerCh", " lastVerFile", "lastVersLog", " lastVerCh", "lastverVal", "lastRespath", "lastVerFile", "lastVerpath", "lastVERDir"], "bkdir": ["blkgroup", "bakdi", "bqdi", "BkDir", "Bkpath", "bckdi", "blkfd", "bkpath", "bkkDIR", "bkkDir", "bkDir", "bkkfolder", "bukgroup", "bakDir", " bakdir", "bkrel", "bkkpath", "bukDIR", "bkfolder", "bckpath", " bkkDir", "bkgfolder", "blkjgroup", " bkDir", "bkdi", "bkjgroup", "bkjdi", "Bckdir", "bukdir", "blkjdir", "blkjfd", " bakfolder", "bkDIR", "bakfolder", " bkdi", "bckDIR", "bckDir", " bkfolder", "bkkdi", "blkdi", "bukpath", "bakrel", "Bkdir", "BckDIR", "bkkdir", "bkfd", " bkkrel", " bkrel", "bukfd", "blkdir", "bkgrel", "bqfd", "BkDIR", "Bckpath", " bkkfolder", "blkjdi", " bakDir", "bkjfd", "BckDir", "bukDir", "bckfolder", "bqgroup", "bukdi", " bkkdir", "bkjdir", "bkgroup", "bakdir", "bkkrel", "bqdir", "bkgDir", " bakdi", "bckdir", "bkgdir"], "oldClassCopied": ["oldclassCopie", "oldDirReplried", "oldClasscopied", "oldclassCopied", "oldDirReplies", "oldClassReplified", "oldClassCopyied", "oldClasscopified", "oldDirCopies", "oldDirRepliated", "oldclassCopaced", "oldClassCopyies", "oldClasscopie", "oldClassCopiated", "oldclasscopified", "oldDirCopiated", "oldClasscopies", "oldclasscopie", "oldClassReplied", "oldClassReplried", "oldClassCopyie", "oldDirCopied", "oldClassColies", "oldClassColied", "oldClassChiated", "oldClassChried", "oldClassCopified", "oldClassCopyified", "oldClasscopried", "oldClassCopie", "oldClassChies", "oldClassCopaced", "oldclasscopies", "oldClassCopies", "oldClassColaced", "oldClassReplies", "oldClassCopried", "oldClassColified", "oldclassCopies", "oldclasscopied", "oldDirCopried", "oldDirReplied", "oldClassRepliated", "oldClassChied", "oldclassCopified", "oldClassReplaced", "oldClasscopiated"], "ls": ["LS", "ks", "irs", "lt", "l", "ws", "less", "los", "lis", "lc", "rl", "ists", "qs", "lines", "la", "rs", "lbs", "sels", "les", "its", "acts", "abs", "vs", "dl", "lv", "ms", "ics", "ols", "ars", "cs", "ln", "tl", "xs", "ts", "ats", "fs", "es", "lf", "els", "lists", "ps", "ns", "bs", "ils", "las", "ds", "gs"], "i": ["m", "multi", "ip", "b", "ci", "ui", "batch", "ij", "l", "ji", "it", "ei", "gi", "key", "ami", "I", "chain", "phi", "us", "index", "im", "y", "oi", "ki", "ini", "li", "io", "is", "gu", "ii", "iq", "ski", "bi", "pi", "j", "u", "a", "me", "init", "eu", "cli", "ri", "sim", "mi", "ti", "hi", "ix", "id", "di", "ims", "fire", "ic", "x", "si", "xi", "qi", "zi"]}}
{"id1": "17996547", "id2": "9727056", "code1": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "code2": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", "copyfile", "deleteFiles", "deleteDir", "copyFiles", " copyfile", "Copyfile", "CopyFile", "deletefile", " copyDir", "CopyDir", "copyDir", "deleteFile"], "fileToCopy": ["file2Copy", "FILEToCop", "filetoCopy", "FILETOCopy", "fileFromRemove", " fileToDelete", " filetoDelete", "fileToWrite", "fileToDelete", "fileFromDelete", "fileToCop", "fileTOApply", "fileTomRemove", "file2Cop", "FILETOCop", "FILEToApply", " fileToWrite", "FILEToSave", "fileTOSave", "fileTomDelete", "fileFromCopy", "filetoDelete", "fileToSave", " fileToRemove", "FILETOSave", "file2Apply", "fileTOCopy", "fileFromWrite", "FILETOApply", "file2Save", " filetoRemove", "FILEToCopy", "fileToRemove", "fileTomCopy", "filetoWrite", " filetoWrite", " filetoCopy", "fileTOCop", "fileToApply", "filetoRemove", "fileTomWrite"], "copiedFile": ["copifiedDir", "coricedFILE", "copcedFile", "copriedFILE", "callediedFILE", " copcedfile", "callediedDir", "copicedfile", "copriedfile", "copanedPlace", "copIEDFilename", "copicedFile", "copicedFilename", "calledyingFile", "copyingDirectory", " copriedDirectory", "coriedFILE", "copiedDir", "coricedfile", "calledyingPlace", "copifiedFILE", " copiedFolder", "copriedDirectory", " copiedfile", " copiedPath", "partriedFile", "coponefile", "copiedPath", "copifiedPlace", "coricedFilename", "copicedFILE", "coponeFILE", "copiedFILE", "copcedFilename", "copriedFilename", "coriedFile", "copiatedFolder", "copanedFile", "copyingFILE", "copriedPath", "copiedfile", "coricedFile", "copiedLog", "copiedFilename", "copyingLog", " copcedFile", "copiatedDirectory", "coriedfile", "copyingFilename", "copcedfile", "partiedFilename", "copanedFILE", "copanedDir", " copriedFile", "calledyingDir", "copriedLog", "copyingFolder", "copyingPath", " copriedPath", "copiatedFile", "copyingPlace", "partriedLog", "callediedFile", "copifiedFilename", "copIEDFile", " copiedFilename", "calledyingFILE", "partriedFilename", " copriedFolder", "partiedLog", "coponeFilename", "copiedDirectory", "copriedFile", " copcedFilename", "copifiedfile", "copiedPlace", "copyingDir", "copriedFolder", " copiedDirectory", "copiedFolder", "coponeFile", "copiatedPath", "copyingFile", "copifiedFile", "coriedFilename", "callediedPlace", "copIEDLog", "partiedFile"], "in": ["inf", "oin", "IN", "inc", "it", "al", "inner", "cin", "ins", "inv", "input", "doc", "re", "ind", "vin", "rin", "bin", "im", "up", "In", "ini", "inside", "is", "io", "form", "f", "ar", "isin", "init", "con", "iter", "ma", "irm", "ai", "file", "gin", "from", "read", "en", "ain", "get", "conf", "inn", "r", "on", "per", "ains", "out", "din", "i", " din", "source"], "outWriter": ["OUTWriting", "OUTwriter", "innerWriter", "innerWrite", "outputHandler", "innerHandler", "outputStreamer", "OutReader", "outputWriting", "backStreamer", "outputwriter", "backWriter", "outputReader", "outputStream", "backReader", "outHandler", "OUTWriter", " outWrite", "outReader", "outputWrit", "OutWriter", "outputWriter", " outWriting", " outwriter", "OutWrit", "outWrit", "OUTReader", "OutWriting", " outHandler", "outputWrite", "innerStream", "outStreamer", " outStreamer", "outStream", "backwriter", " outReader", "outWriting", " outWrit", "outwriter", "outWrite", " outStream"], "c": ["d", "m", "v", "n", "cache", "code", "ac", "l", "cd", "cp", "lc", "k", "cos", "chain", "q", "dc", "cf", "col", "char", "ct", "uc", "f", "cont", "cut", "count", "u", "rc", "ch", "cr", "nc", "e", "cap", "cb", "cmp", "pc", "unc", "cs", "mc", "ce", "t", "gc", "cl", "bc", "sc", "C", "cm", "ec", "r", "cc", "out", "i", "character"]}}
{"id1": "9954926", "id2": "21033686", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "label": 0, "substitutes": {"simulate": ["simure", " simulation", "smulation", "modulates", "smulates", "modure", "simulates", " simulates", "simulation", " simure", "modulate", "modulation", "smure", "smulate"], "out": ["b", "cache", "print", "list", "null", "in", "it", "hit", "ins", "state", "c", "io", "client", "sys", "ger", "init", "con", "manager", "go", "w", "t", "exp", "gr", "o", "report", "n", "to", "raw", "v", "ex", "inner", "flush", "store", "at", "base", "os", "up", "Out", "aos", "cmd", "copy", "handle", "gov", "help", "ent", "set", "content", "output", "pool", "buffer", "p", "nt", "batch", "screen", "conn", "err", "sum", "OUT", "writer", "f", "write", "put", "nr", "last", "can", "all", "conf", "OU", "outs", "on", "pretty", "tree", "gen", "obj", "inv", "res", "group", "name", "error", "ou", "outer", "co", "e", "gc", "log", "cfg", "net", "cn", "conv"], "file": ["b", "report", "l", "data", "filename", "play", "input", "base", "template", "name", "table", "document", "io", "type", "f", "ile", "channel", "fp", "connection", "e", "port", "le", "format", "t", "resource", "File", "handle", "library", "result", "log", "set", "model", "console", "output", "db", "lock", "path", "message", "pool", "buffer", "FILE", "source"], "obtainUserReputationRequest": ["obtainUserRepetitionRequest", "obtainUserRepositoryQuery", "obtainUserRepresentationError", "obtainUserReputationTarget", "obtainUserRepresentationResponse", "obtainUserRepresentutationError", "obtainUserReputationsTask", "obtainUserRelutationTask", "obtainUserReputationrequest", "obtainUserRepetitionResponse", "obtainUserReputationsResponse", "obtainUserReporationQuery", "obtainUserRepationTarget", "obtainUserReplutationRequest", "obtainUserRelutationResponse", "obtainUserReputationsQuery", "obtainUserRepresentutationRequest", "obtainUserReplutationTarget", "obtainUserReporationError", "obtainUserRelutationsResponse", "obtainUserRelutationQuery", "obtainUserRelutationRequest", "obtainUserRepresentutationTarget", "obtainUserRepationrequest", "obtainUserReplutationResponse", "obtainUserReputionResponse", "obtainUserReputationQuery", "obtainUserReporationRequest", "obtainUserReputationsRequest", "obtainUserRepationError", "obtainUserRepresentationrequest", "obtainUserRepationResponse", "obtainUserReputionrequest", "obtainUserRepationRequest", "obtainUserRepationQuery", "obtainUserRepresentutationrequest", "obtainUserReputationsrequest", "obtainUserReputionTarget", "obtainUserRelutationsQuery", "obtainUserReputationError", "obtainUserRelutationsRequest", "obtainUserRelutationsTask", "obtainUserRepresentationQuery", "obtainUserRepresentationTarget", "obtainUserRepositoryTask", "obtainUserRepresentutationResponse", "obtainUserReputationsError", "obtainUserReporationResponse", "obtainUserRepresentationRequest", "obtainUserReputionTask", "obtainUserRepositoryResponse", "obtainUserRepetitionTarget", "obtainUserRepresentutationQuery", "obtainUserReputionQuery", "obtainUserReputationTask", "obtainUserRepositoryRequest", "obtainUserReputionRequest", "obtainUserReputationsTarget"], "obtainUserReputationResponse": ["obtainUserRepulationService", "obtainUserRepulationResponse", "obtainUserRepositoryAnswer", "obtainUserReportositoryAnswer", "obtainUserReputationsResp", "obtainUserRepositoryService", "obtainUserReportositoryResponse", "obtainUserReputationsResponse", "obtainUserReputationService", "obtainUserReportositoryResp", "obtainUserRepulationResp", "obtainUserReputationResp", "obtainUserReportositoryService", "obtainUserReportutationAnswer", "obtainUserReputationAnswer", "obtainUserRepositoryResp", "obtainUserReportutationResp", "obtainUserReportutationResponse", "obtainUserReputationsAnswer", "obtainUserReportutationService", "obtainUserRepositoryResponse", "obtainUserReputationsService", "obtainUserRepulationAnswer"], "rateUserRequest": ["RateUserResponse", "rateJobRequest", "rateOwnerRecord", "createUserCommand", "rateTimeRequest", "rateRowResponse", "createUserRequest", "raceUserrequest", "rateOwnerResponse", "rateOwnerRequest", "rateLineResponse", "RateUserRequest", "createuserRequest", "rateUserChange", "scaleOwnerResponse", "RateLineQuery", "rateUsersRequest", "rateJobResponse", "raceRowRecord", "rateSampleCommand", "rateClientrequest", "rateSampleRequest", "rateOwnerrequest", "rateUserQUEST", "RateClientResponse", "createUserRequ", "rateJobChange", "scaleOwnerRequest", "RateClientGrant", "RateLineResponse", "rateUserJob", "rateLineGrant", "rateUserGrant", "rateOwnerAccess", "scaleUserRequest", "rateClientGrant", "rateLineRequ", "rateDateGrant", "RateUsersRequest", "raceUserRequest", "rateLineQuery", "RateClientRequest", "rateSamplerequest", "rateUserAccess", "rateLinerequest", "rateProxyResponse", "raceUserRecord", " rateUserJob", "rateUserQuery", "RateUsersQuery", "rateUserRequ", "rateuserCommand", " rateUserrequest", "rateuserQUEST", "rateUsersAccess", "rateuserResponse", "rateSampleRequ", "scaleUserAccess", "rateClientRequest", "rateUsersQuery", "rateUserCommand", "rateRowRecord", "rateRowrequest", " rateUserQuery", "rateTimeResponse", "rateRowJob", "rateProxyRequest", "createuserrequest", "rateUsersQUEST", "rateRowRequest", "rateUsersrequest", "createuserCommand", "rateUsersResponse", "rateTimerequest", "raceRowRequest", "RateUsersQUEST", "rateProxyQuery", "rateuserQuery", "RateUserQuery", "rateDateRequest", "rateClientResponse", "rateUsersChange", "rateUserRecord", "rateuserRequ", "RateUserChange", "RateUserrequest", "scaleUserResponse", "rateDateResponse", "createUserrequest", "RateUsersrequest", "rateuserrequest", "rateProxyQUEST", "RateUsersResponse", "RateUserQUEST", "createuserRequ", "RateLineRequest", "rateLineRequest", "RateUserGrant", "rateuserRequest", "rateuserAccess", "RateLinerequest", "rateLineCommand", "RateUsersChange", "rateClientJob", "rateUserrequest", "scaleOwnerAccess", "raceRowrequest"], "rateUserResponse": ["RateUserResponse", "ratesUserMessage", "rateClientReturn", "rateControllerRequest", "rateTimeRequest", "rateControllerMessage", "rateUsersReply", "rateMethodVersion", "rateUserReply", "rateTimeAnswer", "RateUserRequest", "ratesClientResp", "rateUserResp", "rateFileresponse", "rateUsersRequest", "rateWordRequest", "rateFileRequest", "rateWordReturn", "ratesUserResponse", "rateMemberResponse", "rateUserReturn", "ratesClientMessage", " rateClientResponse", " rateClientRequest", "rateMethodRequest", "rateMethodResponse", "RateUsersRequest", "rateUserVersion", "RateUserVersion", "RateUsersReply", "rateuserresponse", "rateMemberReply", "RateUsersresponse", "rateUserMessage", "rateManagerMessage", "rateUserresponse", "ratesUserRequest", "rateWordresponse", "rateFileResponse", "rateMemberresponse", "rateuserResponse", "rateUserAnswer", "rateDateVersion", "rateMemberRequest", "RateUserresponse", "RateUserReply", "rateDateData", "rateMethodData", "rateClientRequest", "rateTimeResponse", " rateUserStatus", " rateUserAnswer", "rateManagerRequest", " rateUserReturn", " rateUserresponse", "rateUsersStatus", "rateUserStatus", "rateUsersResponse", "rateControllerResponse", "rateControllerResp", "rateManagerResponse", "rateUserData", " rateClientresponse", "ratesClientResponse", "ratesUserResp", "rateDateRequest", "rateClientResponse", "RateUserData", " rateClientReturn", "rateClientResp", "rateWordResponse", "rateClientresponse", "rateuserReply", "rateTimeStatus", "rateDateResponse", "rateUsersresponse", "rateClientMessage", "RateUsersResponse", "rateManagerResp", "rateuserRequest", "rateUsersAnswer", "ratesClientRequest", "rateFileReturn"], "fis": [" fisa", "bis", "liss", "lis", "bisa", "fiss", "fIs", "sfIs", "fisa", "FIs", "flis", "lIs", "fi", "bi", "fli", "Fiss", "fIS", "sfIS", "Fis", "flisa", " fi", "sfis", "sfiss", "FIS", "lIS"], "br": ["browser", "BR", "pr", "bh", "tr", "ctr", "bd", "ber", "wr", "adr", "dr", "bt", "kr", "bp", "shr", "str", "bi", "buf", "bn", "ch", "cr", "bf", "ger", "bro", "div", "nr", "be", "mr", "vr", "gb", "hr", "fr", "bm", "bl", "lr", "gr", "sr", "Br", "bridge"], "call": ["Call", "report", "n", "code", "list", "continue", "command", "use", "function", "cin", "dial", "test", "execute", "play", "inv", "label", "ell", "status", "c", "name", "trace", "char", "callback", "str", "cell", "send", "contact", "comment", "draw", "request", "info", "block", "word", "check", "add", "url", "called", "result", "log", "query", "update", "all", "cal", "message", "action", "frame", "bridge", "line"]}}
{"id1": "17724879", "id2": "8064604", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"getDigest": ["getdigest", " getMDse", "getHashested", "getdigse", "getDigEST", "getMDEST", "getMDest", "getDigse", "getDigested", " getMDEST", "getHashest", "getdigested", " getMDested", " getMDest", "getMDested", " getDigested", "getdigEST", " getDigse", "getMDse", "getHashEST", " getDigEST", "getHashse"], "attribute": ["report", "entry", "att", "Attribute", "operation", "command", "policy", "space", "operator", "al", "data", "address", "missing", "property", "input", "attr", "directory", "expression", "information", "at", "name", "document", "description", "type", "password", "definition", "associated", "subject", "pair", "application", "and", "element", "request", "position", "word", "metadata", "add", "value", "argument", "qualified", "ribute", "member", "variable", "article", "relation", "object", "management", "event", "ident", "message", "option", "reference", "a", "each", "communication", "character", "item"], "digestAlgorithm": ["digestPalgorith", "digestalgorithm", "digestSchego", "digestALgorithm", "digesterAlgorith", "digestSchegorithm", "digesterAlgo", "digesterAlgorithm", "digestsAlgorithm", "digestPalgo", "digestALgebra", "digestalgo", "digesteralgorithm", "digestsAlgo", "digestAlgorith", "digestPalgebra", "digestAlgo", "digestalgorith", "digesteralgebra", "digestAlgebra", "digesteralgo", "digestSchegebra", "digesterAlgebra", "digestALgorith", "digestsalgebra", "digestsalgorithm", "digestALgo", "digestsAlgebra", "digesteralgorith", "digestalgebra", "digestsalgo", "digestPalgorithm"], "digest": ["mdested", "equest", "digests", "Digested", "diagnitude", " digist", "Digest", " digested", "Digests", " digEST", "Digist", "equend", "designests", "designest", "hashest", "mdtest", "digitude", "DigEST", "mdest", "digested", "diagnested", "hashend", "Digtest", "mditude", " digests", "diagnest", " digse", "digtest", "equEST", "digEST", "Digse", "designEST", " digtest", " digitude", "digend", "hashested", "diagnse", "mdse", "digist", "Digend", "digse", "designist", "hashEST", "equested"], "md": ["d", "m", "amd", "mg", "pt", "cd", "js", "ld", "strong", "bd", "pd", "hd", "grad", "MD", "mm", "det", "dr", "ind", "pm", "mac", "cond", "mod", "rpm", "cmd", "dd", "ct", "red", "der", "df", "met", "wd", "pdf", "ms", "nd", "ud", "dh", "mc", "mt", "ma", "mn", "managed", "metadata", "rm", "mind", "mk", "sm", "fd", "sd", "good", "dm", "di", "esm", "mb", "ds", "nt"]}}
{"id1": "12055086", "id2": "3801655", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeleing", " copydeleting", " copydeletving", " copyDeletging", " copyDeeleing", " copyDeleging", " copydeletging", " copyDeeleving", " copyDelingging", " copyDeeleging", " copyDeeleting", " copyDeleving", " copydeletting", " copyDeleing", " copyDeletving", " copydeleving", " copyDelingving", " copyDelinging", " copydeleging", " copyDelingting", " copyDeletting"], "source": ["back", "oss", "SOURCE", "body", "site", "target", "input", "store", "seed", "image", "template", "base", "form", "style", "sql", "src", "scope", "sp", "init", "sample", "ource", "origin", "ace", "Source", "ce", "search", "resource", "from", "local", "service", "se", "original", "start", "query", "spec", "parent"], "dest": ["d", "rest", "null", "comb", "it", "cat", "them", "target", "dist", "mm", "th", "bin", "loc", "decl", "Dest", "end", "nom", "trans", "img", "cas", "pub", "est", "src", "sp", "dir", "st", "origin", "pas", "https", "port", "w", "master", "exp", "del", "lit", "tom", "temp", "way", "orig"], "buf": ["b", "cast", "batch", "capt", "aka", "comb", "bh", "Buffer", "prop", "tab", "cat", "pkg", "cp", "data", "meg", "buffer", "seq", "arr", "uf", "rb", "cmd", "alph", "cf", "bag", "str", "img", "ref", "fg", "br", "buff", "cap", "cb", "box", "bytes", "pause", "vec", "block", "cur", "fb", "cv", "tx", "bc", "eb", "bl", "db", "Buff", "bs", "conv", "bus"], "in": ["inf", "IN", "inc", "it", "al", "inner", "cin", "ins", "user", "input", "mm", "el", "ind", "rin", "bin", "inside", "In", "ini", "is", "by", "or", "un", "ze", "isin", "init", "con", "info", "iter", "ri", "ai", "from", "gin", "read", "en", "inn", "on", "per", "ic", "din", "i"], "out": ["o", "v", "to", "n", "dis", "conn", "oss", "inner", "sum", "flush", "obj", "res", "OUT", "at", "os", "up", "ou", "Out", "io", "aos", "writer", "client", "by", "end", "outer", "sys", "conv", "co", "write", "con", "ion", "t", "log", "auto", "can", "en", "output", "outs", "on", "net", "i", "cn", "ne", "page", "nt"], "count": ["n", "acc", "code", "batch", "ctr", "num", "span", "amount", "sum", "q", "found", "index", "total", "ind", "cond", "c", "len", "char", "ct", "core", "number", "cont", "ch", "common", "cap", "comment", "Count", "counter", "size", "check", "add", "t", "coll", "now", "start", "max", "cloud", "read", "ount", "current", "deep", "conf", "nb", "cc", "length", "z", "nt"]}}
{"id1": "2461169", "id2": "4118412", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFile2String", "decodeString2Files", "decodeFile2Files", "decodeFileFileFile", "decodeFileAsfile", "decodeFileToString", "decodeStringToFile", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToFiles", "decodeFileAsFile", "decodeFileFilefile", "decodeFile2file", "decodeString2file", "decodeStringTofile", "decodeFileAsString", "decodeString2String", "decodeFile2File", "decodeFileAsFiles", "decodeStringToString", "decodeFileToFiles", "decodeString2File"], "infile": ["inputname", "outname", "outfilename", "isinname", "isinfile", "inputfolder", "Infilename", "outfolder", "outbase", "inputFile", "Inbase", "isinFile", "inbase", "infolder", "fromFile", "Infile", "InFile", "inputfile", "inname", "frombase", "isinfolder", "inFile", "fromfile", "outFile", "infilename", "fromfilename"], "outfile": ["indir", "Outdir", "outname", "outfilename", "Outfile", "Outfilename", "toFile", "OutFile", "otname", "otfile", "otFILE", "tofilename", " outFILE", "inFILE", "outdir", "todir", "inname", "otFile", "tofile", "inFile", " outname", "outFile", "outFILE", "infilename", " outFile"], "in": ["inf", "conn", "oin", "IN", "it", "inc", "pin", "al", "inner", "cin", "ins", "input", "re", "ind", "rin", "bin", "im", "up", "In", "inside", "is", "ini", "form", "by", "or", "ar", "amin", "isin", "init", "con", "info", "iter", "nin", "t", "gin", "from", "id", "en", "ain", "get", "inn", "on", "per", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "print", "null", "ex", "oss", "it", "inner", "flush", "res", "OUT", "at", "os", "io", "ou", "Out", "aos", "writer", "fn", "end", "outer", "sys", "co", "write", "ot", "con", "ion", "opt", "t", "file", "auto", "gt", "can", "en", "g", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "header", "black", "memory", "paste", "window", "padding", "total", "available", "template", "base", "bone", "shape", "button", "table", "sequence", "document", "bar", "attribute", "password", "pad", "buf", "number", "row", "mem", "phrase", "note", "sample", "buff", "append", "comment", "stack", "info", "column", "block", "library", "variable", "binary", "initial", "view", "message", "temp", "display", "history", "frame", "character"], "read": ["n", "need", "give", " Read", "raw", "print", "shift", "push", "skip", "input", "index", "reading", "reader", "ind", "req", "seek", "load", "hold", "open", "Read", "end", "count", "send", "first", "write", "through", "iter", "size", "check", "wait", "connect", "add", "stream", "allow", "range", "start", "READ", "close", "query", "set", "find", "get", "ok", "run", "i", "before", "each", "length", "ready", "reads", "text", "select", "readable", "len"], "success": ["submit", "sufficient", "summary", "continue", "Success", "condition", "second", "cess", "city", " succ", "status", " successful", "ccess", "response", "accept", "democracy", "error", "town", "unity", "danger", "please", "exist", "commit", "snap", "valid", "first", "scope", "safe", "surv", " failure", "ceed", "setup", " okay", " successes", "primary", "same", "support", "complete", "value", "crit", "successfully", "result", " succeeds", "successful", "release", "ratulations", "good", "photo", "ok", "fail", " succeed", "done", "positive", "growth"]}}
{"id1": "62362", "id2": "21824901", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Conprocess", "compversion", "converting", "conversion", "Converting", "Converts", "ConVERT", "CONvert", "consVERT", "unprocess", "compvert", "compverts", "consverting", "consversion", "CONversion", "converts", "unfer", "unversion", "Converted", "Conversion", "unverts", "conVERT", "compprocess", "consvert", "CONverting", "Confer", "CONVERT", "converted", "unverted", "confer", "CONfer", "Convert", "conprocess", "CONverted", "unvert"], "src": ["http", "rest", "source", "pkg", "ebin", "SOURCE", "href", "filename", "rel", "ins", "ser", "input", "dist", "attr", "hl", "RC", "req", "rs", "scene", "rx", "loc", "iv", "ipl", "its", "str", "cont", "img", "scan", "sys", "usr", "orig", "func", "rc", "ur", "st", "upload", "ource", "Source", "cur", "stream", "inst", "url", "file", "from", "s", "buster", "start", "sit", "config", "sc", "host", "sin", "addr", "path", "cc", "sr", "txt", "sq", "uri", "SourceFile"], "dest": ["rest", "disk", " dst", " Dest", "dat", "test", "target", "tif", "dist", "table", "Dest", " destinations", "img", "est", "write", " Destination", "dir", "port", "gin", "mat", "result", " orig", "foreign", "temp", " destination", "txt", "orig", "source"], "in": ["inf", "d", "m", "b", "IN", "l", "ad", "inner", "cin", "ins", "el", "input", "res", "reader", "ind", "rin", "bin", "up", "In", "is", "io", "ar", "sql", "isin", "serv", "st", "stream", "file", "from", "en", "as", "inn", "r", "i", "din", "source"], "p": ["ping", "pb", "pl", "d", "parse", "m", "b", "pt", "l", "pg", "ap", "it", "cp", "pkg", "pd", "h", "wp", "post", "pe", "pa", "dp", "parser", "at", "pm", "rep", "c", "pro", "jp", "php", "f", "tp", "fp", "pi", "j", "lp", "sp", "pc", "py", "er", "pers", "t", "P", "pre", "vp", "pp", "ph", "part", "op", "g", "prot", "per", "ps", "r", "i"], "ds": ["ks", "pd", "hd", " os", "hs", "dl", "ys", "uds", " des", "iffs", " ads", "amps", "ps", "dt", "bs", "ils", "terms", "sets", "ws", "qs", "edes", "os", "cks", "dd", "ras", "eps", "ags", "loads", "ts", "ports", "gs", "mys", "js", "tags", "Ds", "points", "aws", "obs", "des", "tests", "df", "vs", "dh", "cs", "eds", " DS", "drivers", "xs", "s", "dds", "sts", "ats", "sd", "ands", "nas", "docs", "di", "db", "outs", "ns", "ls", "d", "dates", "DS", "dp", "gd", "posts", "rs", "yes", "ods", "ss", "ads", "its", "tp", " dd", "dos", "tes", " d", "scripts", "workers", "els", "lists"], "format": ["parse", "lat", "Format", "sche", "mode", "l", "policy", "it", "settings", "filter", "MAT", "at", "status", "template", " Format", "shape", "name", "table", "layout", "type", "cf", "form", "ct", "feature", "f", "style", "top", "fc", "unit", "act", "pi", "fm", "module", "title", "version", "mt", "size", "t", "file", "mat", "feat", "pattern", "ats", "set", "id", "spec", "output", "tag", "path", "pretty", "source"], "hasPixelData": ["hasixelDATA", "HaspixelData", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasPixelDATA", "hasixeldata", "HaspixelDATA", "haspixelDATA", "hasFrameData", "hasixelData", "hasFramedata", "HasPixelData", "Haspixeldata", "haspixelData", "HasPixelDATA", "HasPixeldata", "hasFrameDATA", "hasPixeldata"], "inflate": ["invalidATE", "Informat", "Inflat", " invalidocate", "Informocate", "inflat", "inFLocate", "inFlicate", "inflocate", " invalidate", " inflicate", "informocate", "Informate", " invalidicate", "inFlATE", "informated", "infolated", "invalidocate", "inflated", "infolat", "informate", "inflATE", " invalidATE", "inFLated", "infolate", "incelocate", " inflATE", "inflicate", "informat", "inFlocate", "incelicate", "inFlate", "incelate", "invalidicate", "Inflate", "invalidate", " inflocate", "inFLate", "infolocate", "inFLat", "Inflocate", "Informated", "Inflated", "incelATE"], "pxlen": ["xplen", "pixelfun", "mmlength", "pexlen", "pxden", "pxls", "packls", "pxlength", "pixellength", "packdec", "xpln", "xpden", "pixells", "mxlen", "tmplen", "xylin", "mxln", "mmln", "cplen", "phplength", "pxlin", "packlength", "pexden", "mxlength", "pexlength", "cplength", "pexfun", "mmlin", "xyln", "cpden", "pxln", "tmplength", "phpln", "packln", "xylen", "cpln", "phplen", "pexln", "mmlen", "pexls", "phpdec", "packfun", "xplength", "tmpln", "pxfun", "mxdec", "pxdec", "packlen", "pixellen", "tmplin", "xylength"], "out": ["print", "screen", "list", "conn", "ex", "err", "sum", "obj", "inv", "res", "store", "user", "OUT", "msg", "group", "name", "up", "prefix", "ou", "io", "Out", "writer", "aos", "cmd", "client", "outer", "sys", "init", "dir", "ln", "gov", "crit", "log", "inter", "cfg", "outs", "output", "gr", "temp", "net", "pretty"]}}
{"id1": "8625346", "id2": "13565787", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileAsFile", "encodeFiletoFiles", "encodeFileFromDisk", "encodeFileAsStream", "encodeStringToDisk", "encodeStringToFiles", "encodeStringAsFiles", "encodeFileFromStream", "encodeFileToFiles", "encodeFiletoFile", "encodeStringAsFile", "encodeFileToStream", "encodeFiletoDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileFromFile", "encodeFiletoStream", "encodeStringToStream", "encodeStringToFile", "encodeStringAsDisk", "encodeFileAsDisk", "encodeStringAsStream", "encodeFileAsFiles"], "infile": ["outfilename", "inpath", "inputpath", " inbase", " infilename", "outbase", "inputFile", "Inbase", "inbase", " inFile", "Infile", "InFile", "inputfilename", "inputfile", "outpath", "Inpath", "inFile", "outFile", " inpath", "infilename"], "outfile": ["indir", "newfile", "outfilename", "outname", "infp", "toFile", " outfilename", "newfilename", "fromFile", "newFile", "outdir", "todir", "inname", "fromdir", "fromfp", "tofile", "inFile", " outname", "fromfile", "outFile", "outfp", "newname", "tofp", "infilename", " outFile"], "in": ["inf", "conn", "oin", "IN", "it", "inc", "pin", "al", "inner", "cin", "ins", "ro", "input", "re", "ind", "image", "rin", "bin", "im", "up", "In", "inside", "is", "ini", "form", "by", "or", "ar", "amin", "isin", "init", "con", "info", "iter", "nin", "t", "gin", "from", "id", "en", "ain", "get", "inn", "on", "per", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "print", "null", "ex", "oss", "it", "inner", "flush", "res", "OUT", "at", "os", "up", "io", "ou", "Out", "aos", "writer", "fn", "end", "outer", "sys", "co", "write", "ot", "con", "ion", "opt", "t", "file", "gt", "can", "en", "g", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "header", "black", "memory", "paste", "window", "padding", "total", "available", "template", "base", "bone", "button", "table", "sequence", "document", "bar", "attribute", "password", "pad", "buf", "number", "row", "queue", "mem", "phrase", "note", "sample", "buff", "append", "comment", "stack", "info", "column", "block", "library", "variable", "binary", "initial", "view", "message", "temp", "display", "history", "length", "frame", "character"], "read": ["n", "need", "give", " Read", "raw", "print", "push", "skip", "input", "reading", "index", "reader", "ind", "req", "seek", "load", "hold", "open", "Read", "end", "count", "send", "first", "write", "through", "iter", "size", "check", "wait", "connect", "add", "stream", "allow", "range", "start", "READ", "close", "query", "set", "find", "get", "ok", "run", "i", "before", "each", "length", "ready", "reads", "text", "select", "readable", "len"], "success": ["submit", "sufficient", "summary", " Success", "continue", "Success", "condition", "warning", "second", "cess", "city", " succ", "status", " successful", "ccess", "response", "accept", "democracy", "error", "town", "unity", "danger", "please", "commit", "snap", "valid", "first", "safe", "surv", " failure", "ceed", "setup", " okay", "ith", " successes", "primary", "same", "support", "value", "complete", "crit", "successfully", "result", "successful", "release", "ratulations", "good", "photo", "ok", "fail", "done", "positive", "growth"]}}
{"id1": "293167", "id2": "8665321", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["DoVersionCheck", "doDatecheck", "doDateUpdate", "doLicenseUpdate", "doLicenseCheck", "doLicenseFix", "doLicensecheck", "doDateFix", "doVersionsUpdate", "doVersionsCheck", "DoVersionUpdate", "doVersionUpdate", "DoDateCheck", "doVersionscheck", "doVersionFix", "doVersioncheck", "DoVersionFix", "DoDateFix", "DoDatecheck", "DoVersioncheck", "DoDateUpdate", "doDateCheck", "doVersionsFix"], "view": ["browser", "http", "report", "v", "print", "web", "html", "show", "blade", "server", "q", "call", "doc", "input", "views", "window", "index", "controller", "hl", "image", "self", "eye", "document", "layout", "iew", "open", "table", "wrapper", "form", "client", "View", "engine", "row", "cell", "subject", "context", "review", "manager", "block", "check", "cv", "file", "help", "widget", "query", "model", "update", "console", "VIEW", "get", "see", "host", "tv", "component", "this", "display", "util", "out", "page", "buffer", "tree"], "url": ["browser", "http", "pl", "b", "v", "link", "null", "web", "l", "socket", "ll", "html", "rl", "address", "rel", "date", "string", "location", "hl", "lb", "oul", "loc", "language", "char", "client", "f", "str", "ul", "json", "ssl", "dl", "org", "ur", "nl", "bel", "mount", "URL", "gl", "file", "log", "Url", "sl", "id", "github", "host", "lr", "r", "path", "ls", "uri"], "in": ["inf", "b", "n", "IN", "l", "inc", " IN", "inner", "cin", "body", "ins", "input", "reader", "vin", "rin", "In", "is", "f", "isin", "kin", "init", "info", "ln", "asin", "mn", "stream", "file", "gin", "mat", "ain", "inn", "sin", "out", "din", "i", " din", "source"], "bin": ["b", "cache", "conn", "thin", "mon", "ebin", "cin", "inner", "abin", "cos", "buffer", "spin", " bins", "reader", "obin", "rin", " Bin", "rb", "by", "bi", "bed", "bn", "mem", "sam", "bg", "buff", "con", "pipe", "ln", "win", "file", "gin", "ran", "local", "loader", "binary", "bl", "stock", "inn", "sin", "nb", "lib", "out", "din", "bur", " din", "len"], "line": ["entry", "link", "print", "code", "l", "err", "record", "cat", "lin", "eline", "body", "chain", "el", "no", "store", "string", "lines", "one", "lo", " Line", "base", "state", "load", "field", "cmd", "col", "char", "trace", "style", "cell", "row", "Line", "ine", "inline", "sample", "ls", "liner", "comment", "section", "column", "ide", "ln", "block", "iter", "level", "word", "port", "le", "LINE", "file", "lane", "range", "se", "log", "job", "part", "ice", "point", "path", "page", "channel", "frame", "text"], "version": ["browser", "v", "scale", "command", "project", "serial", "usage", "key", "Version", "test", "hash", "major", "VER", "virtual", "date", "index", "string", "software", "VERSION", "volume", "image", "status", "video", "name", "sequence", "description", "latest", "type", "license", "feature", "river", "form", "client", "vers", "ver", "number", "language", "iso", "title", "info", "position", "ion", "vision", "value", "resource", "format", "versions", "release", "update", "match", "spec", "tag", "translation", "python"], "build": ["dev", "b", "building", "print", "link", "project", "struct", "use", "install", "full", "test", "hash", "develop", "date", "dist", "th", "ble", "ward", "load", "ship", "builder", "boost", "hold", "uild", "built", "latest", "ver", "style", "other", "unit", "Build", "work", "where", "old", "be", "add", "last", "bor", "log", "make", "release", "update", "match", "binary", "round", "bug", "db", "arch", "lib", "tag", "fail", "util"]}}
{"id1": "23672408", "id2": "7911686", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyIconfiles", " copyIconImages", "copyiconfiles", "copyiconImages", " copyiconFiles", " copyiconDocuments", " copyIconfiles", "copyIndexfiles", "copyIconImages", "copyiconFiles", " copyiconImages", "copyIconDocuments", "copyiconDocuments", "copyIndexFiles", "copyIndexDocuments", "copyIndexImages", " copyiconfiles", " copyIconDocuments"], "clazz": [" clbo", "classazz", "clbean", " classe", "relaz", " clotted", "chazz", "CLace", "descazz", "colluster", " cluddy", "claz", "colluddy", "Clbo", "callace", " plaz", "descose", "cluster", "descaz", "Close", "CLoser", " plus", "callaz", " closer", "classotted", "sclbean", "escojure", " claz", "relab", "escace", "scloser", "cluddy", "relose", " plub", "classuddy", "escazz", "crub", "chotted", " club", "plazz", "collazz", "Claz", " clus", "escotted", "sclace", "classe", "pkgazz", "chojure", " clbean", "sclazz", "callbo", "CLazz", "pkgasse", "plasse", "clab", "Clab", "classuster", "clace", "close", "clojure", "club", "clus", " clashed", "pkgashed", "chace", "pkgaz", " clojure", "collotted", "Clace", "plashed", "crus", " plazz", "descab", "clashed", "closer", "clbo", "crazz", "plaz", "Clazz", "craz", "clotted", " cluster", "callazz", "relazz", "CLbean", " clace"], "i16": ["amiShort", "li2016", "iniShort", "i19", "iShort", "iri16", "i6", " i24", "ji150", "i63", "ami19", "i160", "ami16", "ami150", "ji63", "i24", " i2016", "ami63", "pi63", "ii160", "i150", "ini2016", "ini24", "ii16", "li19", "ri16", "i157", " i157", " i160", "ri6", "ami2016", " i6", "ini216", "i216", "ini19", "iri6", "ini160", "ji16", "liShort", "iri2016", " i216", "pi150", "iri157", "ami6", "ri2016", "li16", "ini16", "ri157", "pi16", "pi6", "ji6", "ii24", "i2016", "ii216"], "fileType": ["viewTYPE", "iletype", "policyHandler", "webTYPE", "treeTYPE", "fileTime", "fileTyp", "issuePattern", "ilePattern", "treetype", " fileTyp", "formName", " fileValue", "formType", "fieldTyp", "fileDef", "webType", "coreHandler", "coreDef", "fieldDef", " filePattern", "fieldType", "coreType", "ileType", " fileTYPE", "eventUnit", "ileTyp", "resourceTYPE", " filetype", "viewValue", "fieldTYPE", "policyType", "formatTime", "fileList", "FileName", "filetype", "issuetype", "resourceUnit", "relationHandler", "relationFamily", "resourceFormat", "policyFamily", "formtype", "FileType", "coreTyp", "Filetype", "webDef", "issueType", "treeTime", "fileHandler", "filePattern", "FILEType", "fileValue", " fileTime", "FILEName", "formatTYPE", "fileTYPE", "relationTyp", "formattype", " fileList", "eventTYPE", " fileFormat", "formatType", "formatValue", "issueTyp", "fileUnit", "fileFamily", "webList", "fileName", "viewType", "fileFormat", "treeType", "eventFormat", " fileUnit", "coreFamily", "resourceType", "policyTyp", "viewtype", "FILEtype", "relationType", "eventList", "eventType", "webTyp", "coreTYPE"], "desti16": [" destsi18", "destsi160", "destgi216", "destui2016", "destsi16", "resulti24", "resultii2016", "destsi18", "destui216", "resulti216", "desti24", "destui160", "destsi32", "resultii216", "destui32", "destxi160", "resulti2016", "destgi24", "desti160", "destgi16", "destii2016", "destxi32", " destsi16", "destxi18", "destui18", "destui16", "destxi16", "desti18", "resultii16", "destgi2016", "resulti16", "resultii24", " desti18", "destui24", "desti2016", " destsi160", "desti216", "destii216", "destii16", " destsi32", "destii24", " desti160"], "src": ["comp", "syn", "rest", "bh", "ctr", "pkg", "rl", "inner", "rob", "sec", "proc", "rel", "ctx", "ins", "desc", "ser", "via", "obs", "input", "hl", "std", "req", "rs", "bin", "loc", "iv", "rx", "rb", "scan", "cont", "img", "ssl", "sys", "usr", "sel", "rc", "fc", "nl", "sp", "bg", "st", "cmp", "txt", "cb", "sync", "ln", "sn", "cur", "ptr", "inst", "urg", "cli", "iter", "etc", "sit", "sl", "vr", "sc", "bc", "sol", "isl", "ibl", "sub", "rg", "sb", "tmp", "addr", "dest", "sr", "gs", "ls", "sq", "source"], "dst": [" dest", " dcut", "tgt", "tput", " dmn", "ddmn", "Ddest", "rbl", "ddst", "ngt", " dgt", "rdmt", " dput", "rdest", "dnd", "dddest", "dot", "nnd", "derst", "derdest", "tst", "dsts", "fdest", "dcut", "dsst", "ddnd", "dLot", "dLest", "dLst", " dsts", "dLdest", "fnd", "nput", "rcut", "dLnet", "dnet", "dernd", "tnd", " ddest", "dLbl", "dLcut", "dermn", "ddest", "dsnet", " dnet", "dbl", "dgt", " dbl", "ndst", "nst", "Dst", "ndmt", "rdst", "rst", " dmt", "ndest", "dmt", "dmn", "ndsts", "rdsts", "dsest", "Dnd", " dot", " dnd", " ddr", "dsot", "Ddr", "dest", "dput", "ddr", "fst", "fdr"], "i32": ["pi34", "ip34", "i31", " i86", "ic31", "i22", "i48", "xi32", "i86", "ii342", "ip64", "isi32", " i28", "ii32", "i64", "i342", " i342", "ic86", "ic342", " i34", " i31", "i40", "isi86", "xi22", " i40", "ini22", "i28", "ii28", "ip31", "pi64", "ic22", "ii34", "isi64", "ic48", "pi32", "ini31", " i64", "xi31", "ic34", "ic32", "ic28", "pi31", "ic40", "ic64", "ini48", "isi40", "xi48", "i34", "ip32", "ini32"], "desti32": ["targetpi32", "Desti256", "destI31", "targetpi31", "desti34", "desti90", "DestI31", "destpi30", "targeti34", "targeti31", "targetpi30", "DestI32", "destdi32", "Desti90", "destpi31", "destic34", "desti30", "destu90", "destI256", "DestI90", "destic31", "DestI256", "targeti30", "destpi32", "destu32", "targeti32", "destic32", "destI90", "destdi31", "desti31", "destI32", "destu31", "destdi30", "destic30", "Desti31", "destdi34", "destpi34", "Desti32", "destu256", "targetpi34", "desti256"]}}
{"id1": "15799935", "id2": "20128728", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttentionFile", "saveAttachablePart", "saveExtachedbody", "saveAttentionbody", "saveExtachmentbody", "saveExtachmentBody", "saveAttachedBody", "saveExtachmentFile", "saveAttachedPart", "saveAttachedbody", "saveAttachmentPart", "saveAttachableFile", "saveExtachedBody", "saveExtachedFile", "saveAttentionBody", "saveExtachedPart", "saveAttachableBody", "saveAttentionPart", "saveAttachmentbody", "saveExtachmentPart", "saveAttachedFile", "saveAttachmentFile", "saveAttachablebody"], "context": ["cache", "null", "command", "center", "network", "background", "chain", "ctx", "environment", "system", "response", "state", "template", "java", "document", "cf", "Context", "client", "media", "container", "subject", "connection", "application", "foundation", "contact", "stack", "request", "version", "ce", "search", "support", "service", "present", "config", "tx", "course", "content", "component", "view", "host", "message", "translation", "history", "cc", "comments", "frame", "instance", "current", "parent"], "part": ["report", "partial", "data", "session", "parts", "body", "thread", "post", "instance", "base", "name", "type", "pod", "trans", "top", "pair", "connection", "parent", "sp", "reply", "work", "sample", "and", "version", "PART", "block", "task", "word", "zone", "patch", "add", "Part", "file", "se", "piece", "start", "job", "tx", "bound", "host", "component", "tmp", "message", "temp", "art", "join", "p"], "localAttachment": [" localAttached", " localDetached", " localDetail", "localAssail", "localAcail", " localAssached", "localAttached", " localAssail", " localAttachention", "localAppention", " localAttment", "localAttachention", "localDetail", "localDetachment", "localAttachignment", "localattached", " localAssachment", "localDetignment", "localAttachachment", "localAcached", " localAttail", "localAppail", "localATTignment", "localAppached", "localAssignment", " localAttachachment", " localAttignment", "localAssachment", "localATTachment", " localAttention", "localAttachail", "localAttachached", "localAssment", "localAssention", "localAttail", "localDetached", "localAcignment", "localAssached", " localAttachached", "localDetention", "localATTment", "localAttment", " localDetignment", "localattachment", " localAttachignment", "localAcachment", " localDetachment", "localAppachment", "localATTention", "localAttention", "localAttignment", " localAssention", "localattention"], "accountId": [" accountInt", " accountDb", "accountName", " accountS", "accDb", "accAnd", "containerNum", "accountID", "objectName", "objectById", "objectId", "bankID", " accountID", "accountById", "AccountID", "accID", "AccountName", "accS", "accountAnd", "containerInt", "bankId", "accId", "accountInt", " accountNum", " accountById", "AccountById", "accountDb", "containerId", "bankS", "amountID", "amountId", "accNum", "containerID", "bankAnd", " accountAnd", "objectID", " accountName", "accountS", "AccountId", "accountNum", "accInt", "amountInt", "amountDb"], "attachmentId": ["AttachmentId", "attignmentById", "assachmentID", "attmentid", "assignmentid", "assachmentId", "AttachmentById", "contachmentSerial", "assignmentById", "attachmentSerial", "attmentID", "attignmentid", "contachmentId", "attionSerial", "attachmentID", "attachedById", "AttociationById", "attociationid", "contachedid", "contachedById", "attionId", "attionById", "attacheById", "contachedId", "attachmentById", "attmentId", "attachedID", "AttachmentID", "attignmentId", "assachmentById", "contachmentid", "contachmentById", "attachmentid", "attachedSerial", "assignmentId", "attachedId", "Attociationid", "attociationID", "attignmentID", "attionid", "Attachmentid", "attacheId", "attachedid", "attociationSerial", "attacheID", "attociationById", "contachedSerial", "attacheid", "assachmentid", "assignmentID", "AttociationID", "AttociationId", "attmentById", "attociationId"], "in": ["inf", "m", "raw", "IN", "l", "ex", "inc", "it", "al", "inner", "cin", "body", "sum", "ins", "input", "mm", "ind", "vin", "rin", "bin", "up", "In", "inside", "is", "act", "isin", "ch", "init", "con", "info", "iter", "mc", "ai", "file", "from", "gin", "read", "id", "all", "as", "en", "conf", "inn", "r", "per", "on", "din", "i", "p", "source"], "saveIn": ["aveOut", "sendIn", "sendIN", "getIN", "savAs", "storePath", "saveIN", "secureIn", " savePath", "storeIn", "getIn", " saveOut", "savIn", "aveIn", "saveIns", "getOut", "savePath", "sendOut", "storeIN", "secureIN", "saveOut", "secureIns", "savIN", "getIns", "aveIns", " saveIN", "aveIN", "secureAs", "storeOut", "savIns", " saveIns", "sendPath"], "saveAs": ["submitAS", "saveTo", " saveTo", " saveBy", "aveAS", "SaveAS", "dumpAn", "SaveIn", "aveas", "submitAs", "saveAn", "saveAS", "saveas", "aveIn", "dumpTo", "aveAs", " saveAS", "SaveBy", "aveTo", " saveAn", "dumpAs", "submitBy", "saveBy", "aveAn", "submitas", "SaveAs", "Saveas", "submitIn"], "out": ["o", "v", "to", "n", "null", "oss", "ex", "it", "inner", "sum", "cos", "obj", "inv", "res", "OUT", "one", "os", "name", "up", "ou", "Out", "io", "aos", "outer", "sys", "conv", "co", "serv", "con", "copy", "ao", "t", "gc", "log", "auto", "ent", "can", "all", "OU", "output", "outs", "net", "cn", "i"], "copySize": ["CopyLength", " copyCount", " copyFontSize", "copySIZE", "copyPercent", "CopyFontSize", "pushSize", "likeFontSize", " copyLength", "opySize", "msgPercent", "CopyPercent", "copyLength", "msgSize", "pushLength", "CopySize", "msgLength", "pushCount", "CopyCount", "opyLength", "likeSize", "copyFontSize", "CopySIZE", "opyPercent", "pushFontSize", "likeLength", "copyCount", "likeCount", "opySIZE", "msgSIZE"], "contentUriString": ["contentUristring", "contentUuriNumber", "contentIistring", "contentUrisNumber", "contentUuriString", "contentUiStr", "contentIriString", "contentIriStr", "contentIiString", "contentUriNumber", "contentUnuriStr", "contentUicStr", "contentIiStatic", "contentUicStatic", "contentUnriStr", "contentUrisString", "contentIiStr", "contentUiStatic", "contentUriStr", "contentUiString", "contentUnuriNumber", "contentUuriStatic", "contentUuristring", "contentUnistring", "contentUrisstring", "contentUnriNumber", "contentUriStatic", "contentUnuriString", "contentUistring", "contentUicstring", "contentIriStatic", "contentUnristring", "contentUniString", "contentUuriStr", "contentIristring", "contentUrisStr", "contentUnriString", "contentUniStr", "contentUniNumber", "contentUnuristring", "contentUicString"], "mSize": ["mLength", "moSize", "nLength", "lSize", "moPos", "lPos", "mBytes", "mPos", "lBytes", "nSize", "nPos", "nBytes", "moBytes", "moLength", "lLength"], "mContentUri": ["mContentUris", "mResourceURI", "mContentURI", "mContentIuid", "mContentPRI", "mContentPris", "mResourceUuid", "mContent_ri", "mContentIris", "mResourceUris", "mResourceIris", "mContentPri", "mContentPuid", "mContentUuid", "mContent_uid", "mContentIRI", "mResourceIri", "mContentIri", "mContent_ris", "mContent_RI", "mResourceIuid", "mResourceUri", "mResourceIRI"], "cv": ["pb", "v", "rc", "csv", "cp", "lc", "uv", "av", "desc", "vt", "c", "dc", "xc", "cf", "ct", "ov", "buf", "cont", "sv", "conv", "fc", "nc", "act", "cas", "lv", "cap", "box", "qu", "cb", "qv", "cmp", "nv", "ev", "gc", "vv", "mult", "vol", "vp", "ctrl", "const", "cod", "GV", "vr", "vm", "cm", "CV", "vc", "um", "cc", "cn", "cu", "tc"], "uri": ["report", "ip", "ui", "link", " URI", "address", "q", "iri", "phi", "uni", "folder", "term", "directory", "prefix", "ue", "uid", "subject", "u", "unit", "ur", "dir", "du", "origin", "URI", "ri", "url", "doi", "resource", "handle", "range", "result", " ni", "query", "id", "bid", "picture", "component", "i", "qi", " Uri", "uu"]}}
{"id1": "20128728", "id2": "14317425", "code1": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyfile", " cpFiles", " CopyResource", "copyFiles", "CopFiles", " CopyFiles", "copyResource", "CopFile", " cpFile", " cpResource", " CopyFile", "Copfile", "CopResource", " Copyfile"], "src": ["syn", "usc", "in", "js", "ctr", "rt", "rl", "sec", "ins", "input", "ser", "via", "req", "rs", "rx", "ipl", "sys", "usr", "sv", "sel", "rc", "init", "st", "upload", "Source", "sf", "inst", "cur", "urg", "start", "sit", "sl", "sc", "sb", "urus", "bs", "dest", "sr", "txt", "sq", "source"], "dst": ["pest", "Ddest", "sest", " dost", "snd", "pdest", "dnd", "Dest", "pnd", "hst", " ddest", "pst", "sdest", "dost", "ddest", "hdest", "Dst", "hnd", "Dost", "sst", "host", "Dnd", " dnd", "dest"], "inChannel": ["orStream", " inConnection", " inchannel", " inCommand", "INConnection", "inByte", "intChannel", "InChannel", "inPanel", "inchannel", "outCommand", "netChannel", "cinPanel", " inStream", "INChan", "orCommand", "inConnection", "INChannel", "innerChannel", "netChan", "inStream", "inChan", "inCommand", "INPanel", " inChain", "outChan", "inChain", "vinPanel", "outConnection", "Inchannel", "itChannel", "outchannel", "orChannel", "inButton", "cinChannel", " inChan", " inPanel", "intListener", "itByte", "innerConnection", "intChain", "intByte", "itListener", "innerPanel", "vinButton", "innerChan", "InStream", "vinChannel", "outStream", "InConnection", " inButton", "cinButton", "netConnection", "netPanel", "orChan", "inListener", " inListener", "cinConnection", " inByte", "vinConnection", "itChain"], "outChannel": ["outButton", " outCh", "conChannel", "conChan", "inSection", "OUTChan", "OUTSection", "kButton", "outputchannel", "inMachine", "Outchannel", "kConsole", "inChan", "outCh", "outChan", " outClient", "OutClient", "kChan", "outchannel", "atChannel", " outchannel", "outputChannel", "outputClient", "kChannel", "outSection", "OutChan", "outConsole", " outConsole", "conSection", "OUTMachine", "atChan", "atButton", "OUTChannel", " outChan", "outClient", "OutChannel", "OutCh", "outMachine", "outputChan", "outputCh", " outButton", "conMachine", "atConsole"]}}
{"id1": "22868825", "id2": "6188784", "code1": "    String sendRequest(String[] getVars, String[] postVars, Object[] fileVars, boolean getSessionKey) throws IOException {\n        String uri = wikiBaseURI;\n        if (getVars != null) for (int i = 0; i + 1 < getVars.length; i += 2) uri += (i == 0 ? '?' : '&') + urlEncode(getVars[i]) + '=' + urlEncode(getVars[i + 1]);\n        URL url = new URL(uri);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        if (!getSessionKey) {\n            String cookie = \"\";\n            for (String key : cookies.keySet()) cookie += (cookie.length() == 0 ? \"\" : \"; \") + key + \"=\" + cookies.get(key);\n            conn.setRequestProperty(\"Cookie\", cookie);\n        }\n        if (fileVars != null) {\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; fileVars != null && i + 2 < fileVars.length; i += 3) {\n                ps.print(\"--\" + boundary + \"\\r\\n\");\n                postFile(ps, conn, (String) fileVars[i], (String) fileVars[i + 1], (byte[]) fileVars[i + 2]);\n            }\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print(\"--\" + boundary + \"\\r\\n\" + \"Content-Disposition: \" + \"form-data; name=\\\"\" + postVars[i] + \"\\\"\\r\\n\\r\\n\" + postVars[i + 1] + \"\\r\\n\");\n            ps.println(\"--\" + boundary + \"--\");\n            ps.close();\n        } else if (postVars != null) {\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print((i == 0 ? \"\" : \"&\") + urlEncode(postVars[i]) + \"=\" + urlEncode(postVars[i + 1]));\n            ps.close();\n        }\n        int httpCode = conn.getResponseCode();\n        if (httpCode != 200) throw new IOException(\"HTTP code: \" + httpCode);\n        if (getSessionKey) getCookies(conn.getHeaderFields().get(\"Set-Cookie\"));\n        InputStream in = conn.getInputStream();\n        response = \"\";\n        byte[] buffer = new byte[1 << 16];\n        for (; ; ) {\n            int len = in.read(buffer);\n            if (len < 0) break;\n            response += new String(buffer, 0, len);\n        }\n        in.close();\n        return response;\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["submitRequest", "formResponse", "formRequest", "sendrequest", "sendPost", "submitrequest", "submitResponse", " sendResponse", "formrequest", "sendResponse", " sendrequest", "formPost", "submitPost", " sendPost"], "getVars": ["gettingVals", "getPals", "execVys", "execVariarts", "getVCart", "getvars", "fileHars", "gotVariARS", "fileHARS", "getPARS", "getVrs", "getVsrs", "evalVCars", "getvar", "gotVariars", "getVCarp", "evalVarp", "fileHar", "evalVColder", "gotVarials", "getVers", "gettingVsARS", "gettingVrs", "getvrs", "evalVart", "getVsars", "evalVCart", "getVariarts", "getVals", "fileVar", "getVaarp", "evalVars", "getVarp", "getChrs", "getPers", "getChARS", "getAttarp", "gotVars", "getAttars", "getvals", "getVsals", "gettingVsars", "getHarts", "getVCars", "fileVARS", "getVaars", "getVart", "fileVrs", "getHar", "getVolder", "getHrs", "execVariys", "execVariars", "gettingVsals", "getAttolder", "getHARS", "getVys", "getVsers", "execVarts", "evalVolder", "getVariARS", "gotVARS", "getVsARS", "getVarts", "getChars", "getChar", "execVariARS", "getVariys", "getVar", "gettingVARS", "fileHrs", "execVARS", "gettingVars", "getVARS", "getAttart", "getVColder", "getVariars", "getvARS", "gettingVsrs", "getVaart", "gotVals", "execVars", "gotVariers", "getHars", "getVaolder", "getVarials", "getPars", "evalVCarp", "gotVers", "getHys", "getVariers"], "postVars": ["postJrs", "postInvals", "postVaars", "postVables", "postvys", "postVariants", "postEvARS", "postVats", "postVaaults", "getVaults", "putVars", "postNavars", "putVsARS", "postVys", " postVys", "postVariors", " postVrs", "postVsants", "postEvats", "postVsaults", "postVariars", "postVsols", "postVors", "getVsars", "getVsaults", "postVrs", "postNavaults", "getVals", "postvrs", "postvars", "putVals", "postVsors", "putVsals", "putVsats", "postVsARS", "postVsables", "getVols", " postvars", "putInvals", "postCals", "postCARS", "putVsars", "getVsals", "postCars", "postVals", "putVats", "putVARS", "postVaols", "postInvars", "putInvars", " postVables", "postInvants", "postEvals", "postVarials", " postvys", "postEvars", "postVaals", "postVsals", "postVsats", " postvables", "postVaults", "postvables", "postNavals", "postJables", "putInvors", "putVors", "putVants", "postJars", "postJys", "postVants", "postVsrs", " postvrs", "postVols", "getVsols", "postInvors", "postVsars", "postCats", "postVARS", "postNavols", "putInvants", "postVsys"], "fileVars": [" filePARS", "fileAVaults", " fileVsals", "fileVSars", "filevar", "fileInvars", "postVar", "fileVals", "fileMals", "filePars", "fileVaults", "fileDevar", "filevParts", "fileBars", "fileBaults", "postVarts", "fileVsolder", "postVariavers", "fileVolVar", "ruleVals", "fileMarp", "postVariars", "fileVavers", "fileInvar", "ruleVolars", "fileVolals", "fileVarp", "ruleVolals", " fileVARS", "filePolder", " fileVels", "fileVolder", "fileVsar", "postVrs", "fileVar", "filevars", "ruleVVar", "fileDevars", "fileInvrs", "filevrs", "fileJals", " fileVaults", "fileVSARS", " fileVar", "fileVsarp", "fileVariARS", "fileVsels", "postVals", "ruleVarp", "ruleVolVar", "fileVARS", "fileAVars", " fileVoters", "filevPars", "fileVels", "fileVariarts", "fileDevarp", "fileAVARS", "postVavers", "fileVrs", "fileBARS", " fileVsarp", "fileVolarp", "fileVolars", "postVariARS", "fileVSels", "fileInvals", "fileParp", " fileVsars", "fileVsARS", "ruleVars", "postVariarts", "fileMar", "filevals", "fileVsavers", " fileVals", "fileJARS", "fileVsarts", "fileMars", "postVsals", "filevPARS", "fileAVoters", "filePVar", "fileDevals", "fileVariarp", "fileVariVar", "filePals", "fileVSals", " filePolder", "fileBoters", "fileVsals", "fileJars", " fileVarp", "filevPavers", "fileVoters", "fileVariars", "fileVsrs", " fileVolder", "fileVVar", " fileVsar", "postVsrs", "fileVarts", "fileVsars", "postVsar", " filePals", "fileJolder", "fileVarials", "postVsars", "filePARS", " filePars", "postVARS", "fileVariavers", "ruleVolarp"], "getSessionKey": ["gettingSessionkey", "getESSIONkey", " getsessionId", "getsessionKeys", " getSessionkey", "gettingESSIONKey", "getsessionId", "getSessionName", "getsessionName", "gettingSessionKey", " getsessionkey", "gettingSessionName", "gettingESSIONkey", "gettingESSIONName", "getsessionkey", "gettingESSIONId", " getsessionKey", "getsessionKey", "getESSIONKey", "getSessionkey", "getESSIONName", " getSessionId", " getsessionKeys", "gettingSessionId", "getSessionKeys", " getSessionKeys", "getSessionId", "getESSIONId"], "uri": ["browser", "http", "wiki", "ui", "link", "html", "gi", "address", "href", "iri", "filename", "uni", "target", "phi", "ugi", "us", "folder", "location", "directory", "term", "base", "prefix", "description", "subject", "api", "pi", "connection", "unit", "ur", "domain", "title", "du", "dir", "origin", "URI", "ri", "resource", "nu", "file", "doi", "range", "home", "direction", "query", "path", "general", "hi", "qi", "source"], "i": ["m", "ip", "list", "it", "ei", "q", "loop", "lo", "c", "y", "ini", "is", "io", "bi", "pi", "ree", "me", "init", "go", "t", "mi", "ix", "exp", "hi", "o", "v", "menu", "h", "index", "im", "oi", "ki", "ii", "u", "j", "ta", "id", "set", "ic", "I", "x", "xi", "p", "batch", "ui", "ci", "l", "err", "ind", "\u0438", "iu", "f", "um", "info", "ai", "sim", "di", "iy", "on", "si", "zi", "ij", "multi", "gi", "ami", "chain", "us", "phi", "status", "li", "e", "cli", "ma", "ri", "g", "ims", "slice", "ti", "ji", "qi"], "url": ["browser", "http", "b", "att", "link", "l", "ld", "ll", "arl", "el", "hl", "atl", "loc", "open", "char", "www", "str", "ul", "il", "abs", "ssl", "dl", "api", "org", "un", "ur", "nl", "bel", "https", "URL", "au", "gl", "t", "log", "Url", "job", "sl", "r", "sb", "net", "ls"], "conn": ["http", "link", "js", "socket", "ws", "err", "cp", "pkg", "pg", "ann", "resp", "canon", "wp", "obj", "ctx", "call", "res", "Conn", "req", "exec", "reg", "loc", "jp", "open", "secure", "cert", "cmd", "ct", "client", "comm", "fin", "enc", "org", "connection", "act", "nc", "ch", "ssl", "auth", "sys", "init", "cb", "sp", "con", "txt", "cs", "pas", "cur", "forge", "https", "connect", "j", "tn", "close", "en", "cfg", "typ", "conf", "addr", "ait", "dt", "fail", "ns", "cn", "conv", "ls", "p", "nt"], "cookie": ["browser", "jar", "ca", "cache", "menu", "code", "cel", "csv", "magic", "header", "chain", "label", "no", "window", "term", "coin", "timeout", "token", "cy", "c", "cert", "cmd", "ookie", "wine", "client", "password", "cell", "json", "bo", "stay", "KEY", "co", "note", "cue", "sample", "country", "comment", "none", "cb", "copy", "ce", "word", "cook", "kee", "value", "gc", "reason", "qq", "query", "ck", "binary", "good", "cm", "hello", "tmp", "temp", "pretty", "custom", "cn", "cu", "tc", "ie"], "key": ["wk", "code", "val", "ex", "Key", "keys", "k", "chain", "hop", "pe", "property", "label", "child", "mac", "cy", "y", "choice", "table", "prefix", "type", "cert", "col", "char", "by", "any", "str", "row", "cell", "KEY", "pair", "j", "phrase", "me", "box", "ow", "ce", "ke", "file", "value", "te", "ice", "id", "set", "member", "tag", "my", "x", "et", "ie", "ox", "item"], "ps": ["ks", "ops", "pd", "dial", "ins", "ress", "gets", "hs", "ys", "pas", "pres", "ips", "checks", "pp", "ups", "_", "amps", "bs", "ds", "css", "pl", "pos", "pt", "ws", "cp", "fp", "eps", "ts", "Ps", "ports", "gs", "p", "js", "PS", "als", "rep", "plays", "vs", "ms", "sp", "cs", "mp", "sts", "ats", "fs", "po", "out", "ns", "ls", "ros", "pr", "proc", "posts", "rs", "fps", "ss", "its", "pers", "aps", "stats", "pps", "pse"], "name": ["n", "val", "Name", "NAME", "address", "extra", "filename", "label", "field", "description", "type", "form", "class", "title", "dir", "alt", "position", "add", "names", "format", "value", "range", "part", " filename", "id", "component", "ident"]}}
{"id1": "19147279", "id2": "10936821", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "label": 0, "substitutes": {"actualizarDatosFinal": [" actualizarDataosFinancial", " actualizarDatoFinal", " actualizarDataasBasic", " actualizarDatosBasic", " actualizarDataosFinal", " actualizarDataosfinal", " actualizarDatoBasic", " actualizarDatosfinal", " actualizarDatrosfinal", " actualizarDataasFinal", " actualizarDataasFinancial", " actualizarDatasBasic", " actualizarDatasfinal", " actualizarDatrosFinal", " actualizarDatasFinal", " actualizarDatrosFinancial", " actualizarDatofinal", " actualizarDatoFinancial", " actualizarDatosFinancial", " actualizarDataasfinal", " actualizarDatrosBasic", " actualizarDatasFinancial", " actualizarDataosBasic"], "idJugadorDiv": ["idJugadorDef", "idJugordDef", "idJuggadorDef", "idJugadierDiv", "idJuggadoDev", "idJogadeDec", "idJugadeDef", "idJogadeDiv", "idJuggadoDiv", "idJugadierDef", "idJugadeDiv", "idJugordDiv", "idJogadorDiv", "idJugordApp", "idJuggadoDef", "idJogadorDev", "idJugadorDev", "idJugadoDec", "idJugadoDef", "idJugordDec", "idJugadorApp", "idJogadorDef", "idJugadierApp", "idJuggadorDiv", "idJugordDev", "idJugadeDev", "idJugadeDec", "idJugadoDiv", "idJugadierDev", "idJuggadorDev", "idJuggadoApp", "idJuggadorApp", "idJogadeDev", "idJogadorDec", "idJugadoApp", "idJogadeDef", "idJugadorDec", "idJugadoDev"], "idRonda": ["idCoda", "IdRonda", "idRosa", "idCorata", "idRunnerondo", "idCorora", "idRondo", "idRunnerora", "idConda", "idRona", "IDDona", "idTona", "idRora", "IDRosa", "idRoda", "IDDoda", "idRunneronda", "idDosa", "idCorondo", "IdRondo", "idCoronda", "idTonda", "IDRoda", "IDDosa", "idTosa", "IDDonda", "idRunnerata", "idRata", "IDRona", "idCona", "idDonda", "IdRata", "idCosa", "idDona", "idToda", "IdRora", "IDRonda", "idDoda"], "unjxdxr": ["unjxdexe", "unjdxxhr", "unjxdXer", "unjxdxde", "unjxdxhr", "unjxdXR", "unjdxxtr", "unjdxxtrs", "unjdxxe", "unjxdtxer", "unjdxtxer", "unjxdXhr", "unjdxtxhr", "unjdxxer", "unjxdXr", "unjxdtxhr", "unjxdxtR", "unjdxxr", "unjxddxer", "unjdxxrs", "unjxdxdr", "unjxdexrs", "unjxdxR", "unjxdxdrs", "unjxddxr", "unjxdxtrs", "unjdxxte", "unjxdxe", "unjdxtxR", "unjxdxtr", "unjdxtxr", "unjxdtxR", "unjxdxer", "unjxdexR", "unjdxxtR", "unjxddxhr", "unjxdxdR", "unjdxxR", "unjxdexr", "unjxdxrs", "unjxdtxr", "unjxddxR", "unjxdxte"], "intResult": [" intResults", "IntResult", "interResults", "INTReturn", " intRes", "INTResult", "strReturn", "interReturn", "intResults", "intSuccess", "IntSuccess", "intRes", "INTResults", "IntRes", "strResults", " intresult", " intSuccess", "interRes", "strResult", "intReturn", " intReturn", "strresult", "IntReturn", "IntResults", "INTSuccess", "interResult", "INTRes", "intresult", "INTresult"], "sql": ["pr", "command", "csv", "condition", "settings", "cp", "xml", "qs", "pel", "q", "spr", "statement", "string", "what", "expression", "ql", "status", "seed", "template", "description", "fn", "cmd", "dl", "sv", "script", "sp", "serv", "setup", "sq", "url", "s", "log", "query", "SQL", "params", "sol", "scl", "sb", "db", "ls", "select"], "connection": ["link", "conn", "command", "condition", "socket", "pointer", "network", "session", "server", "function", "computer", " Connection", "city", "statement", "connected", "database", "directory", "response", "Connection", "c", "table", "document", "open", "description", "collection", "writer", "platform", "external", "client", "engine", "number", "associated", "bo", "subject", "context", "nc", "application", "con", "position", "port", "connect", "ion", "resource", "library", "created", "creator", "close", "relation", "db", "reference", "pool", "channel", "communication", "character", "current"], "ps": ["ping", "pr", "conn", "pos", "pt", "socket", "pg", "cp", "pd", "proc", "res", "statement", "PS", "p", "processor", "posts", "process", "pm", "rs", "jp", "fps", "fp", "eps", "tp", "sp", "script", "cs", "ptr", "proxy", "pers", "mp", "s", "aps", "gres", "pp", "Ps", "prep", "pps", "po", "ports", "pse", "ds", "pa"]}}
{"id1": "5436973", "id2": "22411381", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"httpToStringStupid": ["httpToStrStuid", "httpToStrStuff", "httpToStringUuid", "httpToStrUuid", "httpToStrStupid", "httpToStringRestuid", "httpToStringRestupid", "httpToStringRestuff", "httpToStringUuff", "httpToStringUamp", "httpToStringSnuff", "httpToStringSnamp", "httpToStrUamp", "httpToStringUupid", "httpToStrUupid", "httpToStringStuff", "httpToStringSnuid", "httpToStrUuff", "httpToStrStamp", "httpToStringStuid", "httpToStringSnupid", "httpToStringRestamp", "httpToStringStamp"], "url": ["http", "b", "pl", "link", "web", "l", "ll", "address", "key", "server", "string", "location", "p", "base", "name", "loc", "password", "char", "str", "ul", "ssl", "dl", "u", "ref", "ret", "ur", "https", "URL", "file", "pattern", "result", "Url", "id", "host", "path", "page", "out", "i", "ls", "uri"], "IOException": ["TimeoutError", "TimeoutException", "ioException", "ioError", " IOError", "IOError"], "HttpException": ["RuntimeException", "HttpError", "HTTPError", "httpException", "HTTPException", "httpError", "RuntimeError"], "InterruptedException": [" InterruptException", "InterruptionEx", "InterruptionError", "InterinterruptedEx", "InterruptEx", "InterruptedEx", "InterinterruptedException", "InterruptError", "InterruptedError", " InterruptedError", " InterruptError", "InterinterruptedError", " InterruptedEx", "InterruptionException", " InterruptEx", "InterruptException"], "URISyntaxException": ["URISyntlexEx", "URISyntlexWarning", "URISeticaxEx", "URISeticntaxWarning", "URISyntixEx", "URISeticntaxEx", "URISyntntaxWarning", "URISyntaxEx", "URISyntixWarning", "URISyntntaxException", "URISeticntaxException", "URISyntaxWarning", "URISeticaxWarning", "URISyntlexException", "URISyntixException", "URISyntntaxEx", "URISeticaxException"], "pageDump": ["pageStump", "pageSump", "pageStdump", "pageDoumper", " pageDumper", "pageDumps", "pageSumper", "pagePash", "pagedump", "pageDoump", " pageDamp", "pageDumper", "pagedumps", "pagePdump", "pageStash", "pagePump", "pageStamp", "PageDumps", "pageDodump", "pageSumps", "pageDoumps", "PageDumper", "PageDdump", "pageDdump", "pagePamp", "PageDump", "pageddump", "pageSdump", "pagedumper", " pageDumps", "pageDamp", " pageDash", "pageDash", " pageDdump"], "httpget": [" httpGET", " httpfind", "ttppost", "httpcall", " httppost", "ttpcall", "ttpget", "httpGET", "HTTPget", "hoverGet", "httpfind", " httpGet", "ttpGet", "HTTPGet", "httpcreate", "HTTPfind", "Httppost", "Httpget", " httpcreate", "hoverGET", "ttpfind", "Httpfind", "httppost", "HTTPGET", "hovercreate", "ttpcreate", "hoverget", "HTTPcreate", "httpGet", "Httpcall", " httpcall"], "response": ["entry", "report", "pos", "command", "resp", "body", "respond", "res", "onse", "status", "that", "yes", "answer", "document", "sequence", "still", "description", "attribute", "open", "json", "connection", "application", "reply", "request", "block", "next", "service", "profile", "result", "Response", "successful", "content", "object", "event", "output", "message", "given", "page", "remote", "frame"], "entity": ["entry", "security", "detail", "address", "body", "obj", "pe", "el", "inv", "environment", "Entity", "activity", "image", "ee", "group", "ITY", "document", "person", "email", "json", "ity", "icon", "unit", "e", "me", "comment", "ce", "metadata", "resource", "existent", "result", "ent", "model", "encrypted", "voice", "content", "object", "event", "output", "page", "ie", "line"]}}
{"id1": "17791385", "id2": "22977189", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyResource", "copyfile", " cpfile", " cpFiles", " copyFiles", "copyFiles", "copyResource", "cloneResource", " cpFile", " cpResource", "cloneFile", "clonefile", "cloneFiles", " copyfile"], "src": ["usc", "ctr", "rl", "sec", "rel", "ins", "input", "via", "ser", "obs", "req", "rs", "rx", "iv", "ipl", "cont", "sys", "usr", "sel", "rc", "init", "st", "ys", "Source", "sf", "cur", "inst", "ux", "from", "start", "sit", "sc", "ck", "sb", "sin", "bs", "sur", "sr", "txt", "sq", "source"], "dst": ["wdest", "wst", "Ddest", "ddst", "ddnt", "snd", " dth", "dnt", "dnd", "dddest", "ddnd", "wnd", "Dth", "Dnt", " ddest", "sdest", "ddest", "snt", "Dst", "dth", "wth", "sst", "Dnd", " dnd"], "in": ["inf", "oin", "IN", "inc", "it", "al", "inner", "cin", "ins", "input", "mm", "ind", "rec", "rin", "im", "bin", "min", "inside", "In", "is", "up", "ar", "ze", "act", "isin", "init", "st", "con", "info", "iter", "ln", "ai", "from", "gin", "en", "ain", "inn", "on", "sin", "ic", "i", "din", "source"], "out": ["o", "n", "to", "dis", "it", "ex", "oss", "inner", "sum", "obj", "res", "OUT", "at", "bin", "os", "up", "ou", "Out", "io", "oe", "writer", "aos", "client", "by", "outer", "sys", "conv", "co", "write", "ot", "st", "con", "and", "t", "auto", "gt", "can", "g", "output", "outs", "on", "po", "net", "cn", "ne", "nt"], "buf": ["b", "pl", "batch", "aka", "gen", "bh", "Buffer", "prop", "tab", "cat", "pkg", "cp", "mu", "seq", "msg", "stab", "arr", "uf", "bar", "cmd", "cf", "bag", "bed", "var", "conv", "br", "buff", "cap", "box", "cb", "bytes", "vec", "block", "cur", "fb", "cv", "cam", "log", "norm", "tx", "good", "db", "Buff", "ck", "buffer", "bus"], "len": ["n", "v", "pos", "val", "l", "ld", "ll", "num", "elt", "h", "L", "rel", "el", "no", "lic", "seq", "loc", "wid", "lon", "end", "fin", "str", "il", "dl", "count", "vol", "compl", "lim", "e", "cap", "cmp", "lan", "ln", "size", "fun", "coll", "t", "le", "exp", "lf", "Len", "fl", "en", "all", "ren", "lib", "nt", "length", "ls", "z"]}}
{"id1": "21979717", "id2": "8665321", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"upload": ["submit", " file", " login", " reload", "execute", " restore", " confirm", " commit", " sort", " store", " load", "ction", "save", " press", " install", " delete", " change", " go", " move", " dispose", " take", " input", " work", " dump", " insert", " paste", " update"], "fileResult": ["FileResult", "reportResults", "FileStatus", "FileRequest", " fileResults", " fileReturn", "fileResults", "reportRequest", "FILEReturn", "FileReturn", " fileStatus", "reportResult", "FILEResult", "fileStatus", "FILEResults", "fileRequest", "fileReturn", " fileRequest", "FileResults", "FILEStatus", "reportStatus"], "in": ["inf", "n", "conn", "IN", "l", "inc", "it", " IN", "inner", "cin", "body", "ins", "doc", "input", "p", "ind", "rin", "bin", "up", "In", "inside", "io", "is", "un", "isin", "init", "st", "win", "file", "gin", "from", "en", "get", "inn", "r", "on", "lock", "i", "din", " din"], "url": ["browser", "http", "pl", "conn", "web", "l", "ll", "arl", "xml", "atl", "name", "open", "char", "client", "www", "f", "str", "ul", "abs", "ssl", "dl", "ref", "ur", "nl", "bel", "https", "URL", "gl", "file", "gc", "log", "Url", "sl", "console", "get", "r", "net", "channel", "conv", "ls"], "con": ["syn", "http", "conn", "pos", "gate", "cat", "cp", "create", "dial", "canon", "cos", "call", "Conn", "re", "coin", "cond", "c", "cons", "open", "cert", "cf", "cmd", "col", "client", "comm", "ver", "un", "cont", "func", "fc", "connection", "act", "co", "pc", "fac", "ln", "cur", "com", "connect", "don", "CON", "ran", "soc", "ion", "bean", "ctrl", "const", "can", "cl", "en", "ain", "sub", "cm", "conf", "cal", "pen", "cn", "conv", "Con"], "out": ["o", "b", "n", "to", "conn", "null", "pos", "oss", "ex", "sum", "cos", "obj", "OUT", "at", "os", "Out", "io", "ou", "aos", "client", "outer", "un", "sys", "conv", "vol", "co", "ion", "w", "t", "auto", "can", "en", "conf", "OU", "output", "po", "outs", "this", "net", "i", "or", "ne"], "in2": ["inner1", "win1", "inner2", "inner3", "IN1", "out02", "IN02", "out2", "in02", "inner02", "din2", " in3", "IN2", " in1", "win2", "out4", "out3", "in1", "out1", "win3", "din1", "in4", "din4", "in3", "IN3", " in4"], "buf": ["pb", "batch", "aka", "Buffer", "tab", "cat", "pkg", "cp", "data", "buffer", "seq", "arr", "uf", "rb", "cmd", "bar", "cf", "bag", "emb", "str", "var", "img", "queue", "mem", "fg", "br", "buff", "cap", "cb", "box", "bytes", "vec", "cam", "block", "cur", "cv", "log", "cfg", "db", "tmp", "Buff", "conv", "orig"], "bytesRead": ["secondsNeed", "BytesWrite", "bytesNeed", "rowsRun", "bytesread", " bytesLoad", " bytesWritten", " bytesread", "tesCount", "cellsRun", "rowsNeed", "rowsWrite", "cellsRead", " bytesNeed", "bytesRun", "tesWrite", "cellsWrite", "rowsRead", " bytesWrite", "tesRead", "BytesWritten", " bytesRun", "secondsWrite", "rowsread", "cellsLoad", "secondsRead", "bytesCount", "BytesCount", "tesWritten", "secondsread", " bytesCount", "bytesWrite", "bytesLoad", "rowsLoad", "BytesRead", "bytesWritten"]}}
{"id1": "11341711", "id2": "23291583", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"makeBackup": ["makebackups", "createBackupid", "createBackups", "makeStpoint", "makeDupid", "makeBackups", "createbackup", "makeStup", "makeDpoint", "createBackpoint", "makebackupid", "makeDups", "createBackup", "createbackupid", "makebackpoint", "makeBackupid", "makeStupid", "makebackup", "makeDup", "createbackups", "makeBackpoint", "makeStups", "createbackpoint"], "dir": ["d", "dis", "disk", "md", "in", "pkg", "dat", "data", "direct", "doc", "store", "dist", "folder", "DIR", "directory", "window", "dr", "ind", "rad", "ir", "base", "y", "loc", "dd", "or", "mail", "wd", "dl", "vol", "src", "draw", "iter", " d", "url", "file", "local", "dep", "handle", "fd", "del", "Directory", "dm", "zip", "db", "tmp", "addr", "path", "out", "Dir"], "sourcedir": ["sourceirs", "sourcesdir", "senderr", "soredire", "sourcedirs", "sourcesirs", "senderdir", "sourceel", "sourcedire", "isourceddir", " sourcesdir", " sourcedirs", " sourceddir", "senderel", "isourcedr", " sourcesir", "sourcer", "isourceel", " sourcesirs", "soredirs", "sourcesel", "sourcesir", " sourcesire", "sourcedr", "senderir", "soreddir", "isourcer", "sourceddir", " sourcedire", "isourceir", "soredir", "isourcedel", "sourceir", "sourceire", "sourcesr", "sourcesire", "sourcedel", "isourcedir"], "destinationdir": ["destionDir", "destinatorir", "estinationdb", "destinationir", "destensiondb", "destineddb", "destineddir", "destineddiv", "destinatordb", "destinedir", "destionfolder", "stinationsdiv", "destinationsir", "destensiondir", "destensionDir", "destinationdb", "destinatordiv", "stinationsir", "stinationsdir", "stinationsdb", "destiondb", "destinatorfolder", "stinationdir", "destiondir", "destinationDir", "destinationsdiv", "estinatorDir", "stinationir", "estinationfolder", "estinatorfolder", "destinationsdb", "estinatordir", "estinationdir", "destinatordir", "stinationdb", "estinationDir", "destinationfolder", "destinatorDir", "estinatordb", "stinationdiv", "destensionfolder", "destinationsdir", "destinationdiv"], "destinationDirEnding": ["destinationDirectoryEnding", "destinationFileEnder", "destinationDirENDiting", "destinationDirServging", "destinationDirFeeder", "destinationDirectoryENDing", "destinationDirENDging", "destinationDirEvenING", "destinationFileEndING", "destinationDirEndging", "destinationDirENDer", "destinationDirENDding", "destinationDirFeeding", "destinationFileEnditing", "destinationDirEveniting", "destinationDirServding", "destinationFileEvener", "destinationFileEnding", "destinationDirENDing", "destinationDirServer", "destinationDirEndING", "destinationDirectoryENDding", "destinationFileEveniting", "destinationDirEvending", "destinationDirENDING", "destinationDirFeedING", "destinationFileEvenING", "destinationDirectoryEndging", "destinationDirEnder", "destinationDirectoryENDging", "destinationDirEvener", "destinationFileEvening", "destinationDirServing", "destinationDirEvenging", "destinationDirFeediting", "destinationDirectoryEndding", "destinationDirectoryENDer", "destinationDirEnditing", "destinationDirEndding", "destinationDirectoryEnder", "destinationDirEvening"], "files": ["reports", "errors", "strings", "types", "images", "list", "forms", "words", "objects", "classes", "members", "qs", "keys", "parts", "users", "tools", "uploads", "plates", "filename", "obs", "features", "lines", "iles", "links", "ids", "parents", "assets", "details", "facts", "tests", "lets", "its", "issues", "actions", "fixes", "Files", "ames", "resources", "bytes", "headers", "names", "events", "file", "mails", "items", "modules", "fs", "fields", "params", "faces", "docs", "states", "sections", "projects", "values", "ports", "bs", "pages", "ls", "prints"], "checkdir": ["checkeddirectory", "checkedDir", "getblock", "checkeddir", "Checkfolder", "checkedir", "Checkdirectory", "Checkdb", "ckurl", "ckDir", "CheckDir", " checkir", "keydir", "workthis", "getdb", "keyroom", "Checkroom", "ckroom", "checkthis", " checkthis", "workDir", " checkdb", " checkfolder", "checkfolder", "ckdirectory", "checkurl", "workurl", " checkurl", "ckfolder", "keyfolder", "checkeddb", "ckthis", " checkdirectory", " checkDir", "checkdb", "workdir", "Checkdir", "getfolder", "checkedfolder", "checkblock", "checkdirectory", "checkroom", "checkir", "ckdir", "Checkblock", "checkDir", "ckdb", " checkblock", "keydb", "Checkir", "getdir"], "date": ["d", "time", "use", "dat", "data", "key", "user", "doc", " Date", "msg", "year", "ate", "month", "when", "iso", "Date", "note", "late", "none", "zone", "now", "today", " day", "add", "resource", "ATE", "te", "file", "diff", "start", "close", "set", "day", "get", "cal", "event", "dt", "de", "tag"], "msec": ["cmisec", "mtsec", "gmstr", "mct", "cmcl", "gmsc", "mSec", "Mct", "Msec", "mtct", "mstr", " msc", " misec", "mtisec", "cmsc", "gmsec", "msc", "gmSec", " mcl", "mtSec", "mcl", "cmsec", " mct", " mstr", "MSec", "mtsc", "misec", "mtcl", " mSec", "mtstr"], "checkFile": ["CheckFile", "updateFiles", "checkFiles", "updateSourceFile", "readFILE", "checkFILE", "checkfile", " checkFILE", "CheckFiles", "readfile", " checkFiles", "checkSourceFile", "Checkfile", " checkfile", "updateFILE", "readSourceFile", "readFile", "updateFile", "CheckFILE", "readFiles", " checkSourceFile"], "i": ["m", "multi", "ip", "ij", "ci", "ui", "batch", "in", "it", "ji", "ex", "ei", "gi", "key", "phi", "major", "index", "ind", "base", "im", "name", "y", "ki", "si", "ini", "li", "sequence", "is", "ii", "gu", "iq", "iu", "io", "ie", "bi", "pi", "j", "x", "me", "init", "info", "cli", "ri", "ai", "sim", "mi", "ti", "hi", "ix", "exp", "id", "di", "my", "ic", "I", "xi", "qi", "zi"], "f": ["d", "b", "fa", "v", "o", "m", "l", "fe", "fw", "tf", "F", "fo", "uf", "fi", "ft", "cf", "df", "fp", "fc", "u", "j", "fg", "bf", "e", "fac", "fb", "file", "t", "fd", "fs", "lf", "fl", "fr", "p"], "g": ["d", "m", "b", "v", "mg", "l", "graph", "pg", "gi", "gd", "tg", "gy", "msg", "gp", "group", "gu", "vg", "gm", "j", "ge", "fg", "bg", "e", "og", "go", "w", "ga", "gl", "file", "s", "gc", "t", "gg", "config", "gb", "eg", "ig", "cfg", "G", "out", "gs", "p"], "destinationFile": ["DestationFile", "destinatorDirectory", "destationFilename", "destinationsFilename", "transinatedDirectory", "destinatedFiles", "DestationFilename", "destarationFile", "transinatedFiles", "transinatedFile", "transinationFilename", "destinationsFiles", "destinatorFiles", "DestinationFiles", "transinationFile", "destinatedFile", "destarationFiles", "destinationsFile", "DestinationEmail", "destinationFiles", "destationFiles", "transinationDirectory", "destinateFiles", "transinatedFilename", "destinationsEmail", "destinatorFilename", "destinationEmail", "destinateFilename", "destarationDirectory", "destinatorFile", "DestinationFilename", "transinationFiles", "destinatedDirectory", "destinateEmail", "destationEmail", "DestinationFile", "destinateFile", "destinationFilename", "DestationFiles", "destinationDirectory", "destarationFilename", "DestationEmail", "destationFile", "destinatedFilename"], "sourceFile": ["srcfile", "Sourcefile", "sourceFiles", "srcFile", " sourcefile", "sourceFILE", "ourceFilename", "ourceFile", "staticFILE", "ourceLine", "staticFiles", "sourceLine", "staticfile", "SourceFilename", "sourceFilename", "SourceFILE", "sourcefile", "srcLine", "SourceLine", "srcFilename", "ourcefile", " sourceFILE", "staticFile", " sourceFiles", "SourceFiles", "SourceFile"], "infile": ["instream", "inputline", "pinFile", " inline", "outblock", "insstream", "INfield", " instream", "inputFile", " inFile", "pinline", "INFile", "infield", "inline", "Infile", "InFile", "inputfile", "INfile", "pinfield", "Instream", "insFile", " inblock", "INline", "insfile", " infield", "inputblock", "pinfile", "inFile", "outFile", "inblock", "outline", "insblock", "Inblock"], "outfile": ["outbuffer", "instream", " outstream", "outerview", "inview", "outpage", "inlink", "Outfile", "OutFile", "Outstream", " outline", "outview", "Outlink", "inline", "outstream", "outputstream", "outputpage", "outputline", "outputfile", "outerbuffer", "outerfile", " outbuffer", "inpage", " outview", "inFile", " outlink", "outerstream", "outFile", " outpage", "outlink", " outFile", "outline", "inbuffer"], "c": ["d", "o", "m", "n", "v", "cache", "code", "ac", "ca", "err", "cd", "cp", "lc", "k", "cos", "chain", "\u00e7", "arc", "dc", "y", "cf", "col", "char", "ct", "uc", "count", "u", "rc", "ch", "cr", "nc", "e", "a", "cb", "pc", "unc", "cs", "mc", "ce", "t", "gc", "close", "cl", "bc", "sc", "C", "cm", "conf", "r", "ec", "cc", "out", "x", "cu", "z", "p"]}}
{"id1": "12128591", "id2": "6457199", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 0, "substitutes": {"hash": ["print", "code", " message", "h", " equals", " sum", " fingerprint", " check", "Hash", " mac", " text", " salt", " key", "hex", " Hash", " address", "dump", " code", "id", "update", " h", " version", " id", " body", " hashing", " signature"], "data": ["raw", "batch", "secret", "command", "html", "dat", "rel", "buffer", "input", "string", "what", "window", "padding", "image", "mu", "accept", "table", "sequence", "password", "any", "json", "DATA", "ata", "bytes", "info", "block", "value", "result", "content", "hello", "output", "this", "message", "a", "out", "action", "text"], "digest": ["mdested", "equest", "digests", "Digested", "displayests", " digist", "Digest", " digested", "initEST", "Digests", " digEST", "Digist", " digester", "mailly", "mailest", "digly", "redester", "mdgest", "equse", "displayse", "mdit", "mdest", "DigEST", "equit", "dese", "digested", "mdests", "mdave", "equave", "mailester", "diggest", "initester", "deest", "redly", "mdester", "redest", "displayest", " digse", "digit", "initested", "digave", "Digse", "digEST", "digester", "deested", "mailgest", "redgest", "deist", "displayested", " digave", " digit", "mdse", "digist", "digse", "initest", "mdly", "Digester"]}}
{"id1": "23677142", "id2": "19096138", "code1": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"BubbleSortShort2": ["BubbleSortShortTwo", "BubblesortShortTwo", "BubbleSortIntDouble", "BubblesortIntDouble", "BubblesortShort2", "BubbleSortIntTwo", "BubbleSortShortDouble", "BubblesortShortDouble", "BubbleSortshortDouble", "BubbleSortString4", "BubblesortShort4", "BubbleSortStringDouble", "BubbleSortshort2", "BubblesortInt4", "BubbleSortInt4", "BubbleSortShort4", "BubbleSortString2", "BubbleSortStringTwo", "BubblesortIntTwo", "BubbleSortInt2", "BubblesortInt2", "BubbleSortshortTwo", "BubbleSortshort4"], "num": ["m", "n", "dim", "cache", "zero", "mon", "val", "np", "dat", "alpha", "sum", "test", "missing", "nam", "na", "NUM", "mu", "msg", "im", "uf", "alph", "fn", "form", "comm", "nom", "number", "buf", "img", "tm", "bn", "snap", "rum", "um", "mem", "sam", "note", "save", "cmp", "con", "tim", "old", "hex", "dec", "mun", "check", "info", "mn", "add", "nu", "ums", "mat", "prim", "nm", "om", "coord", "update", "tu", "en", "pn", "get", "cal", "Num", "ver", "net", "txt", "eng", "nt"], "last_exchange": ["last_sexaction", "last_Exchange", "last_EXerence", "last_EXception", "last_Exception", "last_examine", "last_sexamine", "last_exactly", "last_nameamine", "last_xchange", "last_Exerence", "last_exaction", "last_elamine", "last_sexception", "last_pexactly", "last_exerence", "last_exechange", "last_elception", "last_exeception", "last_pexamine", "last_sexactly", "last_exvert", "last_elcessive", "last_xception", "last_elvert", "last_rxchange", "last_rxvert", "last_exevert", "last_xChange", "last_namechange", "last_ExChange", "last_execessive", "last_rxcessive", "last_xerence", "last_sexchange", "last_elaction", "last_EXamine", "last_EXaction", "last_pexception", "last_rxception", "last_nameactly", "last_elchange", "last_exception", "last_nameception", "last_exChange", "last_excessive", "last_EXchange", "last_EXChange", "last_pexchange"], "right_border": ["right_break", "rightflowgap", "rightflowborder", "right_index", "right_gap", " rightflowborder", " right_break", "right_order", "rightPostgap", " rightflowindex", "right_comment", " right_only", " right_order", "rightflowcomment", "rightPostborder", " right_index", "right_only", " right_comment", "rightPostcomment", "rightPostindex", " right_gap", "rightflowindex", " rightflowcomment", " rightflowgap"], "j": ["bj", "it", "ja", "key", "q", "user", "req", "c", "jp", "kj", "jump", "jit", "other", "je", "jl", "ix", "get", " n", "i", "o", "v", "n", "pos", "pt", "index", " J", "im", "jj", "u", "br", " ii", " dj", " Dj", "jen", "jc", "fr", "expr", "kid", " obj", "jack", "oj", "z", "p", "l", "js", "err", "server", "k", "journal", "ind", "f", "note", "og", "aj", "uj", "dj", "jet", "job", "__", "ij", "pr", "jo", "obj", "el", "adj", "jac", "json", "ret", "e", "er", "g", "J", "my", "ji"], "temp": ["kw", "Temp", "acc", "fake", "null", "comb", "dat", "test", "perm", "deg", "attr", "template", "base", "tem", "rem", "mod", " temporary", "porary", " Temp", "mem", "em", "alt", "tim", "fac", "cu", "ptr", "cum", "t", "mp", "dep", "pre", "result", "read", "tt", "unt", " tmp", "emp", "variable", "tmp", "buffer", "tc", "txt", "orig"]}}
{"id1": "8132219", "id2": "19549489", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", "copyfile", "copyFiles", "copyStream", " CopyFiles", " copyStream", "CopyStream", " CopyStream", "Copyfile", "CopyFile", " CopyFile", " Copyfile", " copyfile"], "inFile": ["dinFile", "ninName", " inEmail", "ninFilename", "inputFile", "innRow", "ninFile", "outFilename", "dinEmail", "dinPath", "outName", "inPath", " inRow", "innEmail", "innFile", "dinRow", "inputTemplate", "inputName", "inEmail", "inTemplate", "inputFilename", "inRow", "innPath", "inFilename", "outTemplate", "ninTemplate", "inName", " inPath"], "outFile": ["inTable", "ouFILE", "outFormat", "outfile", "ouFilename", "destFile", "ouFile", "outTable", "outputTable", " outFormat", " outFILE", "outputFilename", "outFilename", "destFormat", "inFILE", "ouTable", "outputFILE", "outputfile", "outputFormat", " outfile", "destFILE", "outFILE", "inFilename", "outputFile", "destfile"], "in": ["inf", "o", "IN", "inc", "it", "inner", "cin", "ins", "el", "input", "ind", "rin", "ir", "bin", "up", "In", "ini", "is", "ze", "isin", "init", "old", "info", "irm", "ai", "gin", "from", "s", " input", "id", "en", "ain", "inn", "sin", "on", "ic", "i", "din", " din", "source"], "out": ["o", "b", "n", "to", "v", "it", "ex", "res", "OUT", "at", "one", "c", "os", "name", "Out", "ou", "io", "aos", "client", "by", "co", "e", "ot", "w", "t", "file", "gt", "can", "all", "en", "g", "output", "outs", "net", "ne", "p"], "inChannel": ["cinBlock", "cinComponent", "inHandler", " inConnection", " inchannel", "inComponent", "newCategory", "insideHandler", "vinCategory", "inPanel", "inchannel", "cinHandler", "outBlock", "inBlock", "inCase", "sinChannel", "insideChannel", "inConnection", "innerChannel", "inStream", "inChan", "ginPanel", "isinCategory", " inHandler", "newChannel", "outChan", "inCategory", "ginCase", "vinPanel", "sinStream", "outConnection", "innCase", "outchannel", "inButton", "cinChannel", "sinBlock", "vinCase", " inChan", "sinCategory", "innerchannel", "inSlot", "newPanel", "newCase", "innSlot", "sinSlot", "outColumn", "insideComponent", "innerConnection", "sinCase", "cinColumn", "inColumn", "isinCase", "cinStream", "isinSlot", " inComponent", "innerChan", "vinChannel", "outStream", "sinColumn", " inButton", "ginChannel", "innChannel", "cinButton", "ginCategory", "isinChannel", "insideButton", "innCategory"], "outChannel": [" outCh", "oChan", " outPassword", "exBlock", "inchannel", "outPassword", "outBlock", "exChan", " outConnection", "outChain", "inStream", "inChan", "oChannel", "outCh", "outChan", " outClient", "outConnection", "exChannel", " outChain", "outchannel", "OutConnection", "nChannel", " outchannel", "outputChannel", " outBlock", "OutChan", "outputConnection", "inPassword", " outChan", "nStream", "outClient", "OutChannel", "OutCh", "inClient", "exChain", "outStream", "outputChan", "outputCh", "oClient", "oPassword", "nchannel", "nChan", " outStream"]}}
{"id1": "5607440", "id2": "10690321", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "label": 0, "substitutes": {"updateShoppingBean": ["updateShoppingBans", "updateShoppingSpaning", "updateShoppingMein", "updateShoppingSpans", "updateShowshipBean", "updateShoppingBaning", "updateShowshipBeans", "updateShoppingBeaning", "updateShoppingSpan", "updateShoppingBein", "updateShowshipSpans", "updateShoppingBan", "updateShoppingMeans", "updateShowshipBein", "updateShowshipSpan", "updateShowshipSpin", "updateShowshipSpaning", "updateShoppingMean", "updateShoppingMeaning", "updateShoppingBeans", "updateShoppingSpin", "updateShoppingBin", "updateShowshipBeaning"], "userId": ["USERReference", " userPath", "clientPath", "clientName", " userLog", "UserId", "USERId", "UserPath", "USERLog", "clientId", " userReference", "userName", "clientid", "Userid", "UserReference", "UserName", "userLog", " userid", "userPath", "USERName", " userName", "userReference", "UserLog", "userid"], "connection": ["entry", "link", "conn", "command", "condition", "socket", "pointer", "generation", "network", "settings", "operation", "usage", "session", "function", "computer", " Connection", "server", "city", "statement", "database", "directory", "information", "response", "Connection", "c", "table", "document", "open", "license", "collection", "writer", "client", "engine", "container", "bo", "subject", "sql", "context", "application", "con", "manager", "connect", "ion", "resource", "driver", "library", "config", "creator", "close", "query", "office", "relation", "management", "output", "reference", "communication", "character"], "preparedStatement1": ["preparedStat2", "preparedQuery4", "preparedRequest4", "preculatedStatementOne", "preparedStatn", "preparedMessageOne", "preparedStatementOne", "preprotectedStatement11", "preparedQuery2", "preculatedStatement8", "prearedQueryOne", "preparedMessage8", "preparedQuery10", "preparedCommentOne", "preparedstatementOne", "prearedStatement10", "preculatedComment8", "preparedComment4", "preparedStatement4", "preparedStatement12", "prequalifiedStatement6", "preparedQuery5", "preparedTemplate9", "preprotectedStatement9", "preparedTemplate12", "prearedQuery4", "preparedPolicyn", "preprotectedTemplate1", "preparedComment8", "preparedStat10", "preparedStatOne", "preprotectedStatement1", "prequalifiedStatementOne", "preparedRequestOne", "preparedComment2", "preparedQueryn", "preparedTransaction10", "preparedComment1", "prearedStatementOne", "preculatedComment1", "preparedTemplate1", "prearedStatement5", "prequalifiedStatement1", "preparedStatement8", "prearedQuery10", "preparedComment7", "prearedQueryn", "preparedStatement7", "preparedPolicy1", "preparedQuery8", "preparedQueryONE", "preculatedComment7", "preparedTransaction9", "preculatedCommentOne", "preparedComment5", "preparedstatement4", "preparedQueryOne", "preparedStatus1", "preparedTransactionOne", "preparedPolicy10", "preparedStatONE", "preparedMessage7", "preprotectedTemplate12", "prearedQuery5", "preparedPolicyOne", "preculatedStatement7", "preparedStatement11", "preparedTransaction2", "prequalifiedStat2", "preprotectedTemplate11", "preparedStatement9", "preparedStatementn", "prequalifiedStat1", "preprotectedTemplate9", "preparedstatement1", "prequalifiedStat6", "preparedStatus9", "preparedStatement6", "preparedStatus11", "preparedstatement5", "preparedMessage1", "preparedQuery1", "preparedTransaction1", "preparedStatement10", "preparedRequest1", "preparedStatementONE", "preparedStatus12", "preparedTransaction11", "preprotectedStatement12", "preculatedStatement1", "prearedStatement1", "preparedstatement2", "preparedTransaction12", "preparedQuery7", "prearedStatementn", "prequalifiedStatement2", "prearedQuery1", "prearedQuery2", "preparedStat6", "preparedStat1", "preparedStatement5", "preparedRequest2", "preparedTemplate11", "prearedStatement4", "prequalifiedStatOne", "prearedStatement2"], "preparedStatement2": ["preparedTransaction4", "preparedStatementTwo", "preededTransaction2", "preparedList2", "preededStatementTwo", "preparedList1", "preparedSessionSecond", "preparedTransaction2", "preparedTransactionSecond", "prearedStatement1", "preparedTransactionTwo", "preparedstatement2", "preededTransaction4", "preparedSession4", "preparedStatementSecond", "prearedStatementSecond", "preparedstatementTwo", "preparedListSecond", "preededStatement4", "preparedStatement4", "preededStatementSecond", "preparedstatement4", "preparedTransaction1", "preparedSession2", "prearedStatementTwo", "preededTransactionSecond", "preededTransactionTwo", "preparedSessionTwo", "preparedstatementSecond", "preededStatement2", "prearedStatement2", "preparedListTwo"], "preparedQuery": ["prelatedQu", "PrearedQuery", "preferredStatement", "postaredStatement", "premediatedQ", "preutedQu", "prearedSpec", "premediatedQu", "PrearedStatement", "preutedQuery", "prearedString", "premittedQuery", "prefixedSpec", "postparedStatement", "preutedString", "PreparedQ", "prearedQu", "prearedQ", "prefixedQu", "preferredQu", "premediatedQuery", "premittedQL", "premittedStatement", "preutedStatement", "postaredQL", "precedSpec", "prelatedQuery", "preparedSpec", "postaredQuery", "prearedQuery", "preparedQL", "preparedQ", "precedStatement", "prefixedStatement", "preparedStatement", "preparedString", "postparedQL", "prearedQL", "preparedQu", "PrearedString", "precedQu", "PrearedQu", "preferredQL", "PreparedStatement", "prearedStatement", "prelatedQ", "prefixedQuery", "PreparedQu", "PreparedString", "PrearedSpec", "precedQuery", "PreparedQuery", "preferredString", "premediatedStatement", "prelatedStatement", "PreparedSpec", "preferredQuery", "PrearedQ", "postparedQuery"], "date": ["age", "dated", "time", "duration", "dat", "data", "address", "user", "grade", "status", "state", "year", "ate", "document", "render", "number", "month", "when", "Date", "note", "late", "draw", "zone", "now", "today", " day", "value", "diff", "result", "start", "office", "query", "day", "get", "order", "event", "message", "dt", "tag"], "format": ["scale", "parse", "print", "Format", "sche", "use", "it", "html", "cat", "data", "function", "filter", "call", "string", "process", "at", "template", "transform", " Format", "layout", "prefix", "type", "license", "writer", "form", "handler", "fn", "f", "after", "style", "render", "fix", "export", "api", "act", "unit", "write", "late", "append", "atter", "mt", "add", "file", "value", "service", "printf", "pattern", "pre", "set", "sort", "spec", "get", "output", "dt", "tag", "pretty", "apply", "join"], "orderDate": [" orderYear", "orderedDay", "orderdate", "orderedYear", " orderdate", " orderDay", "orderedNow", "OrderDay", "gradeDate", " orderDeliveryDate", "orderYear", "gradeDay", " orderNow", "Orderdate", "orderDay", "orderedDate", "OrderDeliveryDate", "OrderNow", "gradedate", "orderDeliveryDate", "gradeDeliveryDate", "orderNow", "OrderDate", "OrderYear"], "iterator": ["cache", "walker", "list", "pointer", "network", "operator", "ippy", "inner", "data", "udder", "chain", "filename", "loop", "processor", "former", "ator", "instance", "database", "reader", "directory", "information", "video", "sequ", "upper", "starter", "older", "sequence", "wrapper", "collection", "writer", "trace", "later", "Iterator", "river", "consider", "outer", "ter", "runner", "sample", "liner", "pie", "finder", "info", "iter", "rounder", "vector", "counter", "internet", "stream", "next", "size", "integer", "versions", "chest", "loader", "dump", "creator", "set", "storage", "race", "ater", "era", "values", "history", "pee"], "shoppingInfo": ["shitchingInf", "choppingData", "sharingInf", "shillingInf", "sharingInformation", "shoutingDetails", "shoutingInf", "shippingInformation", "chootingData", "shootingInfo", "sharingData", "shillingDetails", "ShippingData", "ShippingInf", "shootingData", "shoppingData", "choppingInf", "shoppingInformation", "shoppingDetails", "shippingData", "chootingInfo", "shoutingData", "shippingInfo", "shppingInformation", "choppingINFO", "ShippingDetails", "ShoppingInfo", "shppingInf", "shitchingData", "ShoppingInformation", "choppingInfo", "shppingData", "shootingINFO", "chootingInf", "shillingInfo", "ShippingInformation", "ShoppingDetails", "shootingInf", "shoppingInf", "ShoppingInf", "shoutingInfo", "chootingINFO", "shppingInfo", "shillingData", "shoppingINFO", "sharingInfo", "shitchingInfo", "ShoppingData", "shippingInf", "ShippingInfo", "shippingINFO", "shppingINFO", "shippingDetails"], "product": ["brand", "print", "command", "project", "material", "operator", "node", "property", "processor", "pixel", "system", "process", "image", "template", "base", "Product", "name", "document", "attribute", "collection", "program", "client", "division", "media", "device", "top", "pi", "shop", "common", "application", "contact", "module", "products", "prototype", "position", "category", "resource", "service", "result", "production", "qualified", "cart", "id", "article", "relation", "object", "order", "per", "translation", "source"], "quantity": ["parify", "quality", "severitude", "percentity", "percenti", "severicity", "materialication", "severularity", "quantitude", "severication", "severency", "quanti", " quantularity", "percenticity", "Quantication", "materiality", "severity", "Quantity", "quanticity", "parularity", "percentitude", "quantularity", "quantify", " quanti", "materialency", "quantency", "Quantularity", "materialularity", "qualicity", "parity", "percentularity", "qualularity", "qualitude", " quantify", "pari", "Quantency", "percentify", "quantication"], "cartInfo": ["CartINFO", "commerceInfo", "armData", "artInformation", "chantData", "artInf", "CartInfo", "artInfo", " cartINFO", "cartNote", "armINFO", " cartNotice", " cartInformation", "commerceINFO", "chantINFO", "CartInformation", " cartNote", "CartInf", "cartNotice", "chipNote", "chantInfo", "cartCheck", "cotCheck", "artData", "cotData", "cartInformation", "CartData", " cartData", " cartInf", " cartCheck", "cartData", "armInf", "cotInfo", "commerceNotice", "cartInf", "armInfo", "commerceData", "cartINFO", "chantNotice", "chipInfo", "chipCheck", "cotNote", "chipData"], "i": ["m", "multi", "v", "ip", "ci", "ui", "ij", "o", "l", "it", "gi", "ami", "I", "h", "phi", "ori", "im", "y", "ini", "li", "ii", "iu", "fi", "xi", "io", "is", "bi", "pi", "u", "me", "init", "info", "cli", "ai", "ite", "t", "s", "mi", "ix", "ice", "di", "ims", "ic", "ti", "si", "hi", "p"], "productList": ["productLIST", "cartLibrary", "processOrder", "productOrder", " productOrder", "processList", "productlist", "productLibrary", "currentLibrary", "cartlist", "currentLIST", " productLIST", "cartList", "cartLIST", " productLibrary", "currentList", "cartOrder", "processlist", " productlist", "currentlist"], "components": [" Compresses", "condositories", "ompducers", "producers", "supponent", "Compositories", "proositories", "compositories", "proonents", "Compresses", "compducers", "supports", "computes", "commorts", "supputes", "ompositories", "condresses", "coponent", "compcomponent", "comports", "compresses", "coponents", "coports", "commonent", "omponents", "condducers", " compcomponent", " compositories", "Components", "condonents", " Compositories", "proresses", "commutes", "supponents", "Compcomponent", "ompresses", "coputes", " Components", " compresses", "commonents", " Compcomponent"], "j": ["ij", "m", "n", "v", "insert", "l", "js", "ja", "jo", "q", "k", "obj", "Connect", "jp", "kj", "item", "jj", "json", "sql", " ii", "aj", "connect", "select", "jl", "query", "jc", "Insert", "g", "J", "this", "Database", "SELECT", "oj", "ji", "z", "p"]}}
{"id1": "13122204", "id2": "17557289", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unarchiveImage", "UnarchiveModel", "unlateModel", "Unzipmodel", "unarchiveModel", "uncodeModule", "unlateImage", "uncodeImage", "UnzipImage", "unlatemodel", "unlateModule", "unarchiveModule", "UnzipModel", "unarchivemodel", "uncodemodel", "unzipImage", "uncodeModel", "Unarchivemodel", "UnarchiveImage", "unzipModule", "unzipmodel", "UnzipModule", "UnarchiveModule"], "filename": ["n", "FIL", "ename", "source", "til", "download", "location", "directory", "journal", "username", "name", "mson", "fn", "fil", "river", "Filename", "fp", "subject", "sql", "nl", "title", "jpg", "dra", "txt", "origin", "ln", "println", "file", "original", "nm", "nil", "wl", "kl", "fle", "FN", "ivo", "output", "path", "stem", "FILE", "SourceFile"], "tempdir": ["TempDir", "tempDIR", "temdirectory", "tmpDIR", "testfolder", "tempfile", "temDir", "tmpdir", " tempDir", "temDIR", "tempdirectory", "Tempdir", "temfolder", "tmppath", "Tempdirectory", " tempfile", "Tempfile", "tempath", "tmpfile", " tempdirectory", "tempfolder", "testdir", "tempDir", "temdir", "temppath", "testDir", " tempDIR", "tmpDir", "tmpdirectory", "tmpfolder", "testpath"], "dest": ["dev", "generated", "rest", "pos", "comb", "null", "tr", "ctr", "dat", "sum", "test", "target", "obj", "inv", "desc", "store", "dist", "bin", "des", "dc", "loc", "table", "document", "decl", "Dest", "writer", "nom", "cont", "trans", "send", "usr", "est", "src", "write", "st", "pipe", "origin", "ptr", "peer", "port", "stream", "slave", "master", "result", "del", "coord", "foreign", "tail", "deep", "default", "output", "tmp", "nt", "temp", "display", "out", "buffer", "parent", "source"], "fis": ["los", "lis", "fjs", "ifos", "flis", "ifatis", "li", "zatis", "fi", "fatis", "fli", "zjs", "ifis", "fljs", "ljs", "flos", "flatis", "ifi", "zos", "zi"], "BUFFER": ["BLOUNT", "MAXBuffer", "MAXOUNT", "BufferBuffer", "BLBER", "MAXBER", " BUFR", "CUBuffer", "BUFR", "LOCKBER", " BUOUNT", "CUFR", "BFFER", "MAXFFER", " BUULT", "BABER", "LOCKBuffer", "BLBuffer", "LOCKFFER", "BUOUNT", "BufferBER", "FFERBuffer", "BUBER", "BAOUNT", " BUBuffer", " BUBER", "BufferFFER", "BAULT", "BUBuffer", "FFERFFER", "BAFFER", "BOUNT", "BufferMT", "BBER", "CUFFER", "BUULT", "FFERBER", "BULT", "LOCKFR", "FFERMT", "BUMT", "BLFFER", " BUMT", "CUBER"], "zis": ["zris", "ozis", " zi", "ozi", "zees", "ziis", "fiss", "zoneits", " zris", " zes", "Zos", "xis", "zoneiss", "ziIS", "zeits", "zoneris", "fi", " zits", "oziss", " zip", "xiss", "xos", " zos", "zios", "zeIS", "ziss", "zoneis", "zIS", "zits", "zeiss", "Zis", "Zi", "zes", "Ziss", " ziss", "zeris", "zies", "fip", "zip", "zeis", "zos", " zIS", "ozip", "zeos", "xi", "zi"], "entry": ["jar", "link", "record", "source", "header", "key", "jo", "chain", "pe", "index", "system", "image", "name", "table", "card", "char", "cell", "row", "ze", "connection", "e", "comment", "element", "enter", "ce", "word", "je", "escape", "file", "existent", "se", "zo", "result", "log", "piece", "ent", "part", "member", "def", "match", "inter", "zip", "Entry", "way", "or", "ie", "ry", "item", "nt"], "count": ["n", "acc", "cache", "code", "batch", "ctr", "OUNT", "num", "amount", "sum", "found", "call", "index", "total", "child", "base", "cond", "c", "ct", "f", "core", "number", "cell", "cont", "common", "force", "comment", "Count", "size", "counter", "check", "ce", "add", "start", "max", "read", "cloud", "part", "ount", "current", "all", "match", "nb", "nt", "page", "cc", "length", "buffer", "z", "len"], "data": ["d", "n", "batch", "raw", "cache", "zero", "step", "dat", " DATA", "rel", "window", "image", "accept", "area", "table", "str", "DATA", "ATA", "dl", "valid", "ata", "sample", "bytes", "dec", "size", "results", "next", "format", "value", "mat", "result", "part", "all", "content", "output", "message", "out", "done", "buffer", "text", "p"], "fos": [" foes", "los", "foes", "fOS", "Foss", "Fios", " fios", "vos", "Foes", "voss", "fios", "Fos", " foss", "lOS", "loss", "foss", "FOS", "lios", "voses", "Foses", " fOS", " foses", "foses", "voes"]}}
{"id1": "620855", "id2": "13946197", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["DoVersionCheck", "doDatecheck", "doDateUpdate", "doLicenseUpdate", "doLicenseCheck", "doLicenseFix", "doLicensecheck", "doDateFix", "doVersionsUpdate", "doVersionsCheck", "DoVersionUpdate", "doVersionUpdate", "DoDateCheck", "doVersionscheck", "doVersionFix", "doVersioncheck", "DoVersionFix", "DoDateFix", "DoDatecheck", "DoVersioncheck", "DoDateUpdate", "doDateCheck", "doVersionsFix"], "view": ["browser", "http", "report", "v", "print", "web", "html", "show", "blade", "server", "q", "call", "doc", "input", "views", "window", "index", "controller", "hl", "image", "self", "eye", "document", "layout", "iew", "open", "table", "wrapper", "form", "client", "View", "engine", "row", "cell", "subject", "context", "review", "manager", "block", "check", "cv", "file", "help", "widget", "query", "model", "update", "console", "VIEW", "get", "see", "host", "tv", "component", "this", "display", "util", "out", "page", "buffer", "tree"], "url": ["browser", "http", "pl", "b", "v", "link", "null", "web", "l", "socket", "ll", "html", "rl", "address", "rel", "date", "string", "location", "hl", "lb", "oul", "loc", "language", "char", "client", "f", "str", "ul", "json", "ssl", "dl", "org", "ur", "nl", "bel", "mount", "URL", "gl", "file", "log", "Url", "sl", "id", "github", "host", "lr", "r", "path", "ls", "uri"], "in": ["inf", "b", "n", "IN", "l", "inc", " IN", "inner", "cin", "body", "ins", "input", "reader", "vin", "rin", "In", "is", "f", "isin", "kin", "init", "info", "ln", "asin", "mn", "stream", "file", "gin", "mat", "ain", "inn", "sin", "out", "din", "i", " din", "source"], "bin": ["b", "cache", "conn", "thin", "mon", "ebin", "cin", "inner", "abin", "cos", "buffer", "spin", " bins", "reader", "obin", "rin", " Bin", "rb", "by", "bi", "bed", "bn", "mem", "sam", "bg", "buff", "con", "pipe", "ln", "win", "file", "gin", "ran", "local", "loader", "binary", "bl", "stock", "inn", "sin", "nb", "lib", "out", "din", "bur", " din", "len"], "line": ["entry", "link", "print", "code", "l", "err", "record", "cat", "lin", "eline", "body", "chain", "el", "no", "store", "string", "lines", "one", "lo", " Line", "base", "state", "load", "field", "cmd", "col", "char", "trace", "style", "cell", "row", "Line", "ine", "inline", "sample", "ls", "liner", "comment", "section", "column", "ide", "ln", "block", "iter", "level", "word", "port", "le", "LINE", "file", "lane", "range", "se", "log", "job", "part", "ice", "point", "path", "page", "channel", "frame", "text"], "version": ["browser", "v", "scale", "command", "project", "serial", "usage", "key", "Version", "test", "hash", "major", "VER", "virtual", "date", "index", "string", "software", "VERSION", "volume", "image", "status", "video", "name", "sequence", "description", "latest", "type", "license", "feature", "river", "form", "client", "vers", "ver", "number", "language", "iso", "title", "info", "position", "ion", "vision", "value", "resource", "format", "versions", "release", "update", "match", "spec", "tag", "translation", "python"], "build": ["dev", "b", "building", "print", "link", "project", "struct", "use", "install", "full", "test", "hash", "develop", "date", "dist", "th", "ble", "ward", "load", "ship", "builder", "boost", "hold", "uild", "built", "latest", "ver", "style", "other", "unit", "Build", "work", "where", "old", "be", "add", "last", "bor", "log", "make", "release", "update", "match", "binary", "round", "bug", "db", "arch", "lib", "tag", "fail", "util"]}}
{"id1": "19944975", "id2": "21308543", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["WriteConfiguration", " writeSettings", "WriteConfig", "writeSettings", "WriteSettings", "outputSettings", " writeConfig", "outputConfig", " writeContent", "writeContent", "outputConfiguration", "WriteContent", "outputContent", "writeConfig"], "out": ["o", "report", "b", "n", "cast", "to", "list", "conn", "null", "print", "err", "h", "res", "OUT", "at", "free", "msg", "group", "c", "over", "table", "up", "Out", "ou", "io", "writer", "aos", "cmd", "client", "outer", "ch", "con", "check", "w", "file", "t", "help", "log", "result", "ent", "set", "all", " OUT", "g", "cm", "OU", "output", "outs", "this", "v", "pool", "pretty", "p", "nt"], "url": ["http", "rect", "link", "l", "ll", "rl", "address", "key", "rel", "user", "location", "base", "name", "loc", "cert", "char", "client", "f", "str", "abs", "mail", "ssl", "dl", "ret", "ref", "nl", "bel", "domain", "mount", "URL", "gl", "file", "resource", "service", "pattern", "Url", "sl", "r", "path", "net", "uri"], "in": ["m", "null", "IN", "l", "it", "al", "inner", "cin", "sum", "body", "ins", "el", "input", "user", "reader", "ind", "rin", "bin", "up", "In", "inside", "is", "io", "f", "str", "isin", "sample", "serv", "st", "con", "and", "none", "ma", "mc", "file", "gin", "from", "read", "en", "inn", "sin", "r", "on", "din", "i", " din", "source"]}}
{"id1": "20247400", "id2": "3430784", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"in": ["inf", "IN", "inc", "it", "inner", "cin", "ins", "input", "ind", "rin", "bin", "up", "In", "is", "io", "ze", "isin", "init", "con", "info", "and", "check", "ai", "file", "gin", "from", "inn", "on", "net", "din", "i", " din", "source"], "out": ["o", "report", "n", "b", "to", "print", "screen", "list", "null", "err", "ex", "oss", "it", "obj", "ins", "OUT", "at", "msg", "name", "os", "Out", "io", "ou", "cmd", "writer", "client", "str", "outer", "sys", "we", "other", "write", "dir", "ot", "con", "ln", "check", "println", "w", "t", "log", "auto", "gt", "exit", "OU", "output", "r", "outs", "net", "or", "ne", "line"], "buffer": ["b", "batch", "cache", "Buffer", "command", "header", "data", "function", "address", "key", "filter", "flush", "memory", "processor", "index", "window", "total", "database", "limit", "available", "template", "shape", "table", "document", "sequence", "bar", "attribute", "trace", "queue", "buf", "channel", "clear", "phrase", "append", "buff", "pause", "comment", "sample", "stack", "iter", "block", "position", "size", "se", "library", "result", "variable", "match", "binary", "view", "event", "component", "output", "db", "message", "temp", "display", "history", "length", "bridge", "source"]}}
{"id1": "19494842", "id2": "838844", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"callService": [" callservice", "runservice", "runQuery", "runServices", "useQuery", "callservice", " callServices", "useservice", "useServices", " callQuery", "runService", "callServices", "useService", "callQuery"], "url": ["browser", "http", "pl", "b", "link", "conn", "web", "l", "ll", "address", "hl", "base", "oul", "google", "client", "char", "str", "ul", "ssl", "dl", "ur", "nl", "bel", "URL", "acl", "resource", "file", "gl", "service", "Url", "sl", "get", "sb", "r", "channel", "ls", "uri"], "in": ["inf", "b", "oin", "IN", "l", "it", "inc", "ill", "inner", "cin", "sum", "ins", "el", "input", "reader", "rin", "bin", "In", "io", "is", "again", "isin", "con", "and", "iter", "mc", "er", "check", "ri", "mn", "gin", "from", "read", "all", "en", "conf", "inn", "r", "on", "ic", "out", "din", "i", " din"], "inputLine": ["responseLine", "inputL", " inputFile", "inputline", "outputL", "responseRow", "helloFile", "parseLine", "parseFile", "helloLine", "contextLine", "contextline", "inputFile", "InputRow", "parseLINE", "outputRow", " inputline", "helloLINE", "Inputline", "inputRow", "outputLine", " inputL", "outputline", "responseLINE", " inputLINE", "InputLINE", "inputLINE", "contextL", " inputRow", "InputLine", "helloRow", "responseline", "parseRow", "contextRow"], "buf": ["pb", "bh", "Buffer", "hung", "tab", "pkg", "inv", "fam", "mu", "msg", "area", "aux", "bu", "rb", "uf", "bar", "cmd", "alph", "cf", "bag", "comm", "nom", "bed", "queue", "img", "conv", "mem", "bg", "buff", "br", "cb", "raf", "cap", "vec", "cur", "cam", "vet", "cv", "block", "mk", "nm", "gor", "db", "Buff", "buffer", "ob"], "answer": ["report", "entry", "cache", "print", "continue", "equ", "command", "install", "address", "question", "onse", "username", "response", "image", "about", "accept", "array", "sequence", "replace", "form", "again", "offer", "ver", "send", "review", "reply", "remember", "version", "sn", "ve", "search", "value", "ask", "say", "result", "interpret", "argument", "exit", "Answer", "poll", "option", "message", "place", "answered", "channel", "archive"]}}
{"id1": "23215235", "id2": "414258", "code1": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readFile": ["parseFiles", "ReadSourceFile", " readSourceFile", "parsefile", "ReadFile", "ReadFiles", "readSourceFile", "readFiles", " readfile", "parseSourceFile", "readfile", "parseFile", "Readfile", " readFiles"], "url": ["browser", "http", "b", "link", "web", "l", "ll", "html", "rl", "address", "full", "rel", "uri", "string", "location", "p", "base", "name", "loc", "document", "char", "client", "str", "abs", "il", "ssl", "dl", "u", "ref", "ur", "nl", "bel", "domain", "mount", "URL", "gl", "file", "impl", "pattern", "log", "ml", "Url", "job", "sl", "id", "cl", "fl", "host", "db", "path", "page", "channel", "ls", "item"], "IOException": [" ioError", " ioException", "BioError", " IOError", "BioException", "IOError"], "ParserConfigurationException": ["ParserizationException", "ParserConfError", "parserConfigurationFailure", "ParserizationFailure", "ParserConfigurationFailure", "parserConfigException", "ParserConfException", "parserConfigError", "parserConfigurationError", "ParserConfigError", "ParserConfigurationError", "ParserizationError", "ParserConfFailure", "parserConfigFailure", "ParserConfigException", "parserConfigurationException", "ParserConfigFailure"], "SAXException": ["SAVFailure", "DAVError", "DAVFailure", "DAXError", "SAIError", "SAXMFailure", "DAVException", "SAXMError", "DAXFailure", "SAXMException", "SAVException", "SAXFailure", "SAIFailure", "SAIException", "DAXException", "SAXError", "SAVError"], "zipFileName": ["zipFolderId", "zipFileId", "zipfileName", "zipFilePath", "zipFolderID", "zipPagePath", "zipPageName", "archivefileId", "archiveFileId", "zipPageId", "zipfileID", "archiveFilePath", "archivefilePath", "zipfilePath", "zipFolderPath", "zipPageID", "zipFileID", "zipFolderName", "archivefileID", "archiveFileName", "zipfileId", "archivefileName", "archiveFileID"], "urlConnection": ["inputConnection", " urlReader", "UrlReader", "sslClient", "UrlConnect", "inputClient", "UrlClient", "clientConn", "sslConnection", " urlConnect", "urlReader", "clientReader", "UrlControl", "urlControl", "clientConnection", "sslConnect", "sslControl", "inputControl", "clientConnect", " urlConn", "UrlConn", "inputConnect", "urlConn", "UrlConnection", "urlConnect", "urlClient"], "inputStream": ["inputScript", "InputSteam", " inputFile", " InputSteam", " inputScript", " inputContext", "inContext", "InputStream", "InputFile", "inStream", "inputFile", " InputScript", "InputContext", " InputFile", "inputContext", "inSteam", "InputScript", "InputView", " inputSteam", " InputStream", "inputView", "inView", "inputSteam", " inputView"]}}
{"id1": "3053403", "id2": "20375440", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"fc": ["fa", "wic", "lc", "full", "frac", "tf", "mac", "c", "cf", "func", "dl", "act", "nc", "ric", "bf", "con", "unc", "win", "football", "icc", " con", "soc", "fd", "pic", "exp", "cm", "vc", "iac", "tc", "ctx", "hl", "abc", "fn", "fp", "cas", "disc", "coll", "console", "fr", "FC", "ic", "util", "las", "ac", "inc", "fab", "xc", "ff", " dc", "anc", "uc", "f", "df", "rc", "ocl", "fm", "raf", "cs", "irc", "cv", "RFC", "fs", "fl", "sc", "bc", "cl", "ec", "isc", "imp", "cond", "owl", "dc", "fps", "form", "co", "pc", "mc", "fb", "acl", "gc", "aft", "conv"], "buff": ["comp", "b", "xy", "att", "bj", "alf", "bis", "html", "hd", "tf", " buffs", "bin", "cho", "hold", "uf", "rb", "interest", "emb", "bed", "tm", "bo", "func", "act", "mem", "bf", "src", "urg", "exp", "pp", "sb", "tmp", "Buff", "ob", "kw", "h", "ctx", "rend", "fo", "aux", "cmd", "xff", "ref", "cb", "fred", "font", "lf", "ph", "fr", "uff", "supp", "bound", "mb", "gz", "buffer", "beck", "nt", "orm", "batch", "back", "np", "utf", "resp", "grow", "ott", "ind", "boost", "ff", "zz", "gold", "f", " Buff", "cell", "note", "bg", "nd", "off", "td", "hex", "printf", "tt", "def", "fl", "hz", "prof", "bind", "butt", "vt", "pb", "inf", "pred", "important", "Buffer", "ld", "tab", "FF", "dat", "fw", "proc", "obj", "th", "cond", "alph", "form", "buf", "pdf", "fb", "obb", "norm", "alg", "qq", "bb", "ust", "txt"], "encoding": ["encoder", " encusing", "enending", "convoding", "decoder", "coded", "escapending", "encusing", "enoding", "cending", " encaching", "decryption", "continryption", " encoder", "enoder", "encending", "escapoder", "coding", "enoded", "escapoded", "encaching", "escapoding", "continoding", " encryption", "continusing", "coder", "continaching", "enryption", " enccode", "encode", "deccode", "enccode", "encryption", "decoding", "convusing", "encoded", "convaching", "convryption"]}}
{"id1": "6190356", "id2": "19549577", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldMBHash", " hashPasswordForoldMD5", " hashPasswordForOldMB4", " hashPasswordForOldSHA4", " hashPasswordForOldMD4", " hashPasswordForoldMD1", " hashPasswordForoldMD4", " hashPasswordForOldSHA1", " hashPasswordForOldMB1", " hashPasswordForOldMDHash", " hashPasswordForOldSHAHash", " hashPasswordForoldMDHash", " hashPasswordForOldMB5", " hashPasswordForOldMD1", " hashPasswordForOldSHA5"], "password": ["Password", "entry", "raw", "shadow", "secret", "command", "words", "data", "address", "reset", "hash", "user", "pass", "input", "string", "padding", "database", "username", "token", "sword", "login", "name", "prefix", "description", "attribute", "wd", "phrase", "word", "value", "pattern", "wordpress", "default", "message", "text", "p"], "md": ["d", "m", "cd", "ld", " Md", "mand", "mode", "bd", "pd", "hd", "grad", "MD", "mm", "det", "od", "dr", "ind", "pm", "mod", "down", "cmd", "dd", " MD", "ct", "red", "der", "df", "pdf", "ms", "dir", "dig", "cmp", "and", "dh", "mt", "mc", "mn", "add", "mk", "sm", "del", "sd", "deep", "dm", "di", "mb", "de", "ds", "sha"], "messageDigest": ["messageWithest", "messagedigear", "Messagedigester", "Messagedigest", "messageDigester", "messageDigse", "messageDatatest", "messageDesignist", "messagedigse", "MessageDigist", "messagedigested", "MessageDigest", "MessageDigse", "messageWithse", "messageDigtest", "MessagedigEST", "messagedigest", "messagedigEST", "messagedigester", "messageWithear", "messageDataester", "messageDesignested", " messagedigested", " messagedigest", " messageDigEST", "messageDesignest", " messagedigist", "messageDigested", "messageDriear", "messageDigear", "MessageDigester", "MessageDigEST", "messageDataEST", "MessageDigtest", "Messagedigse", "messageDriist", "messageDataest", " messageDigested", "messageDigitalest", "messageDigitalested", "messageDigEST", "messageDrise", "messageDigitalist", " messagedigEST", " messageDigist", "messageDesignEST", "messageDriest", "Messagedigear", "messagedigtest", "messagedigist", "messageWithist", "Messagedigist", "messageDigitalEST", "Messagedigtest", "MessageDigear", "messageDigist"], "hexString": ["phpStr", " hexStr", "exString", "hexSingle", " hexSet", "octResponse", "exSingle", " hexSite", "phpSingle", " hexArray", " HexSite", "colorBuffer", "octArray", "phpSite", " hexSingle", "colorStr", " hexBuffer", "phpString", "hexArray", " HexString", " HexArray", " Hexstring", " hexChain", "hexBuffer", "exBuffer", " hexResponse", "phpRest", "hexstring", "octstring", " HexStr", "hexSet", " HexSet", "colorString", "phpChain", "hexSite", " hexstring", " HexResponse", "octString", "phpBuffer", " HexRest", "hexChain", " HexBuffer", "hexRest", "hexStr", " HexChain", "exStr", " hexRest", "colorSet", "hexResponse"], "i": ["m", "multi", "ip", "n", "ci", "ui", "yi", "ij", "o", "in", "it", "ji", "gi", "key", "I", "q", "chain", "phi", "loop", "uri", "index", "ind", "im", "c", "y", "ini", "li", "is", "gu", "ski", "ii", "bi", "u", "pi", "j", "conv", "e", "init", "ai", "sim", "t", "z", "mi", "ti", "ix", "hi", "id", "set", "g", "di", "my", "a", "ic", "x", "si", "ie", "qi", "zi"], "hex": ["comp", "raw", "sh", "print", "prop", "tex", "ex", "rex", "html", "serial", "it", "full", "oct", "h", "rendered", "sex", "pex", "hl", "ext", "xf", "alph", "cf", "form", "php", "red", "imal", "flash", "json", " Hex", "cont", "row", "mix", "sv", "percent", "br", "none", "check", "com", "dump", "exp", "hi", "ph", "tx", "def", "lit", "solid", "hello", "zip", "prof", "x", "EX"]}}
{"id1": "21063400", "id2": "3731077", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doItemImageSort", "doItemImageProcess", " doImageprocess", " doImagesSort", " doImagesProcess", "doMediaWork", " doImageSort", " doImageWork", "doMediaprocess", "doImagesSort", "doImagesWork", "doItemImageprocess", "doImageSort", "doImagesprocess", " doImagesprocess", " doImagesWork", "doMediaProcess", "doImagesProcess", "doImageprocess", "doImageWork", "doMediaSort", "doItemImageWork"], "request": ["command", "address", "server", "session", "question", "input", "re", "image", "template", "document", "quest", "attribute", "client", "context", "application", "version", "resource", "Request", "start", "QUEST", "query", "model", "view", "reference", "message", "frame", "select"], "response": ["http", "report", "entry", "cache", "print", "continue", "list", "detail", "network", "xml", "resp", "server", "respond", "reset", "site", "hash", "res", "user", "onse", "re", "window", "image", "status", "one", "answer", "document", "sequence", "description", "collection", "json", "connection", "parent", "application", "write", "reply", "version", "position", "block", "ve", "next", "search", "format", "Response", "result", "exit", "model", "success", "query", "console", "content", "relation", "view", "output", "fire", "message", "page", "display", "frame", "tree"], "imgSize": [" imgName", "dimsize", "imagError", "imageSIZE", "dimSIZE", "propName", "certScale", "augSize", "certSIZE", "imageInfo", " imgShape", "imageScale", "divSIZE", "imgsize", "augOwner", " imgType", "imgInfo", "imgStyle", " imgsize", "divsize", "divSize", "imgScale", "appStyle", "certSize", "appShape", "imgShape", "appSize", " imgInfo", "augsize", "appsize", "certName", "imagSize", "imgOwner", "imagName", "propsize", "augShape", "imageStyle", "appType", " imgOwner", " imgStyle", "imageSize", " imgSIZE", "imgError", "dimSize", "imgSIZE", "imgName", "appInfo", " imgScale", "propSize", " imgError", "appOwner", "propError", "imgType", "imagsize", "imageName", "imageType"], "imageInputStream": [" imageInputPath", "imageOutputSteam", "imageInStream", "fileRawStream", "fileInputStream", "imageIntPath", "imageInterfaceStream", "imageInputSteam", "imageInSteam", "photoIntstream", "imageByteStream", "fileRawSteam", " imageStreamPath", "imageRawView", "fileRawstream", "imageByteForm", "mediaInputForm", "imageInputPath", "imageStreamPath", "imageRawstream", "imageInputView", "imageInstream", "mediaInputReader", "imageByteReader", "photoIntStream", "photoIntSteam", "imageStreamSteam", "mediaInputSteam", "imageInputReader", "fileInputSteam", " imageStreamStream", "imageRawStream", "imageInterfaceSteam", "imageIntStream", "imageByteSteam", "imageStreamStream", "imageOutputstream", "imageIntstream", "imageOutputForm", "imageOutputReader", "imageInterfaceView", "imageOutputStream", "photoInputstream", "imageInputstream", "fileInputView", "imageRawSteam", "mediaInputStream", " imageStreamSteam", "imageIntSteam", " imageInputSteam", "photoInputSteam", "imageInputForm", "imageInView", "fileRawView", "photoInputStream", "imageInterfacestream", "fileInputstream"], "imageBytes": ["photoGs", "pictureBytes", "audioBytes", "photoBytes", "imgGs", "imageSeries", "imgBs", "imageGs", "photoParts", "imageKeys", "issueParts", "audioSeries", "imageParts", "imageByte", "issueGs", "issueBytes", " imageBs", " imageGs", " imageSeries", " imageByte", "imgBytes", "photoByte", "audioParts", "pictureByte", "imgParts", "photoKeys", "pictureGs", "audioBs", "imgSeries", " imageParts", "pictureParts", "imgKeys", "issueKeys", "imageBs"]}}
{"id1": "12454178", "id2": "7372311", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"alterar": [" alterado", " ingestar", " scalada", " consequado", " consequasar", " alterada", " consequar", " scalasar", " alterasar", " scalado", " ingestasar", " ingestado", " scalar", " consequada", " ingestada"], "t": ["o", "b", "n", "to", "tree", "v", "m", "pt", "l", "it", "tr", "rt", "h", "q", "tg", "det", "total", "at", "template", "c", "tip", "y", "wt", " pt", "table", "type", "trace", "ct", "tm", "tp", "ret", "j", "et", "T", "x", "ter", "e", "ta", "ot", "title", "st", "a", "mt", "task", "qt", "ht", "mint", "w", "te", " ot", "ts", "ent", "tt", "tu", "typ", "get", "g", "dt", "translation", "temp", "i", "out", "ti", "vt", "tc", "txt", "z", "p", "nt"], "stmt": ["sttx", "stmr", " superstmt", " stmk", "Sttxt", "irsttx", "stytm", "Sttm", "stymt", "irstmk", "Stmp", "ttstat", "Stmk", " supersttx", "stytx", " stsm", "ttm", "stm", "stysm", "StMT", " stmp", "Ststat", "stym", "Stmr", "stmp", "stymon", "stmon", "sttm", "irstmt", " stm", " superstMT", "Stmt", " sttm", "sttxt", " superstmr", " sttx", "ststat", "Sttx", "stmk", "sysm", "styMT", "irstMT", "symt", "stsm", " stmr", "stMT", "ttmt", "sym", " stMT", "Stm", " stmon", " sttxt", " supersttxt", "symon", "ttmp", " ststat"], "sql": ["su", "n", "csv", "l", "xml", "pel", "q", "spr", "el", "software", "string", "expression", "ql", "seed", "template", "name", "table", "description", "fn", "cmd", "sk", "sys", "sv", "dl", "nl", "lex", "wal", "ln", "sq", "QL", "format", "url", "s", "series", "sd", "query", "SQL", "spec", "initial", "sol", "scl", "lock", "ls", "select"], "id_disciplina": ["id_displinator", "id_displina", "id_Discompline", "id_disrigina", "id_descipline", "id_Discipline", "id_disciine", "id_Disciplineinator", "id_discompline", "id_Discomplain", "id_discomplain", "id_Discomplini", "id_disciplineina", "id_Disciplini", "id_disciplineinate", "id_descomplini", "id_discomina", "id_Disciplain", "id_disriginate", "id_disgrine", "id_disciplinator", "id_discomine", "id_discomain", "id_desciplini", "id_discomplina", "id_disciplini", "id_displini", "id_Discomplina", "id_disrigINA", "id_displINA", "id_Disciplinator", "id_disciplINA", "id_Disciplineina", "id_DisciplINA", "id_disciina", "id_discomini", "id_disciplain", "id_Disciplineinate", "id_DisciplineINA", "id_disriginator", "id_Disciplinate", "id_descomplain", "id_disgrain", "id_desciplain", "id_descompline", "id_displinate", "id_disciplinate", "id_disciplineINA", "id_discipline", "id_displain", "id_disciain", "id_discomplini", "id_disgrini", "id_disciini", "id_descomplina", "id_disciplineinator", "id_disgrina", "id_displine", "id_desciplina", "id_Disciplina"], "item": ["entry", "menu", "link", "in", "it", "ex", "hit", "key", "site", "obj", "instance", "store", "p", "rec", "image", "tip", "bar", "row", "other", "unit", "iso", "e", "me", "info", "element", "iter", "task", "word", "local", "mi", "items", "team", "job", "id", "article", "match", "object", "component", "event", "Item", "i"]}}
{"id1": "539195", "id2": "5138455", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" Copy", "to", "link", "csv", "cat", "cp", "create", "cop", "download", "Copy", " cop", "transfer", "load", "replace", " cp", "save", "init", "upload", "move", "clone", "sync", "println", "gc", "dump", "delete", "Cop", "slice", "ls"], "src": ["comp", "in", "ctr", "pkg", "rl", "rt", "sec", "spr", "filename", "rel", "ins", "input", "ser", "desc", "dist", "attr", "req", "rs", "rx", "iv", "loc", "imp", "str", "img", "sys", "usr", "orig", "sel", "rc", "init", "ls", "st", "cur", "Source", "inst", "urg", "url", "from", "pres", "start", "sit", "sc", "spec", "host", "sb", "addr", "ident", "sin", "this", "sr", "txt", "sq", "uri", "source"], "dest": ["d", "rest", "it", "cat", "them", "test", "deg", "target", "dist", "req", "loc", "decl", "Dest", "nw", "sup", "end", "nom", "cont", "trans", "usr", "mem", "est", "dir", "st", "origin", "https", "opt", "master", "home", "exp", "del", "gt", "id", "tmp", "temp", "way", "orig", "p", "source"], "ifp": ["alfp", " ify", "alfpp", "ibpa", " ifpa", " ifsp", "ifsp", "iby", "Ifcp", "ffy", "aftp", "Ife", "ffsp", " ifcp", "afpc", "ihp", "ifcp", "ihop", "iftpc", "alftp", "ffp", "ifpa", "iftpp", "ife", " ifop", "ifop", " ife", "ify", "ffpa", "Ifop", "ifpp", "alfpc", "iftp", "ifpc", "ibp", "ifttp", "afpp", "Ifp", "ibsp", "ihcp", "ihe", "afp"], "ofp": ["OFjp", "Ofd", "OFd", "ofP", "ofd", "orfp", " ofproc", "offjp", "offp", "ofjp", "OFP", "ofproc", "offd", "ofsp", "Ofsp", "orfd", "Ofjp", "Ofp", "orfsp", " ofsp", "OfP", "Ofproc", " ofd", "offP", "orfproc", "OFp"], "fis": [" fai", "wiss", "gi", "fiss", "fiist", "fliss", "gais", "Fist", "Fais", "flis", "wais", "fi", " fiss", "flai", "wis", "fios", "Fos", "wi", "Fiss", "flais", "Fis", "Fai", "giss", "fist", "gis", " fi", " fais", "fiis", "fiiss", "fai", " fist", "fais"], "fos": [" foes", "foes", "flaos", "Foss", " faos", "fioes", "flis", " fios", "woss", "fiaos", "Foes", "fios", "flios", "Fos", "woes", "wos", "floes", " foss", "foss", "flos", "Foses", " foses", "woses", "fiis", "foses", "waos", "wios", "faos"], "b": ["pb", "d", "v", "batch", "l", "bis", "bd", "blue", "h", "body", "k", "base", "y", "B", "bar", "rb", "f", "ab", "bi", "bit", "j", "ch", "bg", "br", "reb", "cb", "bits", "fb", "be", "wb", "gb", "bb", "bc", "eb", "binary", "g", "db", "nb", "sb", "lib", "bs", "mb", "ob", "z", "p"]}}
{"id1": "8164056", "id2": "5414088", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encode": ["genenc", " encenc", "Enenc", "genode", "enode", "genoder", "gencode", " encoder", "enoder", "enenc", "Enoder", "Encode", "Enode", " enccode"], "str": ["m", "b", "v", "n", "strings", "print", "it", "tr", "ctr", "data", "Str", "oct", "obj", "wr", "res", "input", "string", "msg", "c", "name", "arr", "char", "comm", "text", "enc", "sp", "e", "br", "st", "STR", "w", "coll", "t", "spec", "r", "this", "conv", "txt", "p"], "buf": ["pb", "b", "que", "batch", "bh", "Buffer", "hung", "np", "pkg", "proc", "av", "obj", "mu", "msg", "aux", "rb", "bar", "cmd", "uf", "cf", "ob", "bp", "bag", "queue", "var", "bn", "bo", "agg", "aer", "bg", "buff", "cap", "cb", "br", "box", "iter", "block", "cur", "cv", "next", "printf", "bc", "bound", "output", "db", "tmp", "pool", "Buff", "temp", "buffer", "foo", "txt"], "md5": [" MDct", " Md3", "md45", "md2", "md12", "MD3", " mdlet", "mdlet", "mdct", "dig8", "dig45", "MD2", " Mdlet", " md12", "dig5", "dig12", "MD5", " md2", "md8", "dd3", "dig2", " MDlet", "dd8", " md45", " MD3", "dd5", "md3", "dig3", " Md5", "MD12", " MD5", "dd45", " md3", " Mdct", " md8", " mdct"], "bytes": ["ashes", "b", "frames", "xy", "clips", "bes", "words", " b", "js", "classes", "sites", "blocks", "bis", "services", "parts", "seconds", "pieces", "bles", "gets", "pointers", "bps", "fps", "its", "vs", "fixes", " chunks", "files", "bits", "cb", "ios", "steps", "tes", "names", "xs", " buffers", "ings", "iers", "es", " tmp", "gb", "binary", " slices", "outs", "tmp", "values", " pixels", "bs", "pages", "Bytes", "gs", "terms", "vals"], "i": ["m", "multi", "ip", "v", "ci", "ui", "batch", "b", "n", "ij", "in", "it", "ex", "ji", "gi", "key", "I", "q", "chain", "phi", "us", "major", "index", "ind", "im", "\u0438", "c", "y", "ki", "ini", "li", "is", "io", "gu", "ski", "ii", "iu", "xi", "json", "bi", "pi", "u", "j", "conv", "a", "init", "me", "info", "cli", "ai", "sim", "mi", "ti", "hi", "ix", "id", "point", "di", "ic", "x", "si", "ie", "qi", "uri"], "s": ["b", "n", "v", "l", "js", "h", "string", "rs", "gets", "gs", "y", "os", "S", "is", "ss", "hs", "f", "join", "abs", "sv", "j", "sql", "conv", "sp", "txt", "sf", "single", "t", "z", "ts", "se", "fs", "sw", "sl", "set", "spec", "sol", "g", "sb", "r", "ps", "ns", "ds", "ls", "sq", "p"]}}
{"id1": "3558512", "id2": "189963", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"serialize": ["finalize", "serializer", "initialization", "initialize", "erialize", "serialization", " serialate", "Serialized", "initialized", "finalization", " serialized", "Serialze", "finalized", "erialate", "serialized", "serialate", " serializer", "initialze", "serialze", "Serialate", "Serializer", "Serialize", "Serialization", "finalze", "erializer", "erialized"], "out": ["d", "o", "b", "v", "report", "n", "to", "err", "it", "sum", "res", "OUT", "c", "os", "up", "Out", "ou", "io", "aos", "f", "ch", "serv", "stream", "w", "t", "file", "log", "result", "sw", " OUT", "OU", "output", "outs", "pool", "a", "i", "p"], "parser": ["tree", "parse", "aser", "plan", "walker", "command", "Parser", "policy", "magic", "pkg", "xml", "inner", "bank", "proc", "util", "processor", "p", "reader", "token", "base", "builder", "tar", "language", "writer", "password", "handler", "asser", "rer", "worker", "layer", "style", "tp", "lp", "ger", "manager", "er", "peer", "now", "format", "file", "loader", "ler", "job", "part", "arser", "per", "jack", "instance", "ker"], "on_disk": [" on_dis", " on_disc", "on_download", "on_volume", "on_disc", "on2file", "on_file", "On_link", " on_Disk", " on_volume", "On2Disk", "on_cloud", "On2file", "On_cloud", "On2link", "On_disk", " on_file", "On_Disk", "on_Disk", "on_dis", "On_file", "on2link", "on_link", "On2disk", "on2Disk", "on2disk", " on_download"], "in": ["inf", "IN", "ad", "inc", "it", " IN", "inner", "cin", "body", "ins", "input", "ind", "vin", "rin", "bin", "min", "In", "inside", "io", "is", "isin", "and", "gin", "from", "mi", "id", "en", "ain", "inn", "sin", "on", "r", "i", "din", " din"]}}
{"id1": "6840241", "id2": "19096138", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["link", "print", "cat", "cp", "cop", "create", "call", "Copy", "system", "clip", "transfer", "load", "replace", "write", "save", "move", "clone", "sync", "size", "gc", "map", "read", "close", "cover", "opy", "delete", "slice", "share"], "source": ["cache", "inner", "SOURCE", "body", "site", "session", "ins", "input", "store", "reader", "image", "status", "state", "base", "template", "table", "inside", "wrapper", "style", "subject", "sql", "context", "src", "scope", "sample", "sp", "ource", "origin", "iter", "info", "Source", "ce", "size", "stream", "resource", "local", "from", "se", "start", "master", "spec", "shell", "pse", "sr", "si", "ie", "select", "parent"], "sink": ["ssink", "Sink", "sender", "slender", "sinker", " sender", "Sinker", " sue", "Sender", "slource", "Sue", "asinker", "Source", "ssender", "asink", "sue", "asender", "slink", "ssource", " sinker", "asource", "slue", "ssinker"]}}
{"id1": "13666876", "id2": "14785308", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"transformSingleFile": ["processSinglefile", "transformSingleSourceFile", "transformSimpleRecord", "transformSingleFiles", "transformSingleModel", "transformOneSourceFile", "TransformSinglePage", "transformOnefile", "transformsingleRecord", "processsingleSourceFile", "transformMultiModel", "transformMultiSourceFile", "transformMultiPage", "transformSinglefile", "transformsingleModel", "transformOneFile", "transformSimplePage", "transformSimpleFile", "transformsinglefile", "transformMultiRecord", "TransformSimpleModel", "transformMultiFile", "TransformSimpleFile", "transformMultifile", "TransformSingleFile", "processsinglefile", "processSingleFile", "transformsingleFile", "transformsingleFiles", "processsingleFiles", "TransformSimpleRecord", "TransformSimplePage", "processSingleFiles", "transformSimpleModel", "transformOneFiles", "processSingleSourceFile", "TransformSingleModel", "TransformSingleRecord", "transformsingleSourceFile", "transformsinglePage", "transformMultiFiles", "processsingleFile", "transformSingleRecord", "transformSinglePage"], "xed": ["txED", "txer", "rxeds", "Xeded", " xented", "uxED", "wxED", "exED", "exeded", "uxed", " xred", "wxred", "xeds", "xer", "wxEd", " xED", "txeds", "passed", "Xeds", "xied", "rxed", "Xed", "xEd", "uxented", "passred", " xied", "pxed", "rxer", "uxied", " xEd", "exeds", "wxied", "exed", "xented", "xeded", "passED", "pxeds", "wxented", "pxED", "txed", "rxED", "XED", "xED", "pxeded", "Xer", "xred", "wxed", "passEd"], "node": ["entry", "n", "link", "edge", "create", "post", "no", "index", "directory", "entity", "seed", "image", "one", "remote", "array", "process", "load", "scene", "name", "station", "stage", "feature", "our", "row", "parent", "note", "Node", "and", "hand", "word", "resource", "range", "map", "job", "set", "day", "ode", "object", "view", "event", "right", "component", "de", "channel", "tree", "line"], "dob": [" dab", " dobar", " doy", "Dobar", "drod", "dab", "drob", "drab", "Dab", " dobb", "dobb", "Doy", "adobar", "diab", "doy", "drobb", "dod", "adob", "diobb", "diod", "adoy", " dod", "diob", "dobar", "adab", "Dob"], "mySrc": ["myDesRC", "mySelources", "myDesources", "mySingsrc", "mySourceource", "mySfc", "myDesrc", "MySRC", "myInsfc", "MySrc", "mySelRC", "MySsrc", "mySingrc", " mySRC", "mySingfc", "mySelsrc", "myAsrc", "myAsource", "MySource", "myInssrc", "myDessrc", "myAsRC", "mySourcesrc", "mySelrc", " mySfc", "MySources", "myInsrc", "mySsrc", "mySRC", "myAssrc", " mySsrc", "mySources", "myInsRC", "mySource", "mySingRC", "mySourcerc", "mySourceRC"], "mySrcF": ["mySsrcO", "mySourceO", "mySsrcI", "myMrcFP", "mySsrcC", "mySourceFP", "myMourceFP", "mySrcP", "mySufO", "mySourceV", "mySufF", "mySRCF", "mySrtI", "mySourceF", "mySrtF", "myMrcF", "mySufV", "mySsrcF", "myMourceF", "myMrcV", "mySrcFP", "mySrcV", "mySRCC", "mySrtC", "myMourceO", "mySRCI", "mySufFP", "mySsrcP", "mySrcI", "myMourceV", "myMrcO", "mySsrcFP", "mySrcC", "mySrtP", "mySRCP", "mySsrcV", "mySrcO"], "myOutF": ["myOffDF", "myOutFile", "myOffE", " myOutC", "mysOutL", "myCoW", "myObjFile", "myOutputV", "myOutputE", " myOutE", "myArtW", "myInV", "myObjF", " myOutV", "myOutputFs", " myoutV", "myOutL", "mysOutFL", "myNetE", "MyInFs", "myOutW", "MyOutFile", "MyOutF", "myOutE", "myOutC", "myInFile", "myObjFs", "myOutputDF", "myOutFL", "MyOutFs", "myOffFile", "myOffF", " myoutF", "MyInFile", " myNetDF", "myOutputF", "myCoF", "MyInV", "myOutFs", "myInF", "myArtFL", "myoutC", "mysNetL", "myOutDF", "mysOutF", "mysNetFL", " myoutL", " myOutL", "myArtF", "myoutV", "myCoL", " myOutFile", "myNetF", "MyOutV", "myNetL", "myOutV", "myNetFile", "myNetW", " myNetF", "myOutputC", "mysNetW", "myCoFL", " myOutDF", "myInL", "MyInF", "myNetFL", "myOutputL", "myoutF", "mysOutW", "myArtL", " myNetFile", "myObjV", "myNetDF", " myNetE", "myOutputFile", " myoutC", "myoutL", "mysNetF", "myInC", "myInFs"], "co": ["o", "ca", "ci", "cache", "CO", "ror", "lc", "cop", "ho", "oc", "cos", "obj", "no", "ro", "lo", "wo", "yes", "aco", "c", "flo", "cho", "loc", "xc", "fo", "io", "col", "fc", "nc", "so", "ko", "con", "ace", "copy", "cs", "ce", "cv", "com", "ico", "coll", "go", "gc", "soc", "ctrl", "cod", "coord", "can", "cl", "cover", "mo", "roc", "cal", "cm", "po", "Co", "cc", "ck", "cu", " Co"], "x3dvFile": ["x3dtfile", "x3dvsFilename", "x3dbfile", "x3cdVFilename", "x3pdbString", "x3davFile", "x3dvsFile", "x3dbString", "x3pdvFile", "x3cdVFile", "x3davPath", "x3cdvFile", "x3dvPath", "x3pdbFilename", "x3pdbFile", "x3dtFilename", "x3dVPath", "x3dtFile", "x3dVfile", "x3dVFilename", "x3dvfile", "x3dvFilename", "x3cdvFilename", "x3dbFilename", "x3dVFile", "x3dbFile", "x3dvString", "x3dtString", "x3pdvFilename", "x3pdvfile", "x3cdvPath", "x3dvsPath", "x3pdbfile", "x3dVString", "x3pdvString", "x3cdVPath", "x3davFilename"], "fis": ["fisi", "fliz", "fires", "bis", "bisi", "fiss", "frie", "fliss", " fiz", "flis", " fie", "fiz", "fileiz", " fiss", " fires", " fisi", "frisi", "biss", "fie", "friss", "fileires", "fileis", "bie", "flires", "fileiss", "fris"], "gzos": ["ggops", "ggies", "zipnos", "gzoss", "gtoss", "gtos", "gsos", "gos", "gties", "ziposs", "gzops", "gznos", "zoes", "gzaos", "sslos", "gzo", "ggos", "zoss", "gsoss", "gzoes", "goss", "gsops", "gtoes", "sslaos", "zaos", "gsnos", "ssloss", "go", "gaos", "zo", "sslo", "gtops", "zies", "zipos", "gzies", "zops", "zipops", "zos", "ggoes", "gtnos"], "buf": ["b", "cast", "batch", "raw", "aka", "Buffer", "tab", "cat", "pkg", "buffer", "mu", "seq", "arr", "uf", "rb", "cmd", "bar", "cf", "bag", "emb", "img", "var", "ref", "mem", "br", "buff", "box", "cap", "cb", "bytes", "block", "vec", "font", "cam", "cv", "fb", "cur", "wb", "max", "good", "Buff", "conv", "orig", "bus"], "ret": ["v", "att", "print", "continue", "val", "RET", "err", "back", "tr", "ctr", "rt", "elt", "deg", "test", "obj", "res", "re", "ext", "aux", "cert", "cmd", "ft", "red", "end", " Ret", "cont", "arg", "ref", "ter", "Ret", "alt", "iter", "ptr", "mt", "pret", "gt", "def", "inter", "repl", "r", "nt", "out", "rets", "et", "ry", "len"]}}
{"id1": "6271502", "id2": "8801436", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getResourceByClassName": ["getResourceByPackageNames", "getResourcebyclassType", "getResourceByPackageName", "getResourcebyclassName", "getResourceByClassType", "getResourceByFileNames", "getResourceByFileName", "getResourceByPackageType", "getResourcebyClassPath", "getResourceByClassNames", "getResourceByclassPath", "getResourceByPackagePath", "getResourcebyclassPath", "getResourcebyClassType", "getResourceByFilePath", "getResourceByClassPath", "getResourceByFileType", "getResourceByclassNames", "getResourceByclassName", "getResourcebyClassName", "getResourcebyClassNames", "getResourceByclassType", "getResourcebyclassNames"], "className": ["classesNAME", " classNames", " classType", "classFamily", "ClassName", "classType", " classname", "templateFamily", "templateType", " classNAME", "classesFamily", "templateName", "ClassNAME", "CLASSName", "CLASSname", "ClassNames", "CLASSNAME", "classname", "templateNAME", "classesName", "Classname", "classNAME", "CLASSNames", "classNames", "classesType", " classFamily"], "url": ["browser", "http", "b", "entry", "rect", "raw", "link", "web", "l", "err", "ll", "rl", "address", "rel", "user", "re", "location", "name", "loc", "button", "builder", "char", "f", "str", "abs", "mail", "ret", "ssl", "dl", "ref", "nl", "mount", "URL", "resource", "file", "gl", "service", "impl", "result", "log", "ml", "Url", "job", "sl", "cl", "bb", "get", "lr", "mb", "path", "page", "util", "channel", "or", "ls", "uri"]}}
{"id1": "20995534", "id2": "19467540", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromFilename", "loadPropertiesfromClassname", "loadPropertiesfromClasspath", "loadPropertiesFromclassname", "loadPropertiesfromclassname", "loadPropertiesFromFilePath", "loadPropertiesFromClassPath", "loadPropertiesfromClassPath", "loadPropertiesFromClassname", "loadPropertiesFromclassloader", "loadPropertiesFromclassPath", "loadPropertiesfromClassloader", "loadPropertiesFromclasspath", "loadPropertiesfromclasspath", "loadPropertiesFromClassloader", "loadPropertiesfromclassloader", "loadPropertiesfromclassPath", "loadPropertiesFromFileloader", "loadPropertiesFromFilepath"], "path": ["entry", "pt", "prop", "Path", "policy", "data", "key", "full", "xml", "test", "chain", "filename", "root", "string", "location", "ath", "p", "directory", "template", "base", "transform", "name", "prefix", "type", "program", "str", "context", "dir", "module", "mount", "txt", "hex", "w", "format", "file", "resource", "pattern", "log", "config", "PATH", "zip", "empty", "text", "item"], "locations": ["locifications", "locates", "equifications", "Locifications", "equators", "LOCATIONS", "plATIONS", " locifications", "Locates", " locators", "plates", "equATIONS", "Locations", "equations", "localations", "LOCators", "LOCocations", "locATION", "LocATION", " locATIONS", " locATION", "Locators", "LOCations", "locATIONS", "plocations", "plations", "localifications", "LOCates", "locators", " lococations", "localATION", "LOCifications", "Lococations", "localates", " locates", "lococations"], "props": ["Probs", "preps", "progs", "properties", "peps", "Progs", "pebs", "Prors", "prors", "pregs", "preports", " prors", "privperties", "prodates", "roperties", "rops", "privps", " prodates", "privdates", "propperties", "Props", "peperties", "Prodates", "pegs", "privrs", "preperties", "Proports", "probs", "propports", "propps", " properties", "proports", "robs", "Properties", "propgs", "rogs"], "url": ["browser", "http", "link", "web", "l", "ll", "html", "rl", "xml", "address", "server", "key", "rel", "el", "user", "string", "location", "term", "name", "loc", "char", "f", "str", "row", "mail", "dl", "org", "ref", "ur", "nl", "bel", "mount", "element", "URL", "gl", "file", "resource", "pattern", "log", "Url", "config", "sl", "r", "mb", "page", "ob", "ls", "uri"], "in": ["IN", "inc", "data", "inner", "cin", "sum", "body", "ins", "input", "reader", "ind", "vin", "bin", "In", "is", "io", "media", "sql", "isin", "sample", "init", "con", "and", "info", "ln", "mc", "ma", "mn", "stream", "file", "from", "gin", "mat", "mi", "mr", "read", "en", "as", "cm", "inn", "on", "out", "din", "i", "cn", "source"]}}
{"id1": "6840241", "id2": "18164929", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"copy": ["link", "print", "cat", "cp", "cop", "create", "call", "Copy", "system", "clip", "transfer", "load", "replace", "write", "save", "move", "clone", "sync", "size", "gc", "map", "read", "close", "cover", "opy", "delete", "slice", "share"], "source": ["cache", "inner", "SOURCE", "body", "site", "session", "ins", "input", "store", "reader", "image", "status", "state", "base", "template", "table", "inside", "wrapper", "style", "subject", "sql", "context", "src", "scope", "sample", "sp", "ource", "origin", "iter", "info", "Source", "ce", "size", "stream", "resource", "local", "from", "se", "start", "master", "spec", "shell", "pse", "sr", "si", "ie", "select", "parent"], "sink": ["ssink", "Sink", "sender", "slender", "sinker", " sender", "Sinker", " sue", "Sender", "slource", "Sue", "asinker", "Source", "ssender", "asink", "sue", "asender", "slink", "ssource", " sinker", "asource", "slue", "ssinker"]}}
{"id1": "8216539", "id2": "11933797", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentAsStr", "getFileTextAsText", "getFileTextAsString", "getFileContentAsText", "getFileContentasStr", "getFileContentasString", "getFileContentasText", "getFileTextAsStr"], "filePath": [" fileDef", "ilePath", "baseName", "filePATH", "baseString", "entryName", "FileInfo", "ileDef", "fileString", "Filepath", " fileString", "basePath", "entrypath", " filepath", "basepath", "FILEName", " fileName", "FileName", "FILEPath", "entryPath", "FilePath", "fileDef", "FileString", "FILEPATH", "ileName", " fileInfo", "filepath", "FileDef", "entryPATH", "FILEpath", "FilePATH", "ileInfo", "fileInfo", "fileName"], "encoding": ["enuing", "encuing", "characterordering", "unicuing", "ENCaching", "enoding", "unicoding", "Encaching", "enaching", "ENCoding", "unicode", "encordering", "unicaching", "encaching", "Encode", "characterging", "encging", "characteraching", "Encordering", "Encoding", "ENCordering", "Encuing", "encode", "enode", "characteroding", "Encging", "ENCging"], "testURL": ["testSR", "testedUR", "TestSR", "testingURL", "testingUrl", "testUrl", " testRE", "testedUrl", "testingRE", "testRE", "TestUrl", " testUrl", "testingUR", "TestUR", "testingSR", " testUR", "testUR", "checkURL", "checkSR", " testSR", "testedRE", "TestURL", "checkUR", "testedURL", "checkUrl"], "input": ["ip", "list", "in", "it", "data", "q", "audio", "Input", "pull", "client", "act", "init", "upload", "iter", "url", "file", "get", "focus", "tmp", "channel", "current", "quit", "source", "raw", "feed", "address", "inner", "exec", "up", "open", "sample", "stream", "start", "read", "config", "output", "PUT", "batch", "command", "xml", "missing", "reader", "image", "cont", "exist", "context", "qa", "active", "cur", "iterator", "from", "eval", "can", "empty", "submit", "hidden", "has", "unsigned", "accept", "quick", "form", "json", "comment", "add", "acl", "op", "view", "hello", "lat"], "sw": ["su", "kw", "rew", "sh", "wra", "ws", "fw", "wr", "ew", "aw", "wo", "SW", "ews", "sk", "nw", "ows", "sa", "wa", "sv", "tw", "iw", "we", "igm", "enc", "sp", "Sw", "ow", "sn", "sf", "sem", "w", "sm", "wl", "hw", "wh", "sl", " Sw", "sc", "sb", "sur", "was", "wn"]}}
{"id1": "7872659", "id2": "5998352", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndVideoindexfile", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndVideoindexTable", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndVideoIndexFiles"], "completePath": [" completeDirectory", "totalPod", "pleteRoot", "pletionDir", "pleteScript", "fullPod", "completeLocation", "pletionProject", "completeDirectory", "pletionNow", "completeNow", "CompleteDir", "totalPath", "CompletePath", "CompleteProject", "COMPLELog", "pleteDir", "completeDir", "completeProject", "pletePod", "pleteProject", "pletionPath", "COMPLEPath", "COMPLEDir", "completeScript", "fullLocation", "CompleteLocation", " completesPath", " completesDirectory", "completeRoot", " completesDir", "CompleteScript", "pleteLog", "totalLocation", " completeDir", "CompleteNow", "totalRoot", "completePod", "CompleteDirectory", "fullPath", "pleteNow", "pleteLocation", "fullRoot", "COMPLEScript", " completeLocation", " completesLocation", "completeLog", "CompleteLog", "pletePath"], "masterFile": ["completefile", "completeFile", "managerFile", "MasterFilename", "masterPath", "currentName", "currentFile", "managerPath", " masterPath", "MasterName", " masterFilename", "currentfile", "managerfile", "MasterPath", "masterfile", "managerFilename", "completeName", "MasterFile", "Masterfile", "masterFilename", " masterfile", "currentPath", "masterName"], "CustRatingFileName": ["CustRatedfileSet", "CustRankFileName", "CustRatingTableNames", "CustRatingFilenameSet", "CustRatedFileSet", "CustRankFilesName", "CustRatedFileNames", "CustRatingFieldInfo", "CustRatedFileName", "CustRatingFileType", "CustRankFileInfo", "CustRatedfileName", "CustRatingFilenameType", "CustRatingFilesType", "CustRankFilesType", "CustRatingFileSet", "CustRatingfileType", "CustRatingFilesname", "CustRatingTableType", "CustRankFilename", "CustRankFilesInfo", "CustRatedfileType", "CustRatingFilenameName", "CustRatingTableSet", "CustRatingFilename", "CustRatingFieldType", "CustRatingfileNames", "CustRatingFieldname", "CustRatingFileInfo", "CustRatedfileNames", "CustRatingFieldName", "CustRatingFilesInfo", "CustRatingFileNames", "CustRatedFileType", "CustRatingTablename", "CustRankFilesname", "CustRatingTableName", "CustRankFileType", "CustRatingfileSet", "CustRatingFilesName", "CustRatingFilenameNames", "CustRatingTableInfo", "CustRatingfileName"], "MovieIndexFileName": ["MovieIndexfileName", "MovieIndexFieldType", "MovieindexfileName", "MovieIndexfileNumber", "MovieIndexFileNumber", "MovieIndexFileKey", "MovieindexFileKey", "MovieIndexTableNames", "MovieindexfileType", "MovieIndexTableKey", "MovieindexfileNames", "MovieIndexFileType", "MovieIndexfileKey", "MovieindexfileKey", "MovieIndexFieldName", "MovieIndexFILEType", "MovieIndexfileType", "MovieIndexfileNames", "MovieindexFileType", "MovieindexfileNumber", "MovieIndexFILENumber", "MovieindexFileNumber", "MovieIndexFILEName", "MovieindexFileName", "MovieIndexFileNames", "MovieIndexTableType", "MovieIndexFieldKey", "MovieIndexTableName", "MovieindexFileNames", "MovieIndexFieldNames", "MovieIndexFILENames"], "inFile": ["infile", "INC", "inF", "localC", "localFile", "outfile", "localfile", "INFile", "inFILE", "outC", "INfile", " infile", "localFILE", " inF", "INF", "outF", " inFILE", "outFile", "INFILE"], "inC": ["inCS", "inF", "inL", " inG", "outG", "iC", "inputF", " outCL", "iR", "inputFile", " outF", "intCI", "iCS", " inCI", "outCL", "intCS", "inCL", "outC", "outL", "iCI", " outL", " inF", "intC", "inputC", "outF", "inCI", "intR", "inR", " outC", " inCL", "inG", "outFile", "inputG", " inR", " inL", " inCS"], "outFile1": ["outChannel9", "outputFile1", "outFILE6", "outFile6", "outPageOnce", "outFileOne", "outfile0", "outPage1", "outfile1", "outPage9", "outFILE1", "outFILE0", "outChannel1", " outfile1", "outputPageOne", "outChannelOne", " outfile6", "outputFileOne", "outFileOnce", "outFILE2", " outFile0", "outPageOne", "outFile0", "outputFile9", "outputPageOnce", "outfile2", "outputFileOnce", " outfile0", "outputPage1", " outfile2", "outFile9", "outChannelOnce", "outPage2", "outPage6", " outFile6", "outputPage9", "outfile6", "outPage0"], "outC1": ["inFile2", "outR2", "outCB3", "outFileOne", "outFile3", "outP3", "outCB0", "inC3", "inC0", "outc2", "outR3", "outC3", "outC0", "outROne", "outP2", "inCOne", "inC1", "outCB1", "inC2", "outP1", "outPOne", "outc3", "outc1", "outR1", "outCB2", "inFile1", "outc0", "outCOne", "inFileOne", "inFile3"], "outFile2": ["outFile02", "outTable3", "exChannel2", "outTable02", "outF1", "outFile3", "outfile0", "outfile1", "outChannel0", "outfile02", "outTable2", "outChannel1", "exChannel0", "outFileTwo", "outF2", " outFileTwo", "exChannel1", "outF3", "outFile0", "exChannel3", "outfile2", " outFile02", "exFile3", "outChannel2", "exFile1", "exFile2", "outChannel3", "exFile0", " outFile3", "outTableTwo", "outfile3", "outfileTwo", "outF0"], "outC2": ["outR2", "allB2", "outSTwo", "allC3", "OutC1", "outE1", "outMTwo", "outE2", "outR4", "outR3", "outC3", "outM22", "outM3", "outE4", "OutR3", "allB22", "OutC3", "OutC4", "outCTwo", "OutR2", "outS3", "outB2", "outE3", "allC2", "outBTwo", "OutC2", "outM2", "outS22", "OutR1", "outB22", "OutR4", "outS2", "outC4", "allCTwo", "allBTwo", "outR1", "outB3", "allB3", "outC22", "allC22"], "fileSize": [" fileCount", "FileSIZE", "fileSIZE", "byteSize", "baseName", "FileLength", "fileLength", "issueLength", " fileSIZE", " fileLength", "fileCount", "byteName", "FileCount", "FileSize", "issueName", " fileName", "FileName", "baseCount", "baseSIZE", "byteLength", "baseSize", "issueSize", "issueSIZE", "byteSIZE", "fileName"], "totalNoDataRows": ["totalNodataRoles", "totalNoDataSlows", "totalNodataRecoles", "totalNoDataBoles", "totalNoDataRecoles", "totalNodataRocks", "totalNoDataBows", "totalNoDataRoles", "totalNodataRues", "totalNoDataRues", "totalNoDataBocks", "totalNoDataSloles", "totalNoDataRecocks", "totalNoDataRocks", "totalNoDataSlocks", "totalNodataRecows", "totalNoDataRecows", "totalNodataRecocks", "totalNodataRows", "totalNoDataRecues", "totalNoDataBues", "totalNodataRecues", "totalNoDataSlues"], "mappedBuffer": ["mapperbuffer", "MappedData", "matchedBuffer", "mapedFB", "mapedCallback", "mmappedbuffer", "mappedCounter", " mappedBuff", " mapedBuff", "mapperBB", "matchedQueue", "MapperBuff", "mappingQueue", "mmappingBuffer", "mattedBB", "mappedQueue", " mappedCounter", " mappedCallback", "mapperCounter", " mapedFB", "MapperBB", "mmappingQueue", "mressedBuff", "mressedFB", "matchedCounter", "mapperBuff", "mappedbuffer", "mmappingBuff", "mattedBuffer", "mappingbuffer", "mappedFB", "mmappedBuffer", "MapedBuffer", " mapperBuff", "maphCallback", "MappedBuffer", "mapedBuffer", " mapperQueue", "maphBuff", "mapperQueue", " mapedCallback", "mappingBuffer", "mapperBuffer", "mapedBB", "MappedBuff", "mapBuff", "mappingData", "mappingBuff", "mapedbuffer", "mmappedBuff", "MappedBB", "mappedData", "mapedBuff", "mmappedQueue", "MapperBuffer", "mressedCallback", "mmappingbuffer", "mappedBB", "mapBuffer", "mappedBuff", "mappingBB", "MapedBB", "MapedBuff", "mressedBuffer", "mapedData", " mapperBuffer", "maphBuffer", "maphFB", "mapedQueue", "mattedData", " mapedBuffer", " mappedQueue", " mappedFB", " mapperCounter", "mapBB", "mappedCallback", "MapedData", "matchedBuff", "mattedBuff", "mappingCounter"], "startIndex": ["StartIndex", "firstPosition", "initPosition", "startInd", "currentPos", "endPage", "StartInd", "currentIndex", "firstInd", "StartIter", " startPage", " startPosition", "startPosition", " startIter", "firstindex", " startInd", "endIndex", "StartPosition", "initindex", "StartPoint", "StartPage", "Startindex", " startPos", "startPos", "initIndex", " startindex", "firstIndex", "currentPoint", " startPoint", "startIter", "StartPos", "currentPosition", "startPage", "startPoint", "startindex", "endIter", "endPosition"], "count": ["n", "cast", "batch", "code", "list", "continue", "ctr", "num", "more", "amount", "sum", "found", "call", "user", "index", "total", "process", "ind", "limit", "state", "status", "c", "name", "type", "core", "number", "act", "first", "force", "mount", "con", "Count", "info", "size", "counter", "check", "next", "add", "coll", "depth", "last", "category", "now", "start", "result", "max", "cloud", "created", "ount", "id", "find", "order", "conf", "page", "length", "i", "current"], "currentMovie": [" currentMusic", "activeMovie", "currentPlayer", "reportedMusic", "activePlayer", "reportedImage", "firstDate", "firstMovie", "firstMouse", "currentlyMovie", "reportedMouse", " currentMedia", "currentMouse", "currentImage", "currentMusic", "presentHero", "reportedHero", "firstMonster", "currentMonster", "firstVideo", "primaryHero", " currentHero", "currentlyHero", "primaryDate", "currentlyDate", "reportedMedia", "firstHero", " currentVideo", "currentSpider", "currentlySpider", "currentHero", "currentVideo", "presentMovie", "reportedMovie", "primaryVideo", "currentlyMonster", "firstMedia", "currentlyPlayer", " currentSpider", "primaryMovie", "currentDate", "currentMedia", " currentPlayer", " currentMonster", "presentImage", "activeVideo", "currentlyVideo", "presentMusic", " currentImage", " currentMouse", "activeSpider"], "movieName": ["MovieName", "movieGroup", " movieNAME", "MovieType", "ovieNAME", "oviename", "ovieGroup", "movieNAME", "mpegname", "mpegName", "filmType", "filmTitle", "filmName", "httpName", "monsterNAME", "ovieName", "Moviename", "httpNAME", " movieTitle", "mpegGroup", " movieType", "monstername", "movieTitle", "httpname", "moviename", "mpegNAME", "filmNAME", "movieType", "monsterName", "filmGroup", "MovieTitle", " moviename", "filmname"], "customer": ["customizer", "customorder", "stickity", "stickER", "Customity", "CustomER", "Customer", "ustomorder", "Customizer", "stickizer", "ustomer", "ustomER", "developer", " customER", " customorder", "customER", "customator", "developator", "sticker", "ustomator", "developity", " customator", "customity", "developizer", "developER", "developorder"], "rating": ["ping", "setting", "scale", "playing", "scoring", "reporting", "ating", "user", "reading", "term", "boarding", " Rating", "error", "ranking", "attribute", "type", "card", "strength", "core", "rate", "average", "rage", "rated", "rat", "weight", "review", "score", "saving", "format", "Rating", "heading", "testing", "option", "credit", "translation", "tag", "rank", "having"], "outBuf1": ["outDuf1", "outBuf18", "outBuc5", "outBBuff11", "outDbuf11", "outRuf1", "outBfx1", "outBuffy1", "outBuf3", "outRuf18", "outBool1", "outBufOnce", "outBbufl", "outBbuf5", "outBulp1", "outBuf5", "outBuff0", "outBbuf18", "outBdf3", "outBool3", "outBbuf3", "outRbuf1", "outDuf0", "outBbufone", "outBooll", "outBufOne", "outRufOne", "outBlf3", "outBBuff3", "outDuf3", "outBuffy0", "outBuffyl", "outRuf3", "outBlf1", "outBlf0", "outBfx3", "outBfx0", "outBlf2", "outBurg1", "outBuf11", "outBbuf0", "outBbufOne", "outBufl", "outBbufOnce", "outBdf1", "outBulp64", "outBfx11", "outBuff3", "outBbuf64", "outDuf11", "outBuf64", "outBdfOnce", "outBbuf11", "outBurg18", "outBuff2", "outBBuff0", "outBucOne", "outBuc1", "outRbuf18", "outBuffyone", "outBoolone", "outBulpOnce", "outRbuf3", "outRbuf0", "outBuff1", "outRbuf5", "outRuf0", "outBdf64", "outDbuf1", "outRbufOne", "outRuf5", "outBBuff1", "outBufone", "outDbuf0", "outBuf0", "outBuffy18", "outBurg3", "outBbuf1", "outDbuf3", "outBulp3", "outBuc0", "outBuffy3", "outBurg0"], "outBuf2": ["outBuffyTwo", "outFbuf02", "outBbuf42", "outMbuf1", "outBfgTwo", "outBfx1", "outBbuff1", "outMuf3", "outBbuf15", "outMbuf15", "outBuff4", "outBuf3", "outBbuff2", "outMuf15", "outBuff2", "outBuffy4", "outFuf4", "outBfx3", "outFuf2", "outBfg2", "outBuf4", "outMbuf3", "outMbuf2", "outFbuf2", "outFuf02", "outBfx2", "outBfg4", "outBbuf1", "outBuf42", "outBbuff4", "outFufTwo", "outBuf15", "outBuffy02", "outBbuff15", "outBufTwo", "outBbufj", "outBfx15", "outBbuff3", "outMuf1", "outBbuf4", "outFbufTwo", "outBuffTwo", "outBfg02", "outBuf02", "outBbuff42", "outBbuf3", "outBuffy3", "outBuffy2", "outBufj", "outBbuf02", "outBbuffj", "outBuffj", "outBbufTwo", "outFbuf4", "outBuff42", "outBuff1", "outMuf2", "outBbuf2", "outBuff3"], "endOfIndexFile": ["endOFindexLine", "endOfErrorF", "endofindexFiles", "endOfPositionTable", "EndFile", "endOfindexfile", "endofindexFile", "endofindexTable", "endOfPositionFiles", "endOfIndFile", "endOfErrorfile", "endOfIndfile", "endOfPositionfile", "endofindexfile", "endOfindexFiles", "endOfIndexFiles", "endFile", "endofIndexFile", "endOfindexF", "endofIndexFiles", "endOfIndLine", "endOFindexfile", "endofIndexTable", "endOfindexTable", "endOfErrorFiles", "endOfIndexTable", "endedFile", "endOFIndexLine", "endOfPositionFile", "endofIndexF", "endOfIndexLine", "endofindexF", "endOFindexFile", "endOFIndexfile", "endOFIndexFile", "endofIndexfile", "endOfindexFile", "endOfIndexF", " endFile", "endOfErrorFile", "endOfIndexfile", "endOfindexLine"]}}
{"id1": "255765", "id2": "8815137", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 1, "substitutes": {"f": ["d", "b", "v", "o", "m", "n", "fa", "l", "it", "fw", "h", "test", "q", "filename", "tf", "fab", "F", "base", "elf", "c", "name", "y", "fo", "fn", "cf", "rf", "fi", "form", "ft", "df", "fp", "ret", "fc", "j", "fed", "bf", "fm", "e", "dir", "info", "fac", "fb", "sf", "w", "file", "t", "fd", "fs", "exp", "lf", "def", "fr", "g", "r", "path", "fx", "fax", "p"], "in": ["inf", "o", "m", "n", "ac", "oin", "IN", "l", "inc", "it", "ex", " IN", "al", "thin", "inner", "cin", "h", "ins", "input", "mm", "re", "reader", "ind", "at", "lo", "rin", "bin", "im", "up", "In", "io", "is", "again", "by", "pi", "isin", "init", "con", "info", "iter", "ma", "er", "ai", "add", "t", "gin", "from", "local", "nin", "log", "make", "all", "en", "get", "inn", "r", "on", "ic", "din", " din"], "cbuf": ["abbfg", "cff", "CBf", "cbuffy", "abbuf", "rboff", "gbuff", "cbdf", "cbbf", "bcoff", "cbbuf", "bcdf", "sbuf", "rbbuf", "cduff", "gbuf", "CBbf", "cfbf", "cfuf", "cduf", "cbather", "cfuff", "sbather", "rbdf", "cduffy", "rbuffy", "CBuf", "cdoff", "rbather", "sbuff", "gbf", "rbfg", "abbbuf", "cdbuf", "cbfg", "sbbuf", "rbuf", "CBuff", "nbbuf", "bcbuf", "nbuff", "rbuff", "cboff", "bcather", "gbbf", "nbuf", "nbfg", "cbf", "abbdf", "bcfg", "bcuf", "CBbuf", "cbuff", "bcuff", "CBuffy"], "read": ["ed", "ip", "print", "it", "record", "data", "key", "q", "test", "reading", "fill", "hold", "io", "is", "pack", "ly", "end", "mix", "mem", "iter", "connect", "range", "reach", "get", "ok", "fail", "ink", "length", "current", "select", "dev", "report", "n", "parse", "raw", "link", " Read", "feed", "skip", "input", "index", "ext", "load", "open", "row", "rate", "est", "stream", "ke", "value", "handle", "allow", "depth", "start", "pre", "READ", "set", "ead", "find", "default", "run", "rank", "buffer", "reads", "shift", "x", "roll", "need", "give", "ignore", "Reader", "k", "play", "re", "reader", "ind", "slow", "core", "think", "clear", "send", "saw", "write", "trust", "check", "wait", "ai", "close", "r", "bind", "ready", "miss", "chain", "pe", "seek", "error", "burst", "scan", "ret", "count", "old", "sync", "add", "ank", "se", "log", "query", "hello", "view", "poll", "Read", "height", "text", "orig", "readable"], "totRead": ["tiatBreak", " toteFind", "tOTWrite", "tobyCheck", "tottedWrit", "tootVal", "totaFill", "tootRead", "ltotaLoad", "retotPrint", "ttotAdd", "totaHave", "tcotDisplay", "totSend", "notLoad", "tottPrint", "tOTFind", "toticRead", "atotaFill", "tottFind", "toiotVal", "trotRead", "trotSee", "tootSend", "notalPrint", "ltotaRead", "tcotCheck", "totedHave", "ptOTRead", "totalPrint", " totRun", "toteNeed", "totConnect", "notNeed", "notaRead", "notPrint", " totFind", "totNeed", "tacotConnect", "ptotFind", "notalWrite", "tottRun", "toteFill", "tokFind", "tobyLoad", "tootCheck", "ptotLoad", "tokWrite", "totFind", "totRun", "notCheck", "tcotRead", "toteLoad", "totaLength", "totalCheck", "toteRun", "totSee", "letrotRead", "totaConnect", "toteRead", "tobyRead", "totPrint", "totedFill", "totalLoad", "tiotWrit", "totalSee", "tcotVal", "totaCheck", "totaRead", "totaWrite", "totFill", "tootBreak", "ltotBuild", "toiotBreak", " totBuild", "ttotNeed", "tOTLoad", "letotRead", "ltotFill", "totWrit", "totAdd", " totalRead", "totalNeed", "totDisplay", "ttottRead", "atotRead", "tiatRead", "toteFind", "totaPrint", "tottedReader", "tOTNeed", "ptOTFind", "totBreak", "tokLoad", "toteBuild", "notalCheck", "tiatVal", "tiotBreak", "atotaPrint", "ptOTLoad", "tfatLoad", "retottReader", "totalWrite", "tfatRead", " toteRead", "tiotSend", "ptotRead", "tottNeed", "trotWrite", " totalLength", "toteReader", "totalRead", "totaSee", "totVal", "toteAdd", "tottedPrint", "retotReader", "tacotDisplay", "tottWrit", "ptOTWrite", "totReader", "notalLoad", "totaNeed", "tottWrite", "totLoad", "toteWrite", "ttotRead", "tootConnect", "tacotCheck", "tiotRead", "taotCheck", "taotRead", "letrotWrite", "toticWrite", "retotRead", "retotWrit", "taotConnect", "toteLength", "totaBuild", "toiotRead", "totedRead", "tottRead", "tOTRead", "ltotaBuild", "retottWrit", "letotSee", "tfatWrite", "ltotaFill", "tottedRead", "totHave", "totalLength", "totaLoad", "toticFind", "retottRead", "tcotSend", "totWrite", " totLength", "tacotRead", "notReader", "tiotPrint", "atotHave", "totBuild", "tobyWrite", "notalRead", "trotFind", "totCheck", "taotDisplay", "tiotReader", "tiatBuild", "tiotFill", "notaWrite", "atotPrint", "tcotBreak", "ltotLoad", "notaLoad", "tootDisplay", "ttotWrite", " totWrite", "tfatReader", "retottPrint", "atotaRead", "atotaHave", "totalBuild", "ttottAdd", "tcotConnect", "letotWrite", "notalNeed", "ltotRead", "totalFind", " totalBuild", "tobyNeed", "notaReader", "tiatLoad", "tiatSend", "ptotWrite", "totaDisplay", "letotFind", "tottReader", "atotFill", "totaAdd", "letrotFind", " toteWrite", "toiotSend", "tottAdd", "ttottWrite", "letrotSee", "tiotHave", "tiotVal", "tokRead", "toticRun", "tobyPrint", " toteRun", "totLength", "totedPrint", " totalWrite", "notRead", "totaReader", "tiatFill", "ttottNeed", "totaFind", "notWrite"], "out": ["o", "b", "to", "n", "v", "ex", "oss", "obj", "res", "OUT", "at", "c", "os", "up", "Out", "io", "ou", "writer", "aos", "end", "sys", "we", "conv", "ch", "co", "write", "con", "w", "t", "s", "log", "auto", "g", "OU", "output", "outs", "r", "net", "or"], "i": ["m", "b", "ip", "print", "it", "ei", "q", "c", "y", "ini", "io", "is", "client", "bi", "ity", "pi", "me", "init", "t", "integer", "mi", "ix", "you", "hi", "o", "v", "to", "index", "dr", "im", "oi", "ki", "ii", "any", "j", "set", "id", "ic", "I", "x", "xi", "p", "uri", " I", "PI", "ci", "ui", "l", "mm", "ind", "\u0438", "iq", "iu", "php", "um", "info", "ai", "ico", "sim", "s", "ice", "iii", "di", "iy", "r", "si", "ie", "zi", "ij", "multi", "gi", "ami", "chain", "phi", "us", "status", "li", "ski", "e", "cli", "ri", "ion", "ia", "point", "g", "ims", "this", "my", "ti", "ji", "qi"]}}
{"id1": "20924119", "id2": "4118412", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"gzip": ["GZip", "mZip", "marchive", "Gzip", "Garchive", " gZip", "garchive", "Gdef", " garchive", " gdef", "mdef", "mzip", "gdef", "gZip"], "zipout": ["pipein", "pipenet", "gzOut", "zipconn", "gzop", "gzconn", " zipnet", " zipop", "lockconn", "zin", " zipo", "pipeout", "login", "zOut", "gzin", "gzo", "logout", "zipo", "zouts", "zipin", "zipop", "gzout", "zout", " zipin", " zipconn", "zipOut", "locko", "logouts", " zipou", "zipou", "lockop", "znet", "pipeou", "zou", "lockout", "zipnet", "zipouts", "gzouts", "logOut"], "buffer": ["batch", "code", "cache", "Buffer", "command", "header", "data", "memory", "paste", "window", "string", "database", "seed", "limit", "table", "sequence", "document", "button", "attribute", "password", "char", "pad", "buf", "number", "row", "queue", "device", "mem", "phrase", "append", "buff", "sample", "comment", "bytes", "stack", "block", "size", "word", "stream", "result", "variable", "binary", "message", "history", "frame", "line"], "dir": ["d", "rect", "pos", "md", "cd", "pkg", "dat", "direct", "rel", "root", "doc", "desc", "dist", "folder", " directory", "directory", "DIR", "dr", "ind", "self", "det", "ir", "cond", "req", "loc", "dd", "fin", "df", "wd", "dl", "vol", "parent", " Dir", "dra", "div", "draw", "ory", "iter", "cur", " director", "add", "file", "mk", "fd", "del", "part", "def", "db", "tmp", "path", "ord", "out", "Dir", "tree"], "in": ["inf", "oin", "IN", "inc", "ex", "it", "al", "inner", "cin", "ins", "el", "input", "reader", "ind", "rin", "bin", "im", "up", "inside", "In", "is", "ini", "form", "act", "isin", "init", "and", "iter", "win", "ri", "check", "gin", "from", "read", "en", "ain", "inn", "sin", "on", "like", "ic", "out", "din", "i", "source"], "length": ["capacity", "time", "l", "ength", "duration", "data", "angle", "full", "body", "index", "total", "padding", "database", "ind", "available", "distance", "volume", "load", "shape", "sequence", "type", "char", "end", "frequency", "number", "row", "SIZE", "join", "count", "character", "Length", "position", "size", "port", "ENGTH", "impl", "start", "needed", "read", "tail", "match", "hello", "component", "message", "history", "before", "family", "height", "text", "len"]}}
{"id1": "3330944", "id2": "5998352", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 1, "substitutes": {"extractImage": ["ExtprocessImage", "ExtractImages", "ExtprocessImages", "extprocessImages", "extlateFrame", "extractorFrame", "ExtractFrame", "extlateImage", "extlateImages", "Extractimage", "extlateimage", "extractimage", "extractorImage", "ExtprocessFrame", "Extprocessimage", "extractorimage", "extprocessimage", "extprocessFrame", "extprocessImage", "extractFrame", "extractorImages", "extractImages", "ExtractImage"], "input": ["ip", "partial", "raw", "null", "hidden", "it", "background", "xml", "address", "data", "q", "ins", "buffer", "index", "string", "audio", "uri", "seed", "image", "base", "accept", "Input", "prefix", "error", "str", "img", "rc", "qa", "context", "sample", "init", "upload", "txt", "request", "origin", "check", "url", "format", "file", "from", "local", "internal", "pattern", "start", "config", "query", "current", "initial", "hello", "empty", "tmp", "this", "path", "before", "out", "i", "text", "select", "p", "source"], "output": ["o", "generated", "to", "print", "hidden", "filename", "target", "OUT", "response", "image", "name", "prefix", "oe", "type", "icon", "write", "put", "port", "format", "file", "result", "success", "Output", "STDOUT", "OU", "path", "temp", "display", "out", "PUT", "pretty", "current", "source"], "params": ["m", "types", "images", "prop", "settings", "tags", "pkg", "members", "requires", "pins", "tools", "parts", "keys", "points", "proc", "ctx", "phi", "users", "options", "mm", "las", "devices", "param", "rs", "parents", "pro", "jp", "caps", "details", "fps", "properties", "ams", "photos", "json", "actions", "eps", "Parameters", "AMS", "Par", "phys", "pi", "ars", "par", "pas", "results", "names", "changes", "s", "packages", "modules", "config", "eters", "arms", "chains", "styles", "spec", "docs", "conf", "stats", "ims", "pps", "ps", "abilities", "ports", "pretty", "marks", "units", "gs", "terms", " parameters", "p"], "w": ["d", "m", "kw", "v", "n", "o", "rw", "ws", "h", "wp", "q", "wr", "wx", "window", "ew", "wo", "Writer", "wt", "writer", "nw", "f", "we", "wa", "wd", "write", "e", "wal", "word", "wl", "wb", "hw", "wh", "sw", "W", "Ws", "out", "p"], "in": ["inf", "raw", "null", "IN", "it", " IN", "al", "inner", "cin", "ins", "mm", "p", "vin", "one", "rin", "bin", "base", "name", "In", "ini", "is", "Input", "f", "ar", "sql", "isin", "phys", "e", "init", "con", "old", "copy", "ln", "mc", "ma", "win", "info", "edIn", "nin", "file", "gin", "from", "local", "include", "mi", "read", "id", "all", "en", "conf", "inn", "sin", "po", "path", "out", "din", "i", " din", "source"], "dest": ["to", "rest", "way", "comb", "csv", "prop", "cat", "ws", " dst", "dat", "data", "resp", "deg", "target", "desc", "tif", "dist", "des", "shape", "loc", "decl", "Dest", "oe", "end", "nom", "buf", "cont", "trans", "img", "usr", "mem", "src", "write", "save", "dir", "st", "alt", "pipe", "origin", "pas", "port", "opt", "result", "wb", "lit", "tmp", "path", "temp", "display", "out", " destination", "txt", "orig", "p", "source"], "bi": ["pb", "yi", "b", "isi", "bh", "bis", "gi", "bas", "rob", "bank", " nib", "iri", "phi", "ibe", "hog", "vi", "mu", "ble", "ali", "bin", "bone", "oi", "ki", "phy", "ini", "li", "bp", "fi", "obi", "bo", "pi", "ba", "beck", "bf", "BI", "abi", "buff", "bg", "bits", "ib", "bil", "be", "ai", "mi", "ni", "bie", "bra", "bb", "bc", "ibi", "umi", "obo", "bm", "Bi", "di", "jiang", "nb", "bs", "i", "ji", "qi", "zi"], "os": ["o", "css", "ks", "ose", "pos", "oid", "oss", "ops", "los", "oos", "cos", "us", "oses", "obs", "is", "io", "aos", "Os", "ows", "or", "sys", "mot", "ot", "OS", "ios", "ols", "cs", "ow", "ys", "acs", "s", "bos", "osi", "ts", "es", "fs", "oo", "ns", "bs", "oes", "ons", "ds", "et", "ls", "ox", "mos", "ros"]}}
{"id1": "20623709", "id2": "8778962", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"split": ["scale", "parse", "disk", "batch", "use", "process", "transfer", "seek", "open", "align", "scan", "count", "unit", "write", "append", "upload", "sync", "copy", "format", "map", "read", "part", "Split", "lock", "slice", "share", "join"], "targetDirectory": ["TargetDirect", "localdirectory", "TargetDirectory", "baseFile", "targetDir", " targetFolder", "localFile", "localDirectory", "baseDir", "basedirectory", "testDirectory", " targetDir", "TargetFolder", "baseFolder", "targetDirect", " targetMemory", "targetLocation", " targetFile", "targetFile", "Targetdirectory", " targetdirectory", "testLocation", "targetdirectory", "targetMemory", "baseDirectory", "targetFolder", "TargetLocation", "testDir", "TargetDir", "localDir", "testDirect", " targetDirect", "baseDirect", "baseMemory", " targetLocation", "TargetMemory"], "prefix": ["zero", "command", "pkg", "key", "filename", "root", "uri", "index", " suffix", "directory", "padding", "username", "status", "base", "template", "name", "fix", "type", "password", "division", "localhost", "alias", "PRE", "fixes", "pi", "FIX", "title", "version", "size", "format", "pres", "pattern", "pre", "ix", "Pref", "fixed", "this", "tag", "path", "p"], "maxUnitBases": ["maxUnitBages", "maxUnitbounds", "maxUnitReplages", "maxUnitChicas", "maxUnitChounds", "maxUnityLases", "maxUnitBades", "maxUnitChias", "maxUnitChases", "maxUnitReplicas", "maxUnitChades", "maxUnityLounds", "maxUnityBicas", "maxUnityBages", "maxUnityBias", "maxUnitReplases", "maxUnitAliounds", "maxUnitReplounds", "maxUnitbades", "maxUnityAliases", "maxUnitLages", "maxUnityAliounds", "maxUnitLases", "maxUnitBounds", "maxUnityLages", "maxUnityBases", "maxUnityBounds", "maxUnitLicas", "maxUnityAliades", "maxUnitAliades", "maxUnityLicas", "maxUnitBicas", "maxUnitbias", "maxUnitbases", "maxUnitAliases", "maxUnityBades", "maxUnitChages", "maxUnityAliias", "maxUnitBias", "maxUnitLounds", "maxUnitAliias"], "maxUnitEntries": ["maxunitEntries", "maxUnitentrs", "maxunitEntires", "maxUnitErrys", "maxUnitentires", "maxUnityentries", "maxUnityEntires", "maxUnitEntrys", "maxUnitErrs", "maxUnitentries", "maxUnitEntryires", "maxUnitIntegires", "maxUnitEntriers", "maxUnitErires", "maxUnitEntryries", "maxUnitEntryrys", "maxUnitEntryriers", "maxUnitIntegrys", "maxUnitEntrs", "maxUnityEntrs", "maxunitEntrys", "maxUnitIntegries", "maxUnitentrys", "maxUnityEntrys", "maxunitEntrs", "maxUnitIntegriers", "maxUnitErries", "maxUnityentrys", "maxUnityentrs", "maxUnityentires", "maxUnityEntries", "maxUnitEntires"], "fis": ["fic", "Fic", "fiss", "Fii", "vi", "vis", "fi", " fiss", " fic", "viss", "ifis", "Fiss", "ific", "Fci", "Fis", "ifii", "fii", "ifci", " fi", " fii", "vic", "Fi"], "fci": [" fai", "Fini", "fic", "Fic", "Fco", "fico", "fini", "cfic", "cfis", "tcu", " fcu", " fic", "tci", "cfco", " fico", "mcu", "mii", "Fci", "Fis", "tco", " fini", "Fai", "fcu", "tii", "cfini", "fii", " fii", "cfci", "cfai", "mco", "fai", "cfico", "Fico", "mci"], "fos": ["wbos", "yos", "yaos", "flOS", " fbos", "flaos", "fOS", "Foss", " faos", "ybos", " fios", "floss", "fios", "Fos", "wos", " foss", "foss", "FOS", "fbos", "flos", " fOS", "waos", "Faos", "yios", "wios", "faos"], "fco": ["fcon", "ccon", "cdo", "Fcos", "Fco", "pco", "cso", "tcos", "toco", "Fcon", "fso", "Fdo", " fcon", "tdo", "Foco", "fcos", " foco", "fdo", "foco", "Fci", "tco", " fso", "pci", " fdo", "Fso", " fcos", "pcos", "cco", "pso"], "buffer": ["entry", "batch", "cache", "print", "Buffer", "command", "record", "data", "black", "function", "address", "filter", "reset", "memory", "flush", "index", "window", "padding", "database", "holder", "limit", "timeout", "template", "button", "document", "table", "sequence", "char", "callback", "queue", "buf", "row", "phrase", "note", "sample", "buff", "pause", "comment", "append", "stack", "iter", "block", "position", "complete", "library", "result", "read", "match", "binary", "order", "event", "message", "temp", "channel", "length", "bridge", "source"], "currentBasesCount": ["currentbaseCode", "currentBaseCode", "currentbasesCode", "currentBasesLength", "currentbaseCount", "currentBadesCode", "currentbasesLength", "currentBadesCount", "currentBasesCode", "currentBasedCode", "currentBasedCount", "currentbasesCount", "currentBaseCount", "currentBaseLength", "currentBasedLength", "currentBadesLength", "currentbaseLength"], "currentEntriesCount": ["currentEntriesFlag", "currentEntiesCount", "currentEntrsCode", "currentEntiesCode", "currentEntrysFlag", "currentEntrysCount", "currentEntrysCode", "currentEntiesFlag", "currentEntriesCode", "currentEntrsFlag", "currentEntrsCount"], "targetCount": ["targetAmount", "targetNum", "TargetInfo", " targetAmount", "argetCount", "argetAmount", "TargetAmount", " targetInfo", "TargetNum", "argetNum", "argetInfo", "TargetCount", "targetInfo", " targetNum"], "fastaChannel": ["fastoStream", " fastaQueue", " fastoStream", " fastoChan", "fastoChannel", "fastoProvider", "fastaConnection", "fastoChan", "fastaStream", " fastaStream", "fastaiStream", "fastaiChannel", "fastoConnection", "fastpaConnection", " fastaProvider", "fastityChannel", "fastaButton", " fastoChannel", "fastityStream", "fastpaButton", "fastaiQueue", "fastaProvider", " fastaButton", "fastityQueue", "fastaChan", " fastaConnection", "fastpaChannel", "fastoQueue", "fastpaProvider", "fastaQueue", "fastityChan", "fastaiChan", "fastoButton", " fastoQueue", " fastaChan"], "totalSeqCount": ["totalSeqsCount", "totalSegSize", "totalSeqSize", "totalSegCount", "totalSeQCount", "totalSeQCode", "totalSeQSize", "totalSeqCode", "totalSegCode", "totalSeqsSize", "totalSegCounter", "totalSeqCounter", "totalSeQCounter", "totalSeqsCounter", "totalSeqsCode"], "totalResiduesCount": ["totalResidueCount", "totalResIdueCode", "totalResidueFlag", "totalResiduationsFlag", "totalResIduesCode", "totalResidusCount", "totalResIdueCount", "totalResiduesFlag", "totalResiduationsCode", "totalResIduesFlag", "totalResiduesCode", "totalResidusFlag", "totalResIdueFlag", "totalResiduationsCount", "totalResidusCode", "totalResidueCode", "totalResIduesCount"], "prevTime": [" prevT", "prevT", " prevThread", "parTime", "prevThread", " previousTime", "parThread", " previousT", " previousThread", "parT"], "fastaFileSize": ["fastAFileHeight", "fastAFileSize", "fastafileSIZE", "fastoFileSize", "fastaChainLength", "fastoFileOwner", "fastaTableLength", "fastaFilesSize", "fastoTableSIZE", "fastoTableSize", "fastaReaderSize", "fastoFileLength", "fastATableName", "fastaFileName", "fastaFilesHeight", "fastafileLength", "fastaFileLength", "fastaFileSIZE", "fastATableSize", "fastATableHeight", "fastaTableSize", "fastaTableHeight", "fastaTableOwner", "fastaChainSize", "fastaFilesName", "fastaFileHeight", "fastATableLength", "fastafileOwner", "fastoTableLength", "fastaReaderLength", "fastAFileLength", "fastaReaderHeight", "fastaTableName", "fastaFileOwner", "fastaChainSIZE", "fastoFileSIZE", "fastafileSize", "fastaTableSIZE", "fastaReaderName", "fastaFilesLength", "fastAFileName", "fastaChainOwner", "fastoTableOwner"], "fastaFileReadOffset": ["fastaChainCurrentLocation", "fastaFileWriteOffset", "fastaFileViewPos", "fastaFileLoadLength", "fastaFileReadPosition", "fastaFileReadLength", "fastaFileLoadOrder", "fastaFileInputAmount", "fastaFileInputPosition", "fastaPageReadOffset", "fastaChainCurrentoffset", "fastaFileReaderLocation", "fastaFileInputLocation", "fastaFileInputOrder", "fastaFilereadOrder", "fastaFileWriteAmount", "fastaChainReadPosition", "fastaFileViewOffset", "fastaFileReadoffset", "fastaFileInputoffset", "fastaChainReadoffset", "fastaFileReaderOffset", "fastaFilereadOffset", "fastaPageLoadOrder", "fastaFileInputOffset", "fastaFilesLoadLength", "fastaFileLoadAmount", "fastaPageLoadPos", "fastaFilereadPos", "fastaFilereadAmount", "fastaFileCurrentoffset", "fastaFileReadOrder", "fastaFileReaderoffset", "fastaPageReadOrder", "fastaFileReaderPosition", "fastaChainReadLocation", "fastaFileLoadOffset", "fastaPageReadAmount", "fastaFileCurrentLocation", "fastaFileCurrentPosition", "fastaFileViewAmount", "fastaFileInputLength", "fastaPageReadPos", "fastaFileViewOrder", "fastaFileWriteOrder", "fastaFilesLoadOffset", "fastaFileLoadPos", "fastaFilesReadOrder", "fastaFileCurrentOffset", "fastaPageLoadAmount", "fastaFileReadPos", "fastaFileReadLocation", "fastaFilesReadAmount", "fastaFilesLoadAmount", "fastaFilesLoadOrder", "fastaFileReadAmount", "fastaChainCurrentOffset", "fastaFileWriteLength", "fastaFilesReadOffset", "fastaChainReadOffset", "fastaChainCurrentPosition", "fastaFilesReadLength", "fastaPageLoadOffset"], "partitionStartOffset": ["partitonStartingPosition", "partitionStartingPoint", "partitionStartingOff", "partitionDataPosition", "partitonStartOffset", "partitonStartingOff", "partitionStartingOffset", "partitionStartPosition", "partitionStartingPosition", "partitionDataOffset", "partitonStartingPoint", "partitionEndPosition", "partitionEndPoint", "partitionStartPoint", "partitionDataOff", "partitonStartPoint", "partitonStartOff", "partitionEndOff", "partitionDataPoint", "partitonStartPosition", "partitonStartingOffset", "partitionStartOff"], "bufferSize": ["BufferName", "buffLength", "buffName", "bufferSIZE", "bufSize", "bufferCode", "sequenceSize", "BufferSIZE", "BufferLength", "buffSize", "BufferSize", " bufferCode", "bufSIZE", "bufLength", "tableSize", "bufferName", "sequenceCode", "bufCode", "tableName", "tableSIZE", " bufferLength", "tableLength", "sequenceSIZE", " bufferSIZE", "buffSIZE", "bufferLength", "sequenceLength"], "fastaBuffer": ["fastuMemory", "fastaDB", "FastmaBuff", "fastmaCache", "fastmaBuilder", "fastoCounter", "fastaBuilder", " fastoBuffer", "fastalQueue", "fastsaChannel", "wildaBuff", "fastcaBuffer", "fastanCache", "fastanRequest", "fastoBuffer", "wildanBuff", "fastasCounter", "fasteBuffer", " fastaBuilder", "fastsaBuffer", "fastcaRequest", "fastmaBuff", " fastaCache", "FastmaStore", "fastsaBuff", "fastasBuff", "fastasCache", "fastoRequest", "fastoBuff", "fastuDB", "fastasBuilder", "fastalCounter", "FastaBuffer", "FastmaBuffer", "fasteMemory", "fastanBuffer", "wildaCache", "fastuBuff", "wildaBuffer", " fastoQueue", "fastcaCache", "fastmaQueue", "fastaBuff", "fastanBuff", " fastoBuff", "FastaBuff", "fastasBuffer", "FastaRequest", "fastcaBuff", "fastaCache", " fastaBuff", "fastaRequest", "FastaStore", "fastasRequest", "fastalBuffer", "wildanBuffer", "wildanRequest", "fastmaBuffer", "FastmaRequest", " fastaDB", " fastaCounter", "fastuBuffer", "wildaRequest", "fastmaStore", " fastoCounter", " fastaQueue", "fasteBuff", "fastsaQueue", "fasteDB", "fastaStore", "fastmaRequest", "fastoStore", " fastaMemory", "fastasStore", "fastasQueue", "fastaCounter", "fastoQueue", "fastmaChannel", "fastaQueue", "fastalBuff", "wildanCache", "fastaMemory"], "fastaReadState": ["fastaReaderState", "fastaCurrentType", "fastoReaderSTATE", "fastoReaderStatus", "fastoReadState", "fastoReaderType", "fastaLoadStatus", "fastoReadStatus", "fastaLoadType", "fastaReaderStatus", "fastaReaderType", "fastoReadSTATE", "fastaCurrentState", "fastaReaderSTATE", "fastoReaderState", "fastaLoadSTATE", "fastaCurrentStatus", "fastaReadSTATE", "fastaReadType", "fastaCurrentSTATE", "fastaReadStatus", "fastaLoadState", "fastoReadType"], "nBytes": ["nsWords", "nsParts", " nItems", " nbytes", " nBlocks", " nNs", "numBlocks", "numNs", "NParts", "noBytes", " nWords", "noBlocks", "nItems", "nBlocks", "noNs", "nrBytes", "nbytes", "nobytes", "nrbytes", "Nbytes", "nParts", "nNs", "NKeys", "nsbytes", "nsBytes", "nKeys", "NItems", "numBytes", "nrKeys", "NBytes", "NWords", "numbytes", "nrItems", "nWords", " nParts", " nKeys"]}}
{"id1": "8093133", "id2": "14733078", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXmlAsWeb", "loadXmlAsUrl", "loadXmlFormUrl", "loadXmlAsURL", "loadXMLFormURL", "loadXmlFormFile", "loadXmlAsFile", "loadXMLFromFile", "loadXmlFromWeb", "loadXmlFormURL", "loadXmlWithFile", "loadXmlWithUrl", "loadXmlFormWeb", "loadXMLFormWeb", "loadXmlWithWeb", "loadXmlFromFile", "loadXMLFormFile", "loadXmlWithURL", "loadXMLFromUrl", "loadXMLFormUrl", "loadXMLFromWeb", "loadXMLFromURL", "loadXmlFromURL"], "url": ["http", "b", "n", "link", "web", "l", "in", "ll", "html", "xml", "address", "user", "input", "res", "location", "base", "name", "loc", "document", "open", "char", "str", "abs", "ssl", "u", "build", "ur", "nl", "domain", "bel", "request", "URL", "file", "log", "Url", "job", "sl", "id", "get", "host", "path", "page", "uri"], "timeout": ["to", "capacity", "time", "resolution", "mode", "policy", "duration", "it", "network", "amount", "server", "window", "until", "directory", "term", "seconds", "limit", "monitor", "total", "period", "padding", "sleep", "io", "type", "latest", "password", "Timeout", "client", "frequency", "number", "unit", "version", "size", "wait", "t", "max", "course", "blocking", "exclusive", "OUT", "out", "length", "buffer", "height", "delay"], "xmlType": ["mlUnit", "imageBlock", "complextype", " xmlStyle", "xmlBlock", "fileBlock", " xmltype", "complexUnit", "xmltype", " xmlUnit", "fileStyle", "xmlStyle", " xmlTyp", " xmlBlock", "xmlUnit", " xmlTypes", "fileType", "mlTyp", "fileTypes", "imageStyle", "xmlTypes", "complexTyp", "mltype", "mlType", "imageTypes", "xmlTyp", "complexType", "imageType"], "connection": ["entry", "to", "link", "conn", "command", "condition", "socket", "pointer", "generation", "network", "usage", "session", "computer", "city", "user", "statement", "connected", "system", "database", "directory", "response", "Connection", "c", "builder", "still", "open", "description", "io", "client", "number", "cone", "subject", "nc", "application", "con", "position", "established", "internet", "manager", "connect", "ion", "resource", "creation", "config", "creator", "close", "opening", "relation", "reference", "channel", "communication", "character", "current", "uri"], "buffInputStream": ["BuffOutputStream", "BuffInputForm", "BuffOutputForm", "BuffOutputSteam", "buffIOField", "buffOutputForm", "BuffInputChannel", "buffEntityStream", "buffEntityChannel", "buffOutputSteam", "buffEarForm", "BuffInputStream", "buffOutputStream", "buffIOForm", "buffInputChannel", "buffEarField", "buffEarSteam", "BuffInputField", "buffOutputField", "buffEntityForm", "buffOutputChannel", "buffInputForm", "BuffInputSteam", "buffEarStream", "BuffOutputField", "buffInputSteam", "buffIOStream", "buffInputField", "buffIOSteam", "BuffOutputChannel"]}}
{"id1": "13152325", "id2": "13063241", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"loadExistingAntlibs": ["loadExistingAntlibFiles", "loadExistingantlibFiles", "loadExistingantLibd", "loadExistingAntibz", "loadExistingAntibs", "loadExistingantlibd", "loadExistingAntLibFiles", "loadExistingAntLibz", "loadExistingAntribFiles", "loadExistingantLibFiles", "loadExistingantLibz", "loadExistingantLibs", "loadExistingAntribs", "loadExistingantlibz", "loadExistingAntribd", "loadExistingAntLibs", "loadExistingAntlibd", "loadExistingAntibFiles", "loadExistingAntLibd", "loadExistingAntribz", "loadExistingantlibs", "loadExistingAntibd", "loadExistingAntlibz"], "classLoader": [" ClassReader", "classReader", " classReader", "ClassPath", " classLoad", " ClassLoader", " classloader", " classPath", "ClassReader", " ClassPath", " Classloader", "classloader", "ClassLoad", "classLoad", "ClassLoader", "classPath", " ClassLoad", "Classloader"], "antlibUrl": ["antsLibStr", "antlibraryRel", "antsLibUr", "antslibUrl", "antdburl", "antLibURL", "AntlibURL", "AntLibURL", "antlabUrl", "AntlibUr", "antLibRel", "antdbURL", "antLibUr", "antsLibUrl", "antribUrl", "antlibraryStr", "Antliburl", "AntLibUrl", "antslibUr", "antlaburl", "antdbUrl", "antlabStr", "antsLibURL", "antlibStr", "antLibStr", "antappUrl", "antsLibRel", "antslibRel", "antsLiburl", "antribURL", "antlibraryUrl", "antlibraryurl", "antlibraryURL", "antlibraryUr", "antappURL", "AntLiburl", "antriburl", "antappRel", "antappUr", "antslibStr", "antslibURL", "antlabUr", "antlibRel", "antsliburl", "antlibUr", "antLiburl", "antlibURL", "antribUr", "AntlibUrl", "AntLibUr", "antliburl", "antLibUrl", "antdbUr"], "antlibUri": ["antlibIris", "antlibUtri", "antLibIURI", "antlibGeris", "antlibIr", "antlibUtpi", "antlibEUris", "antlibIri", "antlibraryUsmi", "antLibUis", "antlibraryUne", "antlibUsris", "antlibUis", "antLibUtpi", "antlibEis", "antlibOr", "antlibUrid", "antlibraryUsris", "antlibUURI", "antlibUpi", "antlibUr", "antlibOne", "antlibIRI", "antlibIne", "antLibUrid", "antlibGeri", "antlibEURI", "antlibraryUris", "antlibURRI", "antlibUtrid", "antlibIpi", "antlibraryUsr", "antlibUtmi", "antLibIrid", "antlibraryURI", "antlibraryUmi", "antlibUsis", "antlibraryUsne", "antlibUsr", "antlibIrid", "antLibUtris", "antlibraryUsri", "antLibURI", "antlibUne", "antlibURmi", "antlibOri", "antlibUsURI", "antlibUsmi", "antLibUpi", "antlibEUpi", "antLibUris", "antlibEri", "antlibEris", "antlibraryUr", "antlibraryUri", "antlibIis", "antLibUtri", "antlibEUri", "antlibURI", "antlibURri", "antLibUURI", "antlibUtRI", "antLibIis", "antlibGerid", "antlibUsRI", "antLibIris", "antlibGeRI", "antlibUsne", "antlibOris", "antLibUri", "antlibUris", "antLibIRI", "antlibURris", "antlibIURI", "antLibIri", "antlibUtris", "antlibUmi", "antlibUsri", "antlibraryUsRI"], "resources": ["reports", "ries", "objects", "types", "images", "dates", "classes", "services", "keys", "users", "roots", "res", "seconds", "rs", "links", "parents", "ples", "issues", "actions", "files", "headers", "bytes", "stores", "writers", "ues", "works", "names", "books", "events", "iers", "relations", "packages", "checks", "modules", "groups", "workers", "models", "these", "ions", "years", "states", "builders", "archives", "values", "pages", "maps", "Resources", "ports"], "url": ["browser", "http", "entry", "link", "web", "l", "ll", "source", "rl", "xml", "address", "key", "server", "rel", "el", "date", "string", "location", "lb", "base", "name", "loc", "li", "char", "f", "str", "abs", "ssl", "dl", "ref", "ur", "nl", "bel", "mount", "request", "URL", "add", "resource", "gl", "file", "service", "format", "Url", "sl", "github", "get", "host", "r", "lr", "addr", "path", "util", "remote", "ls"], "stream": ["feed", "socket", "data", "inner", "body", "user", "input", "store", "window", "system", "response", "io", "open", "standard", "client", "row", "context", "sample", "stack", "pipe", "out", "iterator", "file", "resource", "loader", "read", "sl", "sw", "progress", "console", "content", "view", "zip", "Stream", "path", "message", "history", "channel", "buffer", "ream", "source"], "reader": ["entry", "socket", "rl", "inner", "server", "Reader", "ro", "ner", "reading", "parser", "rar", "via", "volume", "input", "older", "upper", "rx", "handler", "writer", "rer", "dd", "client", "collection", "layer", "row", "review", "runner", "liner", "sample", "iter", "roller", "er", "ri", "reviewed", "iterator", "resource", "rr", "driver", "range", "loader", "file", "read", "READ", "query", "console", "per", "r", "length", "buffer", "reads", "instance", "readable"], "line": ["entry", "n", "link", "print", "pos", "l", "lin", "eline", "header", "body", "pe", "label", "string", "lines", "lo", "msg", "li", "len", "str", "inline", "row", "Line", "ine", "cell", "text", "stay", "sql", "nl", "sample", "ls", "liner", "comment", "column", "ln", "block", "iter", "word", "port", "next", "le", "LINE", "file", "handle", "profile", "range", "log", "lf", "sl", "point", "message", "page", "buffer", "frame", "online"], "pkg": ["entry", "jar", "ip", "pt", "ppa", "pg", "cp", "lang", "key", "perm", "pid", "ctx", "root", "fx", "req", "plugin", "msg", "gp", "name", "mod", "kg", "rpm", "prefix", "deb", "Package", "pack", "password", "pod", "col", "alias", "var", "dl", "wd", "pair", "init", "module", "dir", "cmp", "patch", "port", "mask", "packages", "pp", "part", "quote", "zip", "lib", "path", "kid", "family", "imp", "p"], "uri": ["http", "ip", "ui", "link", " URI", "address", "iri", "folder", "system", "location", "directory", "term", "base", "io", "handler", "uid", "api", "pi", "connection", "ur", "domain", "uu", "cli", "URI", "ri", "proxy", "resource", "file", "local", "profile", "library", "mi", "id", "reference", "util", "i", "source"], "resource2antlib": ["resource1agentib", "resource2boltib", "resourcetoantloc", "resource2agentLib", "resource2boltlib", "resource2AntLib", "resource2antlibrary", "resource2etLib", "resource1agentlib", "resource2Antlibrary", "resource2ANTconfig", "resource2ntLib", "resourcetoantconfig", "resource2etli", "resource2antib", "resourcetoantlib", "resource2boltloc", "resource2ntib", "resource1agentLib", "resource2etlib", "resource2antli", "resource2Antli", "resource1antLib", "resource1agentlibrary", "resource2antsconfig", "resource1antlib", "resource2agentlib", "resource2agentib", "resource1antib", "resource1antlibrary", "resource2antconfig", "resourcetoANTib", "resource2ANTlib", "resource2etlibrary", "resource2antsloc", "resource2Antlib", "resource2antloc", "resource2ANTib", "resourcetoANTloc", "resourcetoANTlib", "resource2ntlib", "resourcetoantib", "resource2ntlibrary", "resource2Antib", "resource2agentlibrary", "resource2boltconfig", "resource2antslib", "resource2antLib", "resourcetoANTconfig", "resource2ntli", "resource2antsib", "resource2ANTloc"]}}
{"id1": "21824901", "id2": "17792212", "code1": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"copyExternalResource": ["downloadExternalresource", "copyexternalResource", "downloadexternalResources", "downloadexternalReference", "copyInternalResources", "copyExternalReference", "copyexternalReference", "downloadExternalResource", "copyOptionalResource", "downloadexternalresource", "copyInternalReference", "copyOptionalresource", "downloadExternalReference", "downloadexternalResource", "copyInternalresource", "downloadExternalResources", "copyexternalResources", "copyExternalresource", "copyInternalResource", "copyExternalResources", "copyOptionalResources", "copyexternalresource", "copyOptionalReference"], "sourceFile": ["destLine", " sourcePage", " sourceDir", "destPath", "sourcePath", "srcFile", "ourceFilename", " sourceChain", "ourceFile", "ourceDir", "srcPage", " sourcePath", "sourcePage", " sourceLine", "sourceDir", "SourceFilename", "sourceFilename", "SourceChain", "srcLine", "sourceChain", "srcPath", "SourceDir", " sourceFilename", "destPage", "sourceLine", "ourceChain", "SourceFile"], "destFile": ["srcPlace", " destFiles", "srcfile", "locFile", "DestFile", " destPlace", "destPath", "locPath", "destfile", "critFilename", "DestFilename", "srcFile", "destPlace", " destPath", "Destfile", "srcFILE", "critDir", "srcDir", " destFilename", "DestFiles", "DestDir", "destDir", "srcPath", " destFILE", "optPlace", " destfile", "optFiles", "srcFiles", "critfile", "destFILE", "destFiles", "optFile", "destFilename", " destDir", "critFile", "locFILE", "locDir", "optDir"], "source": ["cache", "in", "back", "less", "use", "iter", "create", "cause", "inner", "SOURCE", "body", "address", "session", "target", "input", "store", "index", "reader", "image", "base", "load", "table", "sequence", "style", "subject", "connection", "sql", "src", "scope", "sample", "init", "score", "none", "force", "ource", "origin", "copy", "owner", "Source", "check", "proxy", "ce", "search", "iterator", "resource", "stream", "from", "service", "series", "se", "start", "result", "local", "query", "update", "match", "console", "component", "pose", "shell", "before", "channel", "archive", "ie", "parent"], "destination": ["notinated", "potation", "compination", "destation", "descinated", "notinator", "compinated", "combuation", "descinator", "Destination", "Destation", "destociation", "combinated", "compation", "descination", "destinate", "notinate", "combination", "Destinated", "destinator", "potinator", "potination", " destation", "combinator", "destuation", "destinated", " destuation", "catinator", "notination", " destociation", " destinator", "catination", "Destinator", "compinator", "Destuation", "descinate", "potociation", "catinated", "Destociation", " destinated", "catinate"]}}
{"id1": "21224967", "id2": "4921631", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 1, "substitutes": {"crear": [" necessado", " Creas", " Crear", " executar", " Creada", " necessada", "creada", "creado", " Creado", " executado", " necessar", " executas", "creas", " necessas", " executada"], "result": ["su", "report", "continue", "command", "tr", "duration", "num", "Result", "test", "unique", "res", "user", "date", "total", "process", "status", "sequence", "die", "card", "feature", "currency", "number", "df", "row", "ret", "count", "valid", "rc", "br", "comment", "draw", "true", "results", "ULT", "search", "complete", "value", "integer", "successfully", "diff", "power", "successful", "success", "relation", "order", "event", "run", "r", "conf", "message", "length"], "sql": ["csv", "condition", "ws", "xml", "qs", "pel", "q", "spr", "string", "expression", "ql", "status", "seed", "template", "description", "fn", "cmd", "mail", "dl", "sv", "sel", "nl", "sp", "ls", "serv", "sf", "sq", "url", "s", "sd", "query", "SQL", "params", "quote", "sol", "sb", "db", "join", "select"], "connection": ["to", "link", "conn", "command", "condition", "socket", "pointer", "network", "session", "server", "function", "reset", "computer", " Connection", "statement", "connected", "system", "location", "database", "directory", "response", "Connection", "c", "document", "open", "handler", "writer", "platform", "collection", "client", "engine", "number", "we", "context", "nc", "application", "con", "position", "port", "connect", "ion", "resource", "driver", "library", "created", "creator", "close", "query", "relation", "reference", "pool", "channel", "communication", "character", "current"], "ps": ["ping", "pb", "pr", "pt", "pg", "cp", "pd", "proc", "pe", "pa", "res", "statement", "PS", "rs", "jp", "fps", "fp", "eps", "pi", "sp", "cs", "pas", "ptr", "pers", "mp", "s", "aps", "ts", "gres", "ips", "pp", "Ps", "prep", "po", "pps", "bs", "pse", "ds", "p"]}}
{"id1": "16466743", "id2": "3745402", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"getmd5": ["getmd2", "getsha6", "getmd6", " getMD5", "getMD6", "getmd4", " getmd4", "getMD2", "getsha2", "getMD4", " getmd2", " getMD6", " getmd6", " getMD4", " getMD2", "getMD5", "getsha5", "getsha4"], "password": ["Password", "security", "entry", "shadow", "code", "secret", "data", "key", "address", "hash", "user", "pass", "string", "padding", "database", "ew", "username", "token", "sword", "name", "login", "prefix", "description", "attribute", "email", "wd", "phrase", "auth", "word", "w", "value", "pattern", "wordpress", " Password", "hello", "message", "path", "text", "p"], "pwHash": ["pWhash", "pwdHas", "pwhash", "spwdHash", " pwdSum", "pWHash", "pwdSum", " pwdHas", "pwshash", "pwSum", "pwsHas", "spwdSum", "pswHas", "spwhash", "spwdhash", "pwdHash", "pwsHash", "pwtHas", "pswSum", "pwthash", "spwdHas", " pwSum", " pwhash", "pwtSum", "spwSum", "pswhash", "pwsSum", "pwHas", " pwHas", "spwHas", "spwHash", "pWSum", " pwdHash", "pwdhash", " pwdhash", "pwtHash", "pWHas", "pswHash"], "md": ["d", "m", "man", "mg", "ad", "cd", "material", "ld", " Md", "bd", "pd", "hd", "grad", " mm", "MD", "doc", "mm", "det", "desc", "od", "ind", "pm", "msg", "exec", "cond", " mc", "mod", "cmd", "dd", "red", "der", "df", "ng", "mail", "mem", " dd", "ms", "nd", "dig", "dir", "cmp", "td", "mc", "mt", "mn", "metadata", "add", "rm", "mp", "mk", "sm", "del", "sd", "def", "mo", "dm", "di", "mb", " mo", "ds"], "b": ["d", "m", "v", "batch", "bh", "l", "bis", "bas", "obj", "B", "y", "bu", "bar", "bp", "rb", "f", "ab", "bi", "abs", "ba", "bf", "br", "buff", "reb", "cb", "ib", "bytes", "fb", "be", "w", "gb", "bb", "bc", "eb", "binary", "g", "nb", "db", "mb", "sb", "bs", "a", "ob", "p"], "i": ["m", "v", "ip", "ci", "ui", "n", "multi", "yi", "in", "it", "ji", "l", "ei", "gi", "span", "I", "q", "phi", "us", "index", "ind", "im", "\u0438", "y", "oi", "ki", "ini", "li", "is", "io", "gu", "iu", "ii", "ski", "xi", "json", "bi", "u", "pi", "j", "ms", "init", "o", "iter", "cli", "ij", "ri", "next", "ai", "sim", "ti", "mi", "ix", "hi", "id", "di", "my", "a", "ic", "x", "si", "ie", "qi", "p"]}}
{"id1": "8132219", "id2": "17296916", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", "copyfile", "copyFiles", "copyStream", " CopyFiles", " copyStream", "CopyStream", " CopyStream", "Copyfile", "CopyFile", " CopyFile", " Copyfile", " copyfile"], "inFile": ["dinFile", "ninName", " inEmail", "ninFilename", "inputFile", "innRow", "ninFile", "outFilename", "dinEmail", "dinPath", "outName", "inPath", " inRow", "innEmail", "innFile", "dinRow", "inputTemplate", "inputName", "inEmail", "inTemplate", "inputFilename", "inRow", "innPath", "inFilename", "outTemplate", "ninTemplate", "inName", " inPath"], "outFile": ["inTable", "ouFILE", "outFormat", "outfile", "ouFilename", "destFile", "ouFile", "outTable", "outputTable", " outFormat", " outFILE", "outputFilename", "outFilename", "destFormat", "inFILE", "ouTable", "outputFILE", "outputfile", "outputFormat", " outfile", "destFILE", "outFILE", "inFilename", "outputFile", "destfile"], "in": ["inf", "o", "IN", "inc", "it", "inner", "cin", "ins", "el", "input", "ind", "rin", "ir", "bin", "up", "In", "ini", "is", "ze", "isin", "init", "old", "info", "irm", "ai", "gin", "from", "s", " input", "id", "en", "ain", "inn", "sin", "on", "ic", "i", "din", " din", "source"], "out": ["o", "b", "n", "to", "v", "it", "ex", "res", "OUT", "at", "one", "c", "os", "name", "Out", "ou", "io", "aos", "client", "by", "co", "e", "ot", "w", "t", "file", "gt", "can", "all", "en", "g", "output", "outs", "net", "ne", "p"], "inChannel": ["cinBlock", "cinComponent", "inHandler", " inConnection", " inchannel", "inComponent", "newCategory", "insideHandler", "vinCategory", "inPanel", "inchannel", "cinHandler", "outBlock", "inBlock", "inCase", "sinChannel", "insideChannel", "inConnection", "innerChannel", "inStream", "inChan", "ginPanel", "isinCategory", " inHandler", "newChannel", "outChan", "inCategory", "ginCase", "vinPanel", "sinStream", "outConnection", "innCase", "outchannel", "inButton", "cinChannel", "sinBlock", "vinCase", " inChan", "sinCategory", "innerchannel", "inSlot", "newPanel", "newCase", "innSlot", "sinSlot", "outColumn", "insideComponent", "innerConnection", "sinCase", "cinColumn", "inColumn", "isinCase", "cinStream", "isinSlot", " inComponent", "innerChan", "vinChannel", "outStream", "sinColumn", " inButton", "ginChannel", "innChannel", "cinButton", "ginCategory", "isinChannel", "insideButton", "innCategory"], "outChannel": [" outCh", "oChan", " outPassword", "exBlock", "inchannel", "outPassword", "outBlock", "exChan", " outConnection", "outChain", "inStream", "inChan", "oChannel", "outCh", "outChan", " outClient", "outConnection", "exChannel", " outChain", "outchannel", "OutConnection", "nChannel", " outchannel", "outputChannel", " outBlock", "OutChan", "outputConnection", "inPassword", " outChan", "nStream", "outClient", "OutChannel", "OutCh", "inClient", "exChain", "outStream", "outputChan", "outputCh", "oClient", "oPassword", "nchannel", "nChan", " outStream"]}}
{"id1": "13333160", "id2": "15645004", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"run": ["execute", "test", "proc", "pass", "process", "exec", "flow", "render", "scan", "running", "unit", "runner", "wal", "work", "go", "Run", "ran", "eval", "start", "read", "query", "view", "app", "apply", "action"], "xmlIn": ["domIn", "fileIns", "htmlIns", "htmlIn", "xOut", "filein", "xIns", "xInput", "xIn", "xmlin", "jsonOut", "xmlIns", "htmlin", "fileIn", "xmlInput", " xmlIns", "jsonIns", " xmlin", "jsonIn", "xmlOut", "jsonInput", "domInput", "domOut", "domIns"], "out": ["d", "o", "report", "to", "raw", "v", "null", "in", "ex", "ws", "err", "obj", "res", "OUT", "one", "os", "up", "Out", "io", "ou", "aos", "client", "end", "off", "stream", "w", "t", "file", "s", "log", "sw", "set", "OU", "output", "outs", "pool", "i", "p", "nt"], "dom": ["d", "browser", "m", "tree", "web", "md", "cd", "html", "node", "xml", "data", "iam", "el", "doc", "window", "parser", "dr", "atom", "process", "yang", "os", "document", "comm", "df", "img", "dl", "j", "utils", "dem", "domain", "div", "dn", "mat", "Dom", "om", "DOM", "result", "model", "fr", "dm", "mom", "host", "db", "page", "frame", "p"], "f": ["inf", "v", "d", "l", "it", "full", "tf", "fab", "xf", "F", "c", "fo", "ff", "uf", "cf", "ft", "rf", "fi", "df", "fc", "conv", "fg", "bf", "fm", "fort", "fac", "fb", "forge", "sf", "af", "w", "Factory", "fd", "fs", "lf", "fl", "foreign", "fr", "g", "conf", "of", "fx", "fy"], "b": ["d", "pb", "v", "m", "bh", "l", "Builder", "bd", "bt", "base", "c", "B", "builder", "rb", "ab", "bi", "j", "bf", "bg", "e", "fb", "be", "gb", "bb", "bc", "eb", "g", "sb", "nb", "r", "mb", "bs", "db", "a", "p"], "root": ["browser", "m", " rooted", "null", "html", "data", "bank", "roots", "ro", "bot", "loc", "used", "area", "type", "nav", "top", "ree", "head", "DOM", "wrap", "get", "ok", "right", "gr", "raw", "rt", "h", "rap", "base", "os", "row", "first", "module", "mount", "element", "result", "start", "object", "ax", "rank", "p", "node", "xml", "doc", "available", "document", "author", "valid", "owner", "box", "ow", "ram", "ain", "host", "r", "parent", "tree", "create", "chain", "av", "res", "group", "table", "rown", "roid", "feature", "container", "ul", "scope", " Root", "div", "oot", "primary", "mr", "Root", "cover", "instance"], "att": ["acc", "apt", "aff", "ac", "pt", "prop", "ap", "tr", "dat", "ATT", "rt", "data", "nat", "av", "attr", "at", " attribute", "aux", "attribute", "ct", "adj", "ar", "pet", "atts", " matt", " dat", "info", "attach", "alt", "aj", "aria", " ut", "feat", "t", "mat", "ts", "Att", "rib", "tt", "ach", "set", "def", "addr", "tmp", "txt", "nt"], "menu": ["m", "tree", "wiki", "cache", "ui", "list", "summary", "command", "consumer", "theme", "usage", "settings", "header", "node", "chain", "site", "us", "options", "window", "mu", "button", "up", "sequence", "li", "admin", "item", "mouse", "nav", "queue", "ul", "row", "um", "module", "title", "pie", "Menu", "manager", "block", "category", "next", " menus", "movie", "omo", "library", "ctrl", "config", "cm", "men", "option", "page", " Menu", "family", "parent"], "id": ["link", "Id", "data", "key", "pid", "target", "status", "ids", "name", "description", "type", "icon", "uid", "class", "ref", "scope", "init", "title", "version", "method", "url", "value", "file", "mid", "tag", "ID", "uri", "source"], "zout": ["czclient", "zipup", "ziposs", "Zout", "zipOUT", "zouter", "zeross", "zOut", "gzin", "gznet", "zerOUT", " zserv", "ozOUT", "zaos", "zipin", "Zaos", "zipOut", "zpoint", "ZOut", "znet", "zot", "ozouter", "ozot", " zin", " zclient", "zerouter", "ozouts", "ozOut", "zin", "Zin", "zerot", "enzpoint", "zup", "izout", "zouts", "izserv", "zipaos", "ezouts", "enzout", "zserv", "zipnet", "zipclient", "zor", "ozup", "zipserv", "zoss", "zclient", "zipor", "izaos", "zippoint", " zor", "czout", "czup", " zpoint", " zouts", "ezout", " znet", "gzor", " zaos", "enzOut", "ozoss", "zipot", "ozout", "ezpoint", "zOUT", " zup", "zipouter", "zipout", "gzout", "zerout", "czOut", "izOut", "zerup", " zOut", "ozpoint", "zerOut"], "content": ["cache", "code", "html", "header", "data", "full", "string", "c", "layout", "section", "file", "article", "page", "current", "source", "raw", "time", "address", "inner", "ext", "template", "load", "sequence", "description", "cmd", "title", "position", "htm", "value", "result", "read", "config", "object", "good", "default", "output", "pool", "x", "command", "xml", "body", "padding", "image", "document", "core", "media", "cont", "context", "lay", "request", "cur", "now", "search", "format", "ontent", "reason", "host", "message", "tree", "condition", "create", "expression", "accept", "wrapper", "Content", "json", "text", "script", "comment", "block", "size", "ce", "metadata", "query", "path", "txt"], "signal": ["seil", "scale", "seAL", "several", "SIGNature", " signale", " signil", "seale", " signAL", "SIGNale", "signil", "scature", "severaling", "scal", "SIGNaling", "Signaling", "severAL", "severale", "severil", " signaling", "severature", "signature", "signAL", "seal", "scaling", "SIGNal", "Signature", "signaling", "signale", "Signal", "sealing", " signature", "seature"], "n": ["d", "m", "o", "zero", "pos", "l", "np", "num", "nan", "node", "h", "no", "index", "natural", "c", "len", "nw", "number", "un", "ng", "count", "j", "nc", "nl", "N", "nn", "ln", "sn", "nr", "dn", "nv", "mn", "nu", "unn", "t", "nm", "nor", "norm", "ni", "tn", "an", "en", "g", "nb", "on", "i", "ns", "cn", "ne", "z", "p", "nt"], "entry": ["insert", "link", "slot", "record", "data", "RY", "instance", "pixel", "system", "quick", "table", "line", "row", "cell", "sheet", "join", "connection", "cue", "e", "comment", "element", "ace", "enter", "next", "add", "escape", "se", "result", "log", "ent", "office", "member", "query", "zip", "tmp", "Entry", "page", "ie", "ry", "nt"], "pout": ["ppond", "pto", "phpsys", "ppot", "ppent", "wpout", "phpout", "ptout", "pou", "phpnew", "pin", " pin", "pond", "ptouter", "jpconn", "psys", " pond", "phpot", "ppto", "Pin", "pinner", "zconn", "phpOut", " pouter", " pinner", "pnew", "phpouter", "zouter", "jpinner", "ppinner", "wpto", "pOut", "Pout", "jpout", "pconn", " psys", "wpond", "POut", " pent", "zinner", " pou", "pouter", "wpent", "ppout", "phpinner", "pent", "pot", "ptOut", "ptnew", "jpou", " pto", " pnew", "zou", " pOut", "zot", " pconn", "phpin", "ppouter", "Psys"]}}
{"id1": "8266672", "id2": "2511579", "code1": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 0, "substitutes": {"updatePicInfo": ["updatePictureObj", " updatePictureInfo", " updatePictureObj", "updateImageInfo", "updatePanObj", "updatePanData", "updatePictureInf", "updatePictureInfo", "updatePicInf", "updateImageData", "updateImageObj", "updatePicData", "updatePictureData", "updateImageInf", " updatePicObj", " updatePicInf", "updatePanInfo", " updatePictureInf", " updatePictureData", " updatePicData", "updatePicObj", "updatePanInf"], "conn": ["n", "ca", "apt", "priv", "err", "pg", "gate", "js", "cp", "pkg", "yn", "ann", "resp", "wp", "obj", "rel", "ctx", "Conn", "subject", "req", "exec", "c", "dc", "admin", "jp", "open", "cert", "cmd", "ct", "client", "comm", "adj", "cell", "enc", "org", "connection", "sys", "nc", "ch", "co", "iw", "act", "init", "cb", "cmp", "con", "info", "stat", "pas", "cur", "irm", "win", "connect", "coll", "handle", "gc", "config", "close", "query", "conf", "db", "addr", "ait", "on", "pool", "fail", "cc", "ns", "cn", "conv", "wn", "nt"], "nr": ["n", "NR", "wire", "np", "blocks", "num", "rn", "nir", "inner", "rel", "root", "wr", "nar", "ner", "inv", "rar", "attr", "adr", "store", "req", "kr", "rb", "notice", "nit", "nw", "occup", "number", "ng", "sys", "org", "conv", "src", "nn", "info", "iter", "sn", "nv", "ln", "next", "out", "nu", "rid", "reviewed", "nick", "nie", "range", "nor", "nm", "mr", "ni", "tn", "radius", "hr", "stock", "nb", "r", "kid", "Num", "gr", "cor", "ns", "ne"], "lock": ["link", "l", "ld", "pin", "num", "locks", "rl", "key", "k", "locking", "Lock", "prime", "th", "limit", "ock", "type", "or", "row", "fp", "locked", "sp", "LOCK", "box", "sync", "ln", "block", "size", "le", "ite", "handle", "wl", "nil", "length", "id", "kl", " unlock", "zip", "pen", "ck", "ne", "p"], "picInfo": ["pngINFO", "icINFO", "pictInfo", "icTier", " picFi", "pngAuth", "PicINFO", "icData", "pickType", "pInfo", " picINFO", "specExt", "picData", "featAuth", "pInf", "picINFO", "pinInf", "pixelINFO", "piDiff", "pickInf", "camInfo", "picAbout", " picType", "featINFO", "statFi", "PicInf", "picinfo", "pickInfo", "picDef", "pictinfo", "picExt", "styleINFO", "pixelInfo", "icType", "picObj", "icEx", "synInfo", "featInfo", "pinObj", " picDef", "picFi", "picInf", "pINFO", "picEx", " picExt", "synType", "PicDef", "pixelFi", "pinINFO", "pnginfo", "icInfo", "icDiff", "pictINFO", "featinfo", "camEx", "pinDiff", " picInf", "camINFO", "statINFO", "pinAbout", "pictAuth", "piExt", "picAuth", "icObj", "pinEx", "PicType", "camObj", "PicInfo", "picTier", "picType", "piAbout", "specInfo", "styleInfo", "styleInf", "piInfo", "pDef", "pinDef", "pngInfo", "pinInfo", " picDiff", "synINFO", "statInfo", "picDiff", "statInf", "pickINFO", " picTier", "pinTier", "synData", "specINFO", "icAbout", "icInf", "piInf", "icDef", "specDiff", "piINFO", " picData", "pixelInf", "styleDef"], "sql": ["plan", "csv", "l", "socket", "sil", "js", "html", "ll", "services", "xml", "soft", "body", "test", "pel", "spr", "rel", "inv", "joined", "statement", "software", "string", "sal", "seed", "ql", "expression", "msg", "eps", "template", "owl", "links", "login", "ship", "cloth", "sleep", "rpm", "prefix", "description", "cmd", "json", "mail", "il", " SQL", "dl", "sys", "sv", "nl", "ms", "lex", "ssl", "blank", "wal", "sp", "ln", "sn", " msg", "url", "format", "series", "ips", "log", "sl", "query", "SQL", "lua", "params", "spec", "sol", "scl", "expr", "shell", "util", "ns", "sq"], "pstmt": ["postgr", "httphttmat", "opStmt", "pingstructmt", "pputmt", "httpstlem", "pthm", "pstatemt", "pstmed", "httphttmt", "peputapter", "prestr", "pputst", "psymt", " pstatager", "psttar", " pstatmt", "pftom", "pstgr", "pstlet", "psthm", "httpstmt", "pondmr", "opstmt", "ptrylet", "prstem", "pstatml", "pstmat", "ptrymap", "pstapter", "psptim", "psettmat", "pstamt", "pstcl", "peputem", "pstartth", "psetgr", "httpstatemt", "psterager", " pstmag", "opstmm", " pstatmem", "pSttr", "pstatpt", " psttx", "vpputmb", "pstatdt", "pStmt", "pstrql", "psthmu", "pstructmt", "pondmt", "pstatil", "pstatmk", "Pstql", "pconstgr", "pstalmt", "pstr", "pputtar", "pstatql", " pstom", "prrestem", "pthth", "pftpt", "pstMT", " pstatmat", "pspml", "pstartmt", "pstatmn", "peputtar", " pstgr", "pSTmt", "vpstgr", "psycl", "pthcl", "pstkl", "pstarttar", "pputem", "pstatmr", "Pistm", "pstatmat", "pingstm", "pstmk", "pstom", "pStem", "psthmed", "pstmr", "pstatmag", "pstyml", "prestmk", "httpstmap", "phttom", "pistm", "Pstatdt", "pstth", "psettmag", "pspmt", "prestmt", "pistmed", "prrestirm", "pstartst", "pthtr", "postirm", "pputmr", "pstrmt", "pstlt", "prstirm", "pstatem", "pStmm", "pStr", "prostmt", "pstatager", "pconstm", "Pistmt", "pestem", "pstructbolt", "pstmn", "phttpt", "pstymt", "pstartem", "psettmt", "fpstalmem", "pestapter", "pconstdt", "pSTlem", "pstmu", "phttmn", "pstructmr", " pstmm", "pstatMT", "Pistmu", "pstatmu", "pputmb", "pstatgr", "Pistmed", "pstartmm", "Pstmu", "pthmm", "pstirm", " pstmk", "pstml", "psttim", "pstalr", "pconstmm", "psettmem", "Pstmed", "psetager", "pSttx", "pStapter", "pstemb", "vpstirm", "httpstlt", "pstamm", "pthtx", "psthmat", "pstartcl", "prstmt", "pstamk", "prostartmt", "pspm", "pingstructbolt", "pconstil", "pstatom", " pstatmk", "phttlt", "pstatmed", "Pstatql", "fpsttx", "psthlt", "pstpt", "fpstalr", "pStMT", "pthr", "wpstytim", "pstatelet", "pstatelem", "prostartmb", "prestirm", "pSTr", "prstm", "pstatmt", " pthcl", " psttr", " pstager", "pstalMT", "pstolt", "psetmk", "pstlem", "vpputgr", "opstMT", "fpstmt", " pstem", " pstr", "wpstyml", "pstatirm", "pSTlet", "pconstmb", "presttx", "pstatmem", "pstrm", " pstmem", "phttmat", "fpstr", "prestm", "pthmt", " pstatpt", "pconstmk", "Pstm", "wpstym", "fpstaltx", "pstmm", "pstymb", "pondql", "pputirm", "pSTtx", "pstallt", "pstmem", "psymm", "psyth", "Pstil", "postmb", "prostartemb", "httpstmat", "pputgr", "pistmu", "psetil", " pstcl", "pingstbolt", " pstmn", "prrestmt", "pstatmm", "prestolt", "pputbolt", "pstalmem", "peputmt", "pconstirm", "prostartst", "vpputirm", "wpstymt", "Pstdt", "pSTmem", "pconstolt", "Pstatm", " pstpt", "httphttkl", "pscirm", "httpstkl", "pstattim", "prestmm", "pondm", "wpstml", "pstmap", "pstatm", "pstdt", "httpstatemap", "ptrymt", "pstytim", "pthem", "pstaolt", "pstartmb", "pscm", "pstyst", "pStmem", "wpstm", "psetm", "prostst", "wpsttim", "pstaltx", "pftmt", "pstbolt", "psetdt", "vpstmt", "pstmag", "pingstructm", "pstructm", "wpstmt", "pstql", "prestem", "psttr", "pstrmr", "pstatemap", "pesttar", "Pstmt", "pstem", " pthth", " pstattr", "prrestm", "pstartemb", "httpstatelet", "vpputmt", "pSTmap", "opStmm", " pstatm", "pstatr", "opStMT", "prostmb", "fpstmem", "pingstmt", " pstatmn", "pstyemb", " pstatom", "psthkl", "postmt", "pStm", "pstager", "pstatbolt", "Pstatil", "pscmt", " pthmm", "Pstatmt", "pestmt", "psthmt", "pputm", "vpstmb", "pstst", "pftmn", "pstil", "fpstalmt", " pstattx", "pstmb", "prostemb", "pputapter", " pstth", "pstalmm", "psetmt", "pSTmag", "ptrylem", " pstmat", "pscem", " pstatem", " pstatgr", "pstm", "pingstmr", "phttkl", "Pstatmr", "pstermt", "pSTmat", " pstatmag", "psttx", "pSttar", "phttmt", "pstattx", "pstermk", "Pstmr", " pstm", "pputemb", "pistmt", " pstatr", "httpstlet", " pthmt", "pstym", "pstalkl", "httphttlt", "pstalmat", "pstergr", "pconstmt", "pstattr", "pingstructmr", "pstartapter", "httpstatelem"]}}
{"id1": "2461169", "id2": "771802", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFile2String", "decodeString2Files", "decodeFile2Files", "decodeFileFileFile", "decodeFileAsfile", "decodeFileToString", "decodeStringToFile", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToFiles", "decodeFileAsFile", "decodeFileFilefile", "decodeFile2file", "decodeString2file", "decodeStringTofile", "decodeFileAsString", "decodeString2String", "decodeFile2File", "decodeFileAsFiles", "decodeStringToString", "decodeFileToFiles", "decodeString2File"], "infile": ["inputname", "outname", "outfilename", "isinname", "isinfile", "inputfolder", "Infilename", "outfolder", "outbase", "inputFile", "Inbase", "isinFile", "inbase", "infolder", "fromFile", "Infile", "InFile", "inputfile", "inname", "frombase", "isinfolder", "inFile", "fromfile", "outFile", "infilename", "fromfilename"], "outfile": ["indir", "Outdir", "outname", "outfilename", "Outfile", "Outfilename", "toFile", "OutFile", "otname", "otfile", "otFILE", "tofilename", " outFILE", "inFILE", "outdir", "todir", "inname", "otFile", "tofile", "inFile", " outname", "outFile", "outFILE", "infilename", " outFile"], "in": ["inf", "conn", "oin", "IN", "it", "inc", "pin", "al", "inner", "cin", "ins", "input", "re", "ind", "rin", "bin", "im", "up", "In", "inside", "is", "ini", "form", "by", "or", "ar", "amin", "isin", "init", "con", "info", "iter", "nin", "t", "gin", "from", "id", "en", "ain", "get", "inn", "on", "per", "din", "i", " din", "source"], "out": ["o", "b", "n", "to", "print", "null", "ex", "oss", "it", "inner", "flush", "res", "OUT", "at", "os", "io", "ou", "Out", "aos", "writer", "fn", "end", "outer", "sys", "co", "write", "ot", "con", "ion", "opt", "t", "file", "auto", "gt", "can", "en", "g", "OU", "output", "outs", "on", "net", "cn", "ne", "nt"], "buffer": ["batch", "cache", "print", "command", "Buffer", "header", "black", "memory", "paste", "window", "padding", "total", "available", "template", "base", "bone", "shape", "button", "table", "sequence", "document", "bar", "attribute", "password", "pad", "buf", "number", "row", "mem", "phrase", "note", "sample", "buff", "append", "comment", "stack", "info", "column", "block", "library", "variable", "binary", "initial", "view", "message", "temp", "display", "history", "frame", "character"], "read": ["n", "need", "give", " Read", "raw", "print", "shift", "push", "skip", "input", "index", "reading", "reader", "ind", "req", "seek", "load", "hold", "open", "Read", "end", "count", "send", "first", "write", "through", "iter", "size", "check", "wait", "connect", "add", "stream", "allow", "range", "start", "READ", "close", "query", "set", "find", "get", "ok", "run", "i", "before", "each", "length", "ready", "reads", "text", "select", "readable", "len"], "success": ["submit", "sufficient", "summary", "continue", "Success", "condition", "second", "cess", "city", " succ", "status", " successful", "ccess", "response", "accept", "democracy", "error", "town", "unity", "danger", "please", "exist", "commit", "snap", "valid", "first", "scope", "safe", "surv", " failure", "ceed", "setup", " okay", " successes", "primary", "same", "support", "complete", "value", "crit", "successfully", "result", " succeeds", "successful", "release", "ratulations", "good", "photo", "ok", "fail", " succeed", "done", "positive", "growth"]}}
